fset );              // Offset (from header start) to data
    _ULONG( DataDisplacement );        // Displacement of these data bytes
    UCHAR SetupCount;                  // Count of setup words
    UCHAR Buffer[1];
    //USHORT Setup[];                  // Setup words (# = SetupWordCount)
    //USHORT ByteCount;                // Count of data bytes
    //UCHAR Pad1[];                    // Pad to LONG
    //UCHAR Parameters[];              // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                    // Pad to SHORT or LONG
    //UCHAR Data[];                    // Data bytes (# = DataCount)
} RESP_NT_TRANSACTION;
typedef RESP_NT_TRANSACTION SMB_UNALIGNED *PRESP_NT_TRANSACTION;

#endif // def INCLUDE_SMB_TRANSACTION

#ifdef INCLUDE_SMB_TREE

//
// Tree Connect SMB, see #1, page 6
// Function is SrvSmbTreeConnect()
// SMB_COM_TREE_CONNECT 0x70
//

typedef struct _REQ_TREE_CONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR Path[];                     //  Server name and share name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR Password[];                 //  Password
    //UCHAR BufferFormat3;              //  0x04 -- ASCII
    //UCHAR Service[];                  //  Service name
} REQ_TREE_CONNECT;
typedef REQ_TREE_CONNECT SMB_UNALIGNED *PREQ_TREE_CONNECT;

typedef struct _RESP_TREE_CONNECT {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxBufferSize );           // Max size message the server handles
    _USHORT( Tid );                     // Tree ID
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TREE_CONNECT;
typedef RESP_TREE_CONNECT SMB_UNALIGNED *PRESP_TREE_CONNECT;

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_TREE

//
// Tree Connect and X SMB, see #2, page 88
// Function is SrvSmbTreeConnectAndX()
// SMB_COM_TREE_CONNECT_ANDX 0x75
//
// TREE_CONNECT_ANDX flags

#define TREE_CONNECT_ANDX_DISCONNECT_TID    (0x1)
// #define TREE_CONNECT_ANDX_W95            (0x2)  -- W95 sets this flag.  Don't know why.

typedef struct _REQ_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 4
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Flags );                   // Additional information
                                        //  bit 0 set = disconnect Tid
                                        //  bit 7 set = extended response
    _USHORT( PasswordLength );          // Length of Password[]
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Password[];                 //  Password
    //UCHAR Path[];                     //  Server name and share name
    //UCHAR Service[];                  //  Service name
} REQ_TREE_CONNECT_ANDX;
typedef REQ_TREE_CONNECT_ANDX SMB_UNALIGNED *PREQ_TREE_CONNECT_ANDX;

typedef struct _RESP_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Service type connected to
} RESP_TREE_CONNECT_ANDX;
typedef RESP_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_TREE_CONNECT_ANDX;

//
// The response for clients that are LAN Manager 2.1 or better.
//

typedef struct _RESP_21_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 3
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( OptionalSupport );         // Optional support bits
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Service[];                  //   Service type connected to
    //UCHAR NativeFileSystem[];         //   Native file system for this tree
} RESP_21_TREE_CONNECT_ANDX;
typedef RESP_21_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_21_TREE_CONNECT_ANDX;

//
// Optional Support bit definitions
//
#define SMB_SUPPORT_SEARCH_BITS         0x0001
#define SMB_SHARE_IS_IN_DFS             0x0002

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_TREE

//
// Tree Disconnect SMB, see #1 page 7
// Function is SrvSmbTreeDisconnect()
// SMB_COM_TREE_DISCONNECT 0x71
//

typedef struct _REQ_TREE_DISCONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_TREE_DISCONNECT;
typedef REQ_TREE_DISCONNECT SMB_UNALIGNED *PREQ_TREE_DISCONNECT;

typedef struct _RESP_TREE_DISCONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TREE_DISCONNECT;
typedef RESP_TREE_DISCONNECT SMB_UNALIGNED *PRESP_TREE_DISCONNECT;

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_LOCK

//
// Unlock Byte Range SMB, see #1 page 20
// Function is SrvSmbUnlockByteRange()
// SMB_COM_UNLOCK_BYTE_RANGE 0x0D
//

typedef struct _REQ_UNLOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( Count );                    // Count of bytes to unlock
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_UNLOCK_BYTE_RANGE;
typedef REQ_UNLOCK_BYTE_RANGE SMB_UNALIGNED *PREQ_UNLOCK_BYTE_RANGE;

typedef struct _RESP_UNLOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_UNLOCK_BYTE_RANGE;
typedef RESP_UNLOCK_BYTE_RANGE SMB_UNALIGNED *PRESP_UNLOCK_BYTE_RANGE;

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write SMB, see #1 page 12
// Write and Unlock SMB, see #2 page 92
// Function is SrvSmbWrite()
// SMB_COM_WRITE 0x0B
// SMB_COM_WRITE_AND_UNLOCK 0x14
//

//
// *** Warning: the following structure is defined the way it is to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _REQ_WRITE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to be written
    _ULONG( Offset );                   // Offset in file to begin write
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( ByteCount );               // Count of data bytes
    //UCHAR Buffer[1];                  // Buffer containing:
      UCHAR BufferFormat;               //  0x01 -- Data block
      _USHORT( DataLength );            //  Length of data
      ULONG Buffer[1];                  //  Data
} REQ_WRITE;
typedef REQ_WRITE SMB_UNALIGNED *PREQ_WRITE;

typedef struct _RESP_WRITE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Count of bytes actually written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE;
typedef RESP_WRITE SMB_UNALIGNED *PRESP_WRITE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write and Close SMB, see #2 page 90
// Function is SrvSmbWriteAndClose()
// SMB_COM_WRITE_AND_CLOSE 0x2C
//

//
// The Write and Close parameters can be 6 words long or 12 words long,
// depending on whether it's supposed to look like a Write SMB or a
// Write and X SMB.  So we define two different structures here.
//
// *** Warning: the following structures are defined the way they are to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _REQ_WRITE_AND_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 6
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to write
    _ULONG( Offset );                   // Offset in file of first byte to write
    _ULONG( LastWriteTimeInSeconds );   // Time of last write
    _USHORT( ByteCount );               // 1 (for pad) + value of Count
    UCHAR Pad;                          // To force to doubleword boundary
    ULONG Buffer[1];                    // Data
} REQ_WRITE_AND_CLOSE;
typedef REQ_WRITE_AND_CLOSE SMB_UNALIGNED *PREQ_WRITE_AND_CLOSE;

typedef struct _REQ_WRITE_AND_CLOSE_LONG {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to write
    _ULONG( Offset );                   // Offset in file of first byte to write
    _ULONG( LastWriteTimeInSeconds );   // Time of last write
    _ULONG( Reserved )[3];              // Reserved, must be 0
    _USHORT( ByteCount );               // 1 (for pad) + value of Count
    UCHAR Pad;                          // To force to doubleword boundary
    ULONG Buffer[1];                    // Data
} REQ_WRITE_AND_CLOSE_LONG;
typedef REQ_WRITE_AND_CLOSE_LONG SMB_UNALIGNED *PREQ_WRITE_AND_CLOSE_LONG;

typedef struct _RESP_WRITE_AND_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Count of bytes actually written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_AND_CLOSE;
typedef RESP_WRITE_AND_CLOSE SMB_UNALIGNED *PRESP_WRITE_AND_CLOSE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write and X SMB, see #2 page 94
// Function is SrvSmbWriteAndX()
// SMB_COM_WRITE_ANDX 0x2F
//

typedef struct _REQ_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  0 - write through
                                        //  1 - return Remaining
                                        //  2 - use WriteRawNamedPipe (n. pipes)
                                        //  3 - "this is the start of the msg"
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( Reserved );
    _USHORT( DataLength );              // Number of data bytes in buffer (>=0)
    _USHORT( DataOffset );              // Offset to data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_ANDX;
typedef REQ_WRITE_ANDX SMB_UNALIGNED *PREQ_WRITE_ANDX;

typedef struct _REQ_NT_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 14
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  0 - write through
                                        //  1 - return Remaining
                                        //  2 - use WriteRawNamedPipe (n. pipes)
                                        //  3 - "this is the start of the msg"
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( DataLengthHigh );
    _USHORT( DataLength );              // Number of data bytes in buffer (>=0)
    _USHORT( DataOffset );              // Offset to data bytes
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_NT_WRITE_ANDX;
typedef REQ_NT_WRITE_ANDX SMB_UNALIGNED *PREQ_NT_WRITE_ANDX;

typedef struct _RESP_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 6
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Count );                   // Number of bytes written
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    union {
        _ULONG( Reserved );
        _USHORT( CountHigh );           // if large write&x
    };
    _USHORT( ByteCount );               // Count of data bytes. Inaccurate if
                                        //    large writes
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_ANDX;
typedef RESP_WRITE_ANDX SMB_UNALIGNED *PRESP_WRITE_ANDX;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MPX

//
// Write Block Multiplexed SMB, see #2 page 97
// Function is SrvSmbWriteMpx()
// SMB_COM_WRITE_MPX 0x1E
// SMB_COM_WRITE_MPX_SECONDARY 0x1F
// SMB_COM_WRITE_MPX_COMPLETE 0x20
//

typedef struct _REQ_WRITE_MPX {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  bit 7 - IPX datagram mode
    union {
        struct {
            _USHORT( DataCompactionMode );
            _USHORT( Reserved2 );
        } ;
        _ULONG( Mask );                 // IPX datagram mode mask
    } ;
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_MPX;
typedef REQ_WRITE_MPX SMB_UNALIGNED *PREQ_WRITE_MPX;

typedef struct _RESP_WRITE_MPX_INTERIM {    // First response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Remaining );               // Bytes ramaining to be read (pipe/dev)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_MPX_INTERIM;
typedef RESP_WRITE_MPX_INTERIM SMB_UNALIGNED *PRESP_WRITE_MPX_INTERIM;

typedef struct _RESP_WRITE_MPX_DATAGRAM {    // Response to sequenced request
    UCHAR WordCount;                    // Count of parameter words = 2
    _ULONG( Mask );                     // OR of all masks received
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_MPX_DATAGRAM;
typedef RESP_WRITE_MPX_DATAGRAM SMB_UNALIGNED *PRESP_WRITE_MPX_DATAGRAM;

// Secondary request format, 0 to N of these.

typedef struct _REQ_WRITE_MPX_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words  = 8
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes to be sent
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Reserved );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_MPX_SECONDARY;
typedef REQ_WRITE_MPX_SECONDARY SMB_UNALIGNED *PREQ_WRITE_MPX_SECONDARY;

#endif // def INCLUDE_SMB_MPX

#ifndef INCLUDE_SMB_WRITE_COMPLETE
#ifdef INCLUDE_SMB_MPX
#define INCLUDE_SMB_WRITE_COMPLETE
#else
#ifdef INCLUDE_SMB_RAW
#define INCLUDE_SMB_WRITE_COMPLETE
#endif
#endif
#endif

#ifdef INCLUDE_SMB_WRITE_COMPLETE

//
// The following structure is used as the final response to both Write
// Block Multiplexed and Write Block Raw.
//

typedef struct _RESP_WRITE_COMPLETE {   // Final response; command is
                                        //  SMB_COM_WRITE_COMPLETE
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Total number of bytes written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_COMPLETE;
typedef RESP_WRITE_COMPLETE SMB_UNALIGNED *PRESP_WRITE_COMPLETE;

#endif // def INCLUDE_SMB_WRITE_COMPLETE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write Print File SMB, see #1 page 29
// Function is SrvSmbWritePrintFile()
// SMB_COM_WRITE_PRINT_FILE 0xC1
//

typedef struct _REQ_WRITE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Data
} REQ_WRITE_PRINT_FILE;
typedef REQ_WRITE_PRINT_FILE SMB_UNALIGNED *PREQ_WRITE_PRINT_FILE;

typedef struct _RESP_WRITE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_PRINT_FILE;
typedef RESP_WRITE_PRINT_FILE SMB_UNALIGNED *PRESP_WRITE_PRINT_FILE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_RAW

//
// Write Block Raw SMB, see #2 page 100
// Function is SrvSmbWriteRaw()
// SMB_COM_WRITE_RAW 0x1D
//

typedef struct _REQ_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  (see WriteAndX for #defines)
    _ULONG( Reserved2 );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_RAW;
typedef REQ_WRITE_RAW SMB_UNALIGNED *PREQ_WRITE_RAW;

typedef struct _REQ_NT_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words = 14
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  (see WriteAndX for #defines)
    _ULONG( Reserved2 );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_NT_WRITE_RAW;
typedef REQ_NT_WRITE_RAW SMB_UNALIGNED *PREQ_NT_WRITE_RAW;

typedef struct _RESP_WRITE_RAW_INTERIM {    // First response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_RAW_INTERIM;
typedef RESP_WRITE_RAW_INTERIM SMB_UNALIGNED *PRESP_WRITE_RAW_INTERIM;

typedef struct _RESP_WRITE_RAW_SECONDARY {  // Second (final) response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Total number of bytes written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_RAW_SECONDARY;
typedef RESP_WRITE_RAW_SECONDARY SMB_UNALIGNED *PRESP_WRITE_RAW_SECONDARY;

typedef struct _REQ_103_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( Fid );                     // File handle
    _USHORT( Count );
    _USHORT( Reserved );
    _ULONG( Offset );
    _ULONG( Timeout );
    _USHORT( WriteMode );
    _ULONG( Reserved2 );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} REQ_103_WRITE_RAW;
typedef REQ_103_WRITE_RAW SMB_UNALIGNED *PREQ_103_WRITE_RAW;

typedef struct _RESP_103_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} RESP_103_WRITE_RAW;
typedef RESP_103_WRITE_RAW SMB_UNALIGNED *PRESP_103_WRITE_RAW;

#endif // def INCLUDE_SMB_RAW

typedef struct _REQ_NT_CANCEL {
    UCHAR WordCount;                    // = 0
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} REQ_NT_CANCEL;
typedef REQ_NT_CANCEL SMB_UNALIGNED *PREQ_NT_CANCEL;

typedef struct _RESP_NT_CANCEL {
    UCHAR WordCount;                    // = 0
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_NT_CANCEL;
typedef RESP_NT_CANCEL SMB_UNALIGNED *PRESP_NT_CANCEL;

//
// File open modes
//

#define SMB_ACCESS_READ_ONLY 0
#define SMB_ACCESS_WRITE_ONLY 1
#define SMB_ACCESS_READ_WRITE 2
#define SMB_ACCESS_EXECUTE 3

//
// Open flags
//

#define SMB_OPEN_QUERY_INFORMATION  0x01
#define SMB_OPEN_OPLOCK             0x02
#define SMB_OPEN_OPBATCH            0x04
#define SMB_OPEN_QUERY_EA_LENGTH    0x08
#define SMB_OPEN_EXTENDED_RESPONSE  0x10

//
// NT open manifests
//

#define NT_CREATE_REQUEST_OPLOCK    0x02
#define NT_CREATE_REQUEST_OPBATCH   0x04
#define NT_CREATE_OPEN_TARGET_DIR   0x08


#define Added              0
#define Removed            1
#define Modified           2
#define RenamedOldName     3
#define RenamedNewName     4

//
// Lockrange for use with OS/2 DosFileLocks call
//

// *** Where is this used?

//typedef struct lockrange {
//    ULONG offset;
//    ULONG range;
//    };

//#define LOCK 0x1
//#define UNLOCK 0x2

//
// Data buffer format codes, from the core protocol.
//

#define SMB_FORMAT_DATA         1
#define SMB_FORMAT_DIALECT      2
#define SMB_FORMAT_PATHNAME     3
#define SMB_FORMAT_ASCII        4
#define SMB_FORMAT_VARIABLE     5

//
// WriteMode flags
//

#define SMB_WMODE_WRITE_THROUGH        0x0001   // complete write before responding
#define SMB_WMODE_SET_REMAINING        0x0002   // returning amt remaining in pipe
#define SMB_WMODE_WRITE_RAW_NAMED_PIPE 0x0004   // write named pipe in raw mode
#define SMB_WMODE_START_OF_MESSAGE     0x0008   // start of pipe message
#define SMB_WMODE_DATAGRAM             0x0080   // start of pipe message

//
// Various SMB flags:
//

//
// If the server supports LockAndRead and WriteAndUnlock, it sets this
// bit the Negotiate response.
//

#define SMB_FLAGS_LOCK_AND_READ_OK 0x01

//
// When on, the consumer guarantees that there is a receive buffer posted
// such that a "Send.No.Ack" can be used by the server to respond to
// the consumer's request.
//

#define SMB_FLAGS_SEND_NO_ACK 0x2

//
// This is part of the Flags field of every SMB header.  If this bit
// is set, then all pathnames in the SMB should be treated as case-
// insensitive.
//

#define SMB_FLAGS_CASE_INSENSITIVE 0x8

//
// When on in session setup, this bit indicates that all paths sent to
// the server are already in OS/2 canonicalized format.
//

#define SMB_FLAGS_CANONICALIZED_PATHS 0x10

//
// When on in a open file request SMBs (open, create, openX, etc.) this
// bit indicates a request for an oplock on the file.  When on in the
// response, this bit indicates that the oplock was granted.
//

#define SMB_FLAGS_OPLOCK 0x20

//
// When on, this bit indicates that the server should notify the client
// on any request that could cause the file to be changed.  If not set,
// the server only notifies the client on other open requests on the
// file.
//

#define SMB_FLAGS_OPLOCK_NOTIFY_ANY 0x40

//
// This bit indicates that the SMB is being sent from server to redir.
//

#define SMB_FLAGS_SERVER_TO_REDIR 0x80

//
// Valid bits for Flags on an incoming SMB
//

#define INCOMING_SMB_FLAGS      \
            (SMB_FLAGS_LOCK_AND_READ_OK    | \
             SMB_FLAGS_SEND_NO_ACK         | \
             SMB_FLAGS_CASE_INSENSITIVE    | \
             SMB_FLAGS_CANONICALIZED_PATHS | \
             SMB_FLAGS_OPLOCK_NOTIFY_ANY   | \
             SMB_FLAGS_OPLOCK)

//
// Names for bits in Flags2 field of SMB header that indicate what the
// client app is aware of.
//

#define SMB_FLAGS2_KNOWS_LONG_NAMES      0x0001
#define SMB_FLAGS2_KNOWS_EAS             0x0002
#define SMB_FLAGS2_SMB_SECURITY_SIGNATURE 0x0004
#define SMB_FLAGS2_IS_LONG_NAME          0x0040
#define SMB_FLAGS2_DFS                   0x1000
#define SMB_FLAGS2_PAGING_IO             0x2000
#define SMB_FLAGS2_NT_STATUS             0x4000
#define SMB_FLAGS2_UNICODE               0x8000

//
// Valid bits for Flags2 on an incoming SMB
//

#define INCOMING_SMB_FLAGS2     \
            (SMB_FLAGS2_KNOWS_LONG_NAMES | \
             SMB_FLAGS2_KNOWS_EAS        | \
             SMB_FLAGS2_DFS              | \
             SMB_FLAGS2_PAGING_IO        | \
             SMB_FLAGS2_IS_LONG_NAME     | \
             SMB_FLAGS2_NT_STATUS        | \
             SMB_FLAGS2_UNICODE )

//
// The SMB open function determines what action should be taken depending
// on the existence or lack thereof of files used in the operation.  It
// has the following mapping:
//
//    1111 1
//    5432 1098 7654 3210
//    rrrr rrrr rrrC rrOO
//
// where:
//
//    O - Open (action to be taken if the target file exists)
//        0 - Fail
//        1 - Open or Append file
//        2 - Truncate file
//
//    C - Create (action to be taken if the target file does not exist)
//        0 - Fail
//        1 - Create file
//

#define SMB_OFUN_OPEN_MASK 0x3
#define SMB_OFUN_CREATE_MASK 0x10

#define SMB_OFUN_OPEN_FAIL 0
#define SMB_OFUN_OPEN_APPEND 1
#define SMB_OFUN_OPEN_OPEN 1
#define SMB_OFUN_OPEN_TRUNCATE 2

#define SMB_OFUN_CREATE_FAIL 0x00
#define SMB_OFUN_CREATE_CREATE 0x10

//++
//
// BOOLEAN
// SmbOfunCreate(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunCreate(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_CREATE_MASK) == SMB_OFUN_CREATE_CREATE)

//++
//
// BOOLEAN
// SmbOfunAppend(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunAppend(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_APPEND)

//++
//
// BOOLEAN
// SmbOfunTruncate(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunTruncate(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_TRUNCATE)

//
// The desired access mode passed in Open and Open and X has the following
// mapping:
//
//    1111 11
//    5432 1098 7654 3210
//    rWrC rLLL rSSS rAAA
//
// where:
//
//    W - Write through mode.  No read ahead or write behind allowed on
//        this file or device.  When protocol is returned, data is expected
//        to be on the disk or device.
//
//    S - Sharing mode:
//        0 - Compatibility mode (as in core open)
//        1 - Deny read/write/execute (exclusive)
//        2 - Deny write
//        3 - Deny read/execute
//        4 - Deny none
//
//    A - Access mode
//        0 - Open for reading
//        1 - Open for writing
//        2 - Open for reading and writing
//        3 - Open for execute
//
//    rSSSrAAA = 11111111 (hex FF) indicates FCB open (as in core protocol)
//
//    C - Cache mode
//        0 - Normal file
//        1 - Do not cache this file
//
//    L - Locality of reference
//        0 - Locality of reference is unknown
//        1 - Mainly sequential access
//        2 - Mainly random access
//        3 - Random access with some locality
//        4 to 7 - Currently undefined
//


#define SMB_DA_SHARE_MASK           0x70
#define SMB_DA_ACCESS_MASK          0x07
#define SMB_DA_FCB_MASK             (UCHAR)0xFF

#define SMB_DA_ACCESS_READ          0x00
#define SMB_DA_ACCESS_WRITE         0x01
#define SMB_DA_ACCESS_READ_WRITE    0x02
#define SMB_DA_ACCESS_EXECUTE       0x03

#define SMB_DA_SHARE_COMPATIBILITY  0x00
#define SMB_DA_SHARE_EXCLUSIVE      0x10
#define SMB_DA_SHARE_DENY_WRITE     0x20
#define SMB_DA_SHARE_DENY_READ      0x30
#define SMB_DA_SHARE_DENY_NONE      0x40

#define SMB_DA_FCB                  (UCHAR)0xFF

#define SMB_CACHE_NORMAL            0x0000
#define SMB_DO_NOT_CACHE            0x1000

#define SMB_LR_UNKNOWN              0x0000
#define SMB_LR_SEQUENTIAL           0x0100
#define SMB_LR_RANDOM               0x0200
#define SMB_LR_RANDOM_WITH_LOCALITY 0x0300
#define SMB_LR_MASK                 0x0F00

#define SMB_DA_WRITE_THROUGH        0x4000

//
// The Action field of OpenAndX has the following format:
//
//    1111 11
//    5432 1098 7654 3210
//    Lrrr rrrr rrrr rrOO
//
// where:
//
//    L - Opportunistic lock.  1 if lock granted, else 0.
//
//    O - Open action:
//        1 - The file existed and was opened
//        2 - The file did not exist but was created
//        3 - The file existed and was truncated
//

#define SMB_OACT_OPENED     0x01
#define SMB_OACT_CREATED    0x02
#define SMB_OACT_TRUNCATED  0x03

#define SMB_OACT_OPLOCK     0x8000

//
// These flags are passed in the Flags field of the copy and extended rename
// SMBs.
//

//
// If set, the target must be a file or directory.
//

#define SMB_TARGET_IS_FILE         0x1
#define SMB_TARGET_IS_DIRECTORY    0x2

//
// The copy mode--if set, ASCII copying should be done, otherwise binary.
//

#define SMB_COPY_TARGET_ASCII       0x4
#define SMB_COPY_SOURCE_ASCII       0x8

#define SMB_COPY_TREE               0x20

//
// If set, verify all writes.
//

#define SMB_VERIFY_WRITES

//
// Define file attribute bits as used in the SMB protocol.  The specific
// bit positions are, for the most part, identical to those used in NT.
// However, NT does not define Volume and Directory bits.  It also has
// an explicit Normal bit; this bit is implied in SMB attributes by
// Hidden, System, and Directory being off.
//

#define SMB_FILE_ATTRIBUTE_READONLY     0x01
#define SMB_FILE_ATTRIBUTE_HIDDEN       0x02
#define SMB_FILE_ATTRIBUTE_SYSTEM       0x04
#define SMB_FILE_ATTRIBUTE_VOLUME       0x08
#define SMB_FILE_ATTRIBUTE_DIRECTORY    0x10
#define SMB_FILE_ATTRIBUTE_ARCHIVE      0x20

//
// Share type strings are passed in SMBs to indicate what type of shared
// resource is being or has been connected to.
//

#define SHARE_TYPE_NAME_DISK "A:"
#define SHARE_TYPE_NAME_PIPE "IPC"
#define SHARE_TYPE_NAME_COMM "COMM"
#define SHARE_TYPE_NAME_PRINT "LPT1:"
#define SHARE_TYPE_NAME_WILD "?????"

//
// SMB Error codes:
//

//
// Success Class:
//

#define SMB_ERR_SUCCESS (UCHAR)0x00

//
// DOS Error Class:
//

#define SMB_ERR_CLASS_DOS (UCHAR)0x01

#define SMB_ERR_BAD_FUNCTION        1   // Invalid function
#define SMB_ERR_BAD_FILE            2   // File not found
#define SMB_ERR_BAD_PATH            3   // Invalid directory
#define SMB_ERR_NO_FIDS             4   // Too many open files
#define SMB_ERR_ACCESS_DENIED       5   // Access not allowed for req. func.
#define SMB_ERR_BAD_FID             6   // Invalid file handle
#define SMB_ERR_BAD_MCB             7   // Memory control blocks destroyed
#define SMB_ERR_INSUFFICIENT_MEMORY 8   // For the desired function
#define SMB_ERR_BAD_MEMORY          9   // Invalid memory block address
#define SMB_ERR_BAD_ENVIRONMENT     10  // Invalid environment
#define SMB_ERR_BAD_FORMAT          11  // Invalid format
#define SMB_ERR_BAD_ACCESS          12  // Invalid open mode
#define SMB_ERR_BAD_DATA            13  // Invalid data (only from IOCTL)
#define SMB_ERR_RESERVED            14
#define SMB_ERR_BAD_DRIVE           15  // Invalid drive specified
#define SMB_ERR_CURRENT_DIRECTORY   16  // Attempted to remove currect directory
#define SMB_ERR_DIFFERENT_DEVICE    17  // Not the same device
#define SMB_ERR_NO_FILES            18  // File search can't find more files
#define SMB_ERR_BAD_SHARE           32  // An open conflicts with FIDs on file
#define SMB_ERR_LOCK                33  // Conflict with existing lock
#define SMB_ERR_FILE_EXISTS         80  // Tried to overwrite existing file
#define SMB_ERR_BAD_PIPE            230 // Invalie pipe
#define SMB_ERR_PIPE_BUSY           231 // All instances of the pipe are busy
#define SMB_ERR_PIPE_CLOSING        232 // Pipe close in progress
#define SMB_ERR_PIPE_NOT_CONNECTED  233 // No process on other end of pipe
#define SMB_ERR_MORE_DATA           234 // There is more data to return

//
// SERVER Error Class:
//

#define SMB_ERR_CLASS_SERVER (UCHAR)0x02

#define SMB_ERR_ERROR               1   // Non-specific error code
#define SMB_ERR_BAD_PASSWORD        2   // Bad name/password pair
#define SMB_ERR_BAD_TYPE            3   // Reserved
#define SMB_ERR_ACCESS              4   // Requester lacks necessary access
#define SMB_ERR_BAD_TID             5   // Invalid TID
#define SMB_ERR_BAD_NET_NAME        6   // Invalid network name in tree connect
#define SMB_ERR_BAD_DEVICE          7   // Invalid device request
#define SMB_ERR_QUEUE_FULL          49  // Print queue full--returned print file
#define SMB_ERR_QUEUE_TOO_BIG       50  // Print queue full--no space
#define SMB_ERR_QUEUE_EOF           51  // EOF on print queue dump
#define SMB_ERR_BAD_PRINT_FID       52  // Invalid print file FID
#define SMB_ERR_BAD_SMB_COMMAND     64  // SMB command not recognized
#define SMB_ERR_SERVER_ERROR        65  // Internal server error
#define SMB_ERR_FILE_SPECS          67  // FID and pathname were incompatible
#define SMB_ERR_RESERVED2           68
#define SMB_ERR_BAD_PERMITS         69  // Access permissions invalid
#define SMB_ERR_RESERVED3           70
#define SMB_ERR_BAD_ATTRIBUTE_MODE  71  // Invalid attribute mode specified
#define SMB_ERR_SERVER_PAUSED       81  // Server is paused
#define SMB_ERR_MESSAGE_OFF         82  // Server not receiving messages
#define SMB_ERR_NO_ROOM             83  // No room for buffer message
#define SMB_ERR_TOO_MANY_NAMES      87  // Too many remote user names
#define SMB_ERR_TIMEOUT             88  // Operation was timed out
#define SMB_ERR_NO_RESOURCE         89  // No resources available for request
#define SMB_ERR_TOO_MANY_UIDS       90  // Too many UIDs active in session
#define SMB_ERR_BAD_UID             91  // UID not known as a valid UID
#define SMB_ERR_INVALID_NAME        123 // Invalid name returned from FAT.
#define SMB_ERR_INVALID_NAME_RANGE  206 // Non 8.3 name passed to FAT (or non 255 name to HPFS)
#define SMB_ERR_USE_MPX             250 // Can't support Raw; use MPX
#define SMB_ERR_USE_STANDARD        251 // Can't support Raw, use standard r/w
#define SMB_ERR_CONTINUE_MPX        252 // Reserved
#define SMB_ERR_RESERVED4           253
#define SMB_ERR_RESERVED5           254
#define SMB_ERR_NO_SUPPORT_INTERNAL 255 // Internal code for NO_SUPPORT--
                                        // allows codes to be stored in a byte
#define SMB_ERR_NO_SUPPORT          (USHORT)0xFFFF  // Function not supported

//
// HARDWARE Error Class:
//

#define SMB_ERR_CLASS_HARDWARE (UCHAR)0x03

#define SMB_ERR_NO_WRITE            19  // Write attempted to write-prot. disk
#define SMB_ERR_BAD_UNIT            20  // Unknown unit
#define SMB_ERR_DRIVE_NOT_READY     21  // Disk drive not ready
#define SMB_ERR_BAD_COMMAND         22  // Unknown command
#define SMB_ERR_DATA                23  // Data error (CRC)
#define SMB_ERR_BAD_REQUEST         24  // Bad request structure length
#define SMB_ERR_SEEK                25  // Seek error
#define SMB_ERR_BAD_MEDIA           26  // Unknown media type
#define SMB_ERR_BAD_SECTOR          27  // Sector not found
#define SMB_ERR_NO_PAPER            28  // Printer out of paper
#define SMB_ERR_WRITE_FAULT         29  // Write fault
#define SMB_ERR_READ_FAULT          30  // Read fault
#define SMB_ERR_GENERAL             31  // General failure
#define SMB_ERR_LOCK_CONFLICT       33  // Lock conflicts with existing lock
#define SMB_ERR_WRONG_DISK          34  // Wrong disk was found in a drive
#define SMB_ERR_FCB_UNAVAILABLE     35  // No FCBs available to process request
#define SMB_ERR_SHARE_BUFFER_EXCEEDED 36
#define SMB_ERR_DISK_FULL           39  // !!! Undocumented, but in LM2.0

//
// Other Error Classes:
//

#define SMB_ERR_CLASS_XOS        (UCHAR)0x04    // Reserved for XENIX
#define SMB_ERR_CLASS_RMX1       (UCHAR)0xE1    // Reserved for iRMX
#define SMB_ERR_CLASS_RMX2       (UCHAR)0xE2    // Reserved for iRMX
#define SMB_ERR_CLASS_RMX3       (UCHAR)0xE3    // Reserved for iRMX
#define SMB_ERR_CLASS_COMMAND    (UCHAR)0xFF    // Command was not in the SMB format


//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING

//   Old (LanMan 1.2) and new (NT) field names:
//   (Undocumented fields have corresponding structure in parenthesis)
// smb_access            Access
// smb_action            Action
// smb_adate             AccessDate
// smb_allocsize         AllocationSize
// smb_aname             AccountName
// smb_apasslen          PasswordSize
// smb_apasswd           AccountPassword
// smb_atime             AccessTime
// smb_attr              Attribute
// smb_attribute         Attribute
// smb_aunits            (RESP_QUERY_INFORMATION_SERVER)
// smb_bcc               BufferSize
// smb_blkmode           BlockMode
// smb_blksize           BlockSize
// smb_blksperunit       BlocksPerUnit
// smb_bpu               BlocksPerUnit
// smb_bs                BlockSize
// smb_bufsize           MaxBufferSize
// smb_buf[1]            Buffer[1]
// smb_bytes[*]          Bytes[*]
// smb_cat               Category
// smb_cct               FilesCopied
// smb_cdate             CreateDate
// smb_cert              CertificateOffset
// smb_com               Command
// smb_com2              AndXCommand
// smb_count             Count
// smb_count_left        Remaining
// smb_cryptkey[*]       CryptKey
// smb_ctime             CreateTime
// smb_datablock         DataBlock
// smb_datalen           DataSize
// smb_datasize          DataSize
// smb_data[*]           Data[*]
// smb_dcmode            DataCompactMode
// smb_dev               DeviceName
// smb_doff              DataOffset
// smb_drcnt             DataCount
// smb_drdisp            DataDisplacement
// smb_droff             DataOffset
// smb_dscnt             DataCount
// smb_dsdisp            DataDisplacement
// smb_dsize             DataSize
// smb_dsoff             DataOffset
// smb_encrypt           EncryptKey
// smb_encryptlen        EncryptKeySize
// smb_encryptoff        EncryptKeyOffset
// smb_eos               EndOfSearch
// smb_err               Error
// smb_errmsg[1]         ErrorMessage[1]
// smb_fau               (RESP_QUERY_INFORMATION_SERVER)
// smb_fid               Fid
// smb_fileid            ServerFid
// smb_flag              Flag
// smb_flag2             Flag2
// smb_flags             Flag
// smb_flg               Flag
// smb_freeunits         FreeUnits
// smb_fsid              (RESP_QUERY_INFORMATION_SERVER)
// smb_fsize             FileSize
// smb_fun               Function
// smb_gid               Gid
// smb_handle            Handle
// smb_ident1            Identifier
// smb_idf[4]            Protocol[4]
// smb_index             Index
// smb_info              Info
// smb_left              Remaining
// smb_len               SetupLength
// smb_locknum           NumberOfLocks
// smb_lockrng[*]        LockRange
// smb_locktype          LockType
// smb_lpid              OwnerPid
// smb_maxbytes          MaxBytes
// smb_maxcnt            MaxCount
// smb_maxcount          MaxCount
// smb_maxmux            (RESP_NEGOTIATE)
// smb_maxvcs            MaxNumberVcs
// smb_maxxmitsz         MaxTransmitSize
// smb_maxxmt            MaxTransmitSize
// smb_mdate             ModificationDate
// smb_mdrcnt            MaxDataCount
// smb_mid               Mid
// smb_mincnt            MinCount
// smb_mode              Mode
// smb_mprcnt            MaxParameterCount
// smb_mpxmax            MaxMpxCount
// smb_msrcnt            MaxSetupCount
// smb_mtime             ModificationTime
// smb_name[*]           Name[*]
// smb_off2              AndXOffset
// smb_offset            Offset
// smb_ofun              OpenFunction
// smb_pad               Pad
// smb_pad1[]            Pad1
// smb_pad[]             Pad[]
// smb_param[*]          Parameter[*]
// smb_path              ServerName
// smb_pathname          PathName
// smb_pid               Pid
// smb_prcnt             ParameterCount
// smb_prdisp            ParameterDisplacement
// smb_proff             ParameterCount
// smb_pscnt             ParameterCount
// smb_psdisp            ParameterDisplacement
// smb_psoff             ParameterOffset
// smb_range             LockLength or UnlockLength
// smb_rcls              ErrorClass
// smb_reh               ReservedH
// smb_reh2              ReservedH2
// smb_remaining         Remaining
// smb_remcnt            Remaining
// smb_res1              Reserved
// smb_res2              Reserved2
// smb_res3              Reserved3
// smb_res4              Reserved4
// smb_res5              Reserved5
// smb_reserved          Reserved
// smb_restart           Restart
// smb_resumekey         ResumeKey
// smb_res[5]            Reserved[]
// smb_reverb            ReverbCount
// smb_rsvd              Reserved
// smb_rsvd1             Reserved
// smb_rsvd2             Reserved2
// smb_rsvd3             Reserved3
// smb_rsvd4             Reserved4
// smb_sattr             SearchAttribute
// smb_secmode           SecurityMode
// smb_seq               SequenceNumber
// smb_services          Services
// smb_sesskey           SessionKey
// smb_setup[*]          Setup[*]
// smb_size              Size
// smb_spasslen          ServerPasswordSize
// smb_spasswd           ServerPassword
// smb_srv_date          ServerDate
// smb_srv_time          ServerTime
// smb_srv_tzone         ServerTimeZone
// smb_start             StartIndex
// smb_state             DeviceState
// smb_suwcnt            SetupWordCount
// smb_su_class          SetupClass
// smb_su_com            SetupCommand
// smb_su_handle         SetupFid
// smb_su_opcode         SetupOpcode
// smb_su_priority       SetupPriority
// smb_tcount            Count
// smb_tdis              TreeDisconnect
// smb_tdrcnt            TotalDataCount
// smb_tdscnt            TotalDataCount
// smb_tid               Tid
// smb_tid2              Tid2
// smb_time              Time
// smb_timeout           Timeout
// smb_totalunits        TotalUnits
// smb_tprcnt            TotalParameterCount
// smb_tpscnt            TotalParameterCount
// smb_type              FileType
// smb_uid               Uid
// smb_unlkrng[*]        UnlockRange
// smb_unlocknum         NumberOfUnlocks
// smb_vblen             DataLength
// smb_vcnum             VcNumber
// smb_vldate            (RESP_QUERY_INFORMATION_SERVER)
// smb_vllen             (RESP_QUERY_INFORMATION_SERVER)
// smb_vltime            (RESP_QUERY_INFORMATION_SERVER)
// smb_vwv[1]            Param
// smb_wct               WordCount
// smb_wmode             WriteMode
// smb_xchain            EncryptChainOffset


//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING


//
// Named pipe function codes
//

#define TRANS_SET_NMPIPE_STATE      0x01
#define TRANS_RAW_READ_NMPIPE       0x11
#define TRANS_QUERY_NMPIPE_STATE    0x21
#define TRANS_QUERY_NMPIPE_INFO     0x22
#define TRANS_PEEK_NMPIPE           0x23
#define TRANS_TRANSACT_NMPIPE       0x26
#define TRANS_RAW_WRITE_NMPIPE      0x31
#define TRANS_READ_NMPIPE           0x36
#define TRANS_WRITE_NMPIPE          0x37
#define TRANS_WAIT_NMPIPE           0x53
#define TRANS_CALL_NMPIPE           0x54

//
// Mailslot function code
//

#define TRANS_MAILSLOT_WRITE        0x01

//
// Transaction2 function codes
//

#define TRANS2_OPEN2                    0x00
#define TRANS2_FIND_FIRST2              0x01
#define TRANS2_FIND_NEXT2               0x02
#define TRANS2_QUERY_FS_INFORMATION     0x03
#define TRANS2_SET_FS_INFORMATION       0x04
#define TRANS2_QUERY_PATH_INFORMATION   0x05
#define TRANS2_SET_PATH_INFORMATION     0x06
#define TRANS2_QUERY_FILE_INFORMATION   0x07
#define TRANS2_SET_FILE_INFORMATION     0x08
#define TRANS2_FSCTL                    0x09
#define TRANS2_IOCTL2                   0x0A
#define TRANS2_FIND_NOTIFY_FIRST        0x0B
#define TRANS2_FIND_NOTIFY_NEXT         0x0C
#define TRANS2_CREATE_DIRECTORY         0x0D
#define TRANS2_SESSION_SETUP            0x0E
#define TRANS2_QUERY_FS_INFORMATION_FID 0x0F
#define TRANS2_GET_DFS_REFERRAL         0x10
#define TRANS2_REPORT_DFS_INCONSISTENCY 0x11

#define TRANS2_MAX_FUNCTION             0x11

//
// Nt Transaction function codes
//

#define NT_TRANSACT_MIN_FUNCTION        1

#define NT_TRANSACT_CREATE              1
#define NT_TRANSACT_IOCTL               2
#define NT_TRANSACT_SET_SECURITY_DESC   3
#define NT_TRANSACT_NOTIFY_CHANGE       4
#define NT_TRANSACT_RENAME              5
#define NT_TRANSACT_QUERY_SECURITY_DESC 6
#define NT_TRANSACT_QUERY_QUOTA         7
#define NT_TRANSACT_SET_QUOTA           8

#define NT_TRANSACT_MAX_FUNCTION        8

//
// File information levels
//

#define SMB_INFO_STANDARD               1
#define SMB_INFO_QUERY_EA_SIZE          2
#define SMB_INFO_SET_EAS                2
#define SMB_INFO_QUERY_EAS_FROM_LIST    3
#define SMB_INFO_QUERY_ALL_EAS          4       // undocumented but supported
#define SMB_INFO_QUERY_FULL_NAME        5       // never sent by redir
#define SMB_INFO_IS_NAME_VALID          6
#define SMB_INFO_PASSTHROUGH            1000    // any info above here is a simple pass-through

//
// NT extension to file info levels
//

#define SMB_QUERY_FILE_BASIC_INFO          0x101
#define SMB_QUERY_FILE_STANDARD_INFO       0x102
#define SMB_QUERY_FILE_EA_INFO             0x103
#define SMB_QUERY_FILE_NAME_INFO           0x104
#define SMB_QUERY_FILE_ALLOCATION_INFO     0x105
#define SMB_QUERY_FILE_END_OF_FILEINFO     0x106
#define SMB_QUERY_FILE_ALL_INFO            0x107
#define SMB_QUERY_FILE_ALT_NAME_INFO       0x108
#define SMB_QUERY_FILE_STREAM_INFO         0x109
#define SMB_QUERY_FILE_COMPRESSION_INFO    0x10B

#define SMB_SET_FILE_BASIC_INFO                 0x101
#define SMB_SET_FILE_DISPOSITION_INFO           0x102
#define SMB_SET_FILE_ALLOCATION_INFO            0x103
#define SMB_SET_FILE_END_OF_FILE_INFO           0x104

#define SMB_QUERY_FS_LABEL_INFO            0x101
#define SMB_QUERY_FS_VOLUME_INFO           0x102
#define SMB_QUERY_FS_SIZE_INFO             0x103
#define SMB_QUERY_FS_DEVICE_INFO           0x104
#define SMB_QUERY_FS_ATTRIBUTE_INFO        0x105
#define SMB_QUERY_FS_QUOTA_INFO            0x106        // unused?
#define SMB_QUERY_FS_CONTROL_INFO          0x107

//
// Volume information levels.
//

#define SMB_INFO_ALLOCATION             1
#define SMB_INFO_VOLUME                 2

//
// Rename2 information levels.
//

#define SMB_NT_RENAME_MOVE_CLUSTER_INFO   0x102
#define SMB_NT_RENAME_SET_LINK_INFO       0x103
#define SMB_NT_RENAME_RENAME_FILE         0x104 // Server internal
#define SMB_NT_RENAME_MOVE_FILE           0x105 // Server internal

//
// Protocol for NtQueryQuotaInformationFile
//
typedef struct {
    _USHORT( Fid );                 // FID of target
    UCHAR ReturnSingleEntry;        // Indicates that only a single entry should be returned
                                    //   rather than filling the buffer with as
                                    //   many entries as possible.
    UCHAR RestartScan;              // Indicates whether the scan of the quota information
                                    //   is to be restarted from the beginning.
    _ULONG ( SidListLength );       // Supplies the length of the SID list if present
    _ULONG ( StartSidLength );      // Supplies an optional SID that indicates that the returned
                                    //   information is to start with an entry other
                                    //   than the first.  This parameter is ignored if a
                                    //   SidList is given
    _ULONG( StartSidOffset);        // Supplies the offset of Start Sid in the buffer
} REQ_NT_QUERY_FS_QUOTA_INFO, *PREQ_NT_QUERY_FS_QUOTA_INFO;
//
// Desciptor response
//
// Data Bytes:  The Quota Information
//
typedef struct {
    _ULONG ( Length );
} RESP_NT_QUERY_FS_QUOTA_INFO, *PRESP_NT_QUERY_FS_QUOTA_INFO;

//
// Protocol for NtSetQuotaInformationFile
//
typedef struct {
    _USHORT( Fid );                 // FID of target
} REQ_NT_SET_FS_QUOTA_INFO, *PREQ_NT_SET_FS_QUOTA_INFO;
//
// Response:
//
// Setup words:  None.
// Parameter Bytes:  None.
// Data Bytes:  None.
//


//
// Dfs Transactions
//

//
// Request for Referral.
//
typedef struct {
    USHORT MaxReferralLevel;            // Latest version of referral understood
    UCHAR RequestFileName[1];           // Dfs name for which referral is sought
} REQ_GET_DFS_REFERRAL;
typedef REQ_GET_DFS_REFERRAL SMB_UNALIGNED *PREQ_GET_DFS_REFERRAL;

//
// The format of an individual referral contains version and length information
//  allowing the client to skip referrals it does not understand.
//
// !! All referral elements must have VersionNumber and Size as the first 2 elements !!
//

typedef struct {
    USHORT  VersionNumber;              // == 1
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
    };
    WCHAR   ShareName[1];               // The server+share name go right here.  NULL terminated.
} DFS_REFERRAL_V1;
typedef DFS_REFERRAL_V1 SMB_UNALIGNED *PDFS_REFERRAL_V1;

typedef struct {
    USHORT  VersionNumber;              // == 2
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
    };
    ULONG   Proximity;                  // Hint of transport cost
    ULONG   TimeToLive;                 // In number of seconds
    USHORT  DfsPathOffset;              // Offset from beginning of this element to Path to access
    USHORT  DfsAlternatePathOffset;     // Offset from beginning of this element to 8.3 path
    USHORT  NetworkAddressOffset;       // Offset from beginning of this element to Network path
} DFS_REFERRAL_V2;
typedef DFS_REFERRAL_V2 SMB_UNALIGNED *PDFS_REFERRAL_V2;

typedef struct {
    USHORT  VersionNumber;              // == 3
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
        USHORT NameListReferral : 1;    // This referral contains an expanded name list
    };
    ULONG   TimeToLive;                 // In number of seconds
    union {
      struct {
        USHORT DfsPathOffset;           // Offset from beginning of this element to Path to access
        USHORT DfsAlternatePathOffset;  // Offset from beginning of this element to 8.3 path
        USHORT NetworkAddressOffset;    // Offset from beginning of this element to Network path
        GUID   ServiceSiteGuid;         // The guid for the site
      };
      struct {
        USHORT SpecialNameOffset;       // Offset from this element to the special name string
        USHORT NumberOfExpandedNames;   // Number of expanded names
        USHORT ExpandedNameOffset;      // Offset from this element to the expanded name list
      };
    };
} DFS_REFERRAL_V3;
typedef DFS_REFERRAL_V3 SMB_UNALIGNED *PDFS_REFERRAL_V3;

typedef struct {
    USHORT  PathConsumed;               // Number of WCHARs consumed in DfsPathName
    USHORT  NumberOfReferrals;          // Number of referrals contained here
    struct {
            ULONG ReferralServers : 1;  // Elements in Referrals[] are referral servers
            ULONG StorageServers : 1;   // Elements in Referrals[] are storage servers
    };
    union {                             // The vector of referrals
        DFS_REFERRAL_V1 v1;
        DFS_REFERRAL_V2 v2;
        DFS_REFERRAL_V3 v3;
    } Referrals[1];                     // [ NumberOfReferrals ]

    //
    // WCHAR StringBuffer[];            // Used by DFS_REFERRAL_V2
    //

} RESP_GET_DFS_REFERRAL;
typedef RESP_GET_DFS_REFERRAL SMB_UNALIGNED *PRESP_GET_DFS_REFERRAL;

//
// During Dfs operations, a client may discover a knowledge inconsistency in the Dfs.
// The parameter portion of the TRANS2_REPORT_DFS_INCONSISTENCY SMB is
// encoded in this way
//

typedef struct {
    UCHAR RequestFileName[1];           // Dfs name for which inconsistency is being reported
    union {
        DFS_REFERRAL_V1 v1;             // The single referral thought to be in error
    } Referral;
} REQ_REPORT_DFS_INCONSISTENCY;
typedef REQ_REPORT_DFS_INCONSISTENCY SMB_UNALIGNED *PREQ_REPORT_DFS_INCONSISTENCY;

typedef struct _REQ_QUERY_FS_INFORMATION_FID {
    _USHORT( InformationLevel );
    _USHORT( Fid );
} REQ_QUERY_FS_INFORMATION_FID;
typedef REQ_QUERY_FS_INFORMATION_FID SMB_UNALIGNED *PREQ_QUERY_FS_INFORMATION_FID;

//
// The client also needs to send to this server the referral which it believes to be
//  in error.  The data part of this transaction contains the errant referral(s), encoded
//  as above in the DFS_REFERRAL_* structures.
//

//
// Find First, information levels
//

#define SMB_FIND_FILE_DIRECTORY_INFO       0x101
#define SMB_FIND_FILE_FULL_DIRECTORY_INFO  0x102
#define SMB_FIND_FILE_NAMES_INFO           0x103
#define SMB_FIND_FILE_BOTH_DIRECTORY_INFO  0x104

#ifdef INCLUDE_SMB_DIRECTORY

//
// CreateDirectory2 function code os Transaction2 SMB, see #3 page 51
// Function is SrvSmbCreateDirectory2()
// TRANS2_CREATE_DIRECTORY 0x0D
//

typedef struct _REQ_CREATE_DIRECTORY2 {
    _ULONG( Reserved );                 // Reserved--must be zero
    UCHAR Buffer[1];                    // Directory name to create
} REQ_CREATE_DIRECTORY2;
typedef REQ_CREATE_DIRECTORY2 SMB_UNALIGNED *PREQ_CREATE_DIRECTORY2;

// Data bytes for CreateDirectory2 request are the extended attributes for the
// created file.

typedef struct _RESP_CREATE_DIRECTORY2 {
    _USHORT( EaErrorOffset );           // Offset into FEAList of first error
                                        // which occurred while setting EAs
} RESP_CREATE_DIRECTORY2;
typedef RESP_CREATE_DIRECTORY2 SMB_UNALIGNED *PRESP_CREATE_DIRECTORY2;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_SEARCH

//
// FindFirst2 function code of Transaction2 SMB, see #3 page 22
// Function is SrvSmbFindFirst2()
// TRANS2_FIND_FIRST2 0x01
//

typedef struct _REQ_FIND_FIRST2 {
    _USHORT( SearchAttributes );
    _USHORT( SearchCount );             // Maximum number of entries to return
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - close search after this request
                                        //  1 - close search if end reached
                                        //  2 - return resume keys
    _USHORT( InformationLevel );
    _ULONG(SearchStorageType);
    UCHAR Buffer[1];                    // File name
} REQ_FIND_FIRST2;
typedef REQ_FIND_FIRST2 SMB_UNALIGNED *PREQ_FIND_FIRST2;

// Data bytes for Find First2 request are a list of extended attributes
// to retrieve (a GEAList), if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_FIND_FIRST2 {
    _USHORT( Sid );                     // Search handle
    _USHORT( SearchCount );             // Number of entries returned
    _USHORT( EndOfSearch );             // Was last entry returned?
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _USHORT( LastNameOffset );          // Offset into data to file name of
                                        //  last entry, if server needs it
                                        //  to resume search; else 0
} RESP_FIND_FIRST2;
typedef RESP_FIND_FIRST2 SMB_UNALIGNED *PRESP_FIND_FIRST2;

// Data bytes for Find First2 response are level-dependent information
// about the matching files.  If bit 2 in the request parameters was
// set, each entry is preceded by a four-byte resume key.

//
// FindNext2 function code of Transaction2 SMB, see #3 page 26
// Function is SrvSmbFindNext2()
// TRANS2_FIND_NEXT2 0x02
//

typedef struct _REQ_FIND_NEXT2 {
    _USHORT( Sid );                     // Search handle
    _USHORT( SearchCount );             // Maximum number of entries to return
    _USHORT( InformationLevel );
    _ULONG( ResumeKey );                // Value returned by previous find
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - close search after this request
                                        //  1 - close search if end reached
                                        //  2 - return resume keys
                                        //  3 - resume/continue, NOT rewind
    UCHAR Buffer[1];                    // Resume file name
} REQ_FIND_NEXT2;
typedef REQ_FIND_NEXT2 SMB_UNALIGNED *PREQ_FIND_NEXT2;

// Data bytes for Find Next2 request are a list of extended attributes
// to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_FIND_NEXT2 {
    _USHORT( SearchCount );             // Number of entries returned
    _USHORT( EndOfSearch );             // Was last entry returned?
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _USHORT( LastNameOffset );          // Offset into data to file name of
                                        //  last entry, if server needs it
                                        //  to resume search; else 0
} RESP_FIND_NEXT2;
typedef RESP_FIND_NEXT2 SMB_UNALIGNED *PRESP_FIND_NEXT2;

// Data bytes for Find Next2 response are level-dependent information
// about the matching files.  If bit 2 in the request parameters was
// set, each entry is preceded by a four-byte resume key.

//
// Flags for REQ_FIND_FIRST2.Flags
//

#define SMB_FIND_CLOSE_AFTER_REQUEST    0x01
#define SMB_FIND_CLOSE_AT_EOS           0x02
#define SMB_FIND_RETURN_RESUME_KEYS     0x04
#define SMB_FIND_CONTINUE_FROM_LAST     0x08
#define SMB_FIND_WITH_BACKUP_INTENT     0x10

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open2 function code of Transaction2 SMB, see #3 page 19
// Function is SrvSmbOpen2()
// TRANS2_OPEN2 0x00
//
// *** Note that the REQ_OPEN2 and RESP_OPEN2 structures closely
//     resemble the REQ_OPEN_ANDX and RESP_OPEN_ANDX structures.
//

typedef struct _REQ_OPEN2 {
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - return additional info
                                        //  1 - set single user total file lock
                                        //  2 - server notifies consumer of
                                        //      actions which may change file
                                        //  3 - return total length of EAs
    _USHORT( DesiredAccess );           // File open mode
    _USHORT( SearchAttributes );        // *** ignored
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( OpenFunction );
    _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
    _USHORT( Reserved )[5];             // Pad through OpenAndX's Timeout,
                                        //  Reserved, and ByteCount
    UCHAR Buffer[1];                    // File name
} REQ_OPEN2;
typedef REQ_OPEN2 SMB_UNALIGNED *PREQ_OPEN2;

// Data bytes for Open2 request are the extended attributes for the
// created file.

typedef struct _RESP_OPEN2 {
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _ULONG( EaLength );                 // Total EA length for opened file
} RESP_OPEN2;
typedef RESP_OPEN2 SMB_UNALIGNED *PRESP_OPEN2;

// The Open2 response has no data bytes.


#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_MISC

//
// QueryFsInformation function code of Transaction2 SMB, see #3 page 30
// Function is SrvSmbQueryFsInformation()
// TRANS2_QUERY_FS_INFORMATION 0x03
//

typedef struct _REQ_QUERY_FS_INFORMATION {
    _USHORT( InformationLevel );
} REQ_QUERY_FS_INFORMATION;
typedef REQ_QUERY_FS_INFORMATION SMB_UNALIGNED *PREQ_QUERY_FS_INFORMATION;

// No data bytes for Query FS Information request.

//typedef struct _RESP_QUERY_FS_INFORMATION {
//} RESP_QUERY_FS_INFORMATION;
//typedef RESP_QUERY_FS_INFORMATION SMB_UNALIGNED *PRESP_QUERY_FS_INFORMATION;

// Data bytes for Query FS Information response are level-dependent
// information about the specified volume.

//
// SetFSInformation function code of Transaction2 SMB, see #3 page 31
// Function is SrvSmbSetFSInformation()
// TRANS2_SET_PATH_INFORMATION 0x04
//

typedef struct _REQ_SET_FS_INFORMATION {
    _USHORT( Fid );
    _USHORT( InformationLevel );
} REQ_SET_FS_INFORMATION;
typedef REQ_SET_FS_INFORMATION SMB_UNALIGNED *PREQ_SET_FS_INFORMATION;

// Data bytes for Set FS Information request are level-dependant
// information about the specified volume.

//typedef struct _RESP_SET_FS_INFORMATION {
//} RESP_SET_FS_INFORMATION;
//typedef RESP_SET_FS_INFORMATION SMB_UNALIGNED *PRESP_SET_FS_INFORMATION;

// The Set FS Information response has no data bytes.

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_QUERY_SET

//
// QueryPathInformation function code of Transaction2 SMB, see #3 page 33
// Function is SrvSmbQueryPathInformation()
// TRANS2_QUERY_PATH_INFORMATION 0x05
//

typedef struct _REQ_QUERY_PATH_INFORMATION {
    _USHORT( InformationLevel );
    _ULONG( Reserved );                 // Must be zero
    UCHAR Buffer[1];                    // File name
} REQ_QUERY_PATH_INFORMATION;
typedef REQ_QUERY_PATH_INFORMATION SMB_UNALIGNED *PREQ_QUERY_PATH_INFORMATION;

// Data bytes for Query Path Information request are a list of extended
// attributes to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_QUERY_PATH_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_QUERY_PATH_INFORMATION;
typedef RESP_QUERY_PATH_INFORMATION SMB_UNALIGNED *PRESP_QUERY_PATH_INFORMATION;

// Data bytes for Query Path Information response are level-dependent
// information about the specified path/file.

//
// SetPathInformation function code of Transaction2 SMB, see #3 page 35
// Function is SrvSmbSetPathInformation()
// TRANS2_SET_PATH_INFORMATION 0x06
//

typedef struct _REQ_SET_PATH_INFORMATION {
    _USHORT( InformationLevel );
    _ULONG( Reserved );                 // Must be zero
    UCHAR Buffer[1];                    // File name
} REQ_SET_PATH_INFORMATION;
typedef REQ_SET_PATH_INFORMATION SMB_UNALIGNED *PREQ_SET_PATH_INFORMATION;

// Data bytes for Set Path Information request are either file information
// and attributes or a list of extended attributes for the file.

typedef struct _RESP_SET_PATH_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_SET_PATH_INFORMATION;
typedef RESP_SET_PATH_INFORMATION SMB_UNALIGNED *PRESP_SET_PATH_INFORMATION;

// The Set Path Information response has no data bytes.

//
// QueryFileInformation function code of Transaction2 SMB, see #3 page 37
// Function is SrvSmbQueryFileInformation()
// TRANS2_QUERY_FILE_INFORMATION 0x07
//

typedef struct _REQ_QUERY_FILE_INFORMATION {
    _USHORT( Fid );                     // File handle
    _USHORT( InformationLevel );
} REQ_QUERY_FILE_INFORMATION;
typedef REQ_QUERY_FILE_INFORMATION SMB_UNALIGNED *PREQ_QUERY_FILE_INFORMATION;

// Data bytes for Query File Information request are a list of extended
// attributes to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_QUERY_FILE_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_QUERY_FILE_INFORMATION;
typedef RESP_QUERY_FILE_INFORMATION SMB_UNALIGNED *PRESP_QUERY_FILE_INFORMATION;

// Data bytes for Query File Information response are level-dependent
// information about the specified path/file.

//
// SetFileInformation function code of Transaction2 SMB, see #3 page 39
// Function is SrvSmbSetFileInformation()
// TRANS2_SET_FILE_INFORMATION 0x08
//

typedef struct _REQ_SET_FILE_INFORMATION {
    _USHORT( Fid );                     // File handle
    _USHORT( InformationLevel );
    _USHORT( Flags );                   // File I/O control flags: bit set-
                                        //  4 - write through
                                        //  5 - no cache
} REQ_SET_FILE_INFORMATION;
typedef REQ_SET_FILE_INFORMATION SMB_UNALIGNED *PREQ_SET_FILE_INFORMATION;

// Data bytes for Set File Information request are either file information
// and attributes or a list of extended attributes for the file.

typedef struct _RESP_SET_FILE_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_SET_FILE_INFORMATION;
typedef RESP_SET_FILE_INFORMATION SMB_UNALIGNED *PRESP_SET_FILE_INFORMATION;

// The Set File Information response has no data bytes.

#endif // def INCLUDE_SMB_QUERY_SET

//
//  Opcodes for Mailslot transactions.  Not all filled in at present.
//    WARNING ... the info here on mailslots (opcode and smb struct)
//                is duplicated in net/h/mslotsmb.h
//

#define MS_WRITE_OPCODE 1

typedef struct _SMB_TRANSACT_MAILSLOT {
    UCHAR WordCount;                    // Count of data bytes; value = 17
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - unused
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved1 );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    UCHAR SetupWordCount;               // = 3
    UCHAR Reserved2;                    // Reserved (pad above to word)
    _USHORT( Opcode );                  // 1 -- Write Mailslot
    _USHORT( Priority );                // Priority of transaction
    _USHORT( Class );                   // Class: 1 = reliable, 2 = unreliable
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR MailslotName[];             //  "\MAILSLOT\<name>0"
    //UCHAR Pad[]                       //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data to write to mailslot
} SMB_TRANSACT_MAILSLOT;
typedef SMB_TRANSACT_MAILSLOT SMB_UNALIGNED *PSMB_TRANSACT_MAILSLOT;

typedef struct _SMB_TRANSACT_NAMED_PIPE {
    UCHAR WordCount;                    // Count of data bytes; value = 16
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - also disconnect TID in Tid
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved1 );
    _USHORT( ParameterCount );
                                        // Buffer containing:
    //UCHAR PipeName[];                 //  "\PIPE\<name>0"
    //UCHAR Pad[]                       //  Pad to SHORT or LONG
    //UCHAR Param[];                    //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[]                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} SMB_TRANSACT_NAMED_PIPE;
typedef SMB_TRANSACT_NAMED_PIPE SMB_UNALIGNED *PSMB_TRANSACT_NAMED_PIPE;


//
// Transaction - QueryInformationNamedPipe, Level 1, output data format
//

typedef struct _NAMED_PIPE_INFORMATION_1 {
    _USHORT( OutputBufferSize );
    _USHORT( InputBufferSize );
    UCHAR MaximumInstances;
    UCHAR CurrentInstances;
    UCHAR PipeNameLength;
    UCHAR PipeName[1];
} NAMED_PIPE_INFORMATION_1;
typedef NAMED_PIPE_INFORMATION_1 SMB_UNALIGNED *PNAMED_PIPE_INFORMATION_1;

//
// Transaction - PeekNamedPipe, output format
//

typedef struct _RESP_PEEK_NMPIPE {
    _USHORT( ReadDataAvailable );
    _USHORT( MessageLength );
    _USHORT( NamedPipeState );
    //UCHAR Pad[];
    //UCHAR Data[];
} RESP_PEEK_NMPIPE;
typedef RESP_PEEK_NMPIPE SMB_UNALIGNED *PRESP_PEEK_NMPIPE;

//
// Define SMB pipe handle state bits used by Query/SetNamedPipeHandleState
//
// These number are the bit location of the fields in the handle state.
//

#define PIPE_COMPLETION_MODE_BITS   15
#define PIPE_PIPE_END_BITS          14
#define PIPE_PIPE_TYPE_BITS         10
#define PIPE_READ_MODE_BITS          8
#define PIPE_MAXIMUM_INSTANCES_BITS  0

/* DosPeekNmPipe() pipe states */

#define PIPE_STATE_DISCONNECTED 0x0001
#define PIPE_STATE_LISTENING    0x0002
#define PIPE_STATE_CONNECTED    0x0003
#define PIPE_STATE_CLOSING      0x0004

/* DosCreateNPipe and DosQueryNPHState state */

#define SMB_PIPE_READMODE_BYTE        0x0000
#define SMB_PIPE_READMODE_MESSAGE     0x0100
#define SMB_PIPE_TYPE_BYTE            0x0000
#define SMB_PIPE_TYPE_MESSAGE         0x0400
#define SMB_PIPE_END_CLIENT           0x0000
#define SMB_PIPE_END_SERVER           0x4000
#define SMB_PIPE_WAIT                 0x0000
#define SMB_PIPE_NOWAIT               0x8000
#define SMB_PIPE_UNLIMITED_INSTANCES  0x00FF


//
// Pipe name string for conversion between SMB and NT formats.
//

#define SMB_PIPE_PREFIX  "\\PIPE"
#define UNICODE_SMB_PIPE_PREFIX L"\\PIPE"
#define CANONICAL_PIPE_PREFIX "PIPE\\"
#define NT_PIPE_PREFIX   L"\\Device\\NamedPipe"

#define SMB_PIPE_PREFIX_LENGTH  (sizeof(SMB_PIPE_PREFIX) - 1)
#define UNICODE_SMB_PIPE_PREFIX_LENGTH \
                    (sizeof(UNICODE_SMB_PIPE_PREFIX) - sizeof(WCHAR))
#define CANONICAL_PIPE_PREFIX_LENGTH (sizeof(CANONICAL_PIPE_PREFIX) - 1)
#define NT_PIPE_PREFIX_LENGTH   (sizeof(NT_PIPE_PREFIX) - sizeof(WCHAR))

//
// Mailslot name strings.
//

#define SMB_MAILSLOT_PREFIX "\\MAILSLOT"
#define UNICODE_SMB_MAILSLOT_PREFIX L"\\MAILSLOT"

#define SMB_MAILSLOT_PREFIX_LENGTH (sizeof(SMB_MAILSLOT_PREFIX) - 1)
#define UNICODE_SMB_MAILSLOT_PREFIX_LENGTH \
                    (sizeof(UNICODE_SMB_MAILSLOT_PREFIX) - sizeof(WCHAR))

//
// NT Transaction subfunctions
//

#ifdef INCLUDE_SMB_OPEN_CLOSE

typedef struct _REQ_CREATE_WITH_SD_OR_EA {
    _ULONG( Flags );                   // Creation flags
    _ULONG( RootDirectoryFid );        // Optional directory for relative open
    ACCESS_MASK DesiredAccess;         // Desired access (NT format)
    LARGE_INTEGER AllocationSize;      // The initial allocation size in bytes
    _ULONG( FileAttributes );          // The file attributes
    _ULONG( ShareAccess );             // The share access
    _ULONG( CreateDisposition );       // Action to take if file exists or not
    _ULONG( CreateOptions );           // Options for creating a new file
    _ULONG( SecurityDescriptorLength );// Length of SD in bytes
    _ULONG( EaLength );                // Length of EA in bytes
    _ULONG( NameLength );              // Length of name in characters
    _ULONG( ImpersonationLevel );      // Security QOS information
    UCHAR SecurityFlags;               // Security QOS information
    UCHAR Buffer[1];
    //UCHAR Name[];                     // The name of the file (not NUL terminated)
} REQ_CREATE_WITH_SD_OR_EA;
typedef REQ_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PREQ_CREATE_WITH_SD_OR_EA;

//
// Data format:
//   UCHAR SecurityDesciptor[];
//   UCHAR Pad1[];        // Pad to LONG
//   UCHAR EaList[];
//

typedef struct _RESP_CREATE_WITH_SD_OR_EA {
    UCHAR OplockLevel;                  // The oplock level granted
    UCHAR Reserved;
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    _ULONG( EaErrorOffset );            // Offset of the EA error
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    BOOLEAN Directory;                  // TRUE if this is a directory
} RESP_CREATE_WITH_SD_OR_EA;
typedef RESP_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PRESP_CREATE_WITH_SD_OR_EA;

// No data bytes for the response


#endif //  INCLUDE_SMB_OPEN_CLOSE

//
// Setup words for NT I/O control request
//

typedef struct _REQ_NT_IO_CONTROL {
    _ULONG( FunctionCode );
    _USHORT( Fid );
    BOOLEAN IsFsctl;
    UCHAR   IsFlags;
} REQ_NT_IO_CONTROL;
typedef REQ_NT_IO_CONTROL SMB_UNALIGNED *PREQ_NT_IO_CONTROL;

//
// Request parameter bytes - The first buffer
// Request data bytes - The second buffer
//

//
// NT I/O Control response:
//
// Setup Words:  None.
// Parameter Bytes:  First buffer.
// Data Bytes: Second buffer.
//

//
// NT Notify directory change
//

// Request Setup Words

typedef struct _REQ_NOTIFY_CHANGE {
    _ULONG( CompletionFilter );              // Specifies operation to monitor
    _USHORT( Fid );                          // Fid of directory to monitor
    BOOLEAN WatchTree;                       // TRUE = watch all subdirectories too
    UCHAR Reserved;                          // MBZ
} REQ_NOTIFY_CHANGE;
typedef REQ_NOTIFY_CHANGE SMB_UNALIGNED *PREQ_NOTIFY_CHANGE;

//
// Request parameter bytes:  None
// Request data bytes:  None
//

//
// NT Notify directory change response
//
// Setup words:  None.
// Parameter bytes:  The change data buffer.
// Data bytes:  None.
//

//
// NT Set Security Descriptor request
//
// Setup words:  REQ_SET_SECURITY_DESCIPTOR.
// Parameter Bytes:  None.
// Data Bytes:  The Security Descriptor data.
//

typedef struct _REQ_SET_SECURITY_DESCRIPTOR {
    _USHORT( Fid );                    // FID of target
    _USHORT( Reserved );               // MBZ
    _ULONG( SecurityInformation );     // Fields of SD that to set
} REQ_SET_SECURITY_DESCRIPTOR;
typedef REQ_SET_SECURITY_DESCRIPTOR SMB_UNALIGNED *PREQ_SET_SECURITY_DESCRIPTOR;

//
// NT Set Security Desciptor response
//
// Setup words:  None.
// Parameter Bytes:  None.
// Data Bytes:  None.
//

//
// NT Query Security Descriptor request
//
// Setup words:  None.
// Parameter Bytes:  REQ_QUERY_SECURITY_DESCRIPTOR.
// Data Bytes:  None.
//

typedef struct _REQ_QUERY_SECURITY_DESCRIPTOR {
    _USHORT( Fid );                    // FID of target
    _USHORT( Reserved );               // MBZ
    _ULONG( SecurityInformation );     // Fields of SD that to query
} REQ_QUERY_SECURITY_DESCRIPTOR;
typedef REQ_QUERY_SECURITY_DESCRIPTOR SMB_UNALIGNED *PREQ_QUERY_SECURITY_DESCRIPTOR;

//
// NT Query Security Desciptor response
//
// Parameter bytes:  RESP_QUERY_SECURITY_DESCRIPTOR
// Data Bytes:  The Security Descriptor data.
//

typedef struct _RESP_QUERY_SECURITY_DESCRIPTOR {
    _ULONG( LengthNeeded );           // Size of data buffer required for SD
} RESP_QUERY_SECURITY_DESCRIPTOR;
typedef RESP_QUERY_SECURITY_DESCRIPTOR SMB_UNALIGNED *PRESP_QUERY_SECURITY_DESCRIPTOR;

//
// NT Rename file
//
// Setup words: None
// Parameters bytes:  REQ_NT_RENAME
// Data bytes: None
//

typedef struct _REQ_NT_RENAME {
    _USHORT( Fid );                    // FID of file to rename
    _USHORT( RenameFlags );            // defined below
    UCHAR NewName[];                   // New file name.
} REQ_NT_RENAME;
typedef REQ_NT_RENAME SMB_UNALIGNED *PREQ_NT_RENAME;

//
// Rename flags defined
//

#define SMB_RENAME_REPLACE_IF_EXISTS   1

//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING

//
// The following macros store and retrieve USHORTS and ULONGS from
// potentially unaligned addresses, avoiding alignment faults.  They
// would best be written as inline assembly code.
//
// The macros are designed to be used for accessing SMB fields.  Such
// fields are always stored in little-endian byte order, so these macros
// do byte swapping when compiled for a big-endian machine.
//
// !!! Not yet.
//

#if !SMBDBG

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

#endif

//++
//
// USHORT
// SmbGetUshort (
//     IN PSMB_USHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a USHORT value from the possibly misaligned
//     source address, avoiding alignment faults.
//
// Arguments:
//
//     SrcAddress - where to retrieve USHORT value from
//
// Return Value:
//
//     USHORT - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbGetUshort(SrcAddress) *(PSMB_USHORT)(SrcAddress)
#else
#define SmbGetUshort(SrcAddress) (USHORT)(          \
            ( ( (PUCHAR)(SrcAddress) )[0]       ) | \
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 )   \
            )
#endif
#else
#define SmbGetUshort(SrcAddress) (USHORT)(                  \
            ( ( (PUCHAR)(SrcAddress ## S) )[0]       ) |    \
            ( ( (PUCHAR)(SrcAddress ## S) )[1] <<  8 )      \
            )
#endif

#else

USHORT
SmbGetUshort (
    IN PSMB_USHORT SrcAddress
    );

#endif

//++
//
// USHORT
// SmbGetAlignedUshort (
//     IN PUSHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a USHORT value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     SrcAddress - where to retrieve USHORT value from; must be aligned.
//
// Return Value:
//
//     USHORT - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbGetAlignedUshort(SrcAddress) *(SrcAddress)
#else
#define SmbGetAlignedUshort(SrcAddress) *(SrcAddress ## S)
#endif

#else

USHORT
SmbGetAlignedUshort (
    IN PUSHORT SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutUshort (
//     OUT PSMB_USHORT DestAddress,
//     IN USHORT Value
//     )
//
// Routine Description:
//
//     This macro stores a USHORT value at the possibly misaligned
//     destination address, avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store USHORT value.  Address may be
//         misaligned.
//
//     Value - USHORT to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbPutUshort(SrcAddress, Value) \
                            *(PSMB_USHORT)(SrcAddress) = (Value)
#else
#define SmbPutUshort(DestAddress,Value) {                   \
            ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);   \
            ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);   \
        }
#endif
#else
#define SmbPutUshort(DestAddress,Value) {                       \
            ( (PUCHAR)(DestAddress ## S) )[0] = BYTE_0(Value);  \
            ( (PUCHAR)(DestAddress ## S) )[1] = BYTE_1(Value);  \
        }
#endif

#else

VOID
SmbPutUshort (
    OUT PSMB_USHORT DestAddress,
    IN USHORT Value
    );

#endif

//++
//
// VOID
// SmbPutAlignedUshort (
//     OUT PUSHORT DestAddres,
//     IN USHORT Value
//     )
//
// Routine Description:
//
//     This macro stores a USHORT value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     DestAddress - where to store USHORT value.  Address may not be
//         misaligned.
//
//     Value - USHORT to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbPutAlignedUshort(DestAddress,Value) *(DestAddress) = (Value)
#else
#define SmbPutAlignedUshort(DestAddress,Value) *(DestAddress ## S) = (Value)
#endif

#else

VOID
SmbPutAlignedUshort (
    OUT PUSHORT DestAddress,
    IN USHORT Value
    );

#endif

//++
//
// VOID
// SmbMoveUshort (
//     OUT PSMB_USHORT DestAddress
//     IN PSMB_USHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro moves a USHORT value from the possibly misaligned
//     source address to the possibly misaligned destination address,
//     avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store USHORT value
//
//     SrcAddress - where to retrieve USHORT value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbMoveUshort(DestAddress, SrcAddress) \
        *(PSMB_USHORT)(DestAddress) = *(PSMB_USHORT)(SrcAddress)
#else
#define SmbMoveUshort(DestAddress,SrcAddress) {                         \
            ( (PUCHAR)(DestAddress) )[0] = ( (PUCHAR)(SrcAddress) )[0]; \
            ( (PUCHAR)(DestAddress) )[1] = ( (PUCHAR)(SrcAddress) )[1]; \
        }
#endif
#else
#define SmbMoveUshort(DestAddress,SrcAddress) {                                     \
            ( (PUCHAR)(DestAddress ## S) )[0] = ( (PUCHAR)(SrcAddress ## S) )[0];   \
            ( (PUCHAR)(DestAddress ## S) )[1] = ( (PUCHAR)(SrcAddress ## S) )[1];   \
        }
#endif

#else

VOID
SmbMoveUshort (
    OUT PSMB_USHORT DestAddress,
    IN PSMB_USHORT SrcAddress
    );

#endif

//++
//
// ULONG
// SmbGetUlong (
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the possibly misaligned
//     source address, avoiding alignment faults.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbGetUlong(SrcAddress) *(PSMB_ULONG)(SrcAddress)
#else
#define SmbGetUlong(SrcAddress) (ULONG)(                \
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |     \
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 ) |     \
            ( ( (PUCHAR)(SrcAddress) )[2] << 16 ) |     \
            ( ( (PUCHAR)(SrcAddress) )[3] << 24 )       \
            )
#endif
#else
#define SmbGetUlong(SrcAddress) (ULONG)(                    \
            ( ( (PUCHAR)(SrcAddress ## L) )[0]       ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[1] <<  8 ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[2] << 16 ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[3] << 24 )      \
            )
#endif

#else

ULONG
SmbGetUlong (
    IN PSMB_ULONG SrcAddress
    );

#endif

//++
//
// USHORT
// SmbGetAlignedUlong (
//     IN PULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from; must be aligned.
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbGetAlignedUlong(SrcAddress) *(SrcAddress)
#else
#define SmbGetAlignedUlong(SrcAddress) *(SrcAddress ## L)
#endif

#else

ULONG
SmbGetAlignedUlong (
    IN PULONG SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutUlong (
//     OUT PSMB_ULONG DestAddress,
//     IN ULONG Value
//     )
//
// Routine Description:
//
//     This macro stores a ULONG value at the possibly misaligned
//     destination address, avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbPutUlong(SrcAddress, Value) *(PSMB_ULONG)(SrcAddress) = Value
#else
#define SmbPutUlong(DestAddress,Value) {                    \
            ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);   \
            ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);   \
            ( (PUCHAR)(DestAddress) )[2] = BYTE_2(Value);   \
            ( (PUCHAR)(DestAddress) )[3] = BYTE_3(Value);   \
        }
#endif
#else
#define SmbPutUlong(DestAddress,Value) {                        \
            ( (PUCHAR)(DestAddress ## L) )[0] = BYTE_0(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[1] = BYTE_1(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[2] = BYTE_2(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[3] = BYTE_3(Value);  \
        }
#endif

#else

VOID
SmbPutUlong (
    OUT PSMB_ULONG DestAddress,
    IN ULONG Value
    );

#endif

//++
//
// VOID
// SmbPutAlignedUlong (
//     OUT PULONG DestAddres,
//     IN ULONG Value
//     )
//
// Routine Description:
//
//     This macro stores a ULONG value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     DestAddress - where to store ULONG value.  Address may not be
//         misaligned.
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbPutAlignedUlong(DestAddress,Value) *(DestAddress) = (Value)
#else
#define SmbPutAlignedUlong(DestAddress,Value) *(DestAddress ## L) = (Value)
#endif

#else

VOID
SmbPutAlignedUlong (
    OUT PULONG DestAddress,
    IN ULONG Value
    );

#endif

//++
//
// VOID
// SmbMoveUlong (
//     OUT PSMB_ULONG DestAddress,
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro moves a ULONG value from the possibly misaligned
//     source address to the possible misaligned destination address,
//     avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbMoveUlong(DestAddress,SrcAddress) \
        *(PSMB_ULONG)(DestAddress) = *(PSMB_ULONG)(SrcAddress)
#else
#define SmbMoveUlong(DestAddress,SrcAddress) {                          \
            ( (PUCHAR)(DestAddress) )[0] = ( (PUCHAR)(SrcAddress) )[0]; \
            ( (PUCHAR)(DestAddress) )[1] = ( (PUCHAR)(SrcAddress) )[1]; \
            ( (PUCHAR)(DestAddress) )[2] = ( (PUCHAR)(SrcAddress) )[2]; \
            ( (PUCHAR)(DestAddress) )[3] = ( (PUCHAR)(SrcAddress) )[3]; \
        }
#endif
#else
#define SmbMoveUlong(DestAddress,SrcAddress) {                                      \
            ( (PUCHAR)(DestAddress ## L) )[0] = ( (PUCHAR)(SrcAddress ## L) )[0];   \
            ( (PUCHAR)(DestAddress ## L) )[1] = ( (PUCHAR)(SrcAddress ## L) )[1];   \
            ( (PUCHAR)(DestAddress ## L) )[2] = ( (PUCHAR)(SrcAddress ## L) )[2];   \
            ( (PUCHAR)(DestAddress ## L) )[3] = ( (PUCHAR)(SrcAddress ## L) )[3];   \
        }
#endif

#else

VOID
SmbMoveUlong (
    OUT PSMB_ULONG DestAddress,
    IN PSMB_ULONG SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutDate (
//     OUT PSMB_DATE DestAddress,
//     IN SMB_DATE Value
//     )
//
// Routine Description:
//
//     This macro stores an SMB_DATE value at the possibly misaligned
//     destination address, avoiding alignment faults.  This macro
//     is different from SmbPutUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
// Arguments:
//
//     DestAddress - where to store SMB_DATE value
//
//     Value - SMB_DATE to store.  Value must be a constant or an
//         aligned field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbPutDate(DestAddress,Value) (DestAddress)->Ushort = (Value).Ushort
#else
#define SmbPutDate(DestAddress,Value) {                                     \
            ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0((Value).Ushort); \
            ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1((Value).Ushort); \
        }
#endif

#else

VOID
SmbPutDate (
    OUT PSMB_DATE DestAddress,
    IN SMB_DATE Value
    );

#endif

//++
//
// VOID
// SmbMoveDate (
//     OUT PSMB_DATE DestAddress,
//     IN PSMB_DATE SrcAddress
//     )
//
// Routine Description:
//
//     This macro copies an SMB_DATE value from the possibly misaligned
//     source address, avoiding alignment faults.  This macro is
//     different from SmbGetUshort in order to be able to handle funny
//     bitfield / big-endian interactions.
//
//     Note that there is no SmbGetDate because of the way SMB_DATE is
//     defined.  It is a union containing a USHORT and a bitfield
//     struct.  The caller of an SmbGetDate macro would have to
//     explicitly use one part of the union.
//
// Arguments:
//
//     DestAddress - where to store SMB_DATE value.  MUST BE ALIGNED!
//
//     SrcAddress - where to retrieve SMB_DATE value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbMoveDate(DestAddress,SrcAddress)     \
            (DestAddress)->Ushort = (SrcAddress)->Ushort
#else
#define SmbMoveDate(DestAddress,SrcAddress)                         \
            (DestAddress)->Ushort =                                 \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |    \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 )
#endif

#else

VOID
SmbMoveDate (
    OUT PSMB_DATE DestAddress,
    IN PSMB_DATE SrcAddress
    );

#endif

//++
//
// VOID
// SmbZeroDate (
//     IN PSMB_DATE Date
//     )
//
// Routine Description:
//
//     This macro zeroes a possibly misaligned SMB_DATE field.
//
// Arguments:
//
//     Date - Pointer to SMB_DATE field to zero.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbZeroDate(Date) (Date)->Ushort = 0
#else
#define SmbZeroDate(Date) {                     \
            ( (PUCHAR)&(Date)->Ushort )[0] = 0; \
            ( (PUCHAR)&(Date)->Ushort )[1] = 0; \
        }
#endif

#else

VOID
SmbZeroDate (
    IN PSMB_DATE Date
    );

#endif

//++
//
// BOOLEAN
// SmbIsDateZero (
//     IN PSMB_DATE Date
//     )
//
// Routine Description:
//
//     This macro returns TRUE if the supplied SMB_DATE value is zero.
//
// Arguments:
//
//     Date - Pointer to SMB_DATE value to check.  MUST BE ALIGNED!
//
// Return Value:
//
//     BOOLEAN - TRUE if Date is zero, else FALSE.
//
//--

#if !SMBDBG

#define SmbIsDateZero(Date) ( (Date)->Ushort == 0 )

#else

BOOLEAN
SmbIsDateZero (
    IN PSMB_DATE Date
    );

#endif

//++
//
// VOID
// SmbPutTime (
//     OUT PSMB_TIME DestAddress,
//     IN SMB_TIME Value
//     )
//
// Routine Description:
//
//     This macro stores an SMB_TIME value at the possibly misaligned
//     destination address, avoiding alignment faults.  This macro
//     is different from SmbPutUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
// Arguments:
//
//     DestAddress - where to store SMB_TIME value
//
//     Value - SMB_TIME to store.  Value must be a constant or an
//         aligned field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbPutTime(DestAddress,Value) (DestAddress)->Ushort = (Value).Ushort
#else
#define SmbPutTime(DestAddress,Value) {                                     \
            ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0((Value).Ushort); \
            ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1((Value).Ushort); \
        }
#endif

#else

VOID
SmbPutTime (
    OUT PSMB_TIME DestAddress,
    IN SMB_TIME Value
    );

#endif

//++
//
// VOID
// SmbMoveTime (
//     OUT PSMB_TIME DestAddress,
//     IN PSMB_TIME SrcAddress
//     )
//
// Routine Description:
//
//     This macro copies an SMB_TIME value from the possibly
//     misaligned source address, avoiding alignment faults.  This macro
//     is different from SmbGetUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
//     Note that there is no SmbGetTime because of the way SMB_TIME is
//     defined.  It is a union containing a USHORT and a bitfield
//     struct.  The caller of an SmbGetTime macro would have to
//     explicitly use one part of the union.
//
// Arguments:
//
//     DestAddress - where to store SMB_TIME value.  MUST BE ALIGNED!
//
//     SrcAddress - where to retrieve SMB_TIME value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbMoveTime(DestAddress,SrcAddress) \
                (DestAddress)->Ushort = (SrcAddress)->Ushort
#else
#define SmbMoveTime(DestAddress,SrcAddress)                         \
            (DestAddress)->Ushort =                                 \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |    \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 )
#endif

#else

VOID
SmbMoveTime (
    OUT PSMB_TIME DestAddress,
    IN PSMB_TIME SrcAddress
    );

#endif

//++
//
// VOID
// SmbZeroTime (
//     IN PSMB_TIME Time
//     )
//
// Routine Description:
//
//     This macro zeroes a possibly misaligned SMB_TIME field.
//
// Arguments:
//
//     Time - Pointer to SMB_TIME field to zero.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbZeroTime(Time) (Time)->Ushort = 0
#else
#define SmbZeroTime(Time) {                     \
            ( (PUCHAR)&(Time)->Ushort )[0] = 0; \
            ( (PUCHAR)&(Time)->Ushort )[1] = 0; \
        }
#endif

#else

VOID
SmbZeroTime (
    IN PSMB_TIME Time
    );

#endif

//++
//
// BOOLEAN
// SmbIsTimeZero (
//     IN PSMB_TIME Time
//     )
//
// Routine Description:
//
//     This macro returns TRUE if the supplied SMB_TIME value is zero.
//
// Arguments:
//
//     Time - Pointer to SMB_TIME value to check.  Must be aligned and
//         in native format!
//
// Return Value:
//
//     BOOLEAN - TRUE if Time is zero, else FALSE.
//
//--

#if !SMBDBG

#define SmbIsTimeZero(Time) ( (Time)->Ushort == 0 )

#else

BOOLEAN
SmbIsTimeZero (
    IN PSMB_TIME Time
    );

#endif


//
//
//      Define protocol names
//
//


//
//      PCNET1 is the original SMB protocol (CORE).
//

#define PCNET1          "PC NETWORK PROGRAM 1.0"

//
//      Some versions of the original MSNET defined this as an alternate
//      to the core protocol name
//

#define PCLAN1          "PCLAN1.0"

//
//      This is used for the MS-NET 1.03 product.  It defines Lock&Read,
//      Write&Unlock, and a special version of raw read and raw write.
//
#define MSNET103        "MICROSOFT NETWORKS 1.03"

//
//      This is the  DOS Lanman 1.0 specific protocol.  It is equivilant
//      to the LANMAN 1.0 protocol, except the server is required to
//      map errors from the OS/2 error to an appropriate DOS error.
//
#define MSNET30         "MICROSOFT NETWORKS 3.0"

//
//      This is the first version of the full LANMAN 1.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 2.0 document.
//

#define LANMAN10        "LANMAN1.0"

//
//      This is the first version of the full LANMAN 2.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 3.0 document.  Note
//      that the name is an interim protocol definition.  This is for
//      interoperability with IBM LAN SERVER 1.2
//

#define LANMAN12        "LM1.2X002"

//
//      This is the dos equivilant of the LANMAN12 protocol.  It is identical
//      to the LANMAN12 protocol, but the server will perform error mapping
//      to appropriate DOS errors.
//
#define DOSLANMAN12     "DOS LM1.2X002" /* DOS equivalant of above.  Final
                                         * string will be "DOS LANMAN2.0" */

//
//      Strings for LANMAN 2.1.
//
#define LANMAN21 "LANMAN2.1"
#define DOSLANMAN21 "DOS LANMAN2.1"

//
//       !!! Do not set to final protcol string until the spec
//           is cast in stone.
//
//       The SMB protocol designed for NT.  This has special SMBs
//       which duplicate the NT semantics.
//
#define NTLANMAN "NT LM 0.12"


//
//      The XENIXCORE dialect is a bit special.  It is identical to core,
//      except user passwords are not to be uppercased before being shipped
//      to the server
//
#define XENIXCORE       "XENIX CORE"


//
//      Windows for Workgroups V1.0
//
#define WFW10           "Windows for Workgroups 3.1a"


#define PCNET1_SZ       22
#define PCLAN1_SZ        8

#define MSNET103_SZ     23
#define MSNET30_SZ      22

#define LANMAN10_SZ      9
#define LANMAN12_SZ      9

#define DOSLANMAN12_SZ  13



/*
 * Defines and data for Negotiate Protocol
 */
#define PC1             0
#define PC2             1
#define LM1             2
#define MS30            3
#define MS103           4
#define LM12            5
#define DOSLM12         6


/*  Protocol indexes definition.  */
#define PCLAN           1               /* PC Lan 1.0 & MS Lan 1.03 */
#define MSNT30          2               /* MS Net 3.0 redirector    */
#define DOSLM20         3               /* Dos LAN Manager 2.0      */
#define LANMAN          4               /* Lanman redirector        */
#define LANMAN20        5               /* Lan Manager 2.0          */

//
//  Protocol specific path constraints.
//

#define MAXIMUM_PATHLEN_LANMAN12        260
#define MAXIMUM_PATHLEN_CORE            128

#define MAXIMUM_COMPONENT_LANMAN12      254
#define MAXIMUM_COMPONENT_CORE          8+1+3 // 8.3 filenames.



#endif // _CIFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\fcbtable.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.h

Abstract:

    This module defines the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:

    Balan Sethu Raman (SethuR)    10/17/96

Revision History:

    This was derived from the original implementation of prefix tables done
    by Joe Linn.

--*/


#ifndef _RXFCBTABLE_
#define _RXFCBTABLE_

typedef struct _RX_FCB_TABLE_ENTRY {

    //
    //  Normal Header for Refcounted Structure
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  the computed hash value
    //

    ULONG HashValue;

    //
    //  the path associated with the FCB
    //

    UNICODE_STRING Path;

    //
    //  the threaded list of all entries in a bucket.
    //

    LIST_ENTRY HashLinks;

    //
    //  Statistics for amortising lookup costs
    //

    LONG Lookups;
} RX_FCB_TABLE_ENTRY, *PRX_FCB_TABLE_ENTRY;


#define RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS 32

typedef struct _RX_FCB_TABLE {

    //
    //  Normal Header for refcounted data structures
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  version stamp changes on each insertion/removal
    //

    ULONG Version;

    BOOLEAN CaseInsensitiveMatch;
    USHORT NumberOfBuckets;

    //
    //  Statistics for table maintenance
    //

    LONG Lookups;
    LONG FailedLookups;
    LONG Compares;

    //
    //  Resource used to control table access
    //

    ERESOURCE TableLock;

    //
    //  TableEntry for the Null string
    //

    PRX_FCB_TABLE_ENTRY TableEntryForNull;

    //
    //  the hash buckets
    //

    LIST_ENTRY HashBuckets[RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS];
} RX_FCB_TABLE, *PRX_FCB_TABLE;

extern
VOID
RxInitializeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN BOOLEAN CaseInsensitiveMatch
    );

extern 
VOID
RxFinalizeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable
    );

extern 
PFCB
RxFcbTableLookupFcb (
    IN  PRX_FCB_TABLE FcbTable,
    IN  PUNICODE_STRING Path
    );

extern 
NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    );

extern 
NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    );

#define RxAcquireFcbTableLockShared(TABLE,WAIT) \
        ExAcquireResourceSharedLite( &(TABLE)->TableLock, WAIT )

#define RxAcquireFcbTableLockExclusive(TABLE,WAIT) \
        ExAcquireResourceExclusiveLite( &(TABLE)->TableLock, WAIT )

#define RxReleaseFcbTableLock(TABLE)  \
        ExReleaseResourceLite( &(TABLE)->TableLock )

#define RxIsFcbTableLockExclusive(TABLE) ExIsResourceAcquiredExclusiveLite( &(TABLE)->TableLock )

#define RxIsFcbTableLockAcquired(TABLE) ( ExIsResourceAcquiredSharedLite( &(TABLE)->TableLock ) || \
                                          ExIsResourceAcquiredExclusiveLite( &(TABLE)->TableLock ) )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\mrx.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrx.h

Abstract:

    This module defines the interface between the MINI Redirectors and the RDBSS.
    The inteface is a dispatch table for the normal file system operations. In
    addition routines are provided for registrations/deregistration of mini
    redirectors.

Author:

    Joe Linn (JoeLinn)    8-17-94

Revision History:

Notes:

    The interface definition between the mini redirectors and the wrapper
    consists of two parts, the data structures used and the dispatch vector.
    The data structures are defined in mrxfcb.h while the signatures of the
    various entries in the dispatch vector and the dispatch vector itself is
    defined in this file.

--*/

#ifndef _RXMINIRDR_
#define _RXMINIRDR_

//
//  RDBSS data structures shared with the mini redirectors
//

#include <mrxfcb.h>     

//        
//  The following macros encapsulate commonly used operations in the mini redirector.
//  These include setting the status/information associated with the completion of
//  a request etc.
//


//  
//  The following three macros are used for passing back operation status from the  
//  minirdr to the NT wrapper. information passed back is either the open_action
//  for a create or the actual byte count or an operation. these should be passed
//  back directly in the rxcontext.
//

#define RxSetIoStatusStatus(RXCONTEXT, STATUS)  \
            (RXCONTEXT)->CurrentIrp->IoStatus.Status = (STATUS)

#define RxSetIoStatusInfo(RXCONTEXT, INFORMATION) \
             ((RXCONTEXT))->CurrentIrp->IoStatus.Information = (INFORMATION)

#define RxGetIoStatusInfo(RXCONTEXT) \
             ((RXCONTEXT)->CurrentIrp->IoStatus.Information)

#define RxShouldPostCompletion()  ((KeGetCurrentIrql() >= DISPATCH_LEVEL))

//
//  The mini rdr's register/unregister with the RDBSS whenever they are loaded/unloaded.
//  The registartion process is a two way hand shake in which the mini rdr informs the RDBSS
//  by invoking the registartion routine. The RDBSS completes the initialization by invoking
//  the Start routine in the dispatch vector.
//

#define RX_REGISTERMINI_FLAG_DONT_PROVIDE_UNCS            0x00000001
#define RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS       0x00000002
#define RX_REGISTERMINI_FLAG_DONT_INIT_DRIVER_DISPATCH    0x00000004
#define RX_REGISTERMINI_FLAG_DONT_INIT_PREFIX_N_SCAVENGER 0x00000008

NTSTATUS
NTAPI
RxRegisterMinirdr (
    OUT PRDBSS_DEVICE_OBJECT *DeviceObject, //  the deviceobject that was created
    IN OUT PDRIVER_OBJECT DriverObject,     //  the minirdr driver object
    IN PMINIRDR_DISPATCH MrdrDispatch,      //  the mini rdr dispatch vector
    IN ULONG Controls,
    IN PUNICODE_STRING DeviceName,
    IN ULONG DeviceExtensionSize,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics
    );

VOID
NTAPI
RxMakeLateDeviceAvailable (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
NTAPI
__RxFillAndInstallFastIoDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN OUT PFAST_IO_DISPATCH FastIoDispatch,
    IN ULONG FastIoDispatchSize
    );
#define RxFillAndInstallFastIoDispatch(__devobj,__fastiodisp) {\
    __RxFillAndInstallFastIoDispatch(&__devobj->RxDeviceObject,\
                                     &__fastiodisp,            \
                                     sizeof(__fastiodisp)); \
    }

VOID
NTAPI
RxpUnregisterMinirdr (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
RxStartMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
RxStopMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
RxSetDomainForMailslotBroadcast (
    IN PUNICODE_STRING DomainName
    );

NTSTATUS
RxFsdDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    );

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN) (
    IN OUT PRX_CONTEXT RxContext
    );

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_CTX) (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

typedef
NTSTATUS
(NTAPI *PMRX_CHKDIR_CALLDOWN) (
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING DirectoryName
    );

typedef
NTSTATUS
(NTAPI *PMRX_CHKFCB_CALLDOWN) (
    IN PFCB Fcb1,
    IN PFCB Fcb2
    );

//
//  The two important abstractions used in the interface between the mini rdr and RDBSS are
//  Server Calls and Net Roots. The former corresponds to the context associated with a
//  server with which a connection has been established and the later corresponds to a
//  share on a server ( This could also be viewed as a portion of the name space which has
//  been claimed by a mini rdr).
//
//  The creation of Server calls and net roots typically involve atleast one network round trip.
//  In order to provide for asynchronous operations to continue these operations are modelled
//  as a two phase activity. Each calldown to a mini rdr for creating a server call and net root is
//  accompanied by a callup from the mini rdr to the RDBSS notifying with the completion status
//  of the request. Currently these are synchronous!
//
//  The creation of Srv calls is further complicated by the fact that the RDBSS has to choose
//  from a number of mini rdr's to establish a connection with a server. In order to provide
//  the RDBSS with maximum flexibility in choosing the mini rdr's that it wishes to deploy the
//  creation of server calls involves a third phase in which the RDBSS notifies the mini rdr of
//  a winner. All the losing mini rdrs destroy the associated context.
//

typedef enum _RX_BLOCK_CONDITION {
    Condition_Uninitialized = 0,
    Condition_InTransition,
    Condition_Closing,
    Condition_Good,
    Condition_Bad,
    Condition_Closed
    } RX_BLOCK_CONDITION, *PRX_BLOCK_CONDITION;

#define StableCondition(X) ((X) >= Condition_Good)

//    
//  The routine for notifying the RDBSS about the completion status of the NetRoot creation
//  request.
//    

typedef
VOID
(NTAPI *PMRX_NETROOT_CALLBACK) (
    IN OUT PMRX_CREATENETROOT_CONTEXT CreateContext
    );

//
//  this routine allows the minirdr to specify the netrootname. NetRootName and RestOfName are set
//  to point to the appropriate places within FilePathName. SrvCall is used to find the lengthof the srvcallname.
//

typedef
VOID
(NTAPI *PMRX_EXTRACT_NETROOT_NAME) (
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );
//
//  The resumption context for the RDBSS.
//

typedef struct _MRX_CREATENETROOT_CONTEXT {
    PRX_CONTEXT RxContext;
    PV_NET_ROOT pVNetRoot;
    KEVENT FinishEvent;
    NTSTATUS VirtualNetRootStatus;
    NTSTATUS NetRootStatus;
    RX_WORK_QUEUE_ITEM WorkQueueItem;
    PMRX_NETROOT_CALLBACK Callback;
} MRX_CREATENETROOT_CONTEXT, *PMRX_CREATENETROOT_CONTEXT;

//
//  the calldown from RDBSS to the mini rdr for creating a netroot.
//

typedef
NTSTATUS
(NTAPI *PMRX_CREATE_V_NET_ROOT) (
    IN OUT PMRX_CREATENETROOT_CONTEXT Context
    );

//
//  the calldown for querying a net root state.
//

typedef
NTSTATUS
(NTAPI *PMRX_UPDATE_NETROOT_STATE) (
    IN OUT PMRX_NET_ROOT NetRoot
    );

//
//  The resumption context for the RDBSS.
//
typedef struct _MRX_SRVCALL_CALLBACK_CONTEXT {
    struct _MRX_SRVCALLDOWN_STRUCTURE *SrvCalldownStructure; //  could be computed
    ULONG CallbackContextOrdinal;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    NTSTATUS Status;
    PVOID RecommunicateContext;
} MRX_SRVCALL_CALLBACK_CONTEXT, *PMRX_SRVCALL_CALLBACK_CONTEXT;


//
//  The routine for notifying the RDBSS about the completion status of the SrvCall creation
//  request.
//

typedef
VOID
(NTAPI *PMRX_SRVCALL_CALLBACK) (
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT Context
    );

//
//  The context passed from the RDBSS to the mini rdr for creating a server call.
//

typedef struct _MRX_SRVCALLDOWN_STRUCTURE {
    KEVENT FinishEvent;
    LIST_ENTRY SrvCalldownList;
    PRX_CONTEXT RxContext;
    PMRX_SRV_CALL SrvCall;
    PMRX_SRVCALL_CALLBACK CallBack;
    BOOLEAN CalldownCancelled;
    ULONG NumberRemaining;
    ULONG NumberToWait;
    ULONG BestFinisherOrdinal;
    PRDBSS_DEVICE_OBJECT BestFinisher;
    MRX_SRVCALL_CALLBACK_CONTEXT CallbackContexts[1];
} MRX_SRVCALLDOWN_STRUCTURE;

//
//  the calldown from the RDBSS to the mini rdr for creating a server call
//

typedef
NTSTATUS
(NTAPI *PMRX_CREATE_SRVCALL) (
    IN OUT PMRX_SRV_CALL SrvCall,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT SrvCallCallBackContext
    );
//
//  the calldown from the RDBSS to the mini rdr for notifying the mini rdr's of the winner.
//

typedef
NTSTATUS
(NTAPI *PMRX_SRVCALL_WINNER_NOTIFY)(
    IN OUT PMRX_SRV_CALL SrvCall,
    IN BOOLEAN ThisMinirdrIsTheWinner,
    IN OUT PVOID RecommunicateContext
    );

//
//  The prototypes for calldown routines relating to various file system operations
//

typedef
VOID
(NTAPI *PMRX_NEWSTATE_CALLDOWN) (
    IN OUT PVOID Context
    );

typedef
NTSTATUS
(NTAPI *PMRX_DEALLOCATE_FOR_FCB) (
    IN OUT PMRX_FCB Fcb
    );

typedef
NTSTATUS
(NTAPI *PMRX_DEALLOCATE_FOR_FOBX) (
    IN OUT PMRX_FOBX Fobx
    );

typedef
NTSTATUS
(NTAPI *PMRX_IS_LOCK_REALIZABLE) (
    IN OUT PMRX_FCB Fcb,
    IN PLARGE_INTEGER ByteOffset,
    IN PLARGE_INTEGER Length,
    IN ULONG LowIoLockFlags
    );

typedef
NTSTATUS
(NTAPI *PMRX_FORCECLOSED_CALLDOWN) (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

typedef
NTSTATUS
(NTAPI *PMRX_FINALIZE_SRVCALL_CALLDOWN) (
    IN OUT PMRX_SRV_CALL SrvCall,
    IN BOOLEAN Force
    );

typedef
NTSTATUS
(NTAPI *PMRX_FINALIZE_V_NET_ROOT_CALLDOWN) (
    IN OUT PMRX_V_NET_ROOT VirtualNetRoot,
    IN PBOOLEAN Force
    );

typedef
NTSTATUS
(NTAPI *PMRX_FINALIZE_NET_ROOT_CALLDOWN) (
    IN OUT PMRX_NET_ROOT NetRoot,
    IN PBOOLEAN Force
    );

typedef
ULONG
(NTAPI *PMRX_EXTENDFILE_CALLDOWN) (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLARGE_INTEGER NewFileSize,
    OUT PLARGE_INTEGER NewAllocationSize
    );

typedef
BOOLEAN
(*PRX_LOCK_ENUMERATOR) (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    );
typedef
NTSTATUS
(NTAPI *PMRX_CHANGE_BUFFERING_STATE_CALLDOWN) (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN PVOID MRxContext
    );

typedef
NTSTATUS
(NTAPI *PMRX_PREPARSE_NAME) (
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name
    );

typedef
NTSTATUS
(NTAPI *PMRX_GET_CONNECTION_ID) (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PRX_CONNECTION_ID UniqueId
    );

//
//  Buffering state/Policy management TBD
//
typedef enum _MINIRDR_BUFSTATE_COMMANDS {
    MRDRBUFSTCMD__COMMAND_FORCEPURGE0,
    MRDRBUFSTCMD__1,
    MRDRBUFSTCMD__2,
    MRDRBUFSTCMD__3,
    MRDRBUFSTCMD__4,
    MRDRBUFSTCMD__5,
    MRDRBUFSTCMD__6,
    MRDRBUFSTCMD__7,
    MRDRBUFSTCMD__8,
    MRDRBUFSTCMD__9,
    MRDRBUFSTCMD__10,
    MRDRBUFSTCMD__11,
    MRDRBUFSTCMD__12,
    MRDRBUFSTCMD__13,
    MRDRBUFSTCMD__14,
    MRDRBUFSTCMD__15,
    MRDRBUFSTCMD__16,
    MRDRBUFSTCMD__17,
    MRDRBUFSTCMD__18,
    MRDRBUFSTCMD__19,
    MRDRBUFSTCMD__20,
    MRDRBUFSTCMD__21,
    MRDRBUFSTCMD__22,
    MRDRBUFSTCMD__23,
    MRDRBUFSTCMD__24,
    MRDRBUFSTCMD__25,
    MRDRBUFSTCMD__26,
    MRDRBUFSTCMD__27,
    MRDRBUFSTCMD__28,
    MRDRBUFSTCMD__29,
    MRDRBUFSTCMD__30,
    MRDRBUFSTCMD__31,
    MRDRBUFSTCMD_MAXXX
} MINIRDR_BUFSTATE_COMMANDS;


#define MINIRDR_BUFSTATE_COMMAND_FORCEPURGE 0x00000001
#define MINIRDR_BUFSTATE_COMMAND_MASK       ((MINIRDR_BUFSTATE_COMMAND_FORCEPURGE))

typedef
NTSTATUS
(NTAPI *PMRX_COMPUTE_NEW_BUFFERING_STATE) (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN PVOID MRxContext,
    OUT PULONG NewBufferingState
    );

typedef enum _LOWIO_OPS {
  LOWIO_OP_READ=0,
  LOWIO_OP_WRITE,
  LOWIO_OP_SHAREDLOCK,
  LOWIO_OP_EXCLUSIVELOCK,
  LOWIO_OP_UNLOCK,
  LOWIO_OP_UNLOCK_MULTIPLE,
  //LOWIO_OP_UNLOCKALLBYKEY,
  LOWIO_OP_FSCTL,
  LOWIO_OP_IOCTL,
  LOWIO_OP_NOTIFY_CHANGE_DIRECTORY,
  LOWIO_OP_CLEAROUT,
  LOWIO_OP_MAXIMUM
} LOWIO_OPS;

typedef
NTSTATUS
(NTAPI *PLOWIO_COMPLETION_ROUTINE) (
    IN PRX_CONTEXT RxContext
    );

typedef LONGLONG RXVBO;

//
//  we may, at some point, want a smarter implementation of this. we don't statically allocate the first
//  element because that would make unlock behind much harder.
//

typedef struct _LOWIO_LOCK_LIST {
    
    struct _LOWIO_LOCK_LIST * Next;
    ULONG LockNumber;
    RXVBO ByteOffset;
    LONGLONG Length;
    BOOLEAN ExclusiveLock;

} LOWIO_LOCK_LIST, *PLOWIO_LOCK_LIST;

VOID
NTAPI
RxFinalizeLockList(
    struct _RX_CONTEXT *RxContext
    );

typedef struct _XXCTL_LOWIO_COMPONENT {
    ULONG Flags;
    union {
       ULONG FsControlCode;
       ULONG IoControlCode;
    };
    ULONG InputBufferLength;
    PVOID pInputBuffer;
    ULONG OutputBufferLength;
    PVOID pOutputBuffer;
    UCHAR MinorFunction;
} XXCTL_LOWIO_COMPONENT;

typedef struct _LOWIO_CONTEXT {
    USHORT Operation;  //  padding!
    USHORT Flags;
    PLOWIO_COMPLETION_ROUTINE CompletionRoutine;
    PERESOURCE Resource;
    ERESOURCE_THREAD ResourceThreadId;
    union {
        struct {
           ULONG Flags;
           PMDL Buffer;
           RXVBO ByteOffset;
           ULONG ByteCount;
           ULONG Key;
           PNON_PAGED_FCB NonPagedFcb;
        } ReadWrite;
        struct {
           union {
               PLOWIO_LOCK_LIST LockList;
               LONGLONG       Length;
           };
           // 
           //  these fields are not used if locklist is used
           //

           ULONG          Flags;
           RXVBO          ByteOffset;
           ULONG          Key;
        } Locks;
        XXCTL_LOWIO_COMPONENT FsCtl;
        XXCTL_LOWIO_COMPONENT IoCtl; //  these must be the same
        struct {
           BOOLEAN        WatchTree;
           ULONG          CompletionFilter;
           ULONG          NotificationBufferLength;
           PVOID          pNotificationBuffer;
        } NotifyChangeDirectory;
    } ParamsFor;
} LOWIO_CONTEXT;

#define LOWIO_CONTEXT_FLAG_SYNCCALL    0x0001  //  this is set if lowiocompletion is called from lowiosubmit
#define LOWIO_CONTEXT_FLAG_SAVEUNLOCKS 0x0002  //  WRAPPER INTERNAL: on NT, it means the unlock routine add unlocks to the list
#define LOWIO_CONTEXT_FLAG_LOUDOPS     0x0004  //  WRAPPER INTERNAL: on NT, it means read and write routines generate dbg output
#define LOWIO_CONTEXT_FLAG_CAN_COMPLETE_AT_DPC_LEVEL     0x0008  //  WRAPPER INTERNAL: on NT, it means the completion routine maybe can
                                                                 //    complete when called at DPC. otherwise it cannnot. currently
                                                                 //    none can.

#define LOWIO_READWRITEFLAG_PAGING_IO          0x01
#define LOWIO_READWRITEFLAG_EXTENDING_FILESIZE 0x02
#define LOWIO_READWRITEFLAG_EXTENDING_VDL      0x04

//
//  these must match the SL_ values in io.h (ntifs.h) since the flags field is just copied
//

#define LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY 0x01
#define LOWIO_LOCKSFLAG_EXCLUSIVELOCK    0x02

#if (LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY!=SL_FAIL_IMMEDIATELY)
#error LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY!=SL_FAIL_IMMEDIATELY
#endif
#if (LOWIO_LOCKSFLAG_EXCLUSIVELOCK!=SL_EXCLUSIVE_LOCK)
#error LOWIO_LOCKSFLAG_EXCLUSIVELOCK!=SL_EXCLUSIVE_LOCK
#endif

//
//  The six important data structures (SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and
//  FOBX) that are an integral part of the mini rdr architecture have a corresponding
//  counterpart in every mini rdr implementation. In order to provide maximal flexibility
//  and at the same time enhance performance the sizes and the desired allocation
//  behaviour are communicated at the registration time of a mini rdr.
//
//  There is no single way in which these extensions can be managed which will
//  address the concerns of flexibility as well as performance. The solution adopted
//  in the current architecture that meets the dual goals in most cases. The solution
//  and the rationale is as follows ...
//
//  Each mini rdr implementor specifies the size of the data structure extensions
//  alongwith a flag specfying if the allocation/free of the extensions are to be
//  managed by the wrapper.
//  
//  In all those cases where a one to one relationship exists between the wrapper
//  data structure and the corresponding mini rdr counterpart specifying the flag
//  results in maximal performance gains. There are a certain data structures for
//  which many instances of a wrapper data structure map onto the same extension in
//  the mini redirector. In such cases the mini rdr implementor will be better off
//  managing the allocation/deallocation of the data structure extension without the
//  intervention of the wrapper.
//
//  Irrespective of the mechanism choosen the convention is to always associate the
//  extension with the Context field in the corresponding RDBSS data structure.
//  !!!NO EXCEPTIONS!!!
//
//  The remaining field in all the RDBSS data structures, i.e., Context2 is left to
//  the discretion og the mini rdr implementor.
//
//
//  The SRV_CALL extension is not handled currently. This is because of further fixes
//  required in RDBSS w.r.t the mecahsnism used to select the mini rdr and to allow several
//  minis to share the srvcall.
//
//  Please do not use it till further notice; rather, the mini should manage its own srcall
//  storage. There is a finalization calldown that assists in this endeavor.
//

#define RDBSS_MANAGE_SRV_CALL_EXTENSION   (0x1)
#define RDBSS_MANAGE_NET_ROOT_EXTENSION   (0x2)
#define RDBSS_MANAGE_V_NET_ROOT_EXTENSION (0x4)
#define RDBSS_MANAGE_FCB_EXTENSION        (0x8)
#define RDBSS_MANAGE_SRV_OPEN_EXTENSION   (0x10)
#define RDBSS_MANAGE_FOBX_EXTENSION       (0x20)

#define RDBSS_NO_DEFERRED_CACHE_READAHEAD    (0x1000)

typedef struct _MINIRDR_DISPATCH {

    //
    //  Normal Header
    //

    NODE_TYPE_CODE NodeTypeCode;                  
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Flags to control the allocation of extensions.
    //  and various other per-minirdr policies
    //

    ULONG MRxFlags;                

    //
    //  size of the SRV_CALL extensions
    //

    ULONG MRxSrvCallSize;          

    //
    //  size of the NET_ROOT extensions
    //

    ULONG MRxNetRootSize;          

    //
    //  size of the V_NET_ROOT extensions
    //

    ULONG MRxVNetRootSize;         

    //
    //  size of FCB extensions
    //
    
    ULONG MRxFcbSize;              

    //
    //  size of SRV_OPEN extensions
    //

    ULONG MRxSrvOpenSize;          

    //
    //  size of FOBX extensions
    //

    ULONG MRxFobxSize;             

    //
    //  Call downs for starting/stopping the mini rdr
    //

    PMRX_CALLDOWN_CTX MRxStart;
    PMRX_CALLDOWN_CTX MRxStop;

    //
    //  Call down for cancelling outstanding requests
    //

    PMRX_CALLDOWN MRxCancel;

    //
    //  Call downs related to creating/opening/closing file system objects
    //

    PMRX_CALLDOWN MRxCreate;
    PMRX_CALLDOWN MRxCollapseOpen;
    PMRX_CALLDOWN MRxShouldTryToCollapseThisOpen;
    PMRX_CALLDOWN MRxFlush;
    PMRX_CALLDOWN MRxZeroExtend;
    PMRX_CALLDOWN MRxTruncate;
    PMRX_CALLDOWN MRxCleanupFobx;
    PMRX_CALLDOWN MRxCloseSrvOpen;
    PMRX_DEALLOCATE_FOR_FCB MRxDeallocateForFcb;
    PMRX_DEALLOCATE_FOR_FOBX MRxDeallocateForFobx;
    PMRX_IS_LOCK_REALIZABLE MRxIsLockRealizable;
    PMRX_FORCECLOSED_CALLDOWN MRxForceClosed;
    PMRX_CHKFCB_CALLDOWN MRxAreFilesAliased;

    //
    //  call downs related to nonNT style printing.....note that the connect goes thru
    //  the normal srvcall/netroot interface
    //
    
    PMRX_CALLDOWN MRxOpenPrintFile;
    PMRX_CALLDOWN MRxClosePrintFile;
    PMRX_CALLDOWN MRxWritePrintFile;
    PMRX_CALLDOWN MRxEnumeratePrintQueue;

    //
    //  call downs related to unsatisfied requests, i.e., time outs
    //

    PMRX_CALLDOWN MRxClosedSrvOpenTimeOut;
    PMRX_CALLDOWN MRxClosedFcbTimeOut;

    //
    //  call downs related to query/set  information on file system objects
    //

    PMRX_CALLDOWN MRxQueryDirectory;
    PMRX_CALLDOWN MRxQueryFileInfo;
    PMRX_CALLDOWN MRxSetFileInfo;
    PMRX_CALLDOWN MRxSetFileInfoAtCleanup;
    PMRX_CALLDOWN MRxQueryEaInfo;
    PMRX_CALLDOWN MRxSetEaInfo;
    PMRX_CALLDOWN MRxQuerySdInfo;
    PMRX_CALLDOWN MRxSetSdInfo;
    PMRX_CALLDOWN MRxQueryQuotaInfo;
    PMRX_CALLDOWN MRxSetQuotaInfo;
    PMRX_CALLDOWN MRxQueryVolumeInfo;
    PMRX_CALLDOWN MRxSetVolumeInfo;
    PMRX_CHKDIR_CALLDOWN MRxIsValidDirectory;

    //
    //  call downs related to buffer management
    //

    PMRX_COMPUTE_NEW_BUFFERING_STATE MRxComputeNewBufferingState;

    //
    //  call downs related to Low I/O management (reads/writes on file system objects)
    //

    PMRX_CALLDOWN MRxLowIOSubmit[LOWIO_OP_MAXIMUM+1];
    PMRX_EXTENDFILE_CALLDOWN MRxExtendForCache;
    PMRX_EXTENDFILE_CALLDOWN MRxExtendForNonCache;
    PMRX_CHANGE_BUFFERING_STATE_CALLDOWN MRxCompleteBufferingStateChangeRequest;

    //
    //  call downs related to name space management
    //

    PMRX_CREATE_V_NET_ROOT MRxCreateVNetRoot;
    PMRX_FINALIZE_V_NET_ROOT_CALLDOWN MRxFinalizeVNetRoot;
    PMRX_FINALIZE_NET_ROOT_CALLDOWN MRxFinalizeNetRoot;
    PMRX_UPDATE_NETROOT_STATE MRxUpdateNetRootState;
    PMRX_EXTRACT_NETROOT_NAME MRxExtractNetRootName;

    //
    //  call downs related to establishing connections with servers
    //

    PMRX_CREATE_SRVCALL MRxCreateSrvCall;
    PMRX_CREATE_SRVCALL MRxCancelCreateSrvCall;
    PMRX_SRVCALL_WINNER_NOTIFY MRxSrvCallWinnerNotify;
    PMRX_FINALIZE_SRVCALL_CALLDOWN MRxFinalizeSrvCall;

    PMRX_CALLDOWN MRxDevFcbXXXControlFile;

    //
    //  New calldowns
    //

    //
    //  Allow a client to preparse the name
    //

    PMRX_PREPARSE_NAME MRxPreparseName;

    //
    //  call down for controlling multi-plexing
    //

    PMRX_GET_CONNECTION_ID MRxGetConnectionId;

} MINIRDR_DISPATCH, *PMINIRDR_DISPATCH;


#endif   // _RXMINIRDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\mrxfcb.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mrxfFcb.h

Abstract:

    This module defines the macros/inline functions and function prototypes used by
    the mini redirectors to access the RDBSS wrapper data structures.

    IMPORTANT: All mini redirector writers cannot and should not make any assumptions
    about the layout of the RDBSS wrapper data structures. They are not guaranteed to
    be the same across platforms and even on a single platform are liable to change
    across versions.

    The following six data structure abstractions are available to the mini
    redirector writer.

       1) Server Call Context (SRV_CALL)
            The context associated with each known file system server.

       2) Net Roots (NET_ROOT)
            The root of a file system volume( local/remote) opened by the user.

       3) Virtual Net Roots (V_NET_ROOT)
            The view of a file system volume on a server. The view can be
            constrained along multiple dimensions. As an example the view can be
            associated with a logon id. which will constrain the operations that
            can be performed on the file system volume.

       4) File Control Blocks (FCB)
            The RDBSS data structure associated with each unique file opened.

       5) File Object Extensions (FOXB)

       6) ServerSide Open Context (SRV_OPEN)

    A common convention that is adopted for defining Flags in all of these data structures
    is to define a ULONG ( 32 ) flags and split them into two groups -- those that are visible
    to the mini redirector and those that are invisible. These flags are not meant for use
    by the mini redirector writers and are reserved for the wrapper.

Author:

    Balan Sethu Raman    [SethuR]   23-Oct-1995

Revision History:

--*/

#ifndef __MRXFCB_H__
#define __MRXFCB_H__

//
//  The SRVCALL flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define SRVCALL_FLAG_MAILSLOT_SERVER              (0x1)
#define SRVCALL_FLAG_FILE_SERVER                  (0x2)
#define SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS    (0x4)
#define SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES   (0x8)
#define SRVCALL_FLAG_DFS_AWARE_SERVER             (0x10)
#define SRVCALL_FLAG_FORCE_FINALIZED              (0x20)
#define SRVCALL_FLAG_LWIO_AWARE_SERVER            (0x40)
#define SRVCALL_FLAG_LOOPBACK_SERVER              (0x80)

typedef struct _MRX_NORMAL_NODE_HEADER {
   NODE_TYPE_CODE           NodeTypeCode;
   NODE_BYTE_SIZE           NodeByteSize;
   ULONG                    NodeReferenceCount;
} MRX_NORMAL_NODE_HEADER;

#ifdef __cplusplus
typedef struct _MRX_SRV_CALL_ : public MRX_NORMAL_NODE_HEADER {
#else //  !__cplusplus
typedef struct _MRX_SRV_CALL_ {
    MRX_NORMAL_NODE_HEADER;
#endif //  __cplusplus

    //
    //  !!!! changes above this require realignment with fcb.h
    //
    
    //
    //  the context fields for extensions required by the mini redirectors
    //
    
    PVOID Context;
    PVOID Context2;
    
    //
    //  Associated DeviceObject which also contains the dispatch vector
    //
    
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    
    //
    //  the srv call name, the server principal name and the server domain name.
    //
    
    PUNICODE_STRING pSrvCallName;
    PUNICODE_STRING pPrincipalName;
    PUNICODE_STRING pDomainName;
    
    //
    //  Flags used to denote the state of the SRV_CALL.
    //
    
    ULONG Flags;
    
    //
    //  Server parameters updated by the mini redirectors.
    //
    
    LONG MaximumNumberOfCloseDelayedFiles;
    
    //
    //  Status return from the transport in case of failure
    //
    
    NTSTATUS Status;
    
} MRX_SRV_CALL, *PMRX_SRV_CALL;

//
//  The various types of NET_ROOT's currently supported by the wrapper.
//

#define NET_ROOT_DISK      ((UCHAR)0)
#define NET_ROOT_PIPE      ((UCHAR)1)
#define NET_ROOT_COMM      ((UCHAR)2)
#define NET_ROOT_PRINT     ((UCHAR)3)
#define NET_ROOT_WILD      ((UCHAR)4)
#define NET_ROOT_MAILSLOT  ((UCHAR)5)

typedef UCHAR NET_ROOT_TYPE, *PNET_ROOT_TYPE;

//
//  The pipe buffer size for transferring cannot be larger than 0xffff
//

#define MAX_PIPE_BUFFER_SIZE    0xFFFF

//
//  The possible states associated with a NET_ROOT. These have been defined to be
//  line with the definitions foe the LanManager service to avoid redundant mappings.
//  These MUST agree with sdkinc\lmuse.h use_ok, etc.....
//

#define MRX_NET_ROOT_STATE_GOOD         ((UCHAR)0)
#define MRX_NET_ROOT_STATE_PAUSED       ((UCHAR)1)
#define MRX_NET_ROOT_STATE_DISCONNECTED ((UCHAR)2)
#define MRX_NET_ROOT_STATE_ERROR        ((UCHAR)3)
#define MRX_NET_ROOT_STATE_CONNECTED    ((UCHAR)4)
#define MRX_NET_ROOT_STATE_RECONN       ((UCHAR)5)

typedef UCHAR MRX_NET_ROOT_STATE, *PMRX_NET_ROOT_STATE;

//
//  The file systems on the remote servers provide varying levels of functionality to
//  detect aliasing between file names. As an example consider two shares on the same
//  file system volume. In the absence of any support from the file system on the server
//  the correct and conservative approach is to flush all the files to the server as
//  opposed to all the files on the same NET_ROOT to preserve coherency and handle
//  delayed close operations.
//

#define MRX_PURGE_SAME_NETROOT         ((UCHAR)0)
#define MRX_PURGE_SAME_SRVCALL         ((UCHAR)1)

//
//  these are not implemented yet....
//  #define   MRX_PURGE_SAME_FCB           ((UCHAR)2)
//  #define   MRX_PURGE_SAME_VOLUME        ((UCHAR)3)
//  #define   MRX_PURGE_ALL                ((UCHAR)4)
//

typedef UCHAR MRX_PURGE_RELATIONSHIP, *PMRX_PURGE_RELATIONSHIP;

#define MRX_PURGE_SYNC_AT_NETROOT         ((UCHAR)0)
#define MRX_PURGE_SYNC_AT_SRVCALL         ((UCHAR)1)

typedef UCHAR MRX_PURGE_SYNCLOCATION, *PMRX_PURGE_SYNCLOCATION;

//
//  The NET_ROOT flags are split into two groups, i.e., visible to mini rdrs and
//  invisible to mini rdrs. The visible ones are defined above and the definitions
//  for the invisible ones can be found in fcb.h. The convention that has been
//  adopted is that the lower 16 flags will be visible to the mini rdr and the
//  upper 16 flags will be reserved for the wrapper. This needs to be enforced
//  in defining new flags.
//

#define NETROOT_FLAG_SUPPORTS_SYMBOLIC_LINKS  ( 0x0001 )
#define NETROOT_FLAG_DFS_AWARE_NETROOT        ( 0x0002 )
#define NETROOT_FLAG_DEFER_READAHEAD          ( 0x0004 )
#define NETROOT_FLAG_VOLUMEID_INITIALIZED     ( 0x0008 )
#define NETROOT_FLAG_FINALIZE_INVOKED         ( 0x0010 )
#define NETROOT_FLAG_UNIQUE_FILE_NAME         ( 0x0020 )

//
//  Read ahead amount used for normal data files (32k)
//

#define DEFAULT_READ_AHEAD_GRANULARITY           (0x08000)

//
//  the wrapper implements throttling for certain kinds of operations:
//      PeekNamedPipe/ReadNamedPipe
//      LockFile
//
//  a minirdr can set the timing parameters for this in the netroot. leaving them
//  as zero will disable throttling.
//

typedef struct _NETROOT_THROTTLING_PARAMETERS {

    //
    //  Supplies the increase in delay in milliseconds, each time a request
    //  to the network fails.
    //

    ULONG Increment;     

    //
    //  Supplies the longest delay the backoff package can introduce
    //  in milliseconds.
                         
    ULONG MaximumDelay;  
                         
} NETROOT_THROTTLING_PARAMETERS, *PNETROOT_THROTTLING_PARAMETERS;

#define RxInitializeNetRootThrottlingParameters(__tp,__incr,__maxdelay) { \
       PNETROOT_THROTTLING_PARAMETERS tp = (__tp);                         \
       tp->Increment = (__incr);                                   \
       tp->MaximumDelay = (__maxdelay);                            \
}

#ifdef __cplusplus
typedef struct _MRX_NET_ROOT_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_NET_ROOT_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    //
    //  the MRX_SRV_CALL instance with which this MRX_NET_ROOT instance is associated
    //
    
    PMRX_SRV_CALL pSrvCall;
    
    //
    //  !!!! changes above this require realignment with fcb.h
    //
    
    //
    //  the context fields used by the mini redirectors for recording
    //  additional state.
    //
    
    PVOID Context;
    PVOID Context2;
    
    //
    //  The flags used to denote the state of the NET_ROOT instance.
    //
    
    ULONG Flags;
    
    //
    //  We count the number of fcbs, srvopens on the netroot
    //
    
    ULONG NumberOfFcbs;
    ULONG NumberOfSrvOpens;
    
    //
    //  The current state and the purge relationships based on the support
    //  provided by the file system on the server.
    //
    
    MRX_NET_ROOT_STATE MRxNetRootState;
    NET_ROOT_TYPE Type;
    MRX_PURGE_RELATIONSHIP PurgeRelationship;
    MRX_PURGE_SYNCLOCATION PurgeSyncLocation;
    
    //
    //  the type of device, i.e., file system volume, printer, com port etc.
    //
    
    DEVICE_TYPE DeviceType;
    
    //
    //  Name of the NET_ROOT instance
    //
    
    PUNICODE_STRING pNetRootName;
    
    //
    //  the name to be prepended to all FCBS associated with this NET_ROOT
    //
    
    UNICODE_STRING InnerNamePrefix;
    
    //
    //  Parameters based upon the type of the NET_ROOT.
    //
    
    ULONG  ParameterValidationStamp;
    union {
      struct {
         ULONG DataCollectionSize;
         NETROOT_THROTTLING_PARAMETERS PipeReadThrottlingParameters;
      } NamedPipeParameters;
    
      struct {
         ULONG ClusterSize;
         ULONG ReadAheadGranularity;
         NETROOT_THROTTLING_PARAMETERS LockThrottlingParameters;
         ULONG RenameInfoOverallocationSize; //could be a USHORT
         GUID VolumeId;
      } DiskParameters;
    };
} MRX_NET_ROOT, *PMRX_NET_ROOT;

//
//  The VNET_ROOT flags are split into two groups, i.e., visible to mini rdrs and
//  invisible to mini rdrs. The visible ones are defined below and the definitions
//  for the invisible ones can be found in fcb.h. The convention that has been
//  adopted is that the lower 16 flags will be visible to the mini rdr and the
//  upper 16 flags will be reserved for the wrapper. This needs to be enforced
//  in defining new flags.
//

#define VNETROOT_FLAG_CSCAGENT_INSTANCE   0x00000001
#define VNETROOT_FLAG_FINALIZE_INVOKED    0x00000002
#define VNETROOT_FLAG_FORCED_FINALIZE     0x00000004
#define VNETROOT_FLAG_NOT_FINALIZED    0x00000008

#ifdef __cplusplus
typedef struct _MRX_V_NET_ROOT_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_V_NET_ROOT_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    //
    //  the MRX_NET_ROOT instance with which the MRX_V_NET_ROOT instance is associated
    //
    
    PMRX_NET_ROOT pNetRoot;
    
    //
    //  !!!! changes above this require realignment with fcb.h
    //
    
    //
    //  the context fields provided for storing additional information as deemed
    //  necessary by the mini redirectors
    //
    
    PVOID Context;
    PVOID Context2;
    
    ULONG Flags;
    
    //
    //  This field should not be updated by the mini redirectors. Its usage is intended
    //  to provide an easy mechanism for accessing certain state information
    //
    
    ULONG NumberOfOpens;
    
    //
    //  We count the number of Fobxss on the virtual netroot
    //
    
    ULONG NumberOfFobxs;
    
    //
    //  the security parameters associated with the V_NET_ROOT instance.
    //
    
    LUID LogonId;
    
    //
    //  These are the parameters supplied by the used in a NtCreateFile call in
    //  which the FILE_CREATE_TREE_CONNECTION flag is specified as part of the
    //  CreateOptions.
    //
    
    PUNICODE_STRING pUserDomainName;
    PUNICODE_STRING pUserName;
    PUNICODE_STRING pPassword;
    ULONG SessionId;
    NTSTATUS ConstructionStatus;
    BOOLEAN IsExplicitConnection;
} MRX_V_NET_ROOT, *PMRX_V_NET_ROOT;

//
//  ALL FIELDS IN AN FCB ARE READONLY EXCEPT Context and Context2....
//  Also, Context is read only the the mini has specified RDBSS_MANAGE_FCB_EXTENSION
//

typedef struct _MRX_FCB_ {
   
    FSRTL_ADVANCED_FCB_HEADER Header;
    
    //
    //  The MRX_NET_ROOT instance with which this is associated
    //
    
    PMRX_NET_ROOT pNetRoot;
    
    //
    //  !!!! changes above this require realignment with fcb.h
    //
    
    //
    //  the context fields to store additional information as deemed necessary by the
    //  mini redirectors.
    //
    
    PVOID Context;
    PVOID Context2;
    
    //
    //  The reference count: in a different place because we must prefix with
    //  the FSRTL_COMMON_FCB_HEADER structure.
    //
    
    ULONG NodeReferenceCount;

    //
    //  The internal state of the Fcb.  THIS FIELD IS READONLY FOR MINIRDRS
    //

    ULONG FcbState;

    //
    //  A count of the number of file objects that have been opened for
    //  this file/directory, but not yet been cleaned up yet.  This count
    //  is only used for data file objects, not for the Acl or Ea stream
    //  file objects.  This count gets decremented in RxCommonCleanup,
    //  while the OpenCount below gets decremented in RxCommonClose.
    //

    CLONG UncleanCount;

    //
    //  A count of the number of file objects that have been opened for
    //  this file/directory, but not yet been cleaned up yet and for which
    //  cacheing is not supported. This is used in cleanup.c to tell if extra
    //  purges are required to maintain coherence.
    //

    CLONG UncachedUncleanCount;

    //
    //  A count of the number of file objects that have opened
    //  this file/directory.  For files & directories the FsContext of the
    //  file object points to this record.
    //

    CLONG OpenCount;

    //
    //  The outstanding locks count: if this count is nonzero, the we silently
    //  ignore adding LOCK_BUFFERING in a ChangeBufferingState request. This field
    //  is manipulated by interlocked operations so you only have to have the fcb
    //  shared to manipulate it but you have to have it exclusive to use it.
    //

    ULONG OutstandingLockOperationsCount;

    //
    //  The actual allocation length as opposed to the valid data length
    //

    ULONGLONG ActualAllocationLength;

    //
    //  Attributes of the MRX_FCB,
    //

    ULONG Attributes;

    //
    //  Intended for future use, currently used to round off allocation to
    //  DWORD boundaries.
    //

    BOOLEAN Spare1;
    BOOLEAN fShouldBeOrphaned;
    BOOLEAN fMiniInited;

    //
    //  Type of the associated MRX_NET_ROOT, intended to avoid pointer chasing.
    //

    UCHAR CachedNetRootType;

    //
    //  Header for the list of srv_opens for this FCB....
    //  THIS FIELD IS READONLY FOR MINIS
    //

    LIST_ENTRY SrvOpenList;

    //
    //  changes whenever the list changes..prevents extra lookups
    //  THIS FIELD IS READONLY FOR MINIS
    //

    ULONG SrvOpenListVersion;

} MRX_FCB, *PMRX_FCB;


//
//  The following flags define the various types of buffering that can be selectively
//  enabled or disabled for each SRV_OPEN.
//

#define SRVOPEN_FLAG_DONTUSE_READ_CACHING                   (0x1)
#define SRVOPEN_FLAG_DONTUSE_WRITE_CACHING                  (0x2)
#define SRVOPEN_FLAG_CLOSED                                 (0x4)
#define SRVOPEN_FLAG_CLOSE_DELAYED                          (0x8)
#define SRVOPEN_FLAG_FILE_RENAMED                           (0x10)
#define SRVOPEN_FLAG_FILE_DELETED                           (0x20)
#define SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING         (0x40)
#define SRVOPEN_FLAG_COLLAPSING_DISABLED                    (0x80)
#define SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_REQUESTS_PURGED (0x100)
#define SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE              (0x200)
#define SRVOPEN_FLAG_ORPHANED                               (0x400)

typedef
NTSTATUS
(NTAPI *PMRX_SHADOW_CALLDOWN) (
    IN OUT struct _RX_CONTEXT * RxContext
    );

//
//  Minirdrs allocate, initialize and free this structure
//

typedef struct {
    
    //
    // Pointer to the file object associated with the handle. This is set
    // after the handle is successfully created in the usermode.
    //
    
    PFILE_OBJECT UnderlyingFileObject;

    //
    // Pointer to the device object represented by the file object mentioned
    // above.
    //
    
    PDEVICE_OBJECT UnderlyingDeviceObject;

    ULONG   LockKey;

    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;

    PMRX_SHADOW_CALLDOWN    DispatchRoutine;

} MRXSHADOW_SRV_OPEN, *PMRXSHADOW_SRV_OPEN;

#ifdef __cplusplus
typedef struct _MRX_SRV_OPEN_ : public MRX_NORMAL_NODE_HEADER {
#else //  !__cplusplus
typedef struct _MRX_SRV_OPEN_ {
    MRX_NORMAL_NODE_HEADER;
#endif //  __cplusplus

    //
    //  the MRX_FCB instance with which the SRV_OPEN is associated.
    //

    PMRX_FCB pFcb;

    //
    //  the V_NET_ROOT instance with which the SRV_OPEN is associated
    //

    PMRX_V_NET_ROOT pVNetRoot;

    //
    //  !!!! changes above this require realignment with fcb.h
    //

    //
    //  the context fields to store additional state information as deemed necessary
    //  by the mini redirectors
    //

    PVOID Context;
    PVOID Context2;

    //
    //  shadow context, mini-rdr allocates and deallocates this structure
    //
    
    PMRXSHADOW_SRV_OPEN ShadowContext;

    //
    //  The flags are split into two groups, i.e., visible to mini rdrs and invisible
    //  to mini rdrs. The visible ones are defined above and the definitions for the
    //  invisible ones can be found in fcb.h. The convention that has been adopted is
    //  that the lower 16 flags will be visible to the mini rdr and the upper 16 flags
    //  will be reserved for the wrapper. This needs to be enforced in defining new flags.
    //

    ULONG Flags;

    //
    //  the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name
    //

    PUNICODE_STRING pAlreadyPrefixedName;

    //
    //  the number of Fobx's associated with this open for which a cleanup IRP
    //  has not been processed.
    //

    CLONG UncleanFobxCount;

    // 
    //  the number of local opens associated with this open on the server
    //

    CLONG OpenCount;

    //
    //  the Key assigned by the mini redirector for this SRV_OPEN. Since the various mini
    //  redirectors do not always get to pick the unique id for a open instance, the key
    //  used to identify the open to the server is different for different mini redirectors
    //  based upon the convention adopted at the server.
    //

    PVOID Key;

    //
    //  the access and sharing rights specified for this SRV_OPEN. This is used in
    //  determining is subsequent open requests can be collapsed  with an existing
    //  SRV_OPEN instance.
    //

    ACCESS_MASK DesiredAccess;
    ULONG ShareAccess;
    ULONG CreateOptions;

    //
    //  The BufferingFlags field is temporal.....it does not really belong to the
    //  srvopen; rather the srvopen is used as a representative of the fcb. On
    //  each open, the bufferingflags field of the srvopen is taken as the minirdr's
    //  contribution to the buffering state. On an oplock break, a srvopen is passed
    //  (the one that's being broken) whose bufferflags field is taken as the new
    //  proxy. On a close that changes the minirdr's contribution, the minirdr should
    //  take steps to cause a ChangeBufferingState to the new state.
    //
    //  just to reiterate, the field is just used to carry the information from
    //  the minirdr to RxChangeBufferingState and does not hold longterm coherent
    //  information.
    //

    ULONG BufferingFlags;

    //
    //  List Entry to wire the SRV_OPEN to the list of SRV_OPENS maintained as
    //  part of theFCB
    //  THIS FIELD IS READONLY FOR MINIS
    //

    ULONG ulFileSizeVersion;

    LIST_ENTRY SrvOpenQLinks;

} MRX_SRV_OPEN, *PMRX_SRV_OPEN;

#define FOBX_FLAG_DFS_OPEN        (0x0001)
#define FOBX_FLAG_BAD_HANDLE      (0x0002)
#define FOBX_FLAG_BACKUP_INTENT   (0x0004)
#define FOBX_FLAG_NOT_USED        (0x0008)

#define FOBX_FLAG_FLUSH_EVEN_CACHED_READS   (0x0010)
#define FOBX_FLAG_DONT_ALLOW_PAGING_IO      (0x0020)
#define FOBX_FLAG_DONT_ALLOW_FASTIO_READ    (0x0040)

typedef struct _MRX_PIPE_HANDLE_INFORMATION {

    ULONG TypeOfPipe;
    ULONG ReadMode;
    ULONG CompletionMode;

} MRX_PIPE_HANDLE_INFORMATION, *PMRX_PIPE_HANDLE_INFORMATION;

#ifdef __cplusplus
typedef struct _MRX_FOBX_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_FOBX_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    //
    //  the MRX_SRV_OPEN instance with which the FOBX is associated
    //

    PMRX_SRV_OPEN pSrvOpen;

    //
    //  the FILE_OBJECT with which this FOBX is associated
    //  In certain instances the I/O subsystem creates a FILE_OBJECT instance
    //  on the stack in the interests of efficiency. In such cases this field
    //  is NULL.
    //

    PFILE_OBJECT AssociatedFileObject;

    //
    //  !!!! changes above this require realignment with fcb.h
    //
    
    //
    //  The fields provided to accomodate additional state to be associated
    //  by the various mini redirectors
    //

    PVOID Context;
    PVOID Context2;

    //
    //  The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
    //  The visible ones are defined above and the definitions for the invisible ones can be found
    //  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
    //  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
    //  enforced in defining new flags.
    //

    ULONG Flags;

    union {
        struct {
            
            //
            //  The query template is used to filter directory query requests.
            //  It originally is set to null and on the first call the NtQueryDirectory
            //  it is set to the input filename or "*" if the name is not supplied.
            //  All subsquent queries then use this template.
            //

            UNICODE_STRING UnicodeQueryTemplate;
        }; //  for directories

        PMRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;   //  for pipes
    };

    //
    //  The following field is used as an offset into the Eas for a
    //  particular file.  This will be the offset for the next
    //  Ea to return.  A value of 0xffffffff indicates that the
    //  Ea's are exhausted.
    //

    //
    //  This field is manipulated directly by the smbmini....maybe it should move down
    //  one thing is that it is a reminder that NT allows a resume on getting EAs
    //

    ULONG OffsetOfNextEaToReturn;
} MRX_FOBX, *PMRX_FOBX;

//
//  Resource accquisition routines.
//
//  The synchronization resources of interest to mini redirector writers are
//  primarily associated with the FCB. There is a paging I/O resource and a
//  regular resource. The paging I/O resource is managed by the wrapper. The only
//  resource accesible to mini redirector writers is the regular resource which
//  should be accessed using the supplied routines.
//

NTSTATUS
RxAcquireExclusiveFcbResourceInMRx (
    PMRX_FCB Fcb
    );

NTSTATUS
RxAcquireSharedFcbResourceInMRx (
    PMRX_FCB Fcb
    );

VOID
RxReleaseFcbResourceInMRx (
    PMRX_FCB Fcb
    );


#endif // __MRXFCB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\nodetype.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in the RDBSS.
    Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    JoeLinn     [Joelinn]    9-July-1994

Revision History:

--*/

#ifndef _NODETYPE_INCLUDED_
#define _NODETYPE_INCLUDED_


typedef USHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME, *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


typedef struct _NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
      NODE_TYPE_CODE NodeTypeCode;
      NODE_BYTE_SIZE NodeByteSize;
}  NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;

#ifdef __cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE : public NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
#else // !__cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE {
      NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
#endif // __cplusplus

      //
      //  this is for guys with reference counts....not everyone has one
      //

      ULONG NodeReferenceCount; 
}  NODE_TYPE_CODE_AND_SIZE, *PNODE_TYPE_AND_SIZE;


#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeTypeCode = TType;   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeByteSize = (CSHORT)Size;    \
        }


//
//  N O D E T Y P E S
//


//
//  0xeb00 was selected as being far from the other codes
//  0xec00 was added so that we could encode the structure type in the code.
//

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)



#define RDBSS_STORAGE_NTC(x) (0xec00+(x))

//
//  these are here to ensure that we don't use any of the old cairo storage types.
//

#define StorageTypeDirectory (@@@)
#define StorageTypeFile (@@@)

typedef enum _RX_FILE_TYPE {
    FileTypeNotYetKnown = 0,
    FileTypeDirectory = 2,
    FileTypeFile = 3
} RX_FILE_TYPE;

//
//  according to markz, i should plan on the number of STORAGE_NTCs growing to bytesize!!
//

#define RDBSS_NTC_STORAGE_TYPE_UNKNOWN		       ((NODE_TYPE_CODE)0xec00)
#define RDBSS_NTC_STORAGE_TYPE_DIRECTORY     	   ((NODE_TYPE_CODE)0xec02)
#define RDBSS_NTC_STORAGE_TYPE_FILE		           ((NODE_TYPE_CODE)0xec03)

#define RDBSS_NTC_OPENTARGETDIR_FCB                ((NODE_TYPE_CODE)0xecff) //  must be an fcb type and not the same
#define RDBSS_NTC_IPC_SHARE                        ((NODE_TYPE_CODE)0xecfe)
#define RDBSS_NTC_MAILSLOT                         ((NODE_TYPE_CODE)0xecfd)
#define RDBSS_NTC_SPOOLFILE                        ((NODE_TYPE_CODE)0xecfc)

#define RDBSS_NTC_SRVCALL                          ((NODE_TYPE_CODE)0xeb10)
#define RDBSS_NTC_NETROOT                          ((NODE_TYPE_CODE)0xeb11)
#define RDBSS_NTC_V_NETROOT                        ((NODE_TYPE_CODE)0xeb12)
    
//
//  Local filesystems sometimes need volume opens. these are not yet
//  implemented but we reserve the nodetype now.
//     

#define RDBSS_NTC_VOLUME_FCB                       ((NODE_TYPE_CODE)0xeb1f)

#define RDBSS_NTC_SRVOPEN                          ((NODE_TYPE_CODE)0xeb1c)
#define RDBSS_NTC_INTERNAL_SRVOPEN                 ((NODE_TYPE_CODE)0xeb1d)
#define RDBSS_NTC_DEVICE_FCB                       ((NODE_TYPE_CODE)0xeb9a)

#define RDBSS_NTC_DATA_HEADER                      ((NODE_TYPE_CODE)0xeb00)
#define RDBSS_NTC_VCB                              ((NODE_TYPE_CODE)0xeb01)
#define RDBSS_NTC_FOBX                             ((NODE_TYPE_CODE)0xeb07)
#define RDBSS_NTC_RX_CONTEXT                       ((NODE_TYPE_CODE)0xeb08)

#define RDBSS_NTC_PREFIX_TABLE                     ((NODE_TYPE_CODE)0xeb0d)
#define RDBSS_NTC_PREFIX_ENTRY                     ((NODE_TYPE_CODE)0xeb0e)

#define RDBSS_NTC_FCB_TABLE                        ((NODE_TYPE_CODE)0xeb09)
#define RDBSS_NTC_FCB_TABLE_ENTRY                  ((NODE_TYPE_CODE)0xeb0a)

#define RDBSS_NTC_RXCE_TRANSPORT                   ((NODE_TYPE_CODE)0xeb71)
#define RDBSS_NTC_RXCE_ADDRESS                     ((NODE_TYPE_CODE)0xeb72)
#define RDBSS_NTC_RXCE_CONNECTION                  ((NODE_TYPE_CODE)0xeb73)
#define RDBSS_NTC_RXCE_VC                          ((NODE_TYPE_CODE)0xeb74)

#define RDBSS_NTC_NONPAGED_FCB                     ((NODE_TYPE_CODE)0xebfd)
#define RDBSS_NTC_COMMON_DISPATCH                  ((NODE_TYPE_CODE)0xebfe)
#define RDBSS_NTC_MINIRDR_DISPATCH                 ((NODE_TYPE_CODE)0xebff)

typedef USHORT RDBSS_STORAGE_TYPE_CODES;

#define RDBSS_NTC_FCB                      RDBSS_NTC_STORAGE_TYPE_FILE

#define NodeTypeIsFcb( FCB ) \
    ((((NodeType(FCB) & 0xff00) == RDBSS_NTC_STORAGE_TYPE_UNKNOWN)) || ((NodeType( FCB ) & 0xfff0) == 0xeb90))

//
//  a mask to alter the type of a data structure once it is marked for scavenging so
//  that subsequent tests will fail.
//

#define RX_SCAVENGER_MASK (0x1000)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded the line number of the
//  bugcheck call in the low order 16 bits. The high order bits can be whatever
//  the caller wants. In the wrapper, we actually define file identifiers as well.
//  However, the system also displays quire a but of the backtrace; this shows
//  the .sys file of the caller and it is frequently the case that the linenumber
//  is completely disambiguating.
//

//
//  Each individual wrapper file that calls bugcheck has defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  RDBSS_BUG_CHECK_ values defined below and then use RxBugCheck to bugcheck
//  the system.
//


typedef enum _RDBSS_BUG_CHECK_CODES {

     RDBSS_BUG_CHECK_FCBSTRUC  = 0xfcb00000,
     RDBSS_BUG_CHECK_CACHESUP  = 0xca550000,
     RDBSS_BUG_CHECK_CLEANUP   = 0xc1ee0000,
     RDBSS_BUG_CHECK_CLOSE     = 0xc10e0000,
     RDBSS_BUG_CHECK_NTEXCEPT  = 0xbaad0000,

} RDBSS_BUG_CHECK_CODES;

// we overload on the original redirector's bugcheck code using the stack
// backtrace to differentiate among consumers

#define RDBSS_FILE_SYSTEM RDR_FILE_SYSTEM
#define RxBugCheck(A,B,C) { \
        KeBugCheckEx(RDBSS_FILE_SYSTEM, \
                     BugCheckFileId | ((ULONG)(__LINE__)), \
                     A, B, C ); \
        }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\namcache.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    namcache.h

Abstract:

The NAME_CACHE structure is used to remember the name strings of recent
operations performed at the server so the client can suppress redundant
requests.  For example if an open has recently failed with file not found and
the client app tries it again with an upcased string then we can fail it
immediately with STATUS_OBJECT_NAME_NOT_FOUND without hitting the server.  In
general the algorithm is to put a time window and SMB operation count limit on
the NAME_CACHE entry.  The time window is usually 2 seconds so if NAME_CACHE
entry is more than 2 seconds old the match will fail and the request will go to
the server.  If the request fails again at the server the NAME_CACHE is updated
with another 2 second window.  If the SMB operation count doesn't match then one
or more SMBs have been sent to the server which could make this NAME_CACHE entry
invalid.  So again this operation will get sent to the server.

A NAME_CACHE struct has a mini-rdr portion and an RDBSS portion.  The mini-rdr
portion has a context field (see below), an NTSTATUS field for the result of a
prior server operation on this name entry and a context extension pointer for
some additional mini-rdr specific storage that can be co-allocated with the
NAME_CACHE structure.  See RxNameCacheInitialize().

The SMB operation count is an example of mini-rdr specific state which could be
saved in the context field of MRX_NAME_CACHE.  When the wrapper routine
RxNameCacheCheckEntry() is called it will perform an equality check between the
context field and a supplied parameter as part of finding a match in the name
cache.  When a NAME_CACHE entry is created or updated it is the mini-rdr's job
to supply an appropriate value for this field.

The RDBSS portion of the NAME_CACHE struct contains the name (in a UNICODE
STRING) and the expiration time of the entry.  The MaximumEntries field is used
to limit the number of NAME_CACHE entries created in case a poorly behaved
program were to generate a large number of opens with bad file names and so
consume large quanities of pool.

The NAME_CACHE_CONTROL struct is used to manage a given name cache.  It has
a free list, an active list and a lock used to synchronize updates.

Currently there are name caches for:
   1. OBJECT_NAME_NOT_FOUND - 2 second window, any SMB op sent to the
      server will invalidate it.  This is because you could have the case
      where the client app has a file (foo) open which an app on the server could
      use to signal the creation of a file (bar) on the server.  When the client
      reads file foo and learns that file bar has been created on the
      server then a hit in the name cache which matches bar can't return an
      error.  So this optimization only handles the case of successive file
      opens on the same file which does not yet exist.  Happens in WORD.

Author:

    David Orbits          [davidor]   9-Sep-1996

Revision History:

--*/

#ifndef _NAME_CACHE_DEFINED_
#define _NAME_CACHE_DEFINED_


#ifdef __cplusplus
typedef struct _MRX_NAME_CACHE_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_NAME_CACHE_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    // !!!! changes above this require realignment with fcb.h

    ULONG Context;                // Operation Count snapshot when entry made
    PVOID ContextExtension;       // Pointer to mini-rdr extension area
    NTSTATUS PriorStatus;         // Saved Status from last attempt at operation

} MRX_NAME_CACHE, *PMRX_NAME_CACHE;


#ifdef __cplusplus
typedef struct _NAME_CACHE : public MRX_NAME_CACHE {
    // I didn't find any use of the spacer in the union below,
    // and the MRX_NAME_CACHE is by definition larger than
    // MRX_NORMAL_NODE_HEADER, so I didn't worry about the union
#else // !__cplusplus
typedef struct _NAME_CACHE {
    //
    // The portion of NAME_CACHE visible to mini redirectors.
    //
    union {
        MRX_NAME_CACHE;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus
    //
    // The portion of NAME_CACHE visible to RDBSS.
    //
    LARGE_INTEGER ExpireTime;     // Time when entry expires
    LIST_ENTRY Link;              // Entry on free or active list
    UNICODE_STRING Name;          // Cached name
    ULONG HashValue;              // Hash value of name
    BOOLEAN CaseInsensitive;      // Controls name string compare

} NAME_CACHE, *PNAME_CACHE;


typedef struct _NAME_CACHE_CONTROL_ {

    FAST_MUTEX NameCacheLock;     // Lock to synchronize access to the list
    LIST_ENTRY ActiveList;        // List of active name cache entries
    LIST_ENTRY FreeList;          // Free list of NAME_CACHE structs
    ULONG EntryCount;             // Current number of NAME_CACHE entries allocated
    ULONG MaximumEntries;         // Max number of entries we will allocate
    ULONG MRxNameCacheSize;       // Size of Mini-rdr storage area in entry
    //
    // Stats
    //
    ULONG NumberActivates;        // Number of times cache was updated
    ULONG NumberChecks;           // Number of times cache was checked
    ULONG NumberNameHits;         // Number of times a valid match was returned
    ULONG NumberNetOpsSaved;      // Number of times mini-rdr saved a net op

    ULONG Spare[4];

} NAME_CACHE_CONTROL, *PNAME_CACHE_CONTROL;


//
// Return status for RxNameCacheCheckEntry()
//
typedef enum _RX_NC_CHECK_STATUS {
    RX_NC_SUCCESS = 0,
    RX_NC_TIME_EXPIRED,
    RX_NC_MRXCTX_FAIL
} RX_NC_CHECK_STATUS;



//
// Mini-rdr function to count the number of times the cached state avoided
// a trip to the server.
//
#define RxNameCacheOpSaved(_NCC) (_NCC)->NumberNetOpsSaved += 1



VOID
RxNameCacheInitialize(
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN ULONG MRxNameCacheSize,
    IN ULONG MaximumEntries
    );

PNAME_CACHE
RxNameCacheCreateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name,
    IN BOOLEAN CaseInsensitive
    );

PNAME_CACHE
RxNameCacheFetchEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    );

RX_NC_CHECK_STATUS
RxNameCacheCheckEntry (
    IN PNAME_CACHE NameCache,
    IN ULONG MRxContext
    );

VOID
RxNameCacheActivateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache,
    IN ULONG LifeTime,
    IN ULONG MRxContext
    );

VOID
RxNameCacheExpireEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    );

VOID
RxNameCacheExpireEntryWithShortName (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    );

VOID
RxNameCacheFreeEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    );

VOID
RxNameCacheFinalize (
    IN PNAME_CACHE_CONTROL NameCacheCtl
    );

#endif // _NAME_CACHE_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\prefix.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.h

Abstract:

    This module defines the data structures that enable the RDBSS to use the prefix package
    to catalog its server and netroot names. For the moment, file/directory names use the same stuff.

Author:

    Joe Linn (JoeLinn)    8-8-94

Revision History:

--*/

#ifndef _RXPREFIX_
#define _RXPREFIX_

// this stuff is implemented in prefix.c

/*
   The current implementation uses a table that has as components:

     1) a prefix table
     2) a queue
     3) a version
     4) a lock

   You use the lock in the normal way: shared to lookup; eclusive to change. the version changes
   eith each change. The reason that we have the queue is that the prefix table package allows
   caller to be enumerating at a time..... the Q/version approach allows multiple guys at a time.
   The Q could be used as a faster lookup for filenames but the prefix table is definitely the
   right thing for netroots.

*/

typedef struct _RX_CONNECTION_ID {
    union {
        ULONG SessionID;
        LUID  Luid;
    };
} RX_CONNECTION_ID, *PRX_CONNECTION_ID;

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING Name
    );

PVOID
RxPrefixTableLookupName (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING CanonicalName,
    OUT PUNICODE_STRING RemainingName,
    IN PRX_CONNECTION_ID ConnectionId
    );

PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN PVOID Container,
    IN PULONG ContainerRefCount,
    IN USHORT CaseInsensitiveLength,
    IN PRX_CONNECTION_ID ConnectionId
    );

VOID
RxRemovePrefixTableEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

VOID
RxDereferenceEntryContainer (
    IN OUT PRX_PREFIX_ENTRY Entry,
    IN  PRX_PREFIX_TABLE PrefixTable
    );

BOOLEAN
RxIsNameTableEmpty (
    IN PRX_PREFIX_TABLE ThisTable
    );

VOID
RxInitializePrefixTable (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN ULONG TableSize OPTIONAL, 
    IN BOOLEAN CaseInsensitiveMatch
    );

VOID
RxFinalizePrefixTable (
    IN OUT PRX_PREFIX_TABLE ThisTable
    );

//
//  Rx form of a table entry.
//

typedef struct _RX_PREFIX_ENTRY {

    //
    //  Normal Header for Refcounted Structure
    //

    NODE_TYPE_CODE NodeTypeCode;                 
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  the initial part of the name that is always case insensitive
    //

    USHORT CaseInsensitiveLength;                
    USHORT Spare1;

    ULONG SavedHashValue;
    LIST_ENTRY HashLinks;

    //
    //  queue of the set members
    //

    LIST_ENTRY MemberQLinks;                   

    //
    //  Name of the entry
    //

    UNICODE_STRING Prefix;                       

    //
    //  Pointer to the reference count of the container
    //

    PULONG ContainerRefCount;            

    //
    //  don't know the parent type...nor do all callers!
    //  thus, i need this backptr.
    //

    PVOID ContainingRecord;             

    //
    //  some space that alternate table routines can use
    //
                                                 
    PVOID Context;                      

    //
    //  Used for controlled multiplexing
    //

    RX_CONNECTION_ID ConnectionId;               

} RX_PREFIX_ENTRY, *PRX_PREFIX_ENTRY;

//
//  Rx form of name table. wraps in a lock and a queue.  Originally, this implementation used the prefix tables
//  in Rtl which don't allow an empty string entry. so, we special case this.
//

#define RX_PREFIX_TABLE_DEFAULT_LENGTH 32

typedef
PVOID
(*PRX_TABLE_LOOKUPNAME) (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING CanonicalName,
    OUT PUNICODE_STRING RemainingName
    );

typedef
PRX_PREFIX_ENTRY
(*PRX_TABLE_INSERTENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

typedef
VOID
(*PRX_TABLE_REMOVEENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

typedef struct _RX_PREFIX_TABLE {

    //
    //  Normal Header
    //

    NODE_TYPE_CODE NodeTypeCode;         
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  version stamp changes on each insertion/removal
    //

    ULONG Version;                       

    //
    //  queue of the inserted names
    //

    LIST_ENTRY MemberQueue;              

    //
    //  Resource used to control table access
    //

    ERESOURCE TableLock;                 

    //
    //  PrefixEntry for the Null string
    //

    PRX_PREFIX_ENTRY TableEntryForNull;  

    BOOLEAN CaseInsensitiveMatch;

    //
    //  we may act differently for this....esp for debug!
    //

    BOOLEAN IsNetNameTable;              
    ULONG TableSize;

#if DBG
    ULONG Lookups;
    ULONG FailedLookups;
    ULONG Considers;
    ULONG Compares;
#endif
    
    LIST_ENTRY HashBuckets[RX_PREFIX_TABLE_DEFAULT_LENGTH];

} RX_PREFIX_TABLE, *PRX_PREFIX_TABLE;


#if 0

#define RxAcquirePrefixTableLockShared(PrefixTable,Wait) \
        RxpAcquirePrefixTableLockShared((PrefixTable),(Wait),TRUE, __FILE__,__LINE__ )

#define RxAcquirePrefixTableLockExclusive(PrefixTable,Wait) \
        RxpAcquirePrefixTableLockExclusive((PrefixTable),(Wait),TRUE, __FILE__,__LINE__ )

#define RxReleasePrefixTableLock(PrefixTable)  \
        RxpReleasePrefixTableLock((PrefixTable),TRUE, __FILE__,__LINE__ )
        
extern 
BOOLEAN
RxpAcquirePrefixTableLockShared (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber );

extern 
BOOLEAN
RxpAcquirePrefixTableLockExclusive (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber 
   );

extern 
VOID
RxpReleasePrefixTableLock (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber 
   );

#else

#define RxAcquirePrefixTableLockShared(TABLE,WAIT) ExAcquireResourceSharedLite( &(TABLE)->TableLock, (WAIT) )
#define RxAcquirePrefixTableLockExclusive(TABLE,WAIT) ExAcquireResourceExclusiveLite( &(TABLE)->TableLock, (WAIT) )
#define RxReleasePrefixTableLock(TABLE)  ExReleaseResourceLite( &(TABLE)->TableLock )


#endif

extern 
VOID
RxExclusivePrefixTableLockToShared (
    PRX_PREFIX_TABLE Table
    );

#define RxIsPrefixTableLockExclusive(TABLE) ExIsResourceAcquiredExclusiveLite(&(TABLE)->TableLock)
#define RxIsPrefixTableLockAcquired(TABLE) ( ExIsResourceAcquiredSharedLite(&(TABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(TABLE)->TableLock) )



#endif   // _RXPREFIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\ntrxdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtRxDef.h

Abstract:

    This module defines a whole host of macros that orient the code towards NT
    as opposed to Win9x.

Author:

    Joe Linn     [JoeLinn]   19-aug-1994

Revision History:
    Jim McNelis  [jimmcn]    14-mar-1995    added OAL defines.
    Sethu        [SethuR]    15-mar-1995    include OAL defines for RX_DATA_BUFFER (aka MDL )

--*/

#ifndef _RX_NTDEFS_DEFINED_
#define _RX_NTDEFS_DEFINED_

#define INLINE __inline

//
//  from winbase.h:
//

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //  ifndef INVALID_HANDLE_VALUE

#define RxDeviceType(__xxx) ((DEVICE_TYPE)FILE_DEVICE_##__xxx)

//
//  this macro is used in various places to assist in defining sets of constants
//  that can be used to set/clear/test specific bits in a flags-type field
//

#define RX_DEFINE_FLAG(a,c,d)  a = ((1<<c)&d),

//
//  we need this constant various places
//

#define TICKS_PER_SECOND (10 * 1000 * 1000)
#define TICKS_PER_MILLESECOND (10 * 1000)


int
RxSprintf (
    char *, 
    const char *, 
    ...
    );

#ifndef WRAPPER_CALLS_ONLY
#define RxSprintf sprintf
#endif //  ifndef WRAPPER_CALLS_ONLY

//
//  the next set of macros defines how to get things out of the RxContext; however, RxContext is not
//  a macro parameter; rather, the appropriate pointers are just captured from whatever RxContext happens
//  to be around. Q: "why would you use RxCaptureFcb and then reference thru capFcb instead of just having
//  a macro like RxGetFcb() === RxContext->Fcb?" A: it is done this way to help with optimization. when you make
//  the RxGetFcb() call, the Fcb will have to be reloaded from the RxContext if you have called any procs; however,
//  it will not have to be reloaded with the capture technique.
//

#ifndef MINIRDR__NAME
#define RxCaptureFcb PFCB __C_Fcb = (PFCB)(RxContext->pFcb)
#define RxCaptureFobx PFOBX __C_Fobx = (PFOBX)(RxContext->pFobx)
#else
#define RxCaptureFcb PMRX_FCB __C_Fcb = (RxContext->pFcb)
#define RxCaptureFobx PMRX_FOBX __C_Fobx = (RxContext->pFobx)
#endif

#define RxCaptureRequestPacket PIRP __C_Irp = RxContext->CurrentIrp
#define RxCaptureParamBlock PIO_STACK_LOCATION __C_IrpSp = RxContext->CurrentIrpSp
#define RxCaptureFileObject PFILE_OBJECT __C_FileObject = __C_IrpSp-> FileObject

//
//  the "cap" prefix means "Captured from the RxContext....."; it's ok after you get used to it
//

#define capFcb __C_Fcb
#define capFobx __C_Fobx
#define capPARAMS __C_IrpSp
#define capReqPacket __C_Irp
#define capFileObject __C_FileObject


//
//  The following routines are used for pool allocation. On a checked build
//  additional information, we add in callsite information and go to a set of
//  routines that over perform various kinds of checking and guarding. On a free
//  build we forego this luxury and go straight for the allocation.
//

#ifdef RX_POOL_WRAPPER

//
//  These routines do various debug checks on the pool and the block
//  being freed.
//

extern VOID *_RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag, PSZ File, ULONG line );
extern VOID  _RxFreePool( PVOID PoolBlock, PSZ File, ULONG line );
extern BOOLEAN _RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxAllocatePoolWithTag( type, size, tag ) \
        _RxAllocatePoolWithTag( type, size, tag, __FILE__, __LINE__ )

#define RxFreePool( ptr ) \
        _RxFreePool( ptr, __FILE__, __LINE__ )

#define RxCheckMemoryBlock( ptr ) \
        _RxCheckMemoryBlock( ptr, __FILE__, __LINE__ )

#else  //  NOT RX_POOL_WRAPPER

//
// For retail builds, we want to go right to the regular (de)allocator
//

//  extern VOID *RxAllocatePool( ULONG PoolType, ULONG NumberOfBytes );
extern VOID *RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag );
extern VOID  RxFreePool( PVOID PoolBlock );
//  extern BOOLEAN RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxCheckMemoryBlock( ptr ) {NOTHING;}

#endif //  RX_POOL_WRAPPER

#define RxAllocatePool( type, size ) \
        RxAllocatePoolWithTag( type, size, '??xR' )

#if !DBG
#ifndef WRAPPER_CALLS_ONLY
#ifndef RX_POOL_WRAPPER
#define RxAllocatePoolWithTag ExAllocatePoolWithTag
#define RxFreePool ExFreePool
#endif //  RX_POOL_WRAPPER
#endif //  WRAPPER_CALLS_ONLY
#endif


extern 
NTSTATUS
RxDuplicateString(
    PUNICODE_STRING *Copy,
    PUNICODE_STRING Original,
    POOL_TYPE PoolType
    );

#define RxIsResourceOwnershipStateExclusive(__r) (FlagOn((__r)->Flag, ResourceOwnedExclusive))

#define RxProtectMdlFromFree( Mdl ) {NOTHING;}
#define RxUnprotectMdlFromFree( Mdl ) {NOTHING;}
#define RxMdlIsProtected( Mdl ) (FALSE)
#define RxTakeOwnershipOfMdl( Mdl ) {NOTHING;}
#define RxDisownMdl( Mdl ) {NOTHING;}
#define RxMdlIsOwned( Mdl ) (TRUE)

#define RxAllocateMdl( Buffer, BufferSize ) \
        IoAllocateMdl( Buffer, BufferSize, FALSE, FALSE, NULL )

#define RxMdlIsLocked( Mdl )         ((Mdl)->MdlFlags & MDL_PAGES_LOCKED)
#define RxMdlSourceIsNonPaged( Mdl ) ((Mdl)->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL)
#define RxMdlIsPartial( Mdl )        ((Mdl)->MdlFlags & MDL_PARTIAL)

#undef RxProbeAndLockPages
#define RxProbeAndLockPages( Mdl, Mode, Access, Status )          \
        Status = STATUS_SUCCESS;                                  \
        try {                                                     \
           MmProbeAndLockPages((Mdl), (Mode), (Access));          \
        } except (EXCEPTION_EXECUTE_HANDLER) {                    \
           Status = GetExceptionCode();                           \
        }

//
//  Macros for dealing with network header MDLs
//

//
//  This is the amount of space we preallocate in front of the smb header to hold
//  transport headers.  This number came from the server.  I suspect it is a worse case
//  value for all the transports that support MDL_NETWORK_HEADER
//

#define TRANSPORT_HEADER_SIZE 64 //  IPX_HEADER_SIZE+MAC_HEADER_SIZE

//
//  Mdls that are marked with the MDL_NETWORK_HEADER flag have extra space allocated before
//  the current start address that can be used for prepending lower-level headers.  The idea
//  is that when we want to prepend another header, we take the current mdl and adjust it to
//  include this extra header at the front of the message.  This is not strictly kosher and relies
//  on the behavior that the page the current header is on, and the page that the prepended header
//  is on, is the same page.  The way the macros work is that if they are not on the same page,
//  we don't set the NETWORK_HEADER flag, and the transport will use a second Mdl for the header.
//
//  Note that the other wierd thing about this is that we don't use the true buffer sizes.  The
//  buffer address is really offset TRANSPORT_HEADER_SIZE into the buffer.  The buffer size passed
//  in the buffer size without the TRANSPORT_HEADER_SIZE included.  Thus if the addition of the
//  TRANSPORT_HEADER_SIZE would cause the Mdl to span an additonal page, this optimization won't
//  work.
//

#define RxInitializeHeaderMdl( Mdl, Va, Len ) {             \
            MmInitializeMdl( Mdl, Va, Len );                \
            if (Mdl->ByteOffset >= TRANSPORT_HEADER_SIZE) { \
                Mdl->MdlFlags |= MDL_NETWORK_HEADER;        \
            }                                               \
        }

#define RxAllocateHeaderMdl( Buffer, BufferSize, Mdl ) {                 \
            Mdl = RxAllocateMdl( Buffer, BufferSize );                   \
            if ((Mdl) && (Mdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) {  \
                SetFlag( Mdl->MdlFlags, MDL_NETWORK_HEADER );            \
            }                                                            \
        }

#define RxMdlIsHeader( Mdl )    (FlagOn( Mdl )->MdlFlags, MDL_NETWORK_HEADER)

#define RxBuildPartialHeaderMdl( SourceMdl, TargetMdl, Va, Len ) {  \
    IoBuildPartialMdl( SourceMdl, TargetMdl, Va, Len );             \
    if (FlagOn(SourceMdl->MdlFlags, MDL_NETWORK_HEADER ) &&         \
        (TargetMdl->ByteOffset >= TRANSPORT_HEADER_SIZE)) {         \
            SetFlag( TargetMdl->MdlFlags, MDL_NETWORK_HEADER );     \
    }                                                               \
}

#define RxBuildHeaderMdlForNonPagedPool( Mdl) MmBuildMdlForNonPagedPool( Mdl )

#define RxProbeAndLockHeaderPages( Mdl, Mode, Access, Status ) \
         RxProbeAndLockPages( Mdl, Mode, Access, Status )

#define RxUnlockHeaderPages( Mdl ) MmUnlockPages( Mdl )


//
//  the next set of macros defines the prototype and the argument list for the toplevel (Common)
//  routines. these routines are just below the dispatch level and this is where the commonality
//  between win9x and NT begins. In addition, the IN PRX_CONTEXT RxContext and accompanying capture macros
//  could be platform specific as well. We must pass at least the RxContext; but on a RISC machine with
//  lots of registers we could pass a lot more. An adjustment would have to be made in the
//  RxFsdCommonDispatch in this case since the parameters are not yet captured at that point.
//

//
//  the reason why to say "RXSTATUS RxCommonRead (IN PRX_CONTEXT RxContext)" instead
//  of "RxCommon(Read)" is so that the standard tags programs will work. "RxCommon(Read):
//  doesn't look like a procedure definition
//

#define  RXCOMMON_SIGNATURE \
      PRX_CONTEXT RxContext

#define  RXCOMMON_ARGUMENTS \
      RxContext

#define RxGetRequestorProcess( RXCONTEXT ) IoGetRequestorProcess( RXCONTEXT->CurrentIrp )

//
//  RxGetRequestorProcess() returns what IoGetRequestorProcess() returns, which
//  is a pointer to a process structure.  Truncating this to 32 bits does
//  not yield a value that is unique to the process.
//
//  When a 32 bit value that is unique to the process is desired,
//  RxGetRequestorProcessId() must be used instead.
//

#define RxGetRequestorProcessId( RXCONTEXT ) IoGetRequestorProcessId( (RXCONTEXT)->CurrentIrp )

#define RxMarkContextPending( RXCONTEXT ) IoMarkIrpPending( (RXCONTEXT)->CurrentIrp )
                                               
#define RxSetCancelRoutine( Irp, CancelRoutine ) IoSetCancelRoutine( Irp, CancelRoutine );  

//
//  we do this as a macro because we may want to record that we did this adjustment so that
//  people who QFI for standardinfo will be forced to the net to get the right answer and that would
//  probably be better as a routine
//        

#define RxAdjustAllocationSizeforCC( FCB ) {\
        if ((FCB)->Header.FileSize.QuadPart > (FCB)->Header.AllocationSize.QuadPart) {        \
            PMRX_NET_ROOT NetRoot = (FCB)->pNetRoot;                                          \
            ULONGLONG ClusterSize = NetRoot->DiskParameters.ClusterSize;                      \
            ULONGLONG FileSize = (FCB)->Header.FileSize.QuadPart;                             \
            ASSERT(ClusterSize!=0);                                                           \
            (FCB)->Header.AllocationSize.QuadPart = (FileSize+ClusterSize)&~(ClusterSize-1);  \
        }                                                                                     \
        ASSERT ( (FCB)->Header.ValidDataLength.QuadPart <= (FCB)->Header.FileSize.QuadPart ); \
    }


#endif // _RX_NTDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\ntddnfs2.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
This file just builds on the old rdr's dd file.

I am just using the same fsctl code as rdr1....easy to change later.....

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ntddnfs2.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system device.

Author:



Revision History:

    Joe Linn       (JoeLinn) 08-aug-1994  Started changeover to rdr2

--*/

#ifndef _NTDDNFS2_
#define _NTDDNFS2_

#include <ntddnfs.h>

#define FSCTL_LMR_DEBUG_TRACE            _RDR_CONTROL_CODE(219, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_LMMR_STFFTEST              _RDR_CONTROL_CODE(239, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMMR_TEST                  _RDR_CONTROL_CODE(238, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define IOCTL_LMMR_TESTLOWIO             _RDR_CONTROL_CODE(237, METHOD_BUFFERED, FILE_ANY_ACCESS)

//this means whatever the minirdr wants
#define IOCTL_LMMR_MINIRDR_DBG           _RDR_CONTROL_CODE(236, METHOD_NEITHER,  FILE_ANY_ACCESS)

// lwio calls
#define IOCTL_LMR_LWIO_PREIO          	 _RDR_CONTROL_CODE(230, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define IOCTL_LMR_LWIO_POSTIO         	 _RDR_CONTROL_CODE(229, METHOD_NEITHER,  FILE_ANY_ACCESS)

#define IOCTL_LMR_DISABLE_LOCAL_BUFFERING     	 _RDR_CONTROL_CODE(228, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define IOCTL_LMR_QUERY_REMOTE_SERVER_NAME     	 _RDR_CONTROL_CODE(227, METHOD_BUFFERED,  FILE_ANY_ACCESS)

//
// This structure is used to determine for the server and file id of a given open file handle.
// It is used by the LWIO framework to determine which server it needs to connect to and
// what protocol is being used to communicate with the server.
//
typedef struct {
    ULONG	ServerNameLength;
    WCHAR	ServerName[1];
}QUERY_REMOTE_SERVER_NAME, *PQUERY_REMOTE_SERVER_NAME;


#endif  // ifndef _NTDDNFS2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rdbss.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rdbss.h

Abstract:

    This module defines the RDBSS specific data structures

Author:

    Balan Sethu Raman [SethuR]  16-July-95 -- Created

Revision History:

Notes:

    All the data structures that are exposed to the mini redirector writers need to be
    consolidated in this module.

--*/

#ifndef _RDBSS_H_
#define _RDBSS_H_

//
//  In the previous redirector implementation the file system statistics and the network
//  protocol statistics were combined into one data structure ( and correctly so ) since
//  the old redirector supported only one protocol. However this does not apply to the
//  new redirector (RDR2) since there are more than one mini redirectors and the two
//  need to be distingushed. The RDBSS_STATISTICS structure provides the file system
//  level statistics while the protocol level statistics definition is under the control of
//  the mini redirector implementers.
//
//  The staistics can be obtained by issuing the FSCTL_RDBSS_GET_STATISTICS. If no mini
//  redirector name is provided the RDBSS_STATISTICS are returned and if a mini
//  redirctor name is provided the statistics of the appropriate mini redirector are
//  returned ( the call is passed through to the appropriate mini redirector ).
//

typedef struct _RDBSS_STATISTICS {
   
    LARGE_INTEGER StatisticsStartTime;

    LARGE_INTEGER PagingReadBytesRequested;
    LARGE_INTEGER NonPagingReadBytesRequested;
    LARGE_INTEGER CacheReadBytesRequested;
    LARGE_INTEGER NetworkReadBytesRequested;
    
    LARGE_INTEGER PagingWriteBytesRequested;
    LARGE_INTEGER NonPagingWriteBytesRequested;
    LARGE_INTEGER CacheWriteBytesRequested;
    LARGE_INTEGER NetworkWriteBytesRequested;
    
    ULONG InitiallyFailedOperations;
    ULONG FailedCompletionOperations;
    
    ULONG ReadOperations;
    ULONG RandomReadOperations;
    ULONG WriteOperations;
    ULONG RandomWriteOperations;
    
    ULONG NumberOfSrvCalls;
    ULONG NumberOfSrvOpens;
    ULONG NumberOfNetRoots;
    ULONG NumberOfVirtualNetRoots;
} RDBSS_STATISTICS, *PRDBSS_STATISTICS;

//
//  This call is provided for the benefit of mini redirector implementers. Each mini
//  redirector writer is free to choose the appropriate division of labour between
//  the RDBSS and the corresponding mini redirector in maintaining the statistics.
//

NTSTATUS
RdbssGetStatistics (
    PRDBSS_STATISTICS RdbssStatistics
    );

#endif // _RDBSS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rx.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rx.h

Abstract:

    This module is the overall h-file-wrapper for RDBSS.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:


--*/

#ifndef _RX_H_
#define _RX_H_

#include "rxovride.h"   //  common compile environment
#include "ntifs.h"      //  NT file system driver include file.

#ifdef RX_PRIVATE_BUILD

//
//  no one should be using these
//

#ifdef IoGetTopLevelIrp
#error  IoGetTopLevelIrp is deffed
#else
#define IoGetTopLevelIrp() IoxxxxxxGetTopLevelIrp()
#endif
#ifdef IoSetTopLevelIrp
#error  IoSetTopLevelIrp is deffed
#else
#define IoSetTopLevelIrp(irp) IoxxxxxxSetTopLevelIrp(irp)
#endif
#endif //  ifdef RX_PRIVATE_BUILD


//
//  These macros sugarcoat flag manipulation just a bit
//

#ifndef BooleanFlagOn
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
#endif

#ifndef SetFlag
#define SetFlag(Flags,SetOfFlags) { \
    (Flags) |= (SetOfFlags);        \
}
#endif

#ifndef FlagOn

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

#ifndef ClearFlag
#define ClearFlag(Flags,SetOfFlags) { \
    (Flags) &= ~(SetOfFlags);         \
}
#endif

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

//
//  define INLINE to be the appropriate keyword for ANSI C
//

#define INLINE __inline

#include "rxtypes.h"

#ifndef MINIRDR__NAME
#include "rxpooltg.h"   //  RX pool tag macros
#endif

#include "ntrxdef.h"
#include "rxce.h"       //  RxCe functions
#include "rxcehdlr.h"   //  RxCe event handler specifications
#include "fcbtable.h"   //  FCB table data structures
#include "midatlax.h"   //  mid atlas structures
#include "mrxfcb.h"
#include "namcache.h"   //  structs and func defs for name cache routines
#include "rxworkq.h"
#include "rxprocs.h"
#include "rxexcept.h"

#ifndef MINIRDR__NAME
#include "rxdata.h"
#include "buffring.h"
#endif

#define MAKE_RESOURCE_OWNER(X) (((ERESOURCE_THREAD)(X)) | 0x3)
#define RESOURCE_OWNER_SET(X) (((X) & 0x3) == 0x3)

#endif // #ifdef _RX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxassert.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:

    Joe Linn     [JoeLinn]    21-oct-1996

Revision History:


Notes:


--*/

#ifndef _RDBSSASSERT_INCLUDED_
#define _RDBSSASSERT_INCLUDED_

VOID RxDbgBreakPoint(ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef RDBSS_ASSERTS

#if 0
#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#endif //!DBG
#endif

//this will make asserts go to our routine

#define RtlAssert RxAssert
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef RDBSS_ASSERTS


#endif // _RDBSSASSERT_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxdebug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.h

Abstract:

    This module contains the definition of auxilary data structures used in
    debugging. Each of the data structures is conditionalized by its own
    #ifdef tag.

Author:

    Balan Sethu Raman --

--*/

#ifndef _RXDEBUG_H_
#define _RXDEBUG_H_

extern VOID
RxInitializeDebugSupport();

extern VOID
RxTearDownDebugSupport();


#ifdef RX_WJ_DBG_SUPPORT

#define MAX_JOURNAL_BITMAP_SIZE (8 * 1024)


typedef struct _FCB_WRITE_JOURNAL_ {
    LIST_ENTRY      JournalsList;

    PFCB            pFcb;
    PWCHAR pName;

    LONG  WritesInitiated;
    LONG  LowIoWritesInitiated;
    LONG  LowIoWritesCompleted;

    PBYTE pWriteInitiationBitmap;
    PBYTE pLowIoWriteInitiationBitmap;
    PBYTE pLowIoWriteCompletionBitmap;

    BYTE WriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteCompletionBitmap[MAX_JOURNAL_BITMAP_SIZE];

    WCHAR           Path[MAX_PATH] ;

} FCB_WRITE_JOURNAL, *PFCB_WRITE_JOURNAL;

// forward declarations

VOID
RxdInitializeWriteJournalSupport();

VOID
RxdTearDownWriteJournalSupport();

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length);

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);


#endif // RX_WJ_DBG_SUPPORT

#endif // _RXDEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxcehdlr.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcehdlr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    All the necessary types can be redefined in terms of the types defined in
    \nt\private\inc\tdi.h in the case of NT. For Win95 we will provide the
    appropriate definitions.

--*/

#ifndef _RXCEHDLR_H_
#define _RXCEHDLR_H_

#include "tdi.h"

typedef TDI_PROVIDER_INFO RXCE_TRANSPORT_PROVIDER_INFO;
typedef RXCE_TRANSPORT_PROVIDER_INFO* PRXCE_TRANSPORT_PROVIDER_INFO;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFO RXCE_CONNECTION_INFO;
typedef RXCE_CONNECTION_INFO* PRXCE_CONNECTION_INFO;

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ : public RXCE_TRANSPORT_PROVIDER_INFO {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ {
   RXCE_TRANSPORT_PROVIDER_INFO;
#endif // __cplusplus

   ULONG  ConnectionCount;
   ULONG  QualityOfService;
} RXCE_TRANSPORT_INFORMATION, *PRXCE_TRANSPORT_INFORMATION;

typedef enum _RXCE_CONNECTION_INFORMATION_CLASS_ {
    RxCeTransportProviderInformation = 1,
    RxCeConnectionInformation,
    RxCeConnectionEndpointInformation,
    RxCeRemoteAddressInformation
} RXCE_CONNECTION_INFORMATION_CLASS,
  *PRXCE_CONNECTION_INFORMATION_CLASS;

typedef struct _RXCE_VC_         *PRXCE_VC;
typedef struct _RXCE_CONNECTION_ *PRXCE_CONNECTION;
typedef struct _RXCE_ADDRESS_    *PRXCE_ADDRESS;
typedef struct _RXCE_TRANSPORT_  *PRXCE_TRANSPORT;

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it.
//

typedef
NTSTATUS
(*PRXCE_IND_DISCONNECT)(
    IN PVOID            pRxCeEventContext,
    IN PRXCE_VC         pVc,
    IN int              DisconnectDataLength,
    IN PVOID            DisconnectData,
    IN int              DisconnectInformationLength,
    IN PVOID            DisconnectInformation,
    IN ULONG            DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
//

typedef
NTSTATUS
(*PRXCE_IND_ENDPOINT_ERROR)(
    IN PVOID    pRxCeEventContext,    // the event context.
    IN NTSTATUS Status                // status code indicating error type.
    );


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_ERROR)(
    IN PVOID       pRxCeEventContext,    // the event context.
    PRXCE_VC       pVc,                  // the associated VC handle
    IN NTSTATUS    Status                // status code indicating error type.
    );

//
// RXCE_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE)(
    IN PVOID pRxCeEventContext,       // the context provided during registration
    IN PRXCE_VC    pVc,           // the associated VC handle
    IN ULONG ReceiveFlags,            // the receive flags
    IN ULONG BytesIndicated,          // the number of received bytes indicated
    IN ULONG BytesAvailable,          // the total number of bytes available
    OUT ULONG *BytesTaken,            // return indication of the bytes consumed
    IN PVOID Tsdu,                    // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,     // the buffer for copying the bytes not indicated.
    OUT PULONG  pDataBufferSize       // amount of data to copy
    );


//
// RXCE_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_DATAGRAM)(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,      // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize        // amount of data to copy
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_EXPEDITED)(
    IN PVOID pRxCeEventContext,     // the context provided during registration
    IN PRXCE_VC     pVc,        // the associated VC handle
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,   // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize     // amount of data to copy
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_POSSIBLE)(
    IN PVOID pRxCeEventContext,
    IN PRXCE_VC pVc,
    IN ULONG BytesAvailable);

//
// RxCeDataReadyEventHandler -- This is invoked when the desired data is available
// for client consumption. This always follows a receive indication in which the
// client returns a buffer for copying the remaining data
//

typedef
NTSTATUS
(*PRXCE_IND_DATA_READY)(
   IN PVOID         pEventContext,
   IN PMDL  pBuffer,
   IN ULONG         CopiedDataSize,
   IN NTSTATUS      CopyDataStatus);


//
// RxCeSendCompleteEventHandler -- This is invoked when the send has been successfully completed
// The buffer and the length sent are passed in as parameters
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_COMPLETE)(
   IN PVOID       pEventContext,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_COMPLETE)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

//
// Event Handler Dispatch Vector definitions ....
//

typedef struct _RXCE_ADDRESS_EVENT_HANDLER_ {
   PRXCE_IND_ENDPOINT_ERROR   RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM RxCeReceiveDatagramEventHandler;
   PRXCE_IND_DATA_READY       RxCeDataReadyEventHandler;
   PRXCE_IND_SEND_POSSIBLE    RxCeSendPossibleEventHandler;
   PRXCE_IND_SEND_COMPLETE    RxCeSendCompleteEventHandler;
} RXCE_ADDRESS_EVENT_HANDLER, *PRXCE_ADDRESS_EVENT_HANDLER;

typedef struct _RXCE_CONNECTION_EVENT_HANDLER_ {
   PRXCE_IND_DISCONNECT                   RxCeDisconnectEventHandler;
   PRXCE_IND_CONNECTION_ERROR             RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE                      RxCeReceiveEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM             RxCeReceiveDatagramEventHandler;
   PRXCE_IND_RECEIVE_EXPEDITED            RxCeReceiveExpeditedEventHandler;
   PRXCE_IND_SEND_POSSIBLE                RxCeSendPossibleEventHandler;
   PRXCE_IND_DATA_READY                   RxCeDataReadyEventHandler;
   PRXCE_IND_CONNECTION_SEND_COMPLETE     RxCeSendCompleteEventHandler;
} RXCE_CONNECTION_EVENT_HANDLER, *PRXCE_CONNECTION_EVENT_HANDLER;

#endif // _RXCEHDLR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxcontx.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxContx.h

Abstract:

    This module defines RxContext data structure. This structure is used to
    describe an Irp whil it is being processed and contains state information
    that allows global resources to be released as the irp is completed.

Author:

    Joe Linn           [JoeLinn]   19-aug-1994

Revision History:

    Balan Sethu Raman  [SethuR]    11-4-95

Notes:

    The RX_CONTEXT is a data structure to which additional information provided
    by the various mini redirectors need to be attached. This can be done in one
    of the following three ways

      1) Allow for context pointers to be defined as part of the RX_CONTEXT which
      the mini redirectors can use to squirrel away their information. This
      implies that every time an RX_CONTEXT is allocated/destroyed the mini
      redirector has to perform an associated allocation/destruction.

      Since RX_CONTEXT's are created/destroyed in great numbers, this is not an
      acceptable solution.

      2) The second approach consists of over allocating RX_CONTEXT's by a
      prespecified amount for each mini redirector which is then reserved for
      use by the mini redirector. Such an approach avoids the additional
      allocation/destruction but complicates the RX_CONTEXT management code in
      the wrapper.

      3) The third approach ( the one that is implemented ) consists of allocating
      a prespecfied area which is the same for all mini redirectors as part of
      each RX_CONTEXT. This is an unformatted area on top of which any desired
      structure can be imposed by the various mini redirectors. Such an approach
      overcomes the disadvantages associated with (1) and (2).

      All mini redirector writers must try and define the associated mini redirector
      contexts to fit into this area. Those mini redirectors who violate this
      rule will incur a significant performance penalty.

--*/

#ifndef _RX_CONTEXT_STRUCT_DEFINED_
#define _RX_CONTEXT_STRUCT_DEFINED_
#ifndef RDBSS_TRACKER
#error tracker must be defined right now
#endif

#define RX_TOPLEVELIRP_CONTEXT_SIGNATURE ('LTxR')
typedef struct _RX_TOPLEVELIRP_CONTEXT {
    union {
#ifndef __cplusplus
        LIST_ENTRY;
#endif //  __cplusplus
        LIST_ENTRY ListEntry;
    };
    ULONG Signature;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT RxContext;
    PIRP Irp;
    ULONG Flags;
    PVOID Previous;
    PETHREAD Thread;
} RX_TOPLEVELIRP_CONTEXT, *PRX_TOPLEVELIRP_CONTEXT;

BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceTopLevel
    );

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG Flags
    );
#define RxInitializeTopLevelIrpContext(a,b,c) {__RxInitializeTopLevelIrpContext(a,b,c,0);}

PIRP
RxGetTopIrpIfRdbssIrp (
    VOID
    );

PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    VOID
    );

VOID
RxUnwindTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    );

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN PIRP Irp
    );

#ifdef RDBSS_TRACKER
typedef struct _RX_FCBTRACKER_CALLINFO {
    ULONG AcquireRelease;
    USHORT SavedTrackerValue;
    USHORT LineNumber;
    PSZ   FileName;
    ULONG Flags;
} RX_FCBTRACKER_CALLINFO, *PRX_FCBTRACKER_CALLINFO;
#define RDBSS_TRACKER_HISTORY_SIZE 32
#endif

#define MRX_CONTEXT_FIELD_COUNT    4
#define MRX_CONTEXT_SIZE   (sizeof(PVOID) * MRX_CONTEXT_FIELD_COUNT)

//
//  Define rxdriver dispatch routine type....almost all of the important routine
//  will have this type.
//

typedef
NTSTATUS
(NTAPI *PRX_DISPATCH) (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

//
//  predeclare dfs types
//

typedef struct _DFS_NAME_CONTEXT_ *PDFS_NAME_CONTEXT;

typedef struct _NT_CREATE_PARAMETERS {
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG Disposition;
    ULONG CreateOptions;
    PIO_SECURITY_CONTEXT SecurityContext;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PVOID DfsContext;
    PDFS_NAME_CONTEXT DfsNameContext;
} NT_CREATE_PARAMETERS, *PNT_CREATE_PARAMETERS;

typedef struct _RX_CONTEXT {
    
    //
    //  the node type, size and reference count, aka standard header
    // 

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    ULONG ReferenceCount;

    //
    //  the list entry to wire the context to the list of active contexts
    //

    LIST_ENTRY ContextListEntry;

    //
    //  Major and minor function of the IRP associated with the context
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  this is similar to the same field in Irps; it
    //  allows callback routines for async operations
    //  to know whether to do asynchronous work or not
    //

    BOOLEAN PendingReturned;

    //
    //  indicates if the associated request is to be posted to a RDBSS worker thread.
    //

    BOOLEAN PostRequest;

    //
    //  Originating Device (required for workque algorithms)
    //  not currently used but could be used for local minis
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  ptr to the originating Irp
    //

    PIRP CurrentIrp;

    //
    //  ptr to the IRP stack location
    //

    PIO_STACK_LOCATION CurrentIrpSp;

    //
    //  ptr to the FCB and FOBX, derived from the context pointers in the
    //  file object associated with the IRP
    //

    PMRX_FCB pFcb;
    PMRX_FOBX pFobx;
    PMRX_SRV_OPEN pRelevantSrvOpen;
    PNON_PAGED_FCB NonPagedFcb;

    //
    //  device object calldown (not irpsp.....)
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    //
    //  The original thread in which the request was initiated and the last
    //  thread in which some processing associated with the context was done
    //

    PETHREAD OriginalThread;
    PETHREAD LastExecutionThread;

    PVOID LockManagerContext;

    //
    //  One word of the context is given to rdbss for dbg information
    //

    PVOID RdbssDbgExtension;

    RX_SCAVENGER_ENTRY ScavengerEntry;

    //
    //  global serial number for this operation
    //

    ULONG SerialNumber;

    //
    //  used by minirdrs to see if multiple calls are part
    //  of the same larger operation and (therefore) more cacheable
    //

    ULONG FobxSerialNumber;

    ULONG Flags;

    BOOLEAN FcbResourceAcquired;
    BOOLEAN FcbPagingIoResourceAcquired;
    UCHAR MustSucceedDescriptorNumber;

    //
    //  mostly you want the individual components...sometimes it's nice as a pair
    //  used to record the status when you can't just return it; e.g., when
    //  RXSTATUS is not an appropriate return type or if the consumer of the
    //  status didn't call directly (lowiocompletions). minirdrs will not need
    //  to set the information directly
    //

    union {
        struct {
            union {
                NTSTATUS StoredStatus;
                PVOID StoredStatusAlignment;
            };
            ULONG_PTR InformationToReturn;
        };
        IO_STATUS_BLOCK IoStatusBlock;
    };

    //
    //  the context fields provided for use by the mini redirectors
    //  this is defined as a union to force longlong alignment
    //

    union {
        ULONGLONG ForceLonglongAligmentDummyField;
        PVOID MRxContext[MRX_CONTEXT_FIELD_COUNT];
    };

    //
    //  The following field is included to fix the problem related to write only
    //  opens. This introduces a new field for the mini redirector to squirrel
    //  some state. This is redundant and should be removed after Windows 2000.
    //  Having a unique field reduces the impact of the change that we are making
    //  to the specific code path. It will be ideal to use one of the MRXContext
    //  fields defined above
    //

    PVOID WriteOnlyOpenRetryContext;

    //
    //  the cancellation routine to be invoked, set by the mini redirector
    //

    PMRX_CALLDOWN MRxCancelRoutine;

    //
    //  private dispatch, if any. used in fspdisp
    //

    PRX_DISPATCH ResumeRoutine;

    //
    //  for posting to worker threads
    //  the minirdr can use this for posting within the minirdr
    //  a potential problem can arise if the minirdr relies on this both
    //  for queueing async stuff and for queueing cancel stuff
    //

    //
    //  The OverflowListEntry is used for queueing items to the overflow queue.
    //  This is seperate now to allow us to distinguish between an item in the overflow
    //  queue and one in the active work queue (for cancellation logic)
    //

    RX_WORK_QUEUE_ITEM WorkQueueItem;
    LIST_ENTRY OverflowListEntry;

    //
    //  this event is used for synchronous operations
    //  that have to i/f with an underlying async service. it can be used
    //  by the minirdr with the following provisions:
    //      1) on entering the minirdr through lowio, it is set to the
    //         nonsignaled state (but a wise user will reset it before using
    //         it....particularly if it's used multiple times.
    //      2) if you are returning STATUS_PENDING on a sync operation, you must
    //         return with it set to the nonsignaled state; that is, either
    //         you don't use it or you reset it in this case
    //

    KEVENT SyncEvent;

    //
    //  this is a list head of operations that are to be released on completion
    //

    LIST_ENTRY BlockedOperations;

    //
    //  this is the mutex that controls serialization of the blocked operations
    //

    PFAST_MUTEX BlockedOpsMutex;

    //
    //  these links are used to serialize pipe operations on a
    //  per-file-object basis AND FOR LOTS OF OTHER STUFF
    //

    LIST_ENTRY RxContextSerializationQLinks;

    union {
        struct {
            union {
                FS_INFORMATION_CLASS FsInformationClass;
                FILE_INFORMATION_CLASS FileInformationClass;
            };
            PVOID Buffer;
            union {
                LONG Length;
                LONG LengthRemaining;
            };
            BOOLEAN ReplaceIfExists;
            BOOLEAN AdvanceOnly;
        } Info;

        struct {
            UNICODE_STRING SuppliedPathName;
            NET_ROOT_TYPE NetRootType;
            PIO_SECURITY_CONTEXT pSecurityContext;
        } PrefixClaim;
    };

    //
    //  THIS UNION MUST BE LAST....AT SOME POINT, WE MAY START ALLOCATING
    //  SMALLER PER OPERATION!
    //

    union{
        struct {
            NT_CREATE_PARAMETERS NtCreateParameters; //  a copy of the createparameters
            ULONG ReturnedCreateInformation;
            PWCH CanonicalNameBuffer;  // if the canonical name is larger than available buffer
            PRX_PREFIX_ENTRY NetNamePrefixEntry;   // the entry returned by the lookup....for dereferencing

            PMRX_SRV_CALL pSrvCall;              // Server Call being used
            PMRX_NET_ROOT pNetRoot;              // Net Root being used
            PMRX_V_NET_ROOT pVNetRoot;             // Virtual Net Root
            //PMRX_SRV_OPEN        pSrvOpen;              // Server Open

            PVOID EaBuffer;
            ULONG EaLength;

            ULONG SdLength;

            ULONG PipeType;
            ULONG PipeReadMode;
            ULONG PipeCompletionMode;

            USHORT Flags;
            NET_ROOT_TYPE Type;                 // Type of Net Root(Pipe/File/Mailslot..)

            BOOLEAN FcbAcquired;
            BOOLEAN TryForScavengingOnSharingViolation;
            BOOLEAN ScavengingAlreadyTried;

            BOOLEAN ThisIsATreeConnectOpen;
            BOOLEAN TreeConnectOpenDeferred;
            UNICODE_STRING TransportName;
            UNICODE_STRING UserName;
            UNICODE_STRING Password;
            UNICODE_STRING UserDomainName;
        } Create;
        struct {
            ULONG FileIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
            BOOLEAN InitialQuery;
        } QueryDirectory;
        struct {
            PMRX_V_NET_ROOT pVNetRoot;
        } NotifyChangeDirectory;
        struct {
            PUCHAR UserEaList;
            ULONG UserEaListLength;
            ULONG UserEaIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryEa;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;
        struct {
            ULONG Length;
            PSID StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG SidListLength;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryQuota;
        struct {
            ULONG Length;

        } SetQuota;
        struct {
            PV_NET_ROOT VNetRoot;
            PSRV_CALL SrvCall;
            PNET_ROOT NetRoot;
        } DosVolumeFunction;
        struct {
            ULONG FlagsForLowIo;
            LOWIO_CONTEXT LowIoContext;        //  the LOWIO parameters
        }; //  no name here....
        LUID FsdUid;
    } ;

    //
    //  CODE.IMPROVEMENT remove this to wrapperdbgprivates
    //

    PWCH AlsoCanonicalNameBuffer;  //  if the canonical name is larger than available buffer
    PUNICODE_STRING LoudCompletionString;

#ifdef RDBSS_TRACKER
    LONG AcquireReleaseFcbTrackerX;
    ULONG TrackerHistoryPointer;
    RX_FCBTRACKER_CALLINFO TrackerHistory[RDBSS_TRACKER_HISTORY_SIZE];
#endif

#if DBG
    ULONG ShadowCritOwner;
#endif

} RX_CONTEXT, *PRX_CONTEXT;

typedef enum {
    RX_CONTEXT_FLAG_FROM_POOL =                     0x00000001,
    RX_CONTEXT_FLAG_WAIT =                          0x00000002,
    RX_CONTEXT_FLAG_WRITE_THROUGH =                 0x00000004,
    RX_CONTEXT_FLAG_FLOPPY =                        0x00000008,
    RX_CONTEXT_FLAG_RECURSIVE_CALL =                0x00000010,
    RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL =         0x00000020,
    RX_CONTEXT_FLAG_DEFERRED_WRITE =                0x00000040,
    RX_CONTEXT_FLAG_VERIFY_READ =                   0x00000080,
    RX_CONTEXT_FLAG_STACK_IO_CONTEZT =              0x00000100,
    RX_CONTEXT_FLAG_IN_FSP =                        0x00000200,
    RX_CONTEXT_FLAG_CREATE_MAILSLOT =               0x00000400,
    RX_CONTEXT_FLAG_MAILSLOT_REPARSE =              0x00000800,
    RX_CONTEXT_FLAG_ASYNC_OPERATION =               0x00001000,
    RX_CONTEXT_FLAG_NO_COMPLETE_FROM_FSP =          0x00002000,
    RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION =      0x00004000,
    RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE =    0x00008000,
    RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE =   0x00010000,
    RX_CONTEXT_FLAG_MINIRDR_INVOKED =               0x00020000,
    RX_CONTEXT_FLAG_WAITING_FOR_RESOURCE =          0x00040000,
    RX_CONTEXT_FLAG_CANCELLED =                     0x00080000,
    RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS =            0x00100000,
    RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED =          0x00200000,
    RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK =          0x00400000,
    RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME =           0x00800000,
    RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE =        0x01000000,
    RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT =       0x02000000,
    RX_CONTEXT_FLAG_NEEDRECONNECT =                 0x04000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED =                  0x08000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING =      0x10000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED =        0x20000000,
    RX_CONTEXT_FLAG_MINIRDR_INITIATED =             0x80000000,   
} RX_CONTEXT_FLAGS;

#define RX_CONTEXT_PRESERVED_FLAGS (RX_CONTEXT_FLAG_FROM_POOL | \
                                    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED | \
                                    RX_CONTEXT_FLAG_IN_FSP)

#define RX_CONTEXT_INITIALIZATION_FLAGS (RX_CONTEXT_FLAG_WAIT | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING)

typedef enum {
    RX_CONTEXT_CREATE_FLAG_UNC_NAME =                       0x1,
    RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH =    0x2,
    RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH =                 0x4,
    RX_CONTEXT_CREATE_FLAG_REPARSE =                        0x8,
    RX_CONTEXT_CREATE_FLAG_SPECIAL_PATH =                   0x10,
} RX_CONTEXT_CREATE_FLAGS;

typedef enum {
    RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION =                   0x1,
    RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION =              0x2,
    RXCONTEXT_FLAG4LOWIO_READAHEAD =                        0x4,
    RXCONTEXT_FLAG4LOWIO_THIS_READ_ENLARGED =               0x8,
    RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED =                 0x10,
    RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD =           0x20,
    RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER =   0x40,
    RXCONTEXT_FLAG4LOWIO_THIS_IO_FAST =                     0x80,
    RXCONTEXT_FLAG4LOWIO_LOCK_OPERATION_COMPLETED =         0x100

#ifdef __cplusplus
} RX_CONTEXT_LOWIO_FLAGS;
#else // !__cplusplus
} RX_CONTEXT_CREATE_FLAGS;
#endif // __cplusplus

//
//  Macros used to control whether the wrapper breakpoints on an exception
//

#if DBG
#define RxSaveAndSetExceptionNoBreakpointFlag( RXCONTEXT,OLDFLAG ) { \
    OLDFLAG = FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );\
    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );      \
}
#define RxRestoreExceptionNoBreakpointFlag( RXCONTEXT,OLDFLAG ) { \
    ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );    \
    SetFlag( RxContext->Flags, OLDFLAG );                              \
}
#else
#define RxSaveAndSetExceptionNoBreakpointFlag(RXCONTEXT,OLDFLAG)
#define RxRestoreExceptionNoBreakpointFlag(RXCONTEXT,OLDFLAG)
#endif

//
//  a macro used to ensure that a context hasn't been freed during a wait
//

#if DBG
VOID
__RxItsTheSameContext(
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    );
#define RxItsTheSameContext() {__RxItsTheSameContext(RxContext,CapturedRxContextSerialNumber,__LINE__,__FILE__);}
#else
#define RxItsTheSameContext() {NOTHING;}
#endif

extern NPAGED_LOOKASIDE_LIST RxContextLookasideList;

//
//  Macros used in the RDBSS to wrap mini rdr calldowns
//

#define MINIRDR_CALL_THROUGH(STATUS,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if (DISPATCH->FUNC == NULL) {                                          \
        STATUS = STATUS_NOT_IMPLEMENTED;                                   \
    } else {                                                               \
        RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));             \
        STATUS = DISPATCH->FUNC ARGLIST;                                   \
    }                                                                      \
   }

#define MINIRDR_CALL(STATUS,CONTEXT,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if ( DISPATCH->FUNC == NULL) {                                         \
       STATUS = STATUS_NOT_IMPLEMENTED;                                    \
    } else {                                                               \
       if (!BooleanFlagOn((CONTEXT)->Flags,RX_CONTEXT_FLAG_CANCELLED)) {   \
          RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));           \
          RtlZeroMemory(&((CONTEXT)->MRxContext[0]),                       \
                        sizeof((CONTEXT)->MRxContext));                    \
          STATUS = DISPATCH->FUNC ARGLIST;                                 \
       } else {                                                            \
          STATUS = STATUS_CANCELLED;                                       \
       }                                                                   \
    }                                                                      \
   }


//              
//  VOID
//  RxWaitSync (
//      IN PRX_CONTEXT RxContext
//      )
//              

#define  RxWaitSync( RxContext )                                                 \
         RxDbgTrace(+1, Dbg, ("RxWaitSync, RxContext = %08lx\n", (RxContext)));  \
         (RxContext)->Flags |= RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             \
         RxDbgTrace(-1, Dbg, ("RxWaitSync -> VOID\n", 0 ))

//             
//  VOID
//  RxSignalSynchronousWaiter (
//      IN PRX_CONTEXT RxContext
//  ) 
//             

#define RxSignalSynchronousWaiter( RxContext )                     \
        (RxContext)->Flags &= ~RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )


#define RxInsertContextInSerializationQueue( SerializationQueue, RxContext ) \
        (RxContext)->Flags |= RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE;       \
        InsertTailList( SerializationQueue, &((RxContext)->RxContextSerializationQLinks ))

INLINE 
PRX_CONTEXT
RxRemoveFirstContextFromSerializationQueue (
    PLIST_ENTRY SerializationQueue
    )
{
   if (IsListEmpty( SerializationQueue )) {
      return NULL;
   } else {
      PRX_CONTEXT Context = (PRX_CONTEXT)(CONTAINING_RECORD( SerializationQueue->Flink,
                                            RX_CONTEXT,
                                            RxContextSerializationQLinks ));

      RemoveEntryList( SerializationQueue->Flink );

      Context->RxContextSerializationQLinks.Flink = NULL;
      Context->RxContextSerializationQLinks.Blink = NULL;
      return Context;
   }
}

//
//  The following macros provide a mechanism for doing an en masse transfer
//  from one list onto another. This provides a powerful paradigm for dealing
//  with DPC level processing of lists.
//

#define RxTransferList( Destination, Source )                  \
         if (IsListEmpty( (Source) )) {                        \
            InitializeListHead( (Destination) );               \
         } else {                                              \
            *(Destination) = *(Source);                        \
            (Destination)->Flink->Blink = (Destination);       \
            (Destination)->Blink->Flink = (Destination);       \
            InitializeListHead( (Source) );                    \
         }

#define RxTransferListWithMutex( Destination, Source, Mutex )  \
    {                                                          \
        ExAcquireFastMutex( Mutex );                           \
        RxTransferList( Destination, Source );                 \
        ExReleaseFastMutex( Mutex );                           \
    }


VOID 
RxInitializeRxContexter (
    VOID
    );

VOID 
RxUninitializeRxContexter (
    VOID
    );

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot (
   PV_NET_ROOT VNetRoot,
   BOOLEAN ForceFilesClosed
   );

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx (
   PFOBX Fobx
   );

NTSTATUS
NTAPI
RxSetMinirdrCancelRoutine (
    IN OUT PRX_CONTEXT RxContext,
    IN PMRX_CALLDOWN MRxCancelRoutine
    );

VOID
NTAPI
RxInitializeContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext
    );

PRX_CONTEXT
NTAPI
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    );

VOID
NTAPI
RxPrepareContextForReuse (
   IN OUT PRX_CONTEXT RxContext
   );

VOID
NTAPI
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxReinitializeContext (
   IN OUT PRX_CONTEXT RxContext
   );

#if DBG
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
    (RXCONTEXT) = NULL;                    \
}
#else
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
}
#endif //

extern FAST_MUTEX RxContextPerFileSerializationMutex;

NTSTATUS
NTAPI
__RxSynchronizeBlockingOperations (
    IN OUT PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN BOOLEAN DropFcbLock
    );
#define RxSynchronizeBlockingOperationsAndDropFcbLock(RXCONTEXT,FCB,IOQUEUE) \
              __RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE,TRUE)
#define RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE) \
              __RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE,FALSE)

VOID
NTAPI
RxResumeBlockedOperations_Serially (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    );

VOID
RxResumeBlockedOperations_ALL (
    IN OUT PRX_CONTEXT RxContext
    );


VOID
RxCancelBlockingOperation (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

VOID
RxRemoveOperationFromBlockingQueue (
    IN OUT PRX_CONTEXT RxContext
    );

#endif // _RX_CONTEXT_STRUCT_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxce.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxce.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    There are four important data structures that are created/manipulated by the
    various functions associated with the connection engine. Thesr are
    RXCE_TRANSPORT,RXCE_ADDRESS,RXCE_CONNECTION and RXCE_VC.

    The mini redirector writers can embed these data structures in the corresponding
    definitions and invoke the two routines provided for each type to build and
    tear down the connection engine portions. These routines do not allocate/free
    the memory associated with these instances. This provides a flexible mechanism
    for the mini redirector writers to manage instances.

--*/

#ifndef _RXCE_H_
#define _RXCE_H_

#include <nodetype.h>
#include <rxcehdlr.h>    // TDI related definitions.
#include <rxworkq.h>
//
// The connection engine deals with three kinds of entities, transports, transport
// addresses and transport connections. The transports are bindings to the various
// transport service providers on any system. The transport addresses are the
// local connection end points. The connections are transport connections between
// endpoints.  Each connection encapsulates a  number of virtual circuits
// ( typically 1 ).
//

// All the four node types are tagged with  the following signature which is used
// extensively in validating them

typedef struct _RXCE_SIGNATURE_ {
    union {
        struct {
            USHORT  Type;
            CSHORT  Size;
        };

        ULONG   Signature;
    };
} RXCE_SIGNATURE, *PRXCE_SIGNATURE;

//
// RXCE_TRANSPORT encapsulates all the parameters w.r.t. a TRANSPORT
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    UNICODE_STRING                Name;

    PDEVICE_OBJECT                pDeviceObject;             // Device object for transport
    HANDLE                        ControlChannel;            // Control Channel
    PFILE_OBJECT                  pControlChannelFileObject; // File object for the control channel

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;             // Transport Provider Information.

    LONG                          ConnectionCount;           // Number of connections on xport.
    LONG                          VirtualCircuitCount;       // no. of connections
    ULONG                         QualityOfService;          // quality of service provided.
} RXCE_TRANSPORT;

#define RXCE_TRANSPORT_SIGNATURE ((sizeof(RXCE_TRANSPORT) << 16) | RDBSS_NTC_RXCE_TRANSPORT)

#define RxCeIsTransportValid(pTransport)    \
        ((pTransport)->Signature == RXCE_TRANSPORT_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildTransport(
    IN PRXCE_TRANSPORT pRxCeTransport,
    IN PUNICODE_STRING pTransportName,
    IN ULONG           QualityOfService);

extern NTSTATUS
NTAPI
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT         pTransport,
    struct _ADAPTER_STATUS *pAdapterStatus);

extern NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation);

//
// RXCE_ADDRESS encapsulates all the parameters w.r.t. a local transport address
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_ADDRESS_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_ADDRESS_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_TRANSPORT             pTransport;          // the transport handle
    PTRANSPORT_ADDRESS          pTransportAddress;   // the transport address
    PVOID					    pContext;            // the context used in event dispatch
    PRXCE_ADDRESS_EVENT_HANDLER pHandler;            // the address event handler
    PMDL                        pReceiveMdl;         // the MDL for handling Receives Supplied by client
    HANDLE                      hAddress;            // handle to the address object
    PFILE_OBJECT                pFileObject;         // the file object for the address
    LONG                        ConnectionCount;     // no. of connections
    LONG                        VirtualCircuitCount; // no. of vcs
} RXCE_ADDRESS;

#define RXCE_ADDRESS_SIGNATURE ((sizeof(RXCE_ADDRESS) << 16) | RDBSS_NTC_RXCE_ADDRESS)

#define RxCeIsAddressValid(pAddress)    \
        ((pAddress)->Signature == RXCE_ADDRESS_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS            pAddress,
    IN  PRXCE_TRANSPORT             pTransport,
    IN  PTRANSPORT_ADDRESS          pTransportAddress,
    IN  PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN  PVOID                       pEventContext);

extern NTSTATUS
NTAPI
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress);

//
// RxCe Connection Establishment methods ....
//
//
// RXCE_CONNECTION encapsulates all the information w.r.t. a connection
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_CONNECTION_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_CONNECTION_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_ADDRESS                   pAddress;            // the local address for this connection
    ULONG                           VirtualCircuitCount; // the number of virtual circuits associated with the connection
    PVOID			                pContext;            // the context used in event dispatch
    PRXCE_CONNECTION_EVENT_HANDLER  pHandler;            // the event handler for the connection
    PRXCE_CONNECTION_INFORMATION    pConnectionInformation; // the remote address ...
} RXCE_CONNECTION;

#define RXCE_CONNECTION_SIGNATURE ((sizeof(RXCE_CONNECTION) << 16) | RDBSS_NTC_RXCE_CONNECTION)

#define RxCeIsConnectionValid(pConnection)    \
        ((pConnection)->Signature == RXCE_CONNECTION_SIGNATURE)

//
// The following enumerated type defines the various choices presented for
// selecting the transport over which a connection should be established
//

typedef enum _RXCE_CONNECTION_CREATE_OPTIONS_ {
    RxCeSelectFirstSuccessfulTransport,
    RxCeSelectBestSuccessfulTransport,
    RxCeSelectAllSuccessfulTransports
} RXCE_CONNECTION_CREATE_OPTIONS,
  *PRXCE_CONNECTION_CREATE_OPTIONS;

typedef struct _RXCE_CONNECTION_COMPLETION_CONTEXT_ {
    NTSTATUS            Status;
    ULONG               AddressIndex;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    
    // This is used to pass the UNICODE DNS name returned back from TDI
    PRXCE_CONNECTION_INFORMATION pConnectionInformation;
} RXCE_CONNECTION_COMPLETION_CONTEXT,
  *PRXCE_CONNECTION_COMPLETION_CONTEXT;

typedef
NTSTATUS
(*PRXCE_CONNECTION_COMPLETION_ROUTINE)(
    PRXCE_CONNECTION_COMPLETION_CONTEXT pCompletionContext);

extern NTSTATUS
NTAPI
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                           pLocalAddress,
    IN  PRXCE_CONNECTION_INFORMATION            pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER          pHandler,
    IN  PVOID                                   pEventContext,
    IN OUT PRXCE_CONNECTION                     pConnection,
    IN OUT PRXCE_VC                             pVc);

extern NTSTATUS
NTAPI
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOption,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext);

extern NTSTATUS
NTAPI
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection);


extern NTSTATUS
NTAPI
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation);


//
// RXCE_VC encapsulates all the information w.r.t a virtual circuit (VC)
// connection to a particular server as regards the connection engine.
//
// Typically one VC is associated with a connection. However, there are instances in
// which more than one VC can be associated with a connection. In order to efficiently
// handle the common case well and at the same time provide an extensible mechanism we
// define a collection data structure ( a list ) which subsumes the allocation for
// one virtual circuit. It is also imperative that we restrict the knowledge of
// how this collection is organized to as few methods as possible in order to
// enable optimization/restructuring of this data structure at a later time.
//

#define RXCE_VC_ACTIVE       ((LONG)0xaa)
#define RXCE_VC_DISCONNECTED ((LONG)0xdd)
#define RXCE_VC_TEARDOWN     ((LONG)0xbb)

#ifdef __cplusplus
typedef struct _RXCE_VC_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_VC_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_CONNECTION         pConnection;         // the referenced connection instance
    HANDLE                   hEndpoint;           // local endpoint for the connection
    PFILE_OBJECT             pEndpointFileObject; // the end point file object.
    LONG                     State;               // status of the Vc.
    CONNECTION_CONTEXT       ConnectionId;        // local endpoint for the connection.
    PMDL                     pReceiveMdl;         // the MDl for handling receives.
    PKEVENT                  pCleanUpEvent;       // sychronize event for clean up transports
} RXCE_VC;

#define RXCE_VC_SIGNATURE ((sizeof(RXCE_VC) << 16) | RDBSS_NTC_RXCE_VC)

#define RxCeIsVcValid(pVc)    \
        ((pVc)->Signature == RXCE_VC_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildVC(
    IN OUT PRXCE_VC         pVc,
    IN     PRXCE_CONNECTION Connection);

extern NTSTATUS
NTAPI
RxCeTearDownVC(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeInitiateVCDisconnect(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length);

//
// RxCe Data transmission methods
//

//
// Send options
//
// The following flags are equivalent to the TDI flags. In addition
// there are RXCE specific flags which are defined from the other end of
// a dword.
//

#define RXCE_SEND_EXPEDITED            TDI_SEND_EXPEDITED
#define RXCE_SEND_NO_RESPONSE_EXPECTED TDI_SEND_NO_RESPONSE_EXPECTED
#define RXCE_SEND_NON_BLOCKING         TDI_SEND_NON_BLOCKING

//
// The ASYNCHRONOUS and SYNCHRONOUS option available RxCeSend and RxCeSendDatagram
// distinguish between two situations. In the asynchronous case control returns to
// the caller once the request has been successfully submitted to the underlying
// transport. The results for any given request are communicated back using the
// SendCompletion  callback routine. The pCompletionContext parameter in RxCeSend and
// RxCeSendDatagram is passed back in the callback routine to assist the caller in
// disambiguating the requests.
//
// In the synchronous case the request is submitted to the underlying transport and the
// control does not return to the caller till the request completes.
//
// Note that in the synchrnous case the pCompletionContext parameter is ignored and the
// status that is returned correpsonds to the completion status of the operations.
//
// The benefit of ASYNCHRONOUS and SYNCHRONOUS options depends on the underlying
// transport. In a Virtual Circuit environment a SYNCHRONOUS option implies that the
// control does not return till the data reaches the server. On the other hand
// for datagram oriented transports there is very little difference between the two.
//

#define RXCE_FLAGS_MASK (0xff000000)

#define RXCE_SEND_SYNCHRONOUS (0x10000000)

// The following bit signifies if an RX_MEM_DESC(MDL) is to be sent in its entirety
// or only portions of it need to be sent.

#define RXCE_SEND_PARTIAL     (0x20000000)

extern NTSTATUS
NTAPI
RxCeSend(
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
NTAPI
RxCeSendDatagram(
    IN PRXCE_ADDRESS                hAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

extern PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

extern VOID 
RxCeFreeIrp(PIRP pIrp);


#endif  // _RXCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.h

Abstract:

    This module declares the global data used by the RDBSS file system.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSDATA_
#define _RDBSSDATA_

//

#ifndef MONOLITHIC_MINIRDR
extern PIO_WORKITEM RxIoWorkItem;
#endif

extern RX_DISPATCHER RxDispatcher;
extern RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

//this constants are  the same as the versions in ntexapi.h
//   but drivers are not supposed to import that!

#define  RX_PROCESSOR_ARCHITECTURE_INTEL 0
#define  RX_PROCESSOR_ARCHITECTURE_MIPS  1
#define  RX_PROCESSOR_ARCHITECTURE_ALPHA 2
#define  RX_PROCESSOR_ARCHITECTURE_PPC   3
#define  RX_PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff

// RX_CONTEXT serialization

extern KMUTEX RxSerializationMutex;

#define RxAcquireSerializationMutex()                                       \
        KeWaitForSingleObject(&RxSerializationMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseSerializationMutex()                  \
        KeReleaseMutex(&RxSerializationMutex,FALSE)

//
//  The global fsd data record, and  global large integer constants
//

extern ULONG    RxElapsedSecondsSinceStart;
extern NTSTATUS RxStubStatus;

extern PRDBSS_DEVICE_OBJECT RxFileSystemDeviceObject;

extern LARGE_INTEGER RxLargeZero;
extern LARGE_INTEGER RxMaxLarge;
extern LARGE_INTEGER Rx30Milliseconds;
extern LARGE_INTEGER RxOneSecond;
extern LARGE_INTEGER RxOneDay;
extern LARGE_INTEGER RxJanOne1980;
extern LARGE_INTEGER RxDecThirtyOne1979;

//
//  The status actually returned by the FsdDispatchStub.....usually not implemented
//

extern NTSTATUS RxStubStatus;

//
//  The FCB for opens that refer to the device object directly or
//       for file objects that reference nonFcbs (like treecons)
//

extern FCB RxDeviceFCB;


#if 0
//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define RDBSS_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define RDBSS_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG RxMaxDelayedCloseCount;

#endif //0

#if DBG

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG RxFsdEntryCount;
//extern ULONG RxFspEntryCount;
//extern ULONG RxIoCallDriverCount;
//extern ULONG RxTotalTicks[];
extern ULONG RxIrpCodeCount[];


#endif


// The list of active RxContexts being processed by the RDBSS

extern LIST_ENTRY RxSrvCalldownList;
extern LIST_ENTRY RxActiveContexts;
extern LONG RxNumberOfActiveFcbs;


extern UNICODE_STRING s_PipeShareName;
extern UNICODE_STRING s_MailSlotShareName;
extern UNICODE_STRING s_MailSlotServerPrefix;
extern UNICODE_STRING s_IpcShareName;

extern UNICODE_STRING  s_PrimaryDomainName;

//
//  To allow NFS to run RDBSS on W2K, we now look up the kenel routine
//  FsRtlTeardownPerStreamContexts dynamically at run time.
//  This is the global variable that contains the function pointer or NULL
//  if the routine could not be found (as on W2K.
//

extern VOID (*RxTeardownPerStreamContexts)(IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader);

#endif // _RDBSSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxlog.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.h

Abstract:

    This module declares the prototypes and global data used by the RDBSS debug logging facilities.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

    Balan Sethu Raman [SethuR] 23-April-95 revised log layout

Notes:

    The log records are stored in a circular buffer. Each record is bounded on either side by
    a record descriptor. This record descriptor is four bytes long.

--*/

#ifndef _RDBSSLOG_INCLUDED_
#define _RDBSSLOG_INCLUDED_


typedef enum {
   RX_LOG_UNINITIALIZED,
   RX_LOG_ENABLED,
   RX_LOG_DISABLED,
   RX_LOG_ERROR
} RX_LOGGING_STATE;

typedef struct RX_LOG_ENTRY_HEADER {
    PCHAR Buffer;
} RX_LOG_ENTRY_HEADER, *PRX_LOG_ENTRY_HEADER;


typedef struct RX_LOG {
   RX_SPIN_LOCK         SpinLock;
   RX_LOGGING_STATE     State;
   PRX_LOG_ENTRY_HEADER CurrentEntry;
   PRX_LOG_ENTRY_HEADER BaseEntry;
   PRX_LOG_ENTRY_HEADER EntryLimit;
   ULONG                LogBufferSizeInEntries;
   ULONG                NumberOfEntriesIgnored;
   ULONG                NumberOfLogWriteAttempts;
   ULONG                NumberOfLogWraps;
} RX_LOG, *PRX_LOG;


//the logging facilities are always present. what RDBSSLOG does is to enable generation
//of the calls! on checked builds, you even get the calls unless NO_RDBSSLOG is set.

//extern
//VOID
//RxLogInterlockedAddUlong(
//    PULONG Result,
//    PULONG Counter,
//    ULONG Addend);

extern
VOID
RxDebugControlCommand (
    IN char *ControlString
    );

extern
NTSTATUS
RxInitializeLog(void);

extern
VOID
RxUninitializeLog(void);

extern
VOID
_RxPrintLog(IN ULONG EntriesToPrint OPTIONAL);

extern
VOID
_RxPauseLog(void);

extern
VOID
_RxResumeLog (void);

extern
VOID
_RxLog(char *format, ...);


#define MAX_RX_LOG_ENTRY_SIZE  (48)

#define RDBSSLOG_ASYNC_NAME_PREFIX "[nowait]"
#define RXCONTX_OPERATION_NAME(MajorFunction,Wait) \
    (RxContxOperationNames[(MajorFunction)]+((Wait)?(sizeof(RDBSSLOG_ASYNC_NAME_PREFIX)-1):0))
extern PUCHAR RxContxOperationNames[];

#ifdef RDBSSLOG

                             //
// The arguments to RxLog must be enclosed with an additional pair of parenthesis to enable
// transalation into a null call when logging should be turned off.
// e.g. RxLog(("%s %d", FILE, LINE))
#if DBG
#define RxLog(Args)   _RxLog##Args
#define RxLogRetail(Args)   _RxLog##Args
#else
#define RxLogRetail(Args)   _RxLog##Args
#define RxLog(Args) {NOTHING;}
#endif

#define RxPauseLog()  _RxPauseLog()
#define RxResumeLog() _RxResumeLog()

#else //if notdef  RDBSSLOG

#define RxLog(Args)   {NOTHING;}
#define RxLogRetail(Args) {NOTHING;}
#define RxPauseLog()  {NOTHING;}
#define RxResumeLog() {NOTHING;}

#endif

#endif // _RDBSSLOG_INCLUDED_

#if DBG
#define RxDbgPrint(Args) DbgPrint##Args
#else
#define RxDbgPrint(Args) NOTHING
#endif

LIST_ENTRY RxIrpsList;
KSPIN_LOCK RxIrpsListSpinLock;

typedef struct _RX_IRP_LIST_ITEM {
    LIST_ENTRY  IrpsList;
    PIRP        pIrp;
    PMDL        CopyDataBuffer;
    ULONG       Completed;
} RX_IRP_LIST_ITEM, *PRX_IRP_LIST_ITEM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxpooltg.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpooltg.h

Abstract:

    The global pool tag definitions for RDBSS

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled.

--*/

#ifndef _RXPOOLTG_H_
#define _RXPOOLTG_H_


#define RX_SRVCALL_POOLTAG      ('cSxR')
#define RX_NETROOT_POOLTAG      ('rNxR')
#define RX_V_NETROOT_POOLTAG    ('nVxR')
#define RX_FCB_POOLTAG          ('cFxR')
#define RX_SRVOPEN_POOLTAG      ('oSxR')
#define RX_FOBX_POOLTAG         ('xFxR')
#define RX_NONPAGEDFCB_POOLTAG  ('fNxR')
#define RX_WORKQ_POOLTAG        ('qWxR')
#define RX_BUFFERING_MANAGER_POOLTAG ('mBxR')
#define RX_MISC_POOLTAG         ('sMxR')
#define RX_IRPC_POOLTAG         ('rIxR')
#define RX_MRX_POOLTAG          ('xMxR')
#define RX_NAME_CACHE_POOLTAG   ('cNxR')

#define RXCE_TRANSPORT_POOLTAG  ('tCxR')
#define RXCE_ADDRESS_POOLTAG    ('aCxR')
#define RXCE_CONNECTION_POOLTAG ('cCxR')
#define RXCE_VC_POOLTAG         ('vCxR')
#define RXCE_TDI_POOLTAG        ('dCxR')

extern ULONG RxExplodePoolTags;

#define RX_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((RxExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define RX_SRVCALL_PARAMS_POOLTAG   RX_DEFINE_POOLTAG('pSxR',RX_SRVCALL_POOLTAG)
#define RX_V_NETROOT_PARAMS_POOLTAG RX_DEFINE_POOLTAG('pVxR',RX_V_NETROOT_POOLTAG)
#define RX_TIMER_POOLTAG          RX_DEFINE_POOLTAG('mTxR',RX_MISC_POOLTAG)
#define RX_DIRCTL_POOLTAG         RX_DEFINE_POOLTAG('cDxR',RX_MISC_POOLTAG)

#define RXCE_MISC_POOLTAG         RX_DEFINE_POOLTAG('xCxR',RX_MISC_POOLTAG)
#define RXCE_MIDATLAS_POOLTAG     RX_DEFINE_POOLTAG('aMxR',RX_MISC_POOLTAG)

#endif _RXPOOLTG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxovride.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxovride.h

Abstract:

    This file has two purposes. First, things that are absolutely global are included here; a macro
    NO_RXOVRIDE_GLOBAL maybe defined to get only the second behaviour.

    Second, this file is used as a shortterm expedient to ensure that the logging version of the wrapper,
    smbmini and rdr2kd is built irrespective of the build environment. indeed, all of the debugging issues
    can be enabled disabled from here instead of juggling all of the sources files. to override what it says
    in this file...define RX_BUILD_FREE_ANYWAY.

Author:

    Joe Linn (JoeLinn)

Revision History:

Notes:



--*/
#ifndef NO_RXOVRIDE_GLOBAL

// define pointer types for all of the important structures..........
#include <struchdr.h>        // RDBSS related definitions

#endif //ifndef NO_RXOVRIDE_GLOBAL


//control the debugging state of the built components
#define RDBSS_TRACKER 1

#if !DBG
#define RX_ORIGINAL_DBG 0
#else
#define RX_ORIGINAL_DBG 1
#endif

#if 0
#ifndef RDBSSTRACE
#define RDBSSTRACE 1
#endif //ifndef RDBSSTRACE
#endif

#ifndef RX_POOL_WRAPPER
#define RX_POOL_WRAPPER 1
#endif //ifndef RX_POOL_WRAPPER

#ifndef RDBSS_ASSERTS
#define RDBSS_ASSERTS 1
#endif //ifndef RDBSS_ASSERTS

#if DBG

#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG

#else // DBG

#if PRERELEASE
#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG
#endif  // if PRERELEASE

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxProcs.h

Abstract:

    This module defines all of the globally used procedures in the RDBSS
    file system.

Author:

    Joe Linn     [JoeLinn]

Revision History:

--*/

#ifndef _RDBSSPROCS_
#define _RDBSSPROCS_

#include "rx.h"
#include "backpack.h"
#include "RxTypes.h"
#include "RxLog.h"
#include "RxTrace.h"
#include "RxTimer.h"
#include "RxStruc.h"

extern PVOID RxNull;

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just rdbss dbg users
//

#if DBG

#define DbgDoit(X)         {X;}
#define DebugDoit(X)       {X;}
#define DEBUG_ONLY_DECL(X) X

#else

#define DbgDoit(X)        {NOTHING;}
#define DebugDoit(X)      {NOTHING;}
#define DEBUG_ONLY_DECL(X)

#endif // DBG


//
//  utilities
//


//
//  Routines for writing error log entries.
//

/*++

    RxLogFailure, RxLogFailureWithBuffer can be used to record an event in
    the log. The RxLogFailure, RxLogFailureWithBuffer captures the line
    number alongwith the supplied information and writes it to the log. This
    is useful in debugging. RxLogFailureDirect, RxLogBufferDirect do not
    capture the line number

    RxlogEvent is useful for writing events into the log.

--*/
#define RxLogFailure( _DeviceObject, _OriginatorId, _EventId, _Status ) \
            RxLogEventDirect( _DeviceObject, _OriginatorId, _EventId, _Status, __LINE__ )

#define RxLogFailureWithBuffer( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length ) \
            RxLogEventWithBufferDirect( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length, __LINE__ )

#define RxLogEvent( _DeviceObject, _OriginatorId, _EventId, _Status) \
            RxLogEventDirect(_DeviceObject, _OriginatorId, _EventId, _Status, __LINE__)

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING OriginatorId,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN ULONG Line
    );

VOID
RxLogEventWithBufferDirect (
    IN PVOID DeviceOrDriverObject,
    IN PUNICODE_STRING OriginatorId,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN PVOID DataBuffer,
    IN USHORT DataBufferLength,
    IN ULONG LineNumber
    );

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN PVOID DataBuffer,
    IN USHORT DataBufferLength,
    IN PUNICODE_STRING Annotation,
    IN ULONG AnnotationCount
    );

BOOLEAN
RxCcLogError (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    );

//
//  in create.c
//

NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    );

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    );

//
//  in devfcb.c
//

LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RxFindOrCreateConnections (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PUNICODE_STRING LocalNetRootName,
    OUT PUNICODE_STRING FilePathName,
    IN OUT PLOCK_HOLDING_STATE LockHoldingState,
    IN PRX_CONNECTION_ID RxConnectionId
    );

NTSTATUS
RxFindOrCreateVNetRoot (
    PRX_CONTEXT RxContext,
    PUNICODE_STRING CanonicalName,
    NET_ROOT_TYPE NetRootType,
    PV_NET_ROOT *VirtualNetRootPointer,
    PLOCK_HOLDING_STATE *LockHoldingState
    );

//
//  in fileinfo.c
//

typedef enum _RX_NAME_CONJURING_METHODS {
    VNetRoot_As_Prefix,
    VNetRoot_As_UNC_Name,
    VNetRoot_As_DriveLetter
} RX_NAME_CONJURING_METHODS;

VOID
RxConjureOriginalName (
    IN PFCB Fcb,
    IN PFOBX Fobx,
    OUT PLONG ActualNameLength,
    PWCHAR OriginalName,
    IN OUT PLONG LengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    );

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

BOOLEAN
RxZeroData (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );


VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    );

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

PVOID
RxMapUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

#define RxUpcaseEaName(RXCONTEXT,NAME,UPCASEDNAME) \
    RtlUpperString( UPCASEDNAME, NAME )


#ifdef RDBSS_TRACKER
#define RX_FCBTRACKER_PARAMS ,ULONG LineNumber,PSZ FileName,ULONG SerialNumber
#else
#define RX_FCBTRACKER_PARAMS
#endif

#define FCB_MODE_EXCLUSIVE (1)
#define FCB_MODE_SHARED    (2)
#define FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE (3)
#define FCB_MODE_SHARED_STARVE_EXCLUSIVE (4)

#define CHANGE_BUFFERING_STATE_CONTEXT      ((PRX_CONTEXT)IntToPtr(0xffffffff))
#define CHANGE_BUFFERING_STATE_CONTEXT_WAIT ((PRX_CONTEXT)IntToPtr(0xfffffffe))

//
//  NOTE: even though the following routine pass a serial number, this parameter is not used
//

#ifdef RDBSS_TRACKER

NTSTATUS
__RxAcquireFcb(
     IN OUT PFCB Fcb,
     IN OUT PRX_CONTEXT RxContext,
     IN ULONG Mode,
     ULONG LineNumber,
     PSZ FileName,
     ULONG SerialNumber
     );

#else

NTSTATUS
__RxAcquireFcb(
     IN OUT PFCB Fcb,
     IN OUT PRX_CONTEXT RxContext,
     IN ULONG Mode
     );

#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE)
#endif

#define RX_GET_MRX_FCB(FCB) ((PMRX_FCB)((FCB)))

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE)
#endif


#ifdef RDBSS_TRACKER

VOID
__RxReleaseFcb(
    IN PRX_CONTEXT RxContext,
    IN PMRX_FCB Fcb,
    ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
    );

#else

VOID
__RxReleaseFcb(
    IN PRX_CONTEXT pRxContext,
    IN PMRX_FCB    pFcb
    );

#endif

#ifdef  RDBSS_TRACKER
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB),__LINE__,__FILE__,0)
#else
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB))
#endif


#ifdef RDBSS_TRACKER

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT RxContext,
    IN PMRX_FCB Fcb,
    IN ERESOURCE_THREAD ResourceThreadId,
    ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
    ); 
#else

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT RxContext,
    IN PMRX_FCB Fcb,
    IN ERESOURCE_THREAD ResourceThreadId
    ); 

#endif

#ifdef  RDBSS_TRACKER
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD),__LINE__,__FILE__,0)
#else
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD))
#endif

#ifdef RDBSS_TRACKER
VOID RxTrackerUpdateHistory(
    PRX_CONTEXT pRxContext,
    PMRX_FCB pFcb,
    ULONG Operation,
    ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
    );
#else
#define RxTrackerUpdateHistory(xRXCONTEXT,xFCB,xOPERATION,xLINENUM,xFILENAME,xSERIALNUMBER) {NOTHING;}
#endif

VOID RxTrackPagingIoResource(
    PVOID Instance,
    ULONG Type,
    ULONG Line,
    PCHAR File
    );

//
//  this definition is old......i don't like the format
//

#define RxFcbAcquiredShared( RXCONTEXT, FCB ) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquiredShared( FCB ) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquiredExclusive( FCB ) (                      \
    ExIsResourceAcquiredExclusiveLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquired( FCB) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) | \
    ExIsResourceAcquiredExclusiveLite( (FCB)->Header.Resource ) \
)

#define RxAcquirePagingIoResource( RXCONTEXT, FCB )                       \
    ExAcquireResourceExclusiveLite( (FCB)->Header.PagingIoResource, TRUE );  \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = TRUE;   \
    } \
    RxTrackPagingIoResource( FCB, 1, __LINE__, __FILE__ ) \

#define RxAcquirePagingIoResourceShared( RXCONTEXT, FCB, FLAG ) \
    ExAcquireResourceSharedLite( (FCB)->Header.PagingIoResource, FLAG ); \
    if (AcquiredFile) {                                          \
        if (RXCONTEXT) {                                     \
            ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = TRUE;   \
        }                                                    \
        RxTrackPagingIoResource( FCB, 2, __LINE__, __FILE__ );    \
    }

#define RxReleasePagingIoResource( RXCONTEXT, FCB )                      \
     RxTrackPagingIoResource( FCB, 3, __LINE__, __FILE__ ); \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceLite( (FCB)->Header.PagingIoResource )

#define RxReleasePagingIoResourceForThread( RXCONTEXT, FCB, THREAD )    \
    RxTrackPagingIoResource( FCB, 3, __LINE__, __FILE__ ); \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceForThreadLite( (FCB)->Header.PagingIoResource, (THREAD) )


//  The following are cache manager call backs

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
RxNoOpRelease (
    IN PVOID Fcb
    );

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  VOID
//  RxConvertToSharedFcb (
//      IN PRX_CONTEXT RxContext,
//      IN PFCB Fcb
//      );
//

#define RxConvertToSharedFcb(RXCONTEXT,FCB) {                        \
    ExConvertExclusiveToSharedLite( RX_GET_MRX_FCB(FCB)->Header.Resource ); \
    }

VOID
RxVerifyOperationIsLegal (
    IN PRX_CONTEXT RxContext
    );

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    );

#define RxFsdPostRequestWithResume(RXCONTEXT,RESUMEROUTINE) \
        (((RXCONTEXT)->ResumeRoutine = (RESUMEROUTINE)),   \
        RxFsdPostRequest( (RXCONTEXT) ) \
        )

VOID
RxInitializeMRxCalldownContext (
    PMRX_CALLDOWN_CONTEXT Context,
    PRDBSS_DEVICE_OBJECT MRxDeviceObject,
    PMRX_CALLDOWN_ROUTINE Routine,
    PVOID Parameter
    );

NTSTATUS
RxCalldownMiniRedirectors (
    LONG NumberOfMiniRdrs,
    PMRX_CALLDOWN_CONTEXT CalldownContext,
    BOOLEAN PostCalldowns
    );

//
//  This macro takes a ulong and returns its rounded up word value
//

#define WordAlign(Val) (                    \
    ALIGN_UP( Val, WORD )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define WordAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, WORD )           \
    )

//
//  This macro takes a ulong and returns its rounded up longword value
//

#define LongAlign(Val) (                    \
    ALIGN_UP( Val, LONG )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define LongAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, LONG )           \
    )

//
//  This macro takes a ulong and returns its rounded up quadword
//  value
//

#define QuadAlign(Val) (                    \
    ALIGN_UP( Val, ULONGLONG )              \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up quadword value
//

#define QuadAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, ULONGLONG )      \
    )

//
//  This macro takes a pointer and returns whether it's quadword-aligned
//

#define IsPtrQuadAligned(Ptr) (           \
    QuadAlignPtr(Ptr) == (PVOID)(Ptr)     \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//  the wrapper doesn't yet implement notify and oplock. rather than remove the code
//  we define the calls in such a way as to Noop the effects so that we'll have a head
//  start on putting it back later...
// 


/* this is a macro definition we'll reenable when we implement oplocks and notifies
//
//  VOID
//  RxNotifyReportChange (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define RxNotifyReportChange(I,V,F,FL,A) {                             \
    if ((F)->FullFileName.Buffer == NULL) {                             \
        RxSetFullFileNameInFcb((I),(F));                               \
    }                                                                   \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                       \
                                 &(V)->DirNotifyList,                   \
                                 (PSTRING)&(F)->FullFileName,           \
                                 (USHORT) ((F)->FullFileName.Length -   \
                                           (F)->FinalNameLength),       \
                                 (PSTRING)NULL,                         \
                                 (PSTRING)NULL,                         \
                                 (ULONG)FL,                             \
                                 (ULONG)A,                              \
                                 (PVOID)NULL );                         \
}
*/
#define RxNotifyReportChange(I,V,F,FL,A) \
    RxDbgTrace(0, Dbg, ("RxNotifyReportChange PRETENDING Fcb %08lx %wZ Filter/Action = %08lx/%08lx\n", \
                 (F),&((F)->FcbTableEntry.Path),(FL),(A)))

#if 0
#define FsRtlNotifyFullChangeDirectory(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) \
    RxDbgTrace(0, Dbg, ("FsRtlNotifyFullReportChange PRETENDING ............\n",0))
#endif

#define FsRtlCheckOplock(A1,A2,A3,A4,A5)  \
        (STATUS_SUCCESS)

#define FsRtlOplockIsFastIoPossible(__a) (TRUE)

//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the RxContext to be
//  null, however the only legal order to do this in is:
//
//      RxCompleteRequest_OLD( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      RxCompleteRequest_OLD( RxContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" RxContext off to
//  the Fsp for post processing, such as read ahead.
//
//  The new way is to pass just the RxContext..........
//

VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#if DBG
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real( RXCONTEXT, IRP, STATUS); \
    (IRP) = NULL;                                   \
    (RXCONTEXT) = NULL;                            \
}
#else
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS ) { \
    RxCompleteRequest_Real( RXCONTEXT, IRP, STATUS ); \
}
#endif

NTSTATUS
RxCompleteRequest(
      PRX_CONTEXT pContext,
      NTSTATUS    Status);

#define RxCompleteAsynchronousRequest(RXCONTEXT,STATUS)  \
        RxCompleteRequest(RXCONTEXT,STATUS)

#define RxCompleteContextAndReturn(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss); \
             return(__sss);}
#define RxCompleteContext(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss);} \

//
//  The Following routine makes a popup
//

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

NTSTATUS
RxConstructSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PSRV_CALL SrvCall,
    OUT PLOCK_HOLDING_STATE LockHoldingState
    );

NTSTATUS
RxSetSrvCallDomainName (
    IN PMRX_SRV_CALL SrvCall,
    IN PUNICODE_STRING DomainName
    );

NTSTATUS           
RxConstructNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PSRV_CALL SrvCall,
    IN PNET_ROOT NetRoot,
    IN PV_NET_ROOT VirtualNetRoot,
    OUT PLOCK_HOLDING_STATE LockHoldingState
    );

NTSTATUS
RxConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PV_NET_ROOT *VirtualNetRootPointer,
    OUT PLOCK_HOLDING_STATE LockHoldingState,
    OUT PRX_CONNECTION_ID  RxConnectionId
    );

NTSTATUS
RxFindOrConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
RxLowIoFsCtlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxLowIoFsCtlShellCompletion (
    IN PRX_CONTEXT RxContext
    );


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxShadowLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxShadowFastLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxChangeBufferingState (
    PSRV_OPEN SrvOpen,
    PVOID Context,
    BOOLEAN ComputeNewState
    );

VOID
RxAssociateSrvOpenKey (
    PMRX_SRV_OPEN MRxSrvOpen,
    PVOID SrvOpenKey
    );

VOID
RxIndicateChangeOfBufferingState (
    PMRX_SRV_CALL SrvCall,
    PVOID SrvOpenKey,
    PVOID Context
    );

VOID
RxIndicateChangeOfBufferingStateForSrvOpen (
    PMRX_SRV_CALL SrvCall,
    PMRX_SRV_OPEN SrvOpen,
    PVOID SrvOpenKey,
    PVOID Context
    );

NTSTATUS
RxPrepareToReparseSymbolicLink (
    PRX_CONTEXT RxContext,
    BOOLEAN SymbolicLinkEmbeddedInOldPath,
    PUNICODE_STRING NewPath,
    BOOLEAN NewPathIsAbsolute,
    PBOOLEAN ReparseRequired
    );

BOOLEAN
RxLockEnumerator (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    );

//
// Routines for transitioning data structures to stable states.
//

VOID
RxReference (
    IN OUT PVOID Instance
    );

VOID
RxDereference (
    IN OUT PVOID Instance,
    IN LOCK_HOLDING_STATE LockHoldingState
    );

VOID
RxWaitForStableCondition (
    IN PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList,
    IN OUT PRX_CONTEXT RxContext,
    OUT NTSTATUS *AsyncStatus OPTIONAL
    );

VOID
RxUpdateCondition (
    IN RX_BLOCK_CONDITION NewConditionValue,
    OUT PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList
    );

VOID
RxFinalizeNetTable (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceFinalization
    );

#define RxForceNetTableFinalization(RxDeviceObject) RxFinalizeNetTable( RxDeviceObject, TRUE )

NTSTATUS
RxCloseAssociatedSrvOpen (
    IN PRX_CONTEXT RxContext OPTIONAL,
    IN PFOBX Fobx
    );

NTSTATUS
RxFinalizeConnection (
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot OPTIONAL,
    IN LOGICAL ForceFilesClosed
    );

//
//  routines for manipulating the user's view and the server's view of SHARE_ACCESS.
//  the user's view is supported by routines exported by Io...the wrappers just allow
//  us to get a msg. the server's view is supported by routines that are essential just
//  copies of the Io routines EXCEPT that the Io routines work directly on fileobjects and
//  as such cannot be used directly. the routines mentioned are implemented in create.c
//

#if DBG
VOID
RxDumpWantedAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );

VOID
RxDumpCurrentAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    );

#else
#define RxDumpWantedAccess(w1,w2,wlt,DA,DSA) {NOTHING;}
#define RxDumpCurrentAccess(w1,w2,wlt,SA)  {NOTHING;}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens (
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );


VOID
RxUpdateShareAccessPerSrvOpens (
    IN PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    );


#if DBG
NTSTATUS
RxCheckShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxRemoveShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxSetShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxUpdateShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );
#else
#define RxCheckShareAccess(a1,a2,a3,a4,a5,a6,a7) \
    IoCheckShareAccess(a1,a2,a3,a4,a5)

#define RxRemoveShareAccess(a1,a2,a3,a4) \
    IoRemoveShareAccess(a1,a2)

#define RxSetShareAccess(a1,a2,a3,a4,a5,a6) \
    IoSetShareAccess(a1,a2,a3,a4)

#define RxUpdateShareAccess(a1,a2,a3,a4) \
    IoUpdateShareAccess(a1,a2)
#endif

//
//  LoadUnload
//

NTSTATUS
RxDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RxUnload (
    IN PDRIVER_OBJECT DriverObject
    );

//
//  minirdr support
//

VOID
RxInitializeMinirdrDispatchTable (
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

NTSTATUS
DuplicateTransportAddress (
    PTRANSPORT_ADDRESS *Copy,
    PTRANSPORT_ADDRESS Original,
    POOL_TYPE PoolType);

NTSTATUS
RxCepInitializeVC (
    PRXCE_VC Vc,
    PRXCE_CONNECTION Connection
    );

NTSTATUS
DuplicateConnectionInformation (
    PRXCE_CONNECTION_INFORMATION *Copy,
    PRXCE_CONNECTION_INFORMATION Original,
    POOL_TYPE PoolType
    );

NTSTATUS
RxCepInitializeConnection (
    IN OUT PRXCE_CONNECTION Connection,
    IN PRXCE_ADDRESS Address,
    IN PRXCE_CONNECTION_INFORMATION ConnectionInformation,
    IN PRXCE_CONNECTION_EVENT_HANDLER Handler,
    IN PVOID EventContext
    );

typedef struct _RX_CALLOUT_PARAMETERS_BLOCK_ * PRX_CALLOUT_PARAMETERS_BLOCK;
typedef struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ *PRX_CREATE_CONNECTION_CALLOUT_CONTEXT;

NTSTATUS
RxCeInitiateConnectRequest (
    IN PRX_CALLOUT_PARAMETERS_BLOCK ParameterBlock
    );

VOID
RxCeCleanupConnectCallOutContext (
    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT CreateConnectionContext
    );

PVOID
RxAllocateObject (
    NODE_TYPE_CODE NodeType,
    PMINIRDR_DISPATCH MRxDispatch,
    ULONG NameLength
    );

VOID
RxFreeObject (
    PVOID pObject
    );

NTSTATUS
RxInitializeSrvCallParameters (
    IN PRX_CONTEXT RxContext,
    IN OUT PSRV_CALL SrvCall
    );

VOID
RxAddVirtualNetRootToNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    );

VOID
RxRemoveVirtualNetRootFromNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    );

VOID
RxOrphanFcbsFromThisVNetRoot (
    IN PV_NET_ROOT ThisVNetRoot
    );

PVOID
RxAllocateFcbObject (
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE NodeType,
    POOL_TYPE PoolType,
    ULONG NameSize,
    PVOID AlreadyAllocatedObject
    );

VOID
RxFreeFcbObject (
    PVOID Object
    );

VOID
RxPurgeFcb (
    IN  PFCB Fcb
    );

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize,
    IN LONG ReferenceCount
    );

BOOLEAN
RxIsThisACscAgentOpen (
    IN PRX_CONTEXT RxContext
    );

VOID
RxCheckFcbStructuresForAlignment (
    VOID
    );

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    );

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );

NTSTATUS
RxInitializeWorkQueueDispatcher (
   PRX_WORK_QUEUE_DISPATCHER Dispatcher
   );

VOID
RxInitializeWorkQueue (
   PRX_WORK_QUEUE WorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG MaximumNumberOfWorkerThreads,
   ULONG MinimumNumberOfWorkerThreads
   );

VOID
RxTearDownWorkQueueDispatcher (
   PRX_WORK_QUEUE_DISPATCHER Dispatcher
   );

VOID
RxTearDownWorkQueue (
   PRX_WORK_QUEUE WorkQueue
   );

NTSTATUS
RxSpinUpWorkerThread (
   PRX_WORK_QUEUE WorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID Parameter
   );

VOID
RxSpinUpWorkerThreads (
   PRX_WORK_QUEUE WorkQueue
   );

VOID
RxSpinUpRequestsDispatcher (
    PRX_DISPATCHER Dispatcher
    );

VOID
RxpSpinUpWorkerThreads (
    PRX_WORK_QUEUE WorkQueue
    );

VOID
RxpWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue,
   IN PLARGE_INTEGER WaitInterval
   );

VOID
RxBootstrapWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue
   );

VOID
RxWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue
   );

VOID
RxWorkItemDispatcher (
   PVOID Context
   );

BOOLEAN
RxIsPrefixTableEmpty (
    IN PRX_PREFIX_TABLE ThisTable
    );

PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING  Name,
    IN ULONG HashValue,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

PVOID
RxTableLookupName (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING Name,
    OUT PUNICODE_STRING RemainingName,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
RxPrepareRequestForHandling (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxPrepareRequestForReuse (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxpDiscardChangeBufferingStateRequests (
    IN OUT PLIST_ENTRY DiscardedRequests
    );

VOID
RxGatherRequestsForSrvOpen (
    IN OUT PSRV_CALL SrvCall,
    IN PSRV_OPEN SrvOpen,
    IN OUT PLIST_ENTRY RequestsListHead
    );

NTSTATUS
RxpLookupSrvOpenForRequestLite (
    IN PSRV_CALL SrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST Request
    );

BOOLEAN
RxContextCheckToFailThisAttempt (
    IN PIRP Irp,
    IN OUT PULONG InitialContextFlags
    );

ULONG
RxAssignMustSucceedContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

PRX_CONTEXT
RxAllocateMustSucceedContext (
    PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    OUT PUCHAR MustSucceedDescriptorNumber
    );

VOID
RxFreeMustSucceedContext (
    PRX_CONTEXT RxContext
    );

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry (
    VOID
    );

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    );

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen (
    PSRV_OPEN SrvOpen
    );

NTSTATUS
RxPurgeFobxFromCache (
    PFOBX FobxToBePurged
    );

BOOLEAN
RxPurgeFobx (
   PFOBX pFobx
   );

VOID
RxPurgeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxUndoScavengerFinalizationMarking (
    PVOID Instance
    );

VOID
RxScavengeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

ULONG
RxTableComputePathHashValue (
    IN PUNICODE_STRING Name
    );

VOID
RxExtractServerName (
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

VOID
RxSpinDownOutstandingAsynchronousRequests (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
RxRegisterAsynchronousRequest (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxDeregisterAsynchronousRequest (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

BOOLEAN
RxCancelOperationInOverflowQueue (
    IN PRX_CONTEXT RxContext
    );

VOID
RxOrphanSrvOpens (
    IN PV_NET_ROOT ThisVNetRoot
    );

VOID
RxOrphanThisFcb (
    PFCB Fcb
    );

VOID
RxOrphanSrvOpensForThisFcb (
    IN PFCB Fcb,
    IN PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN OrphanAll
    );

VOID
RxForceFinalizeAllVNetRoots (
    PNET_ROOT NetRoot
    );

#define RxEqualConnectionId( P1, P2 ) RtlEqualMemory( P1, P2, sizeof( RX_CONNECTION_ID ) )


//
//  FsRtl lock package callbacks referenced in fcbstruc.c
//

NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    );

//
//  some read routines that need headers
//

VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

//
//  the cancel routine
//

VOID
RxCancelRoutine (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


INLINE
TYPE_OF_OPEN
RxDecodeFileObject ( 
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PFOBX *Fobx
    ) {

    if (FileObject) {
        *Fcb = (PFCB)FileObject->FsContext;
        *Fobx = (PFOBX)FileObject->FsContext2;

        return NodeType( *Fcb );
    } else {

        *Fcb = NULL;
        *Fobx = NULL;
        return RDBSS_NTC_STORAGE_TYPE_UNKNOWN;
    }
}


#endif // _RDBSSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxexcept.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Except.h

Abstract:

    This module prototypes the macros and routines used for exception handling.

Author:

    Joe Linn     [JoeLinn]   24-aug-1994

Revision History:

--*/

#ifndef _EXCEPTION_STUFF_DEFINED_
#define _EXCEPTION_STUFF_DEFINED_


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as RxStatus(FILE_INVALID) (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  RxFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(RxExceptionFilter( RxContext, GetExceptionCode() )) {
//
//          Status = RxProcessException( RxContext, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  RxStatus(FILE_INVALID), use the below macro RxRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  RxNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise RxStatus(UNEXPECTED_IO_ERROR) if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  RxContext->ExceptionStatus, signaling RxExceptionFilter and
//  RxProcessException that the status we actually raise is by definition
//  expected.
//

LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    );

#define CATCH_EXPECTED_EXCEPTIONS   (FsRtlIsNtstatusExpected(GetExceptionCode()) ?   \
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )


//
//  VOID
//  RxRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//
//

#define RxRaiseStatus(RXCONTEXT,STATUS) {   \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    ExRaiseStatus( (STATUS) );              \
}

//
//  VOID
//  RxNormalAndRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//

#define RxNormalizeAndRaiseStatus(RXCONTEXT,STATUS) {                         \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    if ((STATUS) == (STATUS_VERIFY_REQUIRED)) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),(STATUS_UNEXPECTED_IO_ERROR))); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }



#endif // _EXCEPTION_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxtimer.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxTimer.h

Abstract:

    This module defines the prototypes and structures for the timer on the rdbss architecture.
    What is provided is a 55ms timer...that is, if you register a routine then you get a call
    every 55ms. On NT, you're at DPC level.

    Also contained here are the routines for posting to a thread from DPC level.


Author:

    Joe Linn     [JoeLinn]   2-mar-95

Revision History:

    Balan Sethu Raman [SethuR] 7-March-95
         Modified signatures to provide one shot timer service. Merged timer entry and
         work item definitions.

--*/

#ifndef _RXTIMER_H_
#define _RXTIMER_H_

//
// The RX_WORK_ITEM encapsulates the context for posting to a worker thread as well as
// a timer routine to be triggered after a specific interval.
//

typedef struct _RX_WORK_ITEM_ {
    RX_WORK_QUEUE_ITEM       WorkQueueItem;
    ULONG                    LastTick;
    ULONG                    Options;
} RX_WORK_ITEM, *PRX_WORK_ITEM;

extern NTSTATUS
NTAPI
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);

extern NTSTATUS
NTAPI
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);


extern NTSTATUS
NTAPI
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );


//
// Routines for initializing and tearing down the timer service in RDBSS
//

extern NTSTATUS
NTAPI
RxInitializeRxTimer();

extern VOID
NTAPI
RxTearDownRxTimer(void);

#endif // _RXTIMER_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxtrace.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtrace.h

Abstract:

    This module defines the macros which provide debugging support ( tracing ).

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSTRACE_INCLUDED_
#define _RDBSSTRACE_INCLUDED_

#if !DBG
#undef RDBSSTRACE
#endif // !DBG

typedef struct _DEBUG_TRACE_CONTROLPOINT{
    ULONG ControlPointNumber;
    PSZ Name;
} DEBUG_TRACE_CONTROLPOINT, *PDEBUG_TRACE_CONTROLPOINT;

typedef struct {
    LONG PrintLevel;
    ULONG BreakMask;
    PSZ   Name;
} RX_DEBUG_TRACE_CONTROL, *PRX_DEBUG_TRACE_CONTROL;


#ifdef RDBSSTRACE

//define so that &RX_DEBUG_TRACE_CONTROL is NULL
typedef struct {
    RX_DEBUG_TRACE_CONTROL Junk;
} rxrxrx_AlwaysHelper;


#define RX_DEBUG_TRACE_ALWAYS  (((rxrxrx_AlwaysHelper*)0)->Junk)

// The following macros provide fine grained control for selectively enabling
// and disabling tracing.

#define RXDT_Extern(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DeclareCategory(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DefineCategory(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x = {0,#__x}

RXDT_Extern(ERROR);
RXDT_Extern(HOOKS);
RXDT_Extern(CATCH_EXCEPTIONS);
RXDT_Extern(UNWIND);
RXDT_Extern(CLEANUP);
RXDT_Extern(CLOSE);
RXDT_Extern(CREATE);
RXDT_Extern(DIRCTRL);
RXDT_Extern(EA);
RXDT_Extern(FILEINFO);
RXDT_Extern(FSCTRL);
RXDT_Extern(LOCKCTRL);
RXDT_Extern(READ);
RXDT_Extern(VOLINFO);
RXDT_Extern(WRITE);
RXDT_Extern(FLUSH);
RXDT_Extern(DEVCTRL);
RXDT_Extern(SHUTDOWN);
RXDT_Extern(PREFIX);
RXDT_Extern(DEVFCB);
RXDT_Extern(ACCHKSUP);
RXDT_Extern(ALLOCSUP);
RXDT_Extern(DIRSUP);
RXDT_Extern(FILOBSUP);
RXDT_Extern(NAMESUP);
RXDT_Extern(VERFYSUP);
RXDT_Extern(CACHESUP);
RXDT_Extern(SPLAYSUP);
RXDT_Extern(DEVIOSUP);
RXDT_Extern(FCBSTRUCTS);
RXDT_Extern(STRUCSUP);
RXDT_Extern(FSP_DISPATCHER);
RXDT_Extern(FSP_DUMP);
RXDT_Extern(RXCONTX);
RXDT_Extern(DISPATCH);
RXDT_Extern(NTFASTIO);
RXDT_Extern(LOWIO);
RXDT_Extern(MINIRDR);
RXDT_Extern(DISCCODE);  //for the browser interface stuff
RXDT_Extern(BROWSER);
RXDT_Extern(CONNECT);
RXDT_Extern(NTTIMER);
RXDT_Extern(SCAVTHRD);
RXDT_Extern(SCAVENGER);
RXDT_Extern(SHAREACCESS);
RXDT_Extern(NAMECACHE);

//connection engines categories

RXDT_Extern(RXCEBINDING);
RXDT_Extern(RXCEDBIMPLEMENTATION);
RXDT_Extern(RXCEMANAGEMENT);
RXDT_Extern(RXCEXMIT);
RXDT_Extern(RXCEPOOL);
RXDT_Extern(RXCETDI);

#else //RDBSSTRACE

#define RXDT_Extern(__x)
#define RXDT_DeclareCategory(__x)
#define RXDT_DefineCategory(__x)

#endif //RDBSSTRACE

#ifdef RDBSSTRACE
extern BOOLEAN RxGlobalTraceSuppress, RxNextGlobalTraceSuppress;
extern ULONG RxGlobalTraceIrpCount;
VOID RxInitializeDebugTrace(void);
#define RxDbgTraceDoit(___x) ___x

#ifndef MINIRDR__NAME
extern LONG RxDebugTraceIndent;
#else
#define RxDebugTraceIndent (*(*___MINIRDR_IMPORTS_NAME).pRxDebugTraceIndent)
#endif

#else

#define RxInitializeDebugTrace()
#define RxDbgTraceDoit(___x)

#endif //RDBSSTRACE



#if DBG

#define RxDT_INDENT_EXCESS 16 //this is the offset for excess-n for the indent
#define RxDT_INDENT_SHIFT 20
#define RxDT_INDENT_MASK  0x3f
#define RxDT_LEVEL_MASK ((1<<RxDT_INDENT_SHIFT)-1)
#define RxDT_SUPPRESS_PRINT  0x80000000
#define RxDT_OVERRIDE_RETURN 0x40000000


// The implementation details of the tracing feature.

VOID
RxDebugTraceActual (
    IN ULONG NewMask,
    IN PCH Format,
    ...
    );

BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

extern PCHAR RxIrpCodeToName[];

#endif  //DBG

#ifdef RDBSSTRACE
BOOLEAN
RxDbgTraceDisableGlobally(void);

VOID
RxDbgTraceEnableGlobally(BOOLEAN flag);

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    );

VOID
RxDebugTraceZeroAllPrintLevels(
    void
    );

extern ULONG rdbsstracemarker;

#define RxDTMASK(INDENT,WRITELEVEL) \
         ( (((INDENT)+RxDT_INDENT_EXCESS)<<RxDT_INDENT_SHIFT) + ((WRITELEVEL)&RxDT_LEVEL_MASK))

#define RxDTPrefixRx(___x) RX_##___x

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDT_OVERRIDE_RETURN | RxDTMASK((INDENT),(LEVEL))),\
                                               (CONTROLPOINT)); \
         if (!PrintIt) Z;                    \
        }

#define RxDbgTraceLV__norx(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew( RxDTMASK((INDENT),(LEVEL)),(CONTROLPOINT)); \
         if (PrintIt) DbgPrint Z;                    \
        }

#define RxDbgTraceLVUnIndent__norx(INDENT,CONTROLPOINT,LEVEL) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDTMASK((INDENT),(LEVEL))),(CONTROLPOINT)); \
        }

#define RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \
        RxDbgTraceLV__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL,Z)

#define RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,LEVEL) \
        RxDbgTraceLVUnIndent__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL)

#define RxDbgTrace(INDENT,CONTROLPOINT,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,1,Z) \

#define RxDbgTraceLV(INDENT,CONTROLPOINT,LEVEL,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \

#define RxDbgTraceUnIndent(INDENT,CONTROLPOINT) \
             RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,1)

// do not define this for nonrdbsstrace; so to catch references not ifdef'd
#define RxDbgTraceFindControlPoint(CONTROLPOINT) (RxDbgTraceFindControlPointActual(&RxDTPrefixRx##CONTROLPOINT))


#define DebugBreakPoint(CONTROLPOINT,MASKBIT) {           \
    if (((MASKBIT) == 0)                                     \
         || (RxDbgTraceFindControlPoint(CONTROLPOINT)->BreakMask & (1<<((MASKBIT)-1)) )) { \
        DbgBreakPoint();                                     \
    }                                                        \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                              \
        RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ( #X ", Abnormal termination.\n", 0)); \
    }                                                                         \
}

#ifdef RX_PERFPORMANCE_TIMER
extern LONG RxPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    RxTotalTicks[RxLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( RxPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}
#endif //RX_PERFPORMANCE_TIMER

#else  // RDBSSTRACE

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z)      {NOTHING;}
#define RxDbgTraceLV(INDENT,CONTROLPOINTNUM,LEVEL,Z)     {NOTHING;}
#define RxDbgTraceLVUnIndent(INDENT,CONTROLPOINTNUM,LEVEL)     {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define RxDbgTraceUnIndent(INDENT,CONTROLPOINTNUM)     {NOTHING;}
#define DebugBreakPoint(CONTROLPOINTNUM,MASKBIT) {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define RxDbgTraceDisableGlobally() FALSE
#define RxDbgTraceEnableGlobally(f) {NOTHING;}

#ifdef RX_PERFPORMANCE_TIMER
#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)
#endif

#endif // RDBSSTRACE


#endif // _RDBSSTRACE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Rx file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

    Joe Linn        [joelinn]   aug-1994 moved over to rdbss

--*/

#ifndef _RDBSSSTRUC_
#define _RDBSSSTRUC_

#include "prefix.h"
#include "lowio.h"
#include "scavengr.h"      //  scavenger related definitions.
#include "RxContx.h"
#include "mrx.h"
#include "Fcb.h"

//
//  define our byte offsets to be the full 64 bits
//

typedef LONGLONG RXVBO;

#if 0

//
//  Define who many freed structures we are willing to keep around
//

#define FREE_FOBX_SIZE                   (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_NON_PAGED_FCB_SIZE          (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)

#endif //  0


//
//  We will use both a common and private dispatch tables on a per FCB basis to (a) get
//  some encapsulation and (b) [less important] go a little faster. The driver table then gets
//  optimized for the most common case. Right now we just use the common dispatch...later and
//  Eventually, all the FCBs will have pointers to optimized dispatch tables.
//

//
//  used to synchronize access to  rxcontxs and structures
//

extern RX_SPIN_LOCK RxStrucSupSpinLock;

typedef struct _RDBSS_EXPORTS {
    PRX_SPIN_LOCK pRxStrucSupSpinLock;
    PLONG pRxDebugTraceIndent;
} RDBSS_EXPORTS, *PRDBSS_EXPORTS;

extern RDBSS_EXPORTS RxExports;

//
//  this type is used with table locks to track whether or not the lock
//  should be released
//

typedef enum _LOCK_HOLDING_STATE {
    LHS_LockNotHeld,
    LHS_SharedLockHeld,
    LHS_ExclusiveLockHeld
} LOCK_HOLDING_STATE, *PLOCK_HOLDING_STATE;

//
//  The RDBSS_DATA record is the top record in the Rx file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _RDBSS_DATA {

    //
    //  The type and size of this record (must be RDBSS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Mini Rdr registration related fields
    //

    LONG NumberOfMinirdrsStarted;

    FAST_MUTEX MinirdrRegistrationMutex;
    LIST_ENTRY RegisteredMiniRdrs;          //protected by the mutex
    LONG NumberOfMinirdrsRegistered;  //protected by the mutex

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;

    //
    //  To control access to the global Rx data record
    //

    ERESOURCE Resource;

} RDBSS_DATA;
typedef RDBSS_DATA *PRDBSS_DATA;

extern RDBSS_DATA RxData;

PEPROCESS
RxGetRDBSSProcess (
    VOID
    );

//
//  Note: A Strategy needs to be in place to deal with requests for stopping the
//  RDBSS when requests are active.
//

typedef enum _RX_RDBSS_STATE_ {
   RDBSS_STARTABLE = 0,  
   RDBSS_STARTED,
   RDBSS_STOP_IN_PROGRESS

   //
   //  this state deleted with cause! RDBSS_STOPPED
   //

} RX_RDBSS_STATE, *PRX_RDBSS_STATE;

typedef struct _RDBSS_STARTSTOP_CONTEXT_ {
   
    RX_RDBSS_STATE State;
    ULONG Version;
    PRX_CONTEXT pStopContext;

} RDBSS_STARTSTOP_CONTEXT, *PRDBSS_STARTSTOP_CONTEXT;

typedef struct _MRX_CALLDOWN_COMPLETION_CONTEXT_ {
   
    LONG WaitCount;
    KEVENT Event;

} MRX_CALLDOWN_COMPLETION_CONTEXT, *PMRX_CALLDOWN_COMPLETION_CONTEXT;

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_ROUTINE) (
    IN OUT PVOID CalldownParameter
    );


typedef struct _MRX_CALLDOWN_CONTEXT_ {
    
    RX_WORK_QUEUE_ITEM WorkQueueItem;
    PRDBSS_DEVICE_OBJECT pMRxDeviceObject;
    PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext;
    PMRX_CALLDOWN_ROUTINE pRoutine;
    NTSTATUS CompletionStatus;
    PVOID pParameter;

} MRX_CALLDOWN_CONTEXT, *PMRX_CALLDOWN_CONTEXT;

typedef struct _RX_DISPATCHER_CONTEXT_ {
   
    LONG NumberOfWorkerThreads;
    PKEVENT pTearDownEvent;

} RX_DISPATCHER_CONTEXT, *PRX_DISPATCHER_CONTEXT;

#define RxSetRdbssState(RxDeviceObject,NewState)                \
        {                                                       \
           KIRQL SavedIrql;                                     \
           KeAcquireSpinLock( &RxStrucSupSpinLock,&SavedIrql );   \
           RxDeviceObject->StartStopContext.State = (NewState); \
           KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );    \
        }

#define RxGetRdbssState(RxDeviceObject)         \
        (RxDeviceObject)->StartStopContext.State

BOOLEAN
RxIsOperationCompatibleWithRdbssState (
    PIRP Irp
    );

//
//  The RDBSS Device Object is an I/O system device object with additions for
//  the various structures needed by each minirdr: the dispatch, export-to-minirdr
//  structure, MUP call characteristics, list of active operations, etc.
//

typedef struct _RDBSS_DEVICE_OBJECT {

    union {
        DEVICE_OBJECT DeviceObject;
#ifndef __cplusplus
        DEVICE_OBJECT;
#endif //  __cplusplus
    };

    ULONG RegistrationControls;

    //
    //  stuff that the minirdr needs to know
    //

    PRDBSS_EXPORTS RdbssExports;      

    //
    //  set to NULL if monolithic
    //

    PDEVICE_OBJECT RDBSSDeviceObject; 

    //
    //  the mini rdr dispatch vector
    //

    PMINIRDR_DISPATCH Dispatch; 
    UNICODE_STRING DeviceName;

    ULONG NetworkProviderPriority;

    HANDLE MupHandle;

    BOOLEAN RegisterUncProvider;
    BOOLEAN RegisterMailSlotProvider;
    BOOLEAN RegisteredAsFileSystem;
    BOOLEAN Unused;

    LIST_ENTRY MiniRdrListLinks;

    ULONG NumberOfActiveFcbs;
    ULONG NumberOfActiveContexts;

    struct {
        
        LARGE_INTEGER PagingReadBytesRequested;
        LARGE_INTEGER NonPagingReadBytesRequested;
        LARGE_INTEGER CacheReadBytesRequested;
        LARGE_INTEGER FastReadBytesRequested;
        LARGE_INTEGER NetworkReadBytesRequested;
        ULONG ReadOperations;
        ULONG FastReadOperations;
        ULONG RandomReadOperations;

        LARGE_INTEGER PagingWriteBytesRequested;
        LARGE_INTEGER NonPagingWriteBytesRequested;
        LARGE_INTEGER CacheWriteBytesRequested;
        LARGE_INTEGER FastWriteBytesRequested;
        LARGE_INTEGER NetworkWriteBytesRequested;
        ULONG WriteOperations;
        ULONG FastWriteOperations;
        ULONG RandomWriteOperations;
    };

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    LONG PostedRequestCount[MaximumWorkQueue];

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    LONG OverflowQueueCount[MaximumWorkQueue];

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue[MaximumWorkQueue];

    //
    //  The following spinlock protects access to all the above fields.
    //

    RX_SPIN_LOCK OverflowQueueSpinLock;

    //
    //  The following fields are required for synchronization with async.
    //  requests issued by the RDBSS on behalf of this mini redirector on
    //  on shutdown.
    //

    LONG AsynchronousRequestsPending;

    PKEVENT pAsynchronousRequestsCompletionEvent;

    RDBSS_STARTSTOP_CONTEXT StartStopContext;

    RX_DISPATCHER_CONTEXT DispatcherContext;

    //
    //  some guys may want to share
    //

    PRX_PREFIX_TABLE pRxNetNameTable; 
    RX_PREFIX_TABLE RxNetNameTableInDeviceObject;


    //
    //  for sharing
    //

    PRDBSS_SCAVENGER pRdbssScavenger; 
    RDBSS_SCAVENGER RdbssScavengerInDeviceObject;

} RDBSS_DEVICE_OBJECT, *PRDBSS_DEVICE_OBJECT;

INLINE 
VOID
NTAPI
RxUnregisterMinirdr (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
{
    PDEVICE_OBJECT RDBSSDeviceObject;

    RDBSSDeviceObject = RxDeviceObject->RDBSSDeviceObject;

    RxpUnregisterMinirdr( RxDeviceObject );

    if (RDBSSDeviceObject != NULL) {
        ObDereferenceObject( RDBSSDeviceObject );
    }
}

extern FAST_MUTEX RxMinirdrRegistrationMutex;
extern LIST_ENTRY RxRegisteredMiniRdrs;
extern ULONG RxNumberOfMinirdrs;

#endif // _RDBSSSTRUC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\backpack.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    backpack.c

Abstract:

    This module contains the package for pseudo polling. When a caller
    requests the same operation and gets the same error return the rdr
    must prevent flooding the network by backing off requests. Examples
    of when this is desirable are receiving 0 bytes on consequtive reads
    and consequtive fails on a file lock.

    If the caller is flooding the network, the rdr will return the 0 bytes
    for a pipe read or lock fail to the user until NextTime is reached.
    When NextTime is reached BackOff will indicate that the network should
    be used.

Author:

    Colin Watson (colinw) 02-Jan-1991

Notes:

    Typical usage would be demonstrated by fsctrl.c on the peek request.

    1) Each time peek is called it calls RxShouldRequestBeThrottled.
        When the result is true, the wrapper returns to the caller a response
        indicating there is no data at the other end of the pipe.

        When the result is false, a request is made to the network.

    2) If the reply from the server to the peek in step 1 indicates that
    there is no data in the pipe then the wrapper calls RxInitiateOrContinueThrottling.

    3) Whenever there is data in the pipe or when this workstation may
    unblock the pipe (eg. the workstation writing to the pipe)
    RxTerminateThrottling is called.

Revision History:

    ColinWatson   [ColinW]       24-Dec-1990   Created
    Joe Linn      [JoeLinn]      10-Oct-1996   Lifted from rdr1 and massaged for rdr2

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef  ALLOC_PRAGMA
//#pragma alloc_text(PAGE3FILE, RxBackOff)  spinlock
//#pragma alloc_text(PAGE3FILE, RxBackPackFailure)  spinlock
#endif


BOOLEAN
RxShouldRequestBeThrottled (
    IN PTHROTTLING_STATE pBP
    )
/*++

Routine Description:

    This routine is called each time a request is made to find out if a the
    request should be sent to the network or a standard reply should be
    returned to the caller.

Arguments:

    pBP   -  supplies back pack data for this request.

Return Value:

    TRUE when caller should not access the network.


--*/

{
    LARGE_INTEGER CurrentTime,SavedThrottlingTime;
    BOOLEAN result;


    //  If the previous request worked then we should access the network.

    if (( pBP->CurrentIncrement == 0 ) ||
        ( pBP->MaximumDelay == 0 )) {
        return FALSE;
    }

    //  If the delay has expired then access the network.

    KeQuerySystemTime(&CurrentTime);

    InterlockedIncrement(&pBP->NumberOfQueries);

    SavedThrottlingTime.QuadPart = 0;

    RxAcquireSerializationMutex();

    SavedThrottlingTime.QuadPart = pBP->NextTime.QuadPart;

    RxReleaseSerializationMutex();

    result = (CurrentTime.QuadPart < SavedThrottlingTime.QuadPart);

    RxLog(("shouldthrttle=%x (%x)\n",result,pBP));

    return(result);
}

VOID
RxInitiateOrContinueThrottling (
    IN PTHROTTLING_STATE pBP
    )
/*++

Routine Description:

    This routine is called each time a request fails.

Arguments:

    pBP   -  supplies back pack data for this request.

Return Value:

    None.

--*/

{
    LARGE_INTEGER CurrentTime,NextTime;

    KeQuerySystemTime(&CurrentTime);

    if (pBP->CurrentIncrement < pBP->MaximumDelay ) {

        //
        //  We have reached NextTime but not our maximum delay limit.
        //

        InterlockedIncrement(&pBP->CurrentIncrement);
    }

    //  NextTime = CurrentTime + (Interval * CurrentIncrement )

    NextTime.QuadPart = CurrentTime.QuadPart +
                        (pBP->Increment.QuadPart * pBP->CurrentIncrement);

    RxAcquireSerializationMutex();

    pBP->NextTime.QuadPart = NextTime.QuadPart;

    RxReleaseSerializationMutex();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxworkq.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rxworkq.h

Abstract:

    This module defines the data structures required to implement the dispatching
    mechanism in RDBSS for use by RDBSS as well as all the mini redirectors.

Author:

    Balan Sethu Raman [SethuR] 20-Mar-96

--*/

#ifndef _RXWORKQ_H_
#define _RXWORKQ_H_

//
// The worker thread routine prototype definition.
//

typedef
VOID
(NTAPI *PRX_WORKERTHREAD_ROUTINE) (
    IN PVOID Context
    );

//
// The RDBSS needs to keep track of the work items on a per device object basis.
// This enables the race conditions associated with loading/unloading as well as
// a mechanism for preventing a single mini redirector from unfairly hogging all
// the resources.
//

#ifdef __cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ : public WORK_QUEUE_ITEM {
        // the work queue item as defined in NTOS
#else // !__cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ {
   WORK_QUEUE_ITEM;     // the work queue item as defined in NTOS
#endif // __cplusplus

   PRDBSS_DEVICE_OBJECT pDeviceObject;
} RX_WORK_QUEUE_ITEM, *PRX_WORK_QUEUE_ITEM;

//
// There are certain scenarios in which dispatching of work items is inevitable.
// In such instance the WORK_QUEUE_ITEM is allocated as part of another data
// structure to avoid frequent allocation/freeing. In other scenarios where
// dispatching is rare it pays to avoid the allocation of the memory till it
// is rquired. The RDBSS work queue implementations provide for both these
// scenarios in the form of dispatching and posting work queue requests. In
// the case of dispatching no memory for the WORK_QUEUE_ITEM need be allocated
// by the caller while for posting the memory for WORK_QUEUE_ITEM needs to be
// allocated by the caller.
//

typedef struct _RX_WORK_DISPATCH_ITEM_ {
   RX_WORK_QUEUE_ITEM       WorkQueueItem;
   PRX_WORKERTHREAD_ROUTINE DispatchRoutine;
   PVOID                    DispatchRoutineParameter;
} RX_WORK_DISPATCH_ITEM, *PRX_WORK_DISPATCH_ITEM;

//
// The work queues typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_WORK_QUEUE_STATE_ {
   RxWorkQueueActive,
   RxWorkQueueInactive,
   RxWorkQueueRundownInProgress
} RX_WORK_QUEUE_STATE, *PRX_WORK_QUEUE_STATE;

//
// The rundown of work queues is not complete when the threads have been spun down.
// The termination of the threads needs to be ensured before the data structures
// can be torn down. The work queue implementation follows a protocol in which
// each of the threads being spundown stashes a reference to the thread object
// in the rundown context. The rundown issuing thread ( which does not belong to
// the work queue ) waits for the completion of all the threads spundown before
// tearing down the data structures.
//

typedef struct _RX_WORK_QUEUE_RUNDOWN_CONTEXT_ {
   KEVENT      RundownCompletionEvent;
   LONG        NumberOfThreadsSpunDown;
   PETHREAD    *ThreadPointers;
} RX_WORK_QUEUE_RUNDOWN_CONTEXT, *PRX_WORK_QUEUE_RUNDOWN_CONTEXT;

//
// The work queue implementation is built around a KQUEUE implementation. The
// additional support involves the regulation of number of threads that are
// actively waiting for the work items. Each work queue data structure is
// allocated in nonpaged pool and has its own synchronization mechanism ( spinlock).
//
// In addition to the bookkeeing information, i.e., state, type etc. it also includes
// statistics that are gathered over the lifetime of the queue. This will
// provide valuable information in tuning a work queue instance. The number of items
// that have been processed , the number of items that have to be processed and
// the cumulative queue length is recorded. The cumulative queue length is the
// intersiting metric, it is the sum of the number of items awaiting to be processed
// each time an additional work item was queued. The cumulative queue length
// divided by the sum of the total number of items processed and the anumber of
// items to be processed gives an indication of the average length of the
// queue. A value much greater than one signifies that the  minimum number of
// worker threads associated with the work queue can be increased. A value much
// less than one signifies that the maximum number of work threads associated
// with the queue can be decreased.
//

typedef struct _RX_WORK_QUEUE_ {
   USHORT  State;
   BOOLEAN SpinUpRequestPending;
   UCHAR   Type;

   KSPIN_LOCK SpinLock;

   PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

   LONG    NumberOfWorkItemsDispatched;
   LONG    NumberOfWorkItemsToBeDispatched;
   LONG    CumulativeQueueLength;

   LONG    NumberOfSpinUpRequests;
   LONG    MaximumNumberOfWorkerThreads;
   LONG    MinimumNumberOfWorkerThreads;
   LONG    NumberOfActiveWorkerThreads;
   LONG    NumberOfIdleWorkerThreads;
   LONG    NumberOfFailedSpinUpRequests;
   LONG    WorkQueueItemForSpinUpWorkerThreadInUse;

   RX_WORK_QUEUE_ITEM WorkQueueItemForTearDownWorkQueue;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinUpWorkerThread;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinDownWorkerThread;

   KQUEUE  Queue;

   // The next field is for debugging purposes and will be removed from the
   // FREE build.
   PETHREAD *ThreadPointers;

} RX_WORK_QUEUE, *PRX_WORK_QUEUE;

//
// The dispatching mechanism in RDBSS provides for multiple levels of work queues
// on a per processor basis. There are three levels of work queues currently
// supported, Critical,Delayed and HyperCritical. The distinction between Critical
// and delayed is one of priority where as HyperCritical iss different from the
// other two in that the routines should not block, i.e., wait for any resource.
// This requirement cannot be enforced hence the effectiveness of the dispatching
// mechanism relies on the implicit cooperation of the clients.
//

typedef struct _RX_WORK_QUEUE_DISPATCHER_ {
   RX_WORK_QUEUE     WorkQueue[MaximumWorkQueue];
} RX_WORK_QUEUE_DISPATCHER, *PRX_WORK_QUEUE_DISPATCHER;

//
// The dispatcher typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_DISPATCHER_STATE_ {
   RxDispatcherActive,
   RxDispatcherInactive
} RX_DISPATCHER_STATE, *PRX_DISPATCHER_STATE;


//
// The RDBSS dispatching mechanism on any machine is an array of the dispatchers
// associated with each processor. When a work queue item is queued a best effort
// is made to contain the work emanating from a processor onto the same processor.
// This ensures that processor affinities setup by the NT dispatcher are not
// destroyed by the RDBSS dispatching mechanism as this could lead to excessive
// sloshing. When the work needs to be moved there are two metrics that will be
// useful in making the decision, teh amount of delay that will be experienced
// by the work item in the current queue and the effort involved in moving the
// work item to the other queue. It is very easy to quantify the former but very
// difficult to quantify the later.
//

typedef struct _RX_DISPATCHER_ {
   LONG                       NumberOfProcessors;
   PEPROCESS                  OwnerProcess;
   PRX_WORK_QUEUE_DISPATCHER  pWorkQueueDispatcher;

   RX_DISPATCHER_STATE        State;

   LIST_ENTRY                 SpinUpRequests;
   KSPIN_LOCK                 SpinUpRequestsLock;
   KEVENT                     SpinUpRequestsEvent;
   KEVENT                     SpinUpRequestsTearDownEvent;
} RX_DISPATCHER, *PRX_DISPATCHER;

//
// The function prototypes used for dispatching/posting work queue items
//

extern NTSTATUS
NTAPI
RxPostToWorkerThread (
    IN PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN WORK_QUEUE_TYPE          WorkQueueType,
    IN PRX_WORK_QUEUE_ITEM      pWorkQueueItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );

extern NTSTATUS
NTAPI
RxDispatchToWorkerThread(
    IN  PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN  WORK_QUEUE_TYPE          WorkQueueType,
    IN  PRX_WORKERTHREAD_ROUTINE Routine,
    IN  PVOID                    pContext);

extern BOOLEAN           //should only be called from raised IRQL
NTAPI
RxIsWorkItemQueued(
    IN OUT PWORK_QUEUE_ITEM WorkItem
    );

//
// The routines for initializing/tearing down the dispatching mechanism
//

extern NTSTATUS
RxInitializeDispatcher();

extern NTSTATUS
RxTearDownDispatcher();

extern NTSTATUS
RxInitializeMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

extern NTSTATUS
RxSpinDownMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

#endif  _RXWORKQ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\cachesup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module implements the cache management routines for the Rx
    FSD and FSP, by calling the Common Cache Manager.

Author:

    JoeLinn    Created.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CACHESUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CACHESUP)


BOOLEAN
RxLockEnumerator (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCompleteMdl)
//#pzragma alloc_text(PAGE, RxZeroData)
#pragma alloc_text(PAGE, RxSyncUninitializeCacheMap)
#pragma alloc_text(PAGE, RxLockEnumerator)
#endif

//
//  we can't use the Io system exported form of this because he does it on a file object. during a state
//  change, we don't know which fileobject it applies to (although, i suppose we could walk the list and
//  find out). so we need to apply this to the fcb instead.
//

#define RxIsFcbOpenedExclusively( FCB ) (((FCB)->ShareAccess.SharedRead \
                                           + (FCB)->ShareAccess.SharedWrite \
                                           + (FCB)->ShareAccess.SharedDelete) == 0)

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine performs the function of completing Mdl read and write
    requests.  It should be called only from RxFsdRead and RxFsdWrite.

Arguments:

    RxContext  - the Rx Context

Return Value:

    RXSTATUS - Will always be RxStatus(PENDING) or STATUS_SUCCESS.

--*/

{
    
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCompleteMdl\n", 0 ));
    RxDbgTrace( 0, Dbg, ("RxContext = %08lx\n", RxContext ));
    RxDbgTrace( 0, Dbg, ("Irp        = %08lx\n", Irp ));

    switch( RxContext->MajorFunction ) {
    case IRP_MJ_READ:

        CcMdlReadComplete( FileObject, Irp->MdlAddress );
        break;

    case IRP_MJ_WRITE:

        ASSERT( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT ));
        CcMdlWriteComplete( FileObject, &IrpSp->Parameters.Write.ByteOffset, Irp->MdlAddress );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:

        RxDbgTrace( 0, (DEBUG_TRACE_ERROR), ("Illegal Mdl Complete.\n", 0 ));
        RxBugCheck( RxContext->MajorFunction, 0, 0 );
    }

    //
    //  Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    //  Complete the request and exit right away.
    //

    RxCompleteRequest( RxContext, STATUS_SUCCESS );

    RxDbgTrace(-1, Dbg, ("RxCompleteMdl -> RxStatus(SUCCESS\n)", 0 ));

    return STATUS_SUCCESS;
}

VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine performs a CcUnitializeCacheMap to LargeZero synchronously.  That
    is it waits on the Cc event.  This call is useful when we want to be certain
    when a close will actually some in.

Return Value:

    None.

--*/

{
    CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
    NTSTATUS WaitStatus;

    PAGED_CODE();

    KeInitializeEvent( &UninitializeCompleteEvent.Event,
                       SynchronizationEvent,
                       FALSE );

    CcUninitializeCacheMap( FileObject,
                            &RxLargeZero,
                            &UninitializeCompleteEvent );

    //
    //  Now wait for the cache manager to finish purging the file.
    //  This will garentee that Mm gets the purge before we
    //  delete the Vcb.
    //

    WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

    ASSERT( NT_SUCCESS( WaitStatus ));
}


BOOLEAN
RxLockEnumerator (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    )
/*++

Routine Description:

    This routine is called from a minirdr to enumerate the filelocks on an FCB; it gets
    one lock on each call. currently, we just pass thru to the fsrtl routine which is very funky
    because it keeps the enumeration state internally; as a result, only one enumeration can be in progress
    at any time. we can change over to something better if it's ever required.


Arguments:

    SrvOpen - a srvopen on the fcb to be enumerated.

    ContinuationHandle - a handle passed back and forth representing the state of the enumeration.
                         if a NULL is passed in, then we are to start at the beginning.

    FileOffset,LockRange,IsLockExclusive - the description of the returned lock

Return Value:

    a BOOLEAN. FALSE means you've reached the end of the list; TRUE means the returned lock data is valid

--*/
{
    PFILE_LOCK_INFO LockInfo;
    ULONG LockNumber;
    PFCB Fcb = ((PSRV_OPEN)SrvOpen)->Fcb;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("FCB (%lx) LOCK Enumeration Buffering Flags(%lx)\n", Fcb, Fcb->FcbState) );
    if (!FlagOn( Fcb->FcbState, FCB_STATE_LOCK_BUFFERING_ENABLED )) {
       return FALSE;
    }

    LockNumber = PtrToUlong( *ContinuationHandle );
    LockInfo = FsRtlGetNextFileLock( &Fcb->FileLock, (BOOLEAN)(LockNumber == 0) );
    LockNumber += 1;
    if (LockInfo == NULL) {
        return FALSE;
    }
    
    RxDbgTrace( 0, Dbg, ("Rxlockenum %08lx\n", LockNumber ));
    *FileOffset = LockInfo->StartingByte;
    *LockRange = LockInfo->Length;
    *IsLockExclusive = LockInfo->ExclusiveLock;
    *ContinuationHandle = LongToPtr( LockNumber );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\cancel.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cancel.c

Abstract:

    This module implements the support for cancelling operations in the RDBSS driver

Author:

    Balan Sethu Raman [SethuR]    7-June-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg  (DEBUG_TRACE_CANCEL)


NTSTATUS
RxSetMinirdrCancelRoutine (
    IN OUT PRX_CONTEXT RxContext,
    IN PMRX_CALLDOWN MRxCancelRoutine
    )
/*++

Routine Description:

    The routine sets up a  mini rdr cancel routine for an RxContext.

Arguments:

    RxContext - the context

    MRxCancelRoutine - the cancel routine

Return Value:

    None.

Notes:

--*/
{
   NTSTATUS Status;
   KIRQL   SavedIrql;

   KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

   if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {
      
      RxContext->MRxCancelRoutine = MRxCancelRoutine;
      Status = STATUS_SUCCESS;
   
   } else {
      Status = STATUS_CANCELLED;
   }

   KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

   return Status;
}

VOID
RxpCancelRoutine (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is invoked to the underlying mini rdr cancel routine at a non
    DPC level. Note: cancel is not generally synchronized with irp completion. So
    an irp can complete and cancel can still be called at the same time. The rxcontext is
    ref counted so it will stick around. The irp can only be manipulated if some flag in the 
    rxcontext indicates its still active. This occurs in 2 cases
    
    1)  The irp is in the overflow queue
    
    2)  This is pipe operation that is being synchronized in the blocking queues

Arguments:

    RxContext - the context

Return Value:

    None.

Notes:

--*/
{

    PMRX_CALLDOWN MRxCancelRoutine;

    PAGED_CODE();

    MRxCancelRoutine = RxContext->MRxCancelRoutine;

    if (MRxCancelRoutine != NULL) {
        (MRxCancelRoutine)( RxContext );
    } else if (!RxCancelOperationInOverflowQueue( RxContext )) {

        RxCancelBlockingOperation( RxContext, RxContext->CurrentIrp );
    }

    RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
    RxWmiLog( LOG,
              RxpCancelRoutine,
              LOGPTR( RxContext )
              LOGULONG( RxContext->ReferenceCount ));

    RxDereferenceAndDeleteRxContext( RxContext );
}

VOID
RxCancelRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The cancel routine for RDBSS

Arguments:

    DeviceObject - the device object

    Irp          - the IRP to be cancelled

Return Value:

    None.

Notes:

    Any request can be in one of three states in RDBSS ---

    1) the request is being processed.

    2) the request is waiting for the results of a calldown to a minirdr.

    3) the request is waiting on a resource.

    Any request that has been accepted by RDBSS ( the corresponding RxContext has been
    created and the cancel routine has been set ) is a valid target for cancel. The RDBSS
    driver does not make any effort to cancel requests that are in state (1) as described
    above.

    The cancelling action is invoked on those requests which are either in state (2),
    state(3) or when it is about to transition to/from either of these states.

    In order to expedite cancelling a similar strategy needs to be in place for the mini
    redirectors. This is provided by enabling the mini redirectors to register a cancel routine
    and rreserving fields in the RxContext for the mini redirectors to store the state information.

    As part of the RDBSS cancel routine the following steps will be taken .....

    1) Locate the RxContext corresponding to the given IRP.

    2) If the RxContext is waiting for a minirdr invoke the appropriate cancel routine.

    Note that the request is not immediately completed in all cases. This implies that there
    will be latencies in cancelling a request. The goal is to minimise the latency rather
    than completely eliminate them.

--*/
{
    KIRQL         SavedIrql;
    PRX_CONTEXT   RxContext;
    PLIST_ENTRY   ListEntry;

    //
    //  Locate the context corresponding to the given Irp.
    //

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    ListEntry = RxActiveContexts.Flink;

    while (ListEntry != &RxActiveContexts) {
        
        RxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, ContextListEntry );

        if (RxContext->CurrentIrp == Irp) {
            break;
        } else {
            ListEntry = ListEntry->Flink;
        }
    }

    if ((ListEntry != &RxActiveContexts) &&
        !FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {
        
        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED );
        InterlockedIncrement( &RxContext->ReferenceCount );
    } else {
        RxContext = NULL;
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    if (RxContext != NULL) {
        if (!RxShouldPostCompletion()) {
            RxpCancelRoutine( RxContext );
        } else {
            RxDispatchToWorkerThread( RxFileSystemDeviceObject,
                                      CriticalWorkQueue,
                                      RxpCancelRoutine,
                                      RxContext );
        }
    }
}

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot (
    IN PV_NET_ROOT VNetRoot,
    IN BOOLEAN ForceFilesClosed
    )
/*++

Routine Description:

    This routine cancels all the outstanding requests for a given instance of V_NET_ROOT. The
    V_NET_ROOT's are created/deleted are independent of the files that are opened/manipulated
    in them. Therefore it is imperative that when a delete operation is attempted
    all the outstanding requests are cancelled.

Arguments:

    VNetRoot - the V_NET_ROOT instance about to be deleted

    ForceFilesClosed - if true force close, otherwise fai if opens exist

Return Value:

    None.

Notes:

--*/
{
    KIRQL SavedIrql;
    PRX_CONTEXT RxContext;
    PLIST_ENTRY ListEntry;
    LIST_ENTRY CancelledContexts;
    PMRX_CALLDOWN MRxCancelRoutine;
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead( &CancelledContexts );

    //
    //  Locate the context corresponding to the given Irp.
    //

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    ListEntry = RxActiveContexts.Flink;

    while (ListEntry != &RxActiveContexts) {
        
        RxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, ContextListEntry );
        ListEntry = ListEntry->Flink;

        if ((RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
            (RxContext->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY) &&
            (RxContext->pFcb != NULL) &&
            (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) &&
            (RxContext->NotifyChangeDirectory.pVNetRoot == (PMRX_V_NET_ROOT)VNetRoot) &&
            (RxContext->MRxCancelRoutine != NULL)) {

            if (!ForceFilesClosed) {
                
                Status = STATUS_FILES_OPEN;
                break;
            }

            //
            //  After this flag is set no one else will invoke the cancel routine or
            //  change it
            //  

            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED );
            RemoveEntryList( &RxContext->ContextListEntry );
            InsertTailList( &CancelledContexts, &RxContext->ContextListEntry );
            InterlockedIncrement( &RxContext->ReferenceCount );
        }
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (Status == STATUS_SUCCESS) {
        
        while (!IsListEmpty( &CancelledContexts )) {
            
            ListEntry = RemoveHeadList( &CancelledContexts );

            InitializeListHead( ListEntry );
            RxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, ContextListEntry);

            //
            //  check to see if this guy is already completed..........if so, don't call down.
            //

            if (RxContext->CurrentIrp != NULL) {
                
                MRxCancelRoutine = RxContext->MRxCancelRoutine;
                RxContext->MRxCancelRoutine = NULL;

                ASSERT( MRxCancelRoutine != NULL );

                RxLog(( "CCtx %lx CRtn %lx\n", RxContext, MRxCancelRoutine ));
                RxWmiLog( LOG,
                          RxCancelNotifyChangeDirectoryRequestsForVNetRoot,
                          LOGPTR( RxContext )
                          LOGPTR( MRxCancelRoutine ));

                (MRxCancelRoutine)( RxContext );
            }

            RxDereferenceAndDeleteRxContext( RxContext );
        }
    }
    return Status;
}

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx (
    PFOBX Fobx
    )
/*++

Routine Description:

    This routine cancels all the outstanding requests for a given FileObject This
    handles the case when a directory handle is closed while it has outstanding
    change notify requests pending.

Arguments:

    Fobx - the FOBX instance about to be closed

Return Value:

    None.

Notes:

--*/
{
    KIRQL         SavedIrql;
    PRX_CONTEXT   RxContext;
    PLIST_ENTRY   ListEntry;
    LIST_ENTRY    CancelledContexts;
    PMRX_CALLDOWN MRxCancelRoutine;

    InitializeListHead( &CancelledContexts );

    //
    //  Locate the context corresponding to the given Irp.
    //

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    ListEntry = RxActiveContexts.Flink;

    while (ListEntry != &RxActiveContexts) {
        
        RxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, ContextListEntry );
        ListEntry = ListEntry->Flink;

        if ((RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
            (RxContext->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY) &&
            (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) &&
            (RxContext->pFobx == (PMRX_FOBX)Fobx) &&
            (RxContext->MRxCancelRoutine != NULL)) {

            //
            //  After this flag is set no one else will invoke the cancel routine
            //  or change it
            //  

            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED );
            RemoveEntryList(&RxContext->ContextListEntry);
            InsertTailList(&CancelledContexts,&RxContext->ContextListEntry);
            InterlockedIncrement(&RxContext->ReferenceCount);
        }
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    while (!IsListEmpty(&CancelledContexts )) {
        
        ListEntry = RemoveHeadList(&CancelledContexts);

        InitializeListHead( ListEntry );
        RxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, ContextListEntry );

        //
        //  check to see if this IRP is already completed..........if so,
        //  don't call down.
        //

        if (RxContext->CurrentIrp != NULL) {
            MRxCancelRoutine = RxContext->MRxCancelRoutine;
            RxContext->MRxCancelRoutine = NULL;

            ASSERT(MRxCancelRoutine != NULL);

            RxLog(( "CCtx %lx CRtn %lx\n", RxContext, MRxCancelRoutine ));
            RxWmiLog( LOG,
                      RxCancelNotifyChangeDirectoryRequestsForFobx,
                      LOGPTR( RxContext )
                      LOGPTR( MRxCancelRoutine ));

            (MRxCancelRoutine)( RxContext );
        }

        RxDereferenceAndDeleteRxContext( RxContext );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxtypes.h ===
#ifndef _RXTYPES_INCL
#define _RXTYPES_INCL

#include "nodetype.h"

typedef PVOID RX_HANDLE, *PRX_HANDLE;
typedef KSPIN_LOCK  RX_SPIN_LOCK;
typedef PKSPIN_LOCK PRX_SPIN_LOCK;


// String definitions
// The RX_STRING type corresponds to a UNICODE_STRING and all the Rtl functions that are
// available to manipulate Unicode strings can be used to manipulate the strings
//

typedef struct _BINDING_HANDLE {
    RX_HANDLE pTdiEmulationContext;  // Win9X net structure
    RX_HANDLE pTransportInformation; // tdi transport information.
} RX_BINDING_HANDLE, *PRX_BINDING_HANDLE;

typedef UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING*     PUNICODE_STRING;


// This structure is transient.  Most fields in this structure allow us to
// move through the bind/addname part of activating a net.  Runtime info
// for the rxce and long term context is kept elsewhere.

typedef struct _RX_BINDING_CONTEXT {
    PUNICODE_STRING         pTransportName;       // Transport Name (unicode string).
    ULONG              QualityOfService;     // Requested QOS.
    // Common fields.
    PRX_BINDING_HANDLE pBindHandle;          // Handle to transport bind info.
    } RX_BINDING_CONTEXT, *PRX_BINDING_CONTEXT;
#endif      // _RXTYPES_INCL


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\rxwmi.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mupwml.h

Abstract:

    This file defines macro for use by the Rdbss driver

Author:

    yunlin

Revision History:

--*/

#ifndef __RX_RXWML_H__
#define __RX_RXWML_H__

typedef struct _RTL_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;
    
#ifndef _WMIKM_
#define _WMIKM_
#endif

#include "..\wmi\wmlkm.h"
#include "..\wmi\wmlmacro.h"

#define _RX_TRACE_STREAM               0x00
#define _RX_PERF_STREAM                0x01
#define _RX_INSTR_STREAM               0x02

#define _RX_ENABLE_ERROR               0x0001
#define _RX_ENABLE_LOG                 0x0002
#define _RX_ENABLE_TRACE               0x0004
#define _RX_ENABLE_SRVCALL             0x0008
#define _RX_ENABLE_NETROOT             0x0010
#define _RX_ENABLE_VNETROOT            0x0020
#define _RX_ENABLE_FCB                 0x0040
#define _RX_ENABLE_SRVOPEN             0x0080
#define _RX_ENABLE_FOBX                0x0100
#define _RX_ENABLE_TRANSPORT           0x0200
#define _RX_ENABLE_RXCONTEXT           0x0400
#define _RX_ENABLE_UNUSED1             0x0800
#define _RX_ENABLE_UNUSED2             0x1000
#define _RX_ENABLE_UNUSED3             0x2000
#define _RX_ENABLE_UNUSED4             0x4000
#define _RX_ENABLE_PAGEIORES           0x8000

#define _RX_LEVEL_DETAIL               0x1
#define _RX_LEVEL_NORM                 0x2
#define _RX_LEVEL_BRIEF                0x4

#define RX_LOG_STREAM(_stream)   _RX_ ## _stream ## _STREAM
#define RX_LOG_FLAGS(_flag)      _RX_ENABLE_ ## _flag
#define RX_LOG_LEVEL(_level)     _RX_LEVEL_ ## _level

#define RX_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(Rdbss_, RX_LOG_STREAM(_why), RX_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,

#define RxWmiTrace(_flag, _type, _arg)              \
            RX_LOG(TRACE, DETAIL, RX_LOG_FLAGS(_flag), _type, _arg)

#define RxWmiLog(_flag, _type, _arg)              \
            RX_LOG(TRACE, BRIEF, RX_LOG_FLAGS(_flag), _type, _arg)

#define RxWmiTraceError(_status, _flag, _type, _arg)    \
            RX_LOG(TRACE, DETAIL, (RX_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : RX_LOG_FLAGS(ERROR))), _type, _arg)

#define RxWmiLogError(_status, _flag, _type, _arg)    \
            RX_LOG(TRACE, BRIEF, (RX_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : RX_LOG_FLAGS(ERROR))), _type, _arg)

#if 0
#define RX_PERF(_flag, _type, _arg)                    \
            RX_LOG (PERF, HIGH, RX_LOG_FLAGS(_flag), _type, _arg)

#define RX_INSTR(_flag, _type, _arg)                   \
            RX_LOG (INSTR, HIGH, RX_LOG_FLAGS(_flag), _type, _arg)

#define RX_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, RX_LOG_STREAM(_why), RX_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define RX_DBG_PRINT(_flag, _fmtstr, _arg)             \
            RX_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define RX_ERR_PRINT (_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                RX_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }
#endif

typedef enum _RX_WMI_ENUM_ {
  MSG_ID_RxDefault = 1,
  MSG_ID_RxCommonDispatchProblem,
  MSG_ID_RxFsdCommonDispatch_OF,
  MSG_ID_RxInitializeContext,
  MSG_ID_RxCompleteRequest = 5,
  MSG_ID_RxCompleteRequest_NI,
  MSG_ID_RxSynchronizeBlockingOperationsMaybeDroppingFcbLock,
  MSG_ID_RxItsTheSameContext,
  MSG_ID_RxRegisterChangeBufferingStateRequest_1,
  MSG_ID_RxRegisterChangeBufferingStateRequest_2 = 10,
  MSG_ID_RxRegisterChangeBufferingStateRequest_3,
  MSG_ID_RxPrepareRequestForHandling_1,
  MSG_ID_RxPrepareRequestForHandling_2,
  MSG_ID_RxpDiscardChangeBufferingStateRequests,
  MSG_ID_RxpDispatchChangeBufferingStateRequests = 15,
  MSG_ID_RxpProcessChangeBufferingStateRequests_1,
  MSG_ID_RxpProcessChangeBufferingStateRequests_2,
  MSG_ID_RxpProcessChangeBufferingStateRequests_3,
  MSG_ID_RxpProcessChangeBufferingStateRequests_4,
  MSG_ID_RxpProcessChangeBufferingStateRequests_5 = 20,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_1,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_2,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_3,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_1,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_2 = 25,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_3,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_4,
  MSG_ID_RxChangeBufferingState_1,
  MSG_ID_RxChangeBufferingState_2,
  MSG_ID_RxChangeBufferingState_3 = 30,
  MSG_ID_RxChangeBufferingState_4,
  MSG_ID_RxChangeBufferingState_5,
  MSG_ID_RxFlushFcbInSystemCache,
  MSG_ID_RxPurgeFcbInSystemCache,
  MSG_ID_RxCopyCreateParameters_1 = 35,
  MSG_ID_RxCopyCreateParameters_2,
  MSG_ID_RxFindOrCreateFcb,
  MSG_ID_RxSearchForCollapsibleOpen,
  MSG_ID_RxCollapseOrCreateSrvOpen,
  MSG_ID_RxCommonCreate_1 = 40,
  MSG_ID_RxCommonCreate_2,
  MSG_ID_RxCommonCreate_3,
  MSG_ID_RxCommonCreate_4,
  MSG_ID_RxCommonCreate_5,
  MSG_ID_RxCommonClose_1 = 45,
  MSG_ID_RxCommonClose_2,
  MSG_ID_RxCloseAssociatedSrvOpen,
  MSG_ID_RxpCancelRoutine,
  MSG_ID_RxCancelNotifyChangeDirectoryRequestsForVNetRoot,
  MSG_ID_RxCancelNotifyChangeDirectoryRequestsForFobx = 50,
  MSG_ID_RxCommonDirectoryControl,
  MSG_ID_RxQueryDirectory_1,
  MSG_ID_RxQueryDirectory_2,
  MSG_ID_RxQueryDirectory_3,
  MSG_ID_RxCommonQueryInformation_1 = 55,
  MSG_ID_RxCommonQueryInformation_2,
  MSG_ID_RxCommonSetInformation_1,
  MSG_ID_RxCommonSetInformation_2,
  MSG_ID_RxSetBasicInfo,
  MSG_ID_RxSetDispositionInfo = 60,
  MSG_ID_RxSetRenameInfo,
  MSG_ID_RxSetPositionInfo,
  MSG_ID_RxSetAllocationInfo_1,
  MSG_ID_RxSetAllocationInfo_2,
  MSG_ID_RxSetEndOfFileInfo_1 = 65,
  MSG_ID_RxSetEndOfFileInfo_2,
  MSG_ID_RxSetEndOfFileInfo_3,
  MSG_ID_RxSetEndOfFileInfo_4,
  MSG_ID_RxQueryBasicInfo,
  MSG_ID_RxQueryStandardInfo = 70,
  MSG_ID_RxQueryInternalInfo,
  MSG_ID_RxQueryEaInfo,
  MSG_ID_RxQueryPositionInfo,
  MSG_ID_RxQueryNameInfo,
  MSG_ID_RxQueryAlternateNameInfo = 75,
  MSG_ID_RxQueryCompressedInfo,
  MSG_ID_RxSetPipeInfo,
  MSG_ID_RxQueryPipeInfo,
  MSG_ID_RxCommonFlushBuffers,
  MSG_ID_RxCommonFileSystemControl = 80,
  MSG_ID_RxLowIoFsCtlShell,
  MSG_ID_RxLowIoFsCtlShellCompletion_1,
  MSG_ID_RxLowIoFsCtlShellCompletion_2,
  MSG_ID_RxCommonLockControl_1,
  MSG_ID_RxCommonLockControl_2 = 85,
  MSG_ID_RxCommonLockControl_3,
  MSG_ID_RxCommonLockControl_4,
  MSG_ID_RxCommonLockControl_5,
  MSG_ID_RxLockOperationCompletion_1,
  MSG_ID_RxLockOperationCompletion_2 = 90,
  MSG_ID_RxLockOperationCompletion_3,
  MSG_ID_RxLockOperationCompletion_4,
  MSG_ID_RxLockOperationCompletion_5,
  MSG_ID_RxLockOperationCompletion_6,
  MSG_ID_RxLockOperationCompletion_7 = 95,
  MSG_ID_RxLockOperationCompletion_8,
  MSG_ID_RxLockOperationCompletionWithAcquire_1,
  MSG_ID_RxLockOperationCompletionWithAcquire_2,
  MSG_ID_RxLockOperationCompletionWithAcquire_3,
  MSG_ID_RxUnlockOperation = 100,
  MSG_ID_RxLowIoLockControlShellCompletion_1,
  MSG_ID_RxLowIoLockControlShellCompletion_2,
  MSG_ID_RxFinalizeLockList,
  MSG_ID_RxLowIoLockControlShell,
  MSG_ID_RxRegisterMinirdr = 105,
  MSG_ID_RxCommonDevFCBClose,
  MSG_ID_RxCommonDevFCBCleanup,
  MSG_ID_RxCommonDevFCBFsCtl,
  MSG_ID_RxCommonDevFCBQueryVolInfo,
  MSG_ID_RxExceptionFilter_1 = 110,
  MSG_ID_RxExceptionFilter_2,
  MSG_ID_RxFastIoRead_1,
  MSG_ID_RxFastIoRead_2,
  MSG_ID_RxFastIoRead_3,
  MSG_ID_RxFastIoWrite_1 = 115,
  MSG_ID_RxFastIoWrite_2,
  MSG_ID_RxFastIoCheckIfPossible,
  MSG_ID_RxFspDispatch,
  MSG_ID_RxFsdPostRequest,
  MSG_ID_RxGetNetworkProviderPriority = 120,
  MSG_ID_RxAccrueProviderFromServiceName_1,
  MSG_ID_RxAccrueProviderFromServiceName_2,
  MSG_ID_RxConstructProviderOrder_1,
  MSG_ID_RxConstructProviderOrder_2,
  MSG_ID_RxCommonRead_1 = 125,
  MSG_ID_RxCommonRead_2,
  MSG_ID_RxCommonRead_3,
  MSG_ID_RxCommonRead_4,
  MSG_ID_RxLowIoReadShellCompletion_1,
  MSG_ID_RxLowIoReadShellCompletion_2 = 130,
  MSG_ID_RxLowIoReadShellCompletion_3,
  MSG_ID_RxLowIoReadShell_1,
  MSG_ID_RxLowIoReadShell_2,
  MSG_ID_RxSetDomainForMailslotBroadcast_1,
  MSG_ID_RxSetDomainForMailslotBroadcast_2 = 135,
  MSG_ID_RxCommonQueryVolumeInformation_1,
  MSG_ID_RxCommonQueryVolumeInformation_2,
  MSG_ID_RxCommonSetVolumeInformation_1,
  MSG_ID_RxCommonSetVolumeInformation_2,
  MSG_ID_RxCommonWrite_1 = 140,
  MSG_ID_RxCommonWrite_2,
  MSG_ID_RxCommonWrite_3,
  MSG_ID_RxCommonWrite_4,
  MSG_ID_RxCommonWrite_5,
  MSG_ID_RxCommonWrite_6 = 145,
  MSG_ID_RxCommonWrite_7,
  MSG_ID_RxLowIoWriteShellCompletion_1,
  MSG_ID_RxLowIoWriteShellCompletion_2,
  MSG_ID_RxLowIoWriteShell_1,
  MSG_ID_RxLowIoWriteShell_2 =150,
  MSG_ID_RxFinalizeNetTable_1,
  MSG_ID_RxFinalizeNetTable_2,
  MSG_ID_RxFinalizeConnection,
  MSG_ID_RxFinalizeSrvCall,
  MSG_ID_RxFinalizeNetRoot = 155,
  MSG_ID_RxFinalizeVNetRoot,
  MSG_ID_RxCreateNetFcb_1,
  MSG_ID_RxCreateNetFcb_2,
  MSG_ID_RxCreateNetFcb_3,
  MSG_ID_RxFinalizeNetFcb = 160,
  MSG_ID_RxCreateSrvOpen,
  MSG_ID_RxFinalizeSrvOpen,
  MSG_ID_RxCreateNetFobx,
  MSG_ID_RxFinalizeNetFobx_1,
  MSG_ID_RxFinalizeNetFobx_2 = 165,
  MSG_ID_RxUninitializeMidMap,
  MSG_ID_RxAcquireFcb_1,
  MSG_ID_RxAcquireFcb_2,
  MSG_ID_RxCeBindToTransport,
  MSG_ID_RxCeTearDownTransport = 170,
  MSG_ID_RxCeQueryAdapterStatus,
  MSG_ID_RxCeQueryTransportInformation,
  MSG_ID_RxCeBuildAddress,
  MSG_ID_RxCeBuildVC,
  MSG_ID_RxCeInitiateVCDisconnect = 175,
  MSG_ID_RxCeTearDownVC,
  MSG_ID_RxCeBuildConnection,
  MSG_ID_RxCeCleanupConnectCallOutContext,
  MSG_ID_RxCeCompleteConnectRequest,
  MSG_ID_RxCeBuildConnectionOverMultipleTransports_1 = 180,
  MSG_ID_RxCeBuildConnectionOverMultipleTransports_2,
  MSG_ID_RxCeTearDownConnection,
  MSG_ID_RxCeSend,
  MSG_ID_RxCeSendDatagram,
  MSG_ID_RxFindOrCreateConnections_1 = 185,
  MSG_ID_RxFindOrCreateConnections_2,
  MSG_ID_RxFinishSrvCallConstruction,
  MSG_ID_RxConstructSrvCall,
  MSG_ID_RxFindOrConstructVirtualNetRoot,
  MSG_ID_RxSpinUpWorkerThread = 190,
  MSG_ID_RxSpinUpRequestsDispatcher,
  MSG_ID_RxpWorkerThreadDispatcher,
  MSG_ID_RxWorkItemDispatcher,
  MSG_ID_RxDispatchToWorkerThread,
  MSG_ID_RxPostToWorkerThread = 195,
  MSG_ID_RxPurgeFobxFromCache,
  MSG_ID_RxPurgeFobx_1,
  MSG_ID_RxPurgeFobx_2,
  MSG_ID_RxPurgeFobx_3,
  MSG_ID_RxPurgeFobx_4 = 200,
  MSG_ID_RxPurgeRelatedFobxs_1,
  MSG_ID_RxPurgeRelatedFobxs_2,
  MSG_ID_RxPurgeAllFobxs,
  MSG_ID_RxpMarkInstanceForScavengedFinalization,
  MSG_ID_RxScavengerFinalizeEntries = 205,
  MSG_ID_RxCeBuildTransport,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_4,
  MSG_ID_RxInsertWorkQueueItem,
  MSG_ID_RxRefSrvcall,
  MSG_ID_RxRefNetRoot = 210,
  MSG_ID_RxRefVNetRoot,
  MSG_ID_RxRefFcb,
  MSG_ID_RxRefSrvOpen,
  MSG_ID_RxRefFobx,
  MSG_ID_RxDerefSrvcall = 215,
  MSG_ID_RxDerefNetRoot,
  MSG_ID_RxDerefVNetRoot,
  MSG_ID_RxDerefFcb,
  MSG_ID_RxDerefSrvOpen,
  MSG_ID_RxDerefFobx = 220,
  MSG_ID_RxTdiAsynchronousConnectCompletion,
  MSG_ID_RxPurgeRelatedFobxs_3,
  MSG_ID_RxTrackPagingIoResource_1,
  MSG_ID_RxTrackPagingIoResource_2,
  MSG_ID_RxTrackPagingIoResource_3 = 225,
  MSG_ID_RxSetSimpleInfo,
} RX_WMI_ENUM; 

            
#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)

extern WML_CONTROL_GUID_REG Rdbss_ControlGuids[];

#endif /* __RX_RXWML_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\struchdr.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucHdr.h

Abstract:

    This module predefines the structures for important data structures so that we can always talk about them....
    even though they're not defined yet.

Author:

    Joe Linn     [joelinn]    8-19-94

Revision History:

--*/

#ifndef _RDBSSSTRUCHDR_
#define _RDBSSSTRUCHDR_

#define IMPORTANT_STRUCTURE(x) struct _##x; typedef struct _##x *P##x

typedef struct _NODE_TYPE_CODE_AND_SIZE *PNODE_TYPE_CODE_AND_SIZE;

typedef struct _RX_PREFIX_ENTRY *PRX_PREFIX_ENTRY;
typedef struct _RX_PREFIX_TABLE *PRX_PREFIX_TABLE;

typedef struct _RX_FSD_DISPATCH_VECTOR *PRX_FSD_DISPATCH_VECTOR;
typedef struct _RDBSS_DATA *PRDBSS_DATA;
typedef struct _RDBSS_EXPORTS *PRDBSS_EXPORTS;
typedef struct _VCB *PVCB;
typedef struct _RDBSS_DEVICE_OBJECT *PRDBSS_DEVICE_OBJECT;

typedef struct _FILE_NAME_NODE *PFILE_NAME_NODE;
typedef struct _REPINNED_BCBS *PREPINNED_BCBS;
typedef struct _RDBSS_IO_CONTEXT *PRDBSS_IO_CONTEXT;
typedef struct _IO_RUNS *PIO_RUNS;
typedef struct _DELETE_CONTEXT *PDELETE_CONTEXT;
typedef struct _CLOSE_CONTEXT *PCLOSE_CONTEXT;
typedef struct _CLEAN_AND_DIRTY_VOLUME_PACKET *PCLEAN_AND_DIRTY_VOLUME_PACKET;

typedef struct _SRV_CALL *PSRV_CALL;
typedef struct _NET_ROOT *PNET_ROOT;
typedef struct _V_NET_ROOT *PV_NET_ROOT;
typedef struct _NON_PAGED_FCB *PNON_PAGED_FCB;
typedef struct _FCB *PFCB;
typedef struct _SRV_OPEN *PSRV_OPEN;
typedef struct _FOBX *PFOBX;
typedef struct _RX_CONTEXT *PRX_CONTEXT;
typedef struct _LOWIO_CONTEXT *PLOWIO_CONTEXT;

typedef struct _EA_RANGE *PEA_RANGE;

typedef struct _MINIRDR_DISPATCH *PMINIRDR_DISPATCH;
typedef struct _RDBSS_EXPORTS *PRDBSS_EXPORTS;
typedef struct _MRX_SRVCALL_CALLBACK_CONTEXT *PMRX_SRVCALL_CALLBACK_CONTEXT;
typedef struct _MRX_SRVCALLDOWN_STRUCTURE *PMRX_SRVCALLDOWN_STRUCTURE;
typedef struct _MRX_CREATENETROOT_CONTEXT *PMRX_CREATENETROOT_CONTEXT;

#endif // _RDBSSSTRUCHDR_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\inc\scavengr.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.h

Abstract:

    This module defines data structures related to scavenging in the RDBSS

Author:

    Balan Sethu Raman     [SethuR]   9-Sep-1995

Revision History:


Notes:

    The dormant file limit must be made configurable on a per server basis

--*/

#ifndef _SCAVENGR_H_
#define _SCAVENGR_H_

//                                               
//  currently, only a single scavengermutex is across all scavenging operations
//  for all underlying deviceobjects
//

extern KMUTEX       RxScavengerMutex;

//
//  An instance of this data structure is embedded as part of those data structures
//  that are scavenged, i.e., FCB, RX_CONTEXT, etc.
//

#define RX_SCAVENGER_ENTRY_TYPE_MARKER   (0x0001)
#define RX_SCAVENGER_ENTRY_TYPE_FCB      (0x0002)

#define RX_SCAVENGER_OP_PURGE            (0x0001)
#define RX_SCAVENGER_OP_CLOSE            (0x0002)

#define RX_SCAVENGER_INITIATED_OPERATION     (0x0001)

typedef enum _RX_SCAVENGER_ENTRY_STATE {
    RX_SCAVENGING_INACTIVE,
    RX_SCAVENGING_PENDING,
    RX_SCAVENGING_IN_PROGRESS,
    RX_SCAVENGING_AWAITING_RESPONSE
} RX_SCAVENGER_ENTRY_STATE, *PRX_SCAVENGER_ENTRY_STATE;

typedef struct _RX_SCAVENGER_ENTRY {

    //
    // List of related items to be scavenged
    //
    
    LIST_ENTRY  List;
    
    UCHAR        Type;
    UCHAR        Operation;
    UCHAR        State;
    UCHAR        Flags;
    
    struct _RX_SCAVENGER_ENTRY *pContinuationEntry;

} RX_SCAVENGER_ENTRY, *PRX_SCAVENGER_ENTRY;


#define RxInitializeScavengerEntry(ScavengerEntry)      \
        (ScavengerEntry)->State  = 0;                   \
        (ScavengerEntry)->Flags  = 0;                   \
        (ScavengerEntry)->Type   = 0;                   \
        (ScavengerEntry)->Operation = 0;                \
        InitializeListHead(&(ScavengerEntry)->List);  \
        (ScavengerEntry)->pContinuationEntry = NULL

#define RX_SCAVENGER_MUTEX_ACQUIRED (1)

typedef enum _RDBSS_SCAVENGER_STATE {
    RDBSS_SCAVENGER_INACTIVE,
    RDBSS_SCAVENGER_DORMANT,
    RDBSS_SCAVENGER_ACTIVE,
    RDBSS_SCAVENGER_SUSPENDED
} RDBSS_SCAVENGER_STATE, *PRDBSS_SCAVENGER_STATE;

typedef struct _RDBSS_SCAVENGER {
    
    RDBSS_SCAVENGER_STATE State;
    
    LONG MaximumNumberOfDormantFiles;
    LONG NumberOfDormantFiles;
    
    ULONG SrvCallsToBeFinalized;
    ULONG NetRootsToBeFinalized;
    ULONG VNetRootsToBeFinalized;
    ULONG FcbsToBeFinalized;
    ULONG SrvOpensToBeFinalized;
    ULONG FobxsToBeFinalized;
    
    LIST_ENTRY SrvCallFinalizationList;
    LIST_ENTRY NetRootFinalizationList;
    LIST_ENTRY VNetRootFinalizationList;
    LIST_ENTRY FcbFinalizationList;
    LIST_ENTRY SrvOpenFinalizationList;
    LIST_ENTRY FobxFinalizationList;
    
    LIST_ENTRY ClosePendingFobxsList;
    
    RX_WORK_ITEM WorkItem;
    KEVENT SyncEvent;
    
    PETHREAD CurrentScavengerThread;
    PNET_ROOT CurrentNetRootForClosePendingProcessing;
    PFCB CurrentFcbForClosePendingProcessing;
    KEVENT ClosePendingProcessingSyncEvent;

} RDBSS_SCAVENGER, *PRDBSS_SCAVENGER;

#define RxInitializeRdbssScavenger(Scavenger)                              \
    (Scavenger)->State = RDBSS_SCAVENGER_INACTIVE;                         \
    (Scavenger)->SrvCallsToBeFinalized = 0;                                \
    (Scavenger)->NetRootsToBeFinalized = 0;                                \
    (Scavenger)->VNetRootsToBeFinalized = 0;                               \
    (Scavenger)->FcbsToBeFinalized = 0;                                    \
    (Scavenger)->SrvOpensToBeFinalized = 0;                                \
    (Scavenger)->FobxsToBeFinalized = 0;                                   \
    (Scavenger)->NumberOfDormantFiles = 0;                                 \
    (Scavenger)->MaximumNumberOfDormantFiles = 50;                         \
    (Scavenger)->CurrentFcbForClosePendingProcessing = NULL;               \
    (Scavenger)->CurrentNetRootForClosePendingProcessing = NULL;           \
    KeInitializeEvent(&((Scavenger)->SyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((Scavenger)->ClosePendingProcessingSyncEvent),NotificationEvent,FALSE);  \
    InitializeListHead(&(Scavenger)->SrvCallFinalizationList);           \
    InitializeListHead(&(Scavenger)->NetRootFinalizationList);           \
    InitializeListHead(&(Scavenger)->VNetRootFinalizationList);          \
    InitializeListHead(&(Scavenger)->SrvOpenFinalizationList);           \
    InitializeListHead(&(Scavenger)->FcbFinalizationList);               \
    InitializeListHead(&(Scavenger)->FobxFinalizationList);              \
    InitializeListHead(&(Scavenger)->ClosePendingFobxsList)


#define RxAcquireScavengerMutex()   \
        KeWaitForSingleObject( &RxScavengerMutex, Executive, KernelMode, FALSE, NULL )

#define RxReleaseScavengerMutex()   \
        KeReleaseMutex( &RxScavengerMutex, FALSE )

NTSTATUS
RxMarkFcbForScavengingAtCleanup (
    PFCB Fcb
    );

NTSTATUS
RxMarkFcbForScavengingAtClose (
    PFCB 
    Fcb
    );

VOID
RxUpdateScavengerOnCloseCompletion (
    PFCB 
    Fcb
    );

VOID
RxMarkFobxOnCleanup (
    PFOBX pFobx, 
    PBOOLEAN NeedPurge
    );

VOID
RxMarkFobxOnClose (
    PFOBX Fobx
    );

NTSTATUS
RxPurgeRelatedFobxs (
    PNET_ROOT NetRoot,
    PRX_CONTEXT RxContext,
    BOOLEAN AttemptFinalization,
    PFCB PurgingFcb
    );

#define DONT_ATTEMPT_FINALIZE_ON_PURGE FALSE
#define ATTEMPT_FINALIZE_ON_PURGE TRUE

//
//  the purge_sync context is used to synchronize contexts that are attempting to purge...
//  notatbly creates and dirctrls. these are planted in various structures because various minirdrs
//  require different granularity of purge operations
//

    
typedef struct _PURGE_SYNCHRONIZATION_CONTEXT {

    //
    //  the list of purge requests active for this netroot.
    //

    LIST_ENTRY   ContextsAwaitingPurgeCompletion; 
    BOOLEAN      PurgeInProgress;
} PURGE_SYNCHRONIZATION_CONTEXT, *PPURGE_SYNCHRONIZATION_CONTEXT;

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    );

NTSTATUS
RxScavengeRelatedFcbs (
    PRX_CONTEXT RxContext
    );

BOOLEAN
RxScavengeRelatedFobxs (
    PFCB Fcb
    );

VOID
RxScavengeFobxsForNetRoot (
    PNET_ROOT NetRoot,
    PFCB PurgingFcb
    );

VOID
RxpMarkInstanceForScavengedFinalization (
   PVOID Instance
   );

VOID
RxpUndoScavengerFinalizationMarking (
   PVOID Instance
   );

VOID
RxTerminateScavenging (
   PRX_CONTEXT RxContext
   );

BOOLEAN
RxScavengeVNetRoots (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxSynchronizeWithScavenger (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

#endif // _SCAVENGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\drventry.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the externally visible DRIVER_INITIALIZATION routine for the RDBSS;
    actually, it's just a passthru. for nonmonolithic, we need the name to be DriverEntry; for nonmono-
    we need the name NOT to be DriverEntry.

Author:

    Joe Linn [JoeLinn]    20-jul-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is just a wrapper.

Arguments:


Return Value:

--*/

{
    NTSTATUS Status;
    
    //
    //  Setup Unload Routine
    //

    Status =  RxDriverEntry( DriverObject, RegistryPath );
    if (Status == STATUS_SUCCESS) {
        DriverObject->DriverUnload = RxUnload;
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dirctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Rx called
    by the dispatch driver.

Author:

    Joe Linn     [Joe Linn]    4-oct-94

    Balan Sethu Raman [SethuR] 16-Oct-95  Hook in the notify change API routines

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)


WCHAR Rx8QMdot3QM[12] = { DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM,
                           L'.', DOS_QM, DOS_QM, DOS_QM};

WCHAR RxStarForTemplate[] = L"*";

//
//  Local procedure prototypes
//

NTSTATUS
RxQueryDirectory ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxNotifyChangeDirectory ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxLowIoNotifyChangeDirectoryCompletion ( 
    IN PRX_CONTEXT RxContext 
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDirectoryControl)
#pragma alloc_text(PAGE, RxNotifyChangeDirectory)
#pragma alloc_text(PAGE, RxQueryDirectory)
#pragma alloc_text(PAGE, RxLowIoNotifyChangeDirectoryCompletion)
#endif

NTSTATUS
RxCommonDirectoryControl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )
/*++

Routine Description:

    This is the common routine for doing directory control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PFCB Fcb;
    PFOBX Fobx;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonDirectoryControl IrpC/Fobx/Fcb = %08lx %08lx %08lx\n", RxContext, Fobx, Fcb) );
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", Irpsp->MinorFunction ) );
    RxLog(( "CommDirC %lx %lx %lx %ld\n", RxContext, Fobx, Fcb, IrpSp->MinorFunction) );
    RxWmiLog( LOG,
              RxCommonDirectoryControl,
              LOGPTR( RxContext )
              LOGPTR( Fobx )
              LOGPTR( Fcb )
              LOGUCHAR( IrpSp->MinorFunction ));
    
    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:
        
        Status = RxQueryDirectory( RxContext, Irp, Fcb, Fobx );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
        
        Status = RxNotifyChangeDirectory( RxContext, Irp, Fcb, Fobx );

        if (Status == STATUS_PENDING) {
            RxDereferenceAndDeleteRxContext( RxContext );
        }
        break;

    default:
        RxDbgTrace( 0, Dbg, ("Invalid Directory Control Minor Function %08lx\n", IrpSp->MinorFunction ));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDirectoryControl -> %08lx\n", Status));
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
RxQueryDirectory ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    TYPE_OF_OPEN TypeOfOpen = NodeType( Fcb );

    CLONG UserBufferLength;

    PUNICODE_STRING FileName;
    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN PostQuery = FALSE;

    PAGED_CODE();

    //
    //  Display the input values.
    //

    RxDbgTrace( +1, Dbg, ("RxQueryDirectory...\n", 0) );
    RxDbgTrace( 0, Dbg, (" Wait              = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )) );
    RxDbgTrace( 0, Dbg, (" Irp               = %08lx\n", Irp ));
    RxDbgTrace( 0, Dbg, (" ->UserBufLength   = %08lx\n", IrpSp->Parameters.QueryDirectory.Length ));
    RxDbgTrace( 0, Dbg, (" ->FileName = %08lx\n", IrpSp->Parameters.QueryDirectory.FileName ));

#if DBG
    if (IrpSp->Parameters.QueryDirectory.FileName) {
        RxDbgTrace( 0, Dbg, (" ->     %wZ\n", IrpSp->Parameters.QueryDirectory.FileName ));
    }
#endif
    
    RxDbgTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass ));
    RxDbgTrace( 0, Dbg, (" ->FileIndex       = %08lx\n", IrpSp->Parameters.QueryDirectory.FileIndex ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer      = %08lx\n", Irp->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->RestartScan     = %08lx\n", FlagOn( IrpSp->Flags, SL_RESTART_SCAN )));
    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )));
    RxDbgTrace( 0, Dbg, (" ->IndexSpecified  = %08lx\n", FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED )));

    RxLog(( "Qry %lx %d %ld %lx %d\n",
            RxContext, BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT), //  1,2
            IrpSp->Parameters.QueryDirectory.Length, IrpSp->Parameters.QueryDirectory.FileName, //  3,4
            IrpSp->Parameters.QueryDirectory.FileInformationClass //  5
          ));
    RxWmiLog( LOG,
              RxQueryDirectory_1,
              LOGPTR( RxContext )
              LOGULONG( RxContext->Flags )
              LOGULONG( IrpSp->Parameters.QueryDirectory.Length )
              LOGPTR( IrpSp->Parameters.QueryDirectory.FileName )
              LOGULONG( IrpSp->Parameters.QueryDirectory.FileInformationClass ));
    RxLog(( "  alsoqry  %d %lx %lx\n",
          IrpSp->Parameters.QueryDirectory.FileIndex, 
          Irp->UserBuffer, 
          IrpSp->Flags ));
    RxWmiLog( LOG,
              RxQueryDirectory_2,
              LOGULONG( IrpSp->Parameters.QueryDirectory.FileIndex )
              LOGPTR( Irp->UserBuffer )
              LOGUCHAR( IrpSp->Flags ));
    if (IrpSp->Parameters.QueryDirectory.FileName) {
        RxLog(( " QryName %wZ\n", ((PUNICODE_STRING)IrpSp->Parameters.QueryDirectory.FileName) ));
        RxWmiLog( LOG,
                  RxQueryDirectory_3,
                  LOGUSTR(*IrpSp->Parameters.QueryDirectory.FileName) );
    }

    //
    //  If this is the initial query, then grab exclusive access in
    //  order to update the search string in the Fobx.  We may
    //  discover that we are not the initial query once we grab the Fcb
    //  and downgrade our status.
    //
   
    if (Fobx == NULL) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (Fcb->NetRoot->Type != NET_ROOT_DISK) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.QueryDirectory.Length;
    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;
    FileName = IrpSp->Parameters.QueryDirectory.FileName;

    RxContext->QueryDirectory.FileIndex = IrpSp->Parameters.QueryDirectory.FileIndex;
    RxContext->QueryDirectory.RestartScan = BooleanFlagOn( IrpSp->Flags, SL_RESTART_SCAN );
    RxContext->QueryDirectory.ReturnSingleEntry = BooleanFlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY );
    RxContext->QueryDirectory.IndexSpecified = BooleanFlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED );
    RxContext->QueryDirectory.InitialQuery = (BOOLEAN)((Fobx->UnicodeQueryTemplate.Buffer == NULL) &&
                                                        !FlagOn( Fobx->Flags, FOBX_FLAG_MATCH_ALL ));

    if (RxContext->QueryDirectory.IndexSpecified) {
       return STATUS_NOT_IMPLEMENTED;
    }

    if (RxContext->QueryDirectory.InitialQuery) {
        
        Status = RxAcquireExclusiveFcb( RxContext, Fcb );

        if (Status == STATUS_LOCK_NOT_GRANTED) {
            PostQuery = TRUE;
        } else if (Status != STATUS_SUCCESS) {
           
            RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> Could not acquire Fcb(%lx) %lx\n", Fcb, Status) );
            return Status;

        } else if (Fobx->UnicodeQueryTemplate.Buffer != NULL) {
            
            RxContext->QueryDirectory.InitialQuery = FALSE;
            RxConvertToSharedFcb( RxContext, Fcb );
        }
    } else {
        
        Status = RxAcquireExclusiveFcb( RxContext, Fcb );

        if (Status == STATUS_LOCK_NOT_GRANTED) {
            PostQuery = TRUE;
        } else if (Status != STATUS_SUCCESS) {
            RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> Could not acquire Fcb(%lx) %lx\n", Fcb, Status) );
            return Status;
        }
    }

    if (PostQuery) {
        
        RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> Enqueue to Fsp\n", 0) );
        Status = RxFsdPostRequest( RxContext );
        RxDbgTrace( -1, Dbg, ("RxQueryDirectory -> %08lx\n", Status ));

        return Status;
    }

    if (FlagOn( Fcb->FcbState, FCB_STATE_ORPHANED )) {
        
        RxReleaseFcb( RxContext, Fcb );
        return STATUS_FILE_CLOSED;
    }
    
    try {

        Status = STATUS_SUCCESS;

        //
        //  Determine where to start the scan.  Highest priority is given
        //  to the file index.  Lower priority is the restart flag.  If
        //  neither of these is specified, then the existing value in the
        //  Fobx is used.
        //

        if (!RxContext->QueryDirectory.IndexSpecified && RxContext->QueryDirectory.RestartScan) {
            RxContext->QueryDirectory.FileIndex = 0;
        }

        //
        //  If this is the first try then allocate a buffer for the file
        //  name.
        //

        if (RxContext->QueryDirectory.InitialQuery) {

            ASSERT( !FlagOn( Fobx->Flags, FOBX_FLAG_FREE_UNICODE ) );

            //
            //  If either:
            //
            //  - No name was specified
            //  - An empty name was specified
            //  - We received a '*'
            //  - The user specified the DOS equivolent of ????????.???
            //
            //  then match all names.
            //

            if ((FileName == NULL) ||
                (FileName->Length == 0) ||
                (FileName->Buffer == NULL) ||
                ((FileName->Length == sizeof( WCHAR )) &&
                 (FileName->Buffer[0] == L'*')) ||
                ((FileName->Length == 12 * sizeof( WCHAR )) &&
                 (RtlCompareMemory( FileName->Buffer,
                                    Rx8QMdot3QM,
                                    12*sizeof(WCHAR) )) == 12 * sizeof(WCHAR))) {

                Fobx->ContainsWildCards = TRUE;

                Fobx->UnicodeQueryTemplate.Buffer = RxStarForTemplate;
                Fobx->UnicodeQueryTemplate.Length = sizeof(WCHAR);
                Fobx->UnicodeQueryTemplate.MaximumLength = sizeof(WCHAR);

                SetFlag( Fobx->Flags, FOBX_FLAG_MATCH_ALL );

            } else {

                PVOID TemplateBuffer;

                //
                //  See if the name has wild cards & allocate template buffer
                //

                Fobx->ContainsWildCards = FsRtlDoesNameContainWildCards( FileName );

                TemplateBuffer = RxAllocatePoolWithTag( PagedPool, FileName->Length, RX_DIRCTL_POOLTAG );

                if (TemplateBuffer != NULL) {

                    //
                    //  Validate that the length is in sizeof(WCHAR) increments
                    //

                    if(FlagOn( FileName->Length, 1 )) {
                        Status = STATUS_INVALID_PARAMETER;
                    } else {
                       
                        RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> TplateBuffer = %08lx\n", TemplateBuffer) );
                        Fobx->UnicodeQueryTemplate.Buffer = TemplateBuffer;
                        Fobx->UnicodeQueryTemplate.Length = FileName->Length;
                        Fobx->UnicodeQueryTemplate.MaximumLength = FileName->Length;

                        RtlMoveMemory( Fobx->UnicodeQueryTemplate.Buffer,
                                       FileName->Buffer,FileName->Length );

                        RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> Template = %wZ\n", &Fobx->UnicodeQueryTemplate) );
                        SetFlag( Fobx->Flags, FOBX_FLAG_FREE_UNICODE );
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

            }

            if (Status == STATUS_SUCCESS) {
               
                //
                //  We convert to shared access before going to the net.
                //

                RxConvertToSharedFcb( RxContext, Fcb );
            }
        }

        if (Status == STATUS_SUCCESS) {
           
            RxLockUserBuffer( RxContext, Irp, IoModifyAccess, UserBufferLength );
            RxContext->Info.FileInformationClass = FileInformationClass;
            RxContext->Info.Buffer = RxMapUserBuffer( RxContext, Irp );
            RxContext->Info.LengthRemaining = UserBufferLength;

            if (RxContext->Info.Buffer != NULL) {

               //
               //  minirdr updates the fileindex
               //
               
               MINIRDR_CALL( Status,
                             RxContext,
                             Fcb->MRxDispatch,
                             MRxQueryDirectory,
                             (RxContext) ); 

               if (RxContext->PostRequest) {
                   RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> Enqueue to Fsp from minirdr\n", 0) );
                   Status = RxFsdPostRequest( RxContext );
               } else {
                   Irp->IoStatus.Information = UserBufferLength - RxContext->Info.LengthRemaining;
               }
           } else {
               if (Irp->MdlAddress != NULL) {
                   Status = STATUS_INSUFFICIENT_RESOURCES;
               } else {
                   Status = STATUS_INVALID_PARAMETER;
               }
           }
        }
    } finally {

        DebugUnwind( RxQueryDirectory );

        RxReleaseFcb( RxContext, Fcb );

        RxDbgTrace(-1, Dbg, ("RxQueryDirectory -> %08lx\n", Status));

    }

    return Status;
}

NTSTATUS
RxNotifyChangeDirectory ( 
    IN PRX_CONTEXT RxContext, 
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing or enqueuing the operation.

Arguments:

    RxContext - the RDBSS context for the operation

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    ULONG CompletionFilter;
    BOOLEAN WatchTree;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    TYPE_OF_OPEN TypeOfOpen = NodeType( Fcb );

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxNotifyChangeDirectory...\n", 0) );
    RxDbgTrace( 0, Dbg, (" Wait               = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT)) );
    RxDbgTrace( 0, Dbg, (" Irp                = %08lx\n", Irp) );
    RxDbgTrace( 0, Dbg, (" ->CompletionFilter = %08lx\n", IrpSp->Parameters.NotifyDirectory.CompletionFilter) );

    //
    //  Always set the wait flag in the Irp context for the original request.
    //

    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

    RxInitializeLowIoContext( RxContext, LOWIO_OP_NOTIFY_CHANGE_DIRECTORY, LowIoContext );

    //
    //  Reference our input parameter to make things easier
    //

    CompletionFilter = IrpSp->Parameters.NotifyDirectory.CompletionFilter;
    WatchTree = BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE );

    try {
        
        RxLockUserBuffer( RxContext,
                          Irp,
                          IoWriteAccess,
                          IrpSp->Parameters.NotifyDirectory.Length );

        LowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree = WatchTree;
        LowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter = CompletionFilter;

        LowIoContext->ParamsFor.NotifyChangeDirectory.NotificationBufferLength =
                  IrpSp->Parameters.NotifyDirectory.Length;

        if (Irp->MdlAddress != NULL) {
            LowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer =
                  MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

            if (LowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                Status = RxLowIoSubmit( RxContext,
                                        Irp,
                                        Fcb,
                                        RxLowIoNotifyChangeDirectoryCompletion );
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } finally {
        DebugUnwind( RxNotifyChangeDirectory );

        RxDbgTrace(-1, Dbg, ("RxNotifyChangeDirectory -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxLowIoNotifyChangeDirectoryCompletion( 
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the completion routine for NotifyChangeDirectory requests passed down
    to thr mini redirectors

Arguments:

    RxContext -- the RDBSS context associated with the operation

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PIRP Irp = RxContext->CurrentIrp;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoChangeNotifyDirectoryShellCompletion  entry  Status = %08lx\n", Status));

    Irp->IoStatus.Information = RxContext->InformationToReturn;
    Irp->IoStatus.Status = Status;

    RxDbgTrace(-1, Dbg, ("RxLowIoChangeNotifyDirectoryShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Rx called by the
    dispatch driver.

Author:

    Joe Linn     [JoeLinn]    12-sep-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

BOOLEAN
RxUninitializeCacheMap(
    IN OUT PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER TruncateSize
    );

#if DBG

//
//  this is just a dbg thing
//

BOOLEAN
RxFakeLockEnumerator (
    IN OUT PSRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    );

VOID
RxDumpSerializationQueue (
    PLIST_ENTRY SQ,
    PSZ TagText1,
    PSZ TagText2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDumpSerializationQueue)
#endif

#endif //  if DBG

VOID
RxCleanupPipeQueues (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

VOID
RxAdjustFileTimesAndSize ( 
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonCleanup)
#pragma alloc_text(PAGE, RxAdjustFileTimesAndSize)
#pragma alloc_text(PAGE, RxCleanupPipeQueues)
#pragma alloc_text(PAGE, RxUninitializeCacheMap)
#endif

NTSTATUS
RxCommonCleanup ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by
    both the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is
    closed.  This is different than the Close operation which is invoked
    when the last reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the
    file/directory after a user is done with it.  The Fcb/Dcb remains
    around (because MM still has the file object referenced) but is now
    available for another user to open (i.e., as far as the user is
    concerned the file object is now closed).  See close for a more complete
    description of what close does.

    Please see the discussion in openclos.txt.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    NODE_TYPE_CODE TypeOfOpen;
    NET_ROOT_TYPE NetRootType;

    PFCB Fcb;
    PFOBX Fobx;
    PNET_ROOT NetRoot;

    PSHARE_ACCESS ShareAccess = NULL;

    PLARGE_INTEGER TruncateSize = NULL;
    LARGE_INTEGER LocalTruncateSize;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN UninitializeCacheMap = FALSE;
    BOOLEAN LastUncleanOnGoodFcb = FALSE;
    BOOLEAN NeedPurge = FALSE;
    BOOLEAN NeedDelete = FALSE;

    BOOLEAN AcquiredFcb = FALSE;
    BOOLEAN AcquiredTableLock = FALSE;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx );  

    RxDbgTrace( +1, Dbg, ("RxCommonCleanup IrpC/Fobx/Fcb/FileObj = %08lx %08lx %08lx %08lx\n",
                           RxContext, Fobx, Fcb, FileObject ));
    RxLog(( "CommonCleanup %lx %lx %lx\n", RxContext, Fobx, Fcb ));

    //
    //  If this cleanup is for the case of directories opened for renames etc.,
    //  where there is no file object cleanup succeeds immediately.
    //

    if (!Fobx) {
        
        if (Fcb->UncleanCount > 0) {
           InterlockedDecrement( &Fcb->UncleanCount );
        }

        RxDbgTrace( -1, Dbg, ("Cleanup nullfobx open\n", 0) );
        return STATUS_SUCCESS;
    }

    //
    //  Cleanup applies to certain types of opens. If it is not one of those
    //  abort immediately.
    //

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_UNKNOWN) &&
        (TypeOfOpen != RDBSS_NTC_SPOOLFILE)) {

        RxLog(( "RxCC Invalid Open %lx %lx %lx\n", RxContext, Fobx, Fcb ));
        RxBugCheck( TypeOfOpen, 0, 0 );
    }

    //
    //  Ensure that the object has not been cleaned up before. This should
    //  never occur.
    //

    ASSERT( !FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE ) );

    RxMarkFobxOnCleanup( Fobx, &NeedPurge );

    //
    //  Acquire the FCB. In most cases no further resource acquisition is required
    //  to complete the cleanup operation. The only exceptions are when the file
    //  was initially opened with the DELETE_ON_CLOSE option. In such cases the
    //  FCB table lock of the associated NET_ROOT instance is required.
    //

    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
    if (Status != STATUS_SUCCESS) {
       RxDbgTrace( -1, Dbg, ("RxCommonCleanup Failed to acquire FCB -> %lx\n)", Status) );
       return Status;
    }

    AcquiredFcb = TRUE;
    Fobx->AssociatedFileObject = NULL;

    if (FlagOn( Fcb->FcbState, FCB_STATE_ORPHANED )) {
       
        ASSERT( Fcb->UncleanCount );
        InterlockedDecrement( &Fcb->UncleanCount );
        if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {
            Fcb->UncachedUncleanCount -= 1;
        }

        MINIRDR_CALL( Status, 
                      RxContext, 
                      Fcb->MRxDispatch,
                      MRxCleanupFobx,
                      (RxContext) );
        
        ASSERT( Fobx->SrvOpen->UncleanFobxCount );
        
        Fobx->SrvOpen->UncleanFobxCount -= 1;

        SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

        RxUninitializeCacheMap( RxContext, FileObject, NULL );

        RxReleaseFcb( RxContext, Fcb );

        return STATUS_SUCCESS;
    }

    NetRoot = (PNET_ROOT)Fcb->NetRoot;
    NetRootType = Fcb->NetRoot->Type ;

    if (FlagOn( Fobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE )) {
        SetFlag( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
    }

    RxCancelNotifyChangeDirectoryRequestsForFobx( Fobx );

    ShareAccess = &Fcb->ShareAccess;
    if (Fcb->UncleanCount == 1) {
        
        LastUncleanOnGoodFcb = TRUE;
    
        if (FlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE )) {
        
            //
            //  if we can't get it right way, drop the Fcb and acquire/acquire
            //  to preserve lock order. No one else can change the counts while we have
            //  the fcb lock; neither can a file become DELETE_ON_CLOSE or be opened via
            //  CommonCreate. If we are not deleting, get rid of the tablelock after we
            //  verify the count.
            //
    
            if (RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, FALSE )) {
                
                //
                // this is the fast way....hope it works
                //
    
                AcquiredTableLock = TRUE;
            
            } else {
                
                //
                //  Release the FCB and reqcquire the locks in the correct order.
                //  PrefixTableLock followed by the FCB.
                //
    
                AcquiredFcb = FALSE;
                RxReleaseFcb( RxContext, Fcb );
    
                (VOID)RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );
                AcquiredTableLock = TRUE;
    
                Status = RxAcquireExclusiveFcb( RxContext, Fcb );
                if (Status != STATUS_SUCCESS) {
                    AcquiredTableLock = FALSE;
                    RxReleaseFcbTableLock( &NetRoot->FcbTable );
                    RxDbgTrace( -1, Dbg, ("RxCommonCleanup Failed to acquire FCB -> %lx\n)", Status) );
                    return Status;
                }
                AcquiredFcb = TRUE;
            }
    
            //
            //  Retest for last cleanup since we may have dropped the fcb resource
            //
    
            if (Fcb->UncleanCount != 1) {
                RxReleaseFcbTableLock( &NetRoot->FcbTable );
                AcquiredTableLock = FALSE;
                NeedDelete = FALSE;
            } else {
                NeedDelete = TRUE;
            }
        }
    }

    try {
        
        switch (NetRootType) {
        case NET_ROOT_PIPE:
        case NET_ROOT_PRINT:
            
            //           
            //  If the file object corresponds to a pipe or spool file additional
            //  cleanup operations are required. This deals with the special
            //  serialization mechanism for pipes.
            //

            RxCleanupPipeQueues( RxContext, Fcb, Fobx );
            break;
        
        case NET_ROOT_DISK:
            
            switch (TypeOfOpen) {
            case RDBSS_NTC_STORAGE_TYPE_FILE :
            
                //
                //  If the file object corresponds to a disk file, remove any filelocks
                //  and update the associated file times and sizes.
                //
            
                SetFlag( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SAVEUNLOCKS ); 
            
                FsRtlFastUnlockAll( &Fcb->FileLock,
                                    FileObject,
                                    IoGetRequestorProcess( Irp ),
                                    RxContext );
            
                if (LowIoContext->ParamsFor.Locks.LockList != NULL) {
                    
                    RxDbgTrace( 0, Dbg, ("--->before init, locklist=%08lx\n", LowIoContext->ParamsFor.Locks.LockList) );
                    RxInitializeLowIoContext( RxContext, LOWIO_OP_UNLOCK_MULTIPLE, LowIoContext );
                    LowIoContext->ParamsFor.Locks.Flags = 0;     //  no flags
                    Status = RxLowIoLockControlShell( RxContext, Irp, Fcb );
                }
            
                RxAdjustFileTimesAndSize( RxContext, FileObject, Fcb, Fobx );
            
                //
                //  If the file object corresponds to a disk file/directory and this
                //  is the last cleanup call for the FCB additional processing is required.
                //

                if (LastUncleanOnGoodFcb) {
                   
                    try {

                        //
                        //  If the file object was marked DELETE_ON_CLOSE set the file size to
                        //  zero ( synchronizing with the paging resource)
                        //
                       
                        if (NeedDelete) {
                            
                            RxAcquirePagingIoResource( RxContext, Fcb );
            
                            Fcb->Header.FileSize.QuadPart = 0;
            
                            if (TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE) {
                                Fcb->Header.ValidDataLength.QuadPart = 0;
                            }
            
                            RxReleasePagingIoResource( RxContext, Fcb );
                        
                        } else {
                            
                            //
                            //  If the file object was not marked for deletion and it is not
                            //  a paging file ensure that the portion between the valid data
                            //  length and the file size is zero extended.
                            //
                          
                            if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE ) &&
                                (Fcb->Header.ValidDataLength.QuadPart < Fcb->Header.FileSize.QuadPart)) {

                                RxDbgTrace( 0, Dbg, ("---------->zeroextend!!!!!!!\n", 0) );
                                
                                MINIRDR_CALL( Status,
                                              RxContext,
                                              Fcb->MRxDispatch,
                                              MRxZeroExtend,
                                              (RxContext) );
            
                                Fcb->Header.ValidDataLength.QuadPart = Fcb->Header.FileSize.QuadPart;
                            }
                        }
            
                        //
                        //  If the file object was marked for truncation capture the
                        //  sizes for uninitializing the cache maps subsequently.
                        //
                       
                        if (FlagOn( Fcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE )) {
            
                            RxDbgTrace( 0, Dbg, ("truncate file allocation\n", 0) );
            
                            MINIRDR_CALL( Status,
                                          RxContext,
                                          Fcb->MRxDispatch,
                                          MRxTruncate,
                                          (RxContext) );
            
                            //
                            //  Setup to truncate the Cache Map because
                            //  this is the only way we have of trashing the
                            //  truncated pages.
                            //

                            LocalTruncateSize = Fcb->Header.FileSize;
                            TruncateSize = &LocalTruncateSize;
            
                            //
                            //  Mark the Fcb as having now been truncated, just
                            //  in case we have to reprocess this later.
                            //
            
                            ClearFlag( Fcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE );
                        }
            
                    } except (CATCH_EXPECTED_EXCEPTIONS) {
            
                        DbgPrint("!!! Handling Exceptions\n");
                        NOTHING;
                    }
                }
            
                //
                //  Purging can be done now if this FCB does not support collapsed opens
                //

                if (!NeedPurge) {
                    NeedPurge = (LastUncleanOnGoodFcb &&
                                 (NeedDelete ||
                                  !FlagOn( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED )));
                
                } else if (!LastUncleanOnGoodFcb) {
                    NeedPurge = FALSE;
                }
            
                UninitializeCacheMap = TRUE;
                break;
            
            case RDBSS_NTC_STORAGE_TYPE_DIRECTORY :
            case RDBSS_NTC_STORAGE_TYPE_UNKNOWN :
            default:
                break;
            }
            break; 
        
        default:
            break;
        }

        // 
        //  We've just finished everything associated with an unclean
        //  fcb so now decrement the unclean count before releasing
        //  the resource.
        //

        ASSERT( Fcb->UncleanCount );
        InterlockedDecrement( &Fcb->UncleanCount );

        if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {
            Fcb->UncachedUncleanCount -= 1;
        }

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxCleanupFobx,
                      (RxContext) );

        ASSERT( Fobx->SrvOpen->UncleanFobxCount );
        Fobx->SrvOpen->UncleanFobxCount -= 1;

        //
        //  If this was the last cached open, and there are open
        //  non-cached handles, attempt a flush and purge operation
        //  to avoid cache coherency overhead from these non-cached
        //  handles later.  We ignore any I/O errors from the flush.
        //

        if (Fcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL) {
            
            RxLog(( "Cleanup Flush %lx\n", RxContext ));
            RxFlushFcbInSystemCache( Fcb, TRUE );
        }

        if (!FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            (Fcb->UncachedUncleanCount != 0) &&
            (Fcb->UncachedUncleanCount == Fcb->UncleanCount) &&
            (Fcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL)) {

            RxLog(("Cleanup Flush 1111 %lx\n",RxContext));
            RxPurgeFcbInSystemCache( Fcb,
                                     NULL,
                                     0,
                                     FALSE,
                                     TRUE );
        }

        //
        //  do we need a flush?
        //

        if (!NeedDelete && NeedPurge) {
            RxDbgTrace( 0, Dbg, ("CleanupPurge:CCFlush\n", 0 ));

            RxLog(( "Cleanup Flush 2222 %lx\n", RxContext ));
            RxFlushFcbInSystemCache( Fcb, TRUE );
        }

        //
        //  cleanup the cache map to get rid of pages that are no longer part
        //  of the file. amazingly, this works even if we didn't init the Cachemap!!!!!
        //

        if (UninitializeCacheMap) {

            RxLog(( "Cleanup Flush 3333 %lx\n", RxContext ));
            SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );
            RxUninitializeCacheMap( RxContext, FileObject, TruncateSize );
        }

        //
        //  finish up a delete...we have to purge because MM is holding the file open....
        //  just for the record, NeedPurge is set for files and clear for directories......
        //

        if (NeedDelete || NeedPurge) {

            RxLog(("Cleanup Flush 4444 %lx\n",RxContext));

            RxPurgeFcbInSystemCache( Fcb,
                                     NULL,
                                     0,
                                     FALSE,
                                     !NeedDelete );

            if (NeedDelete) {
                RxRemoveNameNetFcb( Fcb );
                RxReleaseFcbTableLock( &NetRoot->FcbTable );
                AcquiredTableLock = FALSE;
            }
        }

        //
        //  The Close Call and the Cleanup Call may be far apart. The share access
        //  must be cleaned up if the file was mapped through this File Object.
        //

        if ((ShareAccess != NULL) &&
            (NetRootType == NET_ROOT_DISK)) {
            
            ASSERT( NetRootType == NET_ROOT_DISK );
            RxRemoveShareAccess( FileObject, ShareAccess, "Cleanup the Share access", "ClnUpShr" );
        }

        //
        //  A local filesystem would do this..........
        //  If the NET_ROOT is on a removeable media, flush the volume.  We do
        //  this in lieu of write through for removeable media for
        //  performance considerations.  That is, data is guaranteed
        //  to be out when NtCloseFile returns.
        //  The file needs to  be flushed
        //

        //
        // The cleanup for this file object has been successfully completed at
        // this point.
        //

        SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

        if (AcquiredFcb) {
            AcquiredFcb = FALSE;
            RxReleaseFcb( RxContext, Fcb );
        }

        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( RxCommonCleanup );

        if (AcquiredFcb) {
           RxReleaseFcb( RxContext, Fcb );
        }

        if (AcquiredTableLock) {
            RxReleaseFcbTableLock( &NetRoot->FcbTable );
        }

        IF_DEBUG {
            if (AbnormalTermination()) {
                RxDbgTrace(-1, Dbg, ("RxCommonCleanup -> Abnormal Termination %08lx\n", Status));
            } else {
                RxDbgTrace(-1, Dbg, ("RxCommonCleanup -> %08lx\n", Status));
            }
        }
    }

    return Status;
}

VOID
RxAdjustFileTimesAndSize ( 
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    This routine is used to adjust the times and the filesize on a cleanup
    or a flush.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    BOOLEAN UpdateFileSize;
    BOOLEAN UpdateLastWriteTime;
    BOOLEAN UpdateLastAccessTime;
    BOOLEAN UpdateLastChangeTime;

    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    //
    //  if there's no cachemap then we don't have to send because the guy is
    //  tracking everything on the other end.
    //  LOCAL.MINI for a localminiFS we would still have to do this; so the answer to this question
    //  (whether to do it or not) should be exposed in the fcb/fobx
    //

    if (FileObject->PrivateCacheMap == NULL)  return;

    KeQuerySystemTime( &CurrentTime );

    //
    //  Note that we HAVE to use BooleanFlagOn() here because
    //  FO_FILE_SIZE_CHANGED > 0x80 (i.e., not in the first byte).
    //

    UpdateFileSize = BooleanFlagOn( FileObject->Flags, FO_FILE_SIZE_CHANGED );

    UpdateLastWriteTime = FlagOn( FileObject->Flags, FO_FILE_MODIFIED) &&
                          !FlagOn( Fobx->Flags, FOBX_FLAG_USER_SET_LAST_WRITE );

    UpdateLastChangeTime = FlagOn( FileObject->Flags, FO_FILE_MODIFIED ) &&
                          !FlagOn( Fobx->Flags, FOBX_FLAG_USER_SET_LAST_CHANGE );

    UpdateLastAccessTime = (UpdateLastWriteTime ||
                            (FlagOn( FileObject->Flags, FO_FILE_FAST_IO_READ ) &&
                             !FlagOn( Fobx->Flags, FOBX_FLAG_USER_SET_LAST_ACCESS )));

    if (UpdateFileSize ||
        UpdateLastWriteTime ||
        UpdateLastChangeTime ||
        UpdateLastAccessTime) {

        BOOLEAN DoTheTimeUpdate = FALSE;

        FILE_BASIC_INFORMATION       BasicInformation;
        FILE_END_OF_FILE_INFORMATION EofInformation;

        RxDbgTrace( 0, Dbg, ("Update Time and/or file size on File\n", 0) );
        RtlZeroMemory( &BasicInformation, sizeof( BasicInformation ) );

        try {     //  for finally
            try {   //  for exceptions

                if (UpdateLastWriteTime) {

                    //
                    //  Update its time of last write
                    //

                    DoTheTimeUpdate = TRUE;
                    Fcb->LastWriteTime = CurrentTime;
                    BasicInformation.LastWriteTime = CurrentTime;
                }

                if (UpdateLastChangeTime) {

                    //
                    //  Update its time of last write
                    //

                    DoTheTimeUpdate = TRUE;
                    BasicInformation.ChangeTime = Fcb->LastChangeTime;
                }

                if (UpdateLastAccessTime) {

                    DoTheTimeUpdate = TRUE;
                    Fcb->LastAccessTime = CurrentTime;
                    BasicInformation.LastAccessTime = CurrentTime;
                }

                if (DoTheTimeUpdate) {
                    
                    NTSTATUS Status;  //  if it doesn't work.....sigh
                    
                    RxContext->Info.FileInformationClass = (FileBasicInformation);
                    RxContext->Info.Buffer = &BasicInformation;
                    RxContext->Info.Length = sizeof(BasicInformation);
                    
                    MINIRDR_CALL( Status,
                                  RxContext,
                                  Fcb->MRxDispatch,
                                  MRxSetFileInfoAtCleanup,
                                  (RxContext) );
                }

                if (UpdateFileSize) {
                    NTSTATUS Status;  //  if it doesn't work.....sigh
                    
                    EofInformation.EndOfFile = Fcb->Header.FileSize;
                    RxContext->Info.FileInformationClass = FileEndOfFileInformation;
                    RxContext->Info.Buffer = &EofInformation;
                    RxContext->Info.Length = sizeof( EofInformation );
                    
                    MINIRDR_CALL( Status,
                                  RxContext,
                                  Fcb->MRxDispatch,
                                  MRxSetFileInfoAtCleanup,
                                  (RxContext) );
                }

            } except( CATCH_EXPECTED_EXCEPTIONS ) {
                NOTHING;
            }
        } finally {
            NOTHING;
        }
    }
}


#define RxMoveAllButFirstToAnotherList(List1,List2) { \
        PLIST_ENTRY FrontListEntry = (List1)->Flink;       \
        if (FrontListEntry->Flink == (List1)) {            \
            (List2)->Flink = (List2)->Blink = (List2);     \
        } else {                                           \
            (List2)->Blink = (List1)->Blink;               \
            (List2)->Blink->Flink = (List2);               \
            (List1)->Blink = FrontListEntry;               \
            (List2)->Flink = FrontListEntry->Flink;        \
            FrontListEntry->Flink = (List1);               \
            (List2)->Flink->Blink = (List2);               \
        }                                                  \
}

#if DBG
PSZ RxDSQTagText[FOBX_NUMBER_OF_SERIALIZATION_QUEUES] = {"read","write"};
VOID
RxDumpSerializationQueue(
    PLIST_ENTRY SQ,
    PSZ TagText1,
    PSZ TagText2
    )
{
    PLIST_ENTRY ListEntry;
    
    PAGED_CODE();

    if (IsListEmpty( SQ )) {
        RxDbgTrace( 0, Dbg, ("RxDumpSerializationQueue %s%s is empty\n", TagText1, TagText2) );
        return;
    }

    RxDbgTrace( 0, Dbg, ("RxDumpSerializationQueue %s%s:\n", TagText1, TagText2) );
    for (ListEntry=SQ->Flink;
         ListEntry!=SQ;
         ListEntry=ListEntry->Flink) {
        
        //
        //  print out the contexts and the major op for validation
        //

        PRX_CONTEXT RxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, RxContextSerializationQLinks );
        RxDbgTrace( 0, Dbg, ("        rxc=%08lx op=%02lx\n", RxContext, RxContext->MajorFunction) );
    }
}
#else
#define RxDumpSerializationQueue(___r,___t12,___t13) {NOTHING;}
#endif

VOID
RxCleanupPipeQueues (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
{
    LIST_ENTRY SecondaryBlockedQs[FOBX_NUMBER_OF_SERIALIZATION_QUEUES];
    PLIST_ENTRY PrimaryBlockedQs = &Fobx->Specific.NamedPipe.ReadSerializationQueue;
    ULONG i;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCleanupPipeQueues \n"));

    //
    //  for pipes there are two sources of unhappiness...........
    //  first, we have to get rid of any blocked operations.
    //  second, if there are blocking operations that have already gone by then we have to send the
    //  close smb early so that the server will, in turn, complete the outstanding
    //

    ExAcquireFastMutexUnsafe(&RxContextPerFileSerializationMutex);

    for (i=0; i < FOBX_NUMBER_OF_SERIALIZATION_QUEUES; i++) {
        
        RxDumpSerializationQueue( &PrimaryBlockedQs[i], RxDSQTagText[i], "Primary" );
        
        if (!IsListEmpty( &PrimaryBlockedQs[i] )) {
            
            RxMoveAllButFirstToAnotherList( &PrimaryBlockedQs[i], &SecondaryBlockedQs[i] );
            
            RxDumpSerializationQueue( &PrimaryBlockedQs[i], RxDSQTagText[i], "Primary" );
            RxDumpSerializationQueue( &SecondaryBlockedQs[i], RxDSQTagText[i], "Secondary" );
        } else {
            InitializeListHead( &SecondaryBlockedQs[i] );
        }
    }

    ExReleaseFastMutexUnsafe(&RxContextPerFileSerializationMutex);

    for (i=0; i < FOBX_NUMBER_OF_SERIALIZATION_QUEUES; i++) {
        
        for (; !IsListEmpty( &SecondaryBlockedQs[i] );) {
            
            PLIST_ENTRY FrontListEntry = (&SecondaryBlockedQs[i])->Flink;
            PRX_CONTEXT FrontRxContext = CONTAINING_RECORD( FrontListEntry, RX_CONTEXT, RxContextSerializationQLinks );
            
            RemoveEntryList( FrontListEntry );

            FrontRxContext->RxContextSerializationQLinks.Flink = NULL;
            FrontRxContext->RxContextSerializationQLinks.Blink = NULL;

            if (!FlagOn( FrontRxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
                
                RxDbgTrace( 0, Dbg, ("  unblocking %08lx\n",FrontRxContext) );
                RxContext->StoredStatus = STATUS_PIPE_CLOSING;
                RxSignalSynchronousWaiter( FrontRxContext );
            } else {
                RxDbgTrace( 0, Dbg, ("  completing %08lx\n",FrontRxContext) );
                RxCompleteAsynchronousRequest( FrontRxContext, STATUS_PIPE_CLOSING );
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCleanupPipeQueues exit\n"));
    return;
}

BOOLEAN
RxFakeLockEnumerator (
    IN OUT PSRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    )
/*++

Routine Description:

    THIS ROUTINE IS A FAKE THAT IS JUST USED FOR TESTING PURPOSES!

    This routine is called from a minirdr to enumerate the filelocks on an FCB; it gets
    one lock on each call. currently, we just pass thru to the fsrtl routine which is very funky
    because it keeps the enumeration state internally; as a result, only one enumeration can be in progress
    at any time. we can change over to something better if it's ever required.


Arguments:

    SrvOpen - a srvopen on the fcb to be enumerated.

    ContinuationHandle - a handle passed back and forth representing the state of the enumeration.
                         if a NULL is passed in, then we are to start at the beginning.

    FileOffset,LockRange,IsLockExclusive - the description of the returned lock

Return Value:

    a BOOLEAN. FALSE means you've reached the end of the list; TRUE means the returned lock data is valid

--*/
{
    ULONG LockNumber;

    LockNumber = PtrToUlong( *ContinuationHandle );
    if (LockNumber >= 12) {
        return FALSE;
    }
    LockNumber += 1;
    RxDbgTrace( 0, Dbg, ("Rxlockenum %08lx\n", LockNumber ) );
    FileOffset->QuadPart = LockNumber;
    LockRange->QuadPart = 1;
    *IsLockExclusive = (LockNumber & 0x4) == 0;
    *ContinuationHandle = LongToPtr( LockNumber );
    return TRUE;
}

BOOLEAN
RxUninitializeCacheMap(
    IN OUT PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER TruncateSize
    )
/*++

Routine Description:

    This routine is a wrapper for CcUninitializeCacheMap.

Arguments:

    IN PFILE_OBJECT FileObject - Supplies the file object for the file to purge.
    IN PLARGE_INTEGER TruncateSize - Specifies the new size for the file.


Return Value:

    BOOLEAN - TRUE if file has been immediately purged, FALSE if we had to wait.

Note:
    The file must be locked exclusively before calling this routine.


--*/
{
    BOOLEAN CacheReturnValue;
    CACHE_UNINITIALIZE_EVENT PurgeCompleteEvent;
    PFCB Fcb = FileObject->FsContext;
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT( NodeTypeIsFcb( Fcb ) );

    //
    //  Make sure that this thread owns the FCB.
    //

    ASSERT( RxIsFcbAcquiredExclusive ( Fcb ) );

    //
    //  Now uninitialize the cache managers own file object.  This is
    //  done basically simply to allow us to wait until the cache purge
    //  is complete.
    //

    KeInitializeEvent( &PurgeCompleteEvent.Event, SynchronizationEvent, FALSE );

    CacheReturnValue = CcUninitializeCacheMap( FileObject, TruncateSize, &PurgeCompleteEvent );

    //
    //  Release the lock on the FCB that our caller applied.
    //

    RxReleaseFcb( RxContext, Fcb );

    //
    //  Now wait for the cache manager to finish purging the file.
    //

    KeWaitForSingleObject( &PurgeCompleteEvent.Event,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    //
    //  Re-acquire the FCB lock once we've waited for the
    //  cache manager to finish the uninitialize.
    //

    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
    ASSERT( Status == STATUS_SUCCESS );
    return CacheReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Ea.c

Abstract:

    This module implements the EA, security and quota  routines for Rx called by
    the dispatch driver.

Author:

    Joe Linn      [JoeLi]  1-Jan-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonQueryEa)
#pragma alloc_text(PAGE, RxCommonSetEa)
#pragma alloc_text(PAGE, RxCommonQuerySecurity)
#pragma alloc_text(PAGE, RxCommonSetSecurity)
#endif

typedef
NTSTATUS
(NTAPI *PRX_MISC_OP_ROUTINE) (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxpCommonMiscOp (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PRX_MISC_OP_ROUTINE MiscOpRoutine
    )
/*++

Routine Description:

    Main stub that all the common routines below use - this does the common work
    such as acquiring the fcb, parameter validation and posting if necc.

Arguments:

    RxContext -  the rxcontext
    
    Fcb - the fcb being used
    
    MiscOpRoutine - The callback that does the real work

Return Value:


Notes:

--*/

{
    NTSTATUS Status;

    NODE_TYPE_CODE TypeOfOpen = NodeType( Fcb );

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace( -1, Dbg, ("RxpCommonMiscOp -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )) {

        RxDbgTrace( 0, Dbg, ("RxpCommonMiscOp:  Set Ea must be waitable....posting\n", 0) );

        Status = RxFsdPostRequest( RxContext );

        RxDbgTrace(-1, Dbg, ("RxpCommonMiscOp -> %08lx\n", Status ));

        return Status;
    }

    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
    
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( -1, Dbg, ("RxpCommonMiscOp -> Error Acquiring Fcb %08lx\n", Status) );
        return Status;
    }

    try {

        Status = (*MiscOpRoutine)( RxContext, Irp, Fcb );
    
    } finally {

        DebugUnwind( *MiscOpRoutine );

        RxReleaseFcb( RxContext, Fcb );

        RxDbgTrace( -1, Dbg, ("RxpCommonMiscOp -> %08lx\n", Status ));
    }

    return Status;
}

NTSTATUS
RxpCommonQuerySecurity (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    Callback that implements the query security call

Arguments:

    RxContext -
    
    Irp -  
    
    Fcb -


Return Value:


Note:


--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PUCHAR Buffer;
    ULONG UserBufferLength;

    UserBufferLength = IrpSp->Parameters.QuerySecurity.Length;

    RxContext->QuerySecurity.SecurityInformation = IrpSp->Parameters.QuerySecurity.SecurityInformation;

    RxLockUserBuffer( RxContext,
                      Irp,
                      IoModifyAccess,
                      UserBufferLength );

    //
    //  Lock before map so that map will get userbuffer instead of assoc buffer
    //

    Buffer = RxMapUserBuffer( RxContext, Irp );
    RxDbgTrace( 0, Dbg, ("RxCommonQuerySecurity -> Buffer = %08lx\n", Buffer) );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        
        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxQuerySdInfo,
                      (RxContext) );

        Irp->IoStatus.Information = RxContext->InformationToReturn;
    
    } else {
        
        Irp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonQuerySecurity ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for querying File ea called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

        STATUS_NO_MORE_EAS(warning):

            If the index of the last Ea + 1 == EaIndex.

        STATUS_NONEXISTENT_EA_ENTRY(error):

            EaIndex > index of last Ea + 1.

        STATUS_EAS_NOT_SUPPORTED(error):

            Attempt to do an operation to a server that did not negotiate
            "KNOWS_EAS".

        STATUS_BUFFER_OVERFLOW(warning):

            User did not supply an EaList, at least one but not all Eas
            fit in the buffer.

        STATUS_BUFFER_TOO_SMALL(error):

            Could not fit a single Ea in the buffer.

            User supplied an EaList and not all Eas fit in the buffer.

        STATUS_NO_EAS_ON_FILE(error):
            There were no eas on the file.

        STATUS_SUCCESS:

            All Eas fit in the buffer.


        If STATUS_BUFFER_TOO_SMALL is returned then IoStatus.Information is set
        to 0.

Note:

    This code assumes that this is a buffered I/O operation.  If it is ever
    implemented as a non buffered operation, then we have to put code to map
    in the users buffer here.

--*/
{
    NTSTATUS Status;

    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    
    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonQuerySecurity...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", Irp ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer        = %08lx\n", Irp->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", IrpSp->Parameters.QuerySecurity.Length ));
    RxDbgTrace( 0, Dbg, (" ->SecurityInfo      = %08lx\n", IrpSp->Parameters.QuerySecurity.SecurityInformation ));

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace( -1, Dbg, ("RxpCommonQuerySecurity -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    Status = RxpCommonMiscOp( RxContext,
                              Irp,
                              Fcb,
                              RxpCommonQuerySecurity );

    RxDbgTrace(-1, Dbg, ("RxCommonQuerySecurity -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonSetSecurity (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    Callback that implements the set security call

Arguments:

    RxContext -
    
    Irp -  
    
    Fcb -


Return Value:


Note:


--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    RxContext->SetSecurity.SecurityInformation = IrpSp->Parameters.SetSecurity.SecurityInformation;

    RxContext->SetSecurity.SecurityDescriptor = IrpSp->Parameters.SetSecurity.SecurityDescriptor;

    RxDbgTrace(0, Dbg, ("RxCommonSetSecurity -> Descr/Info = %08lx/%08lx\n",
                                RxContext->SetSecurity.SecurityDescriptor,
                                RxContext->SetSecurity.SecurityInformation ));

    MINIRDR_CALL( Status,
                  RxContext,
                  Fcb->MRxDispatch,
                  MRxSetSdInfo,
                  (RxContext) );

    return Status;
}

NTSTATUS
RxCommonSetSecurity ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the common Set Ea File Api called by the
    the Fsd and Fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The appropriate status for the Irp

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace( -1, Dbg, ("RxpCommonSetSecurity -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }


    RxDbgTrace(+1, Dbg, ("RxCommonSetSecurity...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", RxContext->CurrentIrp ));

    Status = RxpCommonMiscOp( RxContext, RxContext->CurrentIrp, Fcb, RxpCommonSetSecurity );

    RxDbgTrace(-1, Dbg, ("RxCommonSetSecurity -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonQueryEa (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    Callback that implements the query ea call

Arguments:

    RxContext -
    
    Irp -  
    
    Fcb -


Return Value:


Note:


--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PUCHAR  Buffer;
    ULONG   UserBufferLength;

    UserBufferLength  = IrpSp->Parameters.QueryEa.Length;

    RxContext->QueryEa.UserEaList        = IrpSp->Parameters.QueryEa.EaList;
    RxContext->QueryEa.UserEaListLength  = IrpSp->Parameters.QueryEa.EaListLength;
    RxContext->QueryEa.UserEaIndex       = IrpSp->Parameters.QueryEa.EaIndex;
    RxContext->QueryEa.RestartScan       = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
    RxContext->QueryEa.ReturnSingleEntry = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
    RxContext->QueryEa.IndexSpecified    = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);


    RxLockUserBuffer( RxContext, Irp, IoModifyAccess, UserBufferLength );

    //
    //  lock before map so that map will get userbuffer instead of assoc buffer
    //

    Buffer = RxMapUserBuffer( RxContext, Irp );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        
        RxDbgTrace( 0, Dbg, ("RxCommonQueryEa -> Buffer = %08lx\n", Buffer ));

        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxQueryEaInfo,
                      (RxContext) );

        //
        //  In addition to manipulating the LengthRemaining and filling the buffer,
        //  the minirdr also updates the fileindex (Fobx->OffsetOfNextEaToReturn)
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryEa.Length - RxContext->Info.LengthRemaining;
    
    } else {
        
        Irp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonQueryEa ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )

/*++

Routine Description:

    This is the common routine for querying File ea called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

        STATUS_NO_MORE_EAS(warning):

            If the index of the last Ea + 1 == EaIndex.

        STATUS_NONEXISTENT_EA_ENTRY(error):

            EaIndex > index of last Ea + 1.

        STATUS_EAS_NOT_SUPPORTED(error):

            Attempt to do an operation to a server that did not negotiate
            "KNOWS_EAS".

        STATUS_BUFFER_OVERFLOW(warning):

            User did not supply an EaList, at least one but not all Eas
            fit in the buffer.

        STATUS_BUFFER_TOO_SMALL(error):

            Could not fit a single Ea in the buffer.

            User supplied an EaList and not all Eas fit in the buffer.

        STATUS_NO_EAS_ON_FILE(error):
            There were no eas on the file.

        STATUS_SUCCESS:

            All Eas fit in the buffer.


        If STATUS_BUFFER_TOO_SMALL is returned then IoStatus.Information is set
        to 0.

Note:

    This code assumes that this is a buffered I/O operation.  If it is ever
    implemented as a non buffered operation, then we have to put code to map
    in the users buffer here.


--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;
    
    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCommonQueryEa...\n", 0 ));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", Irp ));
    RxDbgTrace( 0, Dbg, (" ->SystemBuffer      = %08lx\n", Irp->AssociatedIrp.SystemBuffer ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer        = %08lx\n", Irp->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", IrpSp->Parameters.QueryEa.Length ));
    RxDbgTrace( 0, Dbg, (" ->EaList            = %08lx\n", IrpSp->Parameters.QueryEa.EaList ));
    RxDbgTrace( 0, Dbg, (" ->EaListLength      = %08lx\n", IrpSp->Parameters.QueryEa.EaListLength ));
    RxDbgTrace( 0, Dbg, (" ->EaIndex           = %08lx\n", IrpSp->Parameters.QueryEa.EaIndex ));
    RxDbgTrace( 0, Dbg, (" ->RestartScan       = %08lx\n", FlagOn( IrpSp->Flags, SL_RESTART_SCAN )));
    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )));
    RxDbgTrace( 0, Dbg, (" ->IndexSpecified    = %08lx\n", FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED )));

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );


    Status = RxpCommonMiscOp( RxContext,
                              Irp,
                              Fcb,
                              RxpCommonQueryEa );

    RxDbgTrace(-1, Dbg, ("RxCommonQueryEa -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonSetEa (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    Callback that implements the set ea call

Arguments:

    RxContext -
    
    Irp -  
    
    Fcb -


Return Value:


Note:


--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    
    PUCHAR Buffer;
    ULONG UserBufferLength;

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = IrpSp->Parameters.SetEa.Length;

    SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
    
    RxLockUserBuffer( RxContext,
                      Irp,
                      IoModifyAccess,
                      UserBufferLength );

    //
    //  unless we lock first, rxmap actually gets the systembuffer!
    //

    Buffer = RxMapUserBuffer( RxContext, Irp );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        
        ULONG ErrorOffset;

        RxDbgTrace( 0, Dbg, ("RxCommonSetEa -> Buffer = %08lx\n", Buffer ));

        //
        //  Check the validity of the buffer with the new eas.
        //

        Status = IoCheckEaBufferValidity( (PFILE_FULL_EA_INFORMATION)Buffer,
                                          UserBufferLength,
                                          &ErrorOffset );

        if (!NT_SUCCESS( Status )) {
            
            Irp->IoStatus.Information = ErrorOffset;
            return Status;

        }
    
    } else {
        
        Irp->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Irp->IoStatus.Information = 0;
    RxContext->Info.Buffer = Buffer;
    RxContext->Info.Length = UserBufferLength;

    MINIRDR_CALL( Status, 
                  RxContext,
                  Fcb->MRxDispatch,
                  MRxSetEaInfo,
                  (RxContext) );

    return Status;
}


NTSTATUS
RxCommonSetEa ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )

/*++

Routine Description:

    This routine implements the common Set Ea File Api called by the
    the Fsd and Fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The appropriate status for the Irp

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCommonSetEa...\n", 0) );
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", Irp ));
    RxDbgTrace( 0, Dbg, (" ->SystemBuffer      = %08lx\n", Irp->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", IrpSp->Parameters.SetEa.Length ));


    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace( -1, Dbg, ("RxpCommonSetSecurity -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }


    Status = RxpCommonMiscOp( RxContext, Irp, Fcb, RxpCommonSetEa );

    RxDbgTrace(-1, Dbg, ("RxCommonSetEa -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonQueryQuotaInformation (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    Callback that implements the query quota call

Arguments:

    RxContext -
    
    Irp -  
    
    Fcb -


Return Value:


Note:


--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PUCHAR Buffer;
    ULONG UserBufferLength;

    UserBufferLength = IrpSp->Parameters.QueryQuota.Length;

    RxContext->QueryQuota.SidList = IrpSp->Parameters.QueryQuota.SidList;
    RxContext->QueryQuota.SidListLength = IrpSp->Parameters.QueryQuota.SidListLength;
    RxContext->QueryQuota.StartSid = IrpSp->Parameters.QueryQuota.StartSid;
    RxContext->QueryQuota.Length = IrpSp->Parameters.QueryQuota.Length;

    RxContext->QueryQuota.RestartScan = BooleanFlagOn( IrpSp->Flags, SL_RESTART_SCAN );
    RxContext->QueryQuota.ReturnSingleEntry = BooleanFlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY );
    RxContext->QueryQuota.IndexSpecified = BooleanFlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED );


    RxLockUserBuffer( RxContext,
                      Irp,
                      IoModifyAccess,
                      UserBufferLength );

    //
    //  lock before map so that map will get userbuffer instead of assoc buffer
    //

    Buffer = RxMapUserBuffer( RxContext, Irp );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        
        RxDbgTrace( 0, Dbg, ("RxCommonQueryQuota -> Buffer = %08lx\n", Buffer) );

        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxQueryQuotaInfo,
                      (RxContext) );

        Irp->IoStatus.Information = RxContext->Info.LengthRemaining;

    } else {
        
        Irp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonQueryQuotaInformation (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    Main entry point for IRP_MJ_QUERY_QUOTA_INFORMATION

Arguments:

    RxContext -
    

Return Value:


Note:


--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCommonQueryQueryQuotaInformation...\n", 0) );
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", Irp ));
    RxDbgTrace( 0, Dbg, (" ->SystemBuffer      = %08lx\n", Irp->AssociatedIrp.SystemBuffer ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer        = %08lx\n", Irp->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", IrpSp->Parameters.QueryQuota.Length ));
    RxDbgTrace( 0, Dbg, (" ->StartSid          = %08lx\n", IrpSp->Parameters.QueryQuota.StartSid ));
    RxDbgTrace( 0, Dbg, (" ->SidList           = %08lx\n", IrpSp->Parameters.QueryQuota.SidList ));
    RxDbgTrace( 0, Dbg, (" ->SidListLength     = %08lx\n", IrpSp->Parameters.QueryQuota.SidListLength ));
    RxDbgTrace( 0, Dbg, (" ->RestartScan       = %08lx\n", FlagOn( IrpSp->Flags, SL_RESTART_SCAN )));
    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )));
    RxDbgTrace( 0, Dbg, (" ->IndexSpecified    = %08lx\n", FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED )));

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace( -1, Dbg, ("RxpCommonQueryQuotaInformation -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }

    Status = RxpCommonMiscOp( RxContext, Irp, Fcb, RxpCommonQueryQuotaInformation );

    return Status;
}

NTSTATUS
RxpCommonSetQuotaInformation (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    Callback that implements the set quota call

Arguments:

    RxContext -
    
    Irp -  
    
    Fcb -


Return Value:


Note:


--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PUCHAR Buffer;
    ULONG UserBufferLength;

    PAGED_CODE();

    UserBufferLength = IrpSp->Parameters.SetQuota.Length;

    RxLockUserBuffer( RxContext,
                      Irp,
                      IoModifyAccess,
                      UserBufferLength );

    //
    //  lock before map so that map will get userbuffer instead of assoc buffer
    //

    Buffer = RxMapUserBuffer( RxContext, Irp );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        
        RxDbgTrace(0, Dbg, ("RxCommonQueryQuota -> Buffer = %08lx\n", Buffer));

        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxSetQuotaInfo,
                      (RxContext) );
    } else {
        
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonSetQuotaInformation (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    Main entry point for IRP_MJ_SET_QUOTA_INFORMATION

Arguments:

    RxContext -
    

Return Value:


Note:


--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCommonSetQuotaInformation...\n", 0) );
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", Irp ));

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace( -1, Dbg, ("RxpCommonSetQuotaInformation -> %08lx\n", STATUS_INVALID_PARAMETER) );

        return STATUS_INVALID_PARAMETER;
    }


    Status = RxpCommonMiscOp( RxContext, Irp, Fcb, RxpCommonSetQuotaInformation );

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Rx called by
    the dispatch driver.

Author:

    Joe Linn     [JoeLinn]   5-oct-94

Revision History:

    Balan Sethu Raman 15-May-95 --  reworked to fit in pipe FSCTL's

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_FILEINFO)

NTSTATUS
RxQueryBasicInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
RxQueryStandardInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx,
    IN OUT PFILE_STANDARD_INFORMATION Buffer
    );

NTSTATUS
RxQueryInternalInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer
    );

NTSTATUS
RxQueryEaInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer
    );

NTSTATUS
RxQueryPositionInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_POSITION_INFORMATION Buffer
    );

NTSTATUS
RxQueryNameInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx,
    IN OUT PFILE_NAME_INFORMATION Buffer
    );

NTSTATUS
RxQueryAlternateNameInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_NAME_INFORMATION Buffer
    );

NTSTATUS
RxQueryCompressedInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer
    );

NTSTATUS
RxQueryPipeInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx,
    IN OUT PVOID PipeInformation
    );

NTSTATUS
RxSetBasicInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxSetDispositionInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxSetRenameInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxSetPositionInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxSetAllocationInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxSetEndOfFileInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxSetPipeInfo(
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxSetSimpleInfo(
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonQueryInformation)
#pragma alloc_text(PAGE, RxCommonSetInformation)
#pragma alloc_text(PAGE, RxSetAllocationInfo)
#pragma alloc_text(PAGE, RxQueryBasicInfo)
#pragma alloc_text(PAGE, RxQueryEaInfo)
#pragma alloc_text(PAGE, RxQueryInternalInfo)
#pragma alloc_text(PAGE, RxQueryNameInfo)
#pragma alloc_text(PAGE, RxQueryAlternateNameInfo)
#pragma alloc_text(PAGE, RxQueryPositionInfo)
#pragma alloc_text(PAGE, RxQueryStandardInfo)
#pragma alloc_text(PAGE, RxQueryPipeInfo)
#pragma alloc_text(PAGE, RxSetBasicInfo)
#pragma alloc_text(PAGE, RxSetDispositionInfo)
#pragma alloc_text(PAGE, RxSetEndOfFileInfo)
#pragma alloc_text(PAGE, RxSetPositionInfo)
#pragma alloc_text(PAGE, RxSetRenameInfo)
#pragma alloc_text(PAGE, RxSetPipeInfo)
#pragma alloc_text(PAGE, RxSetSimpleInfo)
#pragma alloc_text(PAGE, RxConjureOriginalName)
#pragma alloc_text(PAGE, RxQueryCompressedInfo)
#endif

NTSTATUS
RxpSetInfoMiniRdr (
    PRX_CONTEXT RxContext,
    PIRP Irp,
    PFCB Fcb,
    FILE_INFORMATION_CLASS FileInformationClass
    )
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    RxContext->Info.FileInformationClass = FileInformationClass;
    RxContext->Info.Buffer = Irp->AssociatedIrp.SystemBuffer;
    RxContext->Info.Length = IrpSp->Parameters.SetFile.Length;
    
    MINIRDR_CALL( Status,
                  RxContext,
                  Fcb->MRxDispatch,
                  MRxSetFileInfo,
                  (RxContext) );

    return Status;
}

NTSTATUS
RxpQueryInfoMiniRdr (
    PRX_CONTEXT RxContext,
    PFCB Fcb,
    FILE_INFORMATION_CLASS InformationClass,
    PVOID Buffer)
{
    NTSTATUS Status;

    RxContext->Info.FileInformationClass = InformationClass;
    RxContext->Info.Buffer = Buffer;

    MINIRDR_CALL(
        Status,
        RxContext,
        Fcb->MRxDispatch,
        MRxQueryFileInfo,
        (RxContext));

    return Status;
}

NTSTATUS
RxCommonQueryInformation ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )
/*++
Routine Description:

    This is the common routine for querying file information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    
    PFCB Fcb;
    PFOBX Fobx;

    NODE_TYPE_CODE TypeOfOpen;
    PVOID Buffer = NULL;
    FILE_INFORMATION_CLASS FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN PostIrp = FALSE;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx ); 

    RxDbgTrace( +1, Dbg, ("RxCommonQueryInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb) );
    RxDbgTrace( 0, Dbg, ("               Buffer     %08lx Length  %08lx FileInfoClass %08lx\n",
                             Irp->AssociatedIrp.SystemBuffer,
                             IrpSp->Parameters.QueryFile.Length,
                             IrpSp->Parameters.QueryFile.FileInformationClass
                             ) );
    RxLog(( "QueryFileInfo %lx %lx %lx\n", RxContext, Fcb, Fobx ));
    RxWmiLog( LOG,
              RxCommonQueryInformation_1,
              LOGPTR( RxContext )
              LOGPTR( Fcb )
              LOGPTR( Fobx ) );
    RxLog(( "  alsoqfi %lx %lx %ld\n",
            Irp->AssociatedIrp.SystemBuffer,
            IrpSp->Parameters.QueryFile.Length,
            IrpSp->Parameters.QueryFile.FileInformationClass ));
    RxWmiLog( LOG,
              RxCommonQueryInformation_2,
              LOGPTR( Irp->AssociatedIrp.SystemBuffer )
              LOGULONG( IrpSp->Parameters.QueryFile.Length )
              LOGULONG( IrpSp->Parameters.QueryFile.FileInformationClass ) );

    RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length;

    try {

        //
        //  Obtain the Request packet's(user's) buffer
        //

        Buffer = RxMapSystemBuffer( RxContext, Irp );

        if (Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            try_return( Status );
        }

        //
        //  Zero the buffer
        //

        RtlZeroMemory( Buffer, RxContext->Info.LengthRemaining );

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {
        
        case RDBSS_NTC_STORAGE_TYPE_FILE:
        case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:

            //
            //  Acquire shared access to the fcb, except for a paging file
            //  in order to avoid deadlocks with Mm.
            //

            if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
            
                if (FileInformationClass != FileNameInformation) {
            
                    //
                    //  If this is FileCompressedFileSize, we need the Fcb
                    //  exclusive.
                    //
                    
                    if (FileInformationClass != FileCompressionInformation) {
                        Status = RxAcquireSharedFcb( RxContext, Fcb );
                    } else {
                        Status = RxAcquireExclusiveFcb( RxContext, Fcb );
                    }
                    
                    if (Status == STATUS_LOCK_NOT_GRANTED) {
                       
                        RxDbgTrace(0, Dbg, ("Cannot acquire Fcb\n", 0));
                        try_return( PostIrp = TRUE );
                    
                    } else if (Status != STATUS_SUCCESS) {
                        try_return( PostIrp = FALSE );
                    }
                    
                    FcbAcquired = TRUE;
                }
            }
            
            //
            //  Based on the information class, call down to the minirdr
            //  we either complete or we post
            //
            
            switch (FileInformationClass) {
            
            case FileAllInformation:
            
                //
                //  For the all information class we'll typecast a local
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //
            
                AllInfo = Buffer;
            
                //
                //  can't rely on QueryXXInfo functions to calculate LengthRemaining due to
                //  possible allignment issues
                //

                RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length - FIELD_OFFSET( FILE_ALL_INFORMATION, BasicInformation );
                
                Status = RxQueryBasicInfo( RxContext, Irp, Fcb, &AllInfo->BasicInformation );
                if (Status != STATUS_SUCCESS) break;
                
                RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length - FIELD_OFFSET( FILE_ALL_INFORMATION, StandardInformation );
                
                Status = RxQueryStandardInfo( RxContext, Irp, Fcb, Fobx, &AllInfo->StandardInformation );
                if (Status != STATUS_SUCCESS) break;
                
                RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length - FIELD_OFFSET( FILE_ALL_INFORMATION, InternalInformation );
                
                Status = RxQueryInternalInfo( RxContext, Irp, Fcb, &AllInfo->InternalInformation );
                if (Status != STATUS_SUCCESS) break;
                
                RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length - FIELD_OFFSET( FILE_ALL_INFORMATION, EaInformation );
                
                Status = RxQueryEaInfo( RxContext, Irp, Fcb, &AllInfo->EaInformation );
                if (Status != STATUS_SUCCESS) break;
                
                RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length - FIELD_OFFSET( FILE_ALL_INFORMATION, PositionInformation );
                
                Status = RxQueryPositionInfo( RxContext, Irp, Fcb, &AllInfo->PositionInformation );
                if (Status != STATUS_SUCCESS) break;
                
                RxContext->Info.LengthRemaining = (LONG)IrpSp->Parameters.QueryFile.Length - FIELD_OFFSET( FILE_ALL_INFORMATION, NameInformation );
                
                //
                //  QueryNameInfo could return buffer-overflow!!!
                //

                Status = RxQueryNameInfo( RxContext, Irp, Fcb, Fobx, &AllInfo->NameInformation );
                break;
            
            case FileBasicInformation:
            
                Status = RxQueryBasicInfo( RxContext, Irp, Fcb, Buffer );
                break;
            
            case FileStandardInformation:
            
                Status = RxQueryStandardInfo( RxContext, Irp, Fcb, Fobx, Buffer );
                break;
            
            case FileInternalInformation:
            
                Status = RxQueryInternalInfo( RxContext, Irp, Fcb, Buffer );
                break;
            
            case FileEaInformation:
            
                Status = RxQueryEaInfo( RxContext, Irp, Fcb, Buffer );
                break;
            
            case FilePositionInformation:
            
                Status = RxQueryPositionInfo( RxContext, Irp, Fcb, Buffer );
                break;
            
            case FileNameInformation:
            
                Status = RxQueryNameInfo( RxContext, Irp, Fcb, Fobx, Buffer );
                break;
            
            case FileAlternateNameInformation:
            
                Status = RxQueryAlternateNameInfo( RxContext, Irp, Fcb, Buffer );
                break;
            
            case FileCompressionInformation:
            
                Status = RxQueryCompressedInfo( RxContext, Irp, Fcb, Buffer );
                break;
            
            case FilePipeInformation:
            case FilePipeLocalInformation:
            case FilePipeRemoteInformation:
            
                Status = RxQueryPipeInfo( RxContext, Irp, Fcb, Fobx, Buffer );
                break;
            
            default:

                //
                //  anything that we don't understand, we just remote
                //

                RxContext->StoredStatus = RxpQueryInfoMiniRdr( RxContext,
                                                               Fcb,
                                                               FileInformationClass,
                                                               Buffer );
            
               Status = RxContext->StoredStatus;
               break;
            }
            
            //
            //  If we overflowed the buffer, set the length to 0 and change the
            //  status to RxStatus(BUFFER_OVERFLOW).
            //

            if (RxContext->Info.LengthRemaining < 0) {
               
                Status = STATUS_BUFFER_OVERFLOW;
                RxContext->Info.LengthRemaining = IrpSp->Parameters.QueryFile.Length;
            }
            
            //
            //  Set the information field to the number of bytes actually filled in
            //  and then complete the request  LARRY DOES THIS UNDER "!NT_ERROR"
            //

            Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - RxContext->Info.LengthRemaining;
            break;
        
        case RDBSS_NTC_MAILSLOT:
            Status = STATUS_NOT_IMPLEMENTED;
            break;
        default:
            
            RxDbgTrace( 0, Dbg, ("RxCommonQueryInformation: Illegal Type of Open = %08lx\n", TypeOfOpen) );
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    
try_exit:

        if ((Status == STATUS_SUCCESS) &&
            (PostIrp || RxContext->PostRequest)) {

            Status = RxFsdPostRequest( RxContext );
        }

    } finally {

        DebugUnwind( RxCommonQueryInformation );

        if (FcbAcquired) {
           RxReleaseFcb( RxContext, Fcb );
        }

        RxDbgTrace( -1, Dbg, ("RxCommonQueryInformation -> %08lx\n", Status) );
    }

    return Status;
}

NTSTATUS
RxCommonSetInformation ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for setting file information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    NODE_TYPE_CODE TypeOfOpen;
    PFCB Fcb;
    PFOBX Fobx;
    PNET_ROOT NetRoot;
    FILE_INFORMATION_CLASS FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
	PFCB TempFcb;
    
    PFILE_DISPOSITION_INFORMATION Buffer;
    
    BOOLEAN Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN NetRootTableLockAcquired = FALSE;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );
    NetRoot = Fcb->NetRoot;

    RxDbgTrace( +1, Dbg, ("RxCommonSetInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb) );
    RxDbgTrace( 0, Dbg, ("               Buffer     %08lx Length  %08lx FileInfoClass %08lx Replace %08lx\n",
                             Irp->AssociatedIrp.SystemBuffer,
                             IrpSp->Parameters.QueryFile.Length,
                             IrpSp->Parameters.QueryFile.FileInformationClass,
                             IrpSp->Parameters.SetFile.ReplaceIfExists
                             ) );

    RxLog(( "SetFileInfo %lx %lx %lx\n", RxContext, Fcb, Fobx ));
    RxWmiLog( LOG,
              RxCommonSetInformation_1,
              LOGPTR( RxContext )
              LOGPTR( Fcb )
              LOGPTR( Fobx ) );
    RxLog(("  alsosfi %lx %lx %ld %lx\n",
                 Irp->AssociatedIrp.SystemBuffer,
                 IrpSp->Parameters.QueryFile.Length,
                 IrpSp->Parameters.QueryFile.FileInformationClass,
                 IrpSp->Parameters.SetFile.ReplaceIfExists ));
    RxWmiLog( LOG,
              RxCommonSetInformation_2,
              LOGPTR(Irp->AssociatedIrp.SystemBuffer)
              LOGULONG( IrpSp->Parameters.QueryFile.Length )
              LOGULONG( IrpSp->Parameters.QueryFile.FileInformationClass )
              LOGUCHAR( IrpSp->Parameters.SetFile.ReplaceIfExists ) );

    FcbAcquired = FALSE;
    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {
        
        case RDBSS_NTC_STORAGE_TYPE_FILE:
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
        case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        case RDBSS_NTC_SPOOLFILE:
            
            break;

        case RDBSS_NTC_MAILSLOT:
            
            try_return( Status = STATUS_NOT_IMPLEMENTED );
            break;

        default:
            
            DbgPrint ("SetFile, Illegal TypeOfOpen = %08lx\n", TypeOfOpen);
            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  If the FileInformationClass is FileEndOfFileInformation and the 
        //  AdvanceOnly field in IrpSp->Parameters is TRUE then we don't need
        //  to proceed any further. Only local file systems care about this
        //  call. This is the AdvanceOnly callback  all FAT does with this is
        //  use it as a hint of a good time to punch out the directory entry.
        //  NTFS is much the same way. This is pure PagingIo (dovetailing with
        //  lazy writer sync) to metadata streams and cant block behind other
        //  user file cached IO.
        //
        
        if ((FileInformationClass == FileEndOfFileInformation) &&
            (IrpSp->Parameters.SetFile.AdvanceOnly)) {
                
            RxDbgTrace( -1, Dbg, ("RxCommonSetInfo (no advance) -> %08lx\n", RxContext) );
            RxLog(( "RxCommonSetInfo SetEofAdvance-NOT! %lx\n", RxContext ));
            RxWmiLog( LOG,
                      RxSetEndOfFileInfo_2,
                      LOGPTR( RxContext ) );
            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  In the following two cases, we cannot have creates occuring
        //  while we are here, so acquire the exclusive lock on netroot prefix table.
        //

        if ((FileInformationClass == FileDispositionInformation) ||
            (FileInformationClass == FileRenameInformation)) {
            
			//
			// For directory renames, all files under that directory need to be closed.
			// So, we purge all files on the netroot (share) in case this is a directory.
			// 

			if ( NodeType(Fcb) == RDBSS_NTC_STORAGE_TYPE_DIRECTORY ) {
				TempFcb = NULL;
			} else {
				TempFcb = Fcb;
			}

            RxPurgeRelatedFobxs( NetRoot,
                                 RxContext,
                                 ATTEMPT_FINALIZE_ON_PURGE,
                                 TempFcb );

            RxScavengeFobxsForNetRoot( NetRoot, TempFcb );

            if (!RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, Wait )) {

                RxDbgTrace( 0, Dbg, ("Cannot acquire NetRootTableLock\n", 0) );

                Status = STATUS_PENDING;
                RxContext->PostRequest = TRUE;

                try_return( Status );
            }

            NetRootTableLockAcquired = TRUE;
        }

        //
        //  Acquire exclusive access to the Fcb,  We use exclusive
        //  because it is probable that the subroutines
        //  that we call will need to monkey with file allocation,
        //  create/delete extra fcbs.  So we're willing to pay the
        //  cost of exclusive Fcb access.
        //
        //  Note that we do not acquire the resource for paging file
        //  operations in order to avoid deadlock with Mm.
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );
            if (Status == STATUS_LOCK_NOT_GRANTED) {

                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb\n", 0) );

                Status = STATUS_SUCCESS;

                RxContext->PostRequest = TRUE;

                try_return( Status );
            } else  if (Status != STATUS_SUCCESS) {
                try_return( Status );
            }

            FcbAcquired = TRUE;
        }

        Status = STATUS_SUCCESS;

        //
        //  Based on the information class we'll do different
        //  actions.  Each of the procedures that we're calling will either
        //  complete the request of send the request off to the fsp
        //  to do the work.
        //

        switch (FileInformationClass) {

        case FileBasicInformation:

            Status = RxSetBasicInfo( RxContext, Irp, Fcb, Fobx );
            break;

        case FileDispositionInformation:
        
            Buffer = Irp->AssociatedIrp.SystemBuffer;
    
            //
            //  Check if the user wants to delete the file; if so,
            //  check for situations where we cannot delete.
            //
    
            if (Buffer->DeleteFile) {
                
                //
                //  Make sure there is no process mapping this file as an image.
                //
                
                if (!MmFlushImageSection( &Fcb->NonPaged->SectionObjectPointers, MmFlushForDelete )) {
    
                    RxDbgTrace( -1, Dbg, ("Cannot delete user mapped image\n", 0) );
                    Status = STATUS_CANNOT_DELETE;
                }
    
                if (Status == STATUS_SUCCESS) {
                    
                    //
                    //  In the case of disposition information this name is being
                    //  deleted. In such cases the collapsing of new create requests
                    //  onto this FCB should be prohibited. This can be accomplished
                    //  by removing the FCB name from the FCB table. Subsequently the
                    //  FCB table lock can be dropped.
                    //
    
                    ASSERT( FcbAcquired && NetRootTableLockAcquired );
    
                    RxRemoveNameNetFcb( Fcb );
    
                    RxReleaseFcbTableLock( &NetRoot->FcbTable );
                    NetRootTableLockAcquired = FALSE;
                }
            }
    
            if (Status == STATUS_SUCCESS) {
                Status = RxSetDispositionInfo( RxContext, Irp, Fcb );
            }
        
            break;

        case FileMoveClusterInformation:
        case FileLinkInformation:
        case FileRenameInformation:

            //
            //  We proceed with this operation only if we can wait
            //

            if (!Wait) {

                Status = RxFsdPostRequest( RxContext );

            } else {
                
                ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );

                Status = RxSetRenameInfo( RxContext, Irp, Fcb, Fobx );

                if ((Status == STATUS_SUCCESS) &&
                    (FileInformationClass == FileRenameInformation)) {
                    
                    ASSERT( FcbAcquired && NetRootTableLockAcquired );

                    RxRemoveNameNetFcb( Fcb );
                }
            }

            break;

        case FilePositionInformation:
        
            Status = RxSetPositionInfo( RxContext, Irp, Fcb, Fobx );
            break;


        case FileAllocationInformation:

            Status = RxSetAllocationInfo( RxContext, Irp, Fcb, Fobx );
            break;

        case FileEndOfFileInformation:

            Status = RxSetEndOfFileInfo( RxContext, Irp, Fcb, Fobx );
            break;

        case FilePipeInformation:
        case FilePipeLocalInformation:
        case FilePipeRemoteInformation:

            Status = RxSetPipeInfo( RxContext, Irp, Fcb, Fobx );
            break;

        case FileValidDataLengthInformation:

            if(!MmCanFileBeTruncated( &Fcb->NonPaged->SectionObjectPointers, NULL )) {
                
                Status = STATUS_USER_MAPPED_FILE;
                break;
            }
            Status = RxSetSimpleInfo( RxContext, Irp, Fcb );
            break;

        case FileShortNameInformation:

            Status = RxSetSimpleInfo( RxContext, Irp, Fcb );
            break;


        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

    try_exit:

        if ((Status == STATUS_SUCCESS) &&
            RxContext->PostRequest) {

            Status = RxFsdPostRequest( RxContext );
        }

    } finally {

        DebugUnwind( RxCommonSetInformation );

        if (FcbAcquired) {
            RxReleaseFcb( RxContext, Fcb );
        }

        if (NetRootTableLockAcquired) {
            RxReleaseFcbTableLock( &NetRoot->FcbTable );
        }

        RxDbgTrace(-1, Dbg, ("RxCommonSetInformation -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxSetBasicInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )

/*++

Routine Description:

    (Interal Support Routine)
    This routine performs the set basic information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFILE_BASIC_INFORMATION Buffer;

    BOOLEAN ModifyCreation = FALSE;
    BOOLEAN ModifyLastAccess = FALSE;
    BOOLEAN ModifyLastWrite = FALSE;
    BOOLEAN ModifyLastChange = FALSE;
    

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxSetBasicInfo...\n", 0) );
    RxLog(( "RxSetBasicInfo\n" ));
    RxWmiLog( LOG,
              RxSetBasicInfo,
              LOGPTR( RxContext ) );
    //
    //  call down. if we're successful, then fixup all the fcb data.
    //

    Status = RxpSetInfoMiniRdr( RxContext, Irp, Fcb, FileBasicInformation );

    if (!NT_SUCCESS(Status)) {
        
        RxDbgTrace( -1, Dbg, ("RxSetBasicInfo -> %08lx\n", Status) );
        return Status;
    }

    //
    //  now we have to update the info in the fcb, both the absolute info AND whether changes were made
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    try {

        //
        //  Check if the user specified a non-zero creation time
        //

        if (Buffer->CreationTime.QuadPart != 0 ) {
            ModifyCreation = TRUE;
        }

        //
        //  Check if the user specified a non-zero last access time
        //

        if (Buffer->LastAccessTime.QuadPart != 0 ) {
            ModifyLastAccess = TRUE;
        }

        //
        //  Check if the user specified a non-zero last write time
        //

        if (Buffer->LastWriteTime.QuadPart != 0 ) {
            ModifyLastWrite = TRUE;
        }


        if (Buffer->ChangeTime.QuadPart != 0 ) {
            ModifyLastChange = TRUE;
        }


        //
        //  Check if the user specified a non zero file attributes byte
        //

        if (Buffer->FileAttributes != 0) {

            USHORT Attributes;

            //
            //  Remove the normal attribute flag
            //

            Attributes = (USHORT)FlagOn( Buffer->FileAttributes, ~FILE_ATTRIBUTE_NORMAL );

            //
            //  Make sure that for a file the directory bit is not set
            //  and for a directory that the bit is set
            //

            if (NodeType( Fcb ) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {

                ClearFlag( Attributes, FILE_ATTRIBUTE_DIRECTORY );

            } else {

                SetFlag( Attributes, FILE_ATTRIBUTE_DIRECTORY );
            }

            //
            //  Mark the FcbState temporary flag correctly.
            //

            if (FlagOn( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY )) {

                SetFlag( Fcb->FcbState, FCB_STATE_TEMPORARY );
                SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );

            } else {

                ClearFlag( Fcb->FcbState, FCB_STATE_TEMPORARY );
                ClearFlag( FileObject->Flags, FO_TEMPORARY_FILE );
            }

            //
            //  Set the new attributes byte, and mark the bcb dirty
            //

            Fcb->Attributes = Attributes;
        }

        if (ModifyCreation) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->CreationTime = Buffer->CreationTime;
            
            //
            //  Now because the user just set the creation time we
            //  better not set the creation time on close
            //

            SetFlag( Fobx->Flags, FOBX_FLAG_USER_SET_CREATION );
        }

        if (ModifyLastAccess) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->LastAccessTime = Buffer->LastAccessTime;
            
            //
            //  Now because the user just set the last access time we
            //  better not set the last access time on close
            //

            SetFlag( Fobx->Flags, FOBX_FLAG_USER_SET_LAST_ACCESS );
        }

        if (ModifyLastWrite) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->LastWriteTime = Buffer->LastWriteTime;
            
            //
            //  Now because the user just set the last write time we
            //  better not set the last write time on close
            //

            SetFlag( Fobx->Flags, FOBX_FLAG_USER_SET_LAST_WRITE );
        }

        if (ModifyLastChange) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            Fcb->LastChangeTime = Buffer->ChangeTime;
            
            //
            //  Now because the user just set the last write time we
            //  better not set the last write time on close
            //

            SetFlag( Fobx->Flags, FOBX_FLAG_USER_SET_LAST_CHANGE );
        }

    } finally {

        DebugUnwind( RxSetBasicInfo );

        RxDbgTrace( -1, Dbg, ("RxSetBasicInfo -> %08lx\n", Status) );
    }

    return Status;
}

NTSTATUS
RxSetDispositionInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set disposition information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status;

    PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;
    PFILE_DISPOSITION_INFORMATION Buffer;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxSetDispositionInfo...\n", 0) );
    RxLog(( "RxSetDispositionInfo\n" ));
    RxWmiLog( LOG,
              RxSetDispositionInfo,
              LOGPTR( RxContext ) );

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  call down and check for success
    //

    Status = RxpSetInfoMiniRdr( RxContext, Irp, Fcb, FileDispositionInformation );

    if (!NT_SUCCESS( Status )) {
        RxDbgTrace( -1, Dbg, ("RxSetDispositionInfo -> %08lx\n", Status) );
        return Status;
    }

    //
    //  if successful, record the correct state in the fcb
    //

    if (Buffer->DeleteFile) {

        SetFlag( Fcb->FcbState,  FCB_STATE_DELETE_ON_CLOSE );
        FileObject->DeletePending = TRUE;

    } else {

        //
        //  The user doesn't want to delete the file so clear
        //  the delete on close bit
        //

        RxDbgTrace(0, Dbg, ("User want to not delete file\n", 0));

        ClearFlag(Fcb->FcbState, ~FCB_STATE_DELETE_ON_CLOSE );
        FileObject->DeletePending = FALSE;
    }

    RxDbgTrace(-1, Dbg, ("RxSetDispositionInfo -> RxStatus(SUCCESS)\n", 0));

    return STATUS_SUCCESS;
}

NTSTATUS
RxSetRenameInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set name information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxSetRenameInfo ......FileObj = %08lx\n",
                    IrpSp->Parameters.SetFile.FileObject) );
    RxLog(("RxSetRenameInfo %lx %lx\n",
                   IrpSp->Parameters.SetFile.FileObject,
                   IrpSp->Parameters.SetFile.ReplaceIfExists ));
    RxWmiLog(LOG,
             RxSetRenameInfo,
             LOGPTR(IrpSp->Parameters.SetFile.FileObject)
             LOGUCHAR(IrpSp->Parameters.SetFile.ReplaceIfExists));

    RxContext->Info.ReplaceIfExists = IrpSp->Parameters.SetFile.ReplaceIfExists;
    if (IrpSp->Parameters.SetFile.FileObject){
        // here we have to translate the name. the fcb of the fileobject has the
        // translation already....all we have to do is to allocate a buffer, copy
        // and calldown
        PFILE_OBJECT RenameFileObject = IrpSp->Parameters.SetFile.FileObject;
        PFCB RenameFcb = (PFCB)(RenameFileObject->FsContext);
        PFILE_RENAME_INFORMATION RenameInformation;
        ULONG allocate_size;

        ASSERT (NodeType(RenameFcb)==RDBSS_NTC_OPENTARGETDIR_FCB);

        RxDbgTrace(0, Dbg, ("-->RenameTarget is %wZ,over=%08lx\n",
                                &(RenameFcb->FcbTableEntry.Path),
                                Fcb->NetRoot->DiskParameters.RenameInfoOverallocationSize));
        if (RenameFcb->NetRoot != Fcb->NetRoot) {
            RxDbgTrace(-1, Dbg, ("RxSetRenameInfo -> %s\n", "NOT SAME DEVICE!!!!!!"));
            return(STATUS_NOT_SAME_DEVICE);
        }

        allocate_size = FIELD_OFFSET(FILE_RENAME_INFORMATION, FileName[0])
                             + RenameFcb->FcbTableEntry.Path.Length
                             + Fcb->NetRoot->DiskParameters.RenameInfoOverallocationSize;
        RxDbgTrace(0, Dbg, ("-->AllocSize is %08lx\n", allocate_size));
        RenameInformation = RxAllocatePool( PagedPool, allocate_size );
        if (RenameInformation != NULL) {
            try {
                *RenameInformation = *((PFILE_RENAME_INFORMATION)(Irp->AssociatedIrp.SystemBuffer));
                RenameInformation->FileNameLength = RenameFcb->FcbTableEntry.Path.Length;

                RtlMoveMemory(
                    &RenameInformation->FileName[0],
                    RenameFcb->FcbTableEntry.Path.Buffer,
                    RenameFcb->FcbTableEntry.Path.Length);

                RxContext->Info.FileInformationClass = (IrpSp->Parameters.SetFile.FileInformationClass);
                RxContext->Info.Buffer = RenameInformation;
                RxContext->Info.Length = allocate_size;
                MINIRDR_CALL(Status,RxContext,Fcb->MRxDispatch,MRxSetFileInfo,(RxContext));

               //we don't change the name in the fcb? a la rdr1
            } finally {
                RxFreePool(RenameInformation);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = RxpSetInfoMiniRdr( RxContext,
                                    Irp, 
                                    Fcb, 
                                    IrpSp->Parameters.SetFile.FileInformationClass );
    }

    RxDbgTrace(-1, Dbg, ("RxSetRenameInfo -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxSetPositionInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set position information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSetPositionInfo...\n", 0));
    RxLog(("RxSetPositionInfo\n"));
    RxWmiLog(LOG,
             RxSetPositionInfo,
             LOGPTR(RxContext));

    //
    //  This does NOT call down to the minirdrs  .........
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Check if the file does not use intermediate buffering.  If it
    //  does not use intermediate buffering then the new position we're
    //  supplied must be aligned properly for the device
    //

    if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {

        PDEVICE_OBJECT DeviceObject;

        DeviceObject = IrpSp->DeviceObject;

        if ((Buffer->CurrentByteOffset.LowPart & DeviceObject->AlignmentRequirement) != 0) {

            RxDbgTrace(0, Dbg, ("Cannot set position due to aligment conflict\n", 0));
            RxDbgTrace(-1, Dbg, ("RxSetPositionInfo -> %08lx\n", STATUS_INVALID_PARAMETER));

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  The input parameter is fine so set the current byte offset and
    //  complete the request
    //

    RxDbgTrace(0, Dbg, ("Set the new position to %08lx\n", Buffer->CurrentByteOffset));

    FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;

    RxDbgTrace(-1, Dbg, ("RxSetPositionInfo -> %08lx\n", STATUS_SUCCESS));

    return STATUS_SUCCESS;
}

NTSTATUS
RxSetAllocationInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set Allocation information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFILE_ALLOCATION_INFORMATION Buffer;

    LONGLONG NewAllocationSize;

    BOOLEAN CacheMapInitialized = FALSE;
    LARGE_INTEGER OriginalFileSize;
    LARGE_INTEGER OriginalAllocationSize;

    PAGED_CODE();

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    NewAllocationSize = Buffer->AllocationSize.QuadPart;

    RxDbgTrace( +1, Dbg, ("RxSetAllocationInfo.. to %08lx\n", NewAllocationSize) );
    RxLog(( "SetAlloc %lx %lx %lx\n", Fcb->Header.FileSize.LowPart,
            (ULONG)NewAllocationSize, Fcb->Header.AllocationSize.LowPart ));
    RxWmiLog( LOG,
              RxSetAllocationInfo_1,
              LOGULONG( Fcb->Header.FileSize.LowPart )
              LOGULONG( (ULONG)NewAllocationSize )
              LOGULONG( Fcb->Header.AllocationSize.LowPart ) );

    //
    //  This is kinda gross, but if the file is not cached, but there is
    //  a data section, we have to cache the file to avoid a bunch of
    //  extra work.
    //

    if ((FileObject->SectionObjectPointer->DataSectionObject != NULL) &&
        (FileObject->SectionObjectPointer->SharedCacheMap == NULL) &&
        (Irp->RequestorMode != KernelMode)) {

        if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {
            return STATUS_FILE_CLOSED;
        }

        RxAdjustAllocationSizeforCC( Fcb );

        //
        //  Now initialize the cache map.
        //

        CcInitializeCacheMap( FileObject,
                              (PCC_FILE_SIZES)&Fcb->Header.AllocationSize,
                              FALSE,
                              &RxData.CacheManagerCallbacks,
                              Fcb );

        CacheMapInitialized = TRUE;
    }

    //
    //  Now mark that the time on the dirent needs to be updated on close.
    //

    SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

    try {

        //
        //  Check here if we will be decreasing file size and synchonize with
        //  paging IO.
        //

        RxGetFileSizeWithLock( Fcb, &OriginalFileSize.QuadPart );

        if (OriginalFileSize.QuadPart > Buffer->AllocationSize.QuadPart) {

            //
            //  Before we actually truncate, check to see if the purge
            //  is going to fail.
            //

            if (!MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                                       &Buffer->AllocationSize )) {

                try_return( Status = STATUS_USER_MAPPED_FILE );
            }


            RxAcquirePagingIoResource( RxContext, Fcb );

            RxSetFileSizeWithLock( Fcb, &NewAllocationSize );

            //
            //  If we reduced the file size to less than the ValidDataLength,
            //  adjust the VDL.
            //

            if (Fcb->Header.ValidDataLength.QuadPart > NewAllocationSize) {

                Fcb->Header.ValidDataLength.QuadPart = NewAllocationSize;
            }

            RxReleasePagingIoResource( RxContext, Fcb );
        }

        OriginalAllocationSize.QuadPart = Fcb->Header.AllocationSize.QuadPart;
        Fcb->Header.AllocationSize.QuadPart = NewAllocationSize;

        Status = RxpSetInfoMiniRdr( RxContext,
                                    Irp, 
                                    Fcb, 
                                    FileAllocationInformation );

        if (!NT_SUCCESS( Status )) {
            
            Fcb->Header.AllocationSize.QuadPart =  OriginalAllocationSize.QuadPart;
            RxDbgTrace( -1, Dbg, ("RxSetAllocationInfo -> %08lx\n", Status) );
            try_return( Status );
        }

        //
        //  Now check if we needed to change the file size accordingly.
        //

        if( OriginalAllocationSize.QuadPart != NewAllocationSize ) {

            //
            //  Tell the cache manager we reduced the file size or increased the allocationsize
            //  The call is unconditional, because MM always wants to know.
            //

            try {

                CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();

                //
                //  Cache manager was not able to extend the file.  Restore the file to
                //  its previous state.
                //
                //  NOTE:  If this call to the mini-RDR fails, there is nothing we can do.
                //

                Fcb->Header.AllocationSize.QuadPart =  OriginalAllocationSize.QuadPart;

                RxpSetInfoMiniRdr( RxContext,
                                   Irp, 
                                   Fcb, 
                                   FileAllocationInformation );

                try_return( Status );
            }
        }

    try_exit: NOTHING;
    } finally {
        
        if (CacheMapInitialized) {
            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }
    }

    RxLog(( "SetAllocExit %lx %lx\n",
            Fcb->Header.FileSize.LowPart,
            Fcb->Header.AllocationSize.LowPart ));
    RxWmiLog( LOG,
              RxSetAllocationInfo_2,
              LOGULONG( Fcb->Header.FileSize.LowPart )
              LOGULONG( Fcb->Header.AllocationSize.LowPart) );

    RxDbgTrace( -1, Dbg, ("RxSetAllocationInfo -> %08lx\n", STATUS_SUCCESS) );

    return Status;
}

NTSTATUS
RxSetEndOfFileInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set End of File information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - The rxcontext for the request
    
    Irp - irp to proccess
    
    Fcb - the fcb to work on
    
    Fobx - The fobx for the open
    
    

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFILE_END_OF_FILE_INFORMATION Buffer;

    LONGLONG NewFileSize;
    LONGLONG OriginalFileSize;
    LONGLONG OriginalAllocationSize;
    LONGLONG OriginalValidDataLength;

    BOOLEAN CacheMapInitialized = FALSE;
    BOOLEAN PagingIoResourceAcquired = FALSE;

    PAGED_CODE();

    Buffer = Irp->AssociatedIrp.SystemBuffer;
    NewFileSize = Buffer->EndOfFile.QuadPart;

    RxDbgTrace( +1, Dbg, ("RxSetEndOfFileInfo...Old,New,Alloc %08lx,%08lx,%08lx\n", 
                          Fcb->Header.FileSize.LowPart, 
                          (ULONG)NewFileSize,
                          Fcb->Header.AllocationSize.LowPart) );
    RxLog(( "SetEof %lx %lx %lx %lx\n", RxContext, Fcb->Header.FileSize.LowPart, (ULONG)NewFileSize, Fcb->Header.AllocationSize.LowPart ));
    RxWmiLog( LOG,
              RxSetEndOfFileInfo_1,
              LOGPTR(RxContext)
              LOGULONG( Fcb->Header.FileSize.LowPart )
              LOGULONG( (ULONG)NewFileSize )
              LOGULONG( Fcb->Header.AllocationSize.LowPart ) );

    //
    //  File Size changes are only allowed on a file and not a directory
    //

    if (NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {

        RxDbgTrace( 0, Dbg, ("Cannot change size of a directory\n", 0) );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    try {

        //
        //  remember everything
        //

        OriginalFileSize = Fcb->Header.FileSize.QuadPart;
        OriginalAllocationSize = Fcb->Header.AllocationSize.QuadPart;
        OriginalValidDataLength = Fcb->Header.ValidDataLength.QuadPart;

        //
        //  This is kinda gross, but if the file is not cached, but there is
        //  a data section, we have to cache the file to avoid a bunch of
        //  extra work.
        //

        if ((FileObject->SectionObjectPointer->DataSectionObject != NULL) &&
            (FileObject->SectionObjectPointer->SharedCacheMap == NULL) &&
            (Irp->RequestorMode != KernelMode)) {

            if ( FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE ) ) {
                try_return( STATUS_FILE_CLOSED );
            }

            RxAdjustAllocationSizeforCC( Fcb );

            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( FileObject,
                                  (PCC_FILE_SIZES)&Fcb->Header.AllocationSize,
                                  FALSE,
                                  &RxData.CacheManagerCallbacks,
                                  Fcb );

            CacheMapInitialized = TRUE;
        }

        //
        //  RDR doesn't handle the lazy write of file sizes. See abovein RxCommonSetInformation
        //

        ASSERTMSG( "Unhandled advance only EOF\n", !IrpSp->Parameters.SetFile.AdvanceOnly );

        //
        //  Check if we are really changing the file size
        //

        if (Fcb->Header.FileSize.QuadPart != NewFileSize) {

            if (NewFileSize < Fcb->Header.FileSize.QuadPart) {

                //
                //  Before we actually truncate, check to see if the purge
                //  is going to fail.
                //

                if (!MmCanFileBeTruncated( FileObject->SectionObjectPointer,
                                           &Buffer->EndOfFile )) {

                    try_return( Status = STATUS_USER_MAPPED_FILE );
                }
            }

            //
            //  MM always wants to know if the filesize is changing;
            //  serialize here with paging io since we are truncating the file size.
            //

            PagingIoResourceAcquired = RxAcquirePagingIoResource( RxContext, Fcb );

            //
            //  Set the new file size
            //

            Fcb->Header.FileSize.QuadPart = NewFileSize;

            //
            //  If we reduced the file size to less than the ValidDataLength,
            //  adjust the VDL.
            //

            if (Fcb->Header.ValidDataLength.QuadPart > NewFileSize) {
                Fcb->Header.ValidDataLength.QuadPart = NewFileSize;
            }

            //
            //  Change the file allocation size as well
            //

            Fcb->Header.AllocationSize.QuadPart = NewFileSize;

            Status = RxpSetInfoMiniRdr( RxContext, 
                                        Irp, 
                                        Fcb, 
                                        FileEndOfFileInformation );

            if (Status == STATUS_SUCCESS) {
                
                if (PagingIoResourceAcquired) {
                    RxReleasePagingIoResource( RxContext, Fcb );
                    PagingIoResourceAcquired = FALSE;
                }

                //
                //  We must now update the cache mapping (benign if not cached).
                //

                try {
                    
                    CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );
                
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = GetExceptionCode();
                }

                if (Status != STATUS_SUCCESS) {
                    try_return( Status );
                }
            }

        } else {
            
            //
            //  Set our return status to success
            //

            Status = STATUS_SUCCESS;
        }

        //
        //  Set this handle as having modified the file
        //

        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

    try_exit: NOTHING;

    } finally {

        DebugUnwind( RxSetEndOfFileInfo );

        if ((AbnormalTermination() || !NT_SUCCESS( Status ))) {
            
            RxDbgTrace( -1, Dbg, ("RxSetEndOfFileInfo2 status -> %08lx\n", Status) );

            Fcb->Header.FileSize.QuadPart = OriginalFileSize;
            Fcb->Header.AllocationSize.QuadPart = OriginalAllocationSize;
            Fcb->Header.ValidDataLength.QuadPart = OriginalValidDataLength;

            if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                *CcGetFileSizePointer(FileObject) = Fcb->Header.FileSize;
            }

            RxLog(("SetEofabnormalorbadstatus %lx %lx", RxContext,Status));
            RxWmiLog( LOG,
                      RxSetEndOfFileInfo_3,
                      LOGPTR( RxContext )
                      LOGULONG( Status ) );
        }

        if (PagingIoResourceAcquired) {
            RxReleasePagingIoResource( RxContext, Fcb );
        }

        if (CacheMapInitialized) {
            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        RxDbgTrace(-1, Dbg, ("RxSetEndOfFileInfo -> %08lx\n", Status));
    }

    if (Status == STATUS_SUCCESS) {
        
        RxLog(( "SetEofexit %lx %lx %lx\n",
                Fcb->Header.FileSize.LowPart,
                (ULONG)NewFileSize,
                Fcb->Header.AllocationSize.LowPart ));
        
        RxWmiLog( LOG,
                  RxSetEndOfFileInfo_4,
                  LOGPTR( RxContext )
                  LOGULONG( Fcb->Header.FileSize.LowPart )
                  LOGULONG( (ULONG)NewFileSize )
                  LOGULONG( Fcb->Header.AllocationSize.LowPart ) );
    }
    return Status;
}

BOOLEAN RxForceQFIPassThrough = FALSE;

NTSTATUS
RxQueryBasicInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_BASIC_INFORMATION Buffer
    )
/*++
 Description:

    (Internal Support Routine)
    This routine performs the query basic information function for fat.

Arguments:

    RxContext -

    Irp -
    
    Fcb -
    
    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS if the call was successful, otherwise the appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryBasicInfo...\n", 0) );
    RxLog(( "RxQueryBasicInfo\n" ));
    RxWmiLog( LOG,
              RxQueryBasicInfo,
              LOGPTR( RxContext ) );

    //
    //  Zero out the output buffer, and set it to indicate that
    //  the query is a normal file.  Later we might overwrite the
    //  attribute.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_BASIC_INFORMATION ) );

    Status = RxpQueryInfoMiniRdr( RxContext,
                                  Fcb,
                                  FileBasicInformation,
                                  Buffer );

    return Status;
}

NTSTATUS
RxQueryStandardInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx,
    IN OUT PFILE_STANDARD_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query standard information function for fat.

Arguments:

    RxContext -
    
    Irp -
    
    Fcb -
    
    Fobx -

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    PMRX_SRV_OPEN SrvOpen;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryStandardInfo...\n", 0) );
    RxLog(( "RxQueryStandardInfo\n" ));
    RxWmiLog( LOG,
              RxQueryStandardInfo,
              LOGPTR( RxContext ));

    //
    //  Zero out the output buffer, and fill in the number of links
    //  and the delete pending flag.
    //

    RtlZeroMemory( Buffer, sizeof( FILE_STANDARD_INFORMATION ) );

    SrvOpen = Fobx->pSrvOpen;

    switch (NodeType( Fcb )) {
    
    case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
    case RDBSS_NTC_STORAGE_TYPE_FILE:

        //
        //  If the file was not opened with back up intent then the wrapper has
        //  all the information that is required. In the cases that this is
        //  specified we fill in the information from the mini redirector. This
        //  is because backup pograms rely upon fields that are not available
        //  in the wrapper and that which cannot be cached easily.
        //

        if (!FlagOn( SrvOpen->CreateOptions,FILE_OPEN_FOR_BACKUP_INTENT )) {
            
            //
            //  copy in all the stuff that we know....it may be enough.....
            //

            Buffer->NumberOfLinks = Fcb->NumberOfLinks;
            Buffer->DeletePending = BooleanFlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
            Buffer->Directory = (NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_DIRECTORY);

            if (Buffer->NumberOfLinks == 0) {
                
                //
                //  This switch is required because of compatibility reasons with
                //  the old redirector.
                //
                
                Buffer->NumberOfLinks = 1;
            }

            if (NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_FILE) {
                
                Buffer->AllocationSize = Fcb->Header.AllocationSize;
                RxGetFileSizeWithLock( Fcb, &Buffer->EndOfFile.QuadPart );
            }

            if (!RxForceQFIPassThrough && 
                FlagOn( Fcb->FcbState, FCB_STATE_FILESIZECACHEING_ENABLED )) {

                //
                //  if we don't have to go to the mini, adjust the size and get out.......
                //

                RxContext->Info.LengthRemaining -= sizeof( FILE_STANDARD_INFORMATION );
                break;
            }
        }
        //  falls thru

    default:

        Status = RxpQueryInfoMiniRdr( RxContext,
                                      Fcb,
                                      FileStandardInformation,
                                      Buffer );
        break;

    }

    RxDbgTrace( 0, Dbg, ("LengthRemaining = %08lx\n", RxContext->Info.LengthRemaining));
    RxDbgTrace( -1, Dbg, ("RxQueryStandardInfo -> VOID\n", 0) );

    return Status;
}

NTSTATUS
RxQueryInternalInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer
    )
/*++
Routine Description:

    (Internal Support Routine)
    This routine performs the query internal information function for fat.

Arguments:

    RxContext -
    
    Irp -
    
    Fcb -

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryInternalInfo...\n", 0) );
    RxLog(( "RxQueryInternalInfo\n" ));
    RxWmiLog( LOG,
              RxQueryInternalInfo,
              LOGPTR( RxContext ) );

    Status = RxpQueryInfoMiniRdr( RxContext,
                                  Fcb,
                                  FileInternalInformation,
                                  Buffer );

    RxDbgTrace( -1, Dbg, ("RxQueryInternalInfo...Status %lx\n", Status) );
    return Status;

    UNREFERENCED_PARAMETER( Irp );
}

NTSTATUS
RxQueryEaInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query Ea information function for fat.

Arguments:

    RxContext -
    
    Irp -
    
    Fcb -
    
    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryEaInfo...\n", 0));
    RxLog(( "RxQueryEaInfo\n" ));
    RxWmiLog( LOG,
              RxQueryEaInfo,
              LOGPTR( RxContext ));

    Status = RxpQueryInfoMiniRdr( RxContext, 
                                  Fcb,
                                  FileEaInformation,
                                  Buffer );

    if ((IrpSp->Parameters.QueryFile.FileInformationClass == FileAllInformation) &&
        (Status == STATUS_NOT_IMPLEMENTED)) {
        
        RxContext->Info.LengthRemaining -= sizeof( FILE_EA_INFORMATION );
        Status = STATUS_SUCCESS;
    }

    RxDbgTrace(-1, Dbg, ("RxQueryEaInfo...Status %lx\n", Status));
    return Status;
}

NTSTATUS
RxQueryPositionInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_POSITION_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query position information function for fat.

Arguments:

    RxContext  - the RDBSS context
    
    Irp -
    
    Fcb -

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryPositionInfo...\n", 0) );
    RxLog(( "RxQueryPositionInfo\n" ));
    RxWmiLog( LOG,
              RxQueryPositionInfo,
              LOGPTR( RxContext ) );

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    RxContext->Info.LengthRemaining -= sizeof( FILE_POSITION_INFORMATION );

    RxDbgTrace( 0, Dbg, ("LengthRemaining = %08lx\n", RxContext->Info.LengthRemaining) );
    RxDbgTrace( -1, Dbg, ("RxQueryPositionInfo...Status %lx\n", Status) );
    return Status;

    UNREFERENCED_PARAMETER( Irp );
}

VOID
RxConjureOriginalName (
    IN PFCB Fcb,
    IN PFOBX Fobx,
    OUT PLONG ActualNameLength,
    IN PWCHAR OriginalName,
    IN OUT PLONG LengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    )
/*++
Routine Description:

    This routine conjures up the original name of an Fcb. it is used in querynameinfo below and
    also in RxCanonicalizeAndObtainPieces in the create path for relative opens. for relative opens, we return
    a name of the form \;m:\server\share\.....\name which is how it came down from createfile. otherwise, we give
    back the name relative to the vnetroot.

Arguments:

    Fcb - Supplies the Fcb whose original name is to be conjured

    ActualNameLength - the place to store the actual name length. not all of it will be conjured
                        if the buffer is too small.

    OriginalName - Supplies a pointer to the buffer where the name is to conjured

    LengthRemaining - Supplies the length of the Name buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

    VNetRootAsPrefix - if true, give back the name as "\;m:", if false, give it back w/o net part.

Return Value:

    None


--*/
{
    PNET_ROOT NetRoot = Fcb->NetRoot;
    PUNICODE_STRING NetRootName = &NetRoot->PrefixEntry.Prefix;
    PUNICODE_STRING FcbName = &Fcb->FcbTableEntry.Path;
    PWCHAR CopyBuffer,FcbNameBuffer;
    LONG BytesToCopy,BytesToCopy2;
    LONG FcbNameSuffixLength,PreFcbLength;
    LONG InnerPrefixLength;

    RX_NAME_CONJURING_METHODS OrigianlNameConjuringMethod = NameConjuringMethod;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxConjureOriginalFilename...\n", 0));
    RxDbgTrace(0, Dbg, ("--> NetRootName = %wZ\n", NetRootName));
    RxDbgTrace(0, Dbg, ("--> FcbNameName = %wZ\n", FcbName));
    RxDbgTrace(0, Dbg, ("--> ,AddedBS = %08lx\n",
                         FlagOn(Fcb->FcbState,FCB_STATE_ADDEDBACKSLASH)));

    //
    //  here, we have to copy in the vnetrootprefix and the servershare stuff.
    //  first figure out the size of the two pieces: prefcblength is the part that comes
    //  from the [v]netroot; fcbnamesuffix is the part that is left of the filename after
    //  the vnetroot prefix is skipped
    //
    
    if ((!Fcb->VNetRoot) ||
        (Fcb->VNetRoot->PrefixEntry.Prefix.Buffer[1] != L';') ||
        (FlagOn( Fobx->Flags, FOBX_FLAG_UNC_NAME )) ){

        CopyBuffer = NetRootName->Buffer;
        PreFcbLength = NetRootName->Length;
        InnerPrefixLength = 0;

        NameConjuringMethod = VNetRoot_As_Prefix; //  override whatever was passed

    } else {

        PV_NET_ROOT VNetRoot = Fcb->VNetRoot;
        PUNICODE_STRING VNetRootName = &VNetRoot->PrefixEntry.Prefix;

        ASSERT( NodeType( VNetRoot ) == RDBSS_NTC_V_NETROOT );
        RxDbgTrace( 0, Dbg, ("--> VNetRootName = %wZ\n", VNetRootName) );
        RxDbgTrace(0, Dbg, ("--> VNetRootNamePrefix = %wZ\n", &VNetRoot->NamePrefix) );

        InnerPrefixLength = VNetRoot->NamePrefix.Length;
        RxDbgTrace( 0, Dbg, ("--> ,IPrefixLen = %08lx\n", InnerPrefixLength) );

        CopyBuffer = VNetRootName->Buffer;
        PreFcbLength = VNetRootName->Length;

        if (NameConjuringMethod == VNetRoot_As_UNC_Name) {

            //
            //  move up past the drive information
            //

            for (;;) {
                CopyBuffer++; 
                PreFcbLength -= sizeof(WCHAR);
                if (PreFcbLength == 0) break;
                if (*CopyBuffer == L'\\') break;
            }
        }
    }

    if (FlagOn(Fcb->FcbState, FCB_STATE_ADDEDBACKSLASH )) {
        InnerPrefixLength += sizeof(WCHAR);
    }

    //
    //  next, Copyin the NetRoot Part  OR the VNetRoot part.
    //  If we overflow, set *LengthRemaining to -1 as a flag.
    //

    if (NameConjuringMethod != VNetRoot_As_DriveLetter) {

        if (*LengthRemaining < PreFcbLength) {

            BytesToCopy = *LengthRemaining;
            *LengthRemaining = -1;

        } else {

            BytesToCopy = PreFcbLength;
            *LengthRemaining -= BytesToCopy;
        }

        RtlCopyMemory( OriginalName,
                       CopyBuffer,
                       BytesToCopy );

        BytesToCopy2 = BytesToCopy;

    } else {

        PreFcbLength = 0;
        BytesToCopy2 = 0;

        if ((FcbName->Length > InnerPrefixLength) && 
            (*((PWCHAR)Add2Ptr( FcbName->Buffer , InnerPrefixLength )) != OBJ_NAME_PATH_SEPARATOR)) {
            
            InnerPrefixLength -= sizeof(WCHAR);
        }
    }

    FcbNameSuffixLength = FcbName->Length - InnerPrefixLength;

    if (FcbNameSuffixLength <= 0) {
        
        FcbNameBuffer = L"\\";
        FcbNameSuffixLength = 2;
        InnerPrefixLength = 0;

    } else {
        
        FcbNameBuffer = FcbName->Buffer;
    }

    //
    //  report how much is really needed
    //

    *ActualNameLength = PreFcbLength + FcbNameSuffixLength;

    //
    //  the netroot part has been copied; finally, copy in the part of the name
    //  that is past the prefix
    //

    if (*LengthRemaining != -1) {

        //
        //  Next, Copyin the Fcb Part
        //  If we overflow, set *LengthRemaining to -1 as a flag.
        //

        if (*LengthRemaining < FcbNameSuffixLength) {

            BytesToCopy = *LengthRemaining;
            *LengthRemaining = -1;

        } else {

            BytesToCopy = FcbNameSuffixLength;
            *LengthRemaining -= BytesToCopy;
        }

        RtlCopyMemory( Add2Ptr( OriginalName, PreFcbLength ),
                       Add2Ptr( FcbNameBuffer, InnerPrefixLength ),
                       BytesToCopy );
    } else {

        //  DbgPrint("No second copy\n");
        DbgDoit( BytesToCopy=0; );
    }

    RxDbgTrace(-1, Dbg, ("RxConjureOriginalFilename -> VOID\n", 0));

    return;
}

NTSTATUS
RxQueryNameInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx,
    IN OUT PFILE_NAME_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query name information function.  what makes this hard is that
    we have to return partial results.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS if the name fits
    STATUS_BUFFER_OVERFLOW otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    PLONG LengthRemaining = &RxContext->Info.LengthRemaining;
    LONG OriginalLengthRemaining = RxContext->Info.LengthRemaining;
    
    RxDbgTrace( +1, Dbg, ("RxQueryNameInfo...\n", 0) );
    RxLog(( "RxQueryNameInfo\n" ));
    RxWmiLog( LOG,
              RxQueryNameInfo,
              LOGPTR( RxContext ) );

    PAGED_CODE();

    *LengthRemaining -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    if (*LengthRemaining < 0) {
        *LengthRemaining = 0;
        Status = STATUS_BUFFER_OVERFLOW;
    } else {
        
        RxConjureOriginalName( Fcb,
                               Fobx,
                               &Buffer->FileNameLength,
                               &Buffer->FileName[0],
                               LengthRemaining,
                               VNetRoot_As_UNC_Name );

        RxDbgTrace( 0, Dbg, ("*LengthRemaining = %08lx\n", *LengthRemaining) );
        if (*LengthRemaining < 0) {
            
            *LengthRemaining = 0;
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }

    RxDbgTrace( -1, Dbg, ("RxQueryNameInfo -> %08lx\n", Status) );
    return Status;
    
    UNREFERENCED_PARAMETER( Irp );

}

NTSTATUS
RxQueryAlternateNameInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_NAME_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine queries the short name of the file.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryAlternateNameInfo...\n", 0) );
    RxLog(( "RxQueryAlternateNameInfo\n" ));
    RxWmiLog( LOG,
              RxQueryAlternateNameInfo,
              LOGPTR( RxContext ));

    Status = RxpQueryInfoMiniRdr( RxContext, 
                                  Fcb,
                                  FileAlternateNameInformation,
                                  Buffer );

    RxDbgTrace(-1, Dbg, ("RxQueryAlternateNameInfo...Status %lx\n", Status) );

    return Status;
    
    UNREFERENCED_PARAMETER( Irp );
}

NTSTATUS
RxQueryCompressedInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query compressed file size function for fat.
    This is only defined for compressed volumes.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryCompressedFileSize...\n", 0) );
    RxLog(( "RxQueryCompressedFileSize\n" ));
    RxWmiLog( LOG,
              RxQueryCompressedInfo,
              LOGPTR( RxContext ));

    //
    //  Start by flushing the file.  We have to do this since the compressed
    //  file size is not defined until the file is actually written to disk.
    // 

    Status = RxFlushFcbInSystemCache( Fcb, TRUE );

    if (!NT_SUCCESS( Status )) {
        RxNormalizeAndRaiseStatus( RxContext, Status );
    }

    Status = RxpQueryInfoMiniRdr( RxContext,
                                  Fcb,
                                  FileCompressionInformation,
                                  Buffer );

    RxDbgTrace( 0, Dbg, ("LengthRemaining = %08lx\n", RxContext->Info.LengthRemaining) );
    RxDbgTrace( -1, Dbg, ("RxQueryCompressedFileSize -> Status\n", Status) );

    return Status;

    UNREFERENCED_PARAMETER( Irp );
}


NTSTATUS
RxSetPipeInfo (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
   )
/*++
Routine Description:

    This routine updates the FILE_PIPE_INFORMATION/FILE_PIPE_REMOTE_INFORMATION
    associated with an instance of a named pipe

Arguments:

    RxContext -- the associated RDBSS context

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );    
    FILE_INFORMATION_CLASS FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxSetPipeInfo...\n", 0) );
    RxLog(( "RxSetPipeInfo\n" ));
    RxWmiLog( LOG,
              RxSetPipeInfo,
              LOGPTR( RxContext ));
    
    if (Fcb->NetRoot->Type != NET_ROOT_PIPE) {
        
        Status = STATUS_INVALID_PARAMETER;
    
    } else {
      
        switch (FileInformationClass) {
        case FilePipeInformation:
            
            if (IrpSp->Parameters.SetFile.Length == sizeof(FILE_PIPE_INFORMATION)) {
            
                PFILE_PIPE_INFORMATION PipeInfo = (PFILE_PIPE_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
            
                if ((PipeInfo->ReadMode != Fobx->Specific.NamedPipe.ReadMode) ||
                    (PipeInfo->CompletionMode != Fobx->Specific.NamedPipe.CompletionMode)) {

                    RxContext->Info.FileInformationClass = (FilePipeInformation);
                    RxContext->Info.Buffer = PipeInfo;
                    RxContext->Info.Length = sizeof(FILE_PIPE_INFORMATION);
                    
                    MINIRDR_CALL( Status,
                                  RxContext,
                                  Fcb->MRxDispatch,
                                  MRxSetFileInfo,
                                  (RxContext) );
            
                    if (Status == STATUS_SUCCESS) {
                        Fobx->Specific.NamedPipe.ReadMode = PipeInfo->ReadMode;
                        Fobx->Specific.NamedPipe.CompletionMode = PipeInfo->CompletionMode;
                    }
                }
            } else {
                
                Status = STATUS_INVALID_PARAMETER;
            
            }
            break;

        case FilePipeLocalInformation:
            Status = STATUS_INVALID_PARAMETER;
            break;
        case FilePipeRemoteInformation:
            if (IrpSp->Parameters.SetFile.Length == sizeof(FILE_PIPE_REMOTE_INFORMATION)) {
            
                PFILE_PIPE_REMOTE_INFORMATION PipeRemoteInfo = (PFILE_PIPE_REMOTE_INFORMATION)Irp->AssociatedIrp.SystemBuffer;
            
                Fobx->Specific.NamedPipe.CollectDataTime = PipeRemoteInfo->CollectDataTime;
                Fobx->Specific.NamedPipe.CollectDataSize = PipeRemoteInfo->MaximumCollectionCount;
            
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;
        
        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    
    
    RxDbgTrace( -1, Dbg, ("RxSetPipeInfo: Status ....%lx\n", Status) );
    return Status;

}

NTSTATUS
RxSetSimpleInfo (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++
Routine Description:

    This routine updates file information that is changed through
    a simple MiniRdr Call.
    Right now this consists of ShortNameInfo & ValdiDataLengthInfo

Arguments:

    RxContext -- the associated RDBSS context

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );    
    FILE_INFORMATION_CLASS FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //  
    //  logging code
    //

    RxDbgTrace( +1, Dbg, ("RxSetSimpleInfo: %d\n", FileInformationClass) );
    RxLog(( "RxSetSimpleInfo\n" ));
    RxWmiLog( LOG,
              RxSetSimpleInfo,
              LOGPTR( RxContext ));


    //
    //  call the MiniRdr
    //

    Status =  RxpSetInfoMiniRdr( RxContext, Irp, Fcb, FileInformationClass );

    //
    //  logging code
    //

    RxDbgTrace(-1, Dbg, ("RxSetSimpleInfo: Status ....%lx\n", Status) );
    return Status;
}

NTSTATUS
RxQueryPipeInfo(
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx,
    IN OUT PVOID Buffer
    )
/*++
Routine Description:

    This routine queries the FILE_PIPE_INFORMATION/FILE_PIPE_REMOTE_INFORMATION
    and FILE_PIPE_LOCAL_INFORMATION associated with an instance of a named pipe

Arguments:

    RxContext -- the associated RDBSS context

    Buffer   -- the buffer for query information

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );    
    FILE_INFORMATION_CLASS FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    PLONG LengthRemaining = &RxContext->Info.LengthRemaining;
   
    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxQueryPipeInfo...\n", 0) );
    RxLog(( "RxQueryPipeInfo\n" ));
    RxWmiLog( LOG,
              RxQueryPipeInfo,
              LOGPTR( RxContext ) );
    
    if (Fcb->NetRoot->Type != NET_ROOT_PIPE) {
        
        Status = STATUS_INVALID_PARAMETER;
    
    } else {
      
        switch (FileInformationClass) {
        case FilePipeInformation:
         
            if (*LengthRemaining >= sizeof(FILE_PIPE_INFORMATION)) {
            
                PFILE_PIPE_INFORMATION PipeInfo = (PFILE_PIPE_INFORMATION)Buffer;
    
                PipeInfo->ReadMode       = Fobx->Specific.NamedPipe.ReadMode;
                PipeInfo->CompletionMode = Fobx->Specific.NamedPipe.CompletionMode;
    
                //
                //  Update the buffer length
                //

                *LengthRemaining -= sizeof( FILE_PIPE_INFORMATION );
         
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
            break;

        case FilePipeLocalInformation:
         
          if (*LengthRemaining >= sizeof( FILE_PIPE_LOCAL_INFORMATION )) {
            
              PFILE_PIPE_LOCAL_INFORMATION pPipeLocalInfo = (PFILE_PIPE_LOCAL_INFORMATION)Buffer;
    
              Status = RxpQueryInfoMiniRdr( RxContext, 
                                            Fcb, 
                                            FilePipeLocalInformation,
                                            Buffer );
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
            break;
      
        case FilePipeRemoteInformation:
         
            if (*LengthRemaining >= sizeof(FILE_PIPE_REMOTE_INFORMATION)) {
            
                PFILE_PIPE_REMOTE_INFORMATION PipeRemoteInfo = (PFILE_PIPE_REMOTE_INFORMATION)Buffer;
    
                PipeRemoteInfo->CollectDataTime = Fobx->Specific.NamedPipe.CollectDataTime;
                PipeRemoteInfo->MaximumCollectionCount = Fobx->Specific.NamedPipe.CollectDataSize;
    
                //
                //  Update the buffer length
                //
                
                *LengthRemaining -= sizeof( FILE_PIPE_REMOTE_INFORMATION );
         
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
            break;

        default:
         
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    
    RxDbgTrace( 0, Dbg, ("RxQueryPipeInfo: *LengthRemaining = %08lx\n", *LengthRemaining) );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Rx called by the
    dispatch driver.


Author:

    Joe Linn     [JoeLinn]    sep-9-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CLOSE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

enum _CLOSE_DEBUG_BREAKPOINTS {
    CloseBreakPoint_BeforeCloseFakeFcb = 1,
    CloseBreakPoint_AfterCloseFakeFcb
};

VOID
RxCloseFcbSection (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonClose)
#pragma alloc_text(PAGE, RxCloseFcbSection)
#pragma alloc_text(PAGE, RxCloseAssociatedSrvOpen)
#endif

NTSTATUS
RxCommonClose ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    Close is invoked whenever the last reference to a file object is deleted.
    Cleanup is invoked when the last handle to a file object is closed, and
    is called before close.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The CLOSE handling strategy in RDBSS is predicated upon the axiom that the
    workload on the server should be minimized as and when possible.

    There are a number of applications which repeatedly close and open the same
    file, e.g., batch file processing. In these cases the same file is opened,
    a line/buffer is read, the file is closed and the same set of operations are
    repeated over and over again.

    This is handled in RDBSS by a delayed processing of the CLOSE request. There
    is a delay ( of about 10 seconds ) between completing the request and initiating
    processing on the request. This opens up a window during which a subsequent
    OPEN can be collapsed onto an existing SRV_OPEN. The time interval can be tuned
    to meet these requirements.

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFCB Fcb;
    PFOBX Fobx;

    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN AcquiredFcb = FALSE;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx ); 

    RxDbgTrace( +1, Dbg, ("RxCommonClose IrpC/Fobx/Fcb = %08lx %08lx %08lx\n",
                RxContext, Fobx, Fcb) );
    RxLog(( "CClose %lx %lx %lx %lx\n", RxContext, Fobx, Fcb, FileObject ));
    RxWmiLog( LOG,
              RxCommonClose_1,
              LOGPTR( RxContext )
              LOGPTR( Fobx )
              LOGPTR( Fcb )
              LOGPTR( FileObject ) );

    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( -1, Dbg, ("RxCommonClose Cannot acquire FCB(%lx) %lx\n", Fcb, Status ));
        return Status;
    }

    AcquiredFcb = TRUE;

    try {

        PSRV_OPEN SrvOpen = NULL;
        BOOLEAN DelayClose = FALSE;

        switch (TypeOfOpen) {
        case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        case RDBSS_NTC_STORAGE_TYPE_FILE:
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
        case RDBSS_NTC_OPENTARGETDIR_FCB:
        case RDBSS_NTC_IPC_SHARE:
        case RDBSS_NTC_MAILSLOT:
        case RDBSS_NTC_SPOOLFILE:

            RxDbgTrace( 0, Dbg, ("Close UserFileOpen/UserDirectoryOpen/OpenTargetDir %04lx\n", TypeOfOpen ));

            RxReferenceNetFcb( Fcb );

            if (Fobx) {
                
                SrvOpen = Fobx->SrvOpen;

                if ((NodeType( Fcb ) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) &&
                    (!FlagOn( Fcb->FcbState, FCB_STATE_ORPHANED )) &&
                    (!FlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE )) &&
                    (FlagOn( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED ))) {
                    
                    PSRV_CALL SrvCall = Fcb->NetRoot->SrvCall;

                    RxLog(( "@@@@DelayCls FOBX %lx SrvOpen %lx@@\n", Fobx, SrvOpen ));
                    RxWmiLog( LOG,
                              RxCommonClose_2,
                              LOGPTR( Fobx )
                              LOGPTR( SrvOpen ) );

                    //
                    //  If this is the last open instance and the close is being delayed
                    //  mark the SRV_OPEN. This will enable us to respond to buffering
                    //  state change requests with a close operation as opposed to
                    //  the regular flush/purge response.

                    //
                    //  We also check the COLLAPSING_DISABLED flag to determine whether its even necessary to delay
                    //  close the file.  If we cannot collapse the open, no reason to delay its closure.  Delaying here
                    //  caused us to stall for 10 seconds on an oplock break to a delay closed file because the final close
                    //  caused by the break was delay-closed again, resulting in a delay before the oplock break is satisfied.
                    //

                    if ( (SrvOpen->OpenCount == 1) && !FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_COLLAPSING_DISABLED )) {
                        
                        if (InterlockedIncrement( &SrvCall->NumberOfCloseDelayedFiles ) <
                            SrvCall->MaximumNumberOfCloseDelayedFiles) {

                            DelayClose = TRUE;
                            SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_CLOSE_DELAYED );
                        
                        } else {
                            
                            RxDbgTrace( 0, Dbg, ("Not delaying files because count exceeded limit\n") );
                            InterlockedDecrement( &SrvCall->NumberOfCloseDelayedFiles );
                        }
                    }
                }

                if (!DelayClose) {
                    PNET_ROOT NetRoot = (PNET_ROOT)Fcb->NetRoot;

                    if ((NetRoot->Type != NET_ROOT_PRINT) &&
                        FlagOn( Fobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE )) {

                        RxScavengeRelatedFobxs( Fcb );
                        RxSynchronizeWithScavenger( RxContext, Fcb );
                        RxReleaseFcb( NULL, Fcb );

                        RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE);
                        RxOrphanThisFcb( Fcb );
                        RxReleaseFcbTableLock( &NetRoot->FcbTable );

                        Status = RxAcquireExclusiveFcb( NULL, Fcb );
                        ASSERT( Status == STATUS_SUCCESS );
                    }
                }

                RxMarkFobxOnClose( Fobx );
            }

            if (!DelayClose) {
                Status = RxCloseAssociatedSrvOpen( RxContext, Fobx );

                if (Fobx != NULL) {
                    RxDereferenceNetFobx( Fobx, LHS_ExclusiveLockHeld );
                }
            } else {
                ASSERT(Fobx != NULL);
                RxDereferenceNetFobx( Fobx, LHS_SharedLockHeld );
            }

            AcquiredFcb = !RxDereferenceAndFinalizeNetFcb( Fcb, RxContext, FALSE, FALSE );
            FileObject->FsContext = IntToPtr( 0xffffffff );

            if (AcquiredFcb) {
                AcquiredFcb = FALSE;
                RxReleaseFcb( RxContext, Fcb );
            } else {

                //
                //  the tracker gets very unhappy if you don't do this!
                //

                RxTrackerUpdateHistory( RxContext, NULL, 'rrCr', __LINE__, __FILE__, 0 );
            }
            break;

        default:
            RxBugCheck( TypeOfOpen, 0, 0 );
            break;
        }
    } finally {
        if (AbnormalTermination()) {
            if (AcquiredFcb) {
                RxReleaseFcb( RxContext, Fcb );
            }
        } else {
            ASSERT( !AcquiredFcb );
        }

        RxDbgTrace(-1, Dbg, ("RxCommonClose -> %08lx\n", Status));
    }

    return Status;
}

VOID
RxCloseFcbSection (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb
    )
/*++

Routine Description:

    This routine initiates the flush and close of the image secton associated 
    with an FCB instance

Arguments:

    RxContext - the context
    
    Fcb - the fcb instance for which close processing is to be initiated

Return Value:

Notes:

    On entry to this routine the FCB must have been accquired exclusive.

    On exit there is no change in resource ownership

--*/
{
    NTSTATUS Status;
    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("CleanupPurge:MmFlushImage\n", 0));

    MmFlushImageSection( &Fcb->NonPaged->SectionObjectPointers, MmFlushForWrite );

    //
    //  we don't pass in the context here because it is not necessary to track this
    //  release because of the subsequent acquire...........
    //

    RxReleaseFcb( NULL, Fcb );

    MmForceSectionClosed( &Fcb->NonPaged->SectionObjectPointers, TRUE );

    Status = RxAcquireExclusiveFcb( NULL, Fcb );
    ASSERT( Status == STATUS_SUCCESS );
}

NTSTATUS
RxCloseAssociatedSrvOpen (
    IN OUT PRX_CONTEXT RxContext OPTIONAL,
    IN OUT PFOBX Fobx
    )
/*++

Routine Description:

    This routine initiates the close processing for an FOBX. The FOBX close
    processing can be trigerred in one of three ways ....

    1) Regular close processing on receipt of the IRP_MJ_CLOSE for the associated
    file object.

    2) Delayed close processing while scavenging the FOBX. This happens when the
    close processing was delayed in anticipation of an open and no opens are
    forthcoming.

    3) Delayed close processing on receipt of a buffering state change request
    for a close that was delayed.

Arguments:

    RxContext - the context parameter is NULL for case (2).

    Fobx     - the FOBX instance for which close processing is to be initiated.
                It is NULL for MAILSLOT files.

Return Value:

Notes:

    On entry to this routine the FCB must have been accquired exclusive.

    On exit there is no change in resource ownership

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PFCB Fcb;
    PSRV_OPEN SrvOpen;
    PRX_CONTEXT LocalRxContext = RxContext;

    PAGED_CODE();

    // 
    //  Distinguish between those cases where there is a real SRV_OPEN instance
    //  from those that do not have one, e.g., mailslot files.
    //

    if (Fobx == NULL) {
        if (RxContext != NULL) {
            Fcb = (PFCB)(RxContext->pFcb);
            SrvOpen = NULL;
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        
        if (FlagOn( Fobx->Flags, FOBX_FLAG_SRVOPEN_CLOSED )) {
            
            RxMarkFobxOnClose( Fobx );
            Status = STATUS_SUCCESS;
        
        } else {
            
            SrvOpen = Fobx->SrvOpen;
            if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSED )) {
                
                Fcb = SrvOpen->Fcb;

                ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

                SetFlag( Fobx->Flags, FOBX_FLAG_SRVOPEN_CLOSED );

                if (SrvOpen->OpenCount > 0) {
                    SrvOpen->OpenCount -= 1;
                }

                RxMarkFobxOnClose( Fobx );
                Status = STATUS_SUCCESS;
            } else {
                Fcb = SrvOpen->Fcb;
            }

            ASSERT( (RxContext == NULL) || (Fcb == (PFCB)RxContext->pFcb) );
        }
    }

    //
    //  If there is no corresponding open on the server side or if the close
    //  processing has already been accomplished there is no further processing
    //  required. In other cases w.r.t scavenged close processing a new
    //  context might have to be created.
    // 

    if ((Status == STATUS_MORE_PROCESSING_REQUIRED) && (RxContext == NULL)) {
        
        LocalRxContext = RxCreateRxContext( NULL,
                                            SrvOpen->Fcb->RxDeviceObject,
                                            RX_CONTEXT_FLAG_WAIT | RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING );

        if (LocalRxContext != NULL) {
            
            LocalRxContext->MajorFunction = IRP_MJ_CLOSE;
            LocalRxContext->pFcb = (PMRX_FCB)Fcb;
            LocalRxContext->pFobx = (PMRX_FOBX)Fobx;
            
            if (Fobx != NULL) {
                LocalRxContext->pRelevantSrvOpen = (PMRX_SRV_OPEN)(Fobx->SrvOpen);
            }
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    //  if the context creation was successful and the close processing for
    //  the SRV_OPEN instance needs to be initiated with the mini rdr
    //  proceed.
    //

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        
        ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

        ///
        //  Mark the Fobx instance on the initiation of the close operation. This
        //  is the complement to the action taken on cleanup. It ensures
        //  that the infrastructure setup for delayed close processing is undone.
        //  For those instances in which the FOBS is NULL the FCB is manipulated
        //  directly
        //

        if (Fobx != NULL) {
            RxMarkFobxOnClose( Fobx );
        } else {
            InterlockedDecrement( &Fcb->OpenCount );
        }

        if (SrvOpen != NULL) {
            if (SrvOpen->Condition == Condition_Good) {
                if (SrvOpen->OpenCount > 0) {
                    SrvOpen->OpenCount -= 1;
                }

                if (SrvOpen->OpenCount == 1) {
                    if (!IsListEmpty( &SrvOpen->FobxList )) {
                        
                        PFOBX RemainingFobx;

                        RemainingFobx = CONTAINING_RECORD( SrvOpen->FobxList.Flink,
                                                           FOBX,
                                                           FobxQLinks );

                        if (!IsListEmpty( &RemainingFobx->ScavengerFinalizationList )) {
                            SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_CLOSE_DELAYED );
                        }
                    }
                }

                //
                //  Purge the FCB before initiating the close processing with
                //  the mini redirectors
                //

                if ((SrvOpen->OpenCount == 0) &&
                    (Status == STATUS_MORE_PROCESSING_REQUIRED) &&
                    (RxContext == NULL)) {
                    
                    RxCloseFcbSection( LocalRxContext, Fcb );
                }

                //
                //  Since RxCloseFcbSections drops and reacquires the resource, ensure that
                //  the SrvOpen is still valid before proceeding with the
                //  finalization.
                //

                SrvOpen = Fobx->SrvOpen;

                if ((SrvOpen != NULL) &&
                    ((SrvOpen->OpenCount == 0) ||
                     (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_ORPHANED ))) &&
                    !FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSED ) &&
                    (Status == STATUS_MORE_PROCESSING_REQUIRED)) {
                    
                    ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

                    MINIRDR_CALL( Status,
                                  LocalRxContext,
                                  Fcb->MRxDispatch,
                                  MRxCloseSrvOpen,
                                  (LocalRxContext) );

                    RxLog(( "MRXClose %lx %lx %lx %lx %lx\n", RxContext, Fcb, SrvOpen, Fobx, Status ));
                    RxWmiLog( LOG,
                              RxCloseAssociatedSrvOpen,
                              LOGPTR( RxContext )
                              LOGPTR( Fcb )
                              LOGPTR( SrvOpen )
                              LOGPTR( Fobx )
                              LOGULONG( Status ) );

                    SetFlag( SrvOpen->Flags,  SRVOPEN_FLAG_CLOSED );

                    //
                    // Since the SrvOpen has been closed (the close for the
                    // Fid was sent to the server above) we need to reset
                    // the Key.
                    //
                    SrvOpen->Key = (PVOID) (ULONG_PTR) 0xffffffff;

                    if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSE_DELAYED )) {
                        InterlockedDecrement( &Fcb->NetRoot->SrvCall->NumberOfCloseDelayedFiles );
                    }

                    RxRemoveShareAccessPerSrvOpens( SrvOpen );

                    //
                    //  Ensure that any buffering state change requests for this
                    //  SRV_OPEN instance which was closed is purged from the
                    //  buffering manager data structures.
                    //

                    RxPurgeChangeBufferingStateRequestsForSrvOpen( SrvOpen );

                    RxDereferenceSrvOpen( SrvOpen, LHS_ExclusiveLockHeld );
                
                } else {
                    Status = STATUS_SUCCESS;
                }

                SetFlag( Fobx->Flags, FOBX_FLAG_SRVOPEN_CLOSED );
            } else {
                Status = STATUS_SUCCESS;
            }
        } else {
            
            ASSERT( (NodeType( Fcb ) == RDBSS_NTC_OPENTARGETDIR_FCB) ||
                    (NodeType( Fcb ) == RDBSS_NTC_IPC_SHARE) ||
                    (NodeType( Fcb ) == RDBSS_NTC_MAILSLOT) );
            
            RxDereferenceNetFcb( Fcb );
            Status = STATUS_SUCCESS;
        }

        if (LocalRxContext != RxContext) {
            RxDereferenceAndDeleteRxContext( LocalRxContext );
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\devctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Rx
    called by the dispatch driver.

Author:

Revision History:

   Balan Sethu Raman [19-July-95] -- Hook it up to the mini rdr call down.

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntddmup.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVCTRL)

NTSTATUS
RxLowIoIoCtlShellCompletion ( 
    IN PRX_CONTEXT RxContext
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDeviceControl)
#pragma alloc_text(PAGE, RxLowIoIoCtlShellCompletion)
#endif


NTSTATUS
RxCommonDeviceControl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing Device control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFCB Fcb;
    PFOBX Fobx;

    BOOLEAN SubmitLowIoRequest = TRUE;
    ULONG IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCommonDeviceControl\n", 0 ));
    RxDbgTrace( 0, Dbg, ("Irp           = %08lx\n", Irp ));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", IrpSp->MinorFunction));

    RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if (IoControlCode == IOCTL_REDIR_QUERY_PATH) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        SubmitLowIoRequest = FALSE;
    }

    if (SubmitLowIoRequest) {
        
        RxInitializeLowIoContext( RxContext, LOWIO_OP_IOCTL, &RxContext->LowIoContext );
        Status = RxLowIoSubmit( RxContext, Irp, Fcb, RxLowIoIoCtlShellCompletion );

        if (Status == STATUS_PENDING) {
            
            //
            //  Another thread will complete the request, but we must remove our reference count.
            //

            RxDereferenceAndDeleteRxContext( RxContext );
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDeviceControl -> %08lx\n", Status));
    return Status;
}

NTSTATUS
RxLowIoIoCtlShellCompletion ( 
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the completion routine for IoCtl requests passed down to the mini rdr

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIRP Irp = RxContext->CurrentIrp;
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    
    PAGED_CODE();

    Status = RxContext->StoredStatus;
    
    RxDbgTrace( +1, Dbg, ("RxLowIoIoCtlShellCompletion  entry  Status = %08lx\n", Status) );

    switch (Status) {   //  may be success vs warning vs error
    case STATUS_SUCCESS:
    case STATUS_BUFFER_OVERFLOW:
       Irp->IoStatus.Information = RxContext->InformationToReturn;
       break;
    default:
       break;
    }

    Irp->IoStatus.Status = Status;
    RxDbgTrace( -1, Dbg, ("RxLowIoIoCtlShellCompletion  exit  Status = %08lx\n", Status) );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Rx called by the
    dispatch driver.

    The implementation of SL_OPEN_TARGET_DIRECTORY is a bit unusual...we don't
    actually do it unless the minirdr specifically requests it.
    Instead, we just get the fcb built and then return it. The nodetype is set so
    that no operations can be done except close/cleanup. In this way, we will not
    take an extra trip to the server or a trip to an incorrect server for rename
    operations. If SL_OPEN... can be used for something other than rename, a
    minirdr that uses this facility is toast.

Author:

    Joe Linn      [JoeLinn]    8-aug-94

Revision History:

    Balan Sethu Raman [SethuR]    17-July-95

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntddmup.h>
#include <fsctlbuf.h>
#include <dfsfsctl.h>

#if 0 && defined(REMOTE_BOOT)
BOOLEAN LogAllFiles = FALSE;
BOOLEAN WatchAllFiles = FALSE;
BOOLEAN FirstWatchOnly = FALSE;
BOOLEAN IsFirstWatch = TRUE;
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

#ifdef LOG_SHARINGCHECKS
#define RxLogForSharingCheck(x) RxLog(x)
#else
#define RxLogForSharingCheck(x)
#endif

#if DBG
#define DEBUG_TAG(___xxx) ,(___xxx)
#else
#define DEBUG_TAG(_xxx)
#endif

LUID RxSecurityPrivilege = { SE_SECURITY_PRIVILEGE, 0 };

#define StorageType(co) ((co) & FILE_STORAGE_TYPE_MASK)
#define StorageFlag(co) ((co) & FILE_STORAGE_TYPE_SPECIFIED)
#define IsStorageTypeSpecified(co)  (StorageFlag(co) == FILE_STORAGE_TYPE_SPECIFIED)
#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)

//
// Where 0 represents a SessionId, the following path formats are used:
//
// "\;m:0\Server\Share" for drive based connections
//
// "\;:0\Server\Share"  for UNC based connections
//
// The SessionId is always 0 for NT 5, and a number representing a
// unique session for Hydra.
//
#define DRIVE_BASED_PATH_IDENTIFIER (L';')

//
//  The following is used to enable tracing when a specific file name is seen.
//  Tracing continues for a specified number of IRPs.
//  Usage:
//  Break in with debugger and set DbgTriggerNameStr to the ansi string for the
//  file name to trigger on (with trailing null).
//  Set DbgTriggerIrpCount to the number of IRPs to trace after the Create is
//  seen on the name string.
//  Set DbgTriggerState to zero and then continue.
//
#ifdef RDBSSTRACE

UNICODE_STRING DbgTriggerUStr = {0,0,NULL};
STRING DbgTriggerNameStr = {0,0,NULL};
CHAR DbgTriggerName[120] = "\\;F:\\davidor4\\nb4\\clients\\client1\\~DMTMP\\WINWORD\\~WRD0003.tmp";
#define DBG_TRIGGER_INIT 0
#define DBG_TRIGGER_LOOKING 1
#define DBG_TRIGGER_FOUND 2
ULONG DbgTriggerState = DBG_TRIGGER_FOUND;
ULONG DbgTriggerIrpCount = 130;
ULONG RxGlobalTraceIrpCount = 0;

#endif

extern BOOLEAN DisableByteRangeLockingOnReadOnlyFiles;
#define SPOOLER_PROCESS_NAME "spoolsv.exe"

VOID
RxSetFullNameInFcb (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING FinalName
    );

VOID
RxCopyCreateParameters (
    PRX_CONTEXT RxContext
    );

VOID
RxFreeCanonicalNameBuffer (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
RxAllocateCanonicalNameBuffer (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING CanonicalName,
    IN ULONG BufferSizeRequired);

NTSTATUS
RxFirstCanonicalize (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING CanonicalName,
    OUT PNET_ROOT_TYPE NetRootType
    );

NTSTATUS
RxCanonicalizeFileNameByServerSpecs (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING RemainingName
    );

NTSTATUS
RxCanonicalizeNameAndObtainNetRoot (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING RemainingName
    );

NTSTATUS
RxFindOrCreateFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING RemainingName,
    OUT PFCB *Fcb
    );

VOID
RxSetupNetFileObject (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxSearchForCollapsibleOpen (
    IN OUT PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess
    );

NTSTATUS
RxCollapseOrCreateSrvOpen (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxCreateFromNetRoot (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
RxCreateTreeConnect (
    IN PRX_CONTEXT RxContext
    );

UCHAR *
PsGetProcessImageFileName(
    PEPROCESS Process
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonCreate)
#pragma alloc_text(PAGE, RxAllocateCanonicalNameBuffer)
#pragma alloc_text(PAGE, RxFreeCanonicalNameBuffer)
#pragma alloc_text(PAGE, RxFirstCanonicalize)
#pragma alloc_text(PAGE, RxCanonicalizeFileNameByServerSpecs)
#pragma alloc_text(PAGE, RxCanonicalizeNameAndObtainNetRoot)
#pragma alloc_text(PAGE, RxFindOrCreateFcb)
#pragma alloc_text(PAGE, RxSearchForCollapsibleOpen)
#pragma alloc_text(PAGE, RxCollapseOrCreateSrvOpen)
#pragma alloc_text(PAGE, RxSetupNetFileObject)
#pragma alloc_text(PAGE, RxCreateFromNetRoot)
#pragma alloc_text(PAGE, RxPrefixClaim)
#pragma alloc_text(PAGE, RxCreateTreeConnect)
#pragma alloc_text(PAGE, RxCheckShareAccessPerSrvOpens)
#pragma alloc_text(PAGE, RxUpdateShareAccessPerSrvOpens)
#pragma alloc_text(PAGE, RxRemoveShareAccessPerSrvOpens)
#pragma alloc_text(PAGE, RxGetSessionId)
#endif

#if DBG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDumpWantedAccess)
#pragma alloc_text(PAGE, RxDumpCurrentAccess)
#pragma alloc_text(PAGE, RxCheckShareAccess)
#pragma alloc_text(PAGE, RxRemoveShareAccess)
#pragma alloc_text(PAGE, RxSetShareAccess)
#pragma alloc_text(PAGE, RxUpdateShareAccess)
#endif
#endif


INLINE VOID
RxCopyCreateParameters (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This uses the RxContext as a base to reach out and get the values of the NT
    create parameters. The idea is to centralize this code.

    It also implements such as ideas as (a) it must be a directory if a backslash
    was stripped and (b) unbuffered is translated to write-through.

Arguments:

    RxContext - the context instance

Notes:

--*/
{
    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    RxDbgTrace(+1, Dbg, ("RxCopyCreateParameters\n"));

    cp->SecurityContext = IrpSp->Parameters.Create.SecurityContext;

    if ((cp->SecurityContext->AccessState != NULL) &&
        (cp->SecurityContext->AccessState->SecurityDescriptor != NULL)) {

        //
        //  Note: Io subsystem captures and verifies security descriptor in irp
        //

        RxContext->Create.SdLength = RtlLengthSecurityDescriptor( cp->SecurityContext->AccessState->SecurityDescriptor );

        RxDbgTrace( 0, Dbg, ("->SecurityCtx/SdLength    = %08lx %08lx\n",
                             cp->SecurityContext,
                             RxContext->Create.SdLength ));
        RxLog(( " SDss %lx %lx\n", cp->SecurityContext, RxContext->Create.SdLength ));
        RxWmiLog( LOG,
                  RxCopyCreateParameters_1,
                  LOGPTR( cp->SecurityContext )
                  LOGULONG(RxContext->Create.SdLength ));
    }

    if (cp->SecurityContext->SecurityQos != NULL) {
        cp->ImpersonationLevel = cp->SecurityContext->SecurityQos->ImpersonationLevel;
    } else {
        cp->ImpersonationLevel =  DEFAULT_IMPERSONATION_LEVEL;
    }

    cp->DesiredAccess = cp->SecurityContext->DesiredAccess;
    cp->AllocationSize = Irp->Overlay.AllocationSize;
    cp->FileAttributes = FlagOn( IrpSp->Parameters.Create.FileAttributes, FILE_ATTRIBUTE_VALID_FLAGS );
    cp->ShareAccess = FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_VALID_FLAGS );
    cp->Disposition = (((IrpSp->Parameters.Create.Options)) >> 24) & 0x000000ff;
    cp->CreateOptions = FlagOn( IrpSp->Parameters.Create.Options, FILE_VALID_OPTION_FLAGS );


    cp->DfsNameContext = FileObject->FsContext;
    cp->DfsContext    = FileObject->FsContext2;

    ASSERT( (cp->DfsContext == NULL) ||
            (cp->DfsContext == UIntToPtr( DFS_OPEN_CONTEXT )) ||
            (cp->DfsContext == UIntToPtr( DFS_DOWNLEVEL_OPEN_CONTEXT )) ||
            (cp->DfsContext == UIntToPtr( DFS_CSCAGENT_NAME_CONTEXT )) ||
            (cp->DfsContext == UIntToPtr( DFS_USER_NAME_CONTEXT )) );

    ASSERT( (cp->DfsNameContext == NULL) ||
            (cp->DfsNameContext->NameContextType == DFS_OPEN_CONTEXT) ||
            (cp->DfsNameContext->NameContextType == DFS_DOWNLEVEL_OPEN_CONTEXT) ||
            (cp->DfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT) ||
            (cp->DfsNameContext->NameContextType == DFS_USER_NAME_CONTEXT) );

    FileObject->FsContext2 = NULL;
    FileObject->FsContext = NULL;

    //
    //  The FsContext field was placed as the pFcb in the RX_CONTEXT.  Clear it also
    //

    RxContext->pFcb = NULL;

    if (FlagOn( RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH )){
        SetFlag( cp->CreateOptions, FILE_DIRECTORY_FILE );
    }

    RxContext->Create.ReturnedCreateInformation = 0;

    RxContext->Create.EaLength = IrpSp->Parameters.Create.EaLength;
    if (RxContext->Create.EaLength) {
        RxContext->Create.EaBuffer = Irp->AssociatedIrp.SystemBuffer;

        RxDbgTrace( 0, Dbg, ("->System(Ea)Buffer/EALength    = %08lx %08lx\n",
                                     Irp->AssociatedIrp.SystemBuffer,
                                     IrpSp->Parameters.Create.EaLength ));
        RxLog(( " EAs %lx %lx\n",
                Irp->AssociatedIrp.SystemBuffer,
                IrpSp->Parameters.Create.EaLength ));
        RxWmiLog( LOG,
                  RxCopyCreateParameters_2,
                  LOGPTR( Irp->AssociatedIrp.SystemBuffer )
                  LOGULONG( IrpSp->Parameters.Create.EaLength ));
    } else {
        RxContext->Create.EaBuffer = NULL;
    }

    RxDbgTrace(-1, Dbg, ("RxCopyNtCreateParameters\n"));
}


VOID
RxFreeCanonicalNameBuffer(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called to free the canonical name buffer and reset the state.
    COULD BE INLINED!

Arguments:

    RxContext - the current workitem

Return Value:

    none

--*/
{
    ASSERT( RxContext->Create.CanonicalNameBuffer == RxContext->AlsoCanonicalNameBuffer );
    if (RxContext->Create.CanonicalNameBuffer) {
        RxFreePool( RxContext->Create.CanonicalNameBuffer );
        RxContext->Create.CanonicalNameBuffer = NULL;
        RxContext->AlsoCanonicalNameBuffer = NULL;
    }
    ASSERT( RxContext->Create.CanonicalNameBuffer == NULL );
}

NTSTATUS
RxAllocateCanonicalNameBuffer(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING CanonicalName,
    IN ULONG BufferSizeRequired
    )
/*++

Routine Description:

    Allocate a new unicode string buffer in the CanonicalName and cache the buffer
    in the rxcontext

Arguments:

    RxContext - the current workitem

    CanonicalName - the canonicalized name

    BufferSizeRequired - Size of the canonical name buffer

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       SUCCESS means that everything worked and processing should continue
       otherwise....failcomplete the operation.

--*/
{
    PAGED_CODE();

    ASSERT (RxContext->Create.CanonicalNameBuffer == NULL);

    CanonicalName->Buffer = (PWCHAR)RxAllocatePoolWithTag(
                                        PagedPool | POOL_COLD_ALLOCATION,
                                        BufferSizeRequired,
                                        RX_MISC_POOLTAG);

    if (CanonicalName->Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RxDbgTrace(0, Dbg, ("RxAllocateCanonicalNameBuffer allocated %08lx length %08lx\n",
                                CanonicalName->Buffer,BufferSizeRequired));

    RxContext->Create.CanonicalNameBuffer = CanonicalName->Buffer;
    RxContext->AlsoCanonicalNameBuffer = CanonicalName->Buffer;
    CanonicalName->MaximumLength = (USHORT)BufferSizeRequired;
    CanonicalName->Length = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
RxFirstCanonicalize (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING CanonicalName,
    OUT PNET_ROOT_TYPE NetRootType
    )
/*++

Routine Description:

    This routine is called to perform the first level of canonicalization on the
    name. Essentially, this amounts to copying the name and then upcasing the
    first or the first/second components. In addition for pipe/mailslot UNC names
    the appropriate mapping from  pipe,mailslot to IPC$ is done by this routine.
    This routine also adds the appropriate prefix to distinguish deviceless
    connects(UNC names ).

    In addition to canonicalization this routine also deduces the NET_ROOT_TYPE by
    the information provided in the UNC name.

    Last, as a side effect of this call, the UNC_NAME flag of the RX_CONTEXT is
    set to record that this name came in as a UNC_NAME. This is finally stored in
    the FOBX and used in conjuring the original filename for QueryInfoFile/NameInfo.

Arguments:

    RxContext     - the current workitem

    FileName      - the initial filename

    CanonicalName - the canonicalized name

    NetRootType  - placeholder for the deduced net root type

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       SUCCESS means that everything worked and processing should continue
       otherwise....failcomplete the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG    CanonicalNameLength;
    BOOLEAN  SynthesizeCanonicalName = FALSE;
    BOOLEAN  UNCName = FALSE;
    BOOLEAN  MungeNameForDevicelessTreeConnect = FALSE;
    NET_ROOT_TYPE  DeducedNetRootType = NET_ROOT_WILD;

    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RemainingName;
    ULONG SessionId;
    WCHAR IdBuffer[16]; // From RtlIntegerToUnicodeString()
    UNICODE_STRING IdString;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFirstCanonicalize entry, filename=%wZ\n",FileName));

    //
    // The FileName->Length cannot be less than two WCHARs.
    //
    if ( FileName->Length < (2 * sizeof(WCHAR)) ) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    //  for core servers in particular, it's important to get the service string correct.......
    //  so, if this is a devicefull netuse the we will get the netroottype by looking at the string
    //

    if ((FileName->Length > sizeof( L"\\;m:") ) &&
        (FileName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR) &&
        (FileName->Buffer[1] == DRIVE_BASED_PATH_IDENTIFIER)) {

        //
        //  it looks like a deviceful netuse.....look for the "early colon"
        //  The following test for the classification of net root types is predicated
        //  upon the use of single drive letters for Disk files and multiple letters
        //  for print shares. This will have to be reworked when the support for
        //  extended drive letters is provided.
        //

        if (FileName->Buffer[3] == L':') {
            DeducedNetRootType = NET_ROOT_DISK;
        } else {
            DeducedNetRootType = NET_ROOT_PRINT;
        }

        CanonicalNameLength = FileName->Length;
        SynthesizeCanonicalName = FALSE;

    //
    //  Parse all names of the form "\name" where name does not begin with a semicolon
    //

    } else  if ((FileName->Length >= sizeof( WCHAR ) * 2) &&
                (FileName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR) &&
                (FileName->Buffer[1] != DRIVE_BASED_PATH_IDENTIFIER)) {

        PWCHAR Buffer;
        PWCHAR EndOfName;

        //
        //  This is a UNC path name presented by the user.
        //

        RemainingName.Length = RemainingName.MaximumLength = FileName->Length - sizeof( WCHAR );
        RemainingName.Buffer = &FileName->Buffer[1];
        UNCName = TRUE;
        SetFlag( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME );

        //
        //  UNC tree connect path names have the following format:
        //  "\;:0\Server\Share where 0 represents the SessionId of the session.
        //

        SessionId = RxGetSessionId( IrpSp );
        IdString.Length = 0;
        IdString.MaximumLength = sizeof( IdBuffer );
        IdString.Buffer = IdBuffer;

        //
        //  NOTE: SessionId is a ulong which will always fit in IdString buffer so
        //  we can skip checking the return code
        //

        Status = RtlIntegerToUnicodeString( SessionId, 10, &IdString );
        ASSERT( STATUS_SUCCESS == Status );

        //
        //  scan until the second separator. This will give us the server name.
        //

        ServerName.Buffer = RemainingName.Buffer;
        EndOfName = (PWCHAR) Add2Ptr( RemainingName.Buffer, RemainingName.Length );
        Buffer = RemainingName.Buffer;

        while ((Buffer != EndOfName) && (*Buffer != OBJ_NAME_PATH_SEPARATOR)) {
            Buffer += 1;
        }

        ServerName.Length = (USHORT)((PCHAR)Buffer - (PCHAR)ServerName.Buffer);
        RemainingName.Length = (USHORT)((PCHAR)EndOfName - (PCHAR)Buffer);
        RemainingName.Buffer = Buffer;

        RxDbgTrace(0, Dbg, ("RxFirstCanonicalize entry, remainingname=%wZ\n",&RemainingName));

        //
        //  Apply the transformation for mapping PIPE shares to IPC$ shares.
        //  Note that this needs to be done only if the share name is specified.
        //  since the mup always passes in the trailing slash account for it
        //

        if ((ServerName.Length > 0) && RemainingName.Length > sizeof( WCHAR )) {

            //
            //  The second separator has been located. Compare to see if the name
            //  maps needs to be munged from PIPE or MAILSLOT to IPC$. Note that the
            //  leading / is accounted for as part of the compare
            //

            ShareName = RemainingName;

            //
            //  Check to see if it is a named pipe connection \PIPE
            //

            if ((ShareName.Length == s_PipeShareName.Length) ||
                ((ShareName.Length > s_PipeShareName.Length) &&
                 (ShareName.Buffer[s_PipeShareName.Length / sizeof( WCHAR )] == OBJ_NAME_PATH_SEPARATOR))) {

                ShareName.Length = s_PipeShareName.Length;
                SynthesizeCanonicalName = RtlEqualUnicodeString(
                                              &ShareName,
                                              &s_PipeShareName,
                                              TRUE );              // case insensitive
            }

            if (SynthesizeCanonicalName) {

                ShareName = s_IpcShareName;
                DeducedNetRootType = NET_ROOT_PIPE;
                RemainingName.Length -= s_PipeShareName.Length;
                RemainingName.Buffer = (PWCHAR) Add2Ptr( RemainingName.Buffer, s_PipeShareName.Length );

            } else {

                BOOLEAN FoundIPCdollar = FALSE;

                ShareName = RemainingName;

                //
                //  Check for \IPC$ connection
                //

                if (ShareName.Length == s_IpcShareName.Length ||
                    ShareName.Length > s_IpcShareName.Length &&
                    ShareName.Buffer[s_IpcShareName.Length/2] == OBJ_NAME_PATH_SEPARATOR) {

                    ShareName.Length = s_IpcShareName.Length;
                    FoundIPCdollar = RtlEqualUnicodeString(
                                         &ShareName,
                                         &s_IpcShareName,
                                         TRUE);            // Case insensitive
                }

                if (FoundIPCdollar) {

                    DeducedNetRootType = NET_ROOT_PIPE;
                    ASSERT( SynthesizeCanonicalName == FALSE );

                } else {

                    ShareName = RemainingName;

                    //
                    //  Check for \MAILSLOT
                    //

                    if ((ShareName.Length == s_MailSlotShareName.Length) ||
                        ((ShareName.Length > s_MailSlotShareName.Length) &&
                         (ShareName.Buffer[s_MailSlotShareName.Length/sizeof( WCHAR )] == OBJ_NAME_PATH_SEPARATOR))) {

                        ShareName.Length = s_MailSlotShareName.Length;
                        SynthesizeCanonicalName = RtlEqualUnicodeString(
                                                      &ShareName,
                                                      &s_MailSlotShareName,
                                                      TRUE );            // Case insensitive
                    }

                    if (SynthesizeCanonicalName) {

                        WCHAR LastCharacterInServerName;

                        DeducedNetRootType = NET_ROOT_MAILSLOT;
                        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_CREATE_MAILSLOT );

                        //
                        //  It is a mailslot share. Check to see if further reduction to canonical
                        //  form is required.
                        //

                        LastCharacterInServerName = ServerName.Buffer[(ServerName.Length/sizeof(WCHAR)) - 1];

                        if ((LastCharacterInServerName == L'*') &&
                            (ServerName.Length == sizeof( WCHAR ))) {

                            ServerName = s_PrimaryDomainName;
                            RemainingName.Length -= ShareName.Length;
                            RemainingName.Buffer = (PWCHAR)Add2Ptr( RemainingName.Buffer, ShareName.Length );

                        } else {
                            SynthesizeCanonicalName = FALSE;
                        }
                    }
                }
            }

            if (SynthesizeCanonicalName) {

                CanonicalNameLength = sizeof(WCHAR)     +  //  obj name separator
                                      ServerName.Length +
                                      ShareName.Length  +
                                      RemainingName.Length;

                if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CREATE_MAILSLOT )) {
                    CanonicalNameLength += s_MailSlotServerPrefix.Length;
                }

            } else {
                CanonicalNameLength = FileName->Length;
            }
        } else {

            Status = STATUS_OBJECT_NAME_INVALID;
            CanonicalNameLength = FileName->Length;
            SynthesizeCanonicalName = FALSE;

        }
    } else {
        CanonicalNameLength = FileName->Length;
        SynthesizeCanonicalName = FALSE;
    }

    *NetRootType = DeducedNetRootType;

    if (Status == STATUS_SUCCESS) {

        //
        //  if this is a UNC name AND this is a tree connect then we have to munge
        //  the name so as to avoid a conflict by adding '\;:'
        //

        if (UNCName && !SynthesizeCanonicalName) {

            MungeNameForDevicelessTreeConnect = TRUE;
            CanonicalNameLength += (3 * sizeof(WCHAR));

            // Hydra adds '\;:0' where 0 represents a SessionId
            CanonicalNameLength += IdString.Length;
        }

        if (!SynthesizeCanonicalName && !MungeNameForDevicelessTreeConnect) {

            if (FileName->Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
                Status = STATUS_OBJECT_PATH_INVALID;
            }
        }

        //
        //  Check for a maxed out name - strings only hold 64k due to Length being a ushort
        //

        if (CanonicalNameLength > MAXUSHORT) {
            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if (Status == STATUS_SUCCESS) {
            Status = RxAllocateCanonicalNameBuffer(
                         RxContext,
                         CanonicalName,
                         CanonicalNameLength );
        }

        if (Status == STATUS_SUCCESS) {
            if (!SynthesizeCanonicalName) {
                if (!MungeNameForDevicelessTreeConnect) {
                    RtlCopyUnicodeString( CanonicalName, FileName );
                } else {

                    CanonicalName->Buffer[0] = OBJ_NAME_PATH_SEPARATOR;
                    CanonicalName->Buffer[1] = DRIVE_BASED_PATH_IDENTIFIER;
                    CanonicalName->Buffer[2] = L':';
                    CanonicalName->Length    = 3*sizeof(WCHAR);

                    RtlAppendUnicodeStringToString( CanonicalName, &IdString );
                    RtlAppendUnicodeStringToString( CanonicalName, FileName );
                }
            } else {

                PCHAR CanonicalNameBuffer = (PCHAR)CanonicalName->Buffer;

                //
                //  The name has to be synthesized from the appropriate components.
                //  Copy the initial prefix
                //

                ASSERT( CanonicalName->MaximumLength == CanonicalNameLength );

                CanonicalName->Length = (USHORT)CanonicalNameLength;
                CanonicalName->Buffer[0] = OBJ_NAME_PATH_SEPARATOR;
                CanonicalNameBuffer += sizeof(WCHAR);

                if (MungeNameForDevicelessTreeConnect) {
                    CanonicalName->Buffer[1] = DRIVE_BASED_PATH_IDENTIFIER;
                    CanonicalName->Buffer[2] = L':';
                    CanonicalName->Buffer[3] = OBJ_NAME_PATH_SEPARATOR;
                    CanonicalNameBuffer += 3*sizeof(WCHAR);
                }

                if (RxContext->Flags & RX_CONTEXT_FLAG_CREATE_MAILSLOT) {

                    RtlCopyMemory( CanonicalNameBuffer, s_MailSlotServerPrefix.Buffer, s_MailSlotServerPrefix.Length );
                    CanonicalNameBuffer += s_MailSlotServerPrefix.Length;
                }

                //
                //  Copy the server name
                //

                RtlCopyMemory( CanonicalNameBuffer, ServerName.Buffer, ServerName.Length );
                CanonicalNameBuffer += ServerName.Length;

                //
                //  Copy the share name. Ensure that the share name includes the leading
                //  OBJ_NAME_PATH_SEPARATOR - the share is one of \IPC$ \Mailslot etc.
                //

                ASSERT( ShareName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR );
                RtlCopyMemory( CanonicalNameBuffer, ShareName.Buffer, ShareName.Length );
                CanonicalNameBuffer += ShareName.Length;

                //
                //  Copy the remaining name
                //

                RtlCopyMemory( CanonicalNameBuffer, RemainingName.Buffer, RemainingName.Length );

#ifdef _WIN64
                //
                //  (fcf) This should be addressed.  I was finding that
                //  CanonicalName->Length was ending up too large by 32 bytes
                //  (16 chars).
                //
                //  In the code above, CanonicalNameLength (and therefore
                //  CanonicalName->Length) is padded with (16 * sizeof(WCHAR))
                //  to accomodate a 16-character session ID... yet that
                //  ID is not copied in some circumstances, such as this
                //  code path where SynthesizeCanonicalName == TRUE.
                //
                //  Someone more familiar with the code should figure out why
                //  this isn't causing a problem on 32-bit builds and what
                //  the correct fix is.
                //

                CanonicalName->Length =
                    (USHORT)((CanonicalNameBuffer + RemainingName.Length) -
                    (PCHAR)CanonicalName->Buffer);
#endif

                RxDbgTrace(0,Dbg,("Final Munged Name .....%wZ\n", CanonicalName));
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("RxFirstCanonicalize exit, status=%08lx\n",Status));
    return Status;
}

//#define RX2C_USE_ALTERNATES_FOR_DEBUG  1
#ifndef RX2C_USE_ALTERNATES_FOR_DEBUG
#define RX2C_IS_SEPARATOR(__c) ((__c==OBJ_NAME_PATH_SEPARATOR)||(__c==L':'))
#define RX2C_IS_DOT(__c) ((__c==L'.'))
#define RX2C_IS_COLON(__c) ((__c==L':'))
#else
#define RX2C_IS_SEPARATOR(__c) ((__c==OBJ_NAME_PATH_SEPARATOR)||(__c==L':')||(__c==L'!'))
#define RX2C_IS_DOT(__c) ((__c==L'.')||(__c==L'q'))
#define RX2C_IS_COLON(__c) ((__c==L':'))
#endif

NTSTATUS
RxCanonicalizeFileNameByServerSpecs(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called to canonicalize a filename according to the way that
    the server wants it.

Arguments:

    RxContext - the current workitem

    RemainingName  - the  filename

Return Value:

    NTSTATUS - The Fsd status for the Operation.

       MORE_PROCESSING_REQUIRED means that everything worked and processing
       should continue otherwise....failcomplete the operation.

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    PWCHAR Buffer = RemainingName->Buffer;
    ULONG Length = RemainingName->Length / sizeof(WCHAR);
    ULONG i,o;  //  input and output pointers

    PAGED_CODE();

    if (Length==0) {
        return Status;
    }

    RxDbgTrace(+1, Dbg, ("RxCanonicalizeFileNameByServerSpecs Rname=%wZ\n", RemainingName));

    for (i=o=0;i<Length;) {

        ULONG firstchar,lastchar; //  first and last char of the component

        //
        //  find a component starting at i: [\][^\]* is the format
        //

        firstchar = i;
        for (lastchar=i+1;;lastchar++) {
            if ((lastchar>=Length) || RX2C_IS_SEPARATOR(Buffer[lastchar])) {
                lastchar--;
                break;
            }
        }

        IF_DEBUG {
            UNICODE_STRING Component;
            Component.Buffer = &Buffer[firstchar];
            Component.Length = (USHORT)(sizeof(WCHAR)*(lastchar-firstchar+1));
            RxDbgTraceLV(0, Dbg, 1001, ("RxCanonicalizeFileNameByServerSpecs component=%wZ\n", &Component));
        }

        //
        //  firstchar..lastchar describe the component
        //  according to darrylh, . and .. are illegal now
        //  I believe that consecutive slashes are also illegal
        //

        switch (lastchar-firstchar) {
        case 0: //  length 1

            //
            //  the two bad cases are a backslash or a dot. if the backslash is at the end then that's okay
            //

            if ((RX2C_IS_SEPARATOR(Buffer[firstchar]) && (firstchar != Length-1)) ||
                 RX2C_IS_DOT(Buffer[firstchar])) {

                 if (lastchar != 0) {

                    //
                    //  it is ok if two colons stick together, i.e. \\server\share\foo::stream
                    //

                    if ((lastchar < (Length - 1)) && !RX2C_IS_COLON( Buffer[lastchar + 1] )) {
                        goto BADRETURN;
                    }
                } else {

                    //
                    //  it is fine if the colon follows the share, i.e. \\server\share\:stream
                    //

                    if (!RX2C_IS_COLON( Buffer[1] )) {
                        goto BADRETURN;
                    }
                }
            }
            break;

        case 1: //  length 2

            //
            //  bad cases: \. and ..
            //

            if (RX2C_IS_DOT(Buffer[firstchar+1]) &&
                (RX2C_IS_SEPARATOR(Buffer[firstchar]) || RX2C_IS_DOT(Buffer[firstchar]))) {
                goto BADRETURN;
            }
            break;

        case 2: //length 3
            if ( (RX2C_IS_SEPARATOR(Buffer[firstchar]) &&
                  RX2C_IS_DOT(Buffer[firstchar+1]) &&
                  RX2C_IS_DOT(Buffer[firstchar+2]))) {
                goto BADRETURN;
            }
            break;

        }

        //
        //  DOWNLEVEL this is where you limit by component length. o will be the back ptr
        //  but for no downlevel....do nothing.
        //

        i = lastchar + 1;
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;

BADRETURN:
    RxDbgTrace(-1, Dbg, ("RxCanonicalizeFileNameByServerSpecs BADRETURN \n"));
    return STATUS_OBJECT_PATH_SYNTAX_BAD;
}

NTSTATUS
RxCanonicalizeNameAndObtainNetRoot (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called to find out the server or netroot associated with a
    name. In addition, the name is canonicalized according to what flags are set
    in the srvcall.

Arguments:

    RxContext - the current workitem

    FileName  - the initial filename

    CanonicalName - the canonicalized name. an initial string is passed in; if it
                    is not big enough then a bigger one is allocated and freed
                    when the rxcontx is freed.

    RemainingName - the name of the file after the netroot prefix is removed; it
                    has been canonicalized. This points into the same buffer as
                    canonical name.

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       SUCCESS means that everything worked and processing should continue
       otherwise....failcomplete the operation.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    UNICODE_STRING CanonicalName;

    PFILE_OBJECT RelatedFileObject = FileObject->RelatedFileObject;
    LOCK_HOLDING_STATE LockHoldingState = LHS_LockNotHeld;
    NET_ROOT_TYPE  NetRootType = NET_ROOT_WILD;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCanonicalizeName -> %08lx\n", 0));

    RemainingName->Buffer = NULL;
    RemainingName->Length = RemainingName->MaximumLength = 0;

    CanonicalName.Buffer = NULL;
    CanonicalName.Length = CanonicalName.MaximumLength = 0;

    if (!RelatedFileObject) {

        Status = RxFirstCanonicalize( RxContext,
                                      Irp,
                                      FileName,
                                      &CanonicalName,
                                      &NetRootType );

        if (Status != STATUS_SUCCESS) {
            RxDbgTraceUnIndent(-1,Dbg);
            return Status;
        }

    } else {

        PFCB RelatedFcb = (PFCB)(RelatedFileObject->FsContext);
        PFOBX RelatedFobx = (PFOBX)(RelatedFileObject->FsContext2);
        ULONG AllocationNeeded;
        PV_NET_ROOT RelatedVNetRoot;
        PUNICODE_STRING RelatedVNetRootName,RelatedFcbName;

        if ((RelatedFcb == NULL) || (RelatedFobx == NULL)) {

            RxDbgTraceUnIndent(-1,Dbg);
            return STATUS_INVALID_PARAMETER;
        }

        RelatedVNetRoot = RelatedFobx->SrvOpen->VNetRoot;

        if (!NodeTypeIsFcb( RelatedFcb ) ||
            (RelatedVNetRoot == NULL) ||
            (NodeType( RelatedVNetRoot ) != RDBSS_NTC_V_NETROOT)) {

            RxDbgTraceUnIndent(-1,Dbg);
            return STATUS_INVALID_PARAMETER;
        }

        RelatedVNetRootName = &RelatedVNetRoot->PrefixEntry.Prefix;
        RelatedFcbName = &RelatedFcb->FcbTableEntry.Path;

        //
        //  relative open......
        //      we have to ensure that we have a canonical name buffer that is
        //      long enough so we add the name of the current file to the sum of
        //      the vnetroot length of the relative file and the prefixname (not
        //      the alreadyprefixedname) of the relative file. plus some slop for
        //      chars. If this is greater than the maximum value for a USHORT we
        //  reject the name as being invalid since we cannot represent it in
        //  a UNICODE_STRING
        //

        AllocationNeeded = RelatedVNetRootName->Length + RelatedFcbName->Length + FileName->Length + 3 * sizeof(WCHAR);

        if (AllocationNeeded <= MAXUSHORT) {

            //
            //  you may need some backslashs/colons in the middle
            //

            Status = RxAllocateCanonicalNameBuffer( RxContext,
                                                    &CanonicalName,
                                                    AllocationNeeded );
        } else {
            Status = STATUS_OBJECT_PATH_INVALID;
        }

        if (Status != STATUS_SUCCESS) {

            RxDbgTraceUnIndent(-1,Dbg);
            return Status;
        }

        RtlMoveMemory( CanonicalName.Buffer,
                       RelatedVNetRootName->Buffer,
                       RelatedVNetRootName->Length );
        RtlMoveMemory( Add2Ptr( CanonicalName.Buffer, RelatedVNetRootName->Length ),
                       RelatedFcbName->Buffer,
                       RelatedFcbName->Length );

        CanonicalName.Length = (USHORT)(RelatedVNetRootName->Length + RelatedFcbName->Length);

        RxDbgTrace(0,Dbg,("Name From Related Fileobj.....%wZ\n", &CanonicalName));

        if (FileName->Length != 0) {

            ULONG LastWCharIndex = (CanonicalName.Length / sizeof( WCHAR )) - 1;

            //
            //  add on the rest...there are special cases here! with ':' for streams.........
            //

            if ((CanonicalName.Buffer[LastWCharIndex] != OBJ_NAME_PATH_SEPARATOR) &&
                (FileName->Buffer[0] != L':' )  ) {

                ASSERT(CanonicalName.Length < CanonicalName.MaximumLength);
                CanonicalName.Length += sizeof( WCHAR );
                CanonicalName.Buffer[LastWCharIndex+1] = OBJ_NAME_PATH_SEPARATOR;
            }

            ASSERT (CanonicalName.MaximumLength >= CanonicalName.Length + FileName->Length);
            RxDbgTrace(0,Dbg,("Name From Related Fileobj w/ trailer.....%wZ\n", &CanonicalName));
            RtlMoveMemory( Add2Ptr( CanonicalName.Buffer, CanonicalName.Length ), FileName->Buffer, FileName->Length);
            CanonicalName.Length += FileName->Length;
        }

        if (FlagOn( RelatedFobx->Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME )) {

            //
            //  if the related guy was a UNC, we're a UNC
            //

            SetFlag( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME );
        }

        RxDbgTrace(0,Dbg,("Final Name From Related Fileobj.....%wZ\n", &CanonicalName));
    }

    Status = RxFindOrConstructVirtualNetRoot( RxContext,
                                              Irp,
                                              &CanonicalName,
                                              NetRootType,
                                              RemainingName );

    if ((Status != STATUS_SUCCESS) &&
        (Status != STATUS_PENDING) &&
        (RxContext->Flags & RX_CONTEXT_FLAG_MAILSLOT_REPARSE)) {

        ASSERT(CanonicalName.Buffer == RxContext->Create.CanonicalNameBuffer);

        RxFreeCanonicalNameBuffer( RxContext );

        Status = RxFirstCanonicalize( RxContext,
                                      Irp,
                                      FileName,
                                      &CanonicalName,
                                      &NetRootType);

        if (Status == STATUS_SUCCESS) {
            Status = RxFindOrConstructVirtualNetRoot( RxContext,
                                                      Irp,
                                                      &CanonicalName,
                                                      NetRootType,
                                                      RemainingName );
        }
    }

    if (FsRtlDoesNameContainWildCards( RemainingName )) {
        Status = STATUS_OBJECT_NAME_INVALID;
    }

    if (Status == STATUS_SUCCESS) {

        RxDbgTrace( 0, Dbg, ("RxCanonicalizeName SrvCall-> %08lx\n", RxContext->Create.pSrvCall));
        RxDbgTrace( 0, Dbg, ("RxCanonicalizeName Root-> %08lx\n", RxContext->Create.pNetRoot));

        Status = RxCanonicalizeFileNameByServerSpecs(RxContext,RemainingName);

        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            RxDbgTrace(0, Dbg, ("RxCanonicalizeName Remaining -> %wZ\n", RemainingName));
        }
    }

    if((NT_SUCCESS( Status ) || (Status == STATUS_MORE_PROCESSING_REQUIRED)) &&
        (RxContext->Create.pNetRoot != NULL))
    {
        NTSTATUS PreparseStatus;

        //
        //  Allow the Mini-RDR to do any extra "scanning" of the name
        //

        MINIRDR_CALL( PreparseStatus,
                      RxContext,
                      RxContext->Create.pNetRoot->pSrvCall->RxDeviceObject->Dispatch,
                      MRxPreparseName,
                      (RxContext, &CanonicalName));
    }

   RxDbgTrace(-1, Dbg, ("RxCanonicalizeName Status -> %08lx\n", Status));
   return Status;
}

NTSTATUS
RxFindOrCreateFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING RemainingName,
    OUT PFCB *Fcb
    )
/*++

Routine Description:

    This routine is called to either find the Fcb associated with the
    name or to create it.  If everything succeeds, it returns with a
    reference on the name and with the fcblock held exclusive.

    so, that's a total of two things for success:
      1) fcb lock held exclusive
      2) reference on the fcb ( be it through lookup or taking an additional
         reference on create)

    The current strategy is to not delete the Fcb if things don't work out and
    to let it be scavenged.  this is a good strategy unless we are being bombarded
    with open requests that fail in which case we should change over to something
    different.  for this reason, i record in the irp context if the fcb is built here.

Arguments:

    RxContext - the current workitem

    RemainingName - the name of the file after the netroot prefix is removed; it has been
                    canonicalized.

Return Value:

    RXSTATUS - The Fsd status for the Irp

Notes:

    On Exit -- the FCB resource would have been accquired exclusive if successful

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PV_NET_ROOT VNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;
    PNET_ROOT NetRoot  = (PNET_ROOT)RxContext->Create.pNetRoot;

    ULONG TableVersion;
    CLONG RemainingNameLength;

    BOOLEAN FcbTableLockAcquired;
    BOOLEAN FcbTableLockAcquiredExclusive = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFindOrCreateFcb -> %08lx\n", 0));

    ASSERT( NetRoot == (PNET_ROOT)VNetRoot->NetRoot );

    //
    //  Acquire the NET_ROOT's FcbTable lock shared to beginwith. This will
    //  ensure maximal concurrency and in those cases when the lookup fails
    //  this will be converted to an exclusive lock before proceeding further.
    //

    RxAcquireFcbTableLockShared( &NetRoot->FcbTable, TRUE );
    FcbTableLockAcquired = TRUE;

    TableVersion = NetRoot->FcbTable.Version;
    RemainingNameLength = RemainingName->Length;

    *Fcb = RxFcbTableLookupFcb( &NetRoot->FcbTable, RemainingName );

#if DBG
    if (*Fcb) {
        RxLoudFcbMsg("RxFindOrCreateFcb found: ",&((*Fcb)->FcbTableEntry.Path));
        RxDbgTrace(0, Dbg, ("                   ----->Found Prefix Name=%wZ\n",
                        &(*Fcb)->FcbTableEntry.Path ));
    } else {
        RxDbgTrace(0, Dbg, ("Name not found - %wZ\n", RemainingName));
        RxDbgTrace(0, Dbg, ("Fcb is NULL!!\n"));
        RxLoudFcbMsg("RxFindOrCreateFcb fcbisnull found: ",RemainingName);
    }
#endif

    //
    //  If it has been marked for orphaning, lets do it!
    //

    if (*Fcb && (*Fcb)->fShouldBeOrphaned) {

        //
        //  Release our reference from the first lookup
        //

        RxDereferenceNetFcb( *Fcb );

        //
        //  Switch to an exclusive table lock so we know we're the only one referencing this FCB
        //

        RxReleaseFcbTableLock( &NetRoot->FcbTable );
        FcbTableLockAcquired = FALSE;

        RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );
        FcbTableLockAcquired = TRUE;
        FcbTableLockAcquiredExclusive = TRUE;

        //
        //  Make sure it is still in the table
        //

        *Fcb = RxFcbTableLookupFcb( &NetRoot->FcbTable, RemainingName );

        if (*Fcb && (*Fcb)->fShouldBeOrphaned) {

            RxOrphanThisFcb( *Fcb );
            RxDereferenceNetFcb( *Fcb );
            *Fcb = NULL;
        }
    }

    if ((*Fcb == NULL) ||
        ((*Fcb)->FcbTableEntry.Path.Length != RemainingNameLength)) {

        //
        //  Convert the shared lock that is currently held to an exclusive lock.
        //  This will necessiate another lookup if the FCB table was updated during
        //  this interval
        //

        if (!FcbTableLockAcquiredExclusive) {

            RxReleaseFcbTableLock( &NetRoot->FcbTable );
            FcbTableLockAcquired = FALSE;

            RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );
            FcbTableLockAcquired = TRUE;
        }

        if (TableVersion != NetRoot->FcbTable.Version) {
            *Fcb = RxFcbTableLookupFcb( &NetRoot->FcbTable, RemainingName );
        }

        if ((*Fcb == NULL) ||
            ((*Fcb)->FcbTableEntry.Path.Length != RemainingNameLength)) {

            //
            //  we have to build it
            //

            try {

                *Fcb = RxCreateNetFcb( RxContext, Irp, VNetRoot, RemainingName );

                if (*Fcb == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    Status = RxAcquireExclusiveFcb( RxContext, *Fcb );

                    if (Status == STATUS_SUCCESS) {
                        RxContext->Create.FcbAcquired = TRUE;
                    } else {
                        RxContext->Create.FcbAcquired = FALSE;
                    }
                }
            } finally {
                if (AbnormalTermination()) {
                    RxReleaseFcbTableLock( &NetRoot->FcbTable );
                    FcbTableLockAcquired = FALSE;

                    if (*Fcb) {

                        RxTransitionNetFcb( *Fcb, Condition_Bad );

                        ExAcquireResourceExclusiveLite( (*Fcb)->Header.Resource, TRUE );
                        if (!RxDereferenceAndFinalizeNetFcb( *Fcb, NULL, FALSE, FALSE )) {
                            ExReleaseResourceLite( (*Fcb)->Header.Resource );
                        }
                    }
                }
            }
        }
    }

    if (FcbTableLockAcquired) {
        RxReleaseFcbTableLock( &NetRoot->FcbTable );
    }

    if (Status == STATUS_SUCCESS) {

        RxContext->pFcb = (PMRX_FCB)*Fcb;
        RxLog(( "Found or created FCB %lx Condition %lx\n", *Fcb, (*Fcb)->Condition ));
        RxWmiLog( LOG,
                 RxFindOrCreateFcb,
                 LOGPTR( *Fcb )
                 LOGULONG( (*Fcb)->Condition ) );

        if (!RxContext->Create.FcbAcquired) {

            //
            //  if the FCB was not newly built then ensure that it is in a stable
            //  condition before proceeding further. Note that since a reference
            //  to this FCB is held by this routine it cannot be finalized
            //  before the control can return to this routine.
            //

            RxWaitForStableNetFcb( *Fcb, RxContext );

            Status = RxAcquireExclusiveFcb( RxContext, *Fcb );
            if (Status == STATUS_SUCCESS) {
                RxContext->Create.FcbAcquired = TRUE;
            }
        }
    }

    RxDbgTrace( -1, Dbg, ("RxFindOrCreateFcb Fcb=%08lx\n", *Fcb ));

    if (*Fcb) {
        RxDbgTrace( -1, Dbg, ("RxFindOrCreateFcb name=%wZ\n", &(*Fcb)->FcbTableEntry.Path) );
    }

    return Status;
}

NTSTATUS
RxSearchForCollapsibleOpen (
    IN OUT PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess
    )
/*++

Routine Description:

    This routine is called to seach the list of available srvopens on
    the fcb to see if we can collapse onto an existing open.
    If we search the whole list w/o finding a collapse, then we return
    STATUS_NOT_FOUND.

Arguments:

    RxContext - the current workitem


Return Value:

    STATUS_SUCCESS -- a SRV_OPEN instance was found.
    STATUS_MORE_PROCESSING_REQUIRED -- no SRV_OPEN instance was found.
    STATUS_NOT_FOUND - collapsing is not allowed

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    ULONG Disposition;
    ULONG CurrentCreateOptions;
    BOOLEAN AllowCollapse;

    PNET_ROOT NetRoot = (PNET_ROOT)(RxContext->Create.pNetRoot);
    PSRV_OPEN SrvOpen = NULL;

    PAGED_CODE();

    //
    //  Disallow collapsing for backup and delete on close opens.
    //

    if (FlagOn( RxContext->Create.NtCreateParameters.CreateOptions, FILE_OPEN_FOR_BACKUP_INTENT ) ||
        FlagOn( RxContext->Create.NtCreateParameters.CreateOptions, FILE_DELETE_ON_CLOSE )) {

        ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );
        RxScavengeRelatedFobxs( Fcb );

        RxPurgeFcbInSystemCache( Fcb,
                                 NULL,
                                 0,
                                 FALSE,
                                 TRUE );

        return STATUS_NOT_FOUND;
    }

    //
    //  if the create specifies a special create disposition then we don't
    //  collapse; as well, we give the minirdr the opportunity to defeat
    //  collapsing by a calldown
    //

    CurrentCreateOptions  = RxContext->Create.NtCreateParameters.CreateOptions;
    Disposition = RxContext->Create.NtCreateParameters.Disposition;
    AllowCollapse = (Disposition == FILE_OPEN) || (Disposition == FILE_OPEN_IF);

    if (AllowCollapse && (Fcb->MRxDispatch != NULL)) { //  should be an ASSERT??
        NTSTATUS CollapseStatus;

        ASSERT( RxContext->pRelevantSrvOpen == NULL );
        ASSERT( Fcb->MRxDispatch->MRxShouldTryToCollapseThisOpen != NULL );

        CollapseStatus = Fcb->MRxDispatch->MRxShouldTryToCollapseThisOpen( RxContext );
        AllowCollapse = (CollapseStatus == STATUS_SUCCESS);
    }

    if (!AllowCollapse) {

        //
        //  it may be that there is an existing open that keeps this open from working....
        //  if so, prepurge
        //

        NTSTATUS SharingStatus;

        SharingStatus = RxCheckShareAccessPerSrvOpens( Fcb,
                                                       DesiredAccess,
                                                       ShareAccess );

        if (SharingStatus != STATUS_SUCCESS) {
            ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );
            RxScavengeRelatedFobxs( Fcb );

            RxPurgeFcbInSystemCache( Fcb,
                                     NULL,
                                     0,
                                     FALSE,
                                     TRUE );
        }

        return STATUS_NOT_FOUND;
    }

    if ((Fcb->NetRoot == (PNET_ROOT)RxContext->Create.pNetRoot) &&
        (Fcb->NetRoot->Type == NET_ROOT_DISK)) {

        BOOLEAN FobxsScavengingAttempted = FALSE;
        BOOLEAN FcbPurgingAttempted = FALSE;

        //
        //  Search the list of SRV_OPEN's to determine if this open request can be
        //  collapsed with an existing SRV_OPEN.
        //

        for (;;) {
            PLIST_ENTRY SrvOpenListEntry;

            SrvOpenListEntry = Fcb->SrvOpenList.Flink;

            for (;;) {
                if (SrvOpenListEntry == &Fcb->SrvOpenList) {

                    //
                    //  If the end of the list of SRV_OPEN's has been reached then it
                    //  is time to go to the server, i.e., create a new SRV_OPEN.
                    //

                    Status = STATUS_NOT_FOUND;
                    break;
                }

                SrvOpen = (PSRV_OPEN)CONTAINING_RECORD( SrvOpenListEntry, SRV_OPEN, SrvOpenQLinks );

                if ((SrvOpen->VNetRoot == (PV_NET_ROOT)RxContext->Create.pVNetRoot) &&
                    (SrvOpen->DesiredAccess == DesiredAccess) &&
                    (SrvOpen->ShareAccess == ShareAccess) &&
                    !FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_COLLAPSING_DISABLED ) &&
                    !FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSED ) &&
                    !FlagOn( SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED ) &&
                    !FlagOn( SrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED ))   {

                    if ((FlagOn( SrvOpen->CreateOptions, FILE_OPEN_REPARSE_POINT )) !=
                        FlagOn( CurrentCreateOptions, FILE_OPEN_REPARSE_POINT )) {

                        FobxsScavengingAttempted = TRUE;
                        FcbPurgingAttempted = TRUE;
                        Status = STATUS_NOT_FOUND;
                        break;
                    }

                    //
                    //  If a SRV_OPEN with identical DesiredAccess and ShareAccess
                    //  has been found which has not been renamed/deleted then the
                    //  new open request can be collapsed onto the existing open.
                    //

                    if (DisableByteRangeLockingOnReadOnlyFiles ||
                        !FlagOn( SrvOpen->Fcb->Attributes, FILE_ATTRIBUTE_READONLY )) {

                        Status = STATUS_SUCCESS;
                        break;
                    }

                } else {
                    if (SrvOpen->VNetRoot != (PV_NET_ROOT)RxContext->Create.pVNetRoot) {

                        //
                        // the file is accessed by another user. It needs to be purged out
                        // if the current user is going to use it.
                        //

                        RxContext->Create.TryForScavengingOnSharingViolation = TRUE;

                        //
                        //  Don't collapse srvopens belonging to different vnetroots
                        //

                        SrvOpenListEntry = SrvOpenListEntry->Flink;
                        continue;

                    }

                    //
                    //  If the existing SRV_OPEN does not match the access required by the
                    //  new open request ensure that the new open request does not conflict
                    //  with the existing SRV_OPEN's. If it does scavenging/purging needs
                    //  to be attempted before forwarding the request to the server.
                    //

                    Status = RxCheckShareAccessPerSrvOpens( Fcb,
                                                            DesiredAccess,
                                                            ShareAccess );

                    if (Status != STATUS_SUCCESS) {
                        break;
                    }

                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }

                SrvOpenListEntry = SrvOpenListEntry->Flink;
            }

            if (Status == STATUS_SUCCESS) {

                //
                //  a collapsible open was found. return it.
                //

                RxContext->pRelevantSrvOpen = (PMRX_SRV_OPEN)SrvOpen;
                ASSERT( Fcb->MRxDispatch->MRxShouldTryToCollapseThisOpen != NULL );

                if(Fcb->MRxDispatch->MRxShouldTryToCollapseThisOpen( RxContext ) == STATUS_SUCCESS) {

                    if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSE_DELAYED )) {
                        RxLog(("****** Delayed Close worked reusing SrvOpen(%lx)\n", SrvOpen));
                        RxWmiLog(LOG,
                                 RxSearchForCollapsibleOpen,
                                 LOGPTR( SrvOpen ));
                        InterlockedDecrement( &NetRoot->SrvCall->NumberOfCloseDelayedFiles );
                        ClearFlag( SrvOpen->Flags, SRVOPEN_FLAG_CLOSE_DELAYED );
                    }

                    break;
                } else {
                    Status = STATUS_NOT_FOUND;
                }
            }

            if (!FobxsScavengingAttempted) {

                //
                //  No SRV_OPEN instance onto which the new request can be collapsed was
                //  found. Attempt to scavenge any FOBX's, i.e., ensure that all the
                //  delayed close operations on the FOBX are done before checking again.
                //

                FobxsScavengingAttempted = TRUE;
                ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );
                RxScavengeRelatedFobxs( Fcb );
                continue;
            }

            if (!FcbPurgingAttempted) {

                //
                //  No SRV_OPEN instance was found. Ensure that the potential references
                //  held by the memory manager/cache manager can be purged before the
                //  open request to the server can be attempted.
                //

                RxPurgeFcbInSystemCache( Fcb,
                                         NULL,
                                         0,
                                         FALSE,
                                         TRUE);

                FcbPurgingAttempted = TRUE;
                continue;
            }

            break;
        }
    } else {
        Status = STATUS_NOT_FOUND;
    }

    if (Status == STATUS_SHARING_VIOLATION) {

        //
        //  A local sharing violation was detected.
        //

        RxContext->Create.TryForScavengingOnSharingViolation = TRUE;
    }

    return Status;
}

NTSTATUS
RxCollapseOrCreateSrvOpen (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    This routine is called to either find a SRV_OPEN instance that can be
    collapsed onto or, failing that, to build a fresh one IN
    TRANSITION.  The fcblock will already be held exclusive and the
    tablelock will be either exclusive or shared.  If everything
    succeeds, it returns with a reference on the srvopen and with the
    fcblock still held excl BUT we always release the tablelock.  IF
    IT FAILS, THEN IT COMPLETES THE RXCONTEXT FROM HERE WHICH, IN
    TURN, WILL RELEASE THE FCBLOCK.

    The minirdr is consulted to determine if a collapse is possible so
    there is no reason to call twice.  If the minirdr determines to
    collapse, then it will do so and passback a returnable status.
    Thus, RxStatus(SUCCESS) is an terminating return from here.  For this
    reason, we return RxStatus(MORE_PROCESSING_REQUIRED) as the
    nonterminating return and the minirdr routine uses the same.

    RxContext->SrvOpen contains either the collapsed or built srvopen.

Arguments:

    RxContext - the current workitem


Return Value:

    RxStatus(MORE_PROCESSING_REQUIRED) - further processing of the newly
    constructed SRV_OPEN instance is required.

    RxStatus(SUCCESS) - the SRV_OPEN instance was found/constructed successfully

Notes:

    On Entry -- the FCB resource must have been acquired exclusive

--*/
{
    NTSTATUS  Status = STATUS_NOT_FOUND;

    PNET_ROOT NetRoot = (PNET_ROOT)(RxContext->Create.pNetRoot);

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    ACCESS_MASK DesiredAccess = FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess, FILE_ALL_ACCESS );
    ULONG ShareAccess = FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_VALID_FLAGS );

    RX_BLOCK_CONDITION FcbCondition;

    ULONG   CreateOptions;
    BOOLEAN DeleteOnClose;
    BOOLEAN NoIntermediateBuffering;
    BOOLEAN PagingIoResourceTaken = FALSE;
    ULONG Disposition = RxContext->Create.NtCreateParameters.Disposition;

    PSRV_OPEN SrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCollapseOrCreateSrvOpen -> %08lx\n", 0));

    CreateOptions = IrpSp->Parameters.Create.Options;
    NoIntermediateBuffering = BooleanFlagOn( CreateOptions, FILE_NO_INTERMEDIATE_BUFFERING );
    DeleteOnClose = BooleanFlagOn( CreateOptions, FILE_DELETE_ON_CLOSE );

    ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

    //
    //  this ensures that the fcb will not be finalized while we are in the minirdr
    //

    Fcb->UncleanCount += 1;

    //
    // When we call RxSearchForCollapsibleOpen, it will (in addition to
    // searching for a collapsing candidate) close down delayed closes
    // that could end up giving us a sharing violation on this open.
    // Because of this side effect, we shouldn't try to avoid making
    // this call because of some obviously non-collapsible condition.
    // RxSearchForCollapsibleOpen will take care of those conditions
    // for us.
    //
    Status = RxSearchForCollapsibleOpen( RxContext,
                                         Fcb,
                                         DesiredAccess,
                                         ShareAccess );

    if (Status == STATUS_SUCCESS) {
        RxContext->CurrentIrp->IoStatus.Information = FILE_OPENED;
    }

    if (Status == STATUS_NOT_FOUND) {
        RxDbgTrace(0, Dbg, ("No collapsible srvopens found for %wZ\n", &Fcb->FcbTableEntry.Path));

        try {
            SrvOpen = RxCreateSrvOpen( (PV_NET_ROOT)RxContext->Create.pVNetRoot, Fcb );
            if (SrvOpen != NULL) {
                SrvOpen->DesiredAccess = DesiredAccess;
                SrvOpen->ShareAccess = ShareAccess;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } except (CATCH_EXPECTED_EXCEPTIONS) {

            //
            //  note: we do not give back the FCB!!!!
            //
            RxDbgTrace(-1, Dbg, ("RxCollapseOrCreateSrvOpen EXCEPTION %08lx\n", GetExceptionCode()));
            return RxProcessException( RxContext, GetExceptionCode() );
        } //  try

        RxContext->pRelevantSrvOpen = (PMRX_SRV_OPEN)SrvOpen;

        if (Status == STATUS_SUCCESS) {

            RxInitiateSrvOpenKeyAssociation( SrvOpen );

            //
            //  calldown.....
            //

#if DBG
            RxContext->CurrentIrp->IoStatus.Information = 0xabcdef;
#endif

            MINIRDR_CALL( Status,
                          RxContext,
                          Fcb->MRxDispatch,
                          MRxCreate,
                          (RxContext));

            //
            //  help other minirdr writers find this bug, i.e. they should use the new way
            //

            ASSERT( RxContext->CurrentIrp->IoStatus.Information == 0xabcdef );

            //
            //  if this is a successful overwrite, then truncate the file
            //

            if ((Disposition == FILE_OVERWRITE) || (Disposition == FILE_OVERWRITE_IF)) {

                if (Status == STATUS_SUCCESS) {

                    RxAcquirePagingIoResource( RxContext, Fcb );
                    Fcb->Header.FileSize.QuadPart = 0;
                    Fcb->Header.AllocationSize.QuadPart = 0;
                    Fcb->Header.ValidDataLength.QuadPart = 0;
                    FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;
                    CcSetFileSizes( FileObject,
                                   (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );
                    RxReleasePagingIoResource( RxContext, Fcb );
                }
            } else if (Status == STATUS_SUCCESS) {

                FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;

                if(CcIsFileCached( FileObject )) {

                    //
                    //  Since the file is cached, we need to update the sizes the cache manager
                    //  has with the ones we just got back from the server.  If the server is
                    //  behaving properly, this will be a nop.  But we have to protect ourselves
                    //  from a bad server that returns updated file sizes that we do not know about.
                    //

                    RxAdjustAllocationSizeforCC( Fcb );

                    try {

                        CcSetFileSizes( FileObject,
                                        (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        //
                        //  We took an exception setting the file sizes.  This can happen
                        //  if the cache manager was not able to allocate resources.  We
                        //  cannot restore the previous sizes, since we do not know what they
                        //  were.  The best we can do is purge the file from the cache.
                        //

                        RxPurgeFcbInSystemCache( Fcb,
                                                 NULL,
                                                 0,
                                                 TRUE,
                                                 TRUE );
                    }
                }
            }


            RxContext->CurrentIrp->IoStatus.Information = RxContext->Create.ReturnedCreateInformation;

            SrvOpen->OpenStatus = Status;

            RxTransitionSrvOpen( SrvOpen,
                                 (Status==STATUS_SUCCESS) ? Condition_Good : Condition_Bad );


            RxDumpCurrentAccess( "shareaccess status after calldown....","","ShrAccPostMini", &Fcb->ShareAccess );
            RxDbgTrace( 0, Dbg, ("RxCollapseOrCreateSrvOpen   Back from the minirdr, Status=%08lx\n", Status ));

            ASSERT( RxIsFcbAcquiredExclusive ( Fcb ) );

            RxCompleteSrvOpenKeyAssociation( SrvOpen );

            if (Status != STATUS_SUCCESS) {
               FcbCondition = Condition_Bad;
               RxDereferenceSrvOpen( SrvOpen, LHS_ExclusiveLockHeld );
               RxContext->pRelevantSrvOpen = NULL;

               if (RxContext->pFobx != NULL) {
                   RxDereferenceNetFobx( RxContext->pFobx, LHS_ExclusiveLockHeld );
                   RxContext->pFobx = NULL;
               }

            } else {
               if (DeleteOnClose) {
                  ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );
               }

               SrvOpen->CreateOptions =  RxContext->Create.NtCreateParameters.CreateOptions;
               FcbCondition = Condition_Good;
            }
        } else {
            FcbCondition = Condition_Bad;
        }

        RxLog(("Transitioning FCB %lx Condition %lx\n", Fcb, FcbCondition ));
        RxWmiLog(LOG,
                 RxCollapseOrCreateSrvOpen,
                 LOGPTR( Fcb )
                 LOGULONG( FcbCondition ));

        RxTransitionNetFcb( Fcb, FcbCondition );

    } else if (Status == STATUS_SUCCESS) {

        BOOLEAN TransitionProcessingRequired = FALSE;

       //
       //  An existing SRV_OPEN instance has been found. This instance can be in
       //  one of the following two states -- either it has already transitioned
       //  into a stable state or it is in the process of being constructed. In
       //  the later case this routine needs to wait for this transition to occur.
       //  Note that both the reference count and the OpenCount need to be
       //  incremented before releasing the resource. An incremented reference
       //  count by itself will not ensure that the Close request on a SRV_OPEN
       //  will be delayed till the threads waiting for the transitioning of the
       //  SRV_OPEN have had a chance to process it.
       //

       SrvOpen = (PSRV_OPEN)(RxContext->pRelevantSrvOpen);
       if (!StableCondition( SrvOpen->Condition )) {
          TransitionProcessingRequired = TRUE;
          RxDbgTrace(0,Dbg,("waiting for stable srv open (%lx)\n",SrvOpen));

          RxReferenceSrvOpen( SrvOpen );
          SrvOpen->OpenCount += 1;

          RxReleaseFcb( RxContext, Fcb );
          RxContext->Create.FcbAcquired = FALSE;

          RxWaitForStableSrvOpen( SrvOpen, RxContext);

          Status = RxAcquireExclusiveFcb( RxContext, Fcb );
          if (Status == STATUS_SUCCESS) {
              RxContext->Create.FcbAcquired = TRUE;
          }
       }

       if (SrvOpen->Condition == Condition_Good) {

          MINIRDR_CALL( Status, RxContext, Fcb->MRxDispatch, MRxCollapseOpen, (RxContext) );
          RxDbgTrace(0, Dbg, ("RxCollapseOrCreateSrvOpen   Back from the minirdr, Status=%08lx\n", Status ));

          ASSERT  ( RxIsFcbAcquiredExclusive( Fcb )  );
       } else {
          Status =  SrvOpen->OpenStatus;
       }

       if (TransitionProcessingRequired) {
          SrvOpen->OpenCount -= 1;
          RxDereferenceSrvOpen( SrvOpen, LHS_ExclusiveLockHeld );
       }
    }

    Fcb->UncleanCount -= 1;  //  now that we're back from the minirdr

    RxDbgTrace(-1, Dbg, ("RxCollapseOrCreateSrvOpen SrvOpen %08lx Status %08lx\n"
                                , RxContext->pRelevantSrvOpen, Status));
    return Status;
}

VOID
RxSetupNetFileObject (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    This routine is called to finish setting up the fileobject based on the
    information in the Irpcontext.

Arguments:

    RxContext - the current workitem

    Irp -  The create irp

    Fcb -  The fcb that has been found


Return Value:

    none

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PAGED_CODE();

    ASSERT( (RxContext->pFobx == NULL) || (NodeType( RxContext->pFobx ) == RDBSS_NTC_FOBX) );

    if (Fcb != NULL) {

        ASSERT( NodeTypeIsFcb( Fcb ) );

        //
        //  If this is a temporary file, note it in the FcbState
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_TEMPORARY ) && (FileObject != NULL)) {
            SetFlag( FileObject->Flags, FO_TEMPORARY_FILE );
        }
    }

    //
    //  Now set the fscontext fields of the file object
    //

    if (FileObject != NULL) {
        FileObject->FsContext = Fcb;

        if (RxContext->pFobx != NULL) {
            ULONG_PTR StackBottom,StackTop;

            IoGetStackLimits( &StackTop, &StackBottom );

            //
            //  Determine if the FileObject passed in is on the stack. If it is do
            //  not squirrel away the file object in the FOBX. Otherwise stash it
            //  away.
            //

            if (((ULONG_PTR)FileObject <= StackBottom) ||
                ((ULONG_PTR)FileObject >= StackTop)) {

                RxContext->pFobx->AssociatedFileObject = FileObject;

            } else {

                RxContext->pFobx->AssociatedFileObject = NULL;
            }

            if (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT)) {

                SetFlag( RxContext->pFobx->Flags, FOBX_FLAG_DFS_OPEN );
                RxDbgTrace( 0, Dbg, ("RxSetupNetFileObject %lx Dfs aware FOBX\n", RxContext->pFobx));

            } else {

                ClearFlag( RxContext->pFobx->Flags, FOBX_FLAG_DFS_OPEN );
                RxDbgTrace( 0, Dbg, ("RxSetupNetFileObject %lx Dfs unaware FOBX\n", RxContext->pFobx));
            }
        }

        FileObject->FsContext2 = RxContext->pFobx;
        FileObject->SectionObjectPointer = &Fcb->NonPaged->SectionObjectPointers;

        //
        //  The create is being completed successfully. Turn off the remaining
        //  desired access flags in the IRP. This is required by Praerit/Robert
        //  to facilitate policy code.
        //

        if (IrpSp->Parameters.Create.SecurityContext != NULL) {
            SetFlag( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess,
                     IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess );
            IrpSp->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess = 0;
        }
    }
}

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine prepares an instance of RX_CONTEXT for reuse. This centralizes all
    the actions required to be undone, i.e., accquistion of resources etc.

Arguments:

    RxContext - the current workitem

--*/
{
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    RxDbgTrace(0, Dbg, ("RxpPrepareCreateContextForReuse canonname %08lx\n",
                                RxContext->Create.CanonicalNameBuffer));

    //
    //  the order is important here...release the fcb first
    //

    if (RxContext->Create.FcbAcquired) {
        RxReleaseFcb( RxContext, RxContext->pFcb );
        RxContext->Create.FcbAcquired = FALSE;
    }

    RxFreeCanonicalNameBuffer( RxContext );

    if ((RxContext->Create.pVNetRoot != NULL) ||
        (RxContext->Create.NetNamePrefixEntry != NULL)) {

        PRX_PREFIX_TABLE RxNetNameTable = RxContext->RxDeviceObject->pRxNetNameTable;

        RxAcquirePrefixTableLockShared( RxNetNameTable, TRUE );

        //
        //  Dereference the data structures associated with the create operation
        //

        if (RxContext->Create.pVNetRoot != NULL) {
            RxDereferenceVNetRoot( (PV_NET_ROOT)(RxContext->Create.pVNetRoot), LHS_SharedLockHeld );
            RxContext->Create.pVNetRoot = NULL;
        }

        RxReleasePrefixTableLock( RxNetNameTable );
    }
}

NTSTATUS
RxCreateFromNetRoot(
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called during from CommonCreate once a good netroot has
    been established. This routine builds an Fcb, if necessary, and tries to
    collapse the open onto an existing open if it can. If it cannot, then it
    constructs an InTransition srv_open on this netroot and passes the open down
    to the minirdr. By the time that we get here, there is a reference on the
    netroot but we do not have the netname tablelock. When we complete the context,
    this reference is removed.

Arguments:

    RxContext - the current workitem

    RemainingName - the name of the file after the netroot prefix is removed;
                    it has been canonicalized.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS    Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PV_NET_ROOT VNetRoot;
    PNET_ROOT   NetRoot;
    PFCB        Fcb;
    PSRV_OPEN   SrvOpen;
    PFOBX       Fobx;

    ACCESS_MASK DesiredAccess;
    ULONG       ShareAccess;
    BOOLEAN     OpenTargetDirectory;

    PNT_CREATE_PARAMETERS cp;

    PAGED_CODE();

    VNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;
    NetRoot = (PNET_ROOT)RxContext->Create.pNetRoot;
    Fcb = NULL;
    SrvOpen = NULL;
    Fobx = NULL;

    //
    //  Fix for bug 501657 (opening file with MAXIMUM_ALLOWED flag does not permit read/write
    //

    DesiredAccess = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;

    if(FlagOn( DesiredAccess, MAXIMUM_ALLOWED )) {
        DesiredAccess = FILE_ALL_ACCESS;
        IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess = DesiredAccess;
    } else {
        DesiredAccess &= FILE_ALL_ACCESS;
    }

    ShareAccess = FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_VALID_FLAGS );

    OpenTargetDirectory = BooleanFlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY );

    cp = &RxContext->Create.NtCreateParameters;

    RxDbgTrace(+1, Dbg, ("RxCreateFromNetRoot   Name=%wZ\n", RemainingName ));

    //
    //  A Create request cannot succeed without a valid NET_ROOT instance.
    //

    if (RxContext->Create.pNetRoot == NULL){
        RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot   Couldn't create the FCB: No NetRoot!!\n"));
        return STATUS_NO_SUCH_FILE;
    }

    //
    //  we cannot proceed unless this device owns the srvcall.
    //

    if (RxContext->RxDeviceObject != RxContext->Create.pNetRoot->pSrvCall->RxDeviceObject){
        RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot   wrong DeviceObject!!!!!\n"));
        return STATUS_BAD_NETWORK_PATH;
    }

    //
    //  The DFS driver builds up a logical name space from different physical
    //  volumes. In order to distinguish processing the DFS driver sets the
    //  FsContext2 field to DFS_OPEN_CONTEXT or DFS_DOWWNLEVEL_OPEN_CONTEXT. At
    //  this point in the control flow the V_NET_ROOT has been determined. This
    //  in turn determines the NET_ROOT and SRV_CALL instance and indirectly
    //  also determines the Server type. Uplevel opens can only be permitted to
    //  servers that are DFS aware.
    //

    if ((cp->DfsContext == UIntToPtr( DFS_OPEN_CONTEXT )) &&
        !FlagOn( NetRoot->SrvCall->Flags, SRVCALL_FLAG_DFS_AWARE_SERVER )) {
        return STATUS_DFS_UNAVAILABLE;
    }

    if ((cp->DfsContext == UIntToPtr( DFS_DOWNLEVEL_OPEN_CONTEXT )) &&
        FlagOn( NetRoot->Flags, NETROOT_FLAG_DFS_AWARE_NETROOT )) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    if (NetRoot->Type == NET_ROOT_PRINT) {

        //
        //  allow share read and write to the printer server
        //

        ShareAccess = FILE_SHARE_VALID_FLAGS;
    }

    //
    //  if the create request is for opening the target directory for a rename
    //  a fake FCB needs to be created.
    //

    if (OpenTargetDirectory) {
        if (FlagOn( cp->DesiredAccess, DELETE )) {

            RxPurgeRelatedFobxs( VNetRoot->NetRoot,
                                 RxContext,
                                 ATTEMPT_FINALIZE_ON_PURGE,
                                 NULL );
        }

        Fcb = RxCreateNetFcb( RxContext, Irp, VNetRoot, RemainingName );

        if (Fcb != NULL) {
            Fcb->Header.NodeTypeCode = (USHORT)RDBSS_NTC_OPENTARGETDIR_FCB;
            RxContext->Create.FcbAcquired = FALSE;

            //
            //  Normally the FileObjects reference the associated SRV_OPEN instance
            //  via the FileObjectExtension(FOBX). In this case there is no
            //  corresponding SRV_OPEN and a reference on the FCB is maintained.
            //

            RxContext->Create.NetNamePrefixEntry = NULL; //  don't let it deref the netroot!!!!

            FileObject->FsContext = Fcb;

            if (RxContext->pFobx != NULL) {
                if (FileObject->FsContext2 == UIntToPtr(DFS_OPEN_CONTEXT)) {
                    SetFlag( RxContext->pFobx->Flags, FOBX_FLAG_DFS_OPEN );
                } else {
                    ClearFlag( RxContext->pFobx->Flags, FOBX_FLAG_DFS_OPEN );
                }
            }

            FileObject->FsContext2 = NULL;

            Fcb->UncleanCount += 1;
            Fcb->OpenCount += 1;

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );
            if (Status == STATUS_SUCCESS) {
                RxReferenceNetFcb( Fcb );
                RxReleaseFcb( RxContext, Fcb );
            } else {
                RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot -- Couldn't acquire FCB:(%lx) %lx!\n",Fcb,Status));
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return Status;
    }

    Status = RxFindOrCreateFcb( RxContext, Irp, RemainingName, &Fcb );

    ASSERT( (Fcb != NULL) || (Status != STATUS_SUCCESS) );

    if ((Status != STATUS_SUCCESS) || (Fcb == NULL)) {

        RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot   Couldn't create the FCB%c\n", '!' ));
        return Status;
    }

    //
    //  If the Create request is for a mailslot no further processing is required.
    //

    if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CREATE_MAILSLOT )) {

        Fcb->Header.NodeTypeCode = RDBSS_NTC_MAILSLOT;

        RxTransitionNetFcb( Fcb, Condition_Good );
        RxLog(("Transitioning FCB %lx Condition %lx\n",Fcb,Fcb->Condition));
        RxWmiLog(LOG,
                 RxCollapseOrCreateSrvOpen,
                 LOGPTR(Fcb)
                 LOGULONG(Fcb->Condition));

        Fcb->OpenCount += 1;
        RxSetupNetFileObject( RxContext, Irp, Fcb );
        return Status;

    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }


    //
    //  This Create request is for a file/directory or pipe for which further
    //  processing is required. At this point the corresponding FCB resource
    //  has been accquired ( even for newly constructed FCB's). If this is not the
    //  first open then those requests that do not meet the necessary share access
    //  constraints can be rejected quickly. Note that this early check avoids
    //  a potential Network trip in some cases.
    //

    RxDumpCurrentAccess( "shareaccess status before anything....", "", "DumpAcc000", &Fcb->ShareAccess );
    if (Fcb->OpenCount > 0) {

        Status = RxCheckShareAccess( DesiredAccess,
                                     ShareAccess,
                                     FileObject,
                                     &Fcb->ShareAccess,
                                     FALSE,
                                     "early check per useropens",
                                     "EarlyPerUO" );

        if (Status != STATUS_SUCCESS) {
            RxDereferenceNetFcb( Fcb );
            return Status;
        }
    }

    if (FlagOn( cp->CreateOptions, FILE_DELETE_ON_CLOSE ) &&
        (FlagOn( cp->DesiredAccess, ~DELETE ) == 0)) {

        //
        //  if the file is opened for delete only, we push out possible delayed close on this file
        //  so that mini rdr has the opportunity to do the perfomance optimization, i.e. delete the
        //  file without even open it.
        //

        RxPurgeFcbInSystemCache( Fcb,
                                 NULL,
                                 0,
                                 TRUE,
                                 FALSE );

        RxScavengeRelatedFobxs( Fcb );
    }

    //
    //  A valid FCB which meets the Share access requirements of the create
    //  request is on hand. The associated SRV_OPEN should be either located
    //  amongst the existing SRV_OPEN's or a new SRV_OPEN instance needs to
    //  be constructed.
    //

    try {
        ULONG   CreateOptions;
        BOOLEAN DeleteOnClose;
        BOOLEAN NoIntermediateBuffering;

        Status = RxCollapseOrCreateSrvOpen( RxContext, Irp, Fcb );

        IF_DEBUG {
            if (Status == STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg, ("RxCreateFromNetRoot   Collapsed onto %08lx\n",
                                   RxContext->pRelevantSrvOpen ));
            } else {
                RxDbgTrace(0, Dbg, ("RxCreateFromNetRoot   Error in Srvopen Collapse %08lx\n", Status ));
            }
        }

        if (Status != STATUS_SUCCESS) {
            try_return( Status );
        }


        SrvOpen = (PSRV_OPEN)(RxContext->pRelevantSrvOpen);
        Fobx = (PFOBX)(RxContext->pFobx);

        CreateOptions = IrpSp->Parameters.Create.Options;
        NoIntermediateBuffering = BooleanFlagOn( CreateOptions, FILE_NO_INTERMEDIATE_BUFFERING );
        DeleteOnClose = BooleanFlagOn( CreateOptions, FILE_DELETE_ON_CLOSE );

        //
        //  If the FCB has multiple SRV_OPEN instances associated with it then it
        //  is possible for the Share access associated with the FCB has changed
        //  if the FCB resource was dropped by the mini redirector.
        //

        if (Fcb->OpenCount > 0) {

            Status = RxCheckShareAccess( DesiredAccess,
                                         ShareAccess,
                                         FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE,
                                         "second check per useropens",
                                         "2ndAccPerUO" );

            if (Status != STATUS_SUCCESS) {

                //
                //  When this Fobx goes away it will remove an open from the SrvOpen.
                //  Add a reference to the SrvOpen here to account for this.  This
                //  will prevent the SrvOpen from getting closed prematurely.
                //

                SrvOpen->OpenCount += 1;

                RxDereferenceNetFobx( RxContext->pFobx, LHS_LockNotHeld );
                RxContext->pFobx = NULL;
                try_return( Status );
            }
        } else {

            if (RxContext->Create.pNetRoot->Type != NET_ROOT_PIPE) {
                RxSetShareAccess( DesiredAccess,
                                  ShareAccess,
                                  FileObject,
                                  &Fcb->ShareAccess,
                                  "initial shareaccess setup",
                                  "InitShrAcc" );
            }
        }

        RxSetupNetFileObject( RxContext, Irp, Fcb );

        RxDumpCurrentAccess( "shareaccess status after checkorset....",
                             "",
                             "CurrentAcc",
                             &Fcb->ShareAccess );

        //
        //  At this point the necessary infrastructure to handle the create
        //  request successfully has been established. What remains to be done
        //  is the appropriate initialization of the FileObject( owned by IO
        //  subsystem), the FileObjectExtension(FOBX owned by RDBSS) and updating
        //  the fields associated with the SRV_OPEN and the FCB. This largely
        //  depends upon whether the FCB/SRV_OPEN was newly constructed or
        //  was collapsed.
        //
        //  SRV_OPEN changes
        //      1) For a newly constructed SRV_OPEN the buffering state needs to
        //         be updated
        //
        //  FCB changes
        //      1) for an existing FCB the SHARE ACCESS needs to be updated.
        //
        //  In all the cases the corresponing OpenCounts and UncleanCounts needs
        //  to be updated.
        //

        if ((Fcb->OpenCount > 0) &&
            (RxContext->Create.pNetRoot->Type != NET_ROOT_PIPE)) {

            RxUpdateShareAccess( FileObject,
                                 &Fcb->ShareAccess,
                                 "update share access",
                                 "UpdShrAcc" );
        }

        //
        //  incrementing the uncleancount must be done before RxChangeBufferingState
        //  because that routine will purge the cache otherwise if unclenacount==0
        //

        Fcb->UncleanCount += 1;

        if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {
            Fcb->UncachedUncleanCount += 1;
        } else {
            //  maybe we should turn on the FO_CACHE_SUPPORTED flag
        }

        //
        //  For the first open, we want to initialize the Fcb buffering state flags
        //  to the default value
        //

        if ((SrvOpen->OpenCount == 0) &&
            (Fcb->UncleanCount == 1)  &&
            (!FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE ))) {

            RxChangeBufferingState( SrvOpen, NULL, FALSE );
        }

        //
        //  this might be from a previous usage.
        //

        ClearFlag( Fcb->FcbState, FCB_STATE_DELAY_CLOSE );

        //
        //  Reference the Objects as needed
        //

        Fcb->OpenCount += 1;
        SrvOpen->UncleanFobxCount += 1;
        SrvOpen->OpenCount += 1;

        SrvOpen->ulFileSizeVersion = Fcb->ulFileSizeVersion;

        //
        //  For NoIntermediateBuffering opens, we need to disable caching on
        //  this FCB
        //

        if (NoIntermediateBuffering) {

            SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_DONTUSE_READ_CACHING );
            SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHING );
            ClearFlag( Fcb->FcbState, FCB_STATE_READCACHING_ENABLED );
            ClearFlag( Fcb->FcbState, FCB_STATE_WRITECACHING_ENABLED );
            RxPurgeFcbInSystemCache( Fcb, NULL, 0, TRUE, TRUE );
        }

        RxUpdateShareAccessPerSrvOpens(SrvOpen);

        //
        //  The file object extensions needs to be updated with configuration
        //  information for pipes and spool files. In addition the appropriate
        //  flags needs to be set based upon the parameters specfied in the
        //  request.
        //  For spool files the WriteSerializationQueue is the only field of
        //  interest.
        //

        //
        //  Mark the DeleteOnClose bit if the operation was successful.
        //

        if (DeleteOnClose) {
            SetFlag( Fobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE );
        }

        if (Fobx != NULL) {

            //
            //  fill in various type-specific fields of the fobx
            //

            switch (RxContext->Create.pNetRoot->Type) {

            case NET_ROOT_PIPE:

                SetFlag( FileObject->Flags, FO_NAMED_PIPE );

                //
                //  lack of break intentional
                //

            case NET_ROOT_PRINT:

                Fobx->PipeHandleInformation = &Fobx->Specific.NamedPipe.PipeHandleInformation;
                Fobx->Specific.NamedPipe.CollectDataTime.QuadPart = 0;
                Fobx->Specific.NamedPipe.CollectDataSize = RxContext->Create.pNetRoot->NamedPipeParameters.DataCollectionSize;
                Fobx->Specific.NamedPipe.TypeOfPipe      = RxContext->Create.PipeType;
                Fobx->Specific.NamedPipe.ReadMode        = RxContext->Create.PipeReadMode;
                Fobx->Specific.NamedPipe.CompletionMode  = RxContext->Create.PipeCompletionMode;
                InitializeListHead( &Fobx->Specific.NamedPipe.ReadSerializationQueue );
                InitializeListHead( &Fobx->Specific.NamedPipe.WriteSerializationQueue );
                break;

            default:

                //
                //  check if we have post create handler installed on devfcb. The lwio driver
                //  opens the lanman driver and sets its mrxdispatch on the device fcb so that
                //  it gets informed of file creates on lwio capable servers.
                //

                if (RxDeviceFCB.MRxDispatch != NULL &&
                    NodeTypeIsFcb( Fcb ) &&
                    (NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_FILE) &&
                    FlagOn( Fcb->NetRoot->SrvCall->Flags, SRVCALL_FLAG_LWIO_AWARE_SERVER )) {

                    ExAcquireResourceSharedLite( &RxData.Resource, TRUE );
                    if (RxDeviceFCB.MRxDispatch != NULL &&
                        RxDeviceFCB.MRxDispatch->MRxCreate != NULL) {

                        RxDeviceFCB.MRxDispatch->MRxCreate( RxContext );
                    }
                    ExReleaseResourceLite( &RxData.Resource );
                }

                NOTHING;
            }
        }

try_exit: NOTHING;

    } finally {

        RxDbgTrace(0, Dbg, ("--->Fobx=%08lx, Ref=%08lx\n", Fobx, (Fobx)?Fobx->NodeReferenceCount:0 ));
        RxDbgTrace(0, Dbg, ("--->SrvOpen=%08lx, Ref=%08lx\n", SrvOpen, (SrvOpen)?SrvOpen->NodeReferenceCount:0 ));
        RxDbgTrace(0, Dbg, ("--->Fcb=%08lx, Ref=%08lx\n", Fcb, (Fcb)?Fcb->NodeReferenceCount:0 ));

        //
        //  get rid of the reference on the fcb; we also finalize here if we can
        //

        if (Fcb->OpenCount == 0) {

            //
            //  if we have the lock we can finalize.........
            //

            if (RxContext->Create.FcbAcquired) {

                //
                //  try to finalize right now
                //

                RxContext->Create.FcbAcquired = !RxDereferenceAndFinalizeNetFcb( Fcb, RxContext, FALSE, FALSE);

                //
                //  the tracker gets very unhappy if you don't do this!
                //

                if (!RxContext->Create.FcbAcquired) {
                    RxTrackerUpdateHistory( RxContext, NULL, 'rrCr', __LINE__, __FILE__, 0 );
                }
            }

        } else {

            //
            //  cant finalize now.....just remove our reference.......
            //

            RxDereferenceNetFcb( Fcb );
        }
    }

    RxDbgTrace( -1, Dbg, ("Exiting RxCreateFromNetRoot status=%08lx\n", Status) );

    return Status;
}


NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles the call down from the MUP to claim a name. We pass the name down
    to the routine for finding/creating connections.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the ioctl and Context

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PIRP Irp = RxContext->CurrentIrp;
    PEPROCESS Process = IoGetRequestorProcess( Irp );
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PQUERY_PATH_REQUEST QueryPathRequest;
    PQUERY_PATH_RESPONSE QueryPathResponse;
    UNICODE_STRING FilePathName;
    UNICODE_STRING CanonicalName;
    UNICODE_STRING RemainingName;

    NET_ROOT_TYPE NetRootType = NET_ROOT_WILD;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxPrefixClaim -> %08lx\n", 0));

    if( !_stricmp( PsGetProcessImageFileName( Process ), SPOOLER_PROCESS_NAME ) )
    {
        ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
    }

    //
    //  Initialize RemainingName.
    //

    RemainingName.Buffer = NULL;
    RemainingName.Length = 0;
    RemainingName.MaximumLength = 0;

    //
    //  Only kernel mode callers allowed to use this path
    //

    if (Irp->RequestorMode == UserMode) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        return Status;
    }

    QueryPathResponse = Irp->UserBuffer;

    if (RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL) {

        QueryPathRequest = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        RxContext->MajorFunction = IRP_MJ_CREATE;

        RxContext->PrefixClaim.SuppliedPathName.Buffer =
            (PWCHAR)RxAllocatePoolWithTag( NonPagedPool,
                                           QueryPathRequest->PathNameLength,
                                           RX_MISC_POOLTAG);

        if (RxContext->PrefixClaim.SuppliedPathName.Buffer == NULL) {
            try_return( Status = STATUS_INSUFFICIENT_RESOURCES );
        }

        RtlCopyMemory( RxContext->PrefixClaim.SuppliedPathName.Buffer,
                       QueryPathRequest->FilePathName,
                       QueryPathRequest->PathNameLength );

        RxContext->PrefixClaim.SuppliedPathName.Length = (USHORT)QueryPathRequest->PathNameLength;
        RxContext->PrefixClaim.SuppliedPathName.Length = (USHORT)QueryPathRequest->PathNameLength;

        RtlZeroMemory( &RxContext->Create, sizeof( RxContext->Create ) );

        RxContext->Create.ThisIsATreeConnectOpen = TRUE;
        RxContext->Create.NtCreateParameters.SecurityContext = QueryPathRequest->SecurityContext;

    } else {

        ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );
        ASSERT( RxContext->PrefixClaim.SuppliedPathName.Buffer != NULL );
    }

    FilePathName  = RxContext->PrefixClaim.SuppliedPathName;
    RemainingName = FilePathName;

    Status = RxFirstCanonicalize( RxContext, Irp, &FilePathName, &CanonicalName, &NetRootType );

    if (Status == STATUS_SUCCESS) {
        Status = RxFindOrConstructVirtualNetRoot( RxContext,
                                                  Irp,
                                                  &CanonicalName,
                                                  NetRootType,
                                                  &RemainingName );
    }

try_exit:

    if (Status != STATUS_PENDING) {

        if (Status == STATUS_SUCCESS) {
            QueryPathResponse->LengthAccepted = RxContext->PrefixClaim.SuppliedPathName.Length - RemainingName.Length;
        }

        if (RxContext->MajorFunction == IRP_MJ_CREATE) {

            if (RxContext->PrefixClaim.SuppliedPathName.Buffer != NULL) {
                RxFreePool (RxContext->PrefixClaim.SuppliedPathName.Buffer );
            }

            RxpPrepareCreateContextForReuse( RxContext );
            RxContext->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        }
    }

    RxDbgTrace(0, Dbg, ("RxPrefixClaim -> Status %08lx\n", Status));

    return Status;
}

NTSTATUS
RxCreateTreeConnect (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the routine for creating/opening a TC.

Arguments:

    RxContext -

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;

    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    UNICODE_STRING CanonicalName, RemainingName;
    PUNICODE_STRING OriginalName = &FileObject->FileName;
    LOCK_HOLDING_STATE LockHoldingState = LHS_LockNotHeld;

    NET_ROOT_TYPE NetRootType = NET_ROOT_WILD;

    ULONG EaInformationLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCreateTreeConnect entry\n"));

    CanonicalName.Length = CanonicalName.MaximumLength = 0;
    CanonicalName.Buffer = NULL;

    Status = RxFirstCanonicalize( RxContext, Irp, OriginalName, &CanonicalName, &NetRootType );

    if (Status != STATUS_SUCCESS) {

        RxDbgTraceUnIndent( -1,Dbg );
        return Status;
    }

    RxContext->Create.ThisIsATreeConnectOpen = TRUE;
    RxContext->Create.TreeConnectOpenDeferred = FALSE;

    RxContext->Create.TransportName.Length = 0;
    RxContext->Create.TransportName.MaximumLength = 0;
    RxContext->Create.TransportName.Buffer = NULL;

    RxContext->Create.UserName.Length = 0;
    RxContext->Create.UserName.MaximumLength = 0;
    RxContext->Create.UserName.Buffer = NULL;

    RxContext->Create.Password.Length = 0;
    RxContext->Create.Password.MaximumLength = 0;
    RxContext->Create.Password.Buffer = NULL;

    RxContext->Create.UserDomainName.Length = 0;
    RxContext->Create.UserDomainName.MaximumLength = 0;
    RxContext->Create.UserDomainName.Buffer = NULL;

    EaInformationLength = IrpSp->Parameters.Create.EaLength;

    if (EaInformationLength > 0) {

        BOOLEAN DeferredConnection = FALSE;
        BOOLEAN CredentialsSupplied = FALSE;

        PFILE_FULL_EA_INFORMATION EaEntry;

        EaEntry = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

        ASSERT( EaEntry != NULL );

        for(;;) {

            PUNICODE_STRING TargetString;

            //
            //  Note: iosubsystem verifies all EaNames are valid and null terminated
            //

            if (strcmp( EaEntry->EaName, EA_NAME_CONNECT ) == 0) {
                DeferredConnection = TRUE;
            } else if ((strcmp( EaEntry->EaName, EA_NAME_USERNAME ) == 0) ||
                       (strcmp( EaEntry->EaName, EA_NAME_PASSWORD ) == 0) ||
                       (strcmp( EaEntry->EaName, EA_NAME_DOMAIN ) == 0)) {
                CredentialsSupplied = TRUE;
            }

            TargetString = NULL;

            RxDbgTrace( 0, Dbg, ("RxCreateTreeConnect: Processing EA name %s\n", EaEntry->EaName) );

            if (strcmp( EaEntry->EaName, EA_NAME_TRANSPORT ) == 0) {
                TargetString = &RxContext->Create.TransportName;
            } else if (strcmp( EaEntry->EaName, EA_NAME_USERNAME ) == 0) {
                TargetString = &RxContext->Create.UserName;
            } else if (strcmp( EaEntry->EaName, EA_NAME_PASSWORD ) == 0) {
                TargetString = &RxContext->Create.Password;
            } else if (strcmp( EaEntry->EaName, EA_NAME_DOMAIN ) == 0) {
                TargetString = &RxContext->Create.UserDomainName;
            } else {
                RxDbgTrace( 0, Dbg, ("RxCreateTreeConnect: Invalid EA name/value %s\n", EaEntry->EaName) );
            }

            if (TargetString != NULL) {
                TargetString->Length = EaEntry->EaValueLength;
                TargetString->MaximumLength = EaEntry->EaValueLength;
                TargetString->Buffer = (PWSTR)(EaEntry->EaName + EaEntry->EaNameLength + 1);
            }

            if (EaEntry->NextEntryOffset == 0) {
                break;
            } else {
                EaEntry = (PFILE_FULL_EA_INFORMATION) Add2Ptr( EaEntry, EaEntry->NextEntryOffset );
            }
        }

        if (!CredentialsSupplied && DeferredConnection) {
            RxContext->Create.TreeConnectOpenDeferred = TRUE;
        }

    }

    Status = RxFindOrConstructVirtualNetRoot( RxContext,
                                              Irp,
                                              &CanonicalName,
                                              NetRootType,
                                              &RemainingName );

    if(Status == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
        //
        //  Scavenge the VNetRoots
        //

        RxScavengeVNetRoots( RxContext->RxDeviceObject );

        Status = RxFindOrConstructVirtualNetRoot( RxContext,
                                                  Irp,
                                                  &CanonicalName,
                                                  NetRootType,
                                                  &RemainingName );
    }

    //
    //  We have to check whether the path is valid if it is provided.
    //

    if ((Status == STATUS_SUCCESS) && (RemainingName.Length > 0)) {

        MINIRDR_CALL( Status,
                      RxContext,
                      RxContext->Create.pNetRoot->pSrvCall->RxDeviceObject->Dispatch,
                      MRxIsValidDirectory,
                      (RxContext,&RemainingName) );
    }

    if (Status == STATUS_SUCCESS) {

        PV_NET_ROOT VNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;

        RxReferenceVNetRoot(VNetRoot);

        if (InterlockedCompareExchange( &VNetRoot->AdditionalReferenceForDeleteFsctlTaken, 1, 0) != 0) {

            //
            //  The net use connections have a two phase delete protocol. An FSCTL to
            //  delete the connection is used followed by a close of the corresponding file
            //  object. The additional reference ensures that the finalization is delayed till
            //  the actual close of the corresponding file object.
            //

            RxDereferenceVNetRoot( VNetRoot, LHS_LockNotHeld );
        }

        FileObject->FsContext  = &RxDeviceFCB;
        FileObject->FsContext2 = RxContext->Create.pVNetRoot;

        VNetRoot->IsExplicitConnection = TRUE;
        RxContext->Create.pVNetRoot->NumberOfOpens += 1;

        RxContext->Create.pVNetRoot = NULL;
        RxContext->Create.pNetRoot  = NULL;
        RxContext->Create.pSrvCall  = NULL;
    }

    RxDbgTrace(-1, Dbg, ("RxCreateTreeConnect exit, status=%08lx\n", Status));
    return Status;
}

NTSTATUS
RxPrepareToReparseSymbolicLink(
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN SymbolicLinkEmbeddedInOldPath,
    IN PUNICODE_STRING NewPath,
    IN BOOLEAN NewPathIsAbsolute,
    OUT PBOOLEAN ReparseRequired
    )
/*++

Routine Description:

    This routine sets up the file object name to facilitate a reparse. This routine
    is used by the mini redirectors to traverse symbolic links.

Arguments:

    RxContext - the RDBSS context

    SymbolicLinkEmbeddedInOldPath - if TRUE a symbolic link was encountered as part of the
                traversal of the old path.

    NewPath  - the new path name to be traversed.

    NewPathIsAbsolute - if FALSE, \Device\Mup should be prepended to NewPath. If TRUE,
                NewPath is the full path to which to reparse. In this case, the buffer
                containing NewPath is used directly, rather than allocating a new one.

    ReparseRequired - set to TRUE if Reparse is required.

Return Value:

    NTSTATUS - the return status for the operation

Notes:

    The second parameter passed to this routine is a very important one. In order
    to preserve the correct semantics it should be carefully used. As an example
    consider the old path \A\B\C\D wherein C happens to be symbolic link. In such
    cases the symbolic link is embedded in the path as opposed to the case when
    D happens to be a symbolic link. In the former case the reparse constitutes
    an intermediate step as opposed to the later case when it constitutes the
    final step of the name resolution.

    If DELETE access is specified the OPEN is denied for all in which the symbolic
    link is not embedded. It is possible that if DELETE access were the only one
    specified then the OPEN attempt must succeed without reparse. This will be
    conformant with UNIX symbolic link semantics.

    As part of this routine the RxContext is also tagged appropriately. This ensures
    that the return value can be crosschecked with the invocation of this routine.
    Once this routine is invoked the mini rdr has to return STATUS_REPARSE.

    The value of *ReparseRequired assumes significance only if STATUS_SUCCESS is
    returned from this routine. FALSE implies that no reparse attempt is required
    and the symbolic link file itself should be manipulated as opposed to the
    target of the link. TRUE implies that a reparse attempt was successfully setup.
    In such cases it is imperative that the mini redirector return STATUS_REPARSE
    for the associated MRxCreate call. The wrapper will initiate a check for this.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation( RxContext->CurrentIrp )->FileObject;

    *ReparseRequired = FALSE;

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {

        ACCESS_MASK DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;

        //
        //  Check the Create Parameters to determine the type of ACCESS specified.
        //  if only DELETE access was specified then no reparse is required and the
        //  operation is to be performed on the link itself.
        //

        if (!SymbolicLinkEmbeddedInOldPath) {

            RxDbgTrace( 0, Dbg, ("Desired Access In Reparse %lx\n",DesiredAccess) );

            if (FlagOn( DesiredAccess, DELETE )) {
                *ReparseRequired = FALSE;
                if (FlagOn( DesiredAccess, ~DELETE )) {
                    Status = STATUS_ACCESS_DENIED;
                }
            } else {

                //
                //  If the appropriate flags were specified in the CREATE parameters then
                //  the reparse is to be suppressed since the intention is to open the link
                //  itself as opposed to the TARGET.
                //  TBD. -- The exact combination of flags will be determined for NT 5.0.
                //

                //
                //  If none of the above conditions were satisfied then the reparse is required
                //

                *ReparseRequired = TRUE;
            }
        } else {
            *ReparseRequired = TRUE;
        }

        if (*ReparseRequired) {

            PWSTR  FileNameBuffer;
            USHORT DeviceNameLength;
            USHORT ReparsePathLength;

            if (!NewPathIsAbsolute) {

                DeviceNameLength = wcslen( DD_MUP_DEVICE_NAME ) * sizeof(WCHAR);

                //
                //  On a reparse attempt the I/O subsystem will null out the related file
                //  object field.
                //

                ReparsePathLength = (DeviceNameLength + NewPath->Length);

                FileNameBuffer = ExAllocatePoolWithTag( PagedPool | POOL_COLD_ALLOCATION,
                                                        ReparsePathLength,
                                                        RX_MISC_POOLTAG );

                if (FileNameBuffer != NULL) {

                    //
                    //  Copy the device name
                    //

                    RtlCopyMemory( FileNameBuffer, DD_MUP_DEVICE_NAME, DeviceNameLength );

                    //
                    //  Copy the new name
                    //

                    RtlCopyMemory( Add2Ptr( FileNameBuffer, DeviceNameLength ), NewPath->Buffer, NewPath->Length );

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {

                FileNameBuffer = NewPath->Buffer;
                ReparsePathLength = NewPath->Length;
            }

            //
            //  Free up the buffer associated with the old name.
            //

            ExFreePool( FileObject->FileName.Buffer );

            //
            //  Set up the file object with the new name.
            //

            FileObject->FileName.Buffer = FileNameBuffer;
            FileObject->FileName.Length = ReparsePathLength;
            FileObject->FileName.MaximumLength = FileObject->FileName.Length;

            //
            //  Mark the RxContext so that the return code can be verified. A mini
            //  redirector has to return STATUS_REPARSE is this routine was invoked
            //  as a response to MRxCreate. This will be enforced by marking the
            //  RxContext appropriately and comparing the returned status code against
            //  the expected value.
            //

            SetFlag( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_REPARSE );
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    RxDbgTrace(0, Dbg, ("RxPrepareToReparseSymbolicLink : ReparseReqd: %lx, Status %lx\n",*ReparseRequired,Status));
    return Status;
}

NTSTATUS
RxCommonCreate (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for creating/opening a file called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - the return status for the operation

--*/
{
    NTSTATUS Status;
    ULONG Disposition;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    UNICODE_STRING RemainingName;

    PAGED_CODE();

#if 0 && defined(REMOTE_BOOT)
    {
        PWCH buffer = ExAllocatePoolWithTag( NonPagedPool, FileObject->FileName.Length + 2,RX_MISC_POOLTAG );
        BOOLEAN watchFile = FALSE;
        BOOLEAN logFile = FALSE;
        if ( buffer != NULL ) {

            RtlCopyMemory( buffer, FileObject->FileName.Buffer, FileObject->FileName.Length );
            buffer[FileObject->FileName.Length/sizeof(WCHAR)] = 0;
            if (WatchAllFiles) watchFile = TRUE;
            if (watchFile && (!FirstWatchOnly || IsFirstWatch) ) {
                logFile = TRUE;
                IsFirstWatch = FALSE;
            }
            if (LogAllFiles) logFile = TRUE;
            if (logFile) {
                DbgPrint( "RxCommonCreate: create IRP for %ws %x\n", buffer, FileObject );
            }
            ExFreePool(buffer);
        }
    }
#endif //  defined(REMOTE_BOOT)

    //
    //  check for the case of a device open; if so, handle and get out now
    //

    if ((FileObject->FileName.Length == 0)  && (FileObject->RelatedFileObject == NULL)) {

        //
        //  here we are just opening the device; set the FsContext&counts and get out
        //

        FileObject->FsContext = &RxDeviceFCB;
        FileObject->FsContext2 = NULL;
        RxDeviceFCB.OpenCount += 1;
        RxDeviceFCB.UncleanCount += 1;

        Irp->IoStatus.Information = FILE_OPENED;

        RxDbgTrace( 0, Dbg, ("RxDeviceCreate, File = %08lx\n", FileObject) );


        RxLog(( "DevOpen %lx %lx %lx", RxContext, FileObject, RxContext->RxDeviceObject ));
        RxLog(( "DevOpen2 %wZ", &RxContext->RxDeviceObject->DeviceName));
        RxWmiLog( LOG,
                  RxCommonCreate_1,
                  LOGPTR(RxContext)
                  LOGPTR(FileObject)
                  LOGPTR(RxContext->RxDeviceObject)
                  LOGUSTR(RxContext->RxDeviceObject->DeviceName) );

        return STATUS_SUCCESS;
    }

    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_STRUCTURED_STORAGE ) == FILE_STRUCTURED_STORAGE) {

        //
        //  Deprecated open type
        //

        return STATUS_INVALID_PARAMETER;
    }


    //
    //  Init the file name that will trigger the trace to start.
    //  To trigger on a different file edit DbgTriggerName with debugger (don't
    //  forget the null).  Set DbgTriggerIrpCount to number of IRPs to trace and
    //  then set DbgTriggerState to 0.
    //

    RxDbgTraceDoit(
        if (DbgTriggerState == DBG_TRIGGER_INIT) {

            NTSTATUS Status;

            DbgTriggerState = DBG_TRIGGER_LOOKING;
            DbgTriggerNameStr.Length = (USHORT)strlen( DbgTriggerName );
            DbgTriggerNameStr.MaximumLength = (USHORT)strlen( DbgTriggerName );
            DbgTriggerNameStr.Buffer = &DbgTriggerName[0];

            Status = RtlAnsiStringToUnicodeString( &DbgTriggerUStr, &DbgTriggerNameStr, TRUE );
            if (STATUS_SUCCESS != Staus) {
                DbgTriggerState == DBG_TRIGGER_INIT;
            }


        }
    );

    //
    //  If we find a match on the open file name the enable tracing for the
    //  next DbgTriggerIrpCount's worth of IRPs.
    //

    RxDbgTraceDoit(
        if ((DbgTriggerState == DBG_TRIGGER_LOOKING) &&
            RtlEqualUnicodeString( &DbgTriggerUStr, &FileObject->FileName, TRUE )) {

            DbgTriggerState = DBG_TRIGGER_FOUND;
            RxGlobalTraceIrpCount = DbgTriggerIrpCount;
            RxGlobalTraceSuppress = FALSE;
        }
    );

    RxDbgTrace( +1, Dbg, ("RxCommonCreate\n", 0 ));
    RxDbgTrace( 0, Dbg, ("Irp                        = %08lx\n", IrpSp ));
    RxDbgTrace( 0, Dbg, ("->IrpFlags                 = %08lx\n", IrpSp->Flags ));
    RxDbgTrace( 0, Dbg, ("->FileObject(Related)     = %08lx %08lx\n",     //  ok4->FileObj
                                 FileObject,
                                 FileObject->RelatedFileObject ));
    RxDbgTrace( 0, Dbg, (" ->FileName        = (%lx) %wZ\n",
                                 FileObject->FileName.Length,
                                 &FileObject->FileName ));
    RxDbgTrace( 0, Dbg, ("->AllocationSize(Lo/Hi)    = %08lx %08lx\n",
                                 Irp->Overlay.AllocationSize.LowPart,
                                 Irp->Overlay.AllocationSize.HighPart ));
    RxDbgTrace( 0, Dbg, ("->DesiredAccess/Options    = %08lx %08lx\n",
                                 IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                                 IrpSp->Parameters.Create.Options ));
    RxDbgTrace( 0, Dbg, ("->Attribs/ShrAccess/SPFlags= %04x %04lx %08lx\n",
                                  IrpSp->Parameters.Create.FileAttributes,
                                  IrpSp->Parameters.Create.ShareAccess,
                                  IrpSp->Flags ));

    RxLog(( "Open %lx %lx %lx %lx %lx %lx %lx\n",
            RxContext,FileObject, //1,2
            IrpSp->Parameters.Create.Options,
            IrpSp->Flags,
            IrpSp->Parameters.Create.FileAttributes,
            IrpSp->Parameters.Create.ShareAccess,
            IrpSp->Parameters.Create.SecurityContext->DesiredAccess ));

    RxWmiLog( LOG,
              RxCommonCreate_2,
              LOGPTR(RxContext)
              LOGPTR(FileObject)
              LOGULONG(IrpSp->Parameters.Create.Options)
              LOGUCHAR(IrpSp->Flags)
              LOGXSHORT(IrpSp->Parameters.Create.FileAttributes)
              LOGXSHORT(IrpSp->Parameters.Create.ShareAccess)
              LOGULONG(IrpSp->Parameters.Create.SecurityContext->DesiredAccess));

    RxLog(( " fn %wZ\n", &FileObject->FileName));
    RxWmiLog( LOG,
              RxCommonCreate_3,
              LOGUSTR(FileObject->FileName));

    if (FileObject->RelatedFileObject){

        PFCB RelatedFcb = (PFCB)(FileObject->RelatedFileObject->FsContext);
        RxDbgTrace( 0, Dbg, (" ->RelatedFileName        = %wZ\n",
                                     &(RelatedFcb->FcbTableEntry.Path) ));
        RxLog(( " relat %lx %wZ\n",
                FileObject->RelatedFileObject,
                &(RelatedFcb->FcbTableEntry.Path) ));

        RxWmiLog( LOG,
                  RxCommonCreate_4,
                  LOGPTR(FileObject->RelatedFileObject)
                  LOGUSTR(RelatedFcb->FcbTableEntry.Path));
    }

    if (FlagOn( IrpSp->Flags, SL_OPEN_TARGET_DIRECTORY )) {
        RxDbgTrace( 0, Dbg, (" ->OpenTargetDirectory\n"));
        RxLog((" OpenTargetDir!\n"));
        RxWmiLog(LOG,
                 RxCommonCreate_5,
                 LOGULONG(Status));
    }

    RxCopyCreateParameters( RxContext );

    if (FlagOn( IrpSp->Parameters.Create.Options, FILE_CREATE_TREE_CONNECTION )) {
       Status = RxCreateTreeConnect( RxContext );
    } else {

       //
       //
       //
       //  It's here because Mark says he can't avoid sending me double beginning
       //  backslashes in the Win32 layer.
       //

       if ((FileObject->FileName.Length > sizeof(WCHAR)) &&
           (FileObject->FileName.Buffer[1] == L'\\') &&
           (FileObject->FileName.Buffer[0] == L'\\')) {

            FileObject->FileName.Length -= sizeof(WCHAR);

            RtlMoveMemory( &FileObject->FileName.Buffer[0], &FileObject->FileName.Buffer[1], FileObject->FileName.Length );

            //
            //  If there are still two beginning backslashes, the name is bogus.
            //

            if ((FileObject->FileName.Length > sizeof(WCHAR)) &&
                (FileObject->FileName.Buffer[1] == L'\\') &&
                (FileObject->FileName.Buffer[0] == L'\\')) {

                RxDbgTrace(-1, Dbg, ("RxCommonCreate -> OBJECT_NAME_INVALID[slashes]\n)", 0));

                return STATUS_OBJECT_NAME_INVALID;
            }
        }


        do {

            //
            //  If the file name has a trailing \, and the request is to
            //  operate on a file (not a directory), then the file name is
            //  invalid.
            //

            if ((FileObject->FileName.Length > 0) &&
                (FileObject->FileName.Buffer[(FileObject->FileName.Length/sizeof(WCHAR))-1] == L'\\')) {

                ULONG Options = IrpSp->Parameters.Create.Options;

                if (MustBeFile( Options )) {

                    RxDbgTrace( -1, Dbg, ("RxCommonCreate -> OBJECT_NAME_INVALID[trailing+MBFile]\n)", 0));
                    Status = STATUS_OBJECT_NAME_INVALID;
                    return Status;
                }
                FileObject->FileName.Length -= sizeof(WCHAR);
                SetFlag( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH );
            }


            //
            //  If we have Write Through set in the FileObject, then set the FileObject
            //  flag as well, so that the fast write path call to FsRtlCopyWrite
            //  knows it is Write Through.
            //

            if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH )) {
                SetFlag( FileObject->Flags, FO_WRITE_THROUGH );
            }

            //
            //  Convert the name to its canonical form, i.e. without . and .. and with the luid
            //  on the front as appropriate. try to avoid a pool operation by using an stack-based buffer
            //

            Status = RxCanonicalizeNameAndObtainNetRoot( RxContext,
                                                         Irp,
                                                         &FileObject->FileName,
                                                         &RemainingName );

            if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace( 0, Dbg, ("RxCommonCreate -> Couldn't canonicalize %08lx\n", Status ));
            } else {
                RxDbgTrace( 0, Dbg, ("RxCommonCreate NetRootGoodWasGood status =%08lx\n", Status ));

                Status = RxCreateFromNetRoot( RxContext, Irp, &RemainingName );

                RxDbgTrace(0, Dbg, ("RxCommonCreate RxCreateFromNetRoot status =%08lx\n", Status));

                switch (Status) {
                case STATUS_SHARING_VIOLATION:

                    Disposition = RxContext->Create.NtCreateParameters.Disposition;

                    ASSERT( !FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_REPARSE ));

                    if (Disposition != FILE_CREATE) {
                        if (RxContext->Create.TryForScavengingOnSharingViolation &&
                            !RxContext->Create.ScavengingAlreadyTried &&
                            RxContext->Create.pVNetRoot != NULL) {

                            PV_NET_ROOT VNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;
                            NT_CREATE_PARAMETERS NtCreateParameters = RxContext->Create.NtCreateParameters;
                            NTSTATUS PurgeStatus;

                            //
                            //  Reference the VNetRoot instance. Reinitialize
                            //  the context ( this will drop the FCB if it has
                            //  been accquired. purge the FOBX's related to the
                            //  NET_ROOT instance and resume the create
                            //  operation if it was sucssesful
                            //

                            RxReferenceVNetRoot( VNetRoot );

                            //
                            //  reinitialize the context
                            //

                            RxpPrepareCreateContextForReuse( RxContext );
                            RxReinitializeContext( RxContext );

                            //
                            // Reinitialize the Create parameters.
                            //

                            RxContext->Create.NtCreateParameters = NtCreateParameters;
                            RxCopyCreateParameters( RxContext );

                            PurgeStatus = RxPurgeRelatedFobxs( VNetRoot->NetRoot,
                                                               RxContext,
                                                               DONT_ATTEMPT_FINALIZE_ON_PURGE,
                                                               NULL );

                            //
                            //  Map the SUCCESS code for continuation
                            //
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                            RxContext->Create.ScavengingAlreadyTried = TRUE;

                            //
                            //  Ensure that any buffering state change pending
                            //  requests have been processed. This will cover the
                            //  cases when owing to processing delays the oplock
                            //  response did not make it to the server and it
                            //  returned SHARING_VIOLATION.
                            //

                            {
                                PSRV_CALL SrvCall = VNetRoot->NetRoot->SrvCall;

                                RxReferenceSrvCall( SrvCall );

                                RxpProcessChangeBufferingStateRequests( SrvCall,
                                                                        FALSE ); //  do not update handler state
                            }


                            //
                            //  Drop the reference on the V_NET_ROOT instance
                            //

                            RxDereferenceVNetRoot( VNetRoot, LHS_LockNotHeld );
                        }
                    } else {
                        Status = STATUS_OBJECT_NAME_COLLISION;
                    }
                    break;

                case STATUS_REPARSE:
                    //
                    //  Ensure that the IRP is approrpiately marked for reparsing.
                    //

                    RxContext->CurrentIrp->IoStatus.Information = IO_REPARSE;
                    RxDbgTrace( 0, Dbg, ("RxCommonCreate(Reparse) IRP %lx New Name %wZ status =%08lx\n",
                                   Irp,&FileObject->FileName, Status) );
                    break;

                default:
                    ASSERT( !FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_REPARSE ));
                    break;
                }
            }
        } while (Status == STATUS_MORE_PROCESSING_REQUIRED);
    }

    if (Status == STATUS_RETRY) {
        RxpPrepareCreateContextForReuse( RxContext );
    }

    ASSERT( Status != STATUS_PENDING );

    RxDbgTraceUnIndent( -1, Dbg );

#if 0 && defined(REMOTE_BOOT)
    if ( LogAllFiles ) {
        DbgPrint( "RxCommonCreate: status %x creating %wZ %x %x\n", Status, &FileObject->FileName, FileObject, FileObject->FsContext );
    }
#endif

    return Status;
}

//
//  these next routines are essentially just copies of the same routines from io\iosubs.c
//  I cannot just use them directly because they make all sorts of assumptions about wanting to
//  update the file object
//

#define RxSetAccessVariables(xxx) {\
    ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE  | FILE_READ_DATA)) != 0);        \
    WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0);   \
    DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);                                \
}
#define RxSetShareVariables(xxx) {\
    SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);                     \
    SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);                   \
    SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);                 \
}


#if DBG
VOID
RxDumpWantedAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
   )
{
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;
    RxSetAccessVariables(SrvOpen);
    RxSetShareVariables(SrvOpen);

    PAGED_CODE();

    //(VOID)(DbgPrint
    RxDbgTrace(0, (DEBUG_TRACE_SHAREACCESS),
       ("%s%s wanted = %s%s%s:%s%s%s\n", where1,where2,
                            ReadAccess?"R":"",
                            WriteAccess?"W":"",
                            DeleteAccess?"D":"",
                            SharedRead?"SR":"",
                            SharedWrite?"SW":"",
                            SharedDelete?"SD":""
       ));
    RxLogForSharingCheck(
       ("%s%s wanted = %s%s%s:%s%s%s\n", wherelogtag,  where2,
                            ReadAccess?"R":"",
                            WriteAccess?"W":"",
                            DeleteAccess?"D":"",
                            SharedRead?"SR":"",
                            SharedWrite?"SW":"",
                            SharedDelete?"SD":""
       ));
}

VOID
RxDumpCurrentAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    )
{
    PAGED_CODE();

//    (VOID)(DbgPrint
    RxDbgTrace(0, (DEBUG_TRACE_SHAREACCESS),
       ("%s%s current = %d[%d][%d][%d]:[%d][%d][%d]\n", where1, where2,
                         ShareAccess->OpenCount,
                         ShareAccess->Readers,
                         ShareAccess->Writers,
                         ShareAccess->Deleters,
                         ShareAccess->SharedRead,
                         ShareAccess->SharedWrite,
                         ShareAccess->SharedDelete
       ));
    RxLogForSharingCheck(
       ("%s%s current = %d[%d][%d][%d]:[%d][%d][%d]\n", wherelogtag, where2,
                         ShareAccess->OpenCount,
                         ShareAccess->Readers,
                         ShareAccess->Writers,
                         ShareAccess->Deleters,
                         ShareAccess->SharedRead,
                         ShareAccess->SharedWrite,
                         ShareAccess->SharedDelete
       ));
}

NTSTATUS
RxCheckShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    NTSTATUS Status;
    PAGED_CODE();

    RxDumpWantedAccess(where,"",wherelogtag,
                       DesiredAccess,DesiredShareAccess
                       );
    RxDumpCurrentAccess(where,"",wherelogtag,ShareAccess);
    Status = IoCheckShareAccess( DesiredAccess,
                                 DesiredShareAccess,
                                 FileObject,
                                 ShareAccess,
                                 Update);

    return(Status);
}

VOID
RxRemoveShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    PAGED_CODE();

    RxDumpCurrentAccess( where, "before", wherelogtag, ShareAccess );
    IoRemoveShareAccess( FileObject, ShareAccess );
    RxDumpCurrentAccess( where, "after", wherelogtag, ShareAccess );
}

VOID
RxSetShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    PAGED_CODE();

    RxDumpCurrentAccess( where, "before", wherelogtag, ShareAccess );
    IoSetShareAccess( DesiredAccess, DesiredShareAccess, FileObject, ShareAccess);
    RxDumpCurrentAccess( where, "after",wherelogtag, ShareAccess);
}

VOID
RxUpdateShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    PAGED_CODE();

    RxDumpCurrentAccess( where, "before", wherelogtag, ShareAccess);
    IoUpdateShareAccess( FileObject, ShareAccess );
    RxDumpCurrentAccess( where, "after", wherelogtag, ShareAccess );
}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens (
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not a new accessor to
    a file actually has shared access to it.  The check is made according
    to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    This check is made against the sharing state represented by the actual SrvOpens
    on an Fcb so that we know whether we have to initiate close-behind.


Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    Fcb - Pointer to the file object of the current open request.


Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,
    STATUS_SHARING_VIOLATION is returned.

Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    ULONG ocount;
    PSHARE_ACCESS ShareAccess = &Fcb->ShareAccessPerSrvOpens;
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;

    PAGED_CODE();

    //
    //  Set the access type in the file object for the current accessor.
    //  Note that reading and writing attributes are not included in the
    //  access check.
    //

    RxSetAccessVariables( SrvOpen );

    //
    //  There is no more work to do unless the user specified one of the
    //  sharing modes above.
    //

    if (ReadAccess || WriteAccess || DeleteAccess) {

        RxSetShareVariables( SrvOpen );
        RxDumpWantedAccess("RxCheckShareAccessPerSrvOpens","","AccChkPerSO",
                            DesiredAccess,DesiredShareAccess
                           );
        RxDumpCurrentAccess("RxCheckShareAccessPerSrvOpens","","AccChkPerSO",ShareAccess);

        //
        //  Now check to see whether or not the desired accesses are compatible
        //  with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ((ReadAccess && (ShareAccess->SharedRead < ocount)) ||
            (WriteAccess && (ShareAccess->SharedWrite < ocount)) ||
            (DeleteAccess && (ShareAccess->SharedDelete < ocount)) ||
            ((ShareAccess->Readers != 0) && !SharedRead) ||
            ((ShareAccess->Writers != 0) && !SharedWrite) ||
            ((ShareAccess->Deleters != 0) && !SharedDelete)) {

            //
            //  The check failed.  Simply return to the caller indicating that the
            //  current open cannot access the file.
            //

            return STATUS_SHARING_VIOLATION;
        }
    }

    return STATUS_SUCCESS;
}

VOID
RxUpdateShareAccessPerSrvOpens (
    IN PSRV_OPEN SrvOpen
    )

/*++

Routine Description:

    This routine is invoked to update the access information about how the
    file is currently opened by introducing the contribution of this srvopen. the wrapper
    actually keeps up with two states: (a) the access state according to the files that the user
    can see, and (b) the access state according to the srvopens on the file. this rouinte manipulates
    the latter.

Arguments:


Return Value:


Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    PSHARE_ACCESS ShareAccess = &SrvOpen->Fcb->ShareAccessPerSrvOpens;
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;
    ACCESS_MASK DesiredAccess = SrvOpen->DesiredAccess;
    ULONG DesiredShareAccess = SrvOpen->ShareAccess;

    PAGED_CODE();

    if (!FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_SHAREACCESS_UPDATED )) {

        //
        //  Set the access type in the file object for the current accessor.
        //  Note that reading and writing attributes are not included in the
        //  access check.
        //

        RxSetAccessVariables( SrvOpen );

        //
        //  There is no more work to do unless the user specified one of the
        //  sharing modes above.
        //

        if (ReadAccess || WriteAccess || DeleteAccess) {

            RxSetShareVariables( SrvOpen );
            RxDumpWantedAccess( "RxUpdateShareAccessPerSrvOpens", "", "AccUpdPerSO", DesiredAccess, DesiredShareAccess );
            RxDumpCurrentAccess( "RxUpdateShareAccessPerSrvOpens", "", "AccUpdPerSO", ShareAccess );

            ShareAccess->OpenCount += 1;

            ShareAccess->Readers += ReadAccess;
            ShareAccess->Writers += WriteAccess;
            ShareAccess->Deleters += DeleteAccess;

            ShareAccess->SharedRead += SharedRead;
            ShareAccess->SharedWrite += SharedWrite;
            ShareAccess->SharedDelete += SharedDelete;
        }

        SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_SHAREACCESS_UPDATED );
    }
}

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PSHARE_ACCESS ShareAccess = &SrvOpen->Fcb->ShareAccessPerSrvOpens;
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;
    ACCESS_MASK DesiredAccess = SrvOpen->DesiredAccess;
    ULONG DesiredShareAccess = SrvOpen->ShareAccess;

    PAGED_CODE();

    //
    //  If this accessor wanted some type of access other than READ_ or
    //  WRITE_ATTRIBUTES, then account for the fact that he has closed the
    //  file.  Otherwise, he hasn't been accounted for in the first place
    //  so don't do anything.
    //

    RxSetAccessVariables( SrvOpen );

    if (ReadAccess || WriteAccess || DeleteAccess) {

        RxSetShareVariables( SrvOpen );
        RxDumpWantedAccess( "RxRemoveShareAccessPerSrvOpens", "", "AccRemPerSO", DesiredAccess, DesiredShareAccess );
        RxDumpCurrentAccess( "RxRemoveShareAccessPerSrvOpens", "", "AccRemPerSO", ShareAccess);

        //
        //  Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount -= 1;

        ShareAccess->Readers -= ReadAccess;
        ShareAccess->Writers -= WriteAccess;
        ShareAccess->Deleters -= DeleteAccess;

        ShareAccess->SharedRead -= SharedRead;
        ShareAccess->SharedWrite -= SharedWrite;
        ShareAccess->SharedDelete -= SharedDelete;
    }
}

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine gets the effective SessionId to be used for this create.

Arguments:

    SubjectSecurityContext - Supplies the information from IrpSp.

Return Value:

    None

--*/
{
    ULONG SessionId;
    PQUERY_PATH_REQUEST QpReq;
    PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    NTSTATUS Status;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxGetSessionId ... \n", 0));

    //
    //  If QUERY_PATH_REQUEST, must access from Type3InputBuffer
    //  BUGBUG: is this buffer safe to ref?
    //

    if ((IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
       (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH)) {

        QpReq = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        SubjectSecurityContext = &QpReq->SecurityContext->AccessState->SubjectSecurityContext;

    } else if((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
              (IrpSp->Parameters.Create.SecurityContext != NULL)) {

        SubjectSecurityContext = &IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext;

    } else {

        //
        //  Return 0 for cases we do not handle
        //

        return 0;
    }

    //
    //  Use SeQuerySubjetContextToken to get the proper token based on impersonation for use in
    //  querying - despite retval SeQuerySessionIdToken always returns success
    //

    Status = SeQuerySessionIdToken( SeQuerySubjectContextToken( SubjectSecurityContext ), &SessionId );
    ASSERT( Status == STATUS_SUCCESS );

    RxDbgTrace(-1, Dbg, (" ->SessionId = %08lx\n", SessionId));

    return SessionId;
}

#if 0
VOID
RxUpcaseLeadingComponents(
    IN OUT PUNICODE_STRING CanonicalName
    )
/*++

Routine Description:

    This routine is called to upcase the leading components of a name. Either 2 or 3 components are
    upcased depending on the name (i.e. whether it's a UNC name or a vnetrootname). the operation is performed
    in place!

Arguments:

    RxContext - the current workitem
    CanonicalName - the name being canonicalized

Return Value:

    none

--*/
{
    ULONG ComponentsToUpcase,wcLength,i;
    UNICODE_STRING ShortenedCanonicalName;

    PAGED_CODE();

    ComponentsToUpcase =  (*(CanonicalName->Buffer+1) == L';')?3:2;
    wcLength = CanonicalName->Length/sizeof(WCHAR);
    for (i=1;;i++) { //note: don't start at zero
        if (i>=wcLength) break;
        if (CanonicalName->Buffer[i]!=OBJ_NAME_PATH_SEPARATOR) continue;
        ComponentsToUpcase--;
        if (ComponentsToUpcase==0) break;
    }
    ShortenedCanonicalName.Buffer = CanonicalName->Buffer;
    ShortenedCanonicalName.MaximumLength = CanonicalName->MaximumLength;
    ShortenedCanonicalName.Length = (USHORT)(i*sizeof(WCHAR));
    RtlUpcaseUnicodeString(&ShortenedCanonicalName,&ShortenedCanonicalName,FALSE); //don't allocate
    RxDbgTrace(0, Dbg, ("RxUpcaseLeadingComponents -> %wZ\n", &ShortenedCanonicalName));
    return;
}
#endif //if 0


#if 0

UNICODE_STRING InterestingNames[] = {
    32, 32, L"CreateParent.txt",
};

DWORD
IsInterestingFile(
    PUNICODE_STRING pFileName
    )
{
    int i;

    for (i=0; i< sizeof(InterestingNames)/sizeof(UNICODE_STRING); ++i)
    {
        if (pFileName->Length > InterestingNames[i].Length)
        {
            UNICODE_STRING uTemp;
            uTemp.Length = uTemp.MaximumLength = InterestingNames[i].Length;
            uTemp.Buffer = pFileName->Buffer + (pFileName->Length - InterestingNames[i].Length)/sizeof(WCHAR);
            if(RtlCompareUnicodeString(&uTemp, &InterestingNames[i], TRUE)==0)
            {
//                DbgPrint("Interesting string %wZ \n", pFileName);
                return i+1;
            }
        }
    }
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\lockctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Rx called
    by the dispatch driver.

Author:

    Joe Linn     [JoeLinn]    9-Nov-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
RxLowIoLockControlShellCompletion (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLockOperationCompletionWithAcquire (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonLockControl)
#pragma alloc_text(PAGE, RxLockOperationCompletion)
#pragma alloc_text(PAGE, RxLockOperationCompletionWithAcquire)
#pragma alloc_text(PAGE, RxUnlockOperation)
#pragma alloc_text(PAGE, RxLowIoLockControlShellCompletion)
#pragma alloc_text(PAGE, RxFinalizeLockList)
#pragma alloc_text(PAGE, RxLowIoLockControlShell)
#endif


NTSTATUS
RxCommonLockControl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing Lock control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;
    
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonLockControl...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb) );
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", IrpSp->MinorFunction) );
    RxLog(( "Lock %lx %lx %lx %lx\n", RxContext, Fobx, Fcb, IrpSp->MinorFunction ));
    RxWmiLog( LOG,
              RxCommonLockControl_1,
              LOGPTR( RxContext )
              LOGPTR( Fobx )
              LOGPTR( Fcb )
              LOGUCHAR( IrpSp->MinorFunction ));

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) {

        RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> RxStatus(INVALID_PARAMETER\n)", 0));
        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Acquire shared access to the Fcb and enqueue the Irp if we didn't
    //  get access.
    //

    Status = RxAcquireSharedFcb( RxContext, Fcb );
    if (Status == STATUS_LOCK_NOT_GRANTED) {

        Status = RxFsdPostRequest( RxContext );
        RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> %08lx\n", Status));
        return Status;

    } else if (Status != STATUS_SUCCESS) {

       RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> error accquiring Fcb (%lx) %08lx\n", Fcb, Status));
       return Status;
    }

    SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD );


    try {

        //
        //  tell the buffering change guys that locks are outstanding
        //

        InterlockedIncrement( &Fcb->OutstandingLockOperationsCount );

        //
        //  setup the bit telling the unlock routine whether to pitch or save the unlocks passed down
        //  from fsrtl.
        //

        switch (IrpSp->MinorFunction) {
        case IRP_MN_LOCK:

            //
            //  find out if this lock is realizable......if not, don't proceed........
            //

            if ((Fcb->MRxDispatch != NULL) && (Fcb->MRxDispatch->MRxIsLockRealizable != NULL)) {

                Status = Fcb->MRxDispatch->MRxIsLockRealizable( (PMRX_FCB)Fcb,
                                                                &IrpSp->Parameters.LockControl.ByteOffset,
                                                                IrpSp->Parameters.LockControl.Length,
                                                                IrpSp->Flags );
            }

            if (Status != STATUS_SUCCESS) {
                try_return( Status );
            }

            if (!FlagOn( IrpSp->Flags, SL_FAIL_IMMEDIATELY )) {
                
                //
                //  we cannot handout in the lock queue with the resource held
                //

                RxReleaseFcb( RxContext, Fcb );
                ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD );
            }
            break;

        case IRP_MN_UNLOCK_SINGLE:
            break;
        
        case IRP_MN_UNLOCK_ALL:
        case IRP_MN_UNLOCK_ALL_BY_KEY:
            
            SetFlag( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SAVEUNLOCKS );
            break;
        }
        
        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request; take a reference before we go in that will be removed
        //  by the LockOperationComplete guy.
        //

        RxLog(( "Inc RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
        RxWmiLog( LOG,
                  RxCommonLockControl_2,
                  LOGPTR( RxContext )
                  LOGULONG( RxContext->ReferenceCount ));
        InterlockedIncrement( &RxContext->ReferenceCount );

        //
        //  Store the current thread id. in the lock manager context to
        //  distinguisgh between the case when the request was pended in the
        //  lock manager and the case when it was immediately satisfied.
        //

        InterlockedExchangePointer( &RxContext->LockManagerContext, PsGetCurrentThread() );

        try {
            
            Status = FsRtlProcessFileLock( &Fcb->FileLock,
                                           Irp,
                                           RxContext );
        
        } except(EXCEPTION_EXECUTE_HANDLER) {
              return RxProcessException( RxContext, GetExceptionCode() );
        }

        //
        //  see bug: 514303  
        //

        if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_OPERATION_COMPLETED )) {

            //
            //  reset the status in order to force a completion
            //

            Status = STATUS_SUCCESS;
        }

        //
        //  call the completion wrapper that reacquires the resource
        //

        if ((Status == STATUS_SUCCESS) && 
            !FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD )) {

            //
            //  if we get queued then we have to keep the refcount up to prevent early finalization
            //  from later in this routine. so take a reference here and set up to remove it
            //  if we call down to lowio
            //

            RxLog(( "Inc RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
            RxWmiLog( LOG,
                      RxCommonLockControl_3,
                      LOGPTR( RxContext )
                      LOGULONG( RxContext->ReferenceCount ) );
            
            InterlockedIncrement( &RxContext->ReferenceCount );

            SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER );

            Status = RxLockOperationCompletionWithAcquire( RxContext, Irp );
            if (Status != STATUS_PENDING) {

                //
                //  take back the reference....didn't need it. this cannot
                //  be the last one, so we just decrement
                //

                RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount ));
                RxWmiLog( LOG,
                          RxCommonLockControl_4,
                          LOGPTR( RxContext )
                          LOGULONG( RxContext->ReferenceCount ) );
                InterlockedDecrement( &RxContext->ReferenceCount);
            }
        } else if (Status == STATUS_PENDING) {
            
            InterlockedExchangePointer( &RxContext->LockManagerContext, NULL );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxCommonLockControl );

        //
        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //     3) if we posted the request
        //  We also take away a opcount since the context is about to be completed.
        //

        if (AbnormalTermination() || (Status != STATUS_PENDING)) {

            if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD )) {
                
                InterlockedDecrement( &Fcb->OutstandingLockOperationsCount );

                //
                // If we have set the resource owner to the RxContext, then we have to call
                // ReleaseForThread. 
                if( RESOURCE_OWNER_SET( LowIoContext->ResourceThreadId ) ) {
                    RxReleaseFcbForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );
                } else {
                    RxReleaseFcb( RxContext, Fcb );
                }
            }
        } else {

            //
            //  here the guy below is going to handle the completion....but, we
            //  don't know the finish order....in all likelihood the deletecontext
            //  call below just reduces the refcount but the guy may already have
            //  finished in which case this will really delete the context.
            //

            RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
            RxWmiLog( LOG,
                      RxCommonLockControl_5,
                      LOGPTR( RxContext )
                      LOGULONG( RxContext->ReferenceCount ));
            RxDereferenceAndDeleteRxContext( RxContext );
        }

        RxDbgTrace( -1, Dbg, ("RxCommonLockControl -> %08lx\n", Status) );
    } //  finally

    return Status;
}

#define RDBSS_LOCK_MANAGER_REQUEST_RESUMED (IntToPtr(0xaaaaaaaa)) // Sundown: sign-extended.


NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called after the FSRTL lock package has processed a lock
    operation. If locks are not being held, we call down to the correct minirdr
    routine. BTW, we do not actually complete the packet here. that is either
    done above (fsd or fsp) or it will be done asynchronously.

    The logic for locks is greatly complicated by locks that do not fail
    immediately but wait until they can be completed. If the request is not of
    this type then we will go into the normal lowio stuff from here.

    If the request is !failimmediately, then there are two cases depending on
    whether or not the lock was enqueued. In both cases, we have to reacquire
    the resource before we can proceed. In the case where the lock was NOT
    enqueued, we back up into CommonLock where there is code to call back into
    this routine with the resource held. Then things proceed as normal.

    However, if we did wait in the lock queue then we will have to post to a
    worker thread to get our work. Here, PENDING is returned to CommonLock so he
    removes one refcount leaving only one for this routine. However, the normal
    entrystate for this routine is 2 refcounts....one that is taken away here
    and one that belongs to whoever completes the request. So, we take an extra
    one before we post.  Posting leaves us still with two cases: locks-buffered
    vs locks-not-buffered. In the locks-buffered case, we come back in here with
    2 refcounts; we take awayone here and the fspdispatch takes away the other
    when it completes. Finally, if locks are not buffered then we go to the
    wire: since it is async, pending could be returned. no-pending is just as
    before. With pending, lowio takes an extra reference that belongs to the
    completion routine and that leaves one reference to take away on this path.
    Unlike commonlock, fspdispatch does not have the clause that takes away a
    reference on pending-returned. SOOOOOO, we take one away here if lowio
    returns pending AND we were enqueued. got that???

    A minirdr should not go for an indefinite stay at the wire with the resource
    held; if necessary, it should drop the resource and reacquire it.

Arguments:

    IN PVOID Context - Provides the context supplied to FsRtlProcessFileLock.
                       In this case, it is the original RxContext.

    IN PIRP Irp - Supplies an IRP describing the lock operation.

Return Value:

    RXSTATUS - Final status of operation..

--*/
{
    PRX_CONTEXT RxContext = Context;
    NTSTATUS Status = Irp->IoStatus.Status;
    PVOID LockManagerContext;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFCB Fcb = (PFCB)RxContext->pFcb;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxLockOperationCompletion -> RxContext = %08lx, 1stStatus= %08lx\n", RxContext, Status) );
    RxLog(( "LockCompEntry %lx %lx\n", RxContext, Status ));
    RxWmiLog( LOG,
              RxLockOperationCompletion_1,
              LOGPTR( RxContext )
              LOGULONG( Status ) );

    ASSERT( Context );
    ASSERT( Irp == RxContext->CurrentIrp );

    //
    //  The LockManagerContext field in the RxContext supplied to the lock
    //  manager routine is initialized to the thread id. of the thread submitting
    //  the request and set to RDBSS_LOCK_MANAGER_REQUEST_PENDING on return if
    //  STATUS_PENDING is returned. Thus if this routine is called with the
    //  value in this field is not equal to either the current thread id. or
    //  RDBSS_LOCK_MANAGER_REQUEST_RESUMED, we are guaranteed that this request
    //  was pended in the the lock manager.
    //

    LockManagerContext = InterlockedExchangePointer( &RxContext->LockManagerContext, RDBSS_LOCK_MANAGER_REQUEST_RESUMED );

    if ((LockManagerContext != PsGetCurrentThread()) &&
        (LockManagerContext != RDBSS_LOCK_MANAGER_REQUEST_RESUMED)) {

        //
        //  here we were hung out in the lock queue........turn the operation to
        //  async and post to get the resource back. read the notes above to see
        //  why we inc the refcount
        //

        RxLog(( "Inc RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
        RxWmiLog( LOG,
                  RxLockOperationCompletion_3,
                  LOGPTR( RxContext )
                  LOGULONG( RxContext->ReferenceCount ));

        InterlockedIncrement( &RxContext->ReferenceCount );

        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER );

        RxDbgTrace( -1, Dbg, ("Posting Queued LockReq = %08lx\n", RxContext) );

        if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD )) {
            
            RxReleaseFcb( RxContext, Fcb );
            ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD );
        }

        Status = RxFsdPostRequestWithResume( RxContext, RxLockOperationCompletionWithAcquire );
        return Status;
    }

    //  
    //  if we dropped the resource before we came in, then we reacquire it now.
    //  the guy above me must be the commonlock routine and he come back down
    //  thru the reacquire wrapper...sort of a post without posting
    //

    if (!FlagOn( RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD )) {
    
        //
        //  see bug: 514303
	    //  force completion regardless of return status. fsrtlprocessfilelock can return status_pending
        //  and we will loss this completion, so mark it
        //

        SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_OPERATION_COMPLETED );

        Status = STATUS_SUCCESS;
        RxLog(( "ResDropUp! %lx %lx\n", RxContext, Fcb->FcbState ));
        RxWmiLog( LOG,
                  RxLockOperationCompletion_4,
                  LOGPTR( RxContext )
                  LOGULONG( Fcb->FcbState ) );
        RxDbgTrace( -1, Dbg, ("RxLockOperationCompletion Resdropup-> Status = %08lx\n", Status) );
        return Status;
    }

    //
    //  this is the normal case. remove the extra reference. this cannot
    //  be the last one, so we just decrement
    //

    RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
    RxWmiLog( LOG,
              RxLockOperationCompletion_5,
              LOGPTR( RxContext )
              LOGULONG( RxContext->ReferenceCount ) );
    
    InterlockedDecrement( &RxContext->ReferenceCount );

    //
    //  if we have nonsuccess, just get out!
    //

    if (!NT_SUCCESS( Status )) {
        
        RxLog(( "NONSUCCESS %lx %lx\n", RxContext, Status ));
        RxWmiLog( LOG,
                  RxLockOperationCompletion_6,
                  LOGPTR( RxContext )
                  LOGULONG( Status ) );
        RxDbgTrace( -1, Dbg, ("RxLockOperationCompletion NONSUCCESS-> Rxc,Status =%08lx %08lx\n", RxContext, Status ));
        return Status;
    }

    //
    //  if locks are buffered, just get out
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_LOCK_BUFFERING_ENABLED )) {
        
        Status = STATUS_SUCCESS;
        RxLog(("LocksBuffered! %lx %lx %lx\n", RxContext, Fcb->FcbState, RxContext->ReferenceCount ));
        RxWmiLog( LOG,
                  RxLockOperationCompletion_7,
                  LOGPTR( RxContext )
                  LOGULONG( Fcb->FcbState )
                  LOGULONG( RxContext->ReferenceCount ));
        RxDbgTrace( -1, Dbg, ("RxLockOperationCompletion LockOpBuffered-> Status = %08lx\n", Status) );
        return Status;
    }

    //
    //  otherwise, let's go to the mini
    //

    RxInitializeLowIoContext( RxContext, LOWIO_OP_UNLOCK, LowIoContext );
    LowIoContext->ParamsFor.Locks.ByteOffset = IrpSp->Parameters.LockControl.ByteOffset.QuadPart;
    LowIoContext->ParamsFor.Locks.Key = IrpSp->Parameters.LockControl.Key;
    LowIoContext->ParamsFor.Locks.Flags = 0;     //  no flags

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_LOCK:

        if (FlagOn( IrpSp->Flags, SL_EXCLUSIVE_LOCK )) {
            LowIoContext->Operation = LOWIO_OP_EXCLUSIVELOCK;
        } else {
            LowIoContext->Operation = LOWIO_OP_SHAREDLOCK;
        }
        LowIoContext->ParamsFor.Locks.Flags = IrpSp->Flags;
        LowIoContext->ParamsFor.Locks.Length = (*IrpSp->Parameters.LockControl.Length).QuadPart;
        break;

    case IRP_MN_UNLOCK_SINGLE:
        
        LowIoContext->ParamsFor.Locks.Length = (*IrpSp->Parameters.LockControl.Length).QuadPart;
        break;

    case IRP_MN_UNLOCK_ALL:
    case IRP_MN_UNLOCK_ALL_BY_KEY:
        
        LowIoContext->ParamsFor.Locks.Length = 0;
        if (LowIoContext->ParamsFor.Locks.LockList == NULL) {
            
            RxDbgTrace( -1, Dbg, ("RxLockOperationCompletion -> Nothing to unlock\n") );
            return STATUS_SUCCESS;
        }
        LowIoContext->Operation = LOWIO_OP_UNLOCK_MULTIPLE;
        break;
    }

    RxDbgTrace( 0, Dbg, ("--->Operation = %08lx\n", LowIoContext->Operation) );

    Status = RxLowIoLockControlShell( RxContext, Irp, Fcb );

    if ((Status == STATUS_PENDING) && 
        FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER )) {

        //
        //  the fsp dispatch routine doesn't have a clause to take away a
        //  reference on pended operations. so, if we were queued AND we are
        //  returning pending back thru the fsp, then take away a reference here.
        //

        RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount ));
        RxWmiLog( LOG,
                  RxLockOperationCompletion_8,
                  LOGPTR( RxContext )
                  LOGULONG( RxContext->ReferenceCount ) );
        RxDereferenceAndDeleteRxContext( RxContext );
    }

    RxDbgTrace( -1, Dbg, ("RxLockOperationCompletion -> Status = %08lx\n", Status) );
    return Status;

}

NTSTATUS
RxLockOperationCompletionWithAcquire ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is responsible to get the resource back in case we were held up
    in the lock queue. Then it calls the LockOperationComplete. Of course, it has
    to mess around with giving the resource back for abnormal termination and the
    like.

    Two things are invariant ... first, when we get here there are two references
    on the rxcontext. also, unless we return pending, the fsp guy above will try
    to complete this request. here's what we do.

    this routine is refcount-neutral: it always takes away as many as it places.
    it has to place refcount on the context if it acquires the resource in order
    to maintain the invariant that a context always!!!!! has the same number of
    releases as acquires. if it takes this refcount, then it releases it
    EVEN IF THE FCB IS NOT RELEASED HERE. (it might be relased on the async
    path instead.)

    Last, we can also be called from the original commonlock routine. in this
    case, we take care of releasing the fcb and clear the flag so that it will
    not be released above.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFCB Fcb = (PFCB)RxContext->pFcb;
    PFOBX Fobx = (PFOBX)RxContext->pFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    BOOLEAN ReleaseFcb = FALSE;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxLockOperationCompletionWithAcquire...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb ));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", IrpSp->MinorFunction) );
    RxLog(( "LockAcq %lx %lx %lx %lx\n", RxContext, Fobx, Fcb, IrpSp->MinorFunction ));
    RxWmiLog( LOG,
              RxLockOperationCompletionWithAcquire_1,
              LOGPTR( RxContext )
              LOGPTR( Fobx )
              LOGPTR( Fcb )
              LOGUCHAR( IrpSp->MinorFunction ) );

    //
    //  Acquire shared access to the Fcb
    //

    Status = RxAcquireSharedFcb( RxContext, Fcb );
    if (Status == STATUS_LOCK_NOT_GRANTED) {
        Status = RxFsdPostRequestWithResume( RxContext, RxLockOperationCompletionWithAcquire );
        RxDbgTrace( -1, Dbg, ("RxLockOperationCompletionWithAcquire -> %08lx\n", Status) );
        return Status;
    } else if (Status != STATUS_SUCCESS) {
        RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount ));
        InterlockedDecrement( &RxContext->ReferenceCount);
        return Status;
    }

    SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD );

    RxLog(( "Inc RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
    RxWmiLog( LOG,
              RxLockOperationCompletionWithAcquire_2,
              LOGPTR( RxContext )
              LOGULONG( RxContext->ReferenceCount ) );
    InterlockedIncrement( &RxContext->ReferenceCount ); //  we MUST!!! deref

    try {

        //
        //  Call the guy to complete the lock request....with the resrouce held
        //

        Status = RxLockOperationCompletion( RxContext, Irp );

    } finally {

        DebugUnwind( RxLockOperationCompletionWithAcquire );

        //
        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the
        //        resource since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //  We also take away a opcount since the context is about to be completed.
        //

        if (AbnormalTermination() || (Status != STATUS_PENDING)) {

            ReleaseFcb = TRUE;

        } else {

            //
            //  here the guy below is going to handle the completion
            //

            ASSERT( FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION ) );
        }

        if (ReleaseFcb) {

            InterlockedDecrement( &Fcb->OutstandingLockOperationsCount );
            
            if(RESOURCE_OWNER_SET(LowIoContext->ResourceThreadId ) ) {
                RxReleaseFcbForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );
            } else {
                RxReleaseFcb( RxContext, Fcb );
            }

            ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD );
        }

        //
        //  if we took a refcount we MUST deref no matter what!
        //

        RxLog(( "Dec RxC %lx L %ld %lx\n", RxContext, __LINE__, RxContext->ReferenceCount ));
        RxWmiLog( LOG,
                  RxLockOperationCompletionWithAcquire_3,
                  LOGPTR( RxContext )
                  LOGULONG( RxContext->ReferenceCount ) );
        RxDereferenceAndDeleteRxContext( RxContext );

        RxDbgTrace( -1, Dbg, ("RxLockOperationCompletionWithAcquire -> %08lx\n", Status) );

    } //  finally

    return Status;
}


VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    )

/*++

Routine Description:

    This routine is called after the FSRTL lock package has determined that a
    locked region is to be unlocked. We do one of two things as determined by a
    bit in the lowio_flags field. If the bit is clear, we just ignore the call.
    This happens on unlock single calls that are passed down to the minirdr
    exactly as a single lock. For a unlock_all or unlock_all_by_key, we use
    these calls to get an enumeration of the lock set. then, these go thru lowIO
    but using the list method.


Arguments:

    IN PVOID Context - Provides the context supplied to FsRtlProcessFileLock.
                       In this case, it is the RxContext of the Ongoing unlock
                       operation OR of a cleanup operation

    IN PFILE_LOCK_INFO LockInfo - Describes the region being unlock

Return Value:

    RXSTATUS - Status of unlock operation (it can't really fail, though).

--*/

{
    PRX_CONTEXT RxContext = Context;
    PFCB Fcb;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();


    RxDbgTrace( +1, Dbg, ("RxUnlockOperation -> RxContext/LowByte = %08lx/%08lx\n",
                RxContext,LockInfo->StartingByte.LowPart) );
    RxLog(( "Unlck %x %x",RxContext,LockInfo->StartingByte.LowPart ));
    RxWmiLog(LOG,
             RxUnlockOperation,
             LOGPTR( RxContext )
             LOGULONG( LockInfo->StartingByte.LowPart ) );

    //
    //  If there is a NULL context, this means that this routine was called
    //  on behalf of a failed lock request, so we return immediately.
    //

    if (Context != NULL) {

        PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
        PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation( RxContext->CurrentIrp)->FileObject;

        Fcb = (PFCB) RxContext->pFcb;

        ASSERT( FileObject == LockInfo->FileObject );  //  ok4->FileObj

        if (FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SAVEUNLOCKS ) && 
            !FlagOn( Fcb->FcbState, FCB_STATE_LOCK_BUFFERING_ENABLED )) {
            
            PLOWIO_LOCK_LIST LockList,ThisElement;
            
            LockList = LowIoContext->ParamsFor.Locks.LockList;

            ThisElement = RxAllocatePoolWithTag( PagedPool, sizeof( LOWIO_LOCK_LIST ), 'LLxR' );

            if (ThisElement==NULL) {
                
                RxDbgTrace( -1, Dbg, ("RxUnlockOperation FAILED ALLOCATION!\n") );
                return;
            }

            if (LockList == NULL) {
                ThisElement->LockNumber = 1;
            } else {
                ThisElement->LockNumber = LockList->LockNumber + 1;
            }
            ThisElement->Next = LockList;
            ThisElement->ByteOffset = LockInfo->StartingByte.QuadPart;
            ThisElement->Length = LockInfo->Length.QuadPart;
            LowIoContext->ParamsFor.Locks.LockList = ThisElement;
        }
    }

    RxDbgTrace(-1, Dbg, ("RxUnlockOperation -> status=%08lx\n", Status));
    return;
}


//
//  Internal support routine
//


NTSTATUS
RxLowIoLockControlShellCompletion (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine postprocesses a read request after it comes back from the
    minirdr.  It does callouts to handle compression, buffering and
    shadowing.  It is the opposite number of LowIoLockControlShell.

    This will be called from LowIo; for async, originally in the
    completion routine.  If RxStatus(MORE_PROCESSING_REQUIRED) is returned,
    LowIo will call again in a thread.  If this was syncIo, you'll be back
    in the user's thread; if async, lowIo will requeue to a thread.
    Currrently, we always get to a thread before anything; this is a bit slower
    than completing at DPC time,
    but it's aheckuva lot safer and we may often have stuff to do
    (like decompressing, shadowing, etc) that we don't want to do at DPC
    time.

Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/

{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PIRP Irp = RxContext->CurrentIrp;
    PFCB Fcb = (PFCB) RxContext->pFcb;
    BOOLEAN SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    
    RxDbgTrace( +1, Dbg, ("RxLowIoLockControlShellCompletion  entry  Status = %08lx\n", Status) );
    RxLog(( "LkShlComp" ));
    RxWmiLog( LOG,
              RxLowIoLockControlShellCompletion_1,
              LOGPTR( RxContext ) );

    switch (Status) {
    
    case STATUS_SUCCESS:
        break;
    case STATUS_FILE_LOCK_CONFLICT:
        break;
    case STATUS_CONNECTION_INVALID:

        //
        //  NOT YET IMPLEMENTED here is where the failover will happen
        //  first we give the local guy current minirdr another chance...then we go
        //  to fullscale retry
        //  return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
        //

        break;
    }

    //
    //  for a unlock_multiple, get rid of the lock_list
    //

    if (LowIoContext->Operation == LOWIO_OP_UNLOCK_MULTIPLE) {
        RxFinalizeLockList( RxContext );
    }

    if (FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SYNCCALL )){

        //
        //  if we're being called from lowioubmit then just get out
        //

        RxDbgTrace( -1, Dbg, ("RxLowIoLockControlShellCompletion  syncexit  Status = %08lx\n", Status) );
        return Status;
    }

    //
    //  so we're doing an asynchronous completion. well, the only reason why we would be
    //  trying a lock at the server would be if the lock manager already completed it
    //  successfully! but if it didn't complete successfully at the server then we have
    //  to remove it.
    //

    if ((Status != STATUS_SUCCESS) && 
        (RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL) && 
        (RxContext->MinorFunction == IRP_MN_LOCK)) {

        PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;  
        NTSTATUS LocalStatus;

        LocalStatus = FsRtlFastUnlockSingle( &Fcb->FileLock,
                                             FileObject,
                                             (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset,
                                             (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length,
                                             IoGetRequestorProcess( Irp ),
                                             LowIoContext->ParamsFor.Locks.Key,
                                             NULL,
                                             TRUE );
         
        RxLog(( "RetractLck %lx %lx %lx",RxContext,Status,LocalStatus ));
        RxWmiLog( LOG,
                  RxLowIoLockControlShellCompletion_2,
                  LOGPTR( RxContext )
                  LOGULONG( Status )
                  LOGULONG( LocalStatus ) );
    }

    //
    //  otherwise we have to do the end of the lock from here
    //

    InterlockedDecrement( &Fcb->OutstandingLockOperationsCount );
    RxReleaseFcbForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );

    ASSERT( Status != STATUS_RETRY );

    if (Status != STATUS_RETRY) {
        ASSERT( RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL );
    }

    RxDbgTrace( -1, Dbg, ("RxLowIoLockControlShellCompletion  exit  Status = %08lx\n", Status) );
    return Status;
}

VOID
RxFinalizeLockList (
    PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine runs down a lock lis and frees each member

Arguments:

    RxContext - the usual

Return Value:

    n/a

--*/

{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PLOWIO_LOCK_LIST LockList = LowIoContext->ParamsFor.Locks.LockList;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxFinalizeLockList  entry   rxcontext=%08lx\n", RxContext) );
    RxWmiLog( LOG,
              RxFinalizeLockList,
              LOGPTR( RxContext ) );

    for(;;){
        PLOWIO_LOCK_LIST NextLockList;
        
        if (LockList == NULL) break;
        NextLockList = LockList->Next;
        RxFreePool( LockList );
        LockList = NextLockList;
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeLockList  exit  \n"));
    return;
}


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine preprocesses a read request before it goes down to the minirdr.
    It does callouts to handle compression, buffering and shadowing. It is the
    opposite number of LowIoLockControlShellCompletion. By the time we get here,
    we are going to the wire. Lock buffering is handled in the
    lockcompletionroutine (not lowio)

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxLowIoLockControlShell  entry             %08lx\n", 0) );
    RxLog(( "%s\n", "skL" ));
    RxWmiLog( LOG,
              RxLowIoLockControlShell,
              LOGPTR( RxContext ) );

    //
    // If we are in FSP, we are not guaranteed the thread will stay around till the
    // operation is completed. So we set the resource owner to the RX_CONTEXT
    // so that the resource package does not touch it.
    //
    if( BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION ) && 
        BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP )) {
        
        LowIoContext->ResourceThreadId = MAKE_RESOURCE_OWNER(RxContext);
        ExSetResourceOwnerPointer(Fcb->Header.Resource, (PVOID)LowIoContext->ResourceThreadId);
    }


    Status = RxLowIoSubmit( RxContext, Irp, Fcb, RxLowIoLockControlShellCompletion );


    RxDbgTrace(-1, Dbg, ("RxLowIoLockControlShell  exit  Status = %08lx\n", Status));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Rdbss.
    Fsctls on the device fcb are handled in another module.

Author:

   Joe Linn [JoeLinn] 7-mar-95

Revision History:

   Balan Sethu Raman 18-May-95 -- Integrated with mini rdrs

--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>
#include "fsctlbuf.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)

//
//  Local procedure prototypes
//

NTSTATUS
RxUserFsCtrl ( 
    IN PRX_CONTEXT RxContext 
    );

NTSTATUS
TranslateSisFsctlName (
    IN PWCHAR InputName,
    OUT PUNICODE_STRING RelativeName,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PUNICODE_STRING NetRootName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonFileSystemControl)
#pragma alloc_text(PAGE, RxUserFsCtrl)
#pragma alloc_text(PAGE, RxLowIoFsCtlShell)
#pragma alloc_text(PAGE, RxLowIoFsCtlShellCompletion)
#pragma alloc_text(PAGE, TranslateSisFsctlName)
#endif

//
//  Global to enable throttling namedpipe peeks 
//  

ULONG RxEnablePeekBackoff = 1;

NTSTATUS
RxCommonFileSystemControl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads. What happens is that we pick off fsctls that
    we know about and remote the rest....remoting means sending them thru the
    lowio stuff which may/will pick off a few more. the ones that we pick off here
    (and currently return STATUS_NOT_IMPLEMENTED) and the ones for being an oplock
    provider and for doing volume mounts....we don't even have volume fcbs
    yet since this is primarily a localFS concept.
    nevertheless, these are not passed thru to the mini.

Arguments:


Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFCB Fcb;
    PFOBX Fobx;

    NTSTATUS Status;
    NODE_TYPE_CODE TypeOfOpen;
    BOOLEAN TryLowIo = TRUE;
    ULONG FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonFileSystemControl %08lx\n", RxContext) );
    RxDbgTrace( 0, Dbg, ("Irp           = %08lx\n", Irp) );
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", IrpSp->MinorFunction) );
    RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode) );

    RxLog(( "FsCtl %x %x %x %x", RxContext, Irp, IrpSp->MinorFunction, FsControlCode ));
    RxWmiLog( LOG,
              RxCommonFileSystemControl,
              LOGPTR( RxContext )
              LOGPTR( Irp )
              LOGUCHAR( IrpSp->MinorFunction )
              LOGULONG( FsControlCode ) );

    ASSERT( IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

    //
    //  Validate the buffers passed in for the FSCTL
    //

    if ((Irp->RequestorMode == UserMode) &&
        (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP ))) {
        
        try {
            switch (FsControlCode & 3) {
            case METHOD_NEITHER:
                {
                    PVOID InputBuffer,OutputBuffer;
                    ULONG InputBufferLength,OutputBufferLength;

                    Status = STATUS_SUCCESS;

                    InputBuffer  = METHODNEITHER_OriginalInputBuffer( IrpSp );
                    OutputBuffer = METHODNEITHER_OriginalOutputBuffer( Irp );

                    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
                    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

                    if (InputBuffer != NULL) {
                        
                        ProbeForRead( InputBuffer,
                                      InputBufferLength,
                                      1 );

                        ProbeForWrite( InputBuffer,
                                       InputBufferLength, 
                                       1 );
                    
                    } else if (InputBufferLength != 0) {
                        Status = STATUS_INVALID_USER_BUFFER;
                    }

                    if (Status == STATUS_SUCCESS) {
                        
                        if (OutputBuffer != NULL) {
                            
                            ProbeForRead( OutputBuffer,
                                          OutputBufferLength,
                                          1 );

                            ProbeForWrite( OutputBuffer,
                                           OutputBufferLength,
                                           1 );
                        
                        } else if (OutputBufferLength != 0) {
                            Status = STATUS_INVALID_USER_BUFFER;
                        }
                    }
                }
                break;

            case METHOD_BUFFERED:
            case METHOD_IN_DIRECT:
            case METHOD_OUT_DIRECT:
                
                Status = STATUS_SUCCESS;
                break;
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = STATUS_INVALID_USER_BUFFER;
        }

        if (Status != STATUS_SUCCESS) {
            return Status;
        }
    }

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_USER_FS_REQUEST:
    case IRP_MN_TRACK_LINK:

        RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode) );
        
        switch (FsControlCode) {
        
        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
        case FSCTL_REQUEST_BATCH_OPLOCK:
        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
        case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
        case FSCTL_OPLOCK_BREAK_NOTIFY:
        case FSCTL_OPLOCK_BREAK_ACK_NO_2:
            
            //
            //  Oplocks are not implemented for remote file systems
            //

            Status = STATUS_NOT_IMPLEMENTED;
            TryLowIo = FALSE;
            break;

        case FSCTL_LOCK_VOLUME:
        case FSCTL_UNLOCK_VOLUME:
        case FSCTL_DISMOUNT_VOLUME:
        case FSCTL_MARK_VOLUME_DIRTY:
        case FSCTL_IS_VOLUME_MOUNTED:
                
            //
            //  Decode the file object, the only type of opens we accept are
            //  user volume opens (which are not implemented currently).
            //

            TypeOfOpen = NodeType( Fcb );

            if (TypeOfOpen != RDBSS_NTC_VOLUME_FCB) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Status = STATUS_NOT_IMPLEMENTED;
            }
            TryLowIo = FALSE;
            break;

        case FSCTL_DFS_GET_REFERRALS:
        case FSCTL_DFS_REPORT_INCONSISTENCY:
            
            if (!FlagOn( Fcb->NetRoot->SrvCall->Flags, SRVCALL_FLAG_DFS_AWARE_SERVER )) {
                TryLowIo = FALSE;
                Status = STATUS_DFS_UNAVAILABLE;
            }
            break;

        case FSCTL_LMR_GET_LINK_TRACKING_INFORMATION:
            {
                //
                //  Validate the parameters and reject illformed requests
                //
                
                ULONG OutputBufferLength;
                PLINK_TRACKING_INFORMATION LinkTrackingInformation;

                OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
                LinkTrackingInformation = Irp->AssociatedIrp.SystemBuffer;

                TryLowIo = FALSE;

                if ((OutputBufferLength < sizeof(LINK_TRACKING_INFORMATION)) ||
                    (LinkTrackingInformation == NULL) ||
                    (Fcb->NetRoot->Type != NET_ROOT_DISK)) {
                    
                    Status = STATUS_INVALID_PARAMETER;
                
                } else {
                    
                    BYTE Buffer[sizeof(FILE_FS_OBJECTID_INFORMATION)];
                    PFILE_FS_OBJECTID_INFORMATION ObjectIdInfo;

                    ObjectIdInfo = (PFILE_FS_OBJECTID_INFORMATION)Buffer;
                    
                    RxContext->Info.FsInformationClass = FileFsObjectIdInformation;
                    RxContext->Info.Buffer = ObjectIdInfo;
                    RxContext->Info.LengthRemaining = sizeof( Buffer );

                    MINIRDR_CALL( Status,
                                  RxContext,
                                  Fcb->MRxDispatch,
                                  MRxQueryVolumeInfo, 
                                  (RxContext) );

                    if ((Status == STATUS_SUCCESS) ||
                        (Status == STATUS_BUFFER_OVERFLOW)) {

                        //
                        //  Copy the volume Id onto the net root.
                        //

                        RtlCopyMemory( &Fcb->NetRoot->DiskParameters.VolumeId,
                                       ObjectIdInfo->ObjectId,
                                       sizeof( GUID ) );

                        RtlCopyMemory( LinkTrackingInformation->VolumeId,
                                       &Fcb->NetRoot->DiskParameters.VolumeId,
                                       sizeof( GUID ) );

                        if (FlagOn( Fcb->NetRoot->Flags, NETROOT_FLAG_DFS_AWARE_NETROOT )) {
                            LinkTrackingInformation->Type = DfsLinkTrackingInformation;
                        } else {
                            LinkTrackingInformation->Type = NtfsLinkTrackingInformation;
                        }

                        Irp->IoStatus.Information = sizeof( LINK_TRACKING_INFORMATION );
                        Status = STATUS_SUCCESS;
                    }
                }

                Irp->IoStatus.Status = Status;
            }
            break;

        case FSCTL_SET_ZERO_DATA:
            {
                PFILE_ZERO_DATA_INFORMATION ZeroRange;

                Status = STATUS_SUCCESS;

                //
                //  Verify if the request is well formed...
                //  a. check if the input buffer length is OK
                //

                if (IrpSp->Parameters.FileSystemControl.InputBufferLength <
                    sizeof( FILE_ZERO_DATA_INFORMATION )) {

                    Status = STATUS_INVALID_PARAMETER;
                
                } else {
                    
                    //
                    //  b. Ensure the ZeroRange request is properly formed.
                    //

                    ZeroRange = (PFILE_ZERO_DATA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

                    if ((ZeroRange->FileOffset.QuadPart < 0) ||
                        (ZeroRange->BeyondFinalZero.QuadPart < 0) ||
                        (ZeroRange->FileOffset.QuadPart > ZeroRange->BeyondFinalZero.QuadPart)) {

                        Status = STATUS_INVALID_PARAMETER;
                    }
                }

                if (Status == STATUS_SUCCESS) {

                    //
                    //  Before the request can be processed ensure that there
                    //  are no user mapped sections
                    //

                    if (!MmCanFileBeTruncated( &Fcb->NonPaged->SectionObjectPointers, NULL )) {

                        Status = STATUS_USER_MAPPED_FILE;
                    }
                }

                TryLowIo = (Status == STATUS_SUCCESS);
            }
            break;

        case FSCTL_SET_COMPRESSION:
        case FSCTL_SET_SPARSE:
            
            //
            //  Ensure that the close is not delayed is for these FCB's
            //

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );

            ASSERT( RxContext != CHANGE_BUFFERING_STATE_CONTEXT );
            
            if ((Status == STATUS_LOCK_NOT_GRANTED) &&
                (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT ))) {

                RxDbgTrace(0, Dbg, ("Cannot acquire Fcb\n", 0));
            
                RxContext->PostRequest = TRUE;
            }
            
            if (Status != STATUS_SUCCESS) {
                TryLowIo = FALSE;
            } else {
                
                ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );
            
                if (FsControlCode == FSCTL_SET_SPARSE) {
                    
                    if (NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_FILE) {
            
                        SetFlag( Fcb->Attributes, FILE_ATTRIBUTE_SPARSE_FILE );
                        Fobx->pSrvOpen->BufferingFlags = 0;
            
                        //
                        //  disable local buffering
                        //
            
                        SetFlag( Fcb->FcbState, FCB_STATE_DISABLE_LOCAL_BUFFERING );
            
                        RxChangeBufferingState( (PSRV_OPEN)Fobx->pSrvOpen,
                                                NULL,
                                                FALSE );
                    } else {
                        Status = STATUS_NOT_SUPPORTED;
                    }
                }

                RxReleaseFcb( RxContext, Fcb );
            }
            break;

        case IOCTL_LMR_DISABLE_LOCAL_BUFFERING:
    
            if (NodeType(Fcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {

                //
                //  Ensure that the close is not delayed is for these FCB's
                //

                Status = RxAcquireExclusiveFcb( RxContext, Fcb );

                if ((Status == STATUS_LOCK_NOT_GRANTED) &&
                    (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT ))) {

                    RxDbgTrace(0, Dbg, ("Cannot acquire Fcb\n", 0));

                    RxContext->PostRequest = TRUE;
                }

                if (Status == STATUS_SUCCESS) {

                    //
                    //  disable local buffering
                    //
                    
                    SetFlag( Fcb->FcbState, FCB_STATE_DISABLE_LOCAL_BUFFERING );

                    RxChangeBufferingState( Fobx->SrvOpen,
                                            NULL,
                                            FALSE );

                    RxReleaseFcb( RxContext, Fcb ); 
                }
            } else {
                Status = STATUS_NOT_SUPPORTED;
            }

            //
            //  we are done
            //
            
            TryLowIo = FALSE;
            break;

        case FSCTL_SIS_COPYFILE:
            {
                //
                //  This is the single-instance store copy FSCTL. The input
                //  paths are fully qualified NT paths and must be made
                //  relative to the share (which must be the same for both
                //  names).
                //

                PSI_COPYFILE copyFile = Irp->AssociatedIrp.SystemBuffer;
                ULONG bufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
                PWCHAR source;
                PWCHAR dest;
                UNICODE_STRING sourceString;
                UNICODE_STRING destString;

                memset( &sourceString, 0, sizeof( sourceString ) );
                memset( &destString, 0, sizeof( destString ) );
                
                //
                //  Validate the buffer passed in
                //

                if ((copyFile == NULL) ||
                    (bufferLength < sizeof( SI_COPYFILE ))) {
                    Status = STATUS_INVALID_PARAMETER;
                    TryLowIo = FALSE;
                    break;
                }

                //
                //  Get pointers to the two names.
                //

                source = copyFile->FileNameBuffer;
                dest = source + (copyFile->SourceFileNameLength / sizeof( WCHAR ));

                //
                //  Verify that the inputs are reasonable.
                //

                if ( (copyFile->SourceFileNameLength > bufferLength) ||
                     (copyFile->DestinationFileNameLength > bufferLength) ||
                     (copyFile->SourceFileNameLength < (2 * sizeof(WCHAR))) ||
                     (copyFile->DestinationFileNameLength < (2 * sizeof(WCHAR))) ||
                     ((FIELD_OFFSET( SI_COPYFILE, FileNameBuffer ) +
                       copyFile->SourceFileNameLength +
                       copyFile->DestinationFileNameLength) > bufferLength) ||
                     (*(source + (copyFile->SourceFileNameLength/sizeof( WCHAR )-1)) != 0) ||
                     (*(dest + (copyFile->DestinationFileNameLength/sizeof( WCHAR )-1)) != 0) ) {

                    Status = STATUS_INVALID_PARAMETER;
                    TryLowIo = FALSE;
                    break;

                }

                //
                //  Perform symbolic link translation on the source and destination names,
                //  and ensure that they translate to redirector names.
                //

                Status = TranslateSisFsctlName( source,
                                                &sourceString,
                                                Fcb->RxDeviceObject,
                                                &Fcb->NetRoot->PrefixEntry.Prefix );
                if ( !NT_SUCCESS(Status) ) {
                    TryLowIo = FALSE;
                    break;
                }

                Status = TranslateSisFsctlName( dest,
                                                &destString,
                                                Fcb->RxDeviceObject,
                                                &Fcb->NetRoot->PrefixEntry.Prefix );
                
                if (!NT_SUCCESS( Status )) {
                    
                    RtlFreeUnicodeString( &sourceString );
                    TryLowIo = FALSE;
                    break;
                }

                //
                //  Convert the paths in the input buffer into share-relative
                //  paths.
                //

                if ( (ULONG)(sourceString.MaximumLength + destString.MaximumLength) >
                     (copyFile->SourceFileNameLength + copyFile->DestinationFileNameLength) ) {
                    PSI_COPYFILE newCopyFile;
                    ULONG length = FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) +
                                        sourceString.MaximumLength + destString.MaximumLength;
                    ASSERT( length > IrpSp->Parameters.FileSystemControl.InputBufferLength );
                    newCopyFile = RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    length,
                                    RX_MISC_POOLTAG);
                    if (newCopyFile == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        TryLowIo = FALSE;
                        break;
                    }
                    newCopyFile->Flags = copyFile->Flags;
                    ExFreePool( copyFile );
                    copyFile = newCopyFile;
                    Irp->AssociatedIrp.SystemBuffer = copyFile;
                    IrpSp->Parameters.FileSystemControl.InputBufferLength = length;
                }

                copyFile->SourceFileNameLength = sourceString.MaximumLength;
                copyFile->DestinationFileNameLength = destString.MaximumLength;
                source = copyFile->FileNameBuffer;
                dest = source + (copyFile->SourceFileNameLength / sizeof(WCHAR));
                RtlCopyMemory( source, sourceString.Buffer, copyFile->SourceFileNameLength );
                RtlCopyMemory( dest, destString.Buffer, copyFile->DestinationFileNameLength );

                RtlFreeUnicodeString( &sourceString );
                RtlFreeUnicodeString( &destString );
            }
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }

    if (TryLowIo) {
        Status = RxLowIoFsCtlShell( RxContext, Irp, Fcb, Fobx );
    }

    if (RxContext->PostRequest) {
        Status = RxFsdPostRequest( RxContext );
    } else {
        if (Status == STATUS_PENDING) {
            RxDereferenceAndDeleteRxContext( RxContext );
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCommonFileSystemControl -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxLowIoFsCtlShell ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN PostToFsp = FALSE;

    NODE_TYPE_CODE TypeOfOpen = NodeType( Fcb );
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;
    BOOLEAN SubmitLowIoRequest = TRUE;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxLowIoFsCtlShell...\n", 0) );
    RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));

    RxInitializeLowIoContext( RxContext, LOWIO_OP_FSCTL, LowIoContext );

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_USER_FS_REQUEST:
        
        //
        //  The RDBSS filters out those FsCtls that can be handled without the intervention
        //  of the mini rdr's. Currently all FsCtls are forwarded down to the mini rdr.
        //

        switch (FsControlCode) {
        
        case FSCTL_PIPE_PEEK:
            
            if ((Irp->AssociatedIrp.SystemBuffer != NULL) &&
                (IrpSp->Parameters.FileSystemControl.OutputBufferLength >=
                 (ULONG)FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data[0] ))) {
    
                PFILE_PIPE_PEEK_BUFFER PeekBuffer = (PFILE_PIPE_PEEK_BUFFER)Irp->AssociatedIrp.SystemBuffer;
    
                RtlZeroMemory( PeekBuffer, IrpSp->Parameters.FileSystemControl.OutputBufferLength );
    
                if (RxShouldRequestBeThrottled( &Fobx->Specific.NamedPipe.ThrottlingState ) &&
                    RxEnablePeekBackoff) {
    
                    SubmitLowIoRequest = FALSE;
    
                    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShell: Throttling Peek Request\n") );
    
                    Irp->IoStatus.Information = FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER,Data );
                    PeekBuffer->ReadDataAvailable = 0;
                    PeekBuffer->NamedPipeState    = FILE_PIPE_CONNECTED_STATE;
                    PeekBuffer->NumberOfMessages  = MAXULONG;
                    PeekBuffer->MessageLength     = 0;
    
                    RxContext->StoredStatus = STATUS_SUCCESS;
    
                    Status = RxContext->StoredStatus;

                } else {
                    
                    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShell: Throttling queries %ld\n", Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries) );
    
                    RxLog(( "ThrottlQs %lx %lx %lx %ld\n", RxContext, Fobx, &Fobx->Specific.NamedPipe.ThrottlingState, Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ));
                    RxWmiLog( LOG,
                              RxLowIoFsCtlShell,
                              LOGPTR( RxContext )
                              LOGPTR( Fobx )
                              LOGULONG( Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ) );
                }
            
            } else {
                RxContext->StoredStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }

    if (SubmitLowIoRequest) {
        Status = RxLowIoSubmit( RxContext, Irp, Fcb, RxLowIoFsCtlShellCompletion );
    }

    RxDbgTrace( -1, Dbg, ("RxLowIoFsCtlShell -> %08lx\n", Status ));
    return Status;
}

NTSTATUS
RxLowIoFsCtlShellCompletion ( 
    IN PRX_CONTEXT RxContext 
    )
/*++

Routine Description:

    This is the completion routine for FSCTL requests passed down to the mini rdr

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIRP Irp = RxContext->CurrentIrp;
    PFCB Fcb = (PFCB)RxContext->pFcb;
    PFOBX Fobx = (PFOBX)RxContext->pFobx;

    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG FsControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoFsCtlShellCompletion  entry  Status = %08lx\n", Status));

    switch (FsControlCode) {
    case FSCTL_PIPE_PEEK:
       
        if ((Status == STATUS_SUCCESS) || (Status == STATUS_BUFFER_OVERFLOW)) {
             
            //
            //  In the case of Peek operations a throttle mechanism is in place to
            //  prevent the network from being flodded with requests which return 0
            //  bytes.
            //

            PFILE_PIPE_PEEK_BUFFER PeekBuffer;
            
            PeekBuffer = (PFILE_PIPE_PEEK_BUFFER)LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
            
            if (PeekBuffer->ReadDataAvailable == 0) {
            
                //
                //  The peek request returned zero bytes.
                //
                
                RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShellCompletion: Enabling Throttling for Peek Request\n") );
                RxInitiateOrContinueThrottling( &Fobx->Specific.NamedPipe.ThrottlingState );
                RxLog(( "ThrottlYes %lx %lx %lx %ld\n", RxContext, Fobx, &Fobx->Specific.NamedPipe.ThrottlingState, Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ));
                RxWmiLog( LOG,
                          RxLowIoFsCtlShellCompletion_1,
                          LOGPTR( RxContext )
                          LOGPTR( Fobx )
                          LOGULONG( Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ) );
            } else {
            
                RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShellCompletion: Disabling Throttling for Peek Request\n" ));
                RxTerminateThrottling( &Fobx->Specific.NamedPipe.ThrottlingState );
                RxLog(( "ThrottlNo %lx %lx %lx %ld\n", RxContext, Fobx, &Fobx->Specific.NamedPipe.ThrottlingState, Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ));
                RxWmiLog( LOG,
                          RxLowIoFsCtlShellCompletion_2,
                          LOGPTR( RxContext )
                          LOGPTR( Fobx )
                          LOGULONG( Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ) );
            }

            Irp->IoStatus.Information = RxContext->InformationToReturn;
        }
       
        break;
    
    default:

        if ((Status == STATUS_BUFFER_OVERFLOW) || (Status == STATUS_SUCCESS)) {
            Irp->IoStatus.Information = RxContext->InformationToReturn;
        }
        break;
    }

    Irp->IoStatus.Status = Status;

    RxDbgTrace(-1, Dbg, ("RxLowIoFsCtlShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}

NTSTATUS
TranslateSisFsctlName(
    IN PWCHAR InputName,
    OUT PUNICODE_STRING RelativeName,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PUNICODE_STRING NetRootName
    )

/*++

Routine Description:

    This routine converts a fully qualified name into a share-relative name.
    It is used to munge the input buffer of the SIS_COPYFILE FSCTL, which
    takes two fully qualified NT paths as inputs.

    The routine operates by translating the input path as necessary to get
    to an actual device name, verifying that the target device is the
    redirector, and verifying that the target server/share is the one on
    which the I/O was issued.

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    UNICODE_STRING CurrentString;
    UNICODE_STRING TestString;
    PWCHAR p;
    PWCHAR q;
    HANDLE Directory;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PWCHAR translationBuffer = NULL;
    ULONG translationLength;
    ULONG remainingLength;
    ULONG resultLength;

    RtlInitUnicodeString( &CurrentString, InputName );

    p = CurrentString.Buffer;

    if (!p) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((*p == L'\\') && (*(p+1) == L'\\'))  {

        //
        //  Special case for name that starts with \\ (i.e., a UNC name):
        //  assume that the \\ would translate to the redirector's name and
        //  skip the translation phase.
        //

        p++;

    } else {

        //
        //  The outer loop is executed each time a translation occurs.
        //

        while ( TRUE ) {

            //
            // Walk through any directory objects at the beginning of the string.
            //

            if ( *p != L'\\' ) {
                Status =  STATUS_OBJECT_NAME_INVALID;
                goto error_exit;
            }
            p++;

            //
            // The inner loop is executed while walking the directory tree.
            //

            while ( TRUE ) {

                q = wcschr( p, L'\\' );

                if ( q == NULL ) {
                    TestString.Length = CurrentString.Length;
                } else {
                    TestString.Length = (USHORT)(q - CurrentString.Buffer) * sizeof(WCHAR);
                }
                TestString.Buffer = CurrentString.Buffer;
                remainingLength = CurrentString.Length - TestString.Length + sizeof(WCHAR);

                InitializeObjectAttributes( &ObjectAttributes, 
                                            &TestString,
                                            OBJ_CASE_INSENSITIVE,
                                            NULL,
                                            NULL );

                Status = ZwOpenDirectoryObject( &Directory, DIRECTORY_TRAVERSE, &ObjectAttributes );

                //
                //  If we were unable to open the object as a directory, then break out
                //  of the inner loop and try to open it as a symbolic link.
                //

                if (!NT_SUCCESS( Status )) {
                    if (Status != STATUS_OBJECT_TYPE_MISMATCH) {
                        goto error_exit;
                    }
                    break;
                }

                //
                //  We opened the directory. Close it and try the next element of the path.
                //

                ZwClose( Directory );

                if (q == NULL) {

                    //
                    //  The last element of the name is an object directory. Clearly, this
                    //  is not a redirector path.
                    //

                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                    goto error_exit;
                }

                p = q + 1;
            }

            //
            //  Try to open the current name as a symbolic link.
            //

            Status = ZwOpenSymbolicLinkObject( &Directory, SYMBOLIC_LINK_QUERY, &ObjectAttributes );

            //
            //  If we were unable to open the object as a symbolic link, then break out of
            //  the outer loop and verify that this is a redirector name.
            //

            if (!NT_SUCCESS( Status )) {
                if (Status != STATUS_OBJECT_TYPE_MISMATCH) {
                    goto error_exit;
                }
                break;
            }

            //
            //  The object is a symbolic link. Translate it.
            //

            TestString.MaximumLength = 0;
            Status = ZwQuerySymbolicLinkObject( Directory, &TestString, &translationLength );
            if (!NT_SUCCESS( Status ) && (Status != STATUS_BUFFER_TOO_SMALL)) {
                
                ZwClose( Directory );
                goto error_exit;
            }

            resultLength = translationLength + remainingLength;
            p = RxAllocatePoolWithTag( PagedPool|POOL_COLD_ALLOCATION, resultLength, RX_MISC_POOLTAG );
            if (p == NULL) {
                
                Status = STATUS_INSUFFICIENT_RESOURCES;
                ZwClose( Directory );
                goto error_exit;
            }

            TestString.MaximumLength = (USHORT)translationLength;
            TestString.Buffer = p;
            Status = ZwQuerySymbolicLinkObject( Directory, &TestString, NULL );
            ZwClose( Directory );
            if (!NT_SUCCESS( Status )) {
                
                RxFreePool( p );
                goto error_exit;
            }
            if (TestString.Length > translationLength) {
                Status = STATUS_OBJECT_NAME_INVALID;
                RxFreePool( p );
                goto error_exit;
            }

            RtlCopyMemory( Add2Ptr( p, TestString.Length ), q, remainingLength );
            CurrentString.Buffer = p;
            CurrentString.Length = (USHORT)(resultLength - sizeof(WCHAR));
            CurrentString.MaximumLength = (USHORT)resultLength;

            if (translationBuffer != NULL) {
                RxFreePool( translationBuffer );
            }
            translationBuffer = p;
        }

        //
        //  We have a result name. Verify that it is a redirector name.
        //

        if (!RtlPrefixUnicodeString( &RxDeviceObject->DeviceName, &CurrentString, TRUE )) {
            Status = STATUS_OBJECT_NAME_INVALID;
            goto error_exit;
        }

        //
        //  Skip over the redirector device name.
        //

        p = Add2Ptr( CurrentString.Buffer, RxDeviceObject->DeviceName.Length / sizeof(WCHAR));
        if (*p != L'\\') {
            Status = STATUS_OBJECT_NAME_INVALID;
            goto error_exit;
        }

        //
        //  Skip over the drive letter, if present.
        //

        if (*(p + 1) == L';') {
            p = wcschr( ++p, L'\\' );
            if (p == NULL) {
                Status = STATUS_OBJECT_NAME_INVALID;
                goto error_exit;
            }
        }
    }

    //
    //  Verify that the next part of the string is the correct net root name.
    //

    CurrentString.Length -= (USHORT)(p - CurrentString.Buffer) * sizeof(WCHAR);
    CurrentString.Buffer = p;

    if (!RtlPrefixUnicodeString( NetRootName, &CurrentString, TRUE )) {
        Status = STATUS_OBJECT_NAME_INVALID;
        goto error_exit;
    }
    p += NetRootName->Length / sizeof( WCHAR );
    if (*p != L'\\') {
        Status = STATUS_OBJECT_NAME_INVALID;
        goto error_exit;
    }
    p++;
    if (*p == 0) {
        Status = STATUS_OBJECT_NAME_INVALID;
        goto error_exit;
    }

    //
    //  Copy the rest of the string after the redirector name to a new buffer.
    //

    RtlCreateUnicodeString( RelativeName, p );

    Status = STATUS_SUCCESS;

error_exit:

    if (translationBuffer != NULL) {
        RxFreePool( translationBuffer );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntdisp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Ntdisp.h

Abstract:

    This module prototypes the upper level routines used in dispatching to the implementations

Author:

    Joe Linn     [JoeLinn]   24-aug-1994

Revision History:

--*/

#ifndef _DISPATCH_STUFF_DEFINED_
#define _DISPATCH_STUFF_DEFINED_

VOID
RxInitializeDispatchVectors (
    OUT PDRIVER_OBJECT DriverObject
    );

//
//  The global structure used to contain our fast I/O callbacks; this is
//  exposed because it's needed in read/write; we could use a wrapper....probably should. but since
//  ccinitializecachemap will be macro'd differently for win9x; we'll just doit there.
//

extern FAST_IO_DISPATCH RxFastIoDispatch;

//
//  The following funcs are implemented in DevFCB.c
//

NTSTATUS
RxCommonDevFCBCleanup ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                          

NTSTATUS
RxCommonDevFCBClose ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                            

NTSTATUS
RxCommonDevFCBIoCtl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                

NTSTATUS
RxCommonDevFCBFsCtl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                

NTSTATUS
RxCommonDevFCBQueryVolInfo ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                
    
//
//   contained here are the fastio dispatch routines and the fsrtl callback routines
//

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) IoIsOperationSynchronous(IRP)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
RxFspDispatch (                        //  implemented in FspDisp.c
    IN PVOID Context
    );



//
//  The following routines are the FSP work routines that are called
//  by the preceding RxFspDispath routine.  Each takes as input a pointer
//  to the IRP, perform the function, and return a pointer to the volume
//  device object that they just finished servicing (if any).  The return
//  pointer is then used by the main Fsp dispatch routine to check for
//  additional IRPs in the volume's overflow queue.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

NTSTATUS
RxCommonCleanup (                                           //  implemented in Cleanup.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                      

NTSTATUS
RxCommonClose (                                             //  implemented in Close.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

VOID
RxFspClose (
    IN PVCB Vcb OPTIONAL
    );

NTSTATUS
RxCommonCreate (                                            //  implemented in Create.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonDirectoryControl (                                  //  implemented in DirCtrl.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonDeviceControl (                                     //  implemented in DevCtrl.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonQueryEa (                                           //  implemented in Ea.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
);                        

NTSTATUS
RxCommonSetEa (                                             //  implemented in Ea.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonQuerySecurity (                                     //  implemented in Ea.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonSetSecurity (                                       //  implemented in Ea.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonQueryInformation (                                  //  implemented in FileInfo.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonSetInformation (                                    //  implemented in FileInfo.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonFlushBuffers (                                      //  implemented in Flush.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonFileSystemControl (                                 //  implemented in FsCtrl.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonLockControl (                                       //  implemented in LockCtrl.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonShutdown (                                          //  implemented in Shutdown.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonRead (                                              //  implemented in Read.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonQueryVolumeInformation (                            //  implemented in VolInfo.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonSetVolumeInformation (                              //  implemented in VolInfo.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        

NTSTATUS
RxCommonWrite (                                             //  implemented in Write.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );                        
    
NTSTATUS
RxCommonQueryQuotaInformation (                             //  implemented in Ea.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );            

NTSTATUS
RxCommonSetQuotaInformation (                               //  implemented in Ea.c
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );              

//  Here are the callbacks used by the I/O system for checking for fast I/O or
//  doing a fast query info call, or doing fast lock calls.
//

BOOLEAN
RxFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  The following macro is used to set the is fast i/o possible field in
//  the common part of the nonpaged fcb
//
//
//      BOOLEAN
//      RxIsFastIoPossible (
//          IN PFCB Fcb
//          );
//

//
//  Instead of RxIsFastIoPossible...we set the state to questionable.....this will cause us to be consulted on every call via out
//  CheckIfFastIoIsPossibleCallOut. in this way, we don't have to be continually setting and resetting this
//


VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

//
#endif // _DISPATCH_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntdevfcb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtDevFcb.c

Abstract:

    This module implements the FSD level Close, CleanUp, and  FsCtl and IoCtl routines for RxDevice
    files.  Also, the createroutine is not here; rather, it is called from CommonCreate and
    not called directly by the dispatch driver.

    Each of the pieces listed (close, cleanup, fsctl, ioctl) has its own little section of the
    file......complete with its own forward-prototypes and alloc pragmas

Author:

    Joe Linn     [JoeLinn]    3-aug-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntddnfs2.h>
#include <ntddmup.h>
#include "fsctlbuf.h"
#include "prefix.h"
#include "rxce.h"

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)


NTSTATUS
RxXXXControlFileCallthru (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxDevFcbQueryDeviceInfo (
    IN PRX_CONTEXT RxContext,
    IN PFOBX Fobx,
    OUT PBOOLEAN PostToFsp,
    PFILE_FS_DEVICE_INFORMATION UsersBuffer,
    ULONG BufferSize,
    PULONG ReturnedLength
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDevFCBFsCtl)
#pragma alloc_text(PAGE, RxXXXControlFileCallthru)
#pragma alloc_text(PAGE, RxCommonDevFCBClose)
#pragma alloc_text(PAGE, RxCommonDevFCBCleanup)
#pragma alloc_text(PAGE, RxGetUid)
#pragma alloc_text(PAGE, RxCommonDevFCBIoCtl)
#pragma alloc_text(PAGE, RxCommonDevFCBQueryVolInfo)
#pragma alloc_text(PAGE, RxDevFcbQueryDeviceInfo)
#endif

NTSTATUS
RxXXXControlFileCallthru (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine calls down to the minirdr to implement ioctl and fsctl controls that
    the wrapper doesn't understand. note that if there is no dispatch defined (i.e. for the
    wrapper's own device object) then we also set Rxcontext->Fobx to NULL so that the caller
    won't try to go thru lowio to get to the minirdr.

Arguments:

    RxContext - the context of the request
    
    Irp -  the current irp

Return Value:

    RXSTATUS - The FSD status for the request include the PostRequest field....

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    
    PAGED_CODE();

    if (RxContext->RxDeviceObject->Dispatch == NULL) {

        //
        //  don't try again on lowio
        //
        
        RxContext->pFobx = NULL; 
        
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    Status = RxLowIoPopulateFsctlInfo( RxContext, Irp );

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    if ((LowIoContext->ParamsFor.FsCtl.InputBufferLength > 0) &&
        (LowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL)) {
        
        return STATUS_INVALID_PARAMETER;
    }

    if ((LowIoContext->ParamsFor.FsCtl.OutputBufferLength > 0) &&
        (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL)) {
        
        return STATUS_INVALID_PARAMETER;
    }

    Status = (RxContext->RxDeviceObject->Dispatch->MRxDevFcbXXXControlFile)(RxContext);

    if (Status != STATUS_PENDING) {
        
        Irp->IoStatus.Information = RxContext->InformationToReturn;
    }

    return Status;
}



NTSTATUS
RxCommonDevFCBClose ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )
/*++

Routine Description:

    This routine implements the FSD Close for a Device FCB.

Arguments:

    RxDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The FSD status for the IRP

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;
    PFOBX Fobx;
    PFCB Fcb;
    NODE_TYPE_CODE TypeOfOpen;
    PRX_PREFIX_TABLE RxNetNameTable = RxContext->RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx ); 

    RxDbgTrace( 0, Dbg, ("RxCommonDevFCBClose\n", 0) );
    RxLog(( "DevFcbClose %lx %lx\n",RxContext, FileObject ));
    RxWmiLog( LOG,
              RxCommonDevFCBClose,
              LOGPTR( RxContext )
              LOGPTR( FileObject ) );

    if (TypeOfOpen != RDBSS_NTC_DEVICE_FCB) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  deal with the device fcb
    //

    if (!Fobx) {
        Fcb->OpenCount -= 1;
        return STATUS_SUCCESS;
    }

    //
    //  otherwise, it's a connection-type file. you have to get the lock; then case-out
    //

    RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );

    try {
        
        switch (NodeType( Fobx )) {
        
        case RDBSS_NTC_V_NETROOT:
           {
               PV_NET_ROOT VNetRoot = (PV_NET_ROOT)Fobx;

               VNetRoot->NumberOfOpens -= 1;
               RxDereferenceVNetRoot( VNetRoot, LHS_ExclusiveLockHeld );
           }
           break;
        
        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
    } finally {
         RxReleasePrefixTableLock( RxNetNameTable );
    }

    return Status;
}

NTSTATUS
RxCommonDevFCBCleanup ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD part of closing down a handle to a
    device FCB.

Arguments:

    RxDeviceObject - Supplies the volume device object where the
        file being Cleanup exists

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The FSD status for the IRP

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;
    PFOBX Fobx;
    PFCB Fcb;
    NODE_TYPE_CODE TypeOfOpen;


    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx );

    RxDbgTrace( 0, Dbg, ("RxCommonFCBCleanup\n", 0) );
    RxLog(( "DevFcbCleanup %lx\n", RxContext, FileObject ));
    RxWmiLog( LOG,
              RxCommonDevFCBCleanup,
              LOGPTR( RxContext )
              LOGPTR( FileObject ) );

    if (TypeOfOpen != RDBSS_NTC_DEVICE_FCB) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  deal with the device fcb
    //

    if (!Fobx) {
        
        Fcb->UncleanCount -= 1;
        return STATUS_SUCCESS;
    }

    //
    //  otherwise, it's a connection-type file. you have to get the lock; then case-out
    //

    RxAcquirePrefixTableLockShared( RxContext->RxDeviceObject->pRxNetNameTable, TRUE );

    try {

        Status = STATUS_SUCCESS;

        switch (NodeType( Fobx )) {
        
        case RDBSS_NTC_V_NETROOT:
            
            //
            //  nothing to do
            //

            break;
        
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
    
    } finally {
         RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
    }

    return Status;
}

//
//         | *********************|
//         | |   F  S  C  T  L   ||
//         | *********************|
//


NTSTATUS
RxCommonDevFCBFsCtl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )
/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    RxContext - Supplies the Irp to process and stateinfo about where we are

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFOBX Fobx;
    PFCB Fcb;
    NODE_TYPE_CODE TypeOfOpen;
    ULONG FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonDevFCBFsCtl     IrpC = %08lx\n", RxContext) );
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx, ControlCode   = %08lx \n",
                        IrpSp->MinorFunction, FsControlCode) );
    RxLog(( "DevFcbFsCtl %lx %lx %lx\n", RxContext, IrpSp->MinorFunction, FsControlCode ));
    RxWmiLog( LOG,
              RxCommonDevFCBFsCtl,
              LOGPTR( RxContext )
              LOGUCHAR( IrpSp->MinorFunction )
              LOGULONG( FsControlCode ) );

    if (TypeOfOpen != RDBSS_NTC_DEVICE_FCB ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_USER_FS_REQUEST:
        
        switch (FsControlCode) {

#ifdef RDBSSLOG

        case FSCTL_LMR_DEBUG_TRACE:

            //
            //  This FSCTL is being disabled since no one uses this anymore. If
            //  it needs to be reactivated for some reason, the appropriate 
            //  checks have to be added to make sure that the IRP->UserBuffer is
            //  a valid address. The try/except call below won't protect against
            //  a random kernel address being passed.
            //
            
            return STATUS_INVALID_DEVICE_REQUEST;

            //
            //  the 2nd buffer points to the string
            //

            //
            //  We need to try/except this call to protect against random buffers
            //  being passed in from UserMode.
            //
            
            try {
                RxDebugControlCommand( Irp->UserBuffer );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                  return STATUS_INVALID_USER_BUFFER;
            }

            Status = STATUS_SUCCESS;
            break;

#endif //  RDBSSLOG

        default:
             
            RxDbgTrace( 0, Dbg, ("RxFsdDevFCBFsCTL unknown user request\n") );
             
            Status = RxXXXControlFileCallthru( RxContext, Irp );
            if ((Status == STATUS_INVALID_DEVICE_REQUEST) && (Fobx != NULL)) {
                 
                RxDbgTrace( 0, Dbg, ("RxCommonDevFCBFsCtl -> Invoking Lowio for FSCTL\n") );
                Status = RxLowIoFsCtlShell( RxContext, Irp, Fcb, Fobx );
            }
        }
        break;
    
    default :
        RxDbgTrace( 0, Dbg, ("RxFsdDevFCBFsCTL nonuser request!!\n", 0) );
        Status = RxXXXControlFileCallthru( RxContext, Irp );
    }


    if (RxContext->PostRequest) {
       Status = RxFsdPostRequestWithResume( RxContext, RxCommonDevFCBFsCtl );
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBFsCtl -> %08lx\n", Status));
    return Status;
}

//
//   | *********************|
//   | |   I  O  C  T  L   ||
//   | *********************|
//



NTSTATUS
RxCommonDevFCBIoCtl ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp 
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    RxContext - Supplies the Irp to process and stateinfo about where we are

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;
    ULONG IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonDevFCBIoCtl IrpC-%08lx\n", RxContext) );
    RxDbgTrace( 0, Dbg, ("ControlCode   = %08lx\n", IoControlCode) );

    if (TypeOfOpen != RDBSS_NTC_DEVICE_FCB ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (Fobx == NULL) {

        switch (IoControlCode) {

        case IOCTL_REDIR_QUERY_PATH:
            //
            // This particular IOCTL should only come to us from the MUP and
            // hence the requestor mode of the IRP should always be KernelMode.
            // If its not we return STATUS_INVALID_DEVICE_REQUEST.
            //
            if (Irp->RequestorMode != KernelMode) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            } else {
                Status = RxPrefixClaim( RxContext );
            }
            break;

        default:
            Status = RxXXXControlFileCallthru( RxContext, Irp );
            if ((Status != STATUS_PENDING) && RxContext->PostRequest)  {
                Status = RxFsdPostRequestWithResume( RxContext, RxCommonDevFCBIoCtl );
            }
            break;

        }

    } else {

        Status = STATUS_INVALID_HANDLE;

    }

    RxDbgTrace( -1, Dbg, ("RxCommonDevFCBIoCtl -> %08lx\n", Status) );

    return Status;
}

//
//  Utility Routine
//

LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    )

/*++

Routine Description:

    This routine gets the effective UID to be used for this create.

Arguments:

    SubjectSecurityContext - Supplies the information from IrpSp.

Return Value:

    None

--*/
{
    LUID LogonId;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxGetUid ... \n", 0));

    //
    //  Use SeQuerySubjectContextToken to get the proper token in case of impersonation
    //

    SeQueryAuthenticationIdToken( SeQuerySubjectContextToken( SubjectSecurityContext ), &LogonId );
    RxDbgTrace( -1, Dbg, (" ->UserUidHigh/Low = %08lx %08lx\n", LogonId.HighPart, LogonId.LowPart) );

    return LogonId;
}

//
//   | *********************|
//   | |   V O L I N F O   ||
//   | *********************|
//

NTSTATUS
RxCommonDevFCBQueryVolInfo ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    RxContext - Supplies the Irp to process and stateinfo about where we are

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FS_INFORMATION_CLASS InformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    PFCB Fcb;
    PFOBX Fobx;
    NODE_TYPE_CODE TypeOfOpen;
    
    PVOID UsersBuffer = Irp->AssociatedIrp.SystemBuffer;
    ULONG BufferSize = IrpSp->Parameters.QueryVolume.Length;
    ULONG ReturnedLength;
    BOOLEAN PostToFsp = FALSE;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    if (TypeOfOpen != RDBSS_NTC_DEVICE_FCB ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    RxDbgTrace( +1, Dbg, ("RxCommonDevFCBQueryVolInfo IrpC-%08lx\n", RxContext) );
    RxDbgTrace( 0, Dbg, ("ControlCode   = %08lx\n", InformationClass) );
    RxLog(( "DevFcbQVolInfo %lx %lx\n", RxContext, InformationClass ));
    RxWmiLog( LOG,
              RxCommonDevFCBQueryVolInfo,
              LOGPTR( RxContext )
              LOGULONG( InformationClass ) );

    switch (InformationClass) {

    case FileFsDeviceInformation:

        Status = RxDevFcbQueryDeviceInfo( RxContext, Fobx, &PostToFsp, UsersBuffer, BufferSize, &ReturnedLength );
        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;

    };

    RxDbgTrace( -1, Dbg, ("RxCommonDevFCBQueryVolInfo -> %08lx\n", Status) );

    if ( PostToFsp ) return RxFsdPostRequestWithResume( RxContext, RxCommonDevFCBQueryVolInfo );

    if (Status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = ReturnedLength;
    }

    return Status;
}


NTSTATUS
RxDevFcbQueryDeviceInfo (
    IN PRX_CONTEXT RxContext,
    IN PFOBX Fobx,
    OUT PBOOLEAN PostToFsp,
    PFILE_FS_DEVICE_INFORMATION UsersBuffer,
    ULONG BufferSize,
    PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine shuts down up the RDBSS filesystem...i.e. we connect to the MUP. We can only shut down
    if there's no netroots and if there's only one deviceFCB handle.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

    

--*/

{
    NTSTATUS Status;
    BOOLEAN Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
    BOOLEAN InFSD = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP );

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxDevFcbQueryDeviceInfo -> %08lx\n", 0));

    if (BufferSize < sizeof( FILE_FS_DEVICE_INFORMATION )) {
        return STATUS_BUFFER_OVERFLOW;
    };
    UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;
    *ReturnedLength = sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  deal with the device fcb
    //

    if (!Fobx) {
        
        UsersBuffer->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
        return STATUS_SUCCESS;
    }

    //
    //  otherwise, it's a connection-type file. you have to get the lock; then case-out
    //

    if (!RxAcquirePrefixTableLockShared( RxContext->RxDeviceObject->pRxNetNameTable, Wait )) {
        
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    try {
        
        Status = STATUS_SUCCESS;
        switch (NodeType( Fobx )) {
        
        case RDBSS_NTC_V_NETROOT: 
            {
                PV_NET_ROOT VNetRoot = (PV_NET_ROOT)Fobx;
                PNET_ROOT NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
    
                if (NetRoot->Type == NET_ROOT_PIPE) {
                    NetRoot->DeviceType = FILE_DEVICE_NAMED_PIPE;
                }
    
                UsersBuffer->DeviceType = NetRoot->DeviceType;
            }
            break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
    } finally {
         RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
    }

    return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\minirdr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    minirdr.c

Abstract:

    This module implements minirdr registration functions.

Author:

    Joe Linn (JoeLinn)    2-2-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxRegisterMinirdr)
#pragma alloc_text(PAGE, RxMakeLateDeviceAvailable)
#pragma alloc_text(PAGE, RxpUnregisterMinirdr)
#endif

//
//  The debug trace level
//

#define Dbg                              (0)

#ifdef ALLOC_PRAGMA
#endif

// #define BBT_UPDATE 1

#ifdef BBT_UPDATE
extern VOID RxUpdate(PVOID pContext);

HANDLE   RxHandle  = INVALID_HANDLE_VALUE;
PETHREAD RxPointer = NULL;
#endif 


NTSTATUS
NTAPI
RxRegisterMinirdr(
    OUT PRDBSS_DEVICE_OBJECT *DeviceObject,
    IN OUT PDRIVER_OBJECT DriverObject,    
    IN PMINIRDR_DISPATCH MrdrDispatch,    
    IN ULONG Controls,
    IN PUNICODE_STRING DeviceName,
    IN ULONG DeviceExtensionSize,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics
    )
/*++

Routine Description:

    The routine adds the registration information to the minirdr registration table. As well, it builds
    a device object; the MUP registration is at start time. Also, we fill in the deviceobject so that we are catching
    all the calls.

Arguments:

    DeviceObject   - where the created device object is to be stored
    ProtocolMarker - a 4byte marker denoting the FileLevel Protocol
                             ('LCL ', 'SMB ', 'NCP ', and 'NFS ') are used
    MrdrDispatch   - the dispatch table for finding the server/netroot discovery routines
    Context        - whatever PVOID the underlying guy wants
    MupAction      - whether/how the MUP registration is done
    DeviceName,DeviceExtensionSize,DeviceType,DeviceCharacteristics
                   - the params for the device object that is to be built these are adjusted a bit
                     bfore they're passed to Io

Return Value:

    --

--*/
{
    NTSTATUS Status;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), (" RxRegisterMinirdr  Name = %wZ", DeviceName) );

    if (DeviceObject == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Create the device object.
    //

    Status = IoCreateDevice( DriverObject,
                             sizeof(RDBSS_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT) + DeviceExtensionSize,
                             DeviceName,
                             DeviceType,
                             DeviceCharacteristics,
                             FALSE,
                             (PDEVICE_OBJECT *)(&RxDeviceObject));
    
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    if (RxData.DriverObject == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    //  If the Mini-Redir is being built in a monolithic fashion, then the 
    //  device object "RxFileSystemDeviceObject" would not have been created
    //  in the RxDriverEntry function. Hence we set RxDeviceObject->RDBSSDeviceObject
    //  to NULL. When the "monolithic" Mini-Redir gets unloaded, a check is done
    //  to see if RxDeviceObject->RDBSSDeviceObject is NULL. If it is not NULL,
    //  then the device object is dereferenced. This happens in the function
    //  RxUnregisterMinirdr.
    //
    //  Don't allow myself to be unloaded.
    //

#ifndef MONOLITHIC_MINIRDR
    RxDeviceObject->RDBSSDeviceObject = (PDEVICE_OBJECT)RxFileSystemDeviceObject;
    ObReferenceObject( (PDEVICE_OBJECT)RxFileSystemDeviceObject );

    //
    //  Reset the Unload routine. This prevents rdbss from being unloaded individually
    //

    RxData.DriverObject->DriverUnload = NULL;
#else
    RxDeviceObject->RDBSSDeviceObject = NULL;
    RxFileSystemDeviceObject->ReferenceCount += 1;
#endif

    *DeviceObject = RxDeviceObject;
    
    RxDeviceObject->RdbssExports = &RxExports;
    RxDeviceObject->Dispatch = MrdrDispatch;
    RxDeviceObject->RegistrationControls = Controls;
    RxDeviceObject->DeviceName = *DeviceName;
    RxDeviceObject->RegisterUncProvider =
             !BooleanFlagOn( Controls, RX_REGISTERMINI_FLAG_DONT_PROVIDE_UNCS );
    RxDeviceObject->RegisterMailSlotProvider =
             !BooleanFlagOn( Controls, RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS );

    {
        LONG Index;

        for (Index = 0; Index < MaximumWorkQueue; Index++) {
            InitializeListHead( &RxDeviceObject->OverflowQueue[Index] );
        }
    }

    KeInitializeSpinLock( &RxDeviceObject->OverflowQueueSpinLock );

    RxDeviceObject->NetworkProviderPriority = RxGetNetworkProviderPriority( DeviceName );
    RxLog(( "RegMini %x %wZ\n", RxDeviceObject->NetworkProviderPriority, DeviceName ));
    RxWmiLog( LOG,
              RxRegisterMinirdr,
              LOGULONG( RxDeviceObject->NetworkProviderPriority )
              LOGUSTR( *DeviceName ) );

    ExAcquireFastMutexUnsafe( &RxData.MinirdrRegistrationMutex );

    InsertTailList( &RxData.RegisteredMiniRdrs, &RxDeviceObject->MiniRdrListLinks );
    
    // 
    //  no need for interlock.....we're inside the mutex
    //

    RxData.NumberOfMinirdrsRegistered += 1;

    ExReleaseFastMutexUnsafe(&RxData.MinirdrRegistrationMutex);

    if (!FlagOn( Controls, RX_REGISTERMINI_FLAG_DONT_INIT_DRIVER_DISPATCH )) {
        RxInitializeMinirdrDispatchTable( DriverObject );
    }

    if (!FlagOn( Controls, RX_REGISTERMINI_FLAG_DONT_INIT_PREFIX_N_SCAVENGER )) {

        //
        //  Initialize the netname table
        //

        RxDeviceObject->pRxNetNameTable = &RxDeviceObject->RxNetNameTableInDeviceObject;
        RxInitializePrefixTable( RxDeviceObject->pRxNetNameTable, 0, FALSE );
        RxDeviceObject->RxNetNameTableInDeviceObject.IsNetNameTable = TRUE;

        //
        //  Initialize the scavenger data structures
        //

        RxDeviceObject->pRdbssScavenger = &RxDeviceObject->RdbssScavengerInDeviceObject;
        RxInitializeRdbssScavenger( RxDeviceObject->pRdbssScavenger );
    }

    RxDeviceObject->pAsynchronousRequestsCompletionEvent = NULL;

#ifdef BBT_UPDATE
    if (RxHandle == INVALID_HANDLE_VALUE) {
        NTSTATUS Status;

        Status = PsCreateSystemThread( &RxHandle,
                                       PROCESS_ALL_ACCESS,
                                       NULL,
                                       NULL,
                                       NULL,
                                       RxUpdate,
                                       NULL );

        if (Status == STATUS_SUCCESS) {
            
            Status = ObReferenceObjectByHandle( RxHandle,
                                                THREAD_ALL_ACCESS,
                                                NULL,
                                                KernelMode,
                                                &RxPointer,
                                                NULL );

            if (Status != STATUS_SUCCESS) {
                RxPointer = NULL;
            }

            ZwClose( RxHandle );
        } else {
            RxHandle = INVALID_HANDLE_VALUE;
        }
    }
#endif 

    return STATUS_SUCCESS;
}


VOID
NTAPI
RxMakeLateDeviceAvailable (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    The routine diddles the device object to make a "late device" available.
    A late device is one that is not created in the driver's load routine.
    Non-late devices are diddled by the driverload code in the io subsystem; but
    for late devices we have to do this by hand. This is a routine instead of a
    macro in order that other stuff might have to be done here....it's only
    executed once per device object.

Arguments:

    DeviceObject   - where the created device object is to be stored

Return Value:

    --

--*/
{
    PAGED_CODE();
    ClearFlag( RxDeviceObject->Flags, DO_DEVICE_INITIALIZING );
    return;
}

VOID
RxpUnregisterMinirdr (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )

/*++

Routine Description:

Arguments:

Return Value:

    --

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), (" RxUnregisterMinirdr  Name = %wZ\n",&RxDeviceObject->DeviceName) );
    
    ExAcquireFastMutexUnsafe( &RxData.MinirdrRegistrationMutex );
    
    RemoveEntryList(&RxDeviceObject->MiniRdrListLinks);

    //
    //  no need for interlock.....we're inside the mutex
    //
    
    RxData.NumberOfMinirdrsRegistered -= 1;

    if (RxData.NumberOfMinirdrsRegistered == 0) {
        
        //
        //  Allow rdbss being unloaded after mini rdr driver is unregistered
        //

        RxData.DriverObject->DriverUnload = RxUnload;
    }

    ExReleaseFastMutexUnsafe( &RxData.MinirdrRegistrationMutex );

    if (!FlagOn( RxDeviceObject->RegistrationControls, RX_REGISTERMINI_FLAG_DONT_INIT_PREFIX_N_SCAVENGER )) {

        RxForceNetTableFinalization( RxDeviceObject );
        RxFinalizePrefixTable( &RxDeviceObject->RxNetNameTableInDeviceObject );

        //
        //  no finalization is defined for scavenger structure
        //
    }

    RxSpinDownOutstandingAsynchronousRequests( RxDeviceObject );

    //
    //  Spin down any worker threads associated with this minirdr
    //
    
    RxSpinDownMRxDispatcher( RxDeviceObject );

    IoDeleteDevice( &RxDeviceObject->DeviceObject );

#ifdef BBT_UPDATE
    if (RxPointer != NULL) {

        RxHandle = INVALID_HANDLE_VALUE;
        KeWaitForSingleObject( RxPointer, Executive, KernelMode, FALSE, NULL );
        
        ASSERT( PsIsThreadTerminating( RxPointer ) );
        ObDereferenceObject( RxPointer );

        RxPointer = NULL;
    }
#endif 
}


VOID
RxSpinDownOutstandingAsynchronousRequests (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine spins down all the outstanding requests associated with a
    mini redirector before it can be unloaded

Arguments:

    RxDeviceObject -- the mini redirector's device object


--*/
{
    BOOLEAN WaitForSpinDown = FALSE;
    KEVENT SpinDownEvent;

    KeInitializeEvent( &SpinDownEvent, NotificationEvent, FALSE );

    RxAcquireSerializationMutex();

    ASSERT( RxDeviceObject->pAsynchronousRequestsCompletionEvent == NULL );

    WaitForSpinDown = (RxDeviceObject->AsynchronousRequestsPending != 0);

    RxDeviceObject->pAsynchronousRequestsCompletionEvent = &SpinDownEvent;

    RxReleaseSerializationMutex();

    if (WaitForSpinDown) {
        
        KeWaitForSingleObject( &SpinDownEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
}


NTSTATUS
RxRegisterAsynchronousRequest (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine registers an asynchronous request. On successful completion
    the mini redirector cannot be unloaded till the request completes

Arguments:

    RxDeviceObject - the mini redirector device object

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    RxAcquireSerializationMutex();

    if (RxDeviceObject->pAsynchronousRequestsCompletionEvent == NULL) {
        RxDeviceObject->AsynchronousRequestsPending += 1;
        Status = STATUS_SUCCESS;
    }

    RxReleaseSerializationMutex();

    return Status;
}

VOID
RxDeregisterAsynchronousRequest (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine signals the completion of an asynchronous request. It resumes
    unloading if required.

Arguments:

    RxDeviceObject - the mini redirector device object

--*/
{
    PKEVENT Event = NULL;

    RxAcquireSerializationMutex();

    RxDeviceObject->AsynchronousRequestsPending -= 1;

    if ((RxDeviceObject->AsynchronousRequestsPending == 0) &&
        (RxDeviceObject->pAsynchronousRequestsCompletionEvent != NULL)) {
        
        Event = RxDeviceObject->pAsynchronousRequestsCompletionEvent;
    }

    RxReleaseSerializationMutex();

    if (Event != NULL) { 
        
        KeSetEvent( Event, IO_NO_INCREMENT, FALSE );
    }
}

#ifdef BBT_UPDATE
WCHAR   Request_Name[] = L"\\??\\UNC\\landyw-bear\\bbt\\bbt.txt";

VOID
RxUpdate(PVOID pContext)
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    RequestName;

    RequestName.Buffer = Request_Name;
    RequestName.MaximumLength = wcslen( Request_Name ) * sizeof( WCHAR );
    RequestName.Length = RequestName.MaximumLength;

    InitializeObjectAttributes( &ObjectAttributes,
                                &RequestName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    for (;;) {
        PHYSICAL_ADDRESS StartAddress;
        LARGE_INTEGER NumberOfBytes;
        HANDLE FileHandle;

        struct {
            LIST_ENTRY Link;
            SIZE_T Size;
            CHAR Data[];
        } *Request;

        NumberOfBytes.QuadPart = 0x2;
        StartAddress.QuadPart = 0;

        MmAddPhysicalMemory(
            &StartAddress,
            &NumberOfBytes);

        Request = (PVOID)(StartAddress.QuadPart);

        if (Request != NULL) {
            
            Status = ZwCreateFile( &FileHandle,
                                   FILE_APPEND_DATA | SYNCHRONIZE,
                                   &ObjectAttributes,
                                   &IoStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE,
                                   FILE_OPEN,
                                   FILE_NO_INTERMEDIATE_BUFFERING,
                                   NULL,
                                   0 );


            if (Status == STATUS_SUCCESS) {
                LARGE_INTEGER ByteOffset;

                ByteOffset.QuadPart = -1;

                Status = ZwWriteFile( FileHandle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &IoStatusBlock,
                                      Request->Data,
                                      (ULONG)Request->Size,
                                      &ByteOffset,
                                      NULL );                           

                Status = ZwClose( FileHandle );
            }

            ExFreePool( Request );
        }


        if (RxHandle == INVALID_HANDLE_VALUE) {
            break;
        }
    }

    PsTerminateSystemThread( STATUS_SUCCESS );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\flush.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements the File Flush buffers routine for Rx called by the
    dispatch driver.

    In a future version of the wrapper, it may be that flush will be routed thru lowio.

Author:

    Joe Linn     [JoeLinn]    15-dec-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonFlushBuffers)
#endif



NTSTATUS
RxCommonFlushBuffers ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for flushing file buffers.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PFOBX Fobx;
    
    NODE_TYPE_CODE TypeOfOpen;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    
    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonFlush...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb ));
    RxLog(( "%s %lx %lx %lx\n","slF", RxContext, Fcb, Fobx ));
    RxWmiLog( LOG,
              RxCommonFlushBuffers,
              LOGPTR( RxContext )
              LOGPTR( Fcb )
              LOGPTR( Fobx ) );

    //
    //  CcFlushCache is always synchronous, so if we can't wait enqueue
    //  the irp to the Fsp.
    //

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )) {

        Status = RxFsdPostRequest( RxContext );

        RxDbgTrace( -1, Dbg, ("RxCommonFlushBuffers -> %08lx\n", Status ));
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open that we are trying to flush
        //

        switch (TypeOfOpen) {

        case RDBSS_NTC_STORAGE_TYPE_FILE:

            RxDbgTrace( 0, Dbg, ("Flush User File Open\n", 0) );

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );

            if (Status != STATUS_SUCCESS) break;

            FcbAcquired = TRUE;

            //
            //  If the file is cached then flush its cache
            //

            Status = RxFlushFcbInSystemCache( Fcb, TRUE );

            if (!NT_SUCCESS( Status )) break;

            MINIRDR_CALL( Status, RxContext, Fcb->MRxDispatch, MRxFlush, (RxContext) );
            break;

        case RDBSS_NTC_SPOOLFILE:

            RxDbgTrace(0, Dbg, ("Flush Sppol File\n", 0));

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );

            if (Status != STATUS_SUCCESS) break;

            FcbAcquired = TRUE;

            MINIRDR_CALL( Status, RxContext, Fcb->MRxDispatch, MRxFlush, (RxContext) );
            break;

        default:

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }


    } finally {

        DebugUnwind( RxCommonFlushBuffers );

        if (FcbAcquired) { 
            RxReleaseFcb( RxContext, Fcb ); 
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCommonFlushBuffers -> %08lx\n", Status));
    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntdspvec.h ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    NtDspVec.h

Abstract:

    This module declares the routines used to initialize a dispatch vector. this includefile is
    essentially private for NT version of the fsd and fspdispatch.

Author:

    Joe Linn     [JoeLinn]    2-Aug-94

Revision History:

--*/

#ifndef _DISPVEC_
#define _DISPVEC_


//
//  Global structures used to dispatch to the actual routines. By having
//  a common dispatch we are able to consolidate handling of stuff like
//  dispatching to a stack overflow thread, irpcontext getting, logging, etc.
//  We may decide later that we
//  would rather save the few cycles that this takes. Eventually, all the FCBs will
//  have pointers to optimized dispatch tables.
//

typedef struct _RX_FSD_DISPATCH_VECTOR{
    PRX_DISPATCH CommonRoutine;
    ULONG StackRequirement;
} RX_FSD_DISPATCH_VECTOR, *PRX_FSD_DISPATCH_VECTOR;

extern RX_FSD_DISPATCH_VECTOR RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION + 1];
extern RX_FSD_DISPATCH_VECTOR RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION + 1];


#define DISPVECENTRY_SELECT_1(x) RxCommon##x
#define DISPVECENTRY_SELECT_0(x) RxCommonDispatchProblem
#define DISPVECENTRY_SELECT(x,y) DISPVECENTRY_SELECT_##x(y)
#define DISPVECENTRY_NEW(IRPSUFFIX,IMPL,VEC,STACKREQ) \
     {DISPVECENTRY_SELECT(IMPL,VEC),STACKREQ}

#if (IRP_MJ_CREATE != 0x00)
#error IRP_MJ_CREATE has changed!!!
#endif
#if (IRP_MJ_CREATE_NAMED_PIPE != 0x01)
#error IRP_MJ_CREATE_NAMED_PIPE has changed!!!
#endif
#if (IRP_MJ_CLOSE != 0x02)
#error IRP_MJ_CLOSE has changed!!!
#endif
#if (IRP_MJ_READ != 0x03)
#error IRP_MJ_READ has changed!!!
#endif
#if (IRP_MJ_WRITE != 0x04)
#error IRP_MJ_WRITE has changed!!!
#endif
#if (IRP_MJ_QUERY_INFORMATION != 0x05)
#error IRP_MJ_QUERY_INFORMATION has changed!!!
#endif
#if (IRP_MJ_SET_INFORMATION != 0x06)
#error IRP_MJ_SET_INFORMATION has changed!!!
#endif
#if (IRP_MJ_QUERY_EA != 0x07)
#error IRP_MJ_QUERY_EA has changed!!!
#endif
#if (IRP_MJ_SET_EA != 0x08)
#error IRP_MJ_SET_EA has changed!!!
#endif
#if (IRP_MJ_FLUSH_BUFFERS != 0x09)
#error IRP_MJ_FLUSH_BUFFERS has changed!!!
#endif
#if (IRP_MJ_QUERY_VOLUME_INFORMATION != 0x0a)
#error IRP_MJ_QUERY_VOLUME_INFORMATION has changed!!!
#endif
#if (IRP_MJ_SET_VOLUME_INFORMATION != 0x0b)
#error IRP_MJ_SET_VOLUME_INFORMATION has changed!!!
#endif
#if (IRP_MJ_DIRECTORY_CONTROL != 0x0c)
#error IRP_MJ_DIRECTORY_CONTROL has changed!!!
#endif
#if (IRP_MJ_FILE_SYSTEM_CONTROL != 0x0d)
#error IRP_MJ_FILE_SYSTEM_CONTROL has changed!!!
#endif
#if (IRP_MJ_DEVICE_CONTROL != 0x0e)
#error IRP_MJ_DEVICE_CONTROL has changed!!!
#endif
#if (IRP_MJ_INTERNAL_DEVICE_CONTROL != 0x0f)
#error IRP_MJ_INTERNAL_DEVICE_CONTROL has changed!!!
#endif
#if (IRP_MJ_SHUTDOWN != 0x10)
#error IRP_MJ_SHUTDOWN has changed!!!
#endif
#if (IRP_MJ_LOCK_CONTROL != 0x11)
#error IRP_MJ_LOCK_CONTROL has changed!!!
#endif
#if (IRP_MJ_CLEANUP != 0x12)
#error IRP_MJ_CLEANUP has changed!!!
#endif
#if (IRP_MJ_CREATE_MAILSLOT != 0x13)
#error IRP_MJ_CREATE_MAILSLOT has changed!!!
#endif
#if (IRP_MJ_QUERY_SECURITY != 0x14)
#error IRP_MJ_QUERY_SECURITY has changed!!!
#endif
#if (IRP_MJ_SET_SECURITY != 0x15)
#error IRP_MJ_SET_SECURITY has changed!!!
#endif
#if (IRP_MJ_POWER != 0x16)
#error IRP_MJ_POWER has changed!!!
#endif
#if (IRP_MJ_SYSTEM_CONTROL != 0x17)
#error IRP_MJ_SYSTEM_CONTROL has changed!!!
#endif
#if (IRP_MJ_DEVICE_CHANGE != 0x18)
#error IRP_MJ_DEVICE_CHANGE has changed!!!
#endif
#if (IRP_MJ_QUERY_QUOTA != 0x19)
#error IRP_MJ_QUERY_QUOTA has changed!!!
#endif
#if (IRP_MJ_SET_QUOTA != 0x1a)
#error IRP_MJ_SET_QUOTA has changed!!!
#endif
#if (IRP_MJ_PNP != 0x1b)
#error IRP_MJ_PNP has changed!!!
#endif
#if (IRP_MJ_PNP_POWER != IRP_MJ_PNP)
#error IRP_MJ_PNP_POWER has changed!!!
#endif
#if (IRP_MJ_MAXIMUM_FUNCTION != 0x1b)
#error IRP_MJ_MAXIMUM_FUNCTION has changed!!!
#endif

#endif // _DISPVEC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntfastio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtFastIo.c

Abstract:

    This module implements NT fastio routines.

Author:

    Joe Linn     [JoeLinn]    9-Nov-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_NTFASTIO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxFastIoRead)
#pragma alloc_text(PAGE, RxFastIoWrite)
#pragma alloc_text(PAGE, RxFastIoCheckIfPossible)
#endif


//
//  these declarations would be copied to fsrtl.h
//

BOOLEAN
FsRtlCopyRead2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    );
BOOLEAN
FsRtlCopyWrite2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    );

BOOLEAN
RxFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    
    Basic fastio read routine for the rdr

Arguments:

    FileObject -
    
    FileOffset -
    
    Length -
    
    Wait - 
    
    LockKey -
    
    Buffer -
    
    IoStatus -
    
    DeviceObject -

Return value:

    TRUE if successful


Notes:

--*/

{
    BOOLEAN ReturnValue;

    RX_TOPLEVELIRP_CONTEXT TopLevelContext;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxFastIoRead\n") );

    RxLog(( "FastRead %lx:%lx:%lx", FileObject, FileObject->FsContext, FileObject->FsContext2 ));
    RxLog(( "------>> %lx@%lx %lx", Length, FileOffset->LowPart, FileOffset->HighPart ));
    RxWmiLog( LOG,
              RxFastIoRead_1,
              LOGPTR( FileObject )
              LOGPTR( FileObject->FsContext )
              LOGPTR( FileObject->FsContext2 )
              LOGULONG( Length )
              LOGULONG( FileOffset->LowPart )
              LOGULONG( FileOffset->HighPart ) );

    ASSERT( RxIsThisTheTopLevelIrp( NULL ) );

    RxInitializeTopLevelIrpContext( &TopLevelContext,
                                    ((PIRP)FSRTL_FAST_IO_TOP_LEVEL_IRP),
                                    (PRDBSS_DEVICE_OBJECT)DeviceObject );

    ReturnValue =  FsRtlCopyRead2( FileObject,
                                   FileOffset,
                                   Length,
                                   Wait,
                                   LockKey,
                                   Buffer,
                                   IoStatus,
                                   DeviceObject,
                                   (ULONG_PTR)(&TopLevelContext) );

    RxDbgTrace( -1, Dbg, ("RxFastIoRead ReturnValue=%x\n", ReturnValue) );

    if (ReturnValue) {
        
        RxLog(( "FastReadYes %lx ret %lx:%lx", FileObject->FsContext2, IoStatus->Status, IoStatus->Information ));
        RxWmiLog( LOG,
                  RxFastIoRead_2,
                  LOGPTR( FileObject->FsContext2 )
                  LOGULONG( IoStatus->Status )
                  LOGPTR( IoStatus->Information ) );
    } else {
        
        RxLog(( "FastReadNo %lx", FileObject->FsContext2 ));
        RxWmiLog( LOG,
                  RxFastIoRead_3,
                  LOGPTR( FileObject->FsContext2 ) );
    }

    return ReturnValue;
}

BOOLEAN
RxFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:


Arguments:

Routine Description:
    
    Basic fastio write routine for the rdr

Arguments:

    FileObject -
    
    FileOffset -
    
    Length -
    
    Wait - 
    
    LockKey -
    
    Buffer -
    
    IoStatus -
    
    DeviceObject -

Return value:

    TRUE if successful
    
--*/
{
    BOOLEAN ReturnValue;

    RX_TOPLEVELIRP_CONTEXT TopLevelContext;

    PSRV_OPEN SrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastIoWrite\n"));

    SrvOpen = ((PFOBX)(FileObject->FsContext2))->SrvOpen;
    
    if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHING )) {

        //
        //  if this flag is set, we have to treat this as an unbuffered Io....sigh.
        //

        RxDbgTrace( -1, Dbg, ("RxFastIoWrite DONTUSE_WRITE_CACHEING...failing\n") );
        return FALSE;
    }

    ASSERT( RxIsThisTheTopLevelIrp( NULL ) );

    RxInitializeTopLevelIrpContext( &TopLevelContext,
                                    ((PIRP)FSRTL_FAST_IO_TOP_LEVEL_IRP),
                                    (PRDBSS_DEVICE_OBJECT)DeviceObject );

    ReturnValue = FsRtlCopyWrite2( FileObject,
                                   FileOffset,
                                   Length,
                                   Wait,
                                   LockKey,
                                   Buffer,
                                   IoStatus,
                                   DeviceObject,
                                   (ULONG_PTR)(&TopLevelContext) );

    RxDbgTrace( -1, Dbg, ("RxFastIoWrite ReturnValue=%x\n", ReturnValue) );

    if (ReturnValue) {
        RxLog(( "FWY %lx OLP: %lx SLP: %lx IOSB %lx:%lx", FileObject->FsContext2, FileOffset->LowPart, SrvOpen->Fcb->Header.FileSize.LowPart, IoStatus->Status, IoStatus->Information ));
        RxWmiLog( LOG,
                  RxFastIoWrite_1, 
                  LOGPTR( FileObject->FsContext2 )
                  LOGULONG( FileOffset->LowPart )
                  LOGULONG( SrvOpen->Fcb->Header.FileSize.LowPart )
                  LOGULONG( IoStatus->Status )
                  LOGPTR( IoStatus->Information ) );
    } else {
        
        RxLog(( "FastWriteNo %lx", FileObject->FsContext2 ));
        RxWmiLog( LOG,
                  RxFastIoWrite_2,
                  LOGPTR( FileObject->FsContext2 ) );
    }

    return ReturnValue;
}



BOOLEAN
RxFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PFCB Fcb;
    PFOBX Fobx;
    PSRV_OPEN SrvOpen;
    PCHAR FailureReason = NULL;

    LARGE_INTEGER LargeLength;

    PAGED_CODE();

    RxDecodeFileObject( FileObject, &Fcb, &Fobx ); 
    SrvOpen = Fobx->SrvOpen;

    if (NodeType( Fcb ) != RDBSS_NTC_STORAGE_TYPE_FILE) {
        FailureReason = "notfile";
    } else if (FileObject->DeletePending) {
        FailureReason = "delpend";
    } else if (Fcb->NonPaged->OutstandingAsyncWrites != 0) {
        FailureReason = "asynW";
    } else if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_ORPHANED )) {
        FailureReason = "srvopen orphaned";
    } else if (FlagOn( Fcb->FcbState, FCB_STATE_ORPHANED )) {
        FailureReason = "orphaned";
    } else if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING )) {
        FailureReason = "buf state change";
    } else if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_FILE_RENAMED | SRVOPEN_FLAG_FILE_DELETED)) {
        FailureReason = "ren/del";
    } else {

        //
        //  Ensure that all pending buffering state change requests are processed
        //  before letting the operation through.
        //
    
        FsRtlEnterFileSystem();
        RxProcessChangeBufferingStateRequestsForSrvOpen( SrvOpen );
        FsRtlExitFileSystem();
    
        LargeLength.QuadPart = Length;
    
        //
        //  Based on whether this is a read or write operation we call
        //  fsrtl check for read/write
        //
    
        if (CheckForReadOperation) {
            
            if (!FlagOn( Fcb->FcbState, FCB_STATE_READCACHING_ENABLED )) {
                FailureReason = "notreadC";
            } else if (!FsRtlFastCheckLockForRead( &Fcb->FileLock,
                                                    FileOffset,
                                                    &LargeLength,
                                                    LockKey,
                                                    FileObject,
                                                    PsGetCurrentProcess() )) {
        
                FailureReason = "readlock";
            }
        } else {
    
            if (!FlagOn( Fcb->FcbState,FCB_STATE_WRITECACHING_ENABLED )) {
                FailureReason = "notwriteC";
            } else  if (!FsRtlFastCheckLockForWrite( &Fcb->FileLock,
                                                     FileOffset,
                                                     &LargeLength,
                                                     LockKey,
                                                     FileObject,
                                                     PsGetCurrentProcess() )) {
    
                FailureReason = "writelock";
            }
        }
    }

    if (FailureReason) {
        
        RxLog(( "CheckFast fail %lx %s", FileObject, FailureReason )); 
        RxWmiLog( LOG,                                  
                  RxFastIoCheckIfPossible,              
                  LOGPTR( FileObject )                  
                  LOGARSTR( FailureReason ) );                         
        return FALSE;
    
    } else {
        return TRUE;
    }
    
}

BOOLEAN
RxFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is for the fast device control call.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    InputBuffer - Supplies the input buffer

    InputBufferLength - the length of the input buffer

    OutputBuffer - the output buffer

    OutputBufferLength - the length of the output buffer

    IoControlCode - the IO control code

    IoStatus - Receives the final status of the operation

    DeviceObject - the associated device object

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

Notes:

    The following IO control requests are handled in the first path

    IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER

        InputBuffer - pointer to the other file object

        InputBufferLength - length in bytes of a pointer.

        OutputBuffer - not used

        OutputBufferLength - not used

        IoStatus --

            IoStatus.Status set to STATUS_SUCCESS if both the file objects are
            on the same server, otherwise set to STATUS_NOT_SAME_DEVICE

    This is a kernel mode interface only.

--*/
{
    PFCB Fcb;
    BOOLEAN FastIoSucceeded;

    switch (IoControlCode) {
    
    case IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER:
        
        FastIoSucceeded = TRUE;

        try {
            if (InputBufferLength == sizeof( HANDLE )) {
                
                PFCB Fcb2;
                HANDLE File;
                PFILE_OBJECT FileObject2;
                NTSTATUS Status;    

                Fcb = (PFCB)FileObject->FsContext;

                RtlCopyMemory( &File, InputBuffer, sizeof( HANDLE ) );

                Status = ObReferenceObjectByHandle( File,
                                                    FILE_ANY_ACCESS,
                                                    *IoFileObjectType,
                                                    UserMode,
                                                    &FileObject2,
                                                    NULL );

                if ((Status == STATUS_SUCCESS)) {
                    if(FileObject2->DeviceObject == DeviceObject) {
                    
                        Fcb2 = (PFCB)FileObject2->FsContext;

                        if ((Fcb2 != NULL) &&
                            (NodeTypeIsFcb( Fcb2 ))) {

                            if (Fcb->NetRoot->SrvCall == Fcb2->NetRoot->SrvCall) {
                                IoStatus->Status = STATUS_SUCCESS;
                            } else {
                                IoStatus->Status = STATUS_NOT_SAME_DEVICE;
                            }
                        } else {
                            Status = STATUS_INVALID_PARAMETER;
                        }
                    } else {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                    ObDereferenceObject( FileObject2 );
                
                } else {
                    IoStatus->Status = STATUS_INVALID_PARAMETER;
                }
            } else {
                IoStatus->Status = STATUS_INVALID_PARAMETER;
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
                        
            //
            //  The I/O request was not handled successfully, abort the I/O request with
            //  the error status that we get back from the execption code
            //

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            FastIoSucceeded = TRUE;
        }
        
        break;

    case IOCTL_LMR_LWIO_PREIO:
    
        //
        //  This call allows the lwio user mode caller to preserve the wait IO model for
        //  callers that use the file handle as a synch object. Before each IO, the file
        //  object event must be cleared and after each IO the event must be set as per
        //  the IO manager semantics.
        //
    
        IoStatus->Status = STATUS_NOT_SUPPORTED;
    
        IoStatus->Information = 0;
        if (!FlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO )) {
            
            Fcb = (PFCB)FileObject->FsContext;
            try {
    
                if ((Fcb != NULL) && 
                    (NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_FILE) &&
                    ((FileObject->SectionObjectPointer == NULL) ||
                     (FileObject->SectionObjectPointer->DataSectionObject == NULL))) {
        
                    KeClearEvent( &FileObject->Event );
                    IoStatus->Status = STATUS_SUCCESS;
                    IoStatus->Information = (ULONG_PTR) FileObject->LockOperation;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                IoStatus->Status = GetExceptionCode();
            }
        }
        FastIoSucceeded = TRUE;
        break;

    case IOCTL_LMR_LWIO_POSTIO:
        
        //
        //  This call allows the lwio user mode caller to complete the user mode IO for
        //  a given file handle. The caller specifies an IoStatus block that contains the
        //  user mode IO outcome.
        //
        
        IoStatus->Status = STATUS_NOT_SUPPORTED;
        IoStatus->Information = 0;
        if (!FlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO ) &&
            (InputBuffer != NULL) && 
            (InputBufferLength == sizeof( *IoStatus ))) {
            
            PIO_STATUS_BLOCK Iosb = (PIO_STATUS_BLOCK)InputBuffer;

            Fcb = (PFCB)FileObject->FsContext;
    
            try {
                
                if ((Fcb != NULL) && 
                    NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_FILE &&
                    ((FileObject->SectionObjectPointer == NULL) ||
                     (FileObject->SectionObjectPointer->DataSectionObject == NULL))) {
        
                    KeSetEvent( &FileObject->Event, 0, FALSE );
        
                    IoStatus->Status = Iosb->Status;
                    IoStatus->Information = Iosb->Information;
                }
        
                } except(EXCEPTION_EXECUTE_HANDLER) {
                IoStatus->Status = GetExceptionCode();
                IoStatus->Information = 0;
            }
        }
        FastIoSucceeded = TRUE;
        break;

    default:
        {
            
            Fcb = (PFCB)FileObject->FsContext;
            FastIoSucceeded = FALSE;

            //
            //  Inform lwio rdr of this call
            //
            
            if ((Fcb != NULL) && 
                NodeTypeIsFcb( Fcb ) &&
                FlagOn( Fcb->FcbState, FCB_STATE_LWIO_ENABLED )) {
            
                PFAST_IO_DISPATCH FastIoDispatch = Fcb->MRxFastIoDispatch;
            
                if (FastIoDispatch &&
                    FastIoDispatch->FastIoDeviceControl &&
                    FastIoDispatch->FastIoDeviceControl( FileObject,
                                                         Wait,
                                                         InputBuffer,
                                                         InputBufferLength,
                                                         OutputBuffer,
                                                         OutputBufferLength,
                                                         IoControlCode,
                                                         IoStatus,
                                                         DeviceObject )) {
                        FastIoSucceeded = TRUE;
                }
            }
        }
    }

    return FastIoSucceeded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\nterrlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the rdbss.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

    Joe Linn (joelinn)       23-feb-95  Convert for rdbss

--*/

#include "precomp.h"
#pragma hdrstop
#include <align.h>
#include <netevent.h>

//
//  The local debug trace level
//

#define MIN(__a,__b) (((__a)<=(__b))?(__a):(__b))

static UNICODE_STRING unknownId = { 6, 6, L"???" };

LONG LDWCount = 0;
NTSTATUS LDWLastStatus;
LARGE_INTEGER LDWLastTime;
PVOID LDWContext;

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG Id,
    IN NTSTATUS NtStatus,
    IN PVOID RawDataBuffer,
    IN USHORT RawDataLength,
    IN PUNICODE_STRING Annotations,
    IN ULONG AnnotationCount
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.
    
Arguments:

    DeviceObject - device object to log error against
    
    Id - ErrorCode Id (This is different than an ntstatus and must be defined in ntiolog.h
    
    NtStatus - The ntstatus for the failure
    
    RawDataBuffer -
    
    RadDataLength -
    
    Annotations - Strings to add to the record
    
    AnnotationCount - How many strings
    
--*/
{
    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    ULONG AnnotationStringLength = 0;
    ULONG i;
    PWCHAR Buffer;
    USHORT PaddedRawDataLength = 0;
    ULONG TotalLength = 0;

    //
    //  Calculate length of trailing strings
    //  

    for ( i = 0; i < AnnotationCount ; i++ ) {
        AnnotationStringLength += (Annotations[i].Length + sizeof( WCHAR ));
    }

    //
    //  pad the raw data buffer so that the insertion string starts
    //  on an even address.
    //

    if (ARGUMENT_PRESENT( RawDataBuffer )) {
        PaddedRawDataLength = (RawDataLength + 1) & ~1;
    }

    TotalLength = ( sizeof(IO_ERROR_LOG_PACKET) + PaddedRawDataLength + AnnotationStringLength );

    //
    // If the value of TotalLength is > than 255 then when we cast it to UCHAR
    // below, we get an incorrect smaller number which can cause a buffer over
    // run below. MAX_UCHAR == 255.
    //
    if (TotalLength > 255) {
        return;
    }

    //
    //  Note: error log entry size is pretty small 256 so truncation is a real possibility
    //  

    ErrorLogEntry = IoAllocateErrorLogEntry( (PDEVICE_OBJECT)DeviceObject,
                                             (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + PaddedRawDataLength + AnnotationStringLength) );

    if (ErrorLogEntry != NULL) {

        //
        //  Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = Id;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatus;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.QuadPart = 0;
        ErrorLogEntry->DumpDataSize = RawDataLength;
        ErrorLogEntry->StringOffset = (USHORT)(FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData ) + PaddedRawDataLength);
        ErrorLogEntry->NumberOfStrings = (USHORT)AnnotationCount;

        ErrorLogEntry->SequenceNumber = 0;

        //
        //  Append the extra information.
        //
        
        if (ARGUMENT_PRESENT( RawDataBuffer )) {

            RtlCopyMemory( ErrorLogEntry->DumpData, RawDataBuffer, RawDataLength );
        }

        Buffer = (PWCHAR)Add2Ptr(ErrorLogEntry->DumpData, PaddedRawDataLength );

        for ( i = 0; i < AnnotationCount ; i++ ) {

            RtlCopyMemory( Buffer, Annotations[i].Buffer, Annotations[i].Length );

            Buffer += (Annotations[i].Length / 2);
            *Buffer++ = L'\0';
        }

        //
        //  Write the entry
        //

        IoWriteErrorLogEntry( ErrorLogEntry );

    }

    return;
}


VOID
RxLogEventWithBufferDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN PVOID                DataBuffer,
    IN USHORT               DataBufferLength,
    IN ULONG                LineNumber
    )
/*++

Routine Description:

    Wrapper for RxLogEventWithAnnotation. We encode the line number and status into the raw data buffer
    
Arguments:

    DeviceObject - device object to log error against
    
    OriginatorId - string of caller generating error
    
    EventId - ErrorCode Id (This is different than an ntstatus and must be defined in ntiolog.h
    
    Status - The ntstatus for the failure
    
    DataBuffer -
    
    DataLength -
    
    LineNumber - line number where event was generated
    
    
--*/
{
    ULONG LocalBuffer[ 20 ];

    if (!ARGUMENT_PRESENT( OriginatorId ) || (OriginatorId->Length == 0)) {
        OriginatorId = &unknownId;
    }

    LocalBuffer[0] = Status;
    LocalBuffer[1] = LineNumber;

    //
    //  Truncate databuffer if necc.
    //

    RtlCopyMemory( &LocalBuffer[2], DataBuffer, MIN( DataBufferLength, sizeof( LocalBuffer ) - 2 * sizeof( LocalBuffer[0] ) ) );

    RxLogEventWithAnnotation( DeviceObject,
                              EventId,
                              Status,
                              LocalBuffer,
                              (USHORT)MIN( DataBufferLength + sizeof( LocalBuffer[0] ), sizeof( LocalBuffer ) ),
                              OriginatorId,
                              1 );

}


VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN ULONG                Line
    )
/*++

Routine Description:

    This function logs an error.  You should use the 'RdrLogFailure'
      macro instead of calling this routine directly.

Arguments:
    Status is the status code showing the failure

    Line is where it happened

Return Value:

    None.

--*/
{
    ULONG LineAndStatus[2];

    LineAndStatus[0] = Line;
    LineAndStatus[1] = Status;

    if( !ARGUMENT_PRESENT( OriginatorId ) || OriginatorId->Length == 0 ) {
        OriginatorId = &unknownId;
    }

    RxLogEventWithAnnotation(
        DeviceObject,
        EventId,
        Status,
        &LineAndStatus,
        sizeof(LineAndStatus),
        OriginatorId,
        1
        );

}

BOOLEAN
RxCcLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine writes an eventlog entry to the eventlog.

Arguments:

    DeviceObject - The device object who owns the file where it occurred.

    FileName - The filename to use in logging the error (usually the DOS-side name)

    Error - The error to log in the eventlog record

    DeviceError - The actual error that occured in the device - will be logged
                  as user data

Return Value:

    True if successful, false if internal memory allocation failed

--*/

{
    UCHAR ErrorPacketLength;
    UCHAR BasePacketLength;
    ULONG StringLength;
    PIO_ERROR_LOG_PACKET ErrorLogEntry = NULL;
    BOOLEAN Result = FALSE;
    PWCHAR String;

    PAGED_CODE();

    //
    //  Get our error packet, holding the string and status code.  Note we log against the
    //  true filesystem if this is available.
    //
    //  The sizing of the packet is a bit slimy since the dumpdata is already grown by a
    //  ULONG onto the end of the packet.  Since NTSTATUS is ULONG, well, we just work in
    //  place.
    //

    BasePacketLength = sizeof( IO_ERROR_LOG_PACKET );
    if ((BasePacketLength + FileName->Length + sizeof( WCHAR )) <= ERROR_LOG_MAXIMUM_SIZE) {
        ErrorPacketLength = (UCHAR)(BasePacketLength + FileName->Length + sizeof( WCHAR ));
    } else {
        ErrorPacketLength = ERROR_LOG_MAXIMUM_SIZE;
    }

    //
    //  Generate the lost delayed write popup if necc.
    //  

    if (Error == IO_LOST_DELAYED_WRITE) {
        
        IoRaiseInformationalHardError( STATUS_LOST_WRITEBEHIND_DATA, FileName, NULL );

        //
        //  Increment the CC counter here!
        //

        InterlockedIncrement( &LDWCount );
        KeQuerySystemTime( &LDWLastTime );
        LDWLastStatus = DeviceError;
        LDWContext = Context;
    }

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( DeviceObject,
                                                                    ErrorPacketLength );
    if (ErrorLogEntry) {

        //
        //  Fill in the nonzero members of the packet.
        //

        ErrorLogEntry->MajorFunctionCode = IrpMajorCode;
        ErrorLogEntry->ErrorCode = Error;
        ErrorLogEntry->FinalStatus = DeviceError;

        ErrorLogEntry->DumpDataSize = sizeof(NTSTATUS);
        RtlCopyMemory( &ErrorLogEntry->DumpData, &DeviceError, sizeof( NTSTATUS ) );

        //
        //  The filename string is appended to the end of the error log entry. We may
        //  have to smash the middle to fit it in the limited space.
        //

        StringLength = ErrorPacketLength - BasePacketLength - sizeof( WCHAR );

        ASSERT(!(StringLength % sizeof( WCHAR )));

        String = (PWCHAR)Add2Ptr( ErrorLogEntry, BasePacketLength );
        ErrorLogEntry->NumberOfStrings = 1;
        ErrorLogEntry->StringOffset = BasePacketLength;

        //
        //  If the name does not fit in the packet, divide the name equally to the
        //  prefix and suffix, with an ellipsis " .. " (4 wide characters) to indicate
        //  the loss.
        //

        if (StringLength < FileName->Length) {

            //
            //  Remember, prefix + " .. " + suffix is the length.  Calculate by figuring
            //  the prefix and then get the suffix by whacking the ellipsis and prefix off
            //  the total.
            //

            ULONG NamePrefixSegmentLength = ((StringLength / sizeof( WCHAR ))/2 - 2) * sizeof( WCHAR );
            ULONG NameSuffixSegmentLength = StringLength - 4*sizeof( WCHAR ) - NamePrefixSegmentLength;

            ASSERT(!(NamePrefixSegmentLength % sizeof( WCHAR )));
            ASSERT(!(NameSuffixSegmentLength % sizeof( WCHAR )));

            RtlCopyMemory( String, FileName->Buffer, NamePrefixSegmentLength );
            String = (PWCHAR)Add2Ptr( String, NamePrefixSegmentLength );

            RtlCopyMemory( String,
                           L" .. ",
                           4 * sizeof( WCHAR ) );
            String += 4;

            RtlCopyMemory( String,
                           Add2Ptr( FileName->Buffer, FileName->Length - NameSuffixSegmentLength ),
                           NameSuffixSegmentLength );
            String = (PWCHAR)Add2Ptr( String, NameSuffixSegmentLength );

        } else {

            RtlCopyMemory( String,
                           FileName->Buffer,
                           FileName->Length );
            String += FileName->Length/sizeof(WCHAR);
        }

        //
        //  Null terminate the string and send the packet.
        //

        *String = L'\0';

        IoWriteErrorLogEntry( ErrorLogEntry );
        Result = TRUE;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntfsp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the RDBSS Fsp

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "NtDspVec.h"
#include <ntddnfs2.h>
#include <ntddmup.h>

//
//  Define our local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSP_DISPATCHER)

#ifndef MONOLITHIC_MINIRDR
PIO_WORKITEM RxIoWorkItem;
#endif

//
//  Internal support routine, spinlock wrapper.
//

PRX_CONTEXT
RxRemoveOverflowEntry (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN WORK_QUEUE_TYPE Type
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxFspDispatch)
#endif

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                     ////       1 2 3 4 5 6 7
char RxFsp_SurrogateFormat[] = "%S%S%N%N%N%N%N";
                             ////   2  3   4         5        6   7
char RxFsp_ActualFormat[]    = "Fsp %s/%lx %08lx irp %lx thrd %lx #%lx";

#endif //ifdef RDBSSLOG

#ifndef MONOLITHIC_MINIRDR

VOID
RxFspDispatchEx (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine calls RxFspDispatch which is the main FSP thread routine that
    is executed to receive and dispatch IRP requests.

Arguments:

    Context - The RxContext being queued to the FSP.

Notes:

    None.

--*/
{
    RxFspDispatch( Context );
    return;
}

#endif

VOID
RxFspDispatch (
    IN PVOID Context
    )
/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:

    Context - The RxContext being queued to the FSP.

Notes:

    This routine never exits

--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;
    RX_TOPLEVELIRP_CONTEXT TopLevelContext;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    WORK_QUEUE_TYPE WorkQueueType;
    DWORD CurrentIrql;

    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PAGED_CODE();

    CurrentIrql = KeGetCurrentIrql();


    //
    //  If this request has an associated volume device object, remember it.
    //

    if (FileObject != NULL ) {

        RxDeviceObject = CONTAINING_RECORD( IrpSp->DeviceObject, RDBSS_DEVICE_OBJECT, DeviceObject );

        //
        //  currently, we use the wrapper's device object for all throttling.....
        //

        RxDeviceObject = RxFileSystemDeviceObject;

    } else {

        RxDeviceObject = NULL;
    }

    if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE )) {
        WorkQueueType = DelayedWorkQueue;
    } else if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE )) {
        WorkQueueType = CriticalWorkQueue;
    } else {
        ASSERT(!"Valid RXCONTEXT Work Queue Type");
    }

    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble.
    //

    while (TRUE) {

        //
        //   Grab the current irp
        //  

        Irp = RxContext->CurrentIrp;

        RxDbgTrace( 0, Dbg, ("RxFspDispatch: IrpC = 0x%08lx\n", RxContext) );
        
        ASSERT( RxContext->MajorFunction <= IRP_MJ_MAXIMUM_FUNCTION );
        ASSERT( RxContext->PostRequest == FALSE );

        RxContext->LastExecutionThread = PsGetCurrentThread();

        RxLog(( RxFsp_SurrogateFormat, RxFsp_ActualFormat, RXCONTX_OPERATION_NAME( RxContext->MajorFunction, TRUE ), RxContext->MinorFunction, RxContext, Irp, RxContext->LastExecutionThread, RxContext->SerialNumber ));
        RxWmiLog( LOG,
                  RxFspDispatch,
                  LOGPTR( RxContext)
                  LOGPTR( Irp )
                  LOGPTR( RxContext->LastExecutionThread)
                  LOGULONG( RxContext->SerialNumber)
                  LOGUCHAR( RxContext->MinorFunction)
                  LOGARSTR( RXCONTX_OPERATION_NAME( RxContext->MajorFunction, TRUE ) ) );

        //
        //  Now because we are the Fsp we will force the RxContext to
        //  indicate true on Wait.
        //

        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT | RX_CONTEXT_FLAG_IN_FSP );

        //
        //  If this Irp was top level, note it in our thread local storage.
        //

        FsRtlEnterFileSystem();

        if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_RECURSIVE_CALL )) {
            
            RxTryToBecomeTheTopLevelIrp( &TopLevelContext,
                                         (PIRP)FSRTL_FSP_TOP_LEVEL_IRP,
                                         RxContext->RxDeviceObject,
                                         TRUE ); //  force
        } else {
            
            RxTryToBecomeTheTopLevelIrp( &TopLevelContext,
                                         Irp,
                                         RxContext->RxDeviceObject,
                                         TRUE ); //  force
        }

        try {

            ASSERT( RxContext->ResumeRoutine != NULL );

            if (FlagOn( RxContext->MinorFunction, IRP_MN_DPC ) && (Irp->Tail.Overlay.Thread == NULL)) {

                ASSERT( (RxContext->MajorFunction == IRP_MJ_WRITE) ||
                        (RxContext->MajorFunction == IRP_MJ_READ) );

                Irp->Tail.Overlay.Thread = PsGetCurrentThread();
            }

            do {
                
                BOOLEAN NoCompletion = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_COMPLETE_FROM_FSP );

                Status = RxContext->ResumeRoutine( RxContext, Irp );

                if (NoCompletion) {
                    NOTHING;
                } else if ((Status != STATUS_PENDING) && (Status != STATUS_RETRY)) {
                        
                    Status = RxCompleteRequest( RxContext, Status );
                }
            } while (Status == STATUS_RETRY);

        } except( RxExceptionFilter( RxContext, GetExceptionInformation() )) {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error status that we get back from the
            //  execption code.
            //

            (VOID) RxProcessException( RxContext, GetExceptionCode() );
        }

        RxUnwindTopLevelIrp( &TopLevelContext );

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (RxDeviceObject != NULL) {

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            RxContext = RxRemoveOverflowEntry( RxDeviceObject,WorkQueueType );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if (RxContext == NULL) {
                break;
            }

            continue;
        } else {
            break;
        }
    }

#ifdef DBG
    if(KeGetCurrentIrql() >= APC_LEVEL) {
        
        DbgPrint( "High Irql RxContext=%x Irql On Entry=%x\n", RxContext, CurrentIrql);
        //  DbgBreakPoint();
    }
#endif

    return;
}

//
//  Internal support routine, spinlock wrapper.
//

PRX_CONTEXT
RxRemoveOverflowEntry (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN WORK_QUEUE_TYPE WorkQueueType)
{
    PRX_CONTEXT RxContext;
    KIRQL SavedIrql;

    KeAcquireSpinLock( &RxDeviceObject->OverflowQueueSpinLock, &SavedIrql );

    if (RxDeviceObject->OverflowQueueCount[WorkQueueType] > 0) {
        
        PVOID Entry;

        //
        //  There is overflow work to do in this volume so we'll
        //  decrement the Overflow count, dequeue the IRP, and release
        //  the Event
        //

        RxDeviceObject->OverflowQueueCount[WorkQueueType] -= 1;

        Entry = RemoveHeadList( &RxDeviceObject->OverflowQueue[WorkQueueType] );

        //
        //  Extract the RxContext, Irp, and IrpSp, and loop.
        //

        RxContext = CONTAINING_RECORD( Entry,
                                       RX_CONTEXT,
                                       OverflowListEntry );

        RxContext->OverflowListEntry.Flink = NULL;

        ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE | RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE );
    
    } else {
        
        RxContext = NULL;
        InterlockedDecrement( &RxDeviceObject->PostedRequestCount[WorkQueueType] );
    }

    KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );

    return RxContext;
}

BOOLEAN
RxCancelOperationInOverflowQueue (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine cancels the operation in the overflow queue

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    BOOLEAN CancelledRequest = FALSE;

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    KIRQL SavedIrql;

    //
    //  currently, we use the wrapper's device object for all throttling.....
    //

    RxDeviceObject = RxFileSystemDeviceObject;

    KeAcquireSpinLock( &RxDeviceObject->OverflowQueueSpinLock, &SavedIrql );

    if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE | RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE) &&
        (RxContext->OverflowListEntry.Flink != NULL)) {
        
        //
        //  Remove the entry from the overflow queue
        //

        RemoveEntryList( &RxContext->OverflowListEntry );
        RxContext->OverflowListEntry.Flink = NULL;

        if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE )) {
            RxDeviceObject->OverflowQueueCount[CriticalWorkQueue] -= 1;
        } else {
            RxDeviceObject->OverflowQueueCount[DelayedWorkQueue] -= 1;
        }

        ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE | RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE );
        CancelledRequest = TRUE;
    }

    KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );

    if (CancelledRequest) {
        
        RxRemoveOperationFromBlockingQueue( RxContext );
        RxCompleteRequest( RxContext, STATUS_CANCELLED );
    }

    return CancelledRequest;
}


//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (1)


VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine performs any neccessary work before RxStatus(PENDING) is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package. The main issue is that we are about
    to leave the user's process so we need to get a systemwide address for
    anything in his address space that we require.

Arguments:

    Context - Pointer to the RxContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT) Context;
    PIO_STACK_LOCATION IrpSp;

    //
    //  If there is no Irp, we are done.
    //

    if (Irp == NULL) {
        return;
    }

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED )) {
         
        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED );

        //
        //  We need to lock the user's buffer, unless this is an MDL-read,
        //  in which case there is no user buffer.
        //
        //  **** we need a better test than non-MDL (read or write)!
        //

        if ((RxContext->MajorFunction == IRP_MJ_READ) || (RxContext->MajorFunction == IRP_MJ_WRITE)) {

            //
            //  If not an Mdl request, lock the user's buffer.
            //

            if (!FlagOn( RxContext->MinorFunction, IRP_MN_MDL )) {

                RxLockUserBuffer( RxContext,
                                  Irp,
                                  (RxContext->MajorFunction == IRP_MJ_READ) ? IoWriteAccess : IoReadAccess,
                                  IrpSp->Parameters.Write.Length );
            }

        //
        //  We also need to check whether this is a query file operation.
        //

        } else if ((RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) && 
                   (RxContext->MinorFunction == IRP_MN_QUERY_DIRECTORY)) {

            RxLockUserBuffer( RxContext,
                              Irp,
                              IoWriteAccess,
                              IrpSp->Parameters.QueryDirectory.Length );

        //
        //  We also need to check whether this is a query ea operation.
        //

        } else if (RxContext->MajorFunction == IRP_MJ_QUERY_EA) {

            RxLockUserBuffer( RxContext,
                              Irp,
                              IoWriteAccess,
                              IrpSp->Parameters.QueryEa.Length );

        //
        //  We also need to check whether this is a set ea operation.
        //

        } else if (RxContext->MajorFunction == IRP_MJ_SET_EA) {

            RxLockUserBuffer( RxContext,
                              Irp,
                              IoReadAccess,
                              IrpSp->Parameters.SetEa.Length );
        }

        //
        //  Mark that we've already returned pending to the user
        //

        IoMarkIrpPending( Irp );
    }

    return;
}

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                     ////           1 2 3 4 5 6 7
char RxFsdPost_SurrogateFormat[] = "%S%S%N%N%N%N%N";
                             ////        2  3   4         5        6    7
char RxFsdPost_ActualFormat[]    = "POST %s/%lx %08lx irp %lx thrd %lx #%lx";

#endif //ifdef RDBSSLOG

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine enqueues the request packet specified by RxContext to the
    Ex Worker threads.  This is a FSD routine.

Arguments:

    RxContext - Pointer to the RxContext to be queued to the Fsp

Return Value:

    RxStatus(PENDING)

--*/
{
    PIRP Irp = RxContext->CurrentIrp;

    if(!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED )) {
        
        RxPrePostIrp( RxContext, Irp );
    }

    RxLog(( RxFsdPost_SurrogateFormat, 
            RxFsdPost_ActualFormat,
            RXCONTX_OPERATION_NAME( RxContext->MajorFunction, TRUE ),
            RxContext->MinorFunction,
            RxContext, 
            RxContext->CurrentIrp,
            RxContext->LastExecutionThread,
            RxContext->SerialNumber ));
    RxWmiLog( LOG,
              RxFsdPostRequest,
              LOGPTR( RxContext )
              LOGPTR( RxContext->CurrentIrp )
              LOGPTR( RxContext->LastExecutionThread )
              LOGULONG( RxContext->SerialNumber )
              LOGUCHAR( RxContext->MinorFunction )
              LOGARSTR( RXCONTX_OPERATION_NAME( RxContext->MajorFunction,TRUE ) ) );

    RxAddToWorkque( RxContext, Irp );

    return STATUS_PENDING;
}



VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    RxContext - Pointer to the RxContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/
{
    KIRQL SavedIrql;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    WORK_QUEUE_TYPE WorkQueueType;
    BOOLEAN PostToWorkerThread = FALSE;
                          
    ULONG IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    //
    //  Send it off.....
    //

    RxContext->PostRequest = FALSE;

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //
    
    if ((RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
        (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH)) {
        WorkQueueType = DelayedWorkQueue;
        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE );
    } else {
        WorkQueueType = CriticalWorkQueue;
        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE );
    }

    if (FileObject != NULL) {
        
        PRDBSS_DEVICE_OBJECT RxDeviceObject;
        LONG RequestCount;

        RxDeviceObject = CONTAINING_RECORD( IrpSp->DeviceObject, RDBSS_DEVICE_OBJECT, DeviceObject );

        //
        // currently, we use the wrapper's device object for all throttling.....
        //

        RxDeviceObject = RxFileSystemDeviceObject;

        //
        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.
        //

        KeAcquireSpinLock( &RxDeviceObject->OverflowQueueSpinLock, &SavedIrql );

        RequestCount = InterlockedIncrement(&RxDeviceObject->PostedRequestCount[WorkQueueType]);

        PostToWorkerThread = (RequestCount > FSP_PER_DEVICE_THRESHOLD);

        if (PostToWorkerThread) {

            //
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.
            //

            InterlockedDecrement( &RxDeviceObject->PostedRequestCount[WorkQueueType] );

            InsertTailList( &RxDeviceObject->OverflowQueue[WorkQueueType],
                            &RxContext->OverflowListEntry );

            RxDeviceObject->OverflowQueueCount[WorkQueueType] += 1;

            KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );

            return;

        } else {

            KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );

        }

    } else {

        PostToWorkerThread = TRUE;

    }

#ifndef MONOLITHIC_MINIRDR

    IoQueueWorkItem( RxIoWorkItem, RxFspDispatchEx, WorkQueueType, RxContext );

#else 

    ExInitializeWorkItem( &RxContext->WorkQueueItem, RxFspDispatch, RxContext );

    ExQueueWorkItem( (PWORK_QUEUE_ITEM)&RxContext->WorkQueueItem, WorkQueueType );

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntexcept.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtExcept.c

Abstract:

    This module declares the exception handlers for the NTwrapper.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "prefix.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_NTEXCEPT)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxProcessException)
#pragma alloc_text(PAGE, RxPopUpFileCorrupt)
#endif

PCONTEXT RxExpCXR;
PEXCEPTION_RECORD RxExpEXR;
PVOID RxExpAddr;
NTSTATUS RxExpCode;


LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It first determines the true exception
    code by examining the exception record. If there is an Irp Context, then it inserts the status
    into the RxContext. Finally, it determines whether to handle the exception or bugcheck
    according to whether the except is one of the expected ones. in actuality, all exceptions are expected
    except for some lowlevel machine errors (see fsrtl\filter.c)

Arguments:

    RxContext    - the irp context of current operation for storing away the code.

    ExceptionPointer - Supplies the exception context.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;

    //
    //  save these values in statics so i can see them on the debugger............
    //

    ExceptionCode = RxExpCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    
    RxExpAddr = ExceptionPointer->ExceptionRecord->ExceptionAddress;
    RxExpEXR  = ExceptionPointer->ExceptionRecord;
    RxExpCXR  = ExceptionPointer->ContextRecord;

    RxLog(( "!!! %lx %lx %lx %lx\n", RxExpCode, RxExpAddr, RxExpEXR, RxExpCXR ));
    RxWmiLog( LOG,
              RxExceptionFilter_1,
              LOGULONG( RxExpCode )
              LOGPTR( RxExpAddr )
              LOGPTR( RxExpEXR )
              LOGPTR( RxExpCXR ) );

    RxDbgTrace( 0, (DEBUG_TRACE_UNWIND), ("RxExceptionFilter %X at %X\n", RxExpCode, RxExpAddr) );
    RxDbgTrace( 0, (DEBUG_TRACE_UNWIND), ("RxExceptionFilter EXR=%X, CXR=%X\n", RxExpEXR, RxExpCXR) );

    if (RxContext == NULL) {

        //
        //  we cannot do anything even moderately sane
        //

        return EXCEPTION_EXECUTE_HANDLER;
    }

    //
    //  If the exception is RxStatus(IN_PAGE_ERROR), get the I/O error code
    //  from the exception record.
    //

    if (ExceptionCode == STATUS_IN_PAGE_ERROR) {
        
        RxLog(( "InPageError...." ));
        RxWmiLog( LOG,
                  RxExceptionFilter_2,
                  LOGPTR( RxContext ) );
        
        if (ExceptionPointer->ExceptionRecord->NumberParameters >= 3) {
            ExceptionCode = (NTSTATUS)ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
        }
    }

    if (RxContext->StoredStatus == 0) {

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {

            RxContext->StoredStatus = ExceptionCode;
            return EXCEPTION_EXECUTE_HANDLER;

        } else {

            RxBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                         (ULONG_PTR)ExceptionPointer->ContextRecord,
                         (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine processes an exception.  It either completes the request
    with the saved exception status or it bugchecks


Arguments:

    RxContext - Context of the current operation

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    RXSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxProcessException\n", 0));

    if (RxContext == NULL) {

        //
        //  we cannot do anything even moderately sane without a context..........sigh
        //

        RxBugCheck( 0,0,0 );  //  this shouldn't happen.
    }

    //
    //  Get the  exception status from RxContext->StoredStatus as stored there by
    //  the exception filter., and
    //  reset it.  Also copy it to the Irp in case it isn't already there
    //

    ExceptionCode = RxContext->StoredStatus;

    if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

        RxBugCheck( 0,0,0 );  //this shouldn't happen. we should have BC'd in the filter
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        RxpPrepareCreateContextForReuse( RxContext );
    }

    Fcb = (PFCB)RxContext->pFcb;
    if (Fcb != NULL) {

        if (RxContext->FcbResourceAcquired) {

            RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingFcb\n"));
            
            RxReleaseFcb( RxContext, Fcb );
            RxContext->FcbResourceAcquired = FALSE;
        }

        if (RxContext->FcbPagingIoResourceAcquired) {
            
            RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingPaginIo\n"));
            RxReleasePagingIoResource( RxContext, Fcb );
        }
    }

    RxCompleteContextAndReturn( ExceptionCode );
}

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    The Following routine makes an informational popup that the file
    is corrupt.

Arguments:

    Fcb - The file that is corrupt.

Return Value:

    None.

--*/

{
    PKTHREAD Thread;
    PIRP Irp = RxContext->CurrentIrp;

    PAGED_CODE();


    //
    //  We never want to block a system thread waiting for the user to
    //  press OK.
    //

    if (IoIsSystemThread( Irp->Tail.Overlay.Thread )) {

       Thread = NULL;

    } else {

       Thread = Irp->Tail.Overlay.Thread;
    }

    IoRaiseInformationalHardError( STATUS_FILE_CORRUPT_ERROR,
                                   &Fcb->FcbTableEntry.Path,  //  &Fcb->FullFileName,
                                   Thread );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntfsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the FSD-level dispatch routine for the RDBSS.

Author:

    Joe Linn [JoeLinn]    2-dec-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs.h>
#include <dfsfsctl.h>
#include "NtDspVec.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DISPATCH)

NTSTATUS
RxCommonUnimplemented ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

VOID
RxInitializeTopLevelIrpPackage (
    VOID
    );


RX_FSD_DISPATCH_VECTOR RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION + 1] = {
    
    {RxCommonCreate, 0x10},                         //  0  IRP_MJ_CREATE 
    {RxCommonUnimplemented, 0x10},                  //  1  IRP_MJ_CREATE_NAME_PIPE
    {RxCommonClose, 0x10},                          //  2  IRP_MJ_CLOSE
    {RxCommonRead, 0x10},                           //  3  IRP_MJ_READ
    {RxCommonWrite, 0x10},                          //  4  IRP_MJ_WRITE
    {RxCommonQueryInformation, 0x10},               //  5  IRP_MJ_QUERY_INFORMATION
    {RxCommonSetInformation, 0x10},                 //  6  IRP_MJ_SET_INFORMATION
    {RxCommonQueryEa, 0x10},                        //  7  IRP_MJ_QUERY_EA
    {RxCommonSetEa, 0x10},                          //  8  IRP_MJ_SET_EA
    {RxCommonFlushBuffers, 0x10},                   //  9  IRP_MJ_FLUSH_BUFFERS
    {RxCommonQueryVolumeInformation, 0x10},         //  10  IRP_MJ_QUERY_VOLUME_INFORMATION
    {RxCommonSetVolumeInformation, 0x10},           //  11  IRP_MJ_SET_VOLUME_INFORMATION
    {RxCommonDirectoryControl, 0x10},               //  12  IRP_MJ_DIRECTORY_CONTROL
    {RxCommonFileSystemControl, 0x10},              //  13  IRP_MJ_FILE_SYSTEM_CONTROL
    {RxCommonDeviceControl, 0x10},                  //  14  IRP_MJ_DEVICE_CONTROL
    {RxCommonDeviceControl, 0x10},                  //  15  IRP_MJ_INTERNAL_DEVICE_CONTROL
    {RxCommonUnimplemented, 0x10},                  //  16  IRP_MJ_SHUTDOWN
    {RxCommonLockControl, 0x10},                    //  17  IRP_MJ_LOCK_CONTROL
    {RxCommonCleanup, 0x10},                        //  18  IRP_MJ_CLEANUP
    {RxCommonUnimplemented, 0x10},                  //  19  IRP_MJ_CREATE_MAILSLOT
    {RxCommonQuerySecurity, 0x10},                  //  20  IRP_MJ_QUERY_SECURITY
    {RxCommonSetSecurity, 0x10},                    //  21  IRP_MJ_SET_SECURITY
    {RxCommonUnimplemented, 0x10},                  //  22  IRP_MJ_POWER
    {RxCommonUnimplemented, 0x10},                  //  23  IRP_MJ_SYSTEM_CONTROL
    {RxCommonUnimplemented, 0x10},                  //  24  IRP_MJ_DEVICE_CHANGE
    {RxCommonQueryQuotaInformation, 0x10},          //  25  IRP_MJ_QUERY_QUOTA_INFORMATION
    {RxCommonSetQuotaInformation, 0x10},            //  26  IRP_MJ_SET_QUOTA_INFORMATION    
    {RxCommonUnimplemented, 0x10}                   //  27  IRP_MJ_PNP

};

RX_FSD_DISPATCH_VECTOR RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION + 1] = {

    {RxCommonUnimplemented, 0x10},                //  0  IRP_MJ_CREATE 
    {RxCommonUnimplemented, 0x10},                //  1  IRP_MJ_CREATE_NAME_PIPE
    {RxCommonDevFCBClose, 0x10},                    //  2  IRP_MJ_CLOSE
    {RxCommonUnimplemented, 0x10},                //  3  IRP_MJ_READ
    {RxCommonUnimplemented, 0x10},                //  4  IRP_MJ_WRITE
    {RxCommonUnimplemented, 0x10},                //  5  IRP_MJ_QUERY_INFORMATION
    {RxCommonUnimplemented, 0x10},                //  6  IRP_MJ_SET_INFORMATION
    {RxCommonUnimplemented, 0x10},                //  7  IRP_MJ_QUERY_EA
    {RxCommonUnimplemented, 0x10},                //  8  IRP_MJ_SET_EA
    {RxCommonUnimplemented, 0x10},                //  9  IRP_MJ_FLUSH_BUFFERS
    {RxCommonDevFCBQueryVolInfo, 0x10},             //  10  IRP_MJ_QUERY_VOLUME_INFORMATION
    {RxCommonUnimplemented, 0x10},                //  11  IRP_MJ_SET_VOLUME_INFORMATION
    {RxCommonUnimplemented, 0x10},                //  12  IRP_MJ_DIRECTORY_CONTROL
    {RxCommonDevFCBFsCtl, 0x10},                    //  13  IRP_MJ_FILE_SYSTEM_CONTROL
    {RxCommonDevFCBIoCtl, 0x10},                    //  14  IRP_MJ_DEVICE_CONTROL
    {RxCommonDevFCBIoCtl, 0x10},                    //  15  IRP_MJ_INTERNAL_DEVICE_CONTROL
    {RxCommonUnimplemented, 0x10},                //  16  IRP_MJ_SHUTDOWN
    {RxCommonUnimplemented, 0x10},                //  17  IRP_MJ_LOCK_CONTROL
    {RxCommonDevFCBCleanup, 0x10},                  //  18  IRP_MJ_CLEANUP
    {RxCommonUnimplemented, 0x10},                //  19  IRP_MJ_CREATE_MAILSLOT
    {RxCommonUnimplemented, 0x10},                //  20  IRP_MJ_QUERY_SECURITY
    {RxCommonUnimplemented, 0x10},                //  21  IRP_MJ_SET_SECURITY
    {RxCommonUnimplemented, 0x10},                  //  22  IRP_MJ_POWER
    {RxCommonUnimplemented, 0x10},                  //  23  IRP_MJ_SYSTEM_CONTROL
    {RxCommonUnimplemented, 0x10},                  //  24  IRP_MJ_DEVICE_CHANGE
    {RxCommonUnimplemented, 0x10},                  //  25  IRP_MJ_QUERY_QUOTA_INFORMATION
    {RxCommonUnimplemented, 0x10},                  //  26  IRP_MJ_SET_QUOTA_INFORMATION
    {RxCommonUnimplemented, 0x10}                   //  27  IRP_MJ_PNP
};

FAST_IO_DISPATCH RxFastIoDispatch;

//
//  To allow NFS to run RDBSS on W2K, we now look up the kenel routine
//  FsRtlTeardownPerStreamContexts dynamically at run time.
//  This is the global variable that contains the function pointer or NULL
//  if the routine could not be found (as on W2K.
//

VOID (*RxTeardownPerStreamContexts)(IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader) = NULL;

NTSTATUS
RxFsdCommonDispatch (
    PRX_FSD_DISPATCH_VECTOR DispatchVector,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxInitializeDispatchVectors (
    OUT PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxInitializeDispatchVectors)
//  not pageable SPINLOCK #pragma alloc_text(PAGE, RxFsdCommonDispatch)
#pragma alloc_text(PAGE, RxCommonUnimplemented)
#pragma alloc_text(PAGE, RxCommonUnimplemented)
#pragma alloc_text(PAGE, RxFsdDispatch)
#pragma alloc_text(PAGE, RxTryToBecomeTheTopLevelIrp)
#endif


VOID
RxInitializeDispatchVectors (
    OUT PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine initializes the dispatch table for the driver object

Arguments:

    DriverObject - Supplies the driver object

--*/
{
    ULONG i;
    UNICODE_STRING funcName;
    PAGED_CODE();

    //
    //  Set the routine address for FsRtlTeardownPerStreamContexts
    //

    RtlInitUnicodeString( &funcName, L"FsRtlTeardownPerStreamContexts" );
    RxTeardownPerStreamContexts = MmGetSystemRoutineAddress( &funcName );

    //
    //  Set IRP dispatch vectors
    //

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)RxFsdDispatch;
    }

    //
    //  Set Dispatch Vector for the DevFCB
    //

    RxDeviceFCB.PrivateDispatchVector = &RxDeviceFCBVector[0];

    ASSERT( RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION].CommonRoutine != NULL );
    ASSERT( RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION].CommonRoutine != NULL );

    //
    //  this is dangerous!!!
    //

    DriverObject->FastIoDispatch = &RxFastIoDispatch;  

    RxFastIoDispatch.SizeOfFastIoDispatch = sizeof(FAST_IO_DISPATCH);
    RxFastIoDispatch.FastIoCheckIfPossible =  RxFastIoCheckIfPossible; 
    RxFastIoDispatch.FastIoRead = RxFastIoRead;              
    RxFastIoDispatch.FastIoWrite = RxFastIoWrite;            
    RxFastIoDispatch.FastIoQueryBasicInfo = NULL; 
    RxFastIoDispatch.FastIoQueryStandardInfo = NULL; 
    RxFastIoDispatch.FastIoLock = NULL; 
    RxFastIoDispatch.FastIoUnlockSingle = NULL; 
    RxFastIoDispatch.FastIoUnlockAll = NULL; 
    RxFastIoDispatch.FastIoUnlockAllByKey = NULL; 
    RxFastIoDispatch.FastIoDeviceControl = RxFastIoDeviceControl;

    RxFastIoDispatch.AcquireForCcFlush = RxAcquireForCcFlush;
    RxFastIoDispatch.ReleaseForCcFlush = RxReleaseForCcFlush;
    RxFastIoDispatch.AcquireFileForNtCreateSection = RxAcquireFileForNtCreateSection;
    RxFastIoDispatch.ReleaseFileForNtCreateSection = RxReleaseFileForNtCreateSection;

    //
    //  Initialize stuff for the toplevelirp package
    //

    RxInitializeTopLevelIrpPackage();

    //
    //  Initialize the cache manager callback routines
    //

    RxData.CacheManagerCallbacks.AcquireForLazyWrite = &RxAcquireFcbForLazyWrite;
    RxData.CacheManagerCallbacks.ReleaseFromLazyWrite = &RxReleaseFcbFromLazyWrite;
    RxData.CacheManagerCallbacks.AcquireForReadAhead = &RxAcquireFcbForReadAhead;
    RxData.CacheManagerCallbacks.ReleaseFromReadAhead = &RxReleaseFcbFromReadAhead;

}


NTSTATUS
RxCommonUnimplemented ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxFsdDispatRxFsdUnImplementedchPROBLEM: IrpC =%08lx,Code=",
                        RxContext, RxContext->MajorFunction) );
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---------------------UNIMLEMENTED-----%s\n", "" ) );

    return STATUS_NOT_IMPLEMENTED;
}

RxDbgTraceDoit(ULONG RxDbgTraceEnableCommand = 0xffff;)


WML_CONTROL_GUID_REG Rdbss_ControlGuids[] = {
   { //  cddc01e2-fdce-479a-b8ee-3c87053fb55e Rdbss
     0xcddc01e2,0xfdce,0x479a,{0xb8,0xee,0x3c,0x87,0x05,0x3f,0xb5,0x5e},
     { //  529ae497-0a1f-43a5-8cb5-2aa60b497831
       {0x529ae497,0x0a1f,0x43a5,{0x8c,0xb5,0x2a,0xa6,0x0b,0x49,0x78,0x31},},
       //  b7e3da1d-67f4-49bd-b9c0-1e61ce7417a8
       {0xb7e3da1d,0x67f4,0x49bd,{0xb9,0xc0,0x1e,0x61,0xce,0x74,0x17,0xa8},},
       //  c966bef5-21c5-4630-84a0-4334875f41b8
       {0xc966bef5,0x21c5,0x4630,{0x84,0xa0,0x43,0x34,0x87,0x5f,0x41,0xb8},}
     },
   },
};



#define Rdbss_ControlGuids_len  1

extern BOOLEAN EnableWmiLog;

NTSTATUS
RxSystemControl(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing System control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    WML_TINY_INFO Info;
    UNICODE_STRING RegPath;

    PAGED_CODE();

    if (EnableWmiLog) {
        
        RtlInitUnicodeString( &RegPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss" );

        RtlZeroMemory( &Info, sizeof( Info ) );

        Info.ControlGuids = Rdbss_ControlGuids;
        Info.GuidCount = Rdbss_ControlGuids_len;
        Info.DriverRegPath = &RegPath;

        Status = WmlTinySystemControl( &Info,
                                       (PDEVICE_OBJECT)RxDeviceObject,
                                       Irp );
        
        if (Status != STATUS_SUCCESS) {
            //  DbgPrint("Rdbss WMI control return %lx\n", Status);
        }
    } else {
        
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return Status;
}

NTSTATUS
RxFsdDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the RDBSS.
Arguments:

    RxDeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );  //  ok4ioget

    UCHAR MajorFunctionCode  = IrpSp->MajorFunction;
    PFILE_OBJECT FileObject  = IrpSp->FileObject;  //  ok4->fileobj

    PRX_FSD_DISPATCH_VECTOR DispatchVector;

    PAGED_CODE();

    RxDbgTraceDoit(
        if (MajorFunctionCode == RxDbgTraceEnableCommand) {
            RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  FALSE;
        }
        if (0) {
            RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  FALSE;
        }
    );

    RxDbgTrace( 0, Dbg, ("RxFsdDispatch: Code =%02lx (%lu)  ----------%s-----------\n",
                                    MajorFunctionCode,
                                    ++RxIrpCodeCount[IrpSp->MajorFunction],
                                    RxIrpCodeToName[MajorFunctionCode]) );

    if (IrpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {
        return RxSystemControl( RxDeviceObject, Irp );
    }

    if ((MajorFunctionCode == IRP_MJ_CREATE_MAILSLOT) ||
        (MajorFunctionCode == IRP_MJ_CREATE_NAMED_PIPE)) {
        
        DispatchVector = NULL;
        Status = STATUS_OBJECT_NAME_INVALID;

    } else {
        
        //
        //  get a private dispatch table if there is one
        //

        if (MajorFunctionCode == IRP_MJ_CREATE) {
            
            DispatchVector = RxFsdDispatchVector;
        
        } else if ((FileObject != NULL) && (FileObject->FsContext != NULL)) {
            
            if ((NodeTypeIsFcb( (PFCB)(FileObject->FsContext) )) &&
                (((PFCB)(FileObject->FsContext))->PrivateDispatchVector != NULL)) {  //  ok4fscontext
                
                RxDbgTraceLV( 0, Dbg, 2500, ("Using Private Dispatch Vector\n" ));
                DispatchVector = ((PFCB)(FileObject->FsContext))->PrivateDispatchVector;

            } else {
               DispatchVector = RxFsdDispatchVector;
            }

            if (RxDeviceObject == RxFileSystemDeviceObject) {
                DispatchVector = NULL;
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        } else {
            
            DispatchVector = NULL;
            Status = STATUS_INVALID_DEVICE_REQUEST;
            RxDbgTrace( 0,
                        Dbg,
                        ("RxFsdDispatch: Code =%02lx (%lu)  ----------%s-----------\n",
                         MajorFunctionCode,
                         ++RxIrpCodeCount[IrpSp->MajorFunction],
                         RxIrpCodeToName[MajorFunctionCode]) );
        }
    }

    if (DispatchVector != NULL) {

        Status = RxFsdCommonDispatch( DispatchVector,
                                      Irp,
                                      FileObject,
                                      RxDeviceObject );

        RxDbgTrace( 0, Dbg, ("RxFsdDispatch: Status =%02lx  %s....\n",
                             Status,
                             RxIrpCodeToName[MajorFunctionCode]) );

        RxDbgTraceDoit(
            if (RxGlobalTraceIrpCount > 0) {
                RxGlobalTraceIrpCount -= 1;
                RxGlobalTraceSuppress = FALSE;
            } else {
                RxGlobalTraceSuppress = RxNextGlobalTraceSuppress;
            }
       );

    } else {
        
        IoMarkIrpPending( Irp );
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        Status = STATUS_PENDING;
    }

    return Status;
}


NTSTATUS
RxFsdCommonDispatch (
    PRX_FSD_DISPATCH_VECTOR DispatchVector,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine implements the FSD part of dispatch for IRP's

Arguments:

    DispatchVector    - the dispatch vector

    Irp               - the IRP
    
    FileObject        - the file object
    
    RxDeviceObject    -

Return Value:

    RXSTATUS - The FSD Status for the IRP

Notes:


--*/
{  
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    RX_TOPLEVELIRP_CONTEXT TopLevelContext;

    ULONG ContextFlags = 0;

    KIRQL SavedIrql;
    
    PRX_DISPATCH DispatchRoutine = NULL;
    PDRIVER_CANCEL CancelRoutine = NULL;

    BOOLEAN TopLevel = FALSE;
    BOOLEAN Wait;
    BOOLEAN Cancellable;
    BOOLEAN ModWriter = FALSE;
    BOOLEAN CleanupOrClose = FALSE;
    BOOLEAN Continue = TRUE;
    BOOLEAN PostRequest = FALSE;

    FsRtlEnterFileSystem();

    TopLevel = RxTryToBecomeTheTopLevelIrp( &TopLevelContext, Irp, RxDeviceObject, FALSE ); //  dont force

    try {
        
        //
        //  Treat all operations as being cancellable and waitable.
        //
        
        Wait = TRUE;
        Cancellable = TRUE;
        CancelRoutine = RxCancelRoutine;

        //
        //  Retract the capability based upon the operation
        //

        switch (IrpSp->MajorFunction) {
        
        case IRP_MJ_FILE_SYSTEM_CONTROL:

            //
            //  Call the common FileSystem Control routine, with blocking allowed if
            //  synchronous.  This opeation needs to special case the mount
            //  and verify suboperations because we know they are allowed to block.
            //  We identify these suboperations by looking at the file object field
            //  and seeing if its null.
            //

            if (FileObject == NULL) {
                Wait = TRUE;
            } else {
                Wait = CanFsdWait( Irp );
            }
            break;

        case IRP_MJ_READ:
        case IRP_MJ_LOCK_CONTROL:
        case IRP_MJ_DIRECTORY_CONTROL:
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
        case IRP_MJ_WRITE:
        case IRP_MJ_QUERY_INFORMATION:
        case IRP_MJ_SET_INFORMATION:
        case IRP_MJ_QUERY_EA:
        case IRP_MJ_SET_EA:
        case IRP_MJ_QUERY_SECURITY:
        case IRP_MJ_SET_SECURITY:
        case IRP_MJ_FLUSH_BUFFERS:
        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_SET_VOLUME_INFORMATION:

            Wait = CanFsdWait( Irp );
            break;

        case IRP_MJ_CLEANUP:
        case IRP_MJ_CLOSE:
            
            Cancellable = FALSE;
            CleanupOrClose = TRUE;
            break;

        default:
            break;
        }

        KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );
        Continue = TRUE;

        switch (RxDeviceObject->StartStopContext.State) {
        
        case RDBSS_STARTABLE: 

            //
            //  Only device creates and device operations can go thru
            //
            
            if ((DispatchVector == RxDeviceFCBVector) ||
                ((FileObject->FileName.Length == 0) &&
                (FileObject->RelatedFileObject == NULL))) {
            
                NOTHING;
            
            } else {
                
                Continue = FALSE;
                Status = STATUS_REDIRECTOR_NOT_STARTED;
            }
            break;

        case RDBSS_STOP_IN_PROGRESS:
           
            if (!CleanupOrClose) {
                Continue = FALSE;
                Status = STATUS_REDIRECTOR_NOT_STARTED;
            }
            break;

        //
        //  case RDBSS_STOPPED:
        //     {
        //        if ((MajorFunctionCode == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        //            (MinorFunctionCode == IRP_MN_USER_FS_REQUEST) &&
        //            (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_LMR_START)) {
        //           RxDeviceObject->StartStopContext.State = RDBSS_START_IN_PROGRESS;
        //           RxDeviceObject->StartStopContext.Version++;
        //           Continue = TRUE;
        //        } else {
        //           Continue = FALSE;
        //           Status = STATUS_REDIRECTOR_NOT_STARTED);
        //        }
        //     }
        //

        case RDBSS_STARTED:

            //
            //  intentional fallthrough 
            //
        
        default:
            break;
        }

        KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

        if ((IrpSp->FileObject != NULL) &&
            (IrpSp->FileObject->FsContext != NULL)) {
            
            PFCB Fcb = (PFCB)IrpSp->FileObject->FsContext;
            BOOLEAN Orphaned = FALSE;

            if ((IrpSp->FileObject->FsContext2 != UIntToPtr( DFS_OPEN_CONTEXT )) &&
                (IrpSp->FileObject->FsContext2 != UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT)) &&
                (IrpSp->FileObject->FsContext != &RxDeviceFCB)) {

                Orphaned = BooleanFlagOn( Fcb->FcbState, FCB_STATE_ORPHANED );

                if (!Orphaned && IrpSp->FileObject->FsContext2) {
                    
                    PFOBX Fobx = (PFOBX)IrpSp->FileObject->FsContext2;

                    if (Fobx->SrvOpen != NULL) {
                        Orphaned = BooleanFlagOn( Fobx->SrvOpen->Flags, SRVOPEN_FLAG_ORPHANED );
                    }
                }
            }
            
            if (Orphaned) {
                
                if (!CleanupOrClose) {

                    RxDbgTrace( 0,
                                Dbg,
                                ("Ignoring operation on ORPHANED FCB %lx %lx %lx\n",
                                 Fcb,
                                 IrpSp->MajorFunction,
                                 IrpSp->MinorFunction) );

                    Continue = FALSE;
                    Status = STATUS_UNEXPECTED_NETWORK_ERROR;
                    
                    RxLog(( "#### Orphaned FCB op %lx\n", Fcb ));
                    RxWmiLog( LOG,
                              RxFsdCommonDispatch_OF,
                              LOGPTR( Fcb ) );
                } else {
                    
                    RxDbgTrace( 0, Dbg, ("Delayed Close/Cleanup on ORPHANED FCB %lx\n", Fcb) );
                    Continue = TRUE;
                }
            }
        }

        if ((RxDeviceObject->StartStopContext.State == RDBSS_STOP_IN_PROGRESS) &&
            CleanupOrClose) {
            
            PFILE_OBJECT FileObject = IrpSp->FileObject;
            PFCB Fcb = (PFCB)FileObject->FsContext;
            
            RxDbgPrint(( "RDBSS -- Close after Stop" ));
            RxDbgPrint(( "RDBSS: Irp(%lx) MJ %ld MN %ld FileObject(%lx) FCB(%lx) \n",
                         Irp, IrpSp->MajorFunction, IrpSp->MinorFunction, FileObject, Fcb ));
            
            if ((FileObject != NULL) && 
                (Fcb != NULL) && 
                (Fcb != &RxDeviceFCB) && 
                NodeTypeIsFcb( Fcb )) {
            
                RxDbgPrint(( "RDBSS: OpenCount(%ld) UncleanCount(%ld) Name(%wZ)\n", Fcb->OpenCount, Fcb->UncleanCount, &Fcb->FcbTableEntry.Path ));
            }
        }

        if (!Continue) {
            
            if ((IrpSp->MajorFunction != IRP_MJ_DIRECTORY_CONTROL) ||
                (IrpSp->MinorFunction !=IRP_MN_NOTIFY_CHANGE_DIRECTORY)) {
                
                IoMarkIrpPending( Irp );
                Irp->IoStatus.Status = Status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );

                Status = STATUS_PENDING;
            
            } else {
                
                //
                //  this is a changenotify directory control
                //  Fail the operation
                //  The usermode API cannot get the error in the IO Status block
                //  correctly, due to the way FindFirstChangeNotify/FindNextChangeNotify
                //  APIs are designed
                //

                Irp->IoStatus.Status = Status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
            }
            try_return( Status );
        }

        if (Wait) {
            SetFlag( ContextFlags, RX_CONTEXT_FLAG_WAIT );
        }
        RxContext = RxCreateRxContext( Irp, RxDeviceObject, ContextFlags );
        if (RxContext == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            RxCompleteRequest_OLD( RxNull, Irp, Status );
            try_return( Status );
        }

        //
        //  Assume ownership of the Irp by setting the cancelling routine.
        //

        if (Cancellable) {
            RxSetCancelRoutine( Irp, CancelRoutine );
        } else {

            //                                                        
            //  Ensure that those operations regarded as non cancellable will
            //  not be cancelled.
            //
           
            RxSetCancelRoutine( Irp, NULL );
        }

        ASSERT( IrpSp->MajorFunction <= IRP_MJ_MAXIMUM_FUNCTION );

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;

        DispatchRoutine = DispatchVector[IrpSp->MajorFunction].CommonRoutine;

        switch (IrpSp->MajorFunction) {
        case IRP_MJ_READ:
        case IRP_MJ_WRITE:

            //
            //  If this is an Mdl complete request, don't go through
            //  common read.
            //

            if (FlagOn( IrpSp->MinorFunction, IRP_MN_COMPLETE )) {
                
                DispatchRoutine = RxCompleteMdl;
            
            
            } else if (FlagOn( IrpSp->MinorFunction, IRP_MN_DPC )) {

                //
                //  Post all DPC calls.
                //

                RxDbgTrace( 0, Dbg, ("Passing DPC call to Fsp\n", 0 ) );
                PostRequest = TRUE;

            } else if ((IrpSp->MajorFunction == IRP_MJ_READ) &&
                       (IoGetRemainingStackSize() < 0xe00)) {
                //
                //  Check if we have enough stack space to process this request.  If there
                //  isn't enough then we will pass the request off to the stack overflow thread.
                //
                //  NTBUG 61951 Shishirp 2/23/2000 where did the number come from......
                //  this number should come from the minirdr....only he knows how much he needs
                //  and in my configuration it should definitely be bigger than for FAT!
                //  plus......i can't go to the net on the hypercrtical thread!!! this will have to be
                //  reworked! maybe we should have our own hypercritical thread............
                //
               
                RxDbgTrace(0, Dbg, ("Passing StackOverflowRead off\n", 0 ));

                RxContext->PendingReturned = TRUE;

                Status = RxPostStackOverflowRead( RxContext, (PFCB)IrpSp->FileObject->FsContext );

                if (Status != STATUS_PENDING) {
                    RxContext->PendingReturned = FALSE;
                    RxCompleteRequest( RxContext, Status );
                }

               try_return(Status);
            }
            break;
        
        default:
            NOTHING;
        }

        //
        //  set the resume routine for the fsp to be the dispatch routine and then either post immediately
        //  or calldow to the common dispatch as appropriate
        //

        RxContext->ResumeRoutine = DispatchRoutine;

        if (DispatchRoutine != NULL) {

            RxContext->PendingReturned = TRUE;

            if (PostRequest) {
               Status = RxFsdPostRequest( RxContext );
            } else {
                
                do {
                     Status = DispatchRoutine( RxContext, Irp );
                } while (Status == STATUS_RETRY);

                if (Status != STATUS_PENDING) {

                    if (!((RxContext->CurrentIrp == Irp) &&
                          (RxContext->CurrentIrpSp == IrpSp) &&
                          (RxContext->MajorFunction == IrpSp->MajorFunction) &&
                          (RxContext->MinorFunction == IrpSp->MinorFunction))) {
                                                
                        DbgPrint( "RXCONTEXT CONTAMINATED!!!! rxc=%08lx\n", RxContext );
                        DbgPrint( "-irp> %08lx %08lx\n", RxContext->CurrentIrp, Irp );
                        DbgPrint( "--sp> %08lx %08lx\n", RxContext->CurrentIrpSp, IrpSp );
                        DbgPrint( "--mj> %08lx %08lx\n", RxContext->MajorFunction, IrpSp->MajorFunction );
                        DbgPrint( "--mn> %08lx %08lx\n", RxContext->MinorFunction, IrpSp->MinorFunction );
                        //  DbgBreakPoint();
                    }

                    RxContext->PendingReturned = FALSE;
                    Status = RxCompleteRequest( RxContext, Status );
                }
            }
        } else {
            Status = STATUS_NOT_IMPLEMENTED;
        }

    try_exit: NOTHING;
    
    } except( RxExceptionFilter( RxContext, GetExceptionInformation() )) {
            
        //
        //  The I/O request was not handled successfully, abort the I/O request with
        //  the error Status that we get back from the execption code
        //

        if (RxContext != NULL) {
            RxContext->PendingReturned = FALSE;
        }

        Status = RxProcessException( RxContext, GetExceptionCode() );
    }

    if (TopLevel) {
        
        RxUnwindTopLevelIrp( &TopLevelContext );
    }

    FsRtlExitFileSystem();
    return Status;

    UNREFERENCED_PARAMETER( IrpSp );
}

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //  ifdef RX_PRIVATE_BUILD
#define RX_TOPLEVELCTX_FLAG_FROM_POOL (0x00000001)

KSPIN_LOCK TopLevelIrpSpinLock;
LIST_ENTRY TopLevelIrpAllocatedContextsList;

VOID
RxInitializeTopLevelIrpPackage (
    VOID
    )
{
    KeInitializeSpinLock( &TopLevelIrpSpinLock );
    InitializeListHead( &TopLevelIrpAllocatedContextsList );
}

VOID
RxAddToTopLevelIrpAllocatedContextsList (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This the passed context is added to the allocatedcontexts list. THIS
    ROUTINE TAKES A SPINLOCK...CANNOT BE PAGED.

Arguments:

    TopLevelContext - the context to be removed

Return Value:


--*/
{
    KIRQL SavedIrql;
    
    ASSERT( TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE );
    ASSERT( FlagOn( TopLevelContext->Flags, RX_TOPLEVELCTX_FLAG_FROM_POOL ) );
    
    KeAcquireSpinLock( &TopLevelIrpSpinLock, &SavedIrql );
    InsertHeadList( &TopLevelIrpAllocatedContextsList, &TopLevelContext->ListEntry );
    KeReleaseSpinLock( &TopLevelIrpSpinLock, SavedIrql );
}

VOID
RxRemoveFromTopLevelIrpAllocatedContextsList (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This the passed context is removed from the allocatedcontexts list. THIS
    ROUTINE TAKES A SPINLOCK...CANNOT BE PAGED.

Arguments:

    TopLevelContext - the context to be removed

Return Value:


--*/
{
    KIRQL SavedIrql;
    
    ASSERT( TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE );
    ASSERT( FlagOn( TopLevelContext->Flags, RX_TOPLEVELCTX_FLAG_FROM_POOL ) );
    
    KeAcquireSpinLock( &TopLevelIrpSpinLock, &SavedIrql );
    RemoveEntryList( &TopLevelContext->ListEntry );
    KeReleaseSpinLock( &TopLevelIrpSpinLock, SavedIrql );
}

BOOLEAN
RxIsMemberOfTopLevelIrpAllocatedContextsList (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This looks to see if the passed context is on the allocatedcontexts list.
    THIS ROUTINE TAKES A SPINLOCK...CANNOT BE PAGED.

Arguments:

    TopLevelContext - the context to be looked up

Return Value:

    TRUE if TopLevelContext is on the list, FALSE otherwise

--*/
{
    KIRQL SavedIrql;
    PLIST_ENTRY ListEntry;
    BOOLEAN Found = FALSE;

    KeAcquireSpinLock( &TopLevelIrpSpinLock, &SavedIrql );

    ListEntry = TopLevelIrpAllocatedContextsList.Flink;

    while (ListEntry != &TopLevelIrpAllocatedContextsList) {
        
        PRX_TOPLEVELIRP_CONTEXT ListTopLevelContext
               = CONTAINING_RECORD( ListEntry, RX_TOPLEVELIRP_CONTEXT, ListEntry );

        ASSERT( ListTopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE );
        ASSERT( FlagOn( ListTopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL ) );

        if (ListTopLevelContext == TopLevelContext) {
            
            Found = TRUE;
            break;

        } else {
            ListEntry = ListEntry->Flink;
        }
    }

    KeReleaseSpinLock( &TopLevelIrpSpinLock, SavedIrql );
    return Found;

}

BOOLEAN
RxIsThisAnRdbssTopLevelContext (
    IN PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
{
    ULONG_PTR StackBottom;
    ULONG_PTR StackTop;

    //
    //  if it's a magic value....then no
    //

    if ((ULONG_PTR)TopLevelContext <= FSRTL_MAX_TOP_LEVEL_IRP_FLAG) {
        return FALSE;
    }

    //
    //  if it's on the stack...check the signature
    //

    IoGetStackLimits( &StackTop, &StackBottom );
    if (((ULONG_PTR) TopLevelContext <= StackBottom - sizeof( RX_TOPLEVELIRP_CONTEXT )) &&
        ((ULONG_PTR) TopLevelContext >= StackTop)) {

        //
        //  it's on the stack check it
        //

        if (!FlagOn( (ULONG_PTR) TopLevelContext, 0x3 ) &&
            (TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE)) {
            
            return TRUE;
        
        } else {
            
            return FALSE;
        }
    }

    return RxIsMemberOfTopLevelIrpAllocatedContextsList( TopLevelContext );
}


BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceTopLevel
    )
/*++

Routine Description:

    This routine detects if an Irp is the Top level requestor, ie. if it os OK
    to do a verify or pop-up now.  If TRUE is returned, then no file system
    resources are held above us. Also, we have left a context in TLS that will
    allow us to tell if we are the top level...even if we are entered recursively.

Arguments:

    TopLevelContext -  the toplevelirp context to use. if NULL, allocate one
    Irp             -  the irp. could be a magic value
    RxDeviceObject  -  the associated deviceobject
    ForceTopLevel   -  if true, we force ourselves onto the TLS

Return Value:

    BOOLEAN tells whether we became the toplevel.

--*/
{
    ULONG ContextFlags = 0;
    PAGED_CODE();

    if ((IoGetTopLevelIrp() != NULL ) && !ForceTopLevel) {
        return FALSE;
    }

    //
    //  i hate doing this allocate....toplevelirp is the world's biggest kludge
    //

    if (TopLevelContext == NULL) {
        
        TopLevelContext = RxAllocatePool( NonPagedPool, sizeof( RX_TOPLEVELIRP_CONTEXT ) );
        if (TopLevelContext == NULL) {
            return FALSE;
        }
        ContextFlags = RX_TOPLEVELCTX_FLAG_FROM_POOL;
    }

    __RxInitializeTopLevelIrpContext( TopLevelContext,
                                      Irp,
                                      RxDeviceObject,
                                      ContextFlags );

    ASSERT( TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE );
    ASSERT( (ContextFlags == 0) || FlagOn( TopLevelContext->Flags, RX_TOPLEVELCTX_FLAG_FROM_POOL ));

    IoSetTopLevelIrp( (PIRP)TopLevelContext );
    return TRUE;
}

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine initalizes a toplevelirp context.

Arguments:

    TopLevelContext -  the toplevelirp context to use.
    Irp             -  the irp. could be a magic value
    RxDeviceObject  -  the associated deviceobject
    Flags           -  could be various...currently just tells if context is allocated or not

Return Value:

    None.

--*/
{
    RtlZeroMemory( TopLevelContext, sizeof( RX_TOPLEVELIRP_CONTEXT ) );
    TopLevelContext->Signature = RX_TOPLEVELIRP_CONTEXT_SIGNATURE;
    TopLevelContext->Irp = Irp;
    TopLevelContext->Flags = Flags;
    TopLevelContext->RxDeviceObject = RxDeviceObject;
    TopLevelContext->Previous = IoGetTopLevelIrp();
    TopLevelContext->Thread = PsGetCurrentThread();

    //
    //  if this is an allocated context, add it to the allocatedcontextslist
    //

    if (FlagOn( TopLevelContext->Flags, RX_TOPLEVELCTX_FLAG_FROM_POOL )) {
        RxAddToTopLevelIrpAllocatedContextsList( TopLevelContext );
    }
}



VOID
RxUnwindTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This routine removes us from the TLC....replacing by the previous.

Arguments:

    TopLevelContext -  the toplevelirp context to use. if NULL, use the one from TLS

Return Value:

    None.

--*/
{
    if (TopLevelContext == NULL) {

        //
        //  get the one off the thread and do some asserts to make sure it's me
        //

        TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)(IoGetTopLevelIrp());

        //
        //  depending on a race condition, this context could be NULL.
        //  we chkec it before hand and bail if so.
        //  In this case the Irp was completed by another thread.
        //

        if (!TopLevelContext) {
            return;
        }
        
        ASSERT( RxIsThisAnRdbssTopLevelContext( TopLevelContext ) );
        ASSERT( FlagOn( TopLevelContext->Flags, RX_TOPLEVELCTX_FLAG_FROM_POOL ) );
    }

    ASSERT( TopLevelContext->Thread == PsGetCurrentThread() );
    IoSetTopLevelIrp( TopLevelContext->Previous );
    
    if (FlagOn( TopLevelContext->Flags, RX_TOPLEVELCTX_FLAG_FROM_POOL )) {
        
        RxRemoveFromTopLevelIrpAllocatedContextsList( TopLevelContext );
        RxFreePool( TopLevelContext );
    }
}

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN PIRP Irp
    )
/*++

Routine Description:

    This determines if the irp at hand is the toplevel irp.

Arguments:

    Irp - the one to find out if it's toplevel...btw, it works for NULL.

Return Value:

    TRUE if irp is the toplevelirp.

--*/
{
    PIRP TopIrp = IoGetTopLevelIrp();
    PRX_TOPLEVELIRP_CONTEXT TopLevelContext;

    TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)TopIrp;

    if (RxIsThisAnRdbssTopLevelContext( TopLevelContext )) {
        
        TopIrp = TopLevelContext->Irp;
    }

    return (TopIrp == Irp);
}

PIRP
RxGetTopIrpIfRdbssIrp (
    VOID
    )
/*++

Routine Description:

    This gets the toplevelirp if it belongs to the rdbss.

Arguments:



Return Value:

    topirp if topirp is rdbss-irp and NULL otherwise.

--*/
{
    PRX_TOPLEVELIRP_CONTEXT TopLevelContext;

    TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)(IoGetTopLevelIrp());

    if (RxIsThisAnRdbssTopLevelContext( TopLevelContext )) {
        return TopLevelContext->Irp;
    } else {
        return NULL;
    }
}


PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    VOID
    )
/*++

Routine Description:

    This gets the deviceobject assoc'd w/ toplevelirp if topirp belongs to the rdbss.

Arguments:



Return Value:

    deviceobject for topirp if topirp is rdbss-irp and NULL otherwise.

--*/
{
    PRX_TOPLEVELIRP_CONTEXT TopLevelContext;

    TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)(IoGetTopLevelIrp());

    if (RxIsThisAnRdbssTopLevelContext( TopLevelContext )) {
        return TopLevelContext->RxDeviceObject;
    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\ntinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the RDBSS.

    Also, the routines for pagingio resource selection/allocation are here; since
    we have to delete the resources when we unload, having them here simply centralizes
    all the pagingio resource stuff.

    Finally, the routines that are here that implement the wrapper's version of
    network provider order. Basically, the wrapper MUST implement the same concept of
    network provider order as the MUP so that the UI will work as expected. So, we
    read the provider order from the registry at init time and memorize the order. Then,
    we can assign the correct order when minirdrs register. Obviously, provider order is
    not an issue in MONOLITHIC mode.

Author:

    Joe Linn [JoeLinn]    20-jul-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "NtDdNfs2.h"
#include "netevent.h"

//
//  The local debug trace level
//

#define Dbg                              (0)

ULONG RxBuildNumber = VER_PRODUCTBUILD;
#ifdef RX_PRIVATE_BUILD
ULONG RxPrivateBuild = 1;
#else
ULONG RxPrivateBuild = 0;
#endif

#ifdef MONOLITHIC_MINIRDR
RDBSS_DEVICE_OBJECT RxSpaceForTheWrappersDeviceObject;
#endif

#define LANMAN_WORKSTATION_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkStation\\Parameters"

BOOLEAN DisableByteRangeLockingOnReadOnlyFiles = FALSE;

VOID
RxReadRegistryParameters (
    VOID
    );
      
NPAGED_LOOKASIDE_LIST RxContextLookasideList;

VOID
RxGetRegistryParameters(
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
RxInitializeRegistrationStructures (
    VOID
    );
VOID
RxUninitializeRegistrationStructures (
    VOID
    );

NTSTATUS
RxGetStringRegistryParameter (
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PUNICODE_STRING ParamString,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    );

NTSTATUS
RxGetUlongRegistryParameter (
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    );

// 
//  this type and variable are used for unwinding the initialization so that stuff doesn't go thru the cracks
//  the way that this works is that stuff is done in the reverse order of the enumeration. that way i can just
//  use a switch-no-break to unwind.
//

typedef enum _RX_INIT_STATES {
    RXINIT_ALL_INITIALIZATION_COMPLETED,
    RXINIT_CONSTRUCTED_PROVIDERORDER,
    RXINIT_CREATED_LOG,
    RXINIT_CREATED_DEVICE_OBJECT,
    RXINIT_CREATED_FIRST_LINK,
    RXINIT_START
} RX_INIT_STATES;

VOID
RxInitUnwind (
    IN PDRIVER_OBJECT DriverObject,
    IN RX_INIT_STATES RxInitState
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxDriverEntry)
#pragma alloc_text(INIT, RxGetRegistryParameters)
#pragma alloc_text(INIT, RxGetStringRegistryParameter)
#pragma alloc_text(INIT, RxGetUlongRegistryParameter)
#pragma alloc_text(PAGE, RxUnload)
#pragma alloc_text(PAGE, RxInitUnwind)
#pragma alloc_text(PAGE, RxGetNetworkProviderPriority)
#pragma alloc_text(PAGE, RxInitializeRegistrationStructures)
#pragma alloc_text(PAGE, RxUninitializeRegistrationStructures)
#pragma alloc_text(PAGE, RxInitializeMinirdrDispatchTable)
#pragma alloc_text(PAGE, __RxFillAndInstallFastIoDispatch)
#pragma alloc_text(PAGE, RxReadRegistryParameters)
#endif

#define RX_SYMLINK_NAME L"\\??\\fsWrap"

BOOLEAN EnableWmiLog = FALSE;

NTSTATUS
RxDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Rx file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    RX_INIT_STATES RxInitState = 0;
#ifndef MONOLITHIC_MINIRDR
    UNICODE_STRING UnicodeString,LinkName;
#endif

    //
    //  this will bugcheck if things are bad
    //

    RxCheckFcbStructuresForAlignment(); 

    //
    //  Initialize the global data structures
    //

    ZeroAndInitializeNodeType( &RxData, RDBSS_NTC_DATA_HEADER, sizeof( RDBSS_DATA ) );
    RxData.DriverObject = DriverObject;

    ZeroAndInitializeNodeType( &RxDeviceFCB, RDBSS_NTC_DEVICE_FCB, sizeof( FCB ) );

    KeInitializeSpinLock( &RxStrucSupSpinLock );
    RxExports.pRxStrucSupSpinLock = &RxStrucSupSpinLock;

    RxInitializeDebugSupport();

    try {

        Status = RXINIT_START;

#ifndef MONOLITHIC_MINIRDR
        
        //
        //  Create a symbolic link from \\dosdevices\fswrap to the rdbss device object name
        //

        RtlInitUnicodeString( &LinkName, RX_SYMLINK_NAME );
        RtlInitUnicodeString( &UnicodeString, DD_NFS2_DEVICE_NAME_U );

        IoDeleteSymbolicLink( &LinkName );

        Status = IoCreateSymbolicLink( &LinkName, &UnicodeString );
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        RxInitState = RXINIT_CREATED_FIRST_LINK;

        //
        //  Create the device object.
        //

        Status = IoCreateDevice( DriverObject,
                                 sizeof(RDBSS_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                                 &UnicodeString,
                                 FILE_DEVICE_NETWORK_FILE_SYSTEM,
                                 FILE_REMOTE_DEVICE,
                                 FALSE,
                                 (PDEVICE_OBJECT *)(&RxFileSystemDeviceObject) );
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        RxInitState = RXINIT_CREATED_DEVICE_OBJECT;

#else

        //
        //  in monolithic mode, the wrapper doesn't really need a device object but
        //  we allocate stuff in the wrapper's device object in order to appropriately throttle
        //  thread usage per device object.
        //

        RxFileSystemDeviceObject = &RxSpaceForTheWrappersDeviceObject;
        RtlZeroMemory( RxFileSystemDeviceObject, sizeof( RxSpaceForTheWrappersDeviceObject ) );

#endif
        //
        //  Initialize the trace and logging facilities. loginit is a big allocation.
        //

        RxInitializeDebugTrace();

        RxInitializeLog();

        RxInitState = RXINIT_CREATED_LOG;

        RxGetRegistryParameters( RegistryPath );
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("Constants %08lx %08lx\n", RX_CONTEXT_FLAG_WAIT, RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH ));

        RxReadRegistryParameters();

        //
        //  Initialize the minirdr registration facilities.
        //

        Status = RxInitializeRegistrationStructures();
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        RxInitState = RXINIT_CONSTRUCTED_PROVIDERORDER;

#ifndef MONOLITHIC_MINIRDR

        //
        // We allocate an IoWorkItem to queue the requests to the FSP in the
        // RxAddToWorkque function. We only do this when the DeviceObject
        // RxFileSystemDeviceObject created to make sure that the RDBSS 
        // DeviceObject doesn't get unloaded while a request is being queued
        // to the FSP.
        //
        RxIoWorkItem = IoAllocateWorkItem( (PDEVICE_OBJECT) RxFileSystemDeviceObject );
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }

#endif

  try_exit: NOTHING;
    } finally {
        
        if (Status != STATUS_SUCCESS) {
            
            RxLogFailure ( RxFileSystemDeviceObject, NULL, EVENT_RDR_UNEXPECTED_ERROR, Status );
            RxInitUnwind( DriverObject, RxInitState );
        }
    }

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    //
    //
    //
    //
    //       #####     ##    #    #   ####   ######  #####
    //       #    #   #  #   ##   #  #    #  #       #    #
    //       #    #  #    #  # #  #  #       #####   #    #
    //       #    #  ######  #  # #  #  ###  #       #####
    //       #    #  #    #  #   ##  #    #  #       #   #
    //       #####   #    #  #    #   ####   ######  #    #
    //
    //
    //
    //  EVERYTHING FROM HERE DOWN BETTER WORK BECAUSE THERE IS NO MORE UNWINDING!!!
    //
    //


    RxInitializeDispatcher();
    RxInitializeBackoffPackage();

    //
    //  Initialize the look aside list for RxContext allocation
    //

    ExInitializeNPagedLookasideList( &RxContextLookasideList,
                                     ExAllocatePoolWithTag,
                                     ExFreePool,
                                     0,
                                     sizeof( RX_CONTEXT ),
                                     RX_IRPC_POOLTAG,
                                     4 );

    //
    //  Initialize the list of transport Irps to an empty list
    //

    InitializeListHead( &RxIrpsList );
    KeInitializeSpinLock( &RxIrpsListSpinLock );
    
    //
    //  Initialize the list of active contexts to an empty list
    //

    InitializeListHead( &RxActiveContexts );

    //
    //  Initialize the list of srv call downs active
    //

    InitializeListHead( &RxSrvCalldownList );

    //
    //  a fastmutex is used to serialize access to the Qs that serialize blocking pipe operations
    //

    ExInitializeFastMutex( &RxContextPerFileSerializationMutex );

    //
    //  and to serialize access to the Qs that serialize some pagingio operations
    //

    ExInitializeFastMutex( &RxLowIoPagingIoSyncMutex );

    //
    //  Initialize the scavenger mutex
    //

    KeInitializeMutex( &RxScavengerMutex, 1 );

    //
    // Initialize the global serialization Mutex.
    //

    KeInitializeMutex( &RxSerializationMutex, 1 );

    //
    //  Initialize the wrapper's overflow queue
    //

    {
        PRDBSS_DEVICE_OBJECT MyDo = (PRDBSS_DEVICE_OBJECT)RxFileSystemDeviceObject;
        LONG Index;

        for (Index = 0; Index < MaximumWorkQueue; Index++) {
            
            MyDo->OverflowQueueCount[Index] = 0;
            InitializeListHead( &MyDo->OverflowQueue[Index] );
            MyDo->PostedRequestCount[Index] = 0;
        }

        KeInitializeSpinLock( &MyDo->OverflowQueueSpinLock );
    }

    //
    //      Initialize dispatch vector for driver object AND ALSO FOR the devicefcb
    //

    RxInitializeDispatchVectors( DriverObject );
    ExInitializeResourceLite( &RxData.Resource );

    //
    // Initialize devfcb context2
    //

    RxDeviceFCB.Context2 = (PVOID) &RxData;

    //
    //  Set up global pointer to our process.
    //

    RxData.OurProcess = PsGetCurrentProcess();

    //
    //  Put in a bunch of sanity checks about various structures...hey, it's init code!
    //

    IF_DEBUG {
        ULONG FcbStateBufferingMask = FCB_STATE_BUFFERING_STATE_MASK;
        ULONG MinirdrBufStateCommandMask = MINIRDR_BUFSTATE_COMMAND_MASK;
        USHORT EightBitsPerChar = 8;

        //
        //  we could put in defines for the ULONG/USHORTS here...but they don't change often
        //

        ASSERT( MRDRBUFSTCMD_MAXXX == (sizeof( ULONG )*EightBitsPerChar) );
        ASSERT( !(FcbStateBufferingMask&MinirdrBufStateCommandMask) );

    }

    //
    //  Setup the timer subsystem
    //

    RxInitializeRxTimer();

#ifndef MONOLITHIC_MINIRDR
    Status = IoWMIRegistrationControl( (PDEVICE_OBJECT)RxFileSystemDeviceObject, WMIREG_ACTION_REGISTER );
    
    if (Status != STATUS_SUCCESS) {
        DbgPrint( "Rdbss fails to register WMI %lx\n", Status );
    } else {
        EnableWmiLog = TRUE;
    }
#endif

    return STATUS_SUCCESS;
}


//
//  Unload routine
//

VOID
RxUnload (
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the RDBSS.

Arguments:

     DriverObject - pointer to the driver object for the RDBSS

Return Value:

     None

--*/

{
    PAGED_CODE();

    RxTearDownRxTimer();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxUnload: DriverObject =%08lx\n", DriverObject ) );

    ExDeleteResourceLite( &RxData.Resource );

    RxUninitializeBackoffPackage();

    RxTearDownDispatcher();

    RxTearDownDebugSupport();

    ExDeleteNPagedLookasideList( &RxContextLookasideList );

    RxInitUnwind( DriverObject, RXINIT_ALL_INITIALIZATION_COMPLETED );
    
    if (EnableWmiLog) {
        
        NTSTATUS Status;

        Status = IoWMIRegistrationControl( (PDEVICE_OBJECT)RxFileSystemDeviceObject, WMIREG_ACTION_DEREGISTER );
        if (Status != STATUS_SUCCESS) {
            DbgPrint( "Rdbss fails to deregister WMI %lx\n", Status );
        }
    }

#ifndef MONOLITHIC_MINIRDR

    IoFreeWorkItem(RxIoWorkItem);

#endif

    return;
}

#if DBG
PCHAR RxUnwindFollower = NULL;
#endif

VOID
RxInitUnwind (
    IN PDRIVER_OBJECT DriverObject,
    IN RX_INIT_STATES RxInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
#ifndef MONOLITHIC_MINIRDR
    UNICODE_STRING LinkName;
#endif

    PAGED_CODE();

    switch (RxInitState) {
    
    case RXINIT_ALL_INITIALIZATION_COMPLETED: 

        //
        //  Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //  lack of break intentional
        //
    
#if DBG
        RxUnwindFollower = "RXINIT_ALL_INITIALIZATION_COMPLETED";
#endif

    case RXINIT_CONSTRUCTED_PROVIDERORDER: 
    
#if DBG
        RxUnwindFollower = "RXINIT_CONSTRUCTED_PROVIDERORDER";
#endif
        RxUninitializeRegistrationStructures();

        //
        //  lack of break intentional
        //

    case RXINIT_CREATED_LOG: 
    
#if DBG
        RxUnwindFollower = "RXINIT_CREATED_LOG";
#endif
        RxUninitializeLog();
        
        //
        //  lack of break intentional
        //


    case RXINIT_CREATED_DEVICE_OBJECT: 

#if DBG
        RxUnwindFollower = "RXINIT_CREATED_DEVICE_OBJECT";
#endif

#ifndef MONOLITHIC_MINIRDR
        IoDeleteDevice( (PDEVICE_OBJECT)RxFileSystemDeviceObject );
#endif

        //
        //  lack of break intentional
        //

    case RXINIT_CREATED_FIRST_LINK: 
    
#if DBG        
        RxUnwindFollower = "RXINIT_CREATED_FIRST_LINK";
#endif

#ifndef MONOLITHIC_MINIRDR
        RtlInitUnicodeString( &LinkName, L"\\??\\fsWrap" );
        IoDeleteSymbolicLink( &LinkName );
#endif
        
        //
        //  lack of break intentional
        //

    case RXINIT_START: 
    
#if DBG
        RxUnwindFollower = "RXINIT_START";
#endif
        break;
    }
}


VOID
RxGetRegistryParameters (
    PUNICODE_STRING RegistryPath
    )
{
    ULONG Storage[256];
    UNICODE_STRING UnicodeString;
    HANDLE ConfigHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

    PAGED_CODE(); 

    InitializeObjectAttributes( &ObjectAttributes,
                                RegistryPath,               //  name
                                OBJ_CASE_INSENSITIVE,       //  attributes
                                NULL,                       //  root
                                NULL                        //  security descriptor
                                );

    Status = ZwOpenKey( &ConfigHandle, KEY_READ, &ObjectAttributes );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    RtlInitUnicodeString( &UnicodeString, L"Parameters" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                ConfigHandle,
                                NULL );


    Status = ZwOpenKey( &ParametersHandle, KEY_READ, &ObjectAttributes );

    if (!NT_SUCCESS(Status)) {
        
        ZwClose(ConfigHandle);
        return;
    }

#ifdef RDBSSLOG
    
    RxGetStringRegistryParameter( ParametersHandle,
                                  L"InitialDebugString",
                                  &UnicodeString,
                                  (PKEY_VALUE_PARTIAL_INFORMATION) Storage,
                                  sizeof( Storage ),
                                  FALSE );


    if (UnicodeString.Length && UnicodeString.Length<320) {
        
        PWCH u = UnicodeString.Buffer;
        ULONG l;
        PCH p = (PCH)u;

        for (l=0; l<UnicodeString.Length; l++) {
            
            *p++ = (CHAR)*u++;
            *p = 0;
        }

        DbgPrint( "InitialDebugString From Registry as singlebytestring: <%s>\n", UnicodeString.Buffer );
        RxDebugControlCommand( (PCH)UnicodeString.Buffer );
    }
#endif //  RDBSSLOG

    ZwClose( ParametersHandle );
    ZwClose( ConfigHandle );
}


NTSTATUS
RxGetStringRegistryParameter (
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PUNICODE_STRING ParamString,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); 

    RtlInitUnicodeString( &UnicodeString, ParameterName );

    Status = ZwQueryValueKey( ParametersHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              Value,
                              ValueSize, 
                              &BytesRead );

    ParamString->Length = 0;
    ParamString->Buffer = NULL;
    
    if (NT_SUCCESS(Status)) {
        
        ParamString->Buffer = (PWCH)(&Value->Data[0]);

        //
        //  the datalength actually accounts for the trailing null
        //

        ParamString->Length = ((USHORT)Value->DataLength) - sizeof( WCHAR );
        ParamString->MaximumLength = ParamString->Length;
        return STATUS_SUCCESS;
    }

    if (!LogFailure) { 
        return Status; 
    }

    RxLogFailure ( RxFileSystemDeviceObject, NULL, EVENT_RDR_CANT_READ_REGISTRY, Status );
    return Status;
}


NTSTATUS
RxGetUlongRegistryParameter (
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); 

    RtlInitUnicodeString( &UnicodeString, ParameterName );

    Status = ZwQueryValueKey( ParametersHandle, 
                              &UnicodeString,
                              KeyValuePartialInformation,
                              Value,
                              ValueSize,
                              &BytesRead );


    if (NT_SUCCESS(Status)) {
        
        if (Value->Type == REG_DWORD) {
            
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            DbgPrint( "readRegistryvalue %wZ = %08lx\n", &UnicodeString, *ParamUlong );
            return(STATUS_SUCCESS);
        
        } else {
            
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (!LogFailure) { 
         return Status; 
     }

     RxLogFailureWithBuffer ( RxFileSystemDeviceObject,
                              NULL,
                              EVENT_RDR_CANT_READ_REGISTRY,
                              Status,
                              ParameterName,
                              (USHORT)(wcslen( ParameterName )* sizeof( WCHAR ) ) );

     return Status;
}


/*-------------------------------

    This set of routines implements the network provider order in the wrapper.
    The way that this works is somewhat complicated. First, we go to the registry
    to get the provider order; it is stored at key=PROVIDERORDER_REGISTRY_KEY and
    value=L"ProviderOrder". This is a list of service providers whereas what we need
    are the device names. So, for each ServiceProverName, we go to the registry to
    get the device name at key=SERVICE_REGISTRY_KEY, subkey=ServiceProverName,
    subsubkey=NETWORK_PROVIDER_SUBKEY, and value=L"Devicename".
    
    We build a linked list of these guys. Later when a minirdr registers, we look
    on this list for the corresponding device name and that gives us the priority.
    
----------------------------------*/

#ifndef MONOLITHIC_MINIRDR

NTSTATUS
RxAccrueProviderFromServiceName (
    HANDLE           ServicesHandle,
    PUNICODE_STRING  ServiceName,
    ULONG            Priority,
    PWCHAR           ProviderInfoNameBuffer,
    ULONG            ProviderInfoNameBufferLength
    );

NTSTATUS
RxConstructProviderOrder (
    VOID
    );

VOID
RxDestructProviderOrder (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxAccrueProviderFromServiceName)
#pragma alloc_text(INIT, RxConstructProviderOrder)
#pragma alloc_text(PAGE, RxDestructProviderOrder)
#endif


#define PROVIDERORDER_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\NetworkProvider\\Order"
#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define NETWORK_PROVIDER_SUBKEY L"\\networkprovider"


typedef struct _RX_UNC_PROVIDER_HEADER {
    union {
        LIST_ENTRY;
        LIST_ENTRY Links;
    };
    ULONG Priority;
    union {
        UNICODE_STRING;
        UNICODE_STRING DeviceName;
    };
} RX_UNC_PROVIDER_HEADER;

typedef struct _RX_UNC_PROVIDER {
    RX_UNC_PROVIDER_HEADER;
    KEY_VALUE_PARTIAL_INFORMATION Info;
} RX_UNC_PROVIDER, *PRX_UNC_PROVIDER;

LIST_ENTRY RxUncProviders;

ULONG
RxGetNetworkProviderPriority (
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

     This routine is called at minirdr registration time to find out the priority
     of the provider with the given DeviceName. It simply looks it up on a list.

Arguments:

     DeviceName - name of the device whose priority is to be found

Return Value:

     the network provider priority that the MUP will use.

--*/
{
    PLIST_ENTRY Entry;

    PAGED_CODE();

    RxLog(( "FindUncProvider %wZ \n", DeviceName ));
    RxWmiLog( LOG,
              RxGetNetworkProviderPriority,
              LOGUSTR( *DeviceName ));

    for (Entry = RxUncProviders.Flink; Entry != &RxUncProviders;) {

        PRX_UNC_PROVIDER UncProvider = (PRX_UNC_PROVIDER)Entry;
        Entry = Entry->Flink;
        if (RtlEqualUnicodeString( DeviceName, &UncProvider->DeviceName, TRUE )) {
            return UncProvider->Priority;
        }
    }

    //
    //  no corresponding entry was found
    //

    return 0x7effffff; //  got this constant from the MUP........
}


NTSTATUS
RxAccrueProviderFromServiceName (
    HANDLE ServicesHandle,
    PUNICODE_STRING ServiceName,
    ULONG Priority,
    PWCHAR ProviderInfoNameBuffer,
    ULONG ProviderInfoNameBufferLength
    )
/*++

Routine Description:

     This routine has the responsibility to look up the device name corresponding
     to a particular provider name; if successful, the device name and the corresponding
     priority are recorded on the UncProvider List.

Arguments:

    HANDLE           ServicesHandle  - a handle to the services root in the registry
    PUNICODE_STRING  ServiceName     - the name of the service relative to the servicehandle
    ULONG            Priority,       - the priority of this provider
    PWCHAR           ProviderInfoNameBuffer,    - a buffer that can be used to accrue the subkey name
    ULONG            ProviderInfoNameBufferLength   - and the length

Return Value:

     STATUS_SUCCESS if everything worked elsewise an error status.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ProviderInfoName,ProviderInfoKey,ParameterDeviceName;
    HANDLE NetworkProviderInfoHandle = INVALID_HANDLE_VALUE;
    KEY_VALUE_PARTIAL_INFORMATION InitialValuePartialInformation;
    ULONG DummyBytesRead,ProviderLength;
    PRX_UNC_PROVIDER UncProvider = NULL;

    PAGED_CODE();

    RxLog(( "SvcNm %wZ", ServiceName ));
    RxWmiLog( LOG,
              RxAccrueProviderFromServiceName_1,
              LOGUSTR( *ServiceName ) );
    //
    //  Form the correct keyname using the bufferspace provided
    //

    ProviderInfoName.Buffer = ProviderInfoNameBuffer;
    ProviderInfoName.Length = 0;
    ProviderInfoName.MaximumLength = (USHORT)ProviderInfoNameBufferLength;

    try {

        Status = RtlAppendUnicodeStringToString( &ProviderInfoName, ServiceName );
        if (Status != STATUS_SUCCESS) {
            
            DbgPrint( "Could append1: %08lx %wZ\n", Status, &ProviderInfoName );
            leave;
        }
        
        RtlInitUnicodeString( &ProviderInfoKey, NETWORK_PROVIDER_SUBKEY );
        Status = RtlAppendUnicodeStringToString( &ProviderInfoName, &ProviderInfoKey );
        if (Status != STATUS_SUCCESS) {
            
            DbgPrint( "Could append2: %08lx %wZ\n", Status, &ProviderInfoName );
            leave;
        }

        //
        //  Open the key in preparation for reeading the devicename value
        //

        InitializeObjectAttributes( &ObjectAttributes,
                                    &ProviderInfoName,      //  name
                                    OBJ_CASE_INSENSITIVE,   //  attributes
                                    ServicesHandle,         //  root
                                    NULL );                 //  security descriptor
                                    

        Status = ZwOpenKey( &NetworkProviderInfoHandle, KEY_READ, &ObjectAttributes );

        if (!NT_SUCCESS(Status )) {
            DbgPrint( "NetWorkProviderInfoFailed: %08lx %wZ\n", Status, &ProviderInfoName );
            leave;
        }

        //
        //  Read the devicename. we do this in two steps. first, we do a partial read to find out
        //  how big the name really is. Then, we allocate a UncProviderEntry of the correctsize and make
        //  a second call to fill it in.
        //

        RtlInitUnicodeString( &ParameterDeviceName, L"DeviceName" );

        Status = ZwQueryValueKey( NetworkProviderInfoHandle,
                                  &ParameterDeviceName,
                                  KeyValuePartialInformation,
                                  &InitialValuePartialInformation,
                                  sizeof(InitialValuePartialInformation),
                                  &DummyBytesRead );
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
        if (Status != STATUS_SUCCESS) {
            leave;
        }

        ProviderLength = sizeof( RX_UNC_PROVIDER) + InitialValuePartialInformation.DataLength;
        UncProvider = RxAllocatePoolWithTag( PagedPool | POOL_COLD_ALLOCATION, ProviderLength, RX_MRX_POOLTAG );
        if (UncProvider == NULL) {
            
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DbgPrint( "UncProviderAllocationFailed: %08lx %wZ\n", Status, &ProviderInfoName );
            leave;
        }

        Status = ZwQueryValueKey( NetworkProviderInfoHandle,
                                  &ParameterDeviceName,
                                  KeyValuePartialInformation,
                                  &UncProvider->Info,
                                  ProviderLength,
                                  &DummyBytesRead );
        if (Status != STATUS_SUCCESS) {
            leave;
        }

        //
        //  Finish filling in the UncProviderEntry and link it in
        //

        UncProvider->Buffer = (PWCHAR)(&UncProvider->Info.Data[0]);
        UncProvider->Length = (USHORT)(UncProvider->Info.DataLength - sizeof( WCHAR )); //  dont include trailing NULL
        UncProvider->MaximumLength = UncProvider->Length;
        UncProvider->Priority = Priority;

        InsertTailList( &RxUncProviders, &UncProvider->Links );

        RxLog(( "Dvc p=%lx Nm %wZ",UncProvider->Priority, &UncProvider->DeviceName ));
        RxWmiLog( LOG,
                  RxAccrueProviderFromServiceName_2,
                  LOGULONG( UncProvider->Priority )
                  LOGUSTR( UncProvider->DeviceName ) );
        
        UncProvider = NULL;
    
    } finally {

        //
        //  if we obtained a handle to ...\\services\<sevicename>\providerinfo then close it
        //

        if (NetworkProviderInfoHandle != INVALID_HANDLE_VALUE) {
            ZwClose( NetworkProviderInfoHandle );
        }

        if (UncProvider != NULL) {
            RxFreePool(UncProvider);
        }
    }



    return Status;
}

NTSTATUS
RxConstructProviderOrder (
    VOID
    )
/*++

Routine Description:

     This routine has the responsibility to build the list of network providers
     that is used to look up provider priority at minirdr registration time. It does this
     by first reading the providerorder string fron the registry;  then for each provider
     listed in the string, a helper routine is called to lookup the corresponding device
     name and insert an entry on the provider list.

Arguments:

     none.

Return Value:

     STATUS_SUCCESS if everything worked elsewise an error status.


--*/
{
    KEY_VALUE_PARTIAL_INFORMATION InitialValuePartialInformation;
    UNICODE_STRING ProviderOrderValueName;
    ULONG DummyBytesRead;
    PBYTE ProviderOrderStringBuffer;
    PBYTE ServiceNameStringBuffer = NULL;
    ULONG ProviderOrderStringLength,ServiceNameStringLength,AllocationLength;

    UNICODE_STRING UnicodeString;
    UNICODE_STRING ProviderOrder;
    PWCHAR ScanPtr,FinalScanPtr;
    HANDLE NPOrderHandle = INVALID_HANDLE_VALUE;
    HANDLE ServiceRootHandle = INVALID_HANDLE_VALUE;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Priority = 0;

    PAGED_CODE();

    RxLog(( "RxConstructProviderOrder" ));
    RxWmiLog( LOG,
              RxConstructProviderOrder_1,
              LOGULONG( Priority ) );
    InitializeListHead( &RxUncProviders );

    try {

        //
        //  Start by opening the service registry key. This is the root key of all services
        //  and is used for relative opens by the helper routine so that string manipulation
        //  is reduced.
        //

        RtlInitUnicodeString( &UnicodeString, SERVICE_REGISTRY_KEY );

        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,             //  name
                                    OBJ_CASE_INSENSITIVE,       //  attributes
                                    NULL,                       //  root
                                    NULL );                     //  security descriptor

        Status = ZwOpenKey( &ServiceRootHandle, KEY_READ, &ObjectAttributes );

        if (!NT_SUCCESS( Status )) {
            DbgPrint( "ServiceRootOpenFailed: %08lx %wZ\n", Status, &UnicodeString );
            leave;
        }

        //
        //  Now open up the key where we find the provider order string
        //

        RtlInitUnicodeString( &UnicodeString, PROVIDERORDER_REGISTRY_KEY );

        InitializeObjectAttributes( &ObjectAttributes, 
                                    &UnicodeString,             //  name
                                    OBJ_CASE_INSENSITIVE,       //  attributes
                                    NULL,                       //  root
                                    NULL );                     //  security descriptor
                                    

        Status = ZwOpenKey( &NPOrderHandle, KEY_READ, &ObjectAttributes );

        if (!NT_SUCCESS( Status )) {
            
            DbgPrint( "NetProviderOpenFailed: %08lx %wZ\n", Status, &UnicodeString );
            leave;
        }

        //
        //  Find out how long the provider order string is
        //

        RtlInitUnicodeString( &ProviderOrderValueName, L"ProviderOrder" );

        Status = ZwQueryValueKey( NPOrderHandle, 
                                  &ProviderOrderValueName,
                                  KeyValuePartialInformation,
                                  &InitialValuePartialInformation,
                                  sizeof( InitialValuePartialInformation ),
                                  &DummyBytesRead );
        
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
        if (Status != STATUS_SUCCESS) {
            
            DbgPrint( "ProviderOrderStringPartialInfoFailed: %08lx %wZ\n", Status, &ProviderOrderValueName );
            leave;
        }

        //
        //  allocate two buffers: one buffer will hold the provider string -- ProviderOrderStringBuffer.
        //  it has to be as long as the providerorder string plus enough extra for the registry
        //  structure used in the call. the second buffer is used to hold the servicename key--it has
        //  to be as long as any element of the provider string plus enough extra to hold the suffix
        //  NETWORK_PROVIDER_SUBKEY. in order to only parse the string once, we just allocate for a complete
        //  additional copy of the provider string. we actually combine these into a single allocation.
        //

        ProviderOrderStringLength = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + InitialValuePartialInformation.DataLength;
        ProviderOrderStringLength = QuadAlign( ProviderOrderStringLength + 2*sizeof( WCHAR ) );   //  chars added below

        ServiceNameStringLength = sizeof( NETWORK_PROVIDER_SUBKEY  ) + InitialValuePartialInformation.DataLength;
        ServiceNameStringLength = QuadAlign( ServiceNameStringLength );

        AllocationLength = ProviderOrderStringLength + ServiceNameStringLength;
        RxLog(( "prov string=%lx,alloc=%lx\n", InitialValuePartialInformation.DataLength, AllocationLength ));
        RxWmiLog( LOG,
                  RxConstructProviderOrder_2,
                  LOGULONG( InitialValuePartialInformation.DataLength )
                  LOGULONG( AllocationLength ) );

        ServiceNameStringBuffer = RxAllocatePoolWithTag( PagedPool | POOL_COLD_ALLOCATION, AllocationLength, RX_MRX_POOLTAG );
        if (ServiceNameStringBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }
        ProviderOrderStringBuffer = ServiceNameStringBuffer+ServiceNameStringLength;

        //
        //  now do the final read to get the providerorder string
        //

        RxGetStringRegistryParameter( NPOrderHandle,
                                      L"ProviderOrder",
                                      &ProviderOrder,
                                      (PKEY_VALUE_PARTIAL_INFORMATION) ProviderOrderStringBuffer,
                                      ProviderOrderStringLength,
                                      FALSE );

        if (ProviderOrder.Buffer == NULL) {
            Status = STATUS_UNSUCCESSFUL;
            leave;
        }

        //
        //  comma-terminate the string for easier living. then scan down the string
        //  looking for comma terminated entries. for each entry found, try to accrue
        //  it to the list
        //

        ProviderOrder.Buffer[ProviderOrder.Length / sizeof( WCHAR )] = L',';

        ScanPtr = ProviderOrder.Buffer;
        FinalScanPtr = ScanPtr+(ProviderOrder.Length / sizeof( WCHAR ));
        for (;;) {

            UNICODE_STRING ServiceName;

            //
            //  check for loop termination
            //

            if (ScanPtr >= FinalScanPtr) { break; }
            if (*ScanPtr==L',') { ScanPtr++; continue; }

            //
            //  parse for a servicename
            //

            ServiceName.Buffer = ScanPtr;
            for (; *ScanPtr != L','; ScanPtr++) {}

            ASSERT( *ScanPtr==L',' );
            
            ServiceName.Length = (USHORT)(sizeof( WCHAR )* (ScanPtr - ServiceName.Buffer));

            //
            //  accrue it to the list
            //

            Priority += 1;
            Status = RxAccrueProviderFromServiceName( ServiceRootHandle,
                                                      &ServiceName,
                                                      Priority,
                                                      (PWCHAR)ServiceNameStringBuffer,
                                                      ServiceNameStringLength );
            if (Status == STATUS_INSUFFICIENT_RESOURCES) {
                leave; //  a log entry has already been generated
            } else {
                Status = STATUS_SUCCESS;
            }
        }
    } finally {

        //
        //  give back anything that we got in this procedure
        //

        if (NPOrderHandle != INVALID_HANDLE_VALUE) ZwClose( NPOrderHandle );
        if (ServiceRootHandle != INVALID_HANDLE_VALUE) ZwClose( ServiceRootHandle );
        if (ServiceNameStringBuffer != NULL) RxFreePool( ServiceNameStringBuffer );
                                                                                 
        //
        //  if things didn't work, then we won't start....so give back
        //  the stuff that we have
        //

        if (!NT_SUCCESS( Status )) {
            RxDestructProviderOrder();
        }
    }

    return Status;
}


VOID
RxDestructProviderOrder (
    VOID
    )
{
    PLIST_ENTRY Entry;
    PAGED_CODE();

    for (Entry = RxUncProviders.Flink; Entry != &RxUncProviders;) {
        PRX_UNC_PROVIDER UncProvider = (PRX_UNC_PROVIDER)Entry;
        
        Entry = Entry->Flink;
        RxFreePool( UncProvider );
    }
    return;
}

#else
ULONG
RxGetNetworkProviderPriority (
    PUNICODE_STRING DeviceName
    )
{
    PAGED_CODE(); 
    return 1; //this number is irrelevant for monolithic
}
#endif //#ifndef MONOLITHIC_MINIRDR

NTSTATUS
RxInitializeRegistrationStructures (
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    ExInitializeFastMutex(&RxData.MinirdrRegistrationMutex);
    RxData.NumberOfMinirdrsRegistered = 0;
    RxData.NumberOfMinirdrsStarted = 0;
    InitializeListHead( &RxData.RegisteredMiniRdrs );
#ifndef MONOLITHIC_MINIRDR
    Status = RxConstructProviderOrder();
#endif
    return(Status);
}

VOID
RxUninitializeRegistrationStructures(
    VOID
    )
{
    PAGED_CODE();

#ifndef MONOLITHIC_MINIRDR
    RxDestructProviderOrder();
#endif
}


VOID
RxInitializeMinirdrDispatchTable (
    IN PDRIVER_OBJECT DriverObject
    )
{
    
#ifndef MONOLITHIC_MINIRDR
    ULONG i;

    PAGED_CODE();
    
    //
    //  finally, fill in the dispatch tables for normal guys.........
    //
    
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = RxData.DriverObject->MajorFunction[i];
    }
    DriverObject->FastIoDispatch = RxData.DriverObject->FastIoDispatch;
#else
    PAGED_CODE();
#endif
}


VOID
NTAPI
__RxFillAndInstallFastIoDispatch(
    IN     PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN OUT PFAST_IO_DISPATCH FastIoDispatch,
    IN     ULONG             FastIoDispatchSize
    )
/*++

Routine Description:

    This routine fills out a fastiodispatch vector to be identical with
    that normal one and installs it into the driver object associated with
    the device object passed.

Arguments:

    RxDeviceObject - the device object that is to have its driver's fastiodispatch changed
    FastIoDispatch - the fastiodispatch table to fill in and use
    FastIoDispatchSize - the size of the table passed

Return Value:

    NONE

--*/
{
    ULONG TableSize = min(FastIoDispatchSize, RxFastIoDispatch.SizeOfFastIoDispatch );
    
    PAGED_CODE();

#ifndef MONOLITHIC_MINIRDR
    RtlCopyMemory( FastIoDispatch, &RxFastIoDispatch, TableSize );
    FastIoDispatch->SizeOfFastIoDispatch = TableSize;
    RxDeviceObject->DriverObject->FastIoDispatch = FastIoDispatch;
    return;
#endif
}

VOID
RxReadRegistryParameters( 
    VOID
    )
{
    ULONG Storage[16];
    UNICODE_STRING UnicodeString;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING WorkStationParametersRegistryKeyName;
    PKEY_VALUE_PARTIAL_INFORMATION Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ULONG ValueSize;
    ULONG BytesRead;

    PAGED_CODE(); 

    RtlInitUnicodeString( &WorkStationParametersRegistryKeyName, LANMAN_WORKSTATION_PARAMETERS );

    ValueSize = sizeof( Storage );

    InitializeObjectAttributes( &ObjectAttributes,
                                &WorkStationParametersRegistryKeyName,  //  name
                                OBJ_CASE_INSENSITIVE,                   //  attributes
                                NULL,                                   //  root
                                NULL );                                 //  security descriptor
                                

    Status = ZwOpenKey( &ParametersHandle, KEY_READ, &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {
        return;
    }

    RtlInitUnicodeString( &UnicodeString, L"DisableByteRangeLockingOnReadOnlyFiles" );

    Status = ZwQueryValueKey( ParametersHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              Value,
                              ValueSize,
                              &BytesRead );

    if (NT_SUCCESS( Status ) && (Value->Type == REG_DWORD)) {
            
        PULONG ConfigValue = (PULONG)&Value->Data[0];
        DisableByteRangeLockingOnReadOnlyFiles = (BOOLEAN)(*((PULONG)ConfigValue) != 0);
    }

    ZwClose( ParametersHandle );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\precomp.h ===
#include "rx.h"
#include "ntddnfs2.h"   // NT network file system driver include file
#include "ntdddisk.h"
#include "rxdebug.h"
#include "ntdisp.h"
#include "rxwmi.h"

#pragma warning(error:4101)   // Unreferenced local variable


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Rx called by
    the dispatch driver.

Author:

    Joe Linn     [JoeLinn]    5-oct-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonQueryVolumeInformation)
#pragma alloc_text(PAGE, RxCommonSetVolumeInformation)
#endif

NTSTATUS
RxCommonQueryVolumeInformation ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PFCB Fcb;
    PFOBX Fobx;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG OriginalLength = IrpSp->Parameters.QueryVolume.Length;
    FS_INFORMATION_CLASS FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    PVOID OriginalBuffer = Irp->AssociatedIrp.SystemBuffer;

    PAGED_CODE();

    RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonQueryVolumeInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb) );
    RxDbgTrace( 0, Dbg, ("->Length             = %08lx\n", OriginalLength) );
    RxDbgTrace( 0, Dbg, ("->FsInformationClass = %08lx\n", FsInformationClass) );
    RxDbgTrace( 0, Dbg, ("->Buffer             = %08lx\n", OriginalBuffer) );

    RxLog(( "QueryVolInfo %lx %lx %lx\n", RxContext, Fcb, Fobx ));
    RxWmiLog( LOG,
              RxCommonQueryVolumeInformation_1,
              LOGPTR(RxContext )
              LOGPTR(Fcb )
              LOGPTR(Fobx ) );
    RxLog(( "  alsoqvi %lx %lx %lx\n", OriginalLength, FsInformationClass, OriginalBuffer ));
    RxWmiLog( LOG,
              RxCommonQueryVolumeInformation_2,
              LOGULONG( OriginalLength )
              LOGULONG( FsInformationClass )
              LOGPTR( OriginalBuffer ) );

    try {
        
        RxContext->Info.FsInformationClass = FsInformationClass;
        RxContext->Info.Buffer = OriginalBuffer;
        RxContext->Info.LengthRemaining = OriginalLength;

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxQueryVolumeInfo,
                      (RxContext) );

        if (RxContext->PostRequest) {
            Status = RxFsdPostRequest( RxContext );
        } else {
            Irp->IoStatus.Information = OriginalLength - RxContext->Info.LengthRemaining;
        }

    } finally {
        DebugUnwind( RxCommonQueryVolumeInformation );
    }

    RxDbgTrace( -1, Dbg, ("RxCommonQueryVolumeInformation -> %08lx,%08lx\n", Status, Irp->IoStatus.Information) );

    return Status;
}


NTSTATUS
RxCommonSetVolumeInformation ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for setting Volume Information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PFOBX Fobx;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG Length;

    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

    RxDbgTrace( +1, Dbg, ("RxCommonSetVolumeInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb) );

    Length = IrpSp->Parameters.SetVolume.Length;
    FsInformationClass = IrpSp->Parameters.SetVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    RxDbgTrace( 0, Dbg, ("->Length             = %08lx\n", Length) );
    RxDbgTrace( 0, Dbg, ("->FsInformationClass = %08lx\n", FsInformationClass) );
    RxDbgTrace( 0, Dbg, ("->Buffer             = %08lx\n", Buffer) );

    RxLog(( "SetVolInfo %lx %lx %lx\n", RxContext, Fcb, Fobx ));
    RxWmiLog( LOG,
              RxCommonSetVolumeInformation_1,
              LOGPTR( RxContext )
              LOGPTR( Fcb )
              LOGPTR( Fobx ) );
    RxLog(( "  alsosvi %lx %lx %lx\n", Length, FsInformationClass, Buffer ));
    RxWmiLog( LOG,
              RxCommonSetVolumeInformation_2,
              LOGULONG( Length )
              LOGULONG( FsInformationClass )
              LOGPTR( Buffer ) );

    try {

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling performs the action if
        //  possible and returns true if it successful and false if it couldn't
        //  wait for any I/O to complete.
        //
        
        RxContext->Info.FsInformationClass = FsInformationClass;
        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = Length;

        MINIRDR_CALL( Status,
                      RxContext,
                      Fcb->MRxDispatch,
                      MRxSetVolumeInfo,
                      (RxContext) );

    } finally {

        DebugUnwind( RxCommonSetVolumeInformation );
        RxDbgTrace( -1, Dbg, ("RxCommonSetVolumeInformation -> %08lx\n", Status) );
    }

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\strtstop.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    strtstop.c

Abstract:

    This module implements the Start and Stop routines for the wrapper.

Author:

    Balan Sethu Raman     [SethuR]    27-Jan-1996

Revision History:

Notes:


--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#include "fsctlbuf.h"
#include "prefix.h"
#include "rxce.h"

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)

//
// Forward declarations
//


VOID
RxDeregisterUNCProvider(
   PRDBSS_DEVICE_OBJECT RxDeviceObject
   );

VOID
RxUnstart(
    PRX_CONTEXT         RxContext,
    PRDBSS_DEVICE_OBJECT RxDeviceObject
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDeregisterUNCProvider)
#pragma alloc_text(PAGE, RxUnstart)
#pragma alloc_text(PAGE, RxSetDomainForMailslotBroadcast)
#endif

//
// There are three states associated with each minirdr w.r.t the Start/Stop sequence.
// These are
//    RDBSS_STARTABLE
//       - This is the initial state and also the one intowhich a minirdr transitions
//           after a successful stop.
//
//    RDBSS_STARTED
//       - A transition to this state occurs after the startup sequence has been
//         successfully completed. This is the state in which the minirdr is active.
//
//    RDBSS_STOP_IN_PROGRESS
//       - A transition to this state occurs when a shutdown sequence has been initiated.
//
//
// A minirdr can be started and stopped independent of the system by invoking
// the appropriate command through the workstation service. The
// Start/Stop functionality is different from the Load/UnLoad functionality, i.e., it
// is possible to stop a mini redirectors without unloading it.
//
// The data structures associated with the RDBSS can be classified into two categories
// 1) those maintained by the RDBSS and visible to all the mini redirectors or private
// and 2) those that are mainitained by the RDBSS and visible to the I/O subsystem.
// The NET_ROOT,VNET_ROOT, SRV_CALL etc. are examples of the first category while
// FCB's,FOBX's(File Object extensions ) are examples of the second category.
// None of these data structures can be unilaterally destroyed by the RDBSS -- those
// in category 1 must be destroyed in coordination with the mini redirectors while
// those in category 2 must be done in coordination with the I/O subsystem.
//
// The destruction of the data structures can be initiated by the RDBSS while those
// in the  second category cannot be initiated by the RDBSS. Hence the shutdown
// sequence has to make provisions for handling them differently.
//
// A shutdown sequence can be successfully completed ( so that the driver can be
// unloaded ) if there are no residual instances in category 2, i.e., there are no
// open file handles or references to file objects from the other system components.
//
// If there are any residual references, the corresponding instances are marked as
// having been orphaned. The only permissible operations on orphaned instances are
// close and cleanup. The mini redirector close/cleanup operations must make special
// provisions for dealing with orphaned instances. All other operations are short
// circuited with an error status by the wrapper.
//

VOID
RxUnstart(
    PRX_CONTEXT RxContext,
    PRDBSS_DEVICE_OBJECT RxDeviceObject
   )
{
    PAGED_CODE();

    ASSERT(BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP));

    if (RxDeviceObject->MupHandle != (HANDLE)0) {
        RxDbgTrace(0, Dbg, ("RxDeregisterUNCProvider derigistering from MUP %wZ\n", &RxDeviceObject->DeviceName));
        FsRtlDeregisterUncProvider(RxDeviceObject->MupHandle);
        RxDeviceObject->MupHandle = (HANDLE)0;
    }

    if (RxDeviceObject->RegisteredAsFileSystem) {
        IoUnregisterFileSystem((PDEVICE_OBJECT)RxDeviceObject);
    }

    if (RxData.NumberOfMinirdrsStarted==1) {

        RxForceNetTableFinalization(RxDeviceObject);
        RxData.NumberOfMinirdrsStarted = 0;

        // Get rid of buffers that have been allocated.
        if (s_PrimaryDomainName.Buffer != NULL) {
            RxFreePool(s_PrimaryDomainName.Buffer);
            s_PrimaryDomainName.Length = 0;
            s_PrimaryDomainName.Buffer = NULL;
        }

    } else {
       InterlockedDecrement(&RxData.NumberOfMinirdrsStarted);
    }
}

NTSTATUS
RxSetDomainForMailslotBroadcast (
    IN PUNICODE_STRING DomainName
    )
{
    PAGED_CODE();

    if (s_PrimaryDomainName.Buffer!=NULL) {
        RxFreePool(s_PrimaryDomainName.Buffer);
    }

    RxLog(("DomainName=%wZ",DomainName));
    RxWmiLog(LOG,
             RxSetDomainForMailslotBroadcast_1,
             LOGUSTR(*DomainName));
    s_PrimaryDomainName.Length = (USHORT)DomainName->Length;
    s_PrimaryDomainName.MaximumLength = s_PrimaryDomainName.Length;

    if (s_PrimaryDomainName.Length > 0) {
        s_PrimaryDomainName.Buffer = RxAllocatePoolWithTag(
                                           PagedPool | POOL_COLD_ALLOCATION,
                                           s_PrimaryDomainName.Length,
                                           RX_MISC_POOLTAG);

        if (s_PrimaryDomainName.Buffer == NULL) {
           return(STATUS_INSUFFICIENT_RESOURCES);
        } else {
            RtlCopyMemory(
                  s_PrimaryDomainName.Buffer,
                  DomainName->Buffer,
                  s_PrimaryDomainName.Length);

            RxLog(("CapturedDomainName=%wZ",&s_PrimaryDomainName));
            RxWmiLog(LOG,
                     RxSetDomainForMailslotBroadcast_2,
                     LOGUSTR(s_PrimaryDomainName));
        }
    } else {
        s_PrimaryDomainName.Buffer = NULL;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
RxStartMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine starts up the calling minirdr by registering as an UNC
    provider with the MUP.

Arguments:

    RxContext - Describes the Context. the context is used to get the device object and to tell if we're in the fsp.

    PostToFsp - set to TRUE if the request has to be posted

Return Value:

    RxStatus(SUCCESS) -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS Status;

    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    BOOLEAN SuppressUnstart = FALSE;

    RxDbgTrace(0, Dbg, ("RxStartMinirdr [Start] -> %08lx\n", 0));

    // The startup sequence cannot be completed because there are certain aspects of
    // security and transport initialization that require handles. Since handles are
    // tied to a process the RDBSS needs to present an anchoring point to all the mini
    // redirectors. So the initialization will be completed in the context of the
    // FSP ( system process since RDBSS does not have its own FSP)

    if (InFSD) {
        SECURITY_SUBJECT_CONTEXT SubjectContext;

        SeCaptureSubjectContext(&SubjectContext);
        RxContext->FsdUid = RxGetUid( &SubjectContext );
        SeReleaseSubjectContext(&SubjectContext);

        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    if (!ExAcquireResourceExclusiveLite(&RxData.Resource, Wait)) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    if (!RxAcquirePrefixTableLockExclusive( RxContext->RxDeviceObject->pRxNetNameTable, Wait)) {
        ASSERT(!"How can the wait fail?????");
        ExReleaseResourceLite(&RxData.Resource);
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    try {

        if (RxDeviceObject->MupHandle != NULL) {
           RxDbgTrace(0, Dbg, ("RxStartMinirdr [Already] -> %08lx\n", 0));
           SuppressUnstart = TRUE;
           try_return(Status = STATUS_REDIRECTOR_STARTED);
        }

        if (RxDeviceObject->RegisterUncProvider) {
            Status = FsRtlRegisterUncProvider(
                         &RxDeviceObject->MupHandle,
                         &RxDeviceObject->DeviceName,
                         RxDeviceObject->RegisterMailSlotProvider
                     );

            if (Status!=STATUS_SUCCESS) {
                RxDeviceObject->MupHandle = (HANDLE)0;
                try_return(Status);
            }
        } else {
            Status = STATUS_SUCCESS;
        }

        IoRegisterFileSystem((PDEVICE_OBJECT)RxDeviceObject);

        RxDeviceObject->RegisteredAsFileSystem = TRUE;

        MINIRDR_CALL(Status,
                     RxContext,
                     RxDeviceObject->Dispatch,
                     MRxStart,
                     (RxContext,RxDeviceObject));

        if (Status == STATUS_SUCCESS) {
            RxDeviceObject->StartStopContext.Version++;
            RxSetRdbssState(RxDeviceObject,RDBSS_STARTED);
            InterlockedIncrement(&RxData.NumberOfMinirdrsStarted);
            Status = RxInitializeMRxDispatcher(RxDeviceObject);
        }

        try_return(Status);
try_exit:NOTHING;
    } finally {

        if (AbnormalTermination() || !NT_SUCCESS(Status)){
            if (!SuppressUnstart) {
                RxUnstart(RxContext,RxDeviceObject);
            }
        }

        RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
        ExReleaseResourceLite(&RxData.Resource);
    }

    return Status;
}

NTSTATUS
RxStopMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine stops a minirdr....a stopped minirdr will no longer accept new commands.

Arguments:

    RxContext - the context

    PostToFsp - the flag when set delays processing to the FSP.

Return Value:

    the Status of the STOP operaion ...

      STATUS_PENDING -- processing delayed to FSP

      STATUS_REDIRECTOR_HAS_OPEN_HANDLES -- cannot be stopped at this time

Notes:

    When a STOP request is issued to RDBSS there are ongoing requests in the
    RDBSS. Some of the requests can be cancelled while the remaining requests
    need to be processed to completion.

    There are a number of strategies that can be employed to close down the
    RDBSS. Currently, the most conservative approach is employed. The
    cancellation of those operations that can be cancelled and the STOP
    operation is held back till the remaining requests run through to completion.

    Subsequently, this will be revised so that the response times to STOP requests
    are smaller.

--*/
{
    NTSTATUS Status;
    BOOLEAN  Wait  = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN  InFSD = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    RxDbgTrace(0, Dbg, ("RxStopMinirdr [Stop] -> %08lx\n", 0));

    if (InFSD) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    if (!ExAcquireResourceExclusiveLite(&RxData.Resource, Wait)) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    try {

        KIRQL   SavedIrql;
        BOOLEAN fWait;

        ASSERT(BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP));


        if (RxDeviceObject->StartStopContext.State!=RDBSS_STARTED){
            RxDbgTrace(0, Dbg, ("RxStopMinirdr [Notstarted] -> %08lx\n", 0));
            try_return ( Status = STATUS_REDIRECTOR_NOT_STARTED );
        }
        // Wait for all the ongoing requests to be completed. When the RDBSS is
        // transitioned to the STOPPED state the last context to be completed
        // will complete the wait.

        // Terminate all the scavenging operations.
        RxTerminateScavenging(RxContext);

        RxDbgPrint(("Waiting for all contexts to be flushed\n"));
        KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );
        RemoveEntryList(&RxContext->ContextListEntry);
        RxDeviceObject->StartStopContext.State = RDBSS_STOP_IN_PROGRESS;
        RxDeviceObject->StartStopContext.pStopContext = RxContext;
        KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

        fWait = (InterlockedDecrement(&RxDeviceObject->NumberOfActiveContexts) != 0);

        if (fWait) {
           RxWaitSync(RxContext);
        }

        ASSERT(RxDeviceObject->NumberOfActiveContexts == 0);

        RxUnstart(RxContext,RxDeviceObject);

        RxSpinDownMRxDispatcher(RxDeviceObject);

	// inform hook we are stopping
	if (RxDeviceFCB.MRxDispatch != NULL && RxDeviceFCB.MRxDispatch->MRxStop) {
	    (void) RxDeviceFCB.MRxDispatch->MRxStop(RxContext, RxDeviceObject);
	}

        MINIRDR_CALL(
                  Status,
                  RxContext,
                  RxDeviceObject->Dispatch,
                  MRxStop,
                  (RxContext,RxDeviceObject)
                  );


        // If there are no residual FCB's the driver can be unloaded. If not the
        // driver must remain loaded so that close/cleanup operations on ORPHANED
        // FCB's can be completed.
        if (RxDeviceObject->NumberOfActiveFcbs == 0) {
            Status = STATUS_SUCCESS;
        } else {
            //ASSERT(!"OPENHANDLES!");
            Status = STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
        }

        RxSpinDownMRxDispatcher(RxDeviceObject);

        // All set to startup again.
        RxSetRdbssState(RxDeviceObject,RDBSS_STARTABLE);

try_exit: NOTHING;
    } finally {

        ExReleaseResourceLite( &RxData.Resource );
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Write called by the
    dispatch driver.

Author:

    Joe Linn      [JoeLinn]      2-Nov-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

BOOLEAN RxNoAsync = FALSE;


extern LONG LDWCount;
extern NTSTATUS LDWLastStatus;
extern LARGE_INTEGER LDWLastTime;
extern PVOID LDWContext;

NTSTATUS
RxLowIoWriteShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxLowIoWriteShellCompletion (
    IN PRX_CONTEXT RxContext
    );

#if DBG

//
//  defined in read.c
//

VOID CheckForLoudOperations (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

#endif

#ifdef RDBSS_TRACKER

VOID
__RxWriteReleaseResources(
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN BOOL fSetResourceOwner,
    IN ULONG LineNumber,
    IN PSZ FileName,
    IN ULONG SerialNumber
    );

#else

VOID
__RxWriteReleaseResources(
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN BOOL fSetResourceOwner
    );

#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonWrite)
#pragma alloc_text(PAGE, __RxWriteReleaseResources)
#pragma alloc_text(PAGE, RxLowIoWriteShellCompletion)
#pragma alloc_text(PAGE, RxLowIoWriteShell)
#endif

#if DBG
#define DECLARE_POSTIRP() PCHAR PostIrp = NULL
#define SET_POSTIRP(__XXX__) (PostIrp = (__XXX__))
#define RESET_POSTIRP() (PostIrp = NULL)
#else
#define DECLARE_POSTIRP() BOOLEAN PostIrp = FALSE
#define SET_POSTIRP(__XXX__) (PostIrp = TRUE)
#define RESET_POSTIRP() (PostIrp = FALSE)
#endif

#ifdef RDBSS_TRACKER
#define RxWriteReleaseResources(CTX,FCB, IS_TID) __RxWriteReleaseResources( CTX, FCB, IS_TID, __LINE__, __FILE__, 0 )
#else
#define RxWriteReleaseResources(CTX,FCB, IS_TID) __RxWriteReleaseResources( CTX, FCB, IS_TID )
#endif


#ifdef RDBSS_TRACKER

VOID
__RxWriteReleaseResources (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN BOOL fSetResourceOwner,
    IN ULONG LineNumber,
    IN PSZ FileName,
    IN ULONG SerialNumber
    )

#else

VOID
__RxWriteReleaseResources (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN BOOL fSetResourceOwner
    )

#endif

/*++

Routine Description:

    This function frees resources and tracks the state    
    
Arguments:

    RxContext - 

Return Value:

    none

--*/
{
    PAGED_CODE();

    ASSERT( (RxContext != NULL) && (Fcb != NULL) );

    if (RxContext->FcbResourceAcquired) {

        RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingFcb\n") );
        
        if( fSetResourceOwner ) {

            RxReleaseFcbForThread( RxContext, Fcb, RxContext->LowIoContext.ResourceThreadId );

        } else {

            RxReleaseFcb( RxContext, Fcb );
        }
        RxContext->FcbResourceAcquired = FALSE;
    }

    if (RxContext->FcbPagingIoResourceAcquired) {
        
        RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingPaginIo\n") );

        if( fSetResourceOwner ) {

            RxReleasePagingIoResourceForThread( RxContext, Fcb, RxContext->LowIoContext.ResourceThreadId );
        
        } else {

            RxReleasePagingIoResource( RxContext, Fcb );
        }
    }
}

NTSTATUS
RxCommonWrite ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common write routine for NtWriteFile, called from both
    the Fsd, or from the Fsp if a request could not be completed without
    blocking in the Fsd.  This routine's actions are
    conditionalized by the Wait input parameter, which determines whether
    it is allowed to block or not.  If a blocking condition is encountered
    with Wait == FALSE, however, the request is posted to the Fsp, who
    always calls with WAIT == TRUE.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    NODE_TYPE_CODE TypeOfOpen;

    PFCB Fcb;
    PFOBX Fobx;
    PSRV_OPEN SrvOpen; 
    PNET_ROOT NetRoot;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    LARGE_INTEGER StartingByte;
    RXVBO StartingVbo;
    ULONG ByteCount;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;
    LONGLONG InitialFileSize;
    LONGLONG InitialValidDataLength;

    ULONG CapturedRxContextSerialNumber = RxContext->SerialNumber;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

#if DBG
    PCHAR PostIrp = NULL;
#else
    BOOLEAN PostIrp = FALSE;
#endif

    BOOLEAN ExtendingFile = FALSE;
    BOOLEAN SwitchBackToAsync = FALSE;
    BOOLEAN CalledByLazyWriter = FALSE;
    BOOLEAN ExtendingValidData = FALSE;
    BOOLEAN WriteFileSizeToDirent = FALSE;
    BOOLEAN RecursiveWriteThrough = FALSE;
    BOOLEAN UnwindOutstandingAsync = FALSE;

    BOOLEAN RefdContextForTracker = FALSE;

    BOOLEAN SynchronousIo;
    BOOLEAN WriteToEof;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN Wait;
    
    BOOLEAN DiskWrite = FALSE;
    BOOLEAN PipeWrite = FALSE;
    BOOLEAN BlockingResume = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME );
    BOOLEAN fSetResourceOwner = FALSE;
    BOOLEAN InFsp = FALSE;


    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx );

    //
    //  Get rid of invalid write requests right away.
    //

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) && 
        (TypeOfOpen != RDBSS_NTC_VOLUME_FCB) && 
        (TypeOfOpen != RDBSS_NTC_SPOOLFILE) && 
        (TypeOfOpen != RDBSS_NTC_MAILSLOT)) {

        RxDbgTrace( 0, Dbg, ("Invalid file object for write\n", 0) );
        RxDbgTrace( -1, Dbg, ("RxCommonWrite:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST) );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

#ifdef RX_WJ_DBG_SUPPORT
    RxdUpdateJournalOnWriteInitiation( Fcb, IrpSp->Parameters.Write.ByteOffset, IrpSp->Parameters.Write.Length );
#endif

    NetRoot = (PNET_ROOT)Fcb->NetRoot;

    switch (NetRoot->Type) {
    
    case NET_ROOT_DISK:

        // 
        //  Fallthrough
        //  

    case NET_ROOT_WILD:

        DiskWrite = TRUE;
        break;  

    case NET_ROOT_PIPE:

        PipeWrite = TRUE;
        break;
    }

    BlockingResume = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME );

    //
    //  Initialize the appropriate local variables.
    //

    Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
    PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = BooleanFlagOn( Irp->Flags, IRP_NOCACHE );
    SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
    InFsp = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP );

    //
    //  pick up a write-through specified only for this irp
    //

    if (FlagOn( IrpSp->Flags, SL_WRITE_THROUGH )) {
        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH );
    }

    RxDbgTrace( +1, Dbg, ("RxCommonWrite...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb) );
    RxDbgTrace( 0, Dbg, ("  ->ByteCount = %08lx, ByteOffset = %08lx %lx\n",
                         IrpSp->Parameters.Write.Length,
                         IrpSp->Parameters.Write.ByteOffset.LowPart,
                         IrpSp->Parameters.Write.ByteOffset.HighPart) );
    RxDbgTrace( 0, Dbg,("  ->%s%s%s%s\n",
                    Wait          ?"Wait ":"",
                    PagingIo      ?"PagingIo ":"",
                    NonCachedIo   ?"NonCachedIo ":"",
                    SynchronousIo ?"SynchronousIo ":"") );

    RxLog(( "CommonWrite %lx %lx %lx\n", RxContext, Fobx, Fcb ));
    RxWmiLog( LOG,
              RxCommonWrite_1,
              LOGPTR( RxContext )
              LOGPTR( Fobx )
              LOGPTR( Fcb ) );
    RxLog(( "   write %lx@%lx %lx %s%s%s%s\n", 
            IrpSp->Parameters.Write.Length,
            IrpSp->Parameters.Write.ByteOffset.LowPart,
            IrpSp->Parameters.Write.ByteOffset.HighPart,
            Wait?"Wt":"",
            PagingIo?"Pg":"",
            NonCachedIo?"Nc":"",
            SynchronousIo?"Sy":"" )); 
    
    RxWmiLog( LOG,
              RxCommonWrite_2,
              LOGULONG( IrpSp->Parameters.Write.Length )
              LOGULONG( IrpSp->Parameters.Write.ByteOffset.LowPart )
              LOGULONG( IrpSp->Parameters.Write.ByteOffset.HighPart )
              LOGUCHAR( Wait )
              LOGUCHAR( PagingIo )
              LOGUCHAR( NonCachedIo )
              LOGUCHAR( SynchronousIo ) );

    RxItsTheSameContext();

    RxContext->FcbResourceAcquired = FALSE;
    RxContext->FcbPagingIoResourceAcquired = FALSE;

    //
    //  Extract starting Vbo and offset.
    //

    StartingByte = IrpSp->Parameters.Write.ByteOffset;
    StartingVbo = StartingByte.QuadPart;
    ByteCount = IrpSp->Parameters.Write.Length;
    WriteToEof = (StartingVbo < 0);


#if DBG
    CheckForLoudOperations( RxContext, Fcb );

    if (FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_LOUDOPS )) {
        
        DbgPrint( "LoudWrite %lx/%lx on %lx vdl/size/alloc %lx/%lx/%lx\n",
                  StartingByte.LowPart,ByteCount,
                  Fcb,
                  Fcb->Header.ValidDataLength.LowPart,
                  Fcb->Header.FileSize.LowPart,
                  Fcb->Header.AllocationSize.LowPart );
    }
#endif

    //
    //  Statistics............
    //

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP ) && 
        (Fcb->CachedNetRootType == NET_ROOT_DISK)) {
        
        InterlockedIncrement( &RxDeviceObject->WriteOperations );

        if (StartingVbo != Fobx->Specific.DiskFile.PredictedWriteOffset) {
            InterlockedIncrement( &RxDeviceObject->RandomWriteOperations );
        }

        Fobx->Specific.DiskFile.PredictedWriteOffset = StartingVbo + ByteCount;

        if (PagingIo) {
            ExInterlockedAddLargeStatistic( &RxDeviceObject->PagingWriteBytesRequested,ByteCount );
        } else if (NonCachedIo) {
            ExInterlockedAddLargeStatistic( &RxDeviceObject->NonPagingWriteBytesRequested,ByteCount );
        } else {
            ExInterlockedAddLargeStatistic( &RxDeviceObject->CacheWriteBytesRequested,ByteCount );
        }
    }

    //
    //  If there is nothing to write, return immediately or if the buffers are invalid
    //  return the appropriate status
    //
    
    if (DiskWrite && (ByteCount == 0)) {
        return STATUS_SUCCESS;
    } else if ((Irp->UserBuffer == NULL) && (Irp->MdlAddress == NULL)) {
        return STATUS_INVALID_PARAMETER;
    } else if ((MAXLONGLONG - StartingVbo < ByteCount) && (!WriteToEof)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Fobx != NULL ) {
        SrvOpen = Fobx->SrvOpen;
    } else {
        SrvOpen = NULL;            
    }

    //
    // See if we have to defer the write. Note that if write cacheing is
    // disabled then we don't have to check.
    //
    if (!NonCachedIo &&
        RxWriteCachingAllowed( Fcb, SrvOpen ) &&
        !CcCanIWrite( FileObject,
                      ByteCount,
                      (BOOLEAN)(Wait && !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP )),
                      BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_DEFERRED_WRITE ))) {

        BOOLEAN Retrying = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_DEFERRED_WRITE );

        RxPrePostIrp( RxContext, Irp );

        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_DEFERRED_WRITE );

        CcDeferWrite( FileObject,
                      (PCC_POST_DEFERRED_WRITE)RxAddToWorkque,
                      RxContext,
                      Irp,
                      ByteCount,
                      Retrying );

        return STATUS_PENDING;
    }

    //
    //  Initialize LowIO_CONTEXT block in the RxContext
    //

    RxInitializeLowIoContext( RxContext, LOWIO_OP_WRITE, LowIoContext );

    //
    //  Use a try-finally to free Fcb and buffers on the way out.
    //

    try {

        BOOLEAN DoLowIoWrite = TRUE;
        
        //
        // This case corresponds to a normal user write file.
        //

        ASSERT ((TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE ) || 
                (TypeOfOpen == RDBSS_NTC_SPOOLFILE) || 
                (TypeOfOpen == RDBSS_NTC_MAILSLOT) );

        RxDbgTrace( 0, Dbg, ("Type of write is user file open\n", 0) );

        //
        //  If this is a noncached transfer and is not a paging I/O, and
        //  the file has been opened cached, then we will do a flush here
        //  to avoid stale data problems.
        //
        //  The Purge following the flush will guarantee cache coherency.
        //

        if ((NonCachedIo || !RxWriteCachingAllowed( Fcb, SrvOpen )) &&
            !PagingIo &&
            (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {

            LARGE_INTEGER FlushBase;

            //
            //  We need the Fcb exclusive to do the CcPurgeCache
            //

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );
            if (Status == STATUS_LOCK_NOT_GRANTED) {
                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", Fcb) );

#if DBG
                PostIrp = "Couldn't acquireex for flush";
#else   
                PostIrp = TRUE;
#endif    

                try_return( PostIrp );

            } else if (Status != STATUS_SUCCESS) {
                
                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", Fcb) );
                try_return( PostIrp = FALSE );
           }

            RxContext->FcbResourceAcquired = TRUE;

            //
            //  we don't set fcbacquiredexclusive here since we either return or release
            //

            if (WriteToEof) {
                RxGetFileSizeWithLock( Fcb, &FlushBase.QuadPart );
            } else {
                FlushBase = StartingByte;
            }

            RxAcquirePagingIoResource( RxContext, Fcb );

            CcFlushCache( FileObject->SectionObjectPointer, //  ok4flush
                          &FlushBase,
                          ByteCount,
                          &Irp->IoStatus );

            RxReleasePagingIoResource( RxContext, Fcb );

            if (!NT_SUCCESS( Irp->IoStatus.Status)) {
                try_return( Status = Irp->IoStatus.Status );
            }

            RxAcquirePagingIoResource( RxContext, Fcb );
            RxReleasePagingIoResource( RxContext, Fcb );
            
            CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                 &FlushBase,
                                 ByteCount,
                                 FALSE );
        }

        //
        //  We assert that Paging Io writes will never WriteToEof.
        //

        ASSERT( !(WriteToEof && PagingIo) );

        //
        //  First let's acquire the Fcb shared.  Shared is enough if we
        //  are not writing beyond EOF.
        //

        RxItsTheSameContext();

        if (PagingIo) {
            BOOLEAN AcquiredFile;

            ASSERT( !PipeWrite );

            AcquiredFile = RxAcquirePagingIoResourceShared( RxContext, Fcb, TRUE );
            LowIoContext->Resource = Fcb->Header.PagingIoResource;

        } else if (!BlockingResume) {
            
            //
            //  If this could be async, noncached IO we need to check that
            //  we don't exhaust the number of times a single thread can
            //  acquire the resource.
            //
            //  The writes which extend the valid data length result in the the
            //  capability of collapsing opens being renounced. This is required to
            //  ensure that directory control can see the updated state of the file
            //  on close. If this is not done the extended file length is not visible
            //  on directory control immediately after a close. In such cases the FCB
            //  is accquired exclusive, the changes are made to the buffering state
            //  and then downgraded to a shared accquisition.
            //

            if (!RxContext->FcbResourceAcquired) {
                if (!PipeWrite) {
                    if (!Wait &&
                        (NonCachedIo || !RxWriteCachingAllowed( Fcb, SrvOpen ))) {
                        Status = RxAcquireSharedFcbWaitForEx( RxContext, Fcb );
                    } else {
                        Status = RxAcquireSharedFcb( RxContext, Fcb );
                    }
                } else {
                    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
                }

                if (Status == STATUS_LOCK_NOT_GRANTED) {
                    RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", Fcb ));
                    
#if DBG
                    PostIrp = "Couldn't get mainr w/o waiting sh";
#else   
                    PostIrp = TRUE;
#endif    
                    try_return( PostIrp );
                
                } else if (Status != STATUS_SUCCESS) {
                    
                    RxDbgTrace( 0, Dbg, ("RxCommonWrite : Cannot acquire Fcb(%lx) %lx\n", Fcb, Status) );
                    try_return( PostIrp = FALSE );
                }
                RxContext->FcbResourceAcquired = TRUE;
            
            } else {
                ASSERT( !PipeWrite );
            }

            if (!PipeWrite) {

                //
                //  Check for extending write and convert to an exlusive lock
                //  

                if (ExIsResourceAcquiredSharedLite( Fcb->Header.Resource ) &&
                    (StartingVbo + ByteCount > Fcb->Header.ValidDataLength.QuadPart) &&
                    FlagOn( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED )) {

                    RxReleaseFcb( RxContext,Fcb );
                    RxContext->FcbResourceAcquired = FALSE;

                    Status = RxAcquireExclusiveFcb( RxContext, Fcb );

                    if (Status == STATUS_LOCK_NOT_GRANTED) {
                        RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", Fcb) );
#if DBG
                        PostIrp = "Couldn't get mainr w/o waiting sh";
#else   
                        PostIrp = TRUE;
#endif    
                        try_return( PostIrp );
                    
                    } else if (Status != STATUS_SUCCESS) {
                        
                        RxDbgTrace( 0, Dbg, ("RxCommonWrite : Cannot acquire Fcb(%lx) %lx\n", Fcb, Status) );
                        try_return( PostIrp = FALSE );

                    } else {
                        RxContext->FcbResourceAcquired = TRUE;
                    }
                }

                //
                //  We need to retest for extending writes after dropping the resources
                // 

                if ((StartingVbo + ByteCount > Fcb->Header.ValidDataLength.QuadPart) &&
                    (FlagOn( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED ))) {
                    
                    ASSERT( RxIsFcbAcquiredExclusive ( Fcb ) );

                    RxLog(("RxCommonWrite Disable Collapsing %lx\n",Fcb));
                    RxWmiLog( LOG,
                              RxCommonWrite_3,
                              LOGPTR( Fcb ));

                    //
                    //  If we are still extending the file disable collapsing to ensure that
                    //  once the file is closed directory control will reflect the sizes
                    //  correctly.
                    //

                    ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );
                
                } else {
                    
                    //
                    //  If the resource has been acquired exclusive we downgrade it
                    //  to shared. This enables a combination of buffered and
                    //  unbuffered writes to be synchronized correctly.
                    //

                    if (ExIsResourceAcquiredExclusiveLite( Fcb->Header.Resource )) {
                        ExConvertExclusiveToSharedLite( Fcb->Header.Resource );
                    }
                }
            }

            ASSERT( RxContext->FcbResourceAcquired );
            LowIoContext->Resource =  Fcb->Header.Resource;
        }

        // 
        //  for pipe writes, bail out now. we avoid a goto by duplicating the calldown
        //  indeed, pipe writes should be removed from the main path.
        //

        if (PipeWrite) {

            //
            //  In order to prevent corruption on multi-threaded multi-block
            //  message mode pipe reads, we do this little dance with the fcb resource
            //

            if (!BlockingResume) {

                if ((Fobx != NULL) &&
                    ((Fobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_MESSAGE_TYPE) ||
                     ((Fobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_BYTE_STREAM_TYPE) &&
                      !FlagOn( Fobx->Specific.NamedPipe.CompletionMode, FILE_PIPE_COMPLETE_OPERATION )))) {

                    //
                    //  Synchronization is effected here that will prevent other
                    //  threads from coming in and reading from this file while the
                    //  message pipe read is continuing.
                    //
                    //  This is necessary because we will release the FCB lock while
                    //  actually performing the I/O to allow open (and other) requests
                    //  to continue on this file while the I/O is in progress.
                    //

                    RxDbgTrace( 0,Dbg,("Message pipe write: Fobx: %lx, Fcb: %lx, Enqueuing...\n", Fobx, Fcb ));

                    Status = RxSynchronizeBlockingOperationsAndDropFcbLock( RxContext,
                                                                            Fcb,    
                                                                            &Fobx->Specific.NamedPipe.WriteSerializationQueue );


                    //
                    //  this happens in the above routine
                    //

                    RxContext->FcbResourceAcquired = FALSE;   
                    RxItsTheSameContext();

                    if (!NT_SUCCESS(Status) ||
                        (Status == STATUS_PENDING)) {
                        
                        try_return( Status );
                    }

                    RxDbgTrace( 0,Dbg,("Succeeded: Fobx: %lx\n", Fobx) );
                }
            }

            LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
            LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;

            SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION );

            //
            // If we are in FSP, set the resource owner so that the reosurce package doesnt
            // try to boost the priority of the owner thread. There is no guarantee that the
            // FSP thred will remain alive while the I/O is pending.
            //
            // (there is no PagingIoResource for pipes !)
            //
            if( InFsp && RxContext->FcbResourceAcquired ) {

                LowIoContext->ResourceThreadId = MAKE_RESOURCE_OWNER(RxContext);
                ExSetResourceOwnerPointer(Fcb->Header.Resource, (PVOID)LowIoContext->ResourceThreadId);
                fSetResourceOwner = TRUE;
            }

            Status = RxLowIoWriteShell( RxContext, Irp, Fcb );
            RxItsTheSameContext();
            try_return( Status );
        }

        //
        //  If this is the normal data stream object we have to check for
        //  write access according to the current state of the file locks.
        //

        if (!PagingIo &&
            !FsRtlCheckLockForWriteAccess(  &Fcb->FileLock, Irp )) {

            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
        }

        //
        //  we never write these without protextion...so the following comment is bogus.
        //  also, we manipulate the vdl and filesize as if we owned them.....in fact, we don't unless
        //  the file is cached for writing! i'm leaving the comment in case i understand it later

        //  HERE IS THE BOGUS COMMENT!!! (the part about not being protected.......)
        //  Get a first tentative file size and valid data length.
        //  We must get ValidDataLength first since it is always
        //  increased second (the case we are unprotected) and
        //  we don't want to capture ValidDataLength > FileSize.
        //

        ValidDataLength = Fcb->Header.ValidDataLength.QuadPart;
        RxGetFileSizeWithLock( Fcb, &FileSize );

        ASSERT( ValidDataLength <= FileSize );

        //
        //  If this is paging io, then we do not want
        //  to write beyond end of file.  If the base is beyond Eof, we will just
        //  Noop the call.  If the transfer starts before Eof, but extends
        //  beyond, we will limit write to file size.
        //  Otherwise, in case of write through, since Mm rounds up
        //  to a page, we might try to acquire the resource exclusive
        //  when our top level guy only acquired it shared. Thus, =><=.
        //

        //
        //  finally, if this is for a minirdr (as opposed to a local miniFS) AND
        //  if cacheing is not enabled then i have no idea what VDL is! so, i have to just pass
        //  it thru. Currently we do not provide for this case and let the RDBSS
        //  throw the write on the floor. A better fix would be to let the mini
        //  redirectors deal with it.
        //

        if (PagingIo) {
            
            if (StartingVbo >= FileSize) {

                RxDbgTrace( 0, Dbg, ("PagingIo started beyond EOF.\n", 0) );
                try_return( Status = STATUS_SUCCESS );
            }

            if (ByteCount > FileSize - StartingVbo) {

                RxDbgTrace( 0, Dbg, ("PagingIo extending beyond EOF.\n", 0) );
                ByteCount = (ULONG)(FileSize - StartingVbo);
            }
        }

        //
        //  Determine if we were called by the lazywriter.
        //  see resrcsup.c for where we captured the lazywriter's thread
        //

        if (RxGetTopIrpIfRdbssIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP) {

            RxDbgTrace( 0, Dbg,("RxCommonWrite     ThisIsCalledByLazyWriter%c\n",'!'));
            CalledByLazyWriter = TRUE;

            if (FlagOn( Fcb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {

                //
                //  Fail if the start of this request is beyond valid data length.
                //  Don't worry if this is an unsafe test.  MM and CC won't
                //  throw this page away if it is really dirty.
                //

                if ((StartingVbo + ByteCount > ValidDataLength) &&
                    (StartingVbo < FileSize)) {

                    //
                    //  It's OK if byte range is within the page containing valid data length,
                    //  since we will use ValidDataToDisk as the start point.
                    //

                    if (StartingVbo + ByteCount > ((ValidDataLength + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))) {

                        //
                        //  Don't flush this now.
                        //

                        try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                    }
                }
            }
        }

        //
        //  This code detects if we are a recursive synchronous page write
        //  on a write through file object.
        //

        if (FlagOn( Irp->Flags, IRP_SYNCHRONOUS_PAGING_IO ) &&
            FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_RECURSIVE_CALL )) {

            PIRP TopIrp;

            TopIrp = RxGetTopIrpIfRdbssIrp();

            //
            //  This clause determines if the top level request was
            //  in the FastIo path.
            //

            if ((TopIrp != NULL) &&
                ((ULONG_PTR)TopIrp > FSRTL_MAX_TOP_LEVEL_IRP_FLAG) ) {

                PIO_STACK_LOCATION IrpStack;

                ASSERT( NodeType(TopIrp) == IO_TYPE_IRP );

                IrpStack = IoGetCurrentIrpStackLocation(TopIrp);

                //
                //  Finally this routine detects if the Top irp was a
                //  write to this file and thus we are the writethrough.
                //

                if ((IrpStack->MajorFunction == IRP_MJ_WRITE) &&
                    (IrpStack->FileObject->FsContext == FileObject->FsContext)) {   //  ok4->FileObj butmove

                    RecursiveWriteThrough = TRUE;
                    RxDbgTrace( 0, Dbg,("RxCommonWrite     ThisIsRecursiveWriteThru%c\n",'!') );
                    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH );
                }
            }
        }

        //
        //  Here is the deal with ValidDataLength and FileSize:
        //
        //  Rule 1: PagingIo is never allowed to extend file size.
        //
        //  Rule 2: Only the top level requestor may extend Valid
        //          Data Length.  This may be paging IO, as when a
        //          a user maps a file, but will never be as a result
        //          of cache lazy writer writes since they are not the
        //          top level request.
        //
        //  Rule 3: If, using Rules 1 and 2, we decide we must extend
        //          file size or valid data, we take the Fcb exclusive.
        //

        //
        //  Now see if we are writing beyond valid data length, and thus
        //  maybe beyond the file size.  If so, then we must
        //  release the Fcb and reacquire it exclusive.  Note that it is
        //  important that when not writing beyond EOF that we check it
        //  while acquired shared and keep the FCB acquired, in case some
        //  turkey truncates the file.
        //

        //
        //  Note that the lazy writer must not be allowed to try and
        //  acquire the resource exclusive.  This is not a problem since
        //  the lazy writer is paging IO and thus not allowed to extend
        //  file size, and is never the top level guy, thus not able to
        //  extend valid data length.

        //
        //  finally, all the discussion of VDL and filesize is conditioned on the fact
        //  that cacheing is enabled. if not, we don't know the VDL OR the filesize and
        //  we have to just send out the IOs
        //

        if (!CalledByLazyWriter &&
             !RecursiveWriteThrough &&
             (WriteToEof || (StartingVbo + ByteCount > ValidDataLength))) {

            //
            //  If this was an asynchronous write, we are going to make
            //  the request synchronous at this point, but only temporarily.
            //  At the last moment, before sending the write off to the
            //  driver, we may shift back to async.
            //
            //  The modified page writer already has the resources
            //  he requires, so this will complete in small finite
            //  time.
            //

            if (!SynchronousIo) {
                
                Wait = TRUE;
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
                ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
                SynchronousIo = TRUE;

                if (NonCachedIo) {
                    SwitchBackToAsync = TRUE;
                }
            }

            //
            //  We need Exclusive access to the Fcb since we will
            //  probably have to extend valid data and/or file.  Drop
            //  whatever we have and grab the normal resource exclusive.
            //

            ASSERT(fSetResourceOwner == FALSE);
            RxWriteReleaseResources( RxContext, Fcb, fSetResourceOwner ); 

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );

            if (Status == STATUS_LOCK_NOT_GRANTED) {
                
                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", Fcb) );

#if DBG
                PostIrp = "could get excl for extend";
#else   
                PostIrp = TRUE;
#endif    
                try_return( PostIrp);

            } else if (Status != STATUS_SUCCESS) {
                
                RxDbgTrace( 0, Dbg, ("RxCommonWrite : Cannot acquire Fcb(%lx) : %lx\n", Fcb,Status) );
                try_return( PostIrp = FALSE );
            }

            RxItsTheSameContext();

            RxContext->FcbResourceAcquired = TRUE;

            //
            //  Now that we have the Fcb exclusive, get a new batch of
            //  filesize and ValidDataLength.
            //

            ValidDataLength = Fcb->Header.ValidDataLength.QuadPart;
            RxGetFileSizeWithLock( Fcb, &FileSize );

            ASSERT( ValidDataLength <= FileSize );

            //
            //  Now that we have the Fcb exclusive, see if this write
            //  qualifies for being made async again.  The key point
            //  here is that we are going to update ValidDataLength in
            //  the Fcb before returning.  We must make sure this will
            //  not cause a problem. So, if we are extending the file OR if we have
            //  a section on the file, we can't go async.
            //
            //  Another thing we must do is keep out
            //  the FastIo path.....this is done since we have the resource exclusive
            //

            if (SwitchBackToAsync) {

                if ((Fcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL) || 
                    ((StartingVbo + ByteCount) > FileSize) ||  
                    RxNoAsync) {

                    SwitchBackToAsync = FALSE;

                } 
            }

            //
            //  If this is PagingIo check again if any pruning is
            //  required.
            //

            if (PagingIo) {

                if (StartingVbo >= FileSize) {
                    try_return( Status = STATUS_SUCCESS );
                }
                if (ByteCount > FileSize - StartingVbo) {
                    ByteCount = (ULONG)(FileSize - StartingVbo);
                }
            }
        }

        //
        //  Remember the initial file size and valid data length,
        //  just in case .....
        //

        InitialFileSize = FileSize;
        InitialValidDataLength = ValidDataLength;

        //
        //  Check for writing to end of File.  If we are, then we have to
        //  recalculate a number of fields. These may have changed if we dropped
        //  and regained the resource.
        //

        if (WriteToEof) { 
            StartingVbo = FileSize;
            StartingByte.QuadPart = FileSize;
        }

        //
        //  If this is the normal data stream object we have to check for
        //  write access according to the current state of the file locks.
        //

        if (!PagingIo &&
            !FsRtlCheckLockForWriteAccess( &Fcb->FileLock, Irp )) {

            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
        }

        //
        //  Determine if we will deal with extending the file.
        //

        if (!PagingIo &&
            DiskWrite &&
            (StartingVbo >= 0) &&
            (StartingVbo + ByteCount > FileSize)) {

            LARGE_INTEGER OriginalFileSize;
            LARGE_INTEGER OriginalAllocationSize;
            LARGE_INTEGER OriginalValidDataLength;
            
            RxLog(( "NeedToExtending %lx", RxContext ));
            RxWmiLog( LOG,
                      RxCommonWrite_4,
                      LOGPTR( RxContext ) );
            
            ExtendingFile = TRUE;
            SetFlag( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_EXTENDING_FILESIZE );

            //
            //  EXTENDING THE FILE
            //
            //  Update our local copy of FileSize
            //

            OriginalFileSize.QuadPart = Fcb->Header.FileSize.QuadPart;
            OriginalAllocationSize.QuadPart = Fcb->Header.AllocationSize.QuadPart;
            OriginalValidDataLength.QuadPart = Fcb->Header.ValidDataLength.QuadPart;

            FileSize = StartingVbo + ByteCount;

            if (FileSize > Fcb->Header.AllocationSize.QuadPart) {

                LARGE_INTEGER AllocationSize;

                RxLog(( "Extending %lx", RxContext ));
                RxWmiLog( LOG,
                          RxCommonWrite_5,
                          LOGPTR( RxContext ) );
                
                if (NonCachedIo || !RxWriteCachingAllowed( Fcb, SrvOpen )) {
                    
                    MINIRDR_CALL( Status,
                                  RxContext,
                                  Fcb->MRxDispatch,
                                  MRxExtendForNonCache,
                                  (RxContext,
                                   (PLARGE_INTEGER)&FileSize, &AllocationSize) );
                } else {
                    
                    MINIRDR_CALL( Status,
                                  RxContext,
                                  Fcb->MRxDispatch,
                                  MRxExtendForCache,
                                  (RxContext,(PLARGE_INTEGER)&FileSize,&AllocationSize) );
                }

                if (!NT_SUCCESS( Status )) {
                    
                    RxDbgTrace(0, Dbg, ("Couldn't extend for cacheing.\n", 0) );
                    try_return( Status );
                }

                if (FileSize > AllocationSize.QuadPart) {
                    
                    //
                    //  When the file is sparse this test is not valid. exclude
                    //  this case by resetting the allocation size to file size.
                    //  This effectively implies that we will go to the server
                    //  for sparse I/O.
                    //
                    //  This test is also not valid for compressed files. NTFS
                    //  keeps track of the compressed file size and the uncompressed
                    //  file size. It however returns the compressed file size for
                    //  directory queries and information queries.
                    //
                    //  For now we rely on the servers return code. If it returned
                    //  success and the allocation size is less we believe that
                    //  it is one of the two cases above and set allocation size
                    //  to the desired file size.
                    //

                    AllocationSize.QuadPart = FileSize;
                }

                //
                //  Set the new file allocation in the Fcb.
                //
                
                Fcb->Header.AllocationSize  = AllocationSize;
            }

            //
            //  Set the new file size in the Fcb.
            //

            RxSetFileSizeWithLock( Fcb, &FileSize );
            RxAdjustAllocationSizeforCC( Fcb );

            //
            //  Extend the cache map, letting mm knows the new file size.
            //  We only have to do this if the file is cached.
            //

            if (CcIsFileCached( FileObject )) {
                
                try {
                    CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = GetExceptionCode();
                }

                if (Status != STATUS_SUCCESS) {

                    //
                    //  Restore the original file sizes in the FCB and File object
                    //

                    Fcb->Header.FileSize.QuadPart = OriginalFileSize.QuadPart;
                    Fcb->Header.AllocationSize.QuadPart = OriginalAllocationSize.QuadPart;
                    Fcb->Header.ValidDataLength.QuadPart = OriginalValidDataLength.QuadPart;

                    if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                        *CcGetFileSizePointer( FileObject ) = Fcb->Header.FileSize;
                    }
                    
                    try_return( Status );
                }
            }
        }

        //
        //  Determine if we will deal with extending valid data.
        //

        if (!CalledByLazyWriter &&
            !RecursiveWriteThrough &&
            (WriteToEof || (StartingVbo + ByteCount > ValidDataLength ))) {
            
            ExtendingValidData = TRUE;
            SetFlag( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_EXTENDING_VDL );
        }

        //
        //  HANDLE CACHED CASE
        //

        if (!PagingIo &&
            !NonCachedIo &&             //  this part is not discretionary
            RxWriteCachingAllowed( Fcb, SrvOpen ) ) {

            ASSERT( !PagingIo );

            //
            //  We delay setting up the file cache until now, in case the
            //  caller never does any I/O to the file, and thus
            //  FileObject->PrivateCacheMap == NULL.
            //

            if (FileObject->PrivateCacheMap == NULL) {

                RxDbgTrace( 0, Dbg, ("Initialize cache mapping.\n", 0) );

                //
                // If this FileObject has gone through CleanUp, we cannot
                // CcInitializeCacheMap it.
                //
                if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {
                    Status = STATUS_FILE_CLOSED;
                    try_return( Status );
                }

                RxAdjustAllocationSizeforCC( Fcb );

                //
                //  Now initialize the cache map.
                //

                try {
                    
                    Status = STATUS_SUCCESS;

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&Fcb->Header.AllocationSize,
                                          FALSE,
                                          &RxData.CacheManagerCallbacks,
                                          Fcb );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    
                      Status = GetExceptionCode();
                }

                if (Status != STATUS_SUCCESS) {
                    try_return( Status );
                }

                CcSetReadAheadGranularity( FileObject,
                                           NetRoot->DiskParameters.ReadAheadGranularity );
            }

            //
            //  For local file systems, there's a call here to zero data from VDL
            //  to starting VBO....for remote FSs, that happens on the other end.
            //

            //
            //  DO A NORMAL CACHED WRITE, if the MDL bit is not set,
            //

            if (!FlagOn( RxContext->MinorFunction, IRP_MN_MDL )) {

                PVOID SystemBuffer;
#if DBG
                ULONG SaveExceptionFlag;
#endif

                RxDbgTrace( 0, Dbg, ("Cached write.\n", 0) );

                //
                //  Get hold of the user's buffer.
                //

                SystemBuffer = RxMapUserBuffer( RxContext, Irp );
                if (SystemBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    try_return( Status );
                }

                //
                //  Make sure that a returned exception clears the breakpoint in the filter
                //

                RxSaveAndSetExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );

                //
                //  Do the write, possibly writing through
                //

                RxItsTheSameContext();
                
                if (!CcCopyWrite( FileObject,
                                  &StartingByte,
                                  ByteCount,
                                  Wait,
                                  SystemBuffer )) {

                    RxDbgTrace( 0, Dbg, ("Cached Write could not wait\n", 0) );
                    RxRestoreExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );

                    RxItsTheSameContext();

                    RxLog(( "CcCW2 FO %lx Of %lx Si %lx St %lx\n", FileObject, Fcb->Header.FileSize.LowPart, ByteCount, Status ));
                    RxWmiLog( LOG,
                              RxCommonWrite_6,
                              LOGPTR( FileObject )
                              LOGULONG( Fcb->Header.FileSize.LowPart )
                              LOGULONG( ByteCount )
                              LOGULONG( Status ));

                    try_return( SET_POSTIRP("cccopywritefailed") );
                }

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = ByteCount;
                RxRestoreExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );
                RxItsTheSameContext();

                RxLog(( "CcCW3 FO %lx Of %lx Si %lx St %lx\n", FileObject, Fcb->Header.FileSize.LowPart, ByteCount, Status ));
                RxWmiLog( LOG,
                          RxCommonWrite_7,
                          LOGPTR( FileObject )
                          LOGULONG( Fcb->Header.FileSize.LowPart )
                          LOGULONG( ByteCount )
                          LOGULONG( Status ) );

                try_return( Status = STATUS_SUCCESS );
            
            } else {

                //
                //  DO AN MDL WRITE
                //

                RxDbgTrace( 0, Dbg, ("MDL write.\n", 0) );

                ASSERT( FALSE );  //  NOT YET IMPLEMENTED
                ASSERT( Wait );

                CcPrepareMdlWrite( FileObject,
                                   &StartingByte,
                                   ByteCount,
                                   &Irp->MdlAddress,
                                   &Irp->IoStatus );

                Status = Irp->IoStatus.Status;
                try_return( Status );
            }
        }

        //
        //  HANDLE THE NON-CACHED CASE
        //

        if (SwitchBackToAsync) {

            Wait = FALSE;
            SynchronousIo = FALSE;
            ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        }

        if (!SynchronousIo) {

            //
            //  here we have to setup for async writes. there is a special dance in acquiring
            //  the fcb that looks at these variables..........
            //

            //
            //  only init on the first usage
            //

            if (!Fcb->NonPaged->OutstandingAsyncEvent) {

                Fcb->NonPaged->OutstandingAsyncEvent = &Fcb->NonPaged->TheActualEvent;

                KeInitializeEvent( Fcb->NonPaged->OutstandingAsyncEvent, NotificationEvent, FALSE );
            }

            //
            //  If we are transitioning from 0 to 1, reset the event.
            //

            if (ExInterlockedAddUlong( &Fcb->NonPaged->OutstandingAsyncWrites, 1, &RxStrucSupSpinLock ) == 0) {
                KeResetEvent( Fcb->NonPaged->OutstandingAsyncEvent );
            }

            //
            //  this says that we counted an async write
            //

            UnwindOutstandingAsync = TRUE;    
            LowIoContext->ParamsFor.ReadWrite.NonPagedFcb = Fcb->NonPaged;
        }


        LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
        LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;

        RxDbgTrace( 0, Dbg,("RxCommonWriteJustBeforeCalldown     %s%s%s lowiononpaged is \n",
                        RxContext->FcbResourceAcquired          ?"FcbAcquired ":"",
                        RxContext->FcbPagingIoResourceAcquired   ?"PagingIoResourceAcquired ":"",
                        (LowIoContext->ParamsFor.ReadWrite.NonPagedFcb)?"NonNull":"Null" ));

        RxItsTheSameContext();
        
        ASSERT ( RxContext->FcbResourceAcquired || RxContext->FcbPagingIoResourceAcquired );

        //
        // If we are in FSP, set the resource owner so that the reosurce package doesnt
        // try to boost the priority of the owner thread. There is no guarantee that the
        // FSP thred will remain alive while the I/O is pending.
        //
        if(InFsp) {

            LowIoContext->ResourceThreadId = MAKE_RESOURCE_OWNER(RxContext);
            if ( RxContext->FcbResourceAcquired ) {

                ExSetResourceOwnerPointer( Fcb->Header.Resource, (PVOID)LowIoContext->ResourceThreadId );
            }

            if ( RxContext->FcbPagingIoResourceAcquired ) {

                ExSetResourceOwnerPointer( Fcb->Header.PagingIoResource, (PVOID)LowIoContext->ResourceThreadId );
            }
            fSetResourceOwner = TRUE;
        }

        Status = RxLowIoWriteShell( RxContext, Irp, Fcb );

        RxItsTheSameContext();
        if (UnwindOutstandingAsync && (Status == STATUS_PENDING)) {
            UnwindOutstandingAsync = FALSE;
        }

        try_return( Status );

    try_exit: NOTHING;

        ASSERT( Irp );

        RxItsTheSameContext();
        if (!PostIrp) {

            RxDbgTrace( 0, Dbg, ("CommonWrite InnerFinally->  %08lx,%08lx\n",
                                     Status, Irp->IoStatus.Information) );

            if (!PipeWrite) {

                //
                //  Record the total number of bytes actually written
                //

                if (!PagingIo && NT_SUCCESS( Status ) &&
                    FlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO )) {
                    
                    FileObject->CurrentByteOffset.QuadPart = StartingVbo + Irp->IoStatus.Information;
                }

                //
                //  The following are things we only do if we were successful
                //

                if (NT_SUCCESS( Status ) && (Status != STATUS_PENDING)) {

                    //
                    //  If this was not PagingIo, mark that the modify
                    //  time on the dirent needs to be updated on close.
                    //

                    if (!PagingIo) {

                        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
                    }

                    if (ExtendingFile) {

                        SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
                    }

                    if (ExtendingValidData) {

                        LONGLONG EndingVboWritten = StartingVbo + Irp->IoStatus.Information;

                        //
                        //  Never set a ValidDataLength greater than FileSize.
                        //

                        if (FileSize < EndingVboWritten) {
                            Fcb->Header.ValidDataLength.QuadPart = FileSize;
                        } else {
                            Fcb->Header.ValidDataLength.QuadPart = EndingVboWritten;
                        }

                        //
                        //  Now, if we are noncached and the file is cached, we must
                        //  tell the cache manager about the VDL extension so that
                        //  async cached IO will not be optimized into zero-page faults
                        //  beyond where it believes VDL is.
                        //
                        //  In the cached case, since Cc did the work, it has updated
                        //  itself already.
                        //

                        if (NonCachedIo && CcIsFileCached( FileObject )) {
                            CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );
                        }
                    }
                }
            }
        } else {

            //
            //  Take action on extending writes if we're going to post
            //

            if (ExtendingFile && !PipeWrite) {

                ASSERT( RxWriteCachingAllowed( Fcb,SrvOpen ) );

                //
                //  We need the PagingIo resource exclusive whenever we
                //  pull back either file size or valid data length.
                //

                ASSERT( Fcb->Header.PagingIoResource != NULL );

                RxAcquirePagingIoResource( RxContext, Fcb );

                RxSetFileSizeWithLock( Fcb, &InitialFileSize );
                RxReleasePagingIoResource( RxContext, Fcb );

                //
                //  Pull back the cache map as well
                //

                if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                    *CcGetFileSizePointer(FileObject) = Fcb->Header.FileSize;
                }
            }

            RxDbgTrace( 0, Dbg, ("Passing request to Fsp\n", 0) );

            InterlockedIncrement( &RxContext->ReferenceCount );
            RefdContextForTracker = TRUE;

            //
            //  we only do this here because we're having a problem finding out why resources
            //  are not released.
            //
            
            //
            //  release whatever resources we may have
            //
            ASSERT(fSetResourceOwner == FALSE);
            RxWriteReleaseResources( RxContext, Fcb, fSetResourceOwner ); 

#ifdef RDBSS_TRACKER
            if (RxContext->AcquireReleaseFcbTrackerX != 0) {
                DbgPrint("TrackerNBadBeforePost %08lx %08lx\n",RxContext,&PostIrp);
                ASSERT(!"BadTrackerBeforePost");
            }
#endif //  ifdef RDBSS_TRACKER
            Status = RxFsdPostRequest( RxContext );
        }

    } finally {

        DebugUnwind( RxCommonWrite );

        if (AbnormalTermination()) {
            
            //
            //  Restore initial file size and valid data length
            //

            if ((ExtendingFile || ExtendingValidData) && !PipeWrite) {

                //
                //  We got an error, pull back the file size if we extended it.
                //
                //  We need the PagingIo resource exclusive whenever we
                //  pull back either file size or valid data length.
                //

                ASSERT( Fcb->Header.PagingIoResource != NULL );

                RxAcquirePagingIoResource( RxContext, Fcb );

                RxSetFileSizeWithLock( Fcb, &InitialFileSize );

                Fcb->Header.ValidDataLength.QuadPart = InitialValidDataLength;

                RxReleasePagingIoResource( RxContext, Fcb );

                //
                //  Pull back the cache map as well
                //

                if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                    *CcGetFileSizePointer(FileObject) = Fcb->Header.FileSize;
                }
            }
        }

        //
        //  Check if this needs to be backed out.
        //

        if (UnwindOutstandingAsync) {

            ASSERT( !PipeWrite );
            ExInterlockedAddUlong( &Fcb->NonPaged->OutstandingAsyncWrites,
                                   0xffffffff,
                                   &RxStrucSupSpinLock );

            KeSetEvent( LowIoContext->ParamsFor.ReadWrite.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
        }
#if 0
        //
        //  If we did an MDL write, and we are going to complete the request
        //  successfully, keep the resource acquired, reducing to shared
        //  if it was acquired exclusive.
        //

        if (FlagOn( RxContext->MinorFunction, IRP_MN_MDL ) &&
            !PostIrp &&
            !AbnormalTermination() &&
            NT_SUCCESS( Status )) {

            ASSERT( FcbAcquired && !PagingIoResourceAcquired );

            FcbAcquired = FALSE;

            if (FcbAcquiredExclusive) {

                ExConvertExclusiveToSharedLite( Fcb->Header.Resource );
            }
        }
#endif
        //
        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //     3) if we posted the request
        //

        if (AbnormalTermination() || (Status != STATUS_PENDING) || PostIrp) {
            if (!PostIrp) {

                //
                //  release whatever resources we may have
                //

                RxWriteReleaseResources( RxContext, Fcb, fSetResourceOwner ); 
            }

            if (RefdContextForTracker) {
                RxDereferenceAndDeleteRxContext( RxContext );
            }

            if (!PostIrp) {
                if (FlagOn( RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION )) {
                    
                    RxResumeBlockedOperations_Serially( RxContext, &Fobx->Specific.NamedPipe.WriteSerializationQueue );
                }
            }

            if (Status == STATUS_SUCCESS) {
                ASSERT( Irp->IoStatus.Information <= IrpSp->Parameters.Write.Length );
            }
        } else {

            //
            //  here the guy below is going to handle the completion....but, we don't know the finish
            //  order....in all likelihood the deletecontext call below just reduces the refcount
            //  but the guy may already have finished in which case this will really delete the context.
            //

            ASSERT( !SynchronousIo );
            RxDereferenceAndDeleteRxContext( RxContext );
        }

        RxDbgTrace( -1, Dbg, ("CommonWrite -> %08lx\n", Status) );

        if ((Status != STATUS_PENDING) && (Status != STATUS_SUCCESS) && PagingIo) {
                
            RxLogRetail(( "PgWrtFail %x %x %x\n", Fcb, NetRoot, Status ));
            InterlockedIncrement( &LDWCount );
            KeQuerySystemTime( &LDWLastTime );
            LDWLastStatus = Status;
            LDWContext = Fcb;
        }

    } //  finally

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
RxLowIoWriteShellCompletion (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine postprocesses a write request after it comes back from the
    minirdr.  It does callouts to handle compression, buffering and
    shadowing.  It is the opposite number of LowIoWriteShell.

    This will be called from LowIo; for async, originally in the
    completion routine.  If RxStatus(MORE_PROCESSING_REQUIRED) is returned,
    LowIo will call again in a thread.  If this was syncIo, you'll be back
    in the user's thread; if async, lowIo will requeue to a thread.
    Currrently, we always get to a thread before anything; this is a bit slower
    than completing at DPC time,
    but it's aheckuva lot safer and we may often have stuff to do
    (like decompressing, shadowing, etc) that we don't want to do at DPC
    time.

Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/
{
    NTSTATUS Status;

    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFCB Fcb;
    PFOBX Fobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN SynchronousIo = !BooleanFlagOn( RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION );
    BOOLEAN PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    BOOLEAN PipeOperation = BooleanFlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION );
    BOOLEAN SynchronousPipe = BooleanFlagOn( RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

    PAGED_CODE();

    RxDecodeFileObject( FileObject, &Fcb, &Fobx ); 

    Status = RxContext->StoredStatus;
    Irp->IoStatus.Information = RxContext->InformationToReturn;

    RxDbgTrace( +1, Dbg, ("RxLowIoWriteShellCompletion  entry  Status = %08lx\n", Status ));
    RxLog(( "WtShlComp %lx %lx %lx\n", RxContext, Status, Irp->IoStatus.Information ));
    RxWmiLog( LOG,
              RxLowIoWriteShellCompletion_1,
              LOGPTR( RxContext )
              LOGULONG( Status )
              LOGPTR( Irp->IoStatus.Information ) );

    ASSERT( RxLowIoIsBufferLocked( LowIoContext ) );

    switch (Status) {
    case STATUS_SUCCESS:
        
        if(FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED )){
            
            if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_DISK_COMPRESSED )) {

                //
                //  NOT YET IMPLEMENTED should decompress and put away
                //
               
                ASSERT( FALSE ); 

            } else if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_BUF_COMPRESSED )) {

                //
                //  NOT YET IMPLEMENTED should decompress and put away
                //
                
                ASSERT(FALSE); 
            }
        }

#ifdef RX_WJ_DBG_SUPPORT
        RxdUpdateJournalOnLowIoWriteCompletion( Fcb, IrpSp->Parameters.Write.ByteOffset, IrpSp->Parameters.Write.Length );
#endif
        break;

    case STATUS_FILE_LOCK_CONFLICT:
        break;

    case STATUS_CONNECTION_INVALID:

        //
        //  NOT YET IMPLEMENTED here is where the failover will happen
        //  first we give the local guy current minirdr another chance...then we go
        //  to fullscale retry
        //  return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
        break;
    }

    if (Status != STATUS_SUCCESS) {
        
        if (PagingIo) {
            
            RxLogRetail(( "PgWrtFail %x %x %x\n", Fcb, Fcb->NetRoot, Status ));

            InterlockedIncrement( &LDWCount );
            KeQuerySystemTime( &LDWLastTime );
            LDWLastStatus = Status;
            LDWContext = Fcb;
        }
    }

    if (FlagOn( LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SYNCCALL )){
        
        //
        //  if we're being called from lowioubmit then just get out
        //

        RxDbgTrace( -1, Dbg, ("RxLowIoWriteShellCompletion  syncexit  Status = %08lx\n", Status) );
        return Status;
    }

    //
    //  otherwise we have to do the end of the write from here
    //

    if (NT_SUCCESS( Status ) && !PipeOperation) {

        ASSERT( Irp->IoStatus.Information == LowIoContext->ParamsFor.ReadWrite.ByteCount );

        //
        //  If this was not PagingIo, mark that the modify
        //  time on the dirent needs to be updated on close.
        //

        if (!PagingIo) {
            SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
        }

        if (FlagOn( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_EXTENDING_FILESIZE )) {
            SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
        }

        if (FlagOn( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_EXTENDING_VDL )) {

            //
            //  this flag will not be set unless we have a valid filesize and therefore the starting
            //  vbo will not be write-to-end-of-file
            //

            LONGLONG StartingVbo = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
            LONGLONG EndingVboWritten = StartingVbo + Irp->IoStatus.Information;
            LONGLONG FileSize;

            //
            //  Never set a ValidDataLength greater than FileSize.
            //

            RxGetFileSizeWithLock( Fcb, &FileSize );

            if (FileSize < EndingVboWritten) {
                Fcb->Header.ValidDataLength.QuadPart = FileSize;
            } else {
                Fcb->Header.ValidDataLength.QuadPart = EndingVboWritten;
            }
        }
    }

    if ((!SynchronousPipe) &&
        (LowIoContext->ParamsFor.ReadWrite.NonPagedFcb != NULL) &&
        (ExInterlockedAddUlong( &LowIoContext->ParamsFor.ReadWrite.NonPagedFcb->OutstandingAsyncWrites, 0xffffffff, &RxStrucSupSpinLock ) == 1) ) {

        KeSetEvent( LowIoContext->ParamsFor.ReadWrite.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
    }

    if (RxContext->FcbPagingIoResourceAcquired) {
        RxReleasePagingIoResourceForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );
    }

    if ((!SynchronousPipe) && (RxContext->FcbResourceAcquired)) {
        RxReleaseFcbForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );
    }

    if (SynchronousPipe) {
        
        RxResumeBlockedOperations_Serially( RxContext, &Fobx->Specific.NamedPipe.WriteSerializationQueue );
    }

    ASSERT( Status != STATUS_RETRY );
    ASSERT( (Status != STATUS_SUCCESS) ||
            (Irp->IoStatus.Information <=  IrpSp->Parameters.Write.Length ));
    ASSERT( RxContext->MajorFunction == IRP_MJ_WRITE );

    if (PipeOperation) {
        
        if (Irp->IoStatus.Information != 0) {

            //
            //  if we have been throttling on this pipe, stop because our writing to the pipe may
            //  cause the pipeserver (not smbserver) on the other end to unblock so we should go back
            //  and see
            //

            RxTerminateThrottling( &Fobx->Specific.NamedPipe.ThrottlingState );

            RxLog(( "WThrottlNo %lx %lx %lx %ld\n", RxContext, Fobx, &Fobx->Specific.NamedPipe.ThrottlingState, Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ));
            RxWmiLog( LOG,
                      RxLowIoWriteShellCompletion_2,
                      LOGPTR( RxContext )
                      LOGPTR( Fobx )
                      LOGULONG( Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ) );
        }
    }

    RxDbgTrace( -1, Dbg, ("RxLowIoWriteShellCompletion  exit  Status = %08lx\n", Status) );
    return Status;
}


NTSTATUS
RxLowIoWriteShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine preprocesses a write request before it goes down to the minirdr.
    It does callouts to handle compression, buffering and shadowing. It is the
    opposite number of LowIoWriteShellCompletion. By the time we get here, we are
    going to the wire. Write buffering was already tried in the UncachedWrite strategy

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxLowIoWriteShell  entry             %08lx\n", 0) );
    RxLog(( "WrtShl in %lx\n", RxContext ));
    RxWmiLog( LOG,
              RxLowIoWriteShell_1,
              LOGPTR( RxContext ) );

    if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_DISK_COMPRESSED )) {
        
        //
        //  NOT YET IMPLEMENTED should translated to a buffered but not held diskcompressed write
        //

        ASSERT( FALSE );
    
    } else if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_BUF_COMPRESSED )) {
        
        //
        //  NOT YET IMPLEMENTED should translated to a buffered and bufcompressed write
        //

        ASSERT( FALSE );
    }

    if (Fcb->CachedNetRootType == NET_ROOT_DISK) {
        
        ExInterlockedAddLargeStatistic( &RxContext->RxDeviceObject->NetworkReadBytesRequested, LowIoContext->ParamsFor.ReadWrite.ByteCount );
    }

#ifdef RX_WJ_DBG_SUPPORT
    RxdUpdateJournalOnLowIoWriteInitiation( Fcb, IrpSp->Parameters.Write.ByteOffset, IrpSp->Parameters.Write.Length );
#endif

    Status = RxLowIoSubmit( RxContext, Irp, Fcb, RxLowIoWriteShellCompletion );

    RxDbgTrace( -1, Dbg, ("RxLowIoWriteShell  exit  Status = %08lx\n", Status) );
    RxLog(( "WrtShl out %lx %lx\n", RxContext, Status ));
    RxWmiLog( LOG,
              RxLowIoWriteShell_2,
              LOGPTR( RxContext )
              LOGULONG( Status ) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    dispatch driver.

Author:

    Joe Linn      [JoeLinn]      11-Oct-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

//
//  The following procedures are the handle the procedureal interface with lowio.
//


NTSTATUS
RxLowIoReadShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxLowIoReadShellCompletion (
    IN PRX_CONTEXT RxContext
    );

#if DBG
VOID CheckForLoudOperations (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );
#else
#define CheckForLoudOperations(___r)
#endif

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(AT,BYTE_COUNT) {                            \
    try {                                                          \
        RtlZeroMemory((AT), (BYTE_COUNT));                         \
    } except(EXCEPTION_EXECUTE_HANDLER) {                          \
         RxRaiseStatus( RxContext, STATUS_INVALID_USER_BUFFER );   \
    }                                                              \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxStackOverflowRead)
#pragma alloc_text(PAGE, RxPostStackOverflowRead)
#pragma alloc_text(PAGE, RxCommonRead)
#pragma alloc_text(PAGE, RxLowIoReadShellCompletion)
#pragma alloc_text(PAGE, RxLowIoReadShell)
#if DBG
#pragma alloc_text(PAGE, CheckForLoudOperations)
#endif //DBG
#endif


//
//  Internal support routine
//

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine posts a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    RxContext - the usual

Return Value:

    RxStatus(PENDING).

--*/

{
    PIRP Irp = RxContext->CurrentIrp;
    
    KEVENT Event;
    PERESOURCE Resource;
    
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Getting too close to stack limit pass request to Fsp\n", 0 ) );

    //
    //  Initialize the event
    //  

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    if (FlagOn( Irp->Flags, IRP_PAGING_IO ) && (Fcb->Header.PagingIoResource != NULL)) {

        Resource = Fcb->Header.PagingIoResource;

    } else {

        Resource = Fcb->Header.Resource;
    }

    ExAcquireResourceSharedLite( Resource, TRUE );

    try {

        //
        //  Make the Irp just like a regular post request and
        //  then send the Irp to the special overflow thread.
        //  After the post we will wait for the stack overflow
        //  read routine to set the event so that we can
        //  then release the fcb resource and return.
        //

        RxPrePostIrp( RxContext, Irp );

        FsRtlPostStackOverflow( RxContext, &Event, RxStackOverflowRead );

        //
        //  And wait for the worker thread to complete the item
        //

        (VOID) KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

    } finally {

        ExReleaseResourceLite( Resource );
    }

    return STATUS_PENDING;
    
}


//
//  Internal support routine
//

VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine processes a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    Context - the RxContext being processed

    Event - the event to be signaled when we've finished this request.

Return Value:

    None.

--*/

{
    PRX_CONTEXT RxContext = Context;
    PIRP Irp = RxContext->CurrentIrp;

    PAGED_CODE();

    //
    //  Make it now look like we can wait for I/O to complete
    //

    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

    //
    //  Do the read operation protected by a try-except clause
    //

    try {

        (VOID) RxCommonRead( RxContext, Irp );

    } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

        NTSTATUS ExceptionCode;

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with the
        //  error status that we get back from the execption code

        ExceptionCode = GetExceptionCode();

        if (ExceptionCode == STATUS_FILE_DELETED) {

            RxContext->StoredStatus = ExceptionCode = STATUS_END_OF_FILE;
            Irp->IoStatus.Information = 0;
        }

        (VOID) RxProcessException( RxContext, ExceptionCode );
    }

    //
    //  Signal the original thread that we're done.

    KeSetEvent( Event, 0, FALSE );
}


NTSTATUS
RxCommonRead ( 
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common read routine for NtReadFile, called from both
    the Fsd, or from the Fsp if a request could not be completed without
    blocking in the Fsd.  This routine has no code where it determines
    whether it is running in the Fsd or Fsp.  Instead, its actions are
    conditionalized by the Wait input parameter, which determines whether
    it is allowed to block or not.  If a blocking condition is encountered
    with Wait == FALSE, however, the request is posted to the Fsp, who
    always calls with WAIT == TRUE.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{

    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFCB Fcb;
    PFOBX Fobx;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    NODE_TYPE_CODE TypeOfOpen;

    LARGE_INTEGER StartingByte;
    RXVBO StartingVbo;
    ULONG ByteCount;

    ULONG CapturedRxContextSerialNumber = RxContext->SerialNumber;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN PostIrp = FALSE;
    
    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN RefdContextForTracker = FALSE;

    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;

    PNET_ROOT NetRoot;
    BOOLEAN PipeRead;
    BOOLEAN BlockingResume = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME );
    BOOLEAN fSetResourceOwner = FALSE;
    BOOLEAN InFsp = FALSE;

    PAGED_CODE();

    TypeOfOpen = RxDecodeFileObject( FileObject, &Fcb, &Fobx );
    NetRoot = (PNET_ROOT)Fcb->NetRoot;

    //
    //  Initialize the local decision variables.
    //

    PipeRead = (BOOLEAN)(NetRoot->Type == NET_ROOT_PIPE);
    Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
    PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = BooleanFlagOn( Irp->Flags,IRP_NOCACHE );
    SynchronousIo = !BooleanFlagOn( RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION );
    InFsp = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP );

    RxDbgTrace( +1, Dbg, ("RxCommonRead...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, Fobx, Fcb ));
    RxDbgTrace( 0, Dbg, ("  ->ByteCount = %08lx, ByteOffset = %08lx %lx\n",
                         IrpSp->Parameters.Read.Length,
                         IrpSp->Parameters.Read.ByteOffset.LowPart,
                         IrpSp->Parameters.Read.ByteOffset.HighPart) );
    RxDbgTrace( 0, Dbg,("  ->%s%s%s%s\n",
                    Wait          ?"Wait ":"",
                    PagingIo      ?"PagingIo ":"",
                    NonCachedIo   ?"NonCachedIo ":"",
                    SynchronousIo ?"SynchronousIo ":"") );

    RxLog(( "CommonRead %lx %lx %lx\n", RxContext, Fobx, Fcb ));
    RxWmiLog( LOG,
              RxCommonRead_1,
              LOGPTR( RxContext )
              LOGPTR( Fobx )
              LOGPTR( Fcb ) );
    RxLog(( "   read %lx@%lx %lx %s%s%s%s\n",
              IrpSp->Parameters.Read.Length,
              IrpSp->Parameters.Read.ByteOffset.LowPart,
              IrpSp->Parameters.Read.ByteOffset.HighPart,
              Wait?"Wt":"",
              PagingIo?"Pg":"",
              NonCachedIo?"Nc":"",
              SynchronousIo?"Sync":"" ));
    RxWmiLog( LOG,
              RxCommonRead_2,
              LOGULONG( IrpSp->Parameters.Read.Length )
              LOGULONG( IrpSp->Parameters.Read.ByteOffset.LowPart )
              LOGULONG( IrpSp->Parameters.Read.ByteOffset.HighPart )
              LOGUCHAR( Wait )
              LOGUCHAR( PagingIo )
              LOGUCHAR( NonCachedIo )
              LOGUCHAR( SynchronousIo ) );

    RxItsTheSameContext();
    Irp->IoStatus.Information = 0;

    //
    //  Extract starting Vbo and offset.
    //

    StartingByte = IrpSp->Parameters.Read.ByteOffset;
    StartingVbo = StartingByte.QuadPart;

    ByteCount = IrpSp->Parameters.Read.Length;

#if DBG
    
    CheckForLoudOperations( RxContext, Fcb );

    if (FlagOn( LowIoContext->Flags,LOWIO_CONTEXT_FLAG_LOUDOPS )){
        DbgPrint( "LoudRead %lx/%lx on %lx vdl/size/alloc %lx/%lx/%lx\n",
            StartingByte.LowPart,ByteCount,Fcb,
            Fcb->Header.ValidDataLength.LowPart,
            Fcb->Header.FileSize.LowPart,
            Fcb->Header.AllocationSize.LowPart );
    }
#endif    

    //
    //  Statistics............
    //

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP ) &&
        (Fcb->CachedNetRootType == NET_ROOT_DISK)) {

        InterlockedIncrement( &RxDeviceObject->ReadOperations );

        if (StartingVbo != Fobx->Specific.DiskFile.PredictedReadOffset) {
            InterlockedIncrement( &RxDeviceObject->RandomReadOperations );
        }

        Fobx->Specific.DiskFile.PredictedReadOffset = StartingVbo + ByteCount;

        if (PagingIo) {
            ExInterlockedAddLargeStatistic( &RxDeviceObject->PagingReadBytesRequested, ByteCount );
        } else if (NonCachedIo) {
            ExInterlockedAddLargeStatistic( &RxDeviceObject->NonPagingReadBytesRequested, ByteCount );
        } else {
            ExInterlockedAddLargeStatistic( &RxDeviceObject->CacheReadBytesRequested, ByteCount );
        }
    }

    //
    //  Check for a null, invalid  request, and return immediately
    //

    if (PipeRead && PagingIo) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (ByteCount == 0) {
        return STATUS_SUCCESS;
    }

    //
    //  Get rid of invalid read requests right now.
    //

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_VOLUME_FCB)) {

        RxDbgTrace( 0, Dbg, ("Invalid file object for read, type=%08lx\n", TypeOfOpen ));
        RxDbgTrace( -1, Dbg, ("RxCommonRead:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Initialize LowIO_CONTEXT block in the RxContext
    //

    RxInitializeLowIoContext( RxContext, LOWIO_OP_READ, LowIoContext );

    //
    //  Use a try-finally to release Fcb and free buffers on the way out.
    //

    try {

        //
        //  This case corresponds to a normal user read file.
        //

        LONGLONG FileSize;
        LONGLONG ValidDataLength;

        RxDbgTrace( 0, Dbg, ("Type of read is user file open, fcbstate is %08lx\n", Fcb->FcbState ));

        //
        //  for stackoverflowreads, we will already have the pagingio resource shared as it's
        //  paging io. this doesn't cause a problem here....the resource is just acquired twice.
        //

        if ((NonCachedIo || !FlagOn( Fcb->FcbState, FCB_STATE_READCACHING_ENABLED )) &&
            !PagingIo &&
            (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {

            //
            //  We hold the main resource exclusive here because the flush
            //  may generate a recursive write in this thread
            //

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );

            if (Status == STATUS_LOCK_NOT_GRANTED) {
                
                RxDbgTrace( 0,Dbg,("Cannot acquire Fcb for flush = %08lx excl without waiting - lock not granted\n",Fcb) );
                try_return( PostIrp = TRUE );

            } else if (Status != STATUS_SUCCESS) {
                
                RxDbgTrace( 0,Dbg,("Cannot acquire Fcb = %08lx shared without waiting - other\n",Fcb) );
                try_return( PostIrp = FALSE );
            }

            ExAcquireResourceSharedLite( Fcb->Header.PagingIoResource, TRUE );

            CcFlushCache( FileObject->SectionObjectPointer,
                          &StartingByte,
                          ByteCount,
                          &Irp->IoStatus );

            RxReleasePagingIoResource( RxContext, Fcb );
            RxReleaseFcb( RxContext, Fcb );
            
            if (!NT_SUCCESS( Irp->IoStatus.Status )) {
                
                Status = Irp->IoStatus.Status;
                try_return( Irp->IoStatus.Status );
            }

            RxAcquirePagingIoResource( RxContext, Fcb );
            RxReleasePagingIoResource( RxContext, Fcb );
        }

        //
        //  We need shared access to the Fcb before proceeding.
        //

        if (PagingIo) {

            ASSERT( !PipeRead );

            if (!ExAcquireResourceSharedLite( Fcb->Header.PagingIoResource, Wait )) {

                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", Fcb) );
                try_return( PostIrp = TRUE );
            }

            if (!Wait) {
                LowIoContext->Resource = Fcb->Header.PagingIoResource;
            }

        } else if (!BlockingResume) {

            //
            //  If this is unbuffered async I/O  we need to check that
            //  we don't exhaust the number of times a single thread can
            //  acquire the resource.  Also, we will wait if there is an
            //  exclusive waiter.
            //

            if (!Wait && NonCachedIo) {

                Status = RxAcquireSharedFcbWaitForEx( RxContext, Fcb );

                if (Status == STATUS_LOCK_NOT_GRANTED) {
                    
                    RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting - lock not granted\n", Fcb) );
                    RxLog(( "RdAsyLNG %x\n", RxContext ));
                    RxWmiLog( LOG,
                              RxCommonRead_3,
                              LOGPTR( RxContext ) );
                    try_return( PostIrp = TRUE );
                
                } else if (Status != STATUS_SUCCESS) {
                    
                    RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting - other\n", Fcb) );
                    RxLog(( "RdAsyOthr %x\n", RxContext ));
                    RxWmiLog( LOG,
                              RxCommonRead_4,
                              LOGPTR( RxContext ) );
                    try_return( PostIrp = FALSE );
                }

                if (ExIsResourceAcquiredSharedLite( Fcb->Header.Resource ) > MAX_FCB_ASYNC_ACQUIRE) {

                    FcbAcquired = TRUE;
                    try_return( PostIrp = TRUE );
                }

                LowIoContext->Resource = Fcb->Header.Resource;

            } else {

                Status = RxAcquireSharedFcb( RxContext, Fcb );

                if (Status == STATUS_LOCK_NOT_GRANTED) {
                    
                    RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting - lock not granted\n", Fcb) );
                    try_return( PostIrp = TRUE );

                } else if (Status != STATUS_SUCCESS) {
                    
                    RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting - other\n", Fcb) );
                    try_return( PostIrp = FALSE );
                }
            }
        }

        RxItsTheSameContext();

        FcbAcquired = !BlockingResume;

        //
        //  for pipe reads, bail out now. we avoid a goto by duplicating the calldown
        //

        if (PipeRead) {
            
            //
            //  In order to prevent corruption on multi-threaded multi-block
            //  message mode pipe reads, we do this little dance with the fcb resource
            //

            if (!BlockingResume) {

                if ((Fobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_MESSAGE_TYPE) ||
                    ((Fobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_BYTE_STREAM_TYPE) &&
                     !FlagOn( Fobx->Specific.NamedPipe.CompletionMode, FILE_PIPE_COMPLETE_OPERATION))) {

                    //
                    //  Synchronization is effected here that will prevent other
                    //  threads from coming in and reading from this file while the
                    //  message pipe read is continuing.
                    //
                    //  This is necessary because we will release the FCB lock while
                    //  actually performing the I/O to allow open (and other) requests
                    //  to continue on this file while the I/O is in progress.
                    //

                    RxDbgTrace( 0, Dbg, ("Message pipe read: Fobx: %lx, Fcb: %lx, Enqueuing...\n", Fobx, Fcb) );

                    Status = RxSynchronizeBlockingOperationsAndDropFcbLock(  RxContext,
                                                                             Fcb,
                                                                             &Fobx->Specific.NamedPipe.ReadSerializationQueue );

                    RxItsTheSameContext();

                    FcbAcquired = FALSE;

                    if (!NT_SUCCESS( Status ) ||
                        (Status == STATUS_PENDING)) {
                        
                        try_return( Status );
                    }

                    RxDbgTrace( 0, Dbg, ("Succeeded: Fobx: %lx\n", Fobx) );
                }
            }

            LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
            LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;
            SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION );

            //
            // Set the resource owner pointers (there is no PagingIoResource here !) 
            // if we are in FSP so that even if the FSP thread goes away, we dont run
            // into issues with the resource package trying to boost the thread priority.
            //
            if( InFsp && FcbAcquired ) {

                LowIoContext->ResourceThreadId = MAKE_RESOURCE_OWNER(RxContext);
                ExSetResourceOwnerPointer(Fcb->Header.Resource, (PVOID)LowIoContext->ResourceThreadId);
                fSetResourceOwner = TRUE;
            }

            Status = RxLowIoReadShell( RxContext, Irp, Fcb );

            try_return( Status );
        }

        RxGetFileSizeWithLock( Fcb, &FileSize );
        ValidDataLength = Fcb->Header.ValidDataLength.QuadPart;


        //
        //  We set the fastio state state to questionable
        //  at initialization time and answer the question in realtime
        //  this should be a policy so that local minis can do it this way
        //

        //
        //  We have to check for read access according to the current
        //  state of the file locks, and set FileSize from the Fcb.
        //

        if (!PagingIo &&
            !FsRtlCheckLockForReadAccess( &Fcb->FileLock, Irp )) {

            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
        }


        //
        //  adjust the length if we know the eof...also, don't issue reads past the EOF
        //  if we know the eof
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_READCACHING_ENABLED )) {

            //
            //  If the read starts beyond End of File, return EOF.
            //

            if (StartingVbo >= FileSize) {
                
                RxDbgTrace( 0, Dbg, ("End of File\n", 0 ) );

                try_return ( Status = STATUS_END_OF_FILE );
            }

            //
            //  If the read extends beyond EOF, truncate the read
            //

            if (ByteCount > FileSize - StartingVbo) {
                ByteCount = (ULONG)(FileSize - StartingVbo);
            }
        }

        if (!PagingIo &&
            !NonCachedIo &&               //  this part is not discretionary
            FlagOn( Fcb->FcbState, FCB_STATE_READCACHING_ENABLED ) &&
            !FlagOn( Fobx->SrvOpen->Flags, SRVOPEN_FLAG_DONTUSE_READ_CACHING )) {

            //
            //  HANDLE CACHED CASE
            //
            //  We delay setting up the file cache until now, in case the
            //  caller never does any I/O to the file, and thus
            //  FileObject->PrivateCacheMap == NULL.
            //

            if (FileObject->PrivateCacheMap == NULL) {

                RxDbgTrace( 0, Dbg, ("Initialize cache mapping.\n", 0) );

                //
                // If this FileObject has gone through CleanUp, we cannot
                // CcInitializeCacheMap it.
                //
                if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {
                    Status = STATUS_FILE_CLOSED;
                    try_return( Status );
                }

                RxAdjustAllocationSizeforCC( Fcb );

                //
                //  Now initialize the cache map.
                //

                try {
                    
                    Status = STATUS_SUCCESS;

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&Fcb->Header.AllocationSize,
                                          FALSE,
                                          &RxData.CacheManagerCallbacks,
                                          Fcb );

                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    Status = GetExceptionCode();
                }

                if (Status != STATUS_SUCCESS) {
                    try_return( Status );
                }

                if (!FlagOn( Fcb->MRxDispatch->MRxFlags, RDBSS_NO_DEFERRED_CACHE_READAHEAD )) {

                    //
                    //  Start out with read ahead disabled
                    //

                    CcSetAdditionalCacheAttributes( FileObject, TRUE, FALSE );

                    SetFlag( Fcb->FcbState, FCB_STATE_READAHEAD_DEFERRED );

                } else {

                    //
                    //  this mini doesn't want deferred readahead
                    //

                    CcSetAdditionalCacheAttributes( FileObject, FALSE, FALSE );
                }

                CcSetReadAheadGranularity( FileObject, NetRoot->DiskParameters.ReadAheadGranularity );

            } else {

                //
                //  if we have wandered off the first page and haven't started reading ahead
                //  then start now
                //

                if (FlagOn( Fcb->FcbState, FCB_STATE_READAHEAD_DEFERRED ) &&
                    (StartingVbo >= PAGE_SIZE)) {

                    CcSetAdditionalCacheAttributes( FileObject, FALSE, FALSE );
                    ClearFlag( Fcb->FcbState, FCB_STATE_READAHEAD_DEFERRED );
                }
            }

            //
            //  DO A NORMAL CACHED READ, if the MDL bit is not set,
            //

            RxDbgTrace( 0, Dbg, ("Cached read.\n", 0) );

            if (!FlagOn( RxContext->MinorFunction, IRP_MN_MDL )) {

                PVOID SystemBuffer;

#if DBG
                ULONG SaveExceptionFlag;
#endif

                //
                //  Get hold of the user's buffer.
                //

                SystemBuffer = RxMapUserBuffer( RxContext, Irp );
                if (SystemBuffer == NULL) {
                    
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    try_return( Status );
                }

                //
                //  Make sure that a returned exception clears the breakpoint in the filter
                //

                RxSaveAndSetExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );
                RxItsTheSameContext();

                //
                //  Now try to do the copy.
                //

                if (!CcCopyRead( FileObject,
                                 &StartingByte,
                                 ByteCount,
                                 Wait,
                                 SystemBuffer,
                                 &Irp->IoStatus )) {

                    RxDbgTrace( 0, Dbg, ("Cached Read could not wait\n", 0 ) );
                    RxRestoreExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );

                    RxItsTheSameContext();

                    try_return( PostIrp = TRUE );
                }

                Status = Irp->IoStatus.Status;

                RxRestoreExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );
                RxItsTheSameContext();

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );
            
            } else {
                
                //
                //  HANDLE A MDL READ
                //

                RxDbgTrace(0, Dbg, ("MDL read.\n", 0));

                ASSERT( FALSE ); //  not yet ready for MDL reads
                ASSERT( Wait );

                CcMdlRead( FileObject,
                           &StartingByte,
                           ByteCount,
                           &Irp->MdlAddress,
                           &Irp->IoStatus );

                Status = Irp->IoStatus.Status;

                ASSERT( NT_SUCCESS( Status ));
                try_return( Status );
            }
        }

        //
        //  HANDLE THE NON-CACHED CASE
        //
        //  Bt first, a ValidDataLength check.
        //
        //  If the file in question is a disk file, and it is currently cached,
        //  and the read offset is greater than valid data length, then
        //  return 0s to the application.
        //

        if ((Fcb->CachedNetRootType == NET_ROOT_DISK) &&
            FlagOn( Fcb->FcbState, FCB_STATE_READCACHING_ENABLED ) &&
            (StartingVbo >= ValidDataLength)) {

            //
            //  check if zeroing is really needed.
            //

            if (StartingVbo >= FileSize) {
                ByteCount = 0;
            } else {

                PBYTE SystemBuffer;

                //
                //  There is at least one byte available.  Truncate
                //  the transfer length if it goes beyond EOF.
                //

                if (StartingVbo + ByteCount > FileSize) {
                    ByteCount = (ULONG)(FileSize - StartingVbo);
                }

                SystemBuffer = RxMapUserBuffer( RxContext, Irp );
                SafeZeroMemory( SystemBuffer, ByteCount );   //  this could raise!!
            }

            Irp->IoStatus.Information = ByteCount;
            try_return( Status = STATUS_SUCCESS );
        }


        LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
        LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;

        RxItsTheSameContext();

        //
        // Set the resource owner pointers.
        // if we are in FSP so that even if the FSP thread goes away, we dont run
        // into issues with the resource package trying to boost the thread priority.
        //
        
        if ( InFsp && FcbAcquired ) {

            LowIoContext->ResourceThreadId = MAKE_RESOURCE_OWNER(RxContext);
            if ( PagingIo ) {

                ExSetResourceOwnerPointer( Fcb->Header.PagingIoResource, (PVOID)LowIoContext->ResourceThreadId );

            } else {

                ExSetResourceOwnerPointer( Fcb->Header.Resource, (PVOID)LowIoContext->ResourceThreadId );
            }
            
            fSetResourceOwner = TRUE;
        }

        Status = RxLowIoReadShell( RxContext, Irp, Fcb );

        RxItsTheSameContext();
        try_return( Status );

  try_exit: NOTHING;

        //
        //  If the request was not posted, deal with it.
        //

        RxItsTheSameContext();

        if (!PostIrp) {
            
            if (!PipeRead) {

                RxDbgTrace( 0, Dbg, ("CommonRead InnerFinally-> %08lx %08lx\n",
                                Status, Irp->IoStatus.Information) );

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position. this works becuase info==0 for errors
                //

                if (!PagingIo &&
                    FlagOn( FileObject->Flags, FO_SYNCHRONOUS_IO )) {
                    
                    FileObject->CurrentByteOffset.QuadPart =
                                StartingVbo + Irp->IoStatus.Information;
                }
            }
        } else {

            RxDbgTrace( 0, Dbg, ("Passing request to Fsp\n", 0 ));

            InterlockedIncrement( &RxContext->ReferenceCount );
            RefdContextForTracker = TRUE;

            Status = RxFsdPostRequest( RxContext );
        }
    } finally {

        DebugUnwind( RxCommonRead );

        //
        //  If this was not PagingIo, mark that the last access
        //  time on the dirent needs to be updated on close.
        //

        if (NT_SUCCESS( Status ) && (Status != STATUS_PENDING) && !PagingIo && !PipeRead) {
            SetFlag( FileObject->Flags, FO_FILE_FAST_IO_READ );

        }

        //
        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //     3) if we posted the request
        //
        //  Completion for this case is not handled in the common dispatch routine
        //

        if (AbnormalTermination() || (Status != STATUS_PENDING) || PostIrp) {
            
            if (FcbAcquired) {

                if ( PagingIo ) {

                    if( fSetResourceOwner ) {

                        RxReleasePagingIoResourceForThread(RxContext, Fcb, LowIoContext->ResourceThreadId);

                    } else {

                        RxReleasePagingIoResource( RxContext, Fcb );
                    }

                } else {
                    if( fSetResourceOwner ) {

                        RxReleaseFcbForThread(RxContext, Fcb, LowIoContext->ResourceThreadId);

                    } else {
                        
                        RxReleaseFcb( RxContext, Fcb );
                    }
                }
            }

            if (RefdContextForTracker) {
                RxDereferenceAndDeleteRxContext( RxContext );
            }

            if (!PostIrp) {
               if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION )) {

                   RxResumeBlockedOperations_Serially( RxContext,
                                                       &Fobx->Specific.NamedPipe.ReadSerializationQueue );
               }
            }

            if (Status == STATUS_SUCCESS) {
                ASSERT( Irp->IoStatus.Information <=  IrpSp->Parameters.Read.Length );
            }

        } else {

            //
            //  here the guy below is going to handle the completion....but, we don't know the finish
            //  order....in all likelihood the deletecontext call below just reduces the refcount
            //  but the guy may already have finished in which case this will really delete the context.
            //

            ASSERT( !SynchronousIo );

            RxDereferenceAndDeleteRxContext( RxContext );
        }

        RxDbgTrace( -1, Dbg, ("CommonRead -> %08lx\n", Status) );
    } //  finally

    IF_DEBUG {
        if ((Status == STATUS_END_OF_FILE) && 
            FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_LOUDOPS )){
            
            DbgPrint( "Returning end of file on %wZ\n", &(Fcb->PrivateAlreadyPrefixedName) );
        }
    }

    return Status;
}

NTSTATUS
RxLowIoReadShellCompletion (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine postprocesses a read request after it comes back from the
    minirdr.  It does callouts to handle compression, buffering and
    shadowing.  It is the opposite number of LowIoReadShell.

    This will be called from LowIo; for async, originally in the
    completion routine.  If RxStatus(MORE_PROCESSING_REQUIRED) is returned,
    LowIo will call again in a thread.  If this was syncIo, you'll be back
    in the user's thread; if async, lowIo will requeue to a thread.
    Currrently, we always get to a thread before anything; this is a bit slower
    than completing at DPC time,
    but it's aheckuva lot safer and we may often have stuff to do
    (like decompressing, shadowing, etc) that we don't want to do at DPC
    time.

Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/

{
    NTSTATUS Status;
    
    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    PFCB Fcb;
    PFOBX Fobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
    BOOLEAN PagingIo = BooleanFlagOn( Irp->Flags, IRP_PAGING_IO );
    BOOLEAN PipeOperation = BooleanFlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION );
    BOOLEAN SynchronousPipe = BooleanFlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

    //
    //  we will want to revisit this....not taking this at dpc time would cause
    //  two extra context swaps IF MINIRDRS MADE THE CALL FROM THE INDICATION
    //  CRRRENTLY, THEY DO NOT.
    //

    PAGED_CODE();  

    RxDecodeFileObject( FileObject, &Fcb, &Fobx ); 
    
    Status = RxContext->StoredStatus;
    Irp->IoStatus.Information = RxContext->InformationToReturn;

    RxDbgTrace( +1, Dbg, ("RxLowIoReadShellCompletion  entry  Status = %08lx\n", Status) );
    RxLog(( "RdShlComp %lx %lx %lx\n", RxContext, Status, Irp->IoStatus.Information ));
    RxWmiLog( LOG,
              RxLowIoReadShellCompletion_1,
              LOGPTR( RxContext )
              LOGULONG( Status )
              LOGPTR( Irp->IoStatus.Information ) );

    if (PagingIo) {

        //
        //  for paging io, it's nonsense to have 0bytes and success...map it!
        //

        if (NT_SUCCESS(Status) &&
            (Irp->IoStatus.Information == 0)) {
            
            Status = STATUS_END_OF_FILE;
        }
    }


    ASSERT( RxLowIoIsBufferLocked( LowIoContext ) );
    switch (Status) {
    case STATUS_SUCCESS:
        
        if(FlagOn( RxContext->Flags, RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED )){
            
            if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_DISK_COMPRESSED )){
               
                ASSERT( FALSE ); //  NOT YET IMPLEMENTED should decompress and put away

            } else if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_BUF_COMPRESSED )){
               
                ASSERT( FALSE ); //  NOT YET IMPLEMENTED should decompress and put away
            }
        }
        break;

    case STATUS_FILE_LOCK_CONFLICT:
        
        if(FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_THIS_READ_ENLARGED )){
            ASSERT( FALSE ); //  disenlarge the read
            return STATUS_RETRY;
        }
        break;

    case STATUS_CONNECTION_INVALID:

        //
        //  NOT YET IMPLEMENTED here is where the failover will happen
        //  first we give the local guy current minirdr another chance...then we go
        //  to fullscale retry
        //  return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
        //

        break;
    }

    if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_READAHEAD )) {
       ASSERT( FALSE ); //  RxUnwaitReadAheadWaiters(RxContext);
    }

    if (FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SYNCCALL )){
        
        //
        //  if we're being called from lowioubmit then just get out
        //

        RxDbgTrace(-1, Dbg, ("RxLowIoReadShellCompletion  syncexit  Status = %08lx\n", Status));
        return Status;
    }

    //
    //  otherwise we have to do the end of the read from here
    //

    //
    //  mark that the file has been read accessed
    //

    if (NT_SUCCESS( Status ) && !PagingIo && !PipeOperation) {
        SetFlag( FileObject->Flags, FO_FILE_FAST_IO_READ );
    }

    if ( PagingIo ) {

        RxReleasePagingIoResourceForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );

    } else if (!SynchronousPipe) {

        RxReleaseFcbForThread( RxContext, Fcb, LowIoContext->ResourceThreadId );

    } else {
        
        RxResumeBlockedOperations_Serially( RxContext, &Fobx->Specific.NamedPipe.ReadSerializationQueue );
    }

    if (PipeOperation) {
        
        if (Irp->IoStatus.Information == 0) {

            //
            //  if this is a nowait pipe, initiate throttling to keep from flooding the net
            //

            if (Fobx->Specific.NamedPipe.CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

                RxInitiateOrContinueThrottling( &Fobx->Specific.NamedPipe.ThrottlingState );

                RxLog(( "RThrottlYes %lx %lx %lx %ld\n",
                        RxContext,Fobx,&Fobx->Specific.NamedPipe.ThrottlingState,
                        Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ));
                RxWmiLog( LOG,
                          RxLowIoReadShellCompletion_2,
                          LOGPTR( RxContext )
                          LOGPTR( Fobx )
                          LOGULONG( Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ) );
            }

            //
            //  translate the status if this is a msgmode pipe
            //

            if ((Fobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_MESSAGE_TYPE) &&
                (Status == STATUS_SUCCESS)) {
                
                Status = STATUS_PIPE_EMPTY;
            }

        } else {

            //
            //  if we have been throttling on this pipe, stop because we got some data.....
            //

            RxTerminateThrottling( &Fobx->Specific.NamedPipe.ThrottlingState );

            RxLog(( "RThrottlNo %lx %lx %lx %ld\n",
                    RxContext, Fobx, &Fobx->Specific.NamedPipe.ThrottlingState,
                    Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ));
            RxWmiLog( LOG,
                      RxLowIoReadShellCompletion_3,
                      LOGPTR( RxContext )
                      LOGPTR( Fobx )
                      LOGULONG( Fobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries ) );
        }
    }

    ASSERT( Status != STATUS_RETRY );

    if (Status != STATUS_RETRY) {
        
        ASSERT( Irp->IoStatus.Information <=  IrpSp->Parameters.Read.Length );
        ASSERT( RxContext->MajorFunction == IRP_MJ_READ );
    }

    RxDbgTrace( -1, Dbg, ("RxLowIoReadShellCompletion  asyncexit  Status = %08lx\n", Status) );
    return Status;
}

NTSTATUS
RxLowIoReadShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

    This routine preprocesses a read request before it goes down to the minirdr. It does callouts
    to handle compression, buffering and shadowing. It is the opposite number of LowIoReadShellCompletion.
    By the time we get here, either the shadowing system will handle the read OR we are going to the wire.
    Read buffering was already tried in the UncachedRead strategy

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxLowIoReadShell  entry             %08lx\n") );
    RxLog(( "RdShl in %lx\n", RxContext ));
    RxWmiLog( LOG,
              RxLowIoReadShell_1,
              LOGPTR( RxContext ) );

    if (Fcb->CachedNetRootType == NET_ROOT_DISK) {
        
        ExInterlockedAddLargeStatistic( &RxContext->RxDeviceObject->NetworkReadBytesRequested,
                                        LowIoContext->ParamsFor.ReadWrite.ByteCount );
    }

    Status = RxLowIoSubmit( RxContext, Irp, Fcb, RxLowIoReadShellCompletion );

    RxDbgTrace( -1, Dbg, ("RxLowIoReadShell  exit  Status = %08lx\n", Status) );
    RxLog(( "RdShl out %x %x\n", RxContext, Status ));
    RxWmiLog( LOG,
              RxLowIoReadShell_2,
              LOGPTR( RxContext )
              LOGULONG( Status ) );

    return Status;
}

#if DBG

ULONG RxLoudLowIoOpsEnabled = 0;

VOID CheckForLoudOperations (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )
{
    PAGED_CODE();

    if (RxLoudLowIoOpsEnabled) {
        
        PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
        PCHAR Buffer;
        PWCHAR FileOfConcern = L"all.scr";
        ULONG Length = 7*sizeof( WCHAR ); //7  is the length of all.scr;

        Buffer = Add2Ptr( Fcb->PrivateAlreadyPrefixedName.Buffer, Fcb->PrivateAlreadyPrefixedName.Length - Length );

        if (RtlCompareMemory( Buffer, FileOfConcern, Length ) == Length) {
            
            SetFlag( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_LOUDOPS );
        }
    }
    return;
}
#endif //if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\copysup.nt\precomp.h ===
//precomp include file for copysup.nt directory

#include <ntifs.h>
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\copysup.nt\fastio2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FastIo2.c

Abstract:

    This module REimplements the fsrtl copy read/write routines.

Author:

    Joe Linn     [JoeLinn]    9-Nov-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

BOOLEAN
FsRtlCopyRead2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    );
BOOLEAN
FsRtlCopyWrite2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlCopyRead2)
#pragma alloc_text(PAGE, FsRtlCopyWrite2)
#endif

BOOLEAN
FsRtlCopyRead2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN Status = TRUE;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES((ULongToPtr(FileOffset->LowPart)), Length);
    LARGE_INTEGER BeyondLastByte;
    PDEVICE_OBJECT targetVdo;

    PAGED_CODE();

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Get a real pointer to the common fcb header
        //

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Increment performance counters and get the resource
        //

        if (Wait) {


            //
            //  Acquired shared on the common fcb header
            //

            (VOID)ExAcquireResourceSharedLite( Header->Resource, TRUE );

        } else {


            //
            //  Acquired shared on the common fcb header, and return if we
            //  don't get it
            //

            if (!ExAcquireResourceSharedLite( Header->Resource, FALSE )) {

                FsRtlExitFileSystem();

                //the ntfs guys dont do this AND it causes a compile error for me so
                //comment it out
                //CcFastReadResourceMiss += 1;

                return FALSE;
            }
        }

        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();


            return FALSE;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            // ASSERT(!KeIsExecutingDpc());

            targetVdo = IoGetRelatedDeviceObject( FileObject );
            FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;


            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        targetVdo )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();


                return FALSE;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();

                return TRUE;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        IoSetTopLevelIrp((PIRP) TopLevelIrpValue);

        try {

            if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                CcFastCopyRead( FileObject,
                                FileOffset->LowPart,
                                Length,
                                PageCount,
                                Buffer,
                                IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                        ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

            } else {

                Status = CcCopyRead( FileObject,
                                     FileOffset,
                                     Length,
                                     Wait,
                                     Buffer,
                                     IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( !Status || (IoStatus->Status == STATUS_END_OF_FILE) ||
                        (((ULONGLONG)FileOffset->QuadPart + IoStatus->Information) <= (ULONGLONG)Header->FileSize.QuadPart));
            }

            if (Status) {

                FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + IoStatus->Information;
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

            Status = FALSE;
        }

        IoSetTopLevelIrp(NULL);

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();
        return Status;

    } else {

        //
        //  A zero length transfer was requested.
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

        return TRUE;
    }
}

BOOLEAN
FsRtlCopyWrite2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.  For a complete description of the arguments
    see CcCopyWrite.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN AcquiredShared = FALSE;
    BOOLEAN Status = TRUE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN WriteToEndOfFile = (BOOLEAN)((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                                         (FileOffset->HighPart == -1));

    PAGED_CODE();

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (CcCanIWrite( FileObject, Length, Wait, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Split into separate paths for increased performance.  First
            //  we have the faster path which only supports Wait == TRUE and
            //  32 bits.  We will make an unsafe test on whether the fast path
            //  is ok, then just return FALSE later if we were wrong.  This
            //  should virtually never happen.
            //
            //  IMPORTANT NOTE: It is very important that any changes mad to
            //                  this path also be applied to the 64-bit path
            //                  which is the else of this test!
            //

            if (Wait && (Header->AllocationSize.HighPart == 0)) {

                ULONG Offset, NewFileSize;
                ULONG OldFileSize;
                ULONG OldValidDataLength;
                BOOLEAN Wrapped;

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.  Note that we do not check FileOffset->HighPart
                //  until below.
                //

                NewFileSize = FileOffset->LowPart + Length;

                if (WriteToEndOfFile || (NewFileSize > Header->ValidDataLength.LowPart)) {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                } else {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceSharedLite( Header->Resource, TRUE );

                    AcquiredShared = TRUE;
                }

                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize.LowPart;
                    NewFileSize = Header->FileSize.LowPart + Length;
                    Wrapped = NewFileSize < Header->FileSize.LowPart;

                } else {

                    Offset = FileOffset->LowPart;
                    NewFileSize = FileOffset->LowPart + Length;
                    Wrapped = (NewFileSize < FileOffset->LowPart) || (FileOffset->HighPart != 0);
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we have too much to zero.  This case is not important
                //  for performance, and a file system supporting sparseness may have
                //  a way to do this more efficiently.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                    (NewFileSize > Header->AllocationSize.LowPart) ||
                    (Offset >= (Header->ValidDataLength.LowPart + 0x2000)) ||
                    (Header->AllocationSize.HighPart != 0) || Wrapped) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && (NewFileSize > Header->ValidDataLength.LowPart)) {

                    ExReleaseResourceLite( Header->Resource );

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize.LowPart;
                        NewFileSize = Header->FileSize.LowPart + Length;
                        Wrapped = NewFileSize < Header->FileSize.LowPart;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        (NewFileSize > Header->AllocationSize.LowPart) ||
                        (Header->AllocationSize.HighPart != 0) || Wrapped) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                TRUE,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if (NewFileSize > Header->FileSize.LowPart) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize.LowPart;
                    OldValidDataLength = Header->ValidDataLength.LowPart;
                    Header->FileSize.LowPart = NewFileSize;
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                IoSetTopLevelIrp((PIRP) TopLevelIrpValue);

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if (Offset > Header->ValidDataLength.LowPart) {

                        LARGE_INTEGER ZeroEnd;

                        ZeroEnd.LowPart = Offset;
                        ZeroEnd.HighPart = 0;

                        CcZeroData( FileObject,
                                    &Header->ValidDataLength,
                                    &ZeroEnd,
                                    TRUE );
                    }

                    CcFastCopyWrite( FileObject,
                                     Offset,
                                     Length,
                                     Buffer );

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                IoSetTopLevelIrp(NULL);

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if (NewFileSize > Header->ValidDataLength.LowPart) {

                        Header->ValidDataLength.LowPart = NewFileSize;
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        CcGetFileSizePointer(FileObject)->LowPart = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the file position pointer
                    //

                    FileObject->CurrentByteOffset.LowPart = Offset + Length;
                    FileObject->CurrentByteOffset.HighPart = 0;

                //
                //  If we did not succeed, then we must restore the original
                //  FileSize while holding the PagingIoResource exclusive if
                //  it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                    }
                }

            //
            //  Here is the 64-bit or no-wait path.
            //

            } else {

                LARGE_INTEGER Offset, NewFileSize;
                LARGE_INTEGER OldFileSize;
                LARGE_INTEGER OldValidDataLength;

                // ASSERT(!KeIsExecutingDpc());

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.
                //

                NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

                if (WriteToEndOfFile || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                } else {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceSharedLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    AcquiredShared = TRUE;
                }


                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize;
                    NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;

                } else {

                    Offset = *FileOffset;
                    NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we are about to zero too much as well, as commented above.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                      (Offset.QuadPart >= (Header->ValidDataLength.QuadPart + 0x2000)) ||
                      ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart )) {

                    ExReleaseResourceLite( Header->Resource );

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize;
                        NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                Wait,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ( NewFileSize.QuadPart > Header->FileSize.QuadPart ) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize;
                    OldValidDataLength = Header->ValidDataLength;

                    //
                    //  Deal with an extremely rare pathalogical case here the
                    //  file size wraps.
                    //

                    if ( (Header->FileSize.HighPart != NewFileSize.HighPart) &&
                         (Header->PagingIoResource != NULL) ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = NewFileSize;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = NewFileSize;
                    }
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                IoSetTopLevelIrp((PIRP) TopLevelIrpValue);

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

                        Status = CcZeroData( FileObject,
                                             &Header->ValidDataLength,
                                             &Offset,
                                             Wait );
                    }

                    if (Status) {

                        Status = CcCopyWrite( FileObject,
                                              &Offset,
                                              Length,
                                              Wait,
                                              Buffer );
                    }

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                IoSetTopLevelIrp(NULL);

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart ) {

                        //
                        //  Deal with an extremely rare pathalogical case here
                        //  the ValidDataLength wraps.
                        //

                        if ( (Header->ValidDataLength.HighPart != NewFileSize.HighPart) &&
                             (Header->PagingIoResource != NULL) ) {

                            (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                            Header->ValidDataLength = NewFileSize;
                            ExReleaseResourceLite( Header->PagingIoResource );

                        } else {

                            Header->ValidDataLength = NewFileSize;
                        }
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        *CcGetFileSizePointer(FileObject) = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the current file position pointer
                    //

                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                //
                // If we did not succeed, then we must restore the original
                // FileSize while holding the PagingIoResource exclusive if
                // it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                    }
                }

            }

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return Status;

        } else {

            //
            //  A zero length transfer was requested.
            //

            return TRUE;
        }

    } else {

        //
        // The volume must be verified or the file is write through.
        //

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\copysup.nt\daytona\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\dav2kd.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dav2kd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _DAV2KD_H_
#define _DAV2KD_H_

typedef enum _FOLLOWON_HELPER_RETURNS {
    FOLLOWONHELPER_CALLTHRU,
    FOLLOWONHELPER_DUMP,
    FOLLOWONHELPER_ERROR,
    FOLLOWONHELPER_DONE
} FOLLOWON_HELPER_RETURNS;

typedef struct _PERSISTENT_RDR2KD_INFO {
    DWORD OpenCount;
    ULONG_PTR LastAddressDumped[100];
    ULONG IdOfLastDump;
    ULONG IndexOfLastDump;
    BYTE StructDumpBuffer[2048];
} PERSISTENT_RDR2KD_INFO, *PPERSISTENT_RDR2KD_INFO;

PPERSISTENT_RDR2KD_INFO LocatePersistentInfoFromView ();
VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    );


typedef
FOLLOWON_HELPER_RETURNS
(NTAPI *PFOLLOWON_HELPER_ROUTINE) (
    IN OUT PPERSISTENT_RDR2KD_INFO p,
    OUT    PBYTE Name,
    OUT    PBYTE Buffer2
    );

#define DECLARE_FOLLOWON_HELPER_CALLEE(s) \
    FOLLOWON_HELPER_RETURNS s (           \
    IN OUT PPERSISTENT_RDR2KD_INFO p,     \
    OUT    PBYTE Name,                    \
    OUT    PBYTE Buffer2       \
    )

#endif // _DAV2KD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation











------------------------------
T H I S   F I L E   I S   O B S O L E T E .    I T   I S   B E I N G   K E P T
F O R   A   W H I L E   J U S T   T O   M A K E   S U R E
----------------------------
















Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include "ntifs.h"
#include <nt.h>
//#include <ntrtl.h>
#include "ntverp.h"

#define KDEXTMODE

#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        PRINTF( "Unable to read %u bytes at %p, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString( ULONG_PTR dwAddress, PSZ buf )
{
    do {
        if( !GetData( dwAddress,buf, 1, "..stringfetch") )
            return FALSE;

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) puStr->Buffer,
                UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, puStr, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\dav2kd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dav2kd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rx.h"       // NT network file system driver include file
#include "ntddnfs2.h" // new stuff device driver definitions
#include "smbmrx.h"   // smbmini rdr global include file

#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <dav2kd.h>



/*
 * RDR2 global variables.
 *
 */

LPSTR GlobalBool[]  = {
            "mrxsmb!MRxSmbDeferredOpensEnabled",
            "mrxsmb!MRxSmbOplocksDisabled",
             0};

LPSTR GlobalShort[] = {0};
LPSTR GlobalLong[]  = {
            0};

LPSTR GlobalPtrs[]  = {
            "mrxdav!RxExpCXR",
            "mrxdav!RxExpEXR",
            "mrxdav!RxExpAddr",
            "mrxdav!RxExpCode",
            "mrxdav!RxActiveContexts",
            "mrxdav!RxNetNameTable",
            "mrxdav!RxProcessorArchitecture",
            "mrxdav!RxBuildNumber",
            "mrxdav!RxPrivateBuild",
            "mrxsmb!SmbMmExchangesInUse",
            "mrxsmb!MRxSmbBuildNumber",
            "mrxsmb!MRxSmbPrivateBuild",
            0};


/*
 * IRP_CONTEXT debugging.
 *
 */

FIELD_DESCRIPTOR RxContextFields[] =
   {
      FIELD3(FieldTypeUShort,RX_CONTEXT,NodeTypeCode),
      FIELD3(FieldTypeShort,RX_CONTEXT,NodeByteSize),
      FIELD3(FieldTypeULong,RX_CONTEXT,ReferenceCount),
      FIELD3(FieldTypeULong,RX_CONTEXT,SerialNumber),
      FIELD3(FieldTypeStruct,RX_CONTEXT,WorkQueueItem),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrp),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrpSp),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFcb),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFobx),
      //FIELD3(FieldTypePointer,RX_CONTEXT,pRelevantSrvOpen),
      FIELD3(FieldTypePointer,RX_CONTEXT,LastExecutionThread),
#ifdef RDBSS_TRACKER
      FIELD3(FieldTypePointer,RX_CONTEXT,AcquireReleaseFcbTrackerX),
#endif
      FIELD3(FieldTypePointer,RX_CONTEXT,MRxContext[2]),
      FIELD3(FieldTypeSymbol,RX_CONTEXT,ResumeRoutine),
      FIELD3(FieldTypePointer,RX_CONTEXT,RealDevice),
      FIELD3(FieldTypeULongFlags,RX_CONTEXT,Flags),
      FIELD3(FieldTypeChar,RX_CONTEXT,MajorFunction),
      FIELD3(FieldTypeChar,RX_CONTEXT,MinorFunction),
      FIELD3(FieldTypeULong,RX_CONTEXT,StoredStatus),
      FIELD3(FieldTypeStruct,RX_CONTEXT,SyncEvent),
      FIELD3(FieldTypeStruct,RX_CONTEXT,RxContextSerializationQLinks),
      FIELD3(FieldTypeStruct,RX_CONTEXT,Create),
      FIELD3(FieldTypeStruct,RX_CONTEXT,LowIoContext),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.NetNamePrefixEntry),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvCall),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pNetRoot),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pVNetRoot),
      //FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvOpen),
      0
   };

/*
 * SRV_CALL debugging.
 *
 */

//CODE.IMPROVEMENT we should have a fieldtype for prefixentry that
//                 will print out the names

FIELD_DESCRIPTOR SrvCallFields[] =
   {
      FIELD3(FieldTypeUShort,SRV_CALL,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_CALL,NodeByteSize),
      FIELD3(FieldTypeStruct,SRV_CALL,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,SRV_CALL,PrefixEntry.Prefix),
      FIELD3(FieldTypePointer,SRV_CALL,Context),
      FIELD3(FieldTypePointer,SRV_CALL,Context2),
      FIELD3(FieldTypeULong,SRV_CALL,Flags),
      0
   };

/*
 * NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR NetRootFields[] =
   {
      FIELD3(FieldTypeUShort,NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeStruct,NET_ROOT,FcbTable),
      //FIELD3(FieldTypePointer,NET_ROOT,Dispatch),
      FIELD3(FieldTypePointer,NET_ROOT,Context),
      FIELD3(FieldTypePointer,NET_ROOT,Context2),
      FIELD3(FieldTypePointer,NET_ROOT,SrvCall),
      FIELD3(FieldTypeULong,NET_ROOT,Flags),
      0
   };


/*
 * V_NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR VNetRootFields[] =
   {
      FIELD3(FieldTypeUShort,V_NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,V_NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,V_NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,V_NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,NamePrefix),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context2),
      FIELD3(FieldTypePointer,V_NET_ROOT,NetRoot),
      0
   };


/*
 * FCB debugging.
 *
 */

FIELD_DESCRIPTOR FcbFields[] =
   {
      FIELD3(FieldTypeUShort,FCB,Header.NodeTypeCode),
      FIELD3(FieldTypeShort,FCB,Header.NodeByteSize),
      FIELD3(FieldTypeULong,FCB,NodeReferenceCount),
      FIELD3(FieldTypeULong,FCB,FcbState),
      FIELD3(FieldTypeULong,FCB,OpenCount),
      FIELD3(FieldTypeULong,FCB,UncleanCount),
      FIELD3(FieldTypePointer,FCB,Header.Resource),
      FIELD3(FieldTypePointer,FCB,Header.PagingIoResource),
      FIELD3(FieldTypeStruct,FCB,FcbTableEntry),
      FIELD3(FieldTypeUnicodeString,FCB,PrivateAlreadyPrefixedName),
      FIELD3(FieldTypePointer,FCB,VNetRoot),
      FIELD3(FieldTypePointer,FCB,NetRoot),
      FIELD3(FieldTypePointer,FCB,Context),
      FIELD3(FieldTypePointer,FCB,Context2),
      FIELD3(FieldTypeStruct,FCB,SrvOpenList),
      0
   };

FIELD_DESCRIPTOR FcbTableEntry[]=
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeByteSize),
    FIELD3(FieldTypeULong, RX_FCB_TABLE_ENTRY,HashValue),
    FIELD3(FieldTypeUnicodeString,RX_FCB_TABLE_ENTRY,Path),
    FIELD3(FieldTypeULong,RX_FCB_TABLE_ENTRY,HashLinks),
    FIELD3(FieldTypeLong,RX_FCB_TABLE_ENTRY,Lookups),
    0
   };

FIELD_DESCRIPTOR FcbTable[] =
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeByteSize),
    FIELD3(FieldTypeULong,RX_FCB_TABLE,Version),
    FIELD3(FieldTypeBoolean,RX_FCB_TABLE,CaseInsensitiveMatch),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NumberOfBuckets),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Lookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,FailedLookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Compares),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,TableEntryForNull),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,HashBuckets),
    0
   };

/*
 * SRV_OPEN debugging.
 *
 */

FIELD_DESCRIPTOR SrvOpenFields[] =
   {
      FIELD3(FieldTypeShort,SRV_OPEN,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_OPEN,NodeByteSize),
      FIELD3(FieldTypeULong,SRV_OPEN,NodeReferenceCount),
      FIELD3(FieldTypePointer,SRV_OPEN,Fcb),
      FIELD3(FieldTypeULong,SRV_OPEN,Flags),
      0
   };


/*
 * FOBX debugging.
 *
 */

FIELD_DESCRIPTOR FobxFields[] =
   {
      FIELD3(FieldTypeShort,FOBX,NodeTypeCode),
      FIELD3(FieldTypeShort,FOBX,NodeByteSize),
      FIELD3(FieldTypeULong,FOBX,NodeReferenceCount),
      FIELD3(FieldTypePointer,FOBX,SrvOpen),
      0
   };



#define SMBCE_ENTRY_FIELDS(__TYPE__) \
      FIELD3(FieldTypeULong,__TYPE__,Header.SwizzleCount),    \
      FIELD3(FieldTypeChar,__TYPE__,Header.Flags),    \
      FIELD3(FieldTypeLong,__TYPE__,Header.State),



FIELD_DESCRIPTOR ServerEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SERVER_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,Name),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Sessions),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,NetRoots),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pTransport),
        FIELD3(FieldTypeULong,SMBCEDB_SERVER_ENTRY,ServerStatus),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pMidAtlas),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Server),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DfsRootName),
        0
    };

FIELD_DESCRIPTOR SessionEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SESSION_ENTRY)
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypeStruct,SMBCEDB_SESSION_ENTRY,Session),
        0
    };

FIELD_DESCRIPTOR NetRootEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_NET_ROOT_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_NET_ROOT_ENTRY,Name),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pRdbssNetRoot),
        FIELD3(FieldTypeStruct,SMBCEDB_NET_ROOT_ENTRY,NetRoot),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hShare),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hRootDir),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscEnabled),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscShadowable),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.Disconnected),
        0
    };

FIELD_DESCRIPTOR VNetRootContextFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCE_V_NET_ROOT_CONTEXT)
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pRdbssVNetRoot),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pServerEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pSessionEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pNetRootEntry),
        FIELD3(FieldTypeUShort,SMBCE_V_NET_ROOT_CONTEXT,Flags),
        FIELD3(FieldTypeULong,SMBCE_V_NET_ROOT_CONTEXT,TreeId),
        0
    };

FIELD_DESCRIPTOR ServerTransportFields[] =
    {
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pDispatchVector),
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pTransport),
        FIELD3(FieldTypeULong,SMBCE_SERVER_TRANSPORT,MaximumSendSize),
        0
    };

FIELD_DESCRIPTOR TransportFields[] =
    {
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeTransport),
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeAddress),
        FIELD3(FieldTypeULong,SMBCE_TRANSPORT,Priority),
        0
    };

#define EXCHANGE_FIELDS(__TYPE__) \
      FIELD3(FieldTypePointer,__TYPE__,RxContext),  \
      FIELD3(FieldTypePointer,__TYPE__,SmbCeContext.pServerEntry),  \
      FIELD3(FieldTypeULong,__TYPE__,Status),       \
      FIELD3(FieldTypeULong,__TYPE__,SmbStatus),    \
      FIELD3(FieldTypeUShort,__TYPE__,SmbCeState),    \
      FIELD3(FieldTypeULong,__TYPE__,SmbCeFlags),   \
      FIELD3(FieldTypeStruct,__TYPE__,WorkQueueItem),



FIELD_DESCRIPTOR OrdinaryExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_PSE_ORDINARY_EXCHANGE)
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,StufferStateDbgPtr),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,DataPartialMdl),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificFlags),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificState),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ParseResumeState),
      FIELD3(FieldTypeUShortFlags,SMB_PSE_ORDINARY_EXCHANGE,Flags),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,MessageLength),
      FIELD3(FieldTypeSymbol,SMB_PSE_ORDINARY_EXCHANGE,ContinuationRoutine),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,StartEntryCount),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,AsyncResumptionRoutine),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ReadWrite),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,AssociatedStufferState),
      0
   };

FIELD_DESCRIPTOR TransactExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_TRANSACT_EXCHANGE)
      0
   };

typedef struct _ZZEXCHANGE {
    SMB_EXCHANGE;
} ZZEXCHANGE, *PZZEXCHANGE;

FIELD_DESCRIPTOR GeneralExchangeFields[] =
   {
      EXCHANGE_FIELDS(ZZEXCHANGE)
      0
   };


typedef struct _ZZSMB_HEADER {
    union {
        SMB_HEADER;
        NT_SMB_HEADER Nt;
    };
} ZZSMB_HEADER, *PZZSMB_HEADER;

FIELD_DESCRIPTOR SmbHeaderFields[] =
   {
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Command),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,ErrorClass),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Error),
      FIELD3(FieldTypeULongUnaligned,ZZSMB_HEADER,Nt.Status.NtStatus),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Flags),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Flags2),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,PidHigh),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Pid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Tid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Uid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Mid),
      0
   };




FIELD_DESCRIPTOR StufferStateFields[] =
   {
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,SpecificProblem),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,RxContext),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,Exchange),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderPartialMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,ActualBufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferLimit),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,DataMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentPosition),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentWct),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentBcc),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentDataOffset),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,PreviousCommand),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,CurrentCommand),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,FlagsCopy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,Flags2Copy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,DataSize),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,Started),
      0
   };

//this enum is used in the definition of the structures that can be dumped....the order here
//is not important, only that there is a definition for each dumpee structure.....

typedef enum _STRUCTURE_IDS {
    StrEnum_RX_CONTEXT = 1,
    StrEnum_FCB,
    StrEnum_SRV_OPEN,
    StrEnum_FOBX,
    StrEnum_SRV_CALL,
    StrEnum_NET_ROOT,
    StrEnum_V_NET_ROOT,
    StrEnum_SMBCEDB_SERVER_ENTRY,
    StrEnum_SMBCEDB_SESSION_ENTRY,
    StrEnum_SMBCEDB_NET_ROOT_ENTRY,
    StrEnum_SMB_PSE_ORDINARY_EXCHANGE,
    StrEnum_SMB_TRANSACT_EXCHANGE,
    StrEnum_ZZEXCHANGE,
    StrEnum_SMBSTUFFER_BUFFER_STATE,
    StrEnum_SMBCE_TRANSPORT,
    StrEnum_SMBCE_SERVER_TRANSPORT,
    StrEnum_ZZSMB_HEADER,
    StrEnum_RX_FCB_TABLE_ENTRY,
    StrEnum_RX_FCB_TABLE,
    StrEnum_last
};


//
// List of structs currently handled by the debugger extensions
//

STRUCT_DESCRIPTOR Structs[] =
   {
       STRUCT(RX_CONTEXT,RxContextFields,0xffff,RDBSS_NTC_RX_CONTEXT),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0)),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0xf0)),
       STRUCT(SRV_OPEN,SrvOpenFields,0xffff,RDBSS_NTC_SRVOPEN),
       STRUCT(FOBX,FobxFields,0xffff,RDBSS_NTC_FOBX),
       STRUCT(SRV_CALL,SrvCallFields,0xffff,RDBSS_NTC_SRVCALL),
       STRUCT(NET_ROOT,NetRootFields,0xffff,RDBSS_NTC_NETROOT),
       STRUCT(V_NET_ROOT,VNetRootFields,0xffff,RDBSS_NTC_V_NETROOT),
       STRUCT(SMBCEDB_SERVER_ENTRY,ServerEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SERVER)),
       STRUCT(SMBCEDB_SESSION_ENTRY,SessionEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SESSION)),
       STRUCT(SMBCEDB_NET_ROOT_ENTRY,NetRootEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_NETROOT)),
       STRUCT(SMB_PSE_ORDINARY_EXCHANGE,OrdinaryExchangeFields,0xffff,SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE)),
       STRUCT(SMB_TRANSACT_EXCHANGE,TransactExchangeFields,0xffff,SMB_EXCHANGE_NTC(TRANSACT_EXCHANGE)),
       STRUCT(ZZEXCHANGE,GeneralExchangeFields,0xfff0,SMB_EXCHANGE_NTC(0)),
       STRUCT(SMBSTUFFER_BUFFER_STATE,StufferStateFields,0xffff,SMB_NTC_STUFFERSTATE),
       STRUCT(SMBCE_TRANSPORT,TransportFields,0x0,0xffff),
       STRUCT(SMBCE_SERVER_TRANSPORT,ServerTransportFields,0x0,0xffff),
       STRUCT(ZZSMB_HEADER,SmbHeaderFields,0x0,0xffff),
       STRUCT(RX_FCB_TABLE_ENTRY,FcbTableEntry,0xffff,RDBSS_NTC_FCB_TABLE_ENTRY),
       STRUCT(RX_FCB_TABLE,FcbTable,0xffff,RDBSS_NTC_FCB_TABLE),
       0
   };


ULONG_PTR FieldOffsetOfContextListEntryInRxC(){ return FIELD_OFFSET(RX_CONTEXT,ContextListEntry);}


PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture){
    switch (DebugeeArchitecture) {
    case RX_PROCESSOR_ARCHITECTURE_INTEL:
        return L"kdextx86.dll";
    case RX_PROCESSOR_ARCHITECTURE_MIPS:
        return L"kdextmip.dll";
    case RX_PROCESSOR_ARCHITECTURE_ALPHA:
        return L"kdextalp.dll";
    case RX_PROCESSOR_ARCHITECTURE_PPC:
        return L"kdextppc.dll";
    default:
        return(NULL);
    }
}

//CODE.IMPROVEMENT it is ineficient to try to structure along the lines of "this routine knows
//                 rxstructures" versus "this routine knows debugger extensions". also we
//                 need a precomp.h

BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2)
{
    RX_CONTEXT RxContextBuffer;
    if (!wGetData(RxContext,&RxContextBuffer,sizeof(RxContextBuffer),"RxContextFieldss")) return;
    *pFcb = (ULONG_PTR)(RxContextBuffer.pFcb);
    *pThread = (ULONG_PTR)(RxContextBuffer.LastExecutionThread);
    *pMiniCtx2 = (ULONG_PTR)(RxContextBuffer.MRxContext[2]);
}


FOLLOWON_HELPER_RETURNS
__FollowOnError (
    OUT    PBYTE Buffer2,
    IN     PBYTE followontext,
    ULONG LastId,
    ULONG Index)
{
    if (LastId==0) {
        sprintf(Buffer2,"Cant dump a %s. no previous dump.\n",
                 followontext,Index);
    } else {
        sprintf(Buffer2,"Cant dump a %s from a %s\n",
                 followontext,Structs[Index].StructName);
    }
    return(FOLLOWONHELPER_ERROR);
}
#define FollowOnError(A) (__FollowOnError(Buffer2,A,p->IdOfLastDump,p->IndexOfLastDump))

VOID dprintfsprintfbuffer(BYTE *Buffer);


DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn)
{
    //BYTE DbgBuf[200];
    //sprintf(DbgBuf,"top p,id=%08lx,%d",p,p->IdOfLastDump);
    //dprintfsprintfbuffer(DbgBuf);

    switch (p->IdOfLastDump) {
    case StrEnum_RX_CONTEXT:{
        PRX_CONTEXT RxContext = (PRX_CONTEXT)(&p->StructDumpBuffer[0]);
        sprintf(Buffer2," %08p\n",RxContext->pFcb);
        return(FOLLOWONHELPER_DUMP);
        }
        break;
    default:
        return FollowOnError("irp");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <dav2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1, "..stringfetch") ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s RDBSS+SMBmini Extension dll for Build %d debugging %s kernel for Build %d\n",
                    kind,
                    VER_PRODUCTBUILD,
                    SavedMajorVersion == 0x0c ? "Checked" : "Free",
                    SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

LPSTR LibCommands[] = {
    "dump <Struct Type Name>@<address expr> ",
    "ddd <address expr> -- dump using context"
    "columns <d> -- controls the number of columns in the display ",
    "lg [<logentries>][@filename] -- dump the log",
    "gv -- dump out important variables",
    "activerx [fcbtomatch]-- dump the list of active contexts",
    "flags <value>-- print which flags are actually set (no text yet)",
    "cxr -- looks up cxr value from memory and does !cxr/!kb",
    "irp,thread,fcb,fobx,srvopen,exchange,stuff,smbbuf -- dumps the named item from the last dumpee",
    "version",
    0
};

DECLARE_API( help )
{
    int i;

    dprintf( "\nRDBSS debugger extensions:\n");

    for( i=0; LibCommands[i]; i++ )
        dprintf( "   %s\n", LibCommands[i] );
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );
DECLARE_API( activerx )
{
    //ULONG dwAddress;
    LIST_ENTRY LEbuffer;
    PLIST_ENTRY pRxActiveContexts,pListEntry;
    ULONG_PTR RxContext,CapturedFcb,LastThread,MinirdrCtx2;
    ULONG_PTR MatchFcb = 0x1badf00d;

    pRxActiveContexts = pListEntry = (PLIST_ENTRY)GetExpression("mrxdav!RxActiveContexts");

    if( args && *args ) {
        MatchFcb = GetExpression( args );
    }

    dprintf("\n Firstplentry: %08lx\n", pListEntry);

    for (;;) {
        if (!wGetData((ULONG_PTR)pListEntry,&LEbuffer,sizeof(LEbuffer),"RxActiveContexts")) return;
        if (LEbuffer.Flink == pRxActiveContexts) {
            if (pRxActiveContexts == pListEntry){
                dprintf("Active RxContext List Empty!\n");
            }
            return;
        }
        RxContext = ((ULONG_PTR)LEbuffer.Flink)-FieldOffsetOfContextListEntryInRxC();
        CapturedFcb = LastThread = 0x0badf00d;
        ReadRxContextFields(RxContext,&CapturedFcb,&LastThread,&MinirdrCtx2);
        if (MatchFcb == 0x1badf00d) {
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
        } else if ((MatchFcb == CapturedFcb)
                         || (MatchFcb == LastThread) ) {
            // if a matchfcb is specified and we have a match, the print and dump
            char Bufferqq[100];
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
            sprintf(Bufferqq," %08lx ",RxContext);
            dump( hCurrentProcess,
                  hCurrentThread,
                  dwCurrentPc,
                  dwProcessor,
                  Bufferqq
                  );

        }
        pListEntry = LEbuffer.Flink;
    }
}


#define GV_dprintf(__FORMAT__,__NAME__,__VALUE__) { \
        dprintf( "%s%-30s %08lx " __FORMAT__ "%s",  \
            c&1 ? "    " : "",                      \
            __NAME__,                               \
            dwAddress,                              \
            __VALUE__,                              \
            c&1 ? "\n" : "" );                      \
}
DECLARE_API( gv )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    //CODE.IMPROVEMENT maybe we should hallucinate the moduleprefix instead
    // of having to specify it
    //CODE.IMPROVEMENT if we're not doing that, we shouldn't copy the name!

    //cause stuff to be loaded before we start printing
    dwAddress = GetExpression( "mrxdav!RxExpCXR" );
    dwAddress = GetExpression( "mrxsmb!SmbMmExchangesInUse" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[0], GlobalBool[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !wGetData( dwAddress,&b, sizeof(b), "global BOOL") ) continue;

        GV_dprintf("%10s",GlobalBool[i],(b ? " TRUE" : "FALSE"));
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[0], GlobalShort[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !wGetData( dwAddress,&s,sizeof(s), "global SHORT") )  continue;

        GV_dprintf("%10d",GlobalShort[i],s);
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[0], GlobalLong[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global LONG") )  continue;

        GV_dprintf("%10d",GlobalLong[i],l);
    }

    for( i=0; GlobalPtrs[i]; i++, c++ ) {
        LONG l;

        //ERRPRT( "zaaaaa %s\n", GlobalPtrs[i] );
        strcpy( &buf[0], GlobalPtrs[i] );
        dwAddress = GetExpression( buf );
        //ERRPRT( "zbbbbb %s %08lx\n", GlobalPtrs[i], dwAddress );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalPtrs[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global PTR") )  continue;
        //ERRPRT( "zccccc %s %08lx\n", GlobalPtrs[i], dwAddress );

        GV_dprintf("  %08lx",GlobalPtrs[i],l);
    }

    dprintf( "\n" );
}



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}


DECLARE_API( lg )
{
    ULONG_PTR dwAddress;
    BYTE DataBuffer[MAX_RX_LOG_ENTRY_SIZE];
    BYTE AlternateLine[110];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    BOOLEAN LogEntriesSpecified = FALSE;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();
    dwAddress = GetExpression("mrxdav!s_RxLog");
    if (!wGetData(dwAddress,&RxLog,sizeof(RX_LOG),"RxLog")) return;


    DumpFile = INVALID_HANDLE_VALUE;
    if( args && *args ) {
        LPSTR lpArgs;
        for (;*args;) {
            if (*args=='@') { break;}
            if ((*args>='0') && (*args<='9')) {
                sscanf(args,"%ld",&LogEntries);
                LogEntriesSpecified = TRUE;
                break;
            }
            args++;
        }
        lpArgs = strpbrk(args, "@");
        if (lpArgs) {
            DumpFile = CreateFileA(lpArgs+1,
                       GENERIC_READ|GENERIC_WRITE,0,
                       NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
            if (DumpFile == INVALID_HANDLE_VALUE){
                ULONG rc = LOWORD(GetLastError());
                dprintf("Error Opening <%s> is %d.",lpArgs+1,rc);
                return;
            }
            if (!LogEntriesSpecified) {
                LogEntries = 99999999; //this will be reset to the right size
            }
        }
    }


    // Dump the log header followed by the log entries ...

    dprintf("s_RxLog.State                    %lx\n",RxLog.State);
    dprintf("s_RxLog.CurrentEntry             %lx\n",RxLog.CurrentEntry);
    dprintf("s_RxLog.BaseEntry                %lx\n",RxLog.BaseEntry);
    dprintf("s_RxLog.EntryLimit               %lx\n",RxLog.EntryLimit);
    dprintf("s_RxLog.LogBufferSizeInEntries   %ld\n",RxLog.LogBufferSizeInEntries);
    dprintf("s_RxLog.NumberOfEntriesIgnored   %ld\n",RxLog.NumberOfEntriesIgnored);
    dprintf("s_RxLog.NumberOfLogWriteAttempts %ld\n",RxLog.NumberOfLogWriteAttempts);
    dprintf("s_RxLog.NumberOfLogWraps         %ld\n",RxLog.NumberOfLogWraps);

    if (LogEntries > RxLog.LogBufferSizeInEntries) {
        LogEntries = RxLog.LogBufferSizeInEntries;
    }
    if (LogEntries < 1) {
        LogEntries = 1;
    }

    CurrentEntry = RxLog.CurrentEntry;
    CurrentEntry -= (LogEntries-1);
    if (CurrentEntry < RxLog.BaseEntry) {
        CurrentEntry += (RxLog.EntryLimit - RxLog.BaseEntry);
    }

    for (;;) {
        ULONG TextPtr;
        BOOLEAN ExtraOrdinaryLogEntry;
        LogEntries--;
        if ( CheckControlC() ) {
            return;
        }
        if (!wGetData((ULONG_PTR)CurrentEntry,&TextPtr,sizeof(TextPtr),"TextPtr")) return;
        if (!wGetData(TextPtr,&DataBuffer[0],sizeof(DataBuffer),"LogEntryBuffer")) return;

        ExtraOrdinaryLogEntry = (DataBuffer[0] == '#')&&(DataBuffer[1] == '>')&&(DataBuffer[3] == 0);

        if (!ExtraOrdinaryLogEntry) {
            //dprintf("-%06d:  %s\n",LogEntries,DataBuffer);
            DumpRoutine(LogEntries,DataBuffer);
        } else {
            ULONG BinaryArgs = DataBuffer[2]-'0';
            PULONG_PTR x = (PULONG_PTR)&DataBuffer[sizeof(ULONG_PTR)];
            char Buffers[12*100]; //CODE.IMPROVEMENT this is poor but effective
            ULONG i;
            ULONG_PTR BinaryStringMask;
            PSZ ffFormat;

            //dprintf("textptr = %08lx, binaryString = %08lx\n", TextPtr, x[0]);
            for (i=1,BinaryStringMask=x[0];i<=BinaryArgs;i++) {
                if (BinaryStringMask & (1<<(i-1))) {
                    //dprintf("Stringing %d\n",i);
                    wGetString(x[i],&Buffers[i*100]); //this could fail!!!!
                    x[i] = ((ULONG_PTR)&Buffers[i*100]);
                    //dprintf("    string is %s\n",x[i]);
                }
            }

            ffFormat = (PSZ)(x[1]);

            switch (BinaryArgs) {
            case 9:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
                break;
            case 8:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8]);
                break;
            case 7:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7]);
                break;
            case 6:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6]);
                break;
            case 5:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5]);
                break;
            case 4:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4]);
                break;
            case 3:
                sprintf(AlternateLine,ffFormat,x[2],x[3]);
                break;
            case 2:
                sprintf(AlternateLine,ffFormat,x[2]);
                break;
            case 1:
                sprintf(AlternateLine,ffFormat);
                break;
            }
            DumpRoutine(LogEntries,AlternateLine);
        }
        if (LogEntries==0) break;
        CurrentEntry++;
        if (CurrentEntry==RxLog.EntryLimit) {
            CurrentEntry = RxLog.BaseEntry;
        }
    }

    if (DumpFile != INVALID_HANDLE_VALUE) {
        CloseHandle(DumpFile);
        DumpFile = INVALID_HANDLE_VALUE;
    }
}


PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);

PWINDBG_EXTENSION_ROUTINE
GetKdExtProcAddress(
    IN PCSTR FuncName
    )
{
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = NULL;
    //dprintf( "yaya\n");
    if (hExtensionMod == NULL) {
        if (DebugeeArchitecture == 0) {
            ULONG_PTR pArchitecture;
            ReloadSymbols(" rdbss.sys");
            pArchitecture = GetExpression("mrxdav!RxProcessorArchitecture");
            if (pArchitecture==0) {
                dprintf("couldn't get architecture value...\n");
                return NULL;
            }
            if (!wGetData(pArchitecture,&DebugeeArchitecture,sizeof(DebugeeArchitecture),"RxArch")) return NULL;
            if ((DebugeeArchitecture&0x0fff0000) != 0xabc0000) {
                dprintf("\n Bad DebugeeArchitecture %08lx\n", DebugeeArchitecture);
                return(NULL);
            }
            DebugeeArchitecture &= 0xffff;
        }

        ExtensionLib = GetExtensionLibPerDebugeeArchitecture(DebugeeArchitecture);
        if (ExtensionLib == NULL) {
            dprintf( "bad debuggee arch\n");
            return(NULL);
        }

        hExtensionMod = LoadLibrary( ExtensionLib );
        if (hExtensionMod == NULL) {
            dprintf( "couldn't load %ws\n", ExtensionLib );
            return(NULL);
        }

    }

    WindbgExtRoutine = (PWINDBG_EXTENSION_ROUTINE)GetProcAddress( hExtensionMod, FuncName );
    if (WindbgExtRoutine == NULL) {
        dprintf( "couldn't find %ws%s\n", ExtensionLib, FuncName );
    }
    return WindbgExtRoutine;
}

#define CALL_THRU(NAME,ARGS) { \
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = GetKdExtProcAddress(NAME); \
    if (WindbgExtRoutine != NULL) {                                                   \
        (WindbgExtRoutine)( hCurrentProcess,                                          \
                            hCurrentThread,                                           \
                            dwCurrentPc,                                              \
                            dwProcessor,                                              \
                            ARGS                                                      \
                            );                                                        \
    }                                                                                 \
}

DECLARE_API( testr )
{

    CALL_THRU ( "threadfields", "");
}

DECLARE_API( dump );
VOID
__FollowOnHelper (
     PFOLLOWON_HELPER_ROUTINE Callee,
     HANDLE                 hCurrentProcess,
     HANDLE                 hCurrentThread,
     ULONG                  dwCurrentPc,
     ULONG                  dwProcessor,
     PCSTR                  args
     )
{
    BYTE Name[100], Buffer2[200];
    FOLLOWON_HELPER_RETURNS ret;
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    if (!p) {
        dprintf("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    ret = Callee(p,Name,Buffer2);
    if (p!= NULL) FreePersistentInfoView(p);
    p = NULL;

    switch (ret) {

    case FOLLOWONHELPER_DUMP:
        dump(hCurrentProcess,
             hCurrentThread,
             dwCurrentPc,
             dwProcessor,
             Buffer2
             );
        break;

    case FOLLOWONHELPER_CALLTHRU:
        CALL_THRU ( Name, Buffer2);
        break;

    case FOLLOWONHELPER_ERROR:
        dprintf("%s",Buffer2);
        break;

    case FOLLOWONHELPER_DONE:
        break;
    }

    return;
}
#define FollowOnHelper(a) {            \
    __FollowOnHelper(a,                \
                     hCurrentProcess,  \
                     hCurrentThread,   \
                     dwCurrentPc,      \
                     dwProcessor,      \
                     args);            \
}

DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn);
DECLARE_API( fcb )
{
    FollowOnHelper(FcbFollowOn);
}


DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

DECLARE_API( cxr )
{
    ULONG_PTR dwAddress,cxr;
    BYTE NumBuffer[16];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();


    dwAddress = GetExpression("mrxdav!RxExpCXR");
    if (!wGetData(dwAddress,&cxr,sizeof(cxr),"cxr")) return;

    dprintf("\nRxExpCXR=%08lx\n",cxr);
    sprintf(NumBuffer,"%08lx \n",cxr);

    CALL_THRU ( "cxr", NumBuffer);
    if (DebugeeArchitecture==0) {
        CALL_THRU ( "kb", "");
    }

}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\inc\ntumrefl.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ntumrefl.h

Abstract:

    This module defines the types and functions which make up the reflector
    library. These functions are used by the miniredirs to reflect calls upto
    the user mode.

Author:

    Andy Herron (andyhe)

--*/

#ifndef _NTUMREFL_H
#define _NTUMREFL_H

//
//  These two structures are opaque to callers of the reflector library but
//  we'll define them here to make the compiler validate the types sent in.
//

typedef struct _UMRX_USERMODE_REFLECT_BLOCK *PUMRX_USERMODE_REFLECT_BLOCK;
typedef struct _UMRX_USERMODE_WORKER_INSTANCE *PUMRX_USERMODE_WORKER_INSTANCE;

//
//  These structures and function prototypes are for the user mode reflector.
//

#define UMREFLECTOR_CURRENT_VERSION 1

//
// This structure will be exposed to both user and kernel mode components.
//
#define UMRX_WORKITEM_IMPERSONATING 0X00000001
typedef struct _UMRX_USERMODE_WORKITEM_HEADER {

    //
    // The kernel mode component stores the context in here.
    //
    PVOID Context;

    //
    // The kernel mode context uses the serial number to keep track of the
    // number of requests.
    //
    ULONG SerialNumber;

    //
    // This allows the kernel mode component of the reflector library to track
    // request to response. If this is zero, then no response is present in the
    // workitem.
    //
    USHORT WorkItemMID;

    //
    // Length of the workitem.
    //
    ULONG WorkItemLength;

    //
    // Flags describing the state of the request.
    //
    ULONG Flags;

    BOOL callWorkItemCleanup;

    union {
        IO_STATUS_BLOCK IoStatus;
        IO_STATUS_BLOCK;
    };

} UMRX_USERMODE_WORKITEM_HEADER, *PUMRX_USERMODE_WORKITEM_HEADER;

//
// The structure that is sent down to the usermode when starting the 
// DAV MiniRedir.
//
typedef struct _DAV_USERMODE_DATA {

    //
    // The ProcessId of the svchost.exe process that is loading the webclnt.dll
    //
    ULONG ProcessId;

    //
    // The WinInet's Cache Path.
    //
    WCHAR WinInetCachePath[MAX_PATH];

} DAV_USERMODE_DATA, *PDAV_USERMODE_DATA;

//
// This routine registers the user mode process with the kernel mode component.
// The DriverDeviceName must be a valid name of the form L"\\Device\\foobar"
// where foobar is the device name registered with RxRegisterMinirdr. The 
// Reflector is returned by the call and points to an opaque structure that
// should be passed to subsequent calls. This structure gets initialized during
// this call. The return value is a Win32 error code. STATUS_SUCCESS is 
// returned on success.
//
ULONG
UMReflectorRegister (
    PWCHAR DriverDeviceName,
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK *Reflector
    );

//
// This will close down the associated user mode reflector instance. If any user
// mode threads are waiting for requests, they'll return immediately.  This call
// will not return until all threads are closed down and all associated
// structures are freed.  A user application should not use the Reflector after
// this call has been started except to complete work on a request that is
// pending.
//
ULONG
UMReflectorUnregister(
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    );

//
// We have instance handles for those apps with multiple threads pending in
// the library at once. You should open an instance thread for each worker
// thread you'll have sending down an IOCTL waiting for work.
//
ULONG
UMReflectorOpenWorker(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    PUMRX_USERMODE_WORKER_INSTANCE *WorkerHandle
    );

//
// Even after calling UMReflectorUnregister, you should still call
// UMReflectorCloseWorker on each worker handle instance you have open.
//
VOID
UMReflectorCloseWorker(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle
    );

//
// This starts the Mini-Redir.
//
ULONG
UMReflectorStart(
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle
    );

//
// This stops the Mini-Redir.
//
ULONG
UMReflectorStop(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle
    );

//
// If any user mode threads are waiting for requests, they'll return
// immediately.
//
ULONG
UMReflectorReleaseThreads(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle
    );

//
// This allocates a work item that may have additional space below it for
// Mini-Redir specific information. It should be freed using
// ReflectorCompleteWorkItem below.
//
PUMRX_USERMODE_WORKITEM_HEADER
UMReflectorAllocateWorkItem(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    ULONG AdditionalBytes
    );

//
// This may free the work item.  It may unmap and possibly free both the user
// and kernel mode associated buffers.  If a kernel mode associated buffer is
// stored in this WorkItem, the WorkItem will be posted back to the kernel mode
// process for freeing.  Once the call to ReflectorCompleteWorkItem is called,
// the WorkItem should not be touched by the calling application.
//
ULONG
UMReflectorCompleteWorkItem(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem
    );

//
// This user mode thread is requesting a client request to work on. It will not
// return until the kernel portion of the library has a request to send up to
// user mode. If the PreviousWorkItem is not NULL, then this work item contains
// a response that will be sent down to the kernel. This eliminates a transition
// for the typical case of a worker thread returning a result and then asking
// for another work item.
//
ULONG
UMReflectorGetRequest (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER ResponseWorkItem OPTIONAL,
    PUMRX_USERMODE_WORKITEM_HEADER ReceiveWorkItem,
    BOOL revertAlreadyDone
    );

//
// A response is sent down to kernel mode due to an action in user mode being
// completed. The kernel mode library does not get another request for this
// thread. Both the request and response buffers associated with the WorkItem
// will be unmapped/unlocked/freed (when the library has done the
// allocating/locking/mapping).
//
ULONG
UMReflectorSendResponse(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem
    );

ULONG
UMReflectorImpersonate(
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem,
    HANDLE ImpersonationToken
    );

ULONG
UMReflectorRevert (
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem
    );

//
//  If the user mode side needs to allocate memory in the shared memory
//  area, it can do so using these calls.  Note that if the memory isn't
//  freed up by the caller, it will be freed when the kernel mode async work
//  context is freed.
//
ULONG
UMReflectorAllocateSharedMemory(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    SIZE_T  SizeRequired,
    PVOID *SharedBuffer
    );

ULONG
UMReflectorFreeSharedMemory(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    PVOID SharedBuffer
    );

VOID
UMReflectorCompleteRequest(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    );

VOID
DavCleanupWorkItem(
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem
    );

//
// The control codes specific to the reflector library.
//
#define IOCTL_UMRX_RELEASE_THREADS           \
                     _RDR_CONTROL_CODE(222, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_UMRX_GET_REQUEST               \
                     _RDR_CONTROL_CODE(223, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_UMRX_RESPONSE_AND_REQUEST      \
                     _RDR_CONTROL_CODE(224, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_UMRX_RESPONSE                  \
                     _RDR_CONTROL_CODE(225, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_UMRX_GET_LOCK_OWNER            \
                     _RDR_CONTROL_CODE(226, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_UMRX_START                     \
                    _RDR_CONTROL_CODE(227, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_UMRX_STOP                      \
                    _RDR_CONTROL_CODE(228, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif // _NTUMREFL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\inc\umrx.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    umrx.h

Abstract:

    This module defines the types and functions which make up the reflector
    library. These functions are used by the miniredirs to reflect calls upto
    the user mode.

Author:

    Rohan Kumar    [rohank]    14-March-1999

Revision History:

--*/

#ifndef _UMRX_H_
#define _UMRX_H_

#include "align.h"
#include "status.h"

//
// Unreferenced local variable.
//
#pragma warning(error:4101)

IMPORTANT_STRUCTURE(UMRX_ASYNCENGINE_CONTEXT);
IMPORTANT_STRUCTURE(UMRX_DEVICE_OBJECT);

//
// The BUGBUG macro expands to NOTHING. Its basically used to describe problems
// associated with the current code.
//
#define BUGBUG(_x_)

//
// The argument signatures that are used in a lot of the reflector and miniredir
// functions.
//
#define UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE \
                            PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext, \
                            PRX_CONTEXT RxContext

//
// The arguments that are passed to a lof of the reflector and miniredir
// functions.
//
#define UMRX_ASYNCENGINE_ARGUMENTS AsyncEngineContext,RxContext

//
// The global list of all the currently active AsyncEngineContexts and the
// resource that is used to synchronize access to it.
//
extern LIST_ENTRY UMRxAsyncEngineContextList;
extern ERESOURCE UMRxAsyncEngineContextListLock;

//
// The ASYNCENG_HISTORY structure which is used to keep track of the history
// of AsyncEngineContext structure.
//
#define UMRX_ASYNCENG_HISTORY_SIZE 32
typedef struct _ASYNCENG_HISTORY {
    ULONG Next;
    ULONG Submits;
    struct {
        ULONG Longs[2];
    } Markers[UMRX_ASYNCENG_HISTORY_SIZE];
} ASYNCENG_HISTORY, *PASYNCENG_HISTORY;

//
// This macro defines the flags of the AsyncEngineContext strucutre.
//
#define UMRX_ASYNCENG_DEFINE_CTX_FLAG(a, c) \
                RX_DEFINE_FLAG(UMRX_ASYNCENG_CTX_FLAG_##a, c, 0xffff)
typedef enum {
    UMRX_ASYNCENG_DEFINE_CTX_FLAG(ASYNC_OPERATION, 0)
} UMRX_ASYNCENG_CONTEXT_FLAGS;

//
// The prototype of the ContextFormatRoutine specified by the Miniredir.
//
typedef
NTSTATUS
(*PUMRX_ASYNCENG_CONTEXT_FORMAT_ROUTINE) (
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    USHORT FormatContext
    );

//
// The prototype of the continuation routine specified by the Miniredir.
//
typedef
NTSTATUS
(*PUMRX_ASYNCENG_CONTINUE_ROUTINE) (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

//
// The prototype of the format routine specified by the Miniredir.
//
typedef
NTSTATUS
(*PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE) (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

//
// The prototype of the precompletion routine specified by the Miniredir.
//
typedef
BOOL
(*PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE) (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

//
// The various states of an AsyncEngineContext.
//
typedef enum _UMRX_ASYNCENGINE_CONTEXT_STATE {
    UMRxAsyncEngineContextAllocated = 0,
    UMRxAsyncEngineContextInUserMode,
    UMRxAsyncEngineContextBackFromUserMode,
    UMRxAsyncEngineContextCancelled
} UMRX_ASYNCENGINE_CONTEXT_STATE;

//
// The AsyncEngineContext strucutre that is shared across all the miniredirs.
// It contains information common to all the miniredirs.
//
typedef struct _UMRX_ASYNCENGINE_CONTEXT {

    //
    // The header below is a common header which is present at the start of all
    // the data strucutres manipulated by the RDBSS and the MiniRedirs. It is
    // used for debugging purposes and for keeping track of the number of times
    // a node (data structure) has been referenced.
    //
    MRX_NORMAL_NODE_HEADER;

    //
    // This listEntry is used to insert the AsyncEngineContext into the global
    // UMRxAsyncEngineContextList list.
    //
    LIST_ENTRY ActiveContextsListEntry;

    UMRX_ASYNCENGINE_CONTEXT_STATE AsyncEngineContextState;

    //
    // Is this context handling a synchronous or an asynchronous operation?
    //
    BOOL AsyncOperation;

    //
    // If this is an AsyncOperation, then RxLowIoCompletion is called only if
    // this is set to TRUE. Some operations like CreateSrvCall are Async but
    // do not need LowIoCompletion to be called.
    //
    BOOL ShouldCallLowIoCompletion;

    //
    // Was IoMarkIrpPending called on the Irp that is being handled by this
    // AsyncEngineContext?
    //
    BOOL ContextMarkedPending;

    //
    // The system tick count when this context was created. This value is used
    // in timing out requests that take more than a specified time.
    //
    LARGE_INTEGER CreationTimeInTickCount;

    //
    // The RxContext data structure that is passed in by the RDBSS. It describes
    // an Irp while it is being processed and contains state information that
    // allows global resources to be released as the Irp is completed.
    //
    PRX_CONTEXT RxContext;

    //
    // The context ptr that saves the incoming (from RDBSS) state of
    // MRxContext[0] (which is a field  of the RxContext data structure).
    //
    PVOID SavedMinirdrContextPtr;

    //
    // Pointer to IRP used to call down to the underlying file system.
    //
    PIRP CalldownIrp;

    //
    // The I/O status block is set to indicate the status of a given I/O
    // request.
    //
    union {
        IO_STATUS_BLOCK;
        IO_STATUS_BLOCK IoStatusBlock;
    };

    //
    // The work item which is queued to be completed.
    //
    RX_WORK_QUEUE_ITEM  WorkQueueItem;

    //
    // Flags that set and indicate the state of the AsyncEngineContext.
    //
    USHORT Flags;

    BOOLEAN FileInformationCached;
    BOOLEAN FileNotExists;

    BOOLEAN ParentDirInfomationCached;
    BOOLEAN ParentDirIsEncrypted;

    //
    // The continuation routine which is to be called for this I/O request.
    //
    PUMRX_ASYNCENG_CONTINUE_ROUTINE Continuation;

    //
    //  List of shared memory allocations for this context.  All are freed when
    //  this context is freed.
    //
    LIST_ENTRY AllocationList;

    //
    // The UserMode structure.
    //
    struct {
        //
        // The work entry thats inserted into the Queue of the
        // UMRdrDeviceObject.
        //
        LIST_ENTRY WorkQueueLinks;

        //
        // The routine that formats the arguments of the I/O request which is
        // reflected to the usermode.
        //
        PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine;

        //
        // The routine that is called (to do some final cleanup etc.)just before
        // an I/O operation that was sent to the usermode gets completed. 
        // 
        //
        PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PrecompletionRoutine;

        //
        // The event used to signal a thread waiting for a MID to be freed up. 
        //
        KEVENT WaitForMidEvent;

        //
        // The serial number set before sending this conttext to the user mode.
        //
        ULONG CallUpSerialNumber;

        //
        // The MID value of the context.
        //
        USHORT CallUpMid;

        union {
            struct {
                //
                //
                //
                PBYTE CapturedOutputBuffer;
            };
            //
            //
            //
            ULONG SetInfoBufferLength;
        };
    } UserMode;

    //
    // The context passed to the function called in the context of a worker 
    // thread.
    //
    PVOID     PostedOpContext;

    //
    // The completion status of a posted operation. Operations get posted to 
    // worker threads created by RDBSS.
    //
    NTSTATUS  PostedOpStatus;

    //
    // This is set to the global serialnumber (for this operation) of RxContext.
    //
    ULONG SerialNumber;

    //
    // Used to keep track of the history of the operations on the AsynEngCtx.
    //
    ASYNCENG_HISTORY History;

    //
    // This is set to the CurrentIrp in RxContext which points to the
    // origination irp.
    //
    PIRP RxContextCapturedRequestPacket;

} UMRX_ASYNCENGINE_CONTEXT, *PUMRX_ASYNCENGINE_CONTEXT;

#define SIZEOF_UMRX_ASYNCENGINE_CONTEXT   sizeof(UMRX_ASYNCENGINE_CONTEXT)

//
// The API of the reflector library exposed to the miniredirs. These are the
// only functions of the library that the miniredirs should use to reflect
// the requests to the user mode.
//

NTSTATUS
UMRxInitializeDeviceObject(
    OUT PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN USHORT MaxNumberMids,
    IN USHORT InitialMids,
    IN SIZE_T HeapSize
    );

NTSTATUS
UMRxCleanUpDeviceObject(
    PUMRX_DEVICE_OBJECT DeviceObject
    );

NTSTATUS
UMRxAsyncEngOuterWrapper(
    IN PRX_CONTEXT RxContext,
    IN ULONG AdditionalBytes,
    IN PUMRX_ASYNCENG_CONTEXT_FORMAT_ROUTINE ContextFormatRoutine,
    USHORT FormatContext,
    IN PUMRX_ASYNCENG_CONTINUE_ROUTINE Continuation,
    IN PSZ RoutineName
    );

NTSTATUS
UMRxSubmitAsyncEngUserModeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine,
    PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PrecompletionRoutine
    );

BOOLEAN
UMRxFinalizeAsyncEngineContext(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT *AEContext
    );

NTSTATUS
UMRxAsyncEngineCalldownIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN OUT PVOID Context
    );

typedef
NTSTATUS
(*PUMRX_POSTABLE_OPERATION) (
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext
    );
NTSTATUS
UMRxPostOperation (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PVOID PostedOpContext,
    IN PUMRX_POSTABLE_OPERATION Operation
    );

PBYTE
UMRxAllocateSecondaryBuffer (
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    SIZE_T Length
    );

NTSTATUS
UMRxFreeSecondaryBuffer (
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    PBYTE  Buffer
    );

VOID
UMRxReleaseCapturedThreads (
    IN OUT PUMRX_DEVICE_OBJECT UMRdrDeviceObject
    );

VOID
UMRxAssignWork (
    IN PUMRX_DEVICE_OBJECT UMRdrDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER InputWorkItem,
    IN ULONG InputWorkItemLength,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER OutputWorkItem,
    IN ULONG OutputWorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UMRxResumeAsyncEngineContext(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
UMRxImpersonateClient(
    IN PSECURITY_CLIENT_CONTEXT SecurityClientContext,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    );

NTSTATUS
UMRxReadDWORDFromTheRegistry(
    IN PWCHAR RegKey,
    IN PWCHAR ValueToRead,
    OUT LPDWORD DataRead
    );


#define UMRxRevertClient() PsRevertToSelf()

//
// Macro definitions used by the reflector and the miniredirs.
//

//
// Check to see if we have a correct AsyncEngineContext node.
//
#define ASSERT_ASYNCENG_CONTEXT(__p)  \
                        ASSERT(NodeType(__p) == UMRX_NTC_ASYNCENGINE_CONTEXT)

//
// This macro is used to do the async completion for read/write/locks. Note
// that the call to lowiocompletion will try to complete the irp thereby
// freeing the user's mdl. We use this macro so that there will be only one
// version of this code. When we combine the start routines, this will be
// unmacroed.
//
#define UMRxAsyncEngAsyncCompletionIfNecessary(AECTX, RXCONTEXT) {       \
    if (ContinueEntryCount > 1) {                                        \
        BOOLEAN FinalizationComplete;                                    \
        if (FALSE) { DbgBreakPoint(); }                                  \
        (RXCONTEXT)->StoredStatus = NtStatus;                            \
        RxLowIoCompletion((RXCONTEXT));                                  \
        FinalizationComplete = UMRxFinalizeAsyncEngineContext(&(AECTX));  \
        ASSERT(!FinalizationComplete);                                   \
    }                                                                    \
}

//
// This macro allows one to execute conditional debugging code.
//
#if DBG
#define DEBUG_ONLY_CODE(x) x
#else
#define DEBUG_ONLY_CODE(x)
#endif

//
// The heap is shared between kernel and user but only the kernel component 
// allocates and frees into the heap.
//
typedef struct _UMRX_SHARED_HEAP {
    LIST_ENTRY  HeapListEntry;
    PBYTE       VirtualMemoryBuffer;
    SIZE_T      VirtualMemoryLength;
    PVOID       Heap;
    ULONG       HeapAllocationCount;
    BOOLEAN     HeapFull;
} UMRX_SHARED_HEAP, * PUMRX_SHARED_HEAP;

//
// NodeType Codes.
//
#define UMRX_NTC_ASYNCENGINE_CONTEXT  ((USHORT)0xedd0)

//
// This strucutre defines the fields which the reflector and the miniredir can
// share and is encapsulated in the miniredirs device object. The miniredirs
// device object may contain some other fields which are specific to its
// operation.
//
typedef struct _UMRX_DEVICE_OBJECT {

    //
    // The RDBSS's device object structure.
    //
    union {
        RDBSS_DEVICE_OBJECT;
        RDBSS_DEVICE_OBJECT RxDeviceObject;
    };

    //
    // The max size of the heap that can be allocated.
    //
    SIZE_T NewHeapSize;

    //
    // List of shared heaps created by worker threads.
    //
    LIST_ENTRY SharedHeapList;

    //
    // Used to synchronize the heap allocation/deletion, creation/destruction.
    //
    ERESOURCE HeapLock;

    //
    // Mid atlas and its management and synchronization.
    //
    struct {
        PRX_MID_ATLAS MidAtlas;
        FAST_MUTEX MidManagementMutex;
        LIST_ENTRY WaitingForMidListhead;
    };

    struct {

        //
        // The Queue of the device object where the requests which need reflection
        // wait.
        //
        KQUEUE Queue;
        
        //
        // Used to synchronize the KQUEUE insertions.
        //
        ERESOURCE QueueLock;
        
        //
        // The timeout value used by the worker threads when waiting on the 
        // KQUEUE for requests to be taken to user mode.
        //
        LARGE_INTEGER TimeOut;
        
        //
        // Used to release the worker threads which are waiting on the KQUEUE.
        // Once the worker threads are released, no requests can be reflected.
        //
        LIST_ENTRY PoisonEntry;
        
        //
        // Used to signal the thread (which comes down with an IOCTL to release
        // the worker threads) waiting for all the worker threads to be
        // released.
        //
        KEVENT RunDownEvent;
        
        //
        // Number of worker threads waiting on the KQUEUE.
        //
        ULONG NumberOfWorkerThreads;
        
        //
        // Number of workitems (requests to be reflected) in the queue.
        //
        ULONG NumberOfWorkItems;
        
        //
        // Are the worker threads still willing to take the requests.
        //
        BOOLEAN WorkersAccepted;

    } Q;

    //
    // Always incremented and assigned to the AsyncEngineContext's serial
    // number.
    //
    ULONG NextSerialNumber;

} UMRX_DEVICE_OBJECT, *PUMRX_DEVICE_OBJECT;

#endif   //_UMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

//#include <windef.h>

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeULongUnaligned,
    FieldTypeULongFlags,
    FieldTypeLong,
    FieldTypeLongUnaligned,
    FieldTypeUShort,
    FieldTypeUShortUnaligned,
    FieldTypeUShortFlags,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    //USHORT           Offset;      // The offset of the field in the structure
    LONG             Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRIPTOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    ULONG             EnumManifest;
    FIELD_DESCRIPTOR  *FieldDescriptors;
    USHORT            MatchMask;
    USHORT            MatchValue;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors,MatchMask,MatchValue) \
        { #StructTypeName,sizeof(StructTypeName), \
          StrEnum_##StructTypeName,               \
          FieldDescriptors,MatchMask,MatchValue}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\strucsup.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <dav2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

//need this for unaligned smbget macros
#include <smbgtpt.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
//EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf
#define    PRINTF     dprintf

#define    NL      1
#define    NONL    0

BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
#ifndef RXKD_2col
ULONG s_NoOfColumns = 1;
#else
ULONG s_NoOfColumns = 2;
#endif

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
wPrintStringU( IN LPSTR PrefixMsg OPTIONAL, IN PUNICODE_STRING puStr, IN LPSTR SuffixMsg OPTIONAL )
{
    PWCHAR    StringData;
    UNICODE_STRING UnicodeString;
    ULONG BytesRead;

    if (PrefixMsg == NULL) {
        PrefixMsg = "";
    }
    if (SuffixMsg == NULL) {
        SuffixMsg = "";
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }
    UnicodeString.Buffer =  StringData; //puStr->Buffer;
    UnicodeString.Length =  puStr->Length;
    UnicodeString.MaximumLength =  puStr->MaximumLength;

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        dprintf("%s%wZ%s", PrefixMsg, &UnicodeString, SuffixMsg );
    } else {
        dprintf("MEMORYREAD FAILED %s%s",PrefixMsg,SuffixMsg);
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

VOID
SetFlagString(
    ULONG Value,
    PCHAR FlagString
    )
{
    ULONG i,t,mask;
    *FlagString = '('; FlagString++;
    for (i=t=0,mask=1;i<32;i++,mask<<=1) {
        //PRINTF("hithere %08lx %08lx %08lx\n",Value,mask,i);
        if (i==t+10) {
            *FlagString = ':'; FlagString++;
            t=t+10;
        }
        if (Value&mask) {
            *FlagString = '0'+(UCHAR)(i-t); FlagString++;
        }
    }

    *FlagString = ')'; FlagString++;
    *FlagString = 0;
}

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16X%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongUnaligned:
        case FieldTypeLongUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUlong( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShortUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUshort( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongFlags:{ULONG Value; char FlagString[60];
            Value = *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset );
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUShortFlags:{USHORT Value; char FlagString[60];
            Value = *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUnicodeString:
            wPrintStringU( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NULL );
            PRINTF( NewLine );
            break;
        //case FieldTypeAnsiString:
        //    //PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
        //    //PRINTF( NewLine );
        //    PRINTF( NewLine );
        //    break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numericla value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
            }
            break;
        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
        case FieldTypeFileTime:
        default:
            ERRPRT( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}

DECLARE_API( columns )
{
    ULONG NoOfColumns;
    int   i;

    //SETCALLBACKS();

    //sscanf(lpArgumentString,"%ld",&NoOfColumns);
    sscanf(args,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@"
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PPERSISTENT_RDR2KD_INFO
LocatePersistentInfoFromView()
/*
    the purpose of this routine is to allocate or find the named section that holds the
    data we expect to find across calls. the way that we make this persitent is that we
    do not close the handle used to create the view. it will go away when the process does.
*/
{
    BYTE SectionName[128];
    DWORD SectionSize;
    DWORD ProcessId;
    HANDLE h;
    BOOLEAN CreatedSection = FALSE;
    PPERSISTENT_RDR2KD_INFO p;

    ProcessId = GetCurrentProcessId();
    SectionSize = sizeof(PERSISTENT_RDR2KD_INFO);
    sprintf(SectionName,"Rdr2KdSection_%08lx",ProcessId);
    //PRINTF("sectionname=%s, size=%x\n",SectionName,SectionSize);

    h = OpenFileMappingA(
           FILE_MAP_WRITE, //DWORD  dwDesiredAccess,	// access mode
           FALSE,           //BOOL  bInheritHandle,	// inherit flag
           SectionName     //LPCTSTR  lpName 	// address of name of file-mapping object
           );

    if (h==NULL) {
        h = CreateFileMappingA(
                   (HANDLE)IntToPtr(0xFFFFFFFF), // HANDLE  hFile,	// handle of file to map
                    NULL,              //LPSECURITY_ATTRIBUTES  lpFileMappingAttributes,	// optional security attributes
                    PAGE_READWRITE,    //DWORD  flProtect,	// protection for mapping object
                    0,                 //DWORD  dwMaximumSizeHigh,	// high-order 32 bits of object size
                    SectionSize,       //DWORD  dwMaximumSizeLow,	// low-order 32 bits of object size
                    SectionName        //LPCTSTR  lpName 	// name of file-mapping object
                    );
        if (h==NULL) {
            return(FALSE);
        }
        CreatedSection = TRUE;
    }

    //now we have a filemapping....get a view.....
    p = MapViewOfFile(h,FILE_MAP_WRITE,0,0,0);
    if (p==NULL) {
        CloseHandle(h);
        return(NULL);
    }

    if (CreatedSection) {
        //zero the stuff that needs to be zeroed....
        ULONG i;
        p->IdOfLastDump = 0;
        for (i=0;i<100;i++) {
            p->LastAddressDumped[i] = 0;
        }
        p->OpenCount = 100;
    } else {
        CloseHandle(h);
        p->OpenCount++;
    }

    //PRINTF("Opencount for persistent section = %08lx\n",p->OpenCount);
    return(p);
}

VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    )
{
    UnmapViewOfFile(p);
}

VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct
    )
{
    DWORD Index = (DWORD)(pStruct - Structs);
    DWORD SizeToRead = min(pStruct->StructSize,2048);
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    PRINTF("top @ %lx and %lx for %s(%d,%d)\n",dwAddress,p,pStruct->StructName,Index,p->IdOfLastDump);
    if (!p) {
        PRINTF("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    if ((dwAddress==0) &&(Index<100)) {
        dwAddress = p->LastAddressDumped[Index];
        PRINTF("setting @ %lx and %lx for %s\n",dwAddress,p->LastAddressDumped[Index],pStruct->StructName);
    }

    if (wGetData(dwAddress,&p->StructDumpBuffer[0],SizeToRead,pStruct->StructName)) {

        p->LastAddressDumped[Index] = dwAddress;
        p->IdOfLastDump = pStruct->EnumManifest;
        p->IndexOfLastDump = Index;

        PRINTF("++++++++++++++++ %s(%d/%d)@%lx ---+++++++++++++\n",
            pStruct->StructName,
            p->IdOfLastDump,p->IndexOfLastDump,
            dwAddress);
        PrintStructFields(
            dwAddress,
            &p->StructDumpBuffer[0],
            pStruct->FieldDescriptors);
        PRINTF("---------------- %s@%lx ----------------\n",
            pStruct->StructName,
            dwAddress);
    }

    if (p!= NULL) FreePersistentInfoView(p);
    return;
}


DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                DumpAStruct(dwAddress,&Structs[Index]);
                //if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize,"..structure")) {
                //
                //    PRINTF(
                //        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //    PrintStructFields(
                //        dwAddress,
                //        &DataBuffer,
                //        Structs[Index].FieldDescriptors);
                //    PRINTF(
                //        "---------------- %s@%lx ----------------\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //} else {
                //    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                //}
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
#if 0
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
#endif
            //
            // here we try to figure out what to display based on the context....whoa, nellie!
            //
            USHORT Tag;
            STRUCT_DESCRIPTOR *pStructs = Structs;
            ULONG             NameIndex = INVALID_INDEX;
            BYTE DataBuffer[512];
            //ULONG             ArgumentLength = strlen(lpArgument);
            //BOOLEAN           fAmbigous = FALSE;



            dwAddress = GetExpression( args );
            if (!wGetData(dwAddress,&Tag,sizeof(Tag),"..structure TAG")) return;

            PRINTF("here's the tag: %04lx\n",Tag);

            //look thru the table for matching structs

            while ((pStructs->StructName != 0)) {
                int Result = (Tag&pStructs->MatchMask)==pStructs->MatchValue;

                if (Result != 0) {

                    DumpAStruct(dwAddress,pStructs);
                    break;
                }


                pStructs++;
            }

        }
    } else {
            DisplayStructs();
    }

    return;
}


DECLARE_API( ddd )
{
    dump( hCurrentProcess,
          hCurrentThread,
          dwCurrentPc,
          dwProcessor,
          args
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\kernel\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

//
// Get the minirdr environment.
//
#include "rx.h"

//
// NT network file system driver include files.
//
#include "ntddnfs2.h"

//
// Reflector library's user mode header file.
//
#include "ntumrefl.h"

#include "netevent.h"

//
// Reflector library's kernel mode header file.
//
#include "umrx.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\global.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.h

Abstract:

   This module contains data declarations necessary for the user mode
   reflector user mode library.

Author:

    Andy Herron    (andyhe)        19-Apr-1999

Revision History:

--*/

//
// This structure is maintained one per reflector instance. We pass it back to
// the calling app and he always passes it in to us. If we loose it, we're lost.
//
typedef struct _UMRX_USERMODE_REFLECT_BLOCK {

    //
    // Reference count of this reflector block.
    //
    ULONG               ReferenceCount;
    
    //
    // Handle to the Mini-Redirs device object.
    //
    HANDLE              DeviceHandle;      
    
    //
    // Lock used to synchronize access to the fields of this reflect block.
    //
    CRITICAL_SECTION    Lock;
    
    //
    // Name of the Device object.
    //
    PWCHAR              DriverDeviceName;
    
    //
    // Is this reflector block active ? Closing = FALSE : Closing = TRUE;
    //
    BOOL                Closing;

    //
    // List of user mode worker thread(s) instance blocks.
    //
    LIST_ENTRY          WorkerList;         
    
    //
    // List of work items currently in use to satisfy requests getting 
    // reflected from the kernel.
    //
    LIST_ENTRY          WorkItemList;

    //
    // For efficiency, we hold a few workitems around in a small cache. Note
    // that if the entry size changes, the cache will not be as effective.
    //

    //
    // List of work items which are available for use. After a workitem gets
    // finalized, it moves from the WorkItemList (see above) to the 
    // AvailableList.
    //
    LIST_ENTRY          AvailableList;      
    
    //
    // Number of work items present on the AvailableList.
    //
    ULONG               NumberAvailable;
    
    //
    // The maximum number of workitems that can be cached on the AvailableList.
    // When NumberAvailable exceeds the CacheLimit, one of the work items on the
    // list (specifically the last entry) is freed up.
    //
    ULONG               CacheLimit;

    //
    // Must be last element.
    //
    WCHAR               DeviceNameBuffers[1];   

} UMRX_USERMODE_REFLECT_BLOCK, *PUMRX_USERMODE_REFLECT_BLOCK;


//
// This structure is maintained one per worker thread.  It holds the handle
// on which we do our IOCTLs down to kernel.
//
typedef struct _UMRX_USERMODE_WORKER_INSTANCE {

    //
    // Used to add it to the reflect block list of worker instances.
    //
    LIST_ENTRY                      WorkerListEntry;
    
    //
    // The instance (user mode process) being served.
    //
    PUMRX_USERMODE_REFLECT_BLOCK    ReflectorInstance;

    //
    // Is this thread impersonating a client ?
    //
    BOOL IsImpersonating;
    
    //
    // Handle of kernel device for this registered instance.
    //
    HANDLE                          ReflectorHandle;    

} UMRX_USERMODE_WORKER_INSTANCE, *PUMRX_USERMODE_WORKER_INSTANCE;

//
//  User mode Work Item States :  Mostly for debugging/support purposes.
//
typedef enum _USERMODE_WORKITEM_STATE {

    //
    // It's about to be freed back to the heap.
    //
    WorkItemStateFree = 0,

    //
    // It's on the list of freed and available for reallocation.
    //
    WorkItemStateAvailable,     

    //
    // Has been sent to kernel to get a request.
    //
    WorkItemStateInKernel,

    //
    // Allocated by UMReflectorAllocateWorkItem but UMReflectorGetRequest 
    // has not yet been called.
    //
    WorkItemStateNotYetSentToKernel,

    //
    // UMReflectorGetRequest is back from kernel but a response has not yet 
    // been sent for this work item.
    //
    WorkItemStateReceivedFromKernel,

    //
    // During UMReflectorGetRequest, responses that are in flight to the kernel 
    // are set with this state.
    //
    WorkItemStateResponseNotYetToKernel,

    //
    // After UMReflectorGetRequest, response workitem is set to this state on 
    // the way to free or available.
    //
    WorkItemStateResponseFromKernel

} USERMODE_WORKITEM_STATE;

//
// This structure is maintained one per reflection down to kernel mode. We give
// it to the calling app, he fills it in and gives it back to us to give to 
// kernel and then we return it when kernel has a request. This structure is 
// just for housekeeping and is not passed between user and kernel mode. It sits
// directly in front of the UMRX_USERMODE_WORKITEM_HEADER structure.
//
typedef struct _UMRX_USERMODE_WORKITEM_ADDON {

    //
    // Size of this entry.
    //
    ULONG                          EntrySize; 

    //
    // The user mode instance with which this work item is associated.
    //
    PUMRX_USERMODE_REFLECT_BLOCK   ReflectorInstance;

    //
    // Used in adding it to the reflect blocks list.
    //
    LIST_ENTRY                     ListEntry;

    //
    // The state of the work item.
    //
    USERMODE_WORKITEM_STATE        WorkItemState;

    //
    // The work item header which the user mode instance gets back to use.
    //
    union {
        UMRX_USERMODE_WORKITEM_HEADER   Header;
        UMRX_USERMODE_WORKITEM_HEADER;
    };

} UMRX_USERMODE_WORKITEM_ADDON, *PUMRX_USERMODE_WORKITEM_ADDON;

#if DBG
#define RlDavDbgPrint(_x_) DbgPrint _x_
#else
#define RlDavDbgPrint(_x_)
#endif

VOID
DereferenceReflectorBlock (
    PUMRX_USERMODE_REFLECT_BLOCK reflectorInstance
    );

ULONG
ReflectorSendSimpleFsControl(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    ULONG IoctlCode
    );

// global.h eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\kernel\reflctor.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    reflctor.h

Abstract:

    The global include file for the reflector.

Author:

    Rohan Kumar   [rohank]  (21-Mar-99)

Revision History:

--*/

#ifndef _REFLCTOR_H_
#define _REFLCTOR_H_

//
// This structure is used for secondary buffer allocations.
//
#define UMRX_SECONDARY_BUFFER_SIGNATURE 0x42534d55   // "UMSB"

typedef struct _UMRX_SECONDARY_BUFFER {
    ULONG               Signature;
    SIZE_T              AllocationSize;
    PUMRX_SHARED_HEAP   SourceSharedHeap;
    LIST_ENTRY          ListEntry;
    WCHAR               Buffer[1];
} UMRX_SECONDARY_BUFFER, *PUMRX_SECONDARY_BUFFER;


//
// Pool tags used by the reflector library. All the DAV MiniRedir pool tags 
// have "DV" as the first two characters.
//
#define UMRX_ASYNCENGINECONTEXT_POOLTAG ('DVCx')
#define UMRX_SHAREDHEAP_POOLTAG ('DVSh')

//
// Use the UMRxDbgTrace macro for logging reflector stuff in the 
// kernel debugger.
//
#if DBG
ULONG UMRxDebugVector = 0;
#define UMRX_TRACE_ERROR      0x00000001
#define UMRX_TRACE_DEBUG      0x00000002
#define UMRX_TRACE_CONTEXT    0x00000004
#define UMRX_TRACE_DETAIL     0x00000008
#define UMRX_TRACE_ENTRYEXIT  0x00000010
#define UMRX_TRACE_ALL        0xffffffff
#define UMRxDbgTrace(_x_, _y_) {         \
        if (_x_ & UMRxDebugVector) {     \
            DbgPrint _y_;                \
        }                                \
}
#else
#define UMRxDbgTrace(_x_, _y_)
#endif

//
// Usermode callout stuff.
//
typedef struct _UMRX_WORKITEM_HEADER_PRIVATE {
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    ULONG SerialNumber;
    USHORT Mid;
} UMRX_WORKITEM_HEADER_PRIVATE, *PUMRX_WORKITEM_HEADER_PRIVATE;

#define MIN(x,y) ((x) < (y) ? (x) : (y))

#if DBG
#define P__ASSERT(exp) {                                   \
        if (!(exp)) {                                      \
            UMRxDbgTrace(UMRX_TRACE_DEBUG,                 \
                         ("%ld: %s is not TRUE.\n",        \
                          PsGetCurrentThreadId(), #exp));  \
            errors++;                                      \
        }                                                  \
}
#endif

#if DBG
#define FINALIZE_TRACKING_SETUP() \
    struct {                      \
        ULONG marker1;            \
        ULONG finalstate;         \
        ULONG marker2;            \
    } Tracking = {'ereh',0,'ereh'};

#define FINALIZE_TRACKING(x) {    \
        Tracking.finalstate |= x; \
}
#define FINALIZE_TRACE(x)  {                                                 \
        UMRxDbgTrace(UMRX_TRACE_DETAIL,                                      \
                     ("%ld: UMRxFinalizeAsyncEngineContext: %s (%08lx).\n",  \
                      PsGetCurrentThreadId(), x, Tracking.finalstate));      \
}
#else
#define FINALIZE_TRACKING_SETUP()
#define FINALIZE_TRACKING(x)
#define FINALIZE_TRACE(x)
#endif

#define REASSIGN_MID      1
#define DONT_REASSIGN_MID 0

#if DBG
ULONG
UMRxAsyncEngShortStatus(
    IN ULONG Status
    );

VOID UMRxAsyncEngUpdateHistory(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Tag1,
    ULONG Tag2
    );

#define UPDATE_HISTORY_LONG(a) {                             \
        UMRxAsyncEngUpdateHistory(AsyncEngineContext, a, 0); \
}
#define UPDATE_HISTORY_2SHORTS(a,b) {                        \
        UMRxAsyncEngUpdateHistory(AsyncEngineContext, a, b); \
}
#define UPDATE_HISTORY_WITH_STATUS(a) \
  UPDATE_HISTORY_2SHORTS(a, UMRxAsyncEngShortStatus(AsyncEngineContext->Status))
#else
#define UPDATE_HISTORY_LONG(a)
#define UPDATE_HISTORY_2SHORTS(a,b)
#define UPDATE_HISTORY_WITH_STATUS(a)
#endif

#if DBG
#define AECTX_CHKLINKAGE_FLAG_NO_REQPCKT_CHECK 0x00000001

VOID
__UMRxAsyncEngAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Flags
    );

#define UMRxAsyncEngAssertConsistentLinkage(a, flags) {              \
        __UMRxAsyncEngAssertConsistentLinkage(a,                     \
                                              __FILE__,              \
                                              __LINE__,              \
                                              RxContext,             \
                                              AsyncEngineContext,    \
                                              flags);                \
}
#else
#define UMRxAsyncEngAssertConsistentLinkage(a, flags) {NOTHING;}
#endif // DBG

#endif // _REFLCTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

#pragma once

#define UNICODE 1
#define _UNICODE 1

//
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>

//
// Public windows headers.
//
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <rpc.h>
#include <ntumrefl.h>
#include "global.h"

// eof. precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\kernel\umrx.c ===
/*++ Copyright (c) 1999  Microsoft Corporation

Module Name:

    umrx.c

Abstract:

    This module defines the types and functions which make up the reflector
    library. These functions are used by the miniredirs to reflect calls upto
    the user mode.

Author:

    Rohan Kumar     [rohank]     15-March-1999

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>
#include "reflctor.h"

//
// Mentioned below are the prototypes of functions that are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
UMRxCompleteUserModeRequest (
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    IN ULONG WorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UMRxCompleteUserModeErroneousRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemHeaderLength
    );

NTSTATUS
UMRxAcquireMidAndFormatHeader (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItem
    );

NTSTATUS
UMRxPrepareUserModeRequestBuffer (
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN  PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    IN  ULONG WorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UMRxVerifyHeader (
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    IN ULONG ReassignmentCmd,
    OUT PUMRX_ASYNCENGINE_CONTEXT *capturedAsyncEngineContext
    );

NTSTATUS
UMRxEnqueueUserModeCallUp(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

PUMRX_SHARED_HEAP
UMRxAddSharedHeap(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    SIZE_T HeapSize
    );

PUMRX_ASYNCENGINE_CONTEXT
UMRxCreateAsyncEngineContext(
    IN PRX_CONTEXT RxContext,
    IN ULONG SizeToAllocate
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UMRxResumeAsyncEngineContext)
#pragma alloc_text(PAGE, UMRxSubmitAsyncEngUserModeRequest)
#pragma alloc_text(PAGE, UMRxCreateAsyncEngineContext)
#pragma alloc_text(PAGE, UMRxFinalizeAsyncEngineContext)
#pragma alloc_text(PAGE, UMRxPostOperation)
#pragma alloc_text(PAGE, UMRxAcquireMidAndFormatHeader)
#pragma alloc_text(PAGE, UMRxPrepareUserModeRequestBuffer)
#pragma alloc_text(PAGE, UMRxCompleteUserModeErroneousRequest)
#pragma alloc_text(PAGE, UMRxVerifyHeader)
#pragma alloc_text(PAGE, UMRxCompleteUserModeRequest)
#pragma alloc_text(PAGE, UMRxEnqueueUserModeCallUp)
#pragma alloc_text(PAGE, UMRxAssignWork)
#pragma alloc_text(PAGE, UMRxReleaseCapturedThreads)
#pragma alloc_text(PAGE, UMRxAllocateSecondaryBuffer)
#pragma alloc_text(PAGE, UMRxFreeSecondaryBuffer)
#pragma alloc_text(PAGE, UMRxAddSharedHeap)
#pragma alloc_text(PAGE, UMRxInitializeDeviceObject)
#pragma alloc_text(PAGE, UMRxCleanUpDeviceObject)
#pragma alloc_text(PAGE, UMRxImpersonateClient)
#pragma alloc_text(PAGE, UMRxAsyncEngOuterWrapper)
#pragma alloc_text(PAGE, UMRxReadDWORDFromTheRegistry)
#endif

#if DBG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, __UMRxAsyncEngAssertConsistentLinkage)
#pragma alloc_text(PAGE, UMRxAsyncEngShortStatus)
#pragma alloc_text(PAGE, UMRxAsyncEngUpdateHistory)
#endif
#endif

//
// The global list of all the currently active AsyncEngineContexts and the
// resource that is used to synchronize access to it.
//
LIST_ENTRY UMRxAsyncEngineContextList;
ERESOURCE UMRxAsyncEngineContextListLock;


//
// Implementation of functions begins here.
//

#if DBG
VOID
__UMRxAsyncEngAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Flags
    )
/*++

Routine Description:

   This routine performs a variety of checks to ensure that the linkage between
   the RxContext and the AsyncEngineContext is correct and that various fields
   have correct values. If anything is bad, print stuff out and break into the
   debugger.

Arguments:

     MsgPrefix - An identifying message for debugging purposes.

     RxContext - The RDBSS context.

     AsyncEngineContext - The exchange to be conducted.

     Flags - The flags associated with the AsyncEngineContext.

Return Value:

    none

Notes:

--*/
{
    ULONG errors = 0;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: Entering __UMRxAsyncEngAssertConsistentLinkage!!!!.\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "AsyncEngineContext: %08lx.\n", 
                  PsGetCurrentThreadId(), AsyncEngineContext));

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "RxContext->MRxContext[0]: %08lx.\n", 
                  PsGetCurrentThreadId(), RxContext->MRxContext[0]));
    
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "RxContext: %08lx.\n", PsGetCurrentThreadId(), RxContext));
    
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "AsyncEngineContext->RxContext = %08lx.\n", 
                  PsGetCurrentThreadId(), AsyncEngineContext->RxContext));

    P__ASSERT(AsyncEngineContext->SerialNumber == RxContext->SerialNumber);
    P__ASSERT(NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT);
    P__ASSERT(NodeType(AsyncEngineContext) == UMRX_NTC_ASYNCENGINE_CONTEXT);
    P__ASSERT(AsyncEngineContext->RxContext == RxContext);
    P__ASSERT(AsyncEngineContext == (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0]);
    if (!FlagOn(Flags, AECTX_CHKLINKAGE_FLAG_NO_REQPCKT_CHECK)) {
        // P__ASSERT(AsyncEngineContext->RxContextCapturedRequestPacket == RxContext->CurrentIrp);
    }

    if (errors == 0) {
        return;
    }

    UMRxDbgTrace(UMRX_TRACE_ERROR, 
                 ("%ld: ERROR: __UMRxAsyncEngAssertConsistentLinkage: %s "
                  "%d errors in file %s at line %d\n",
                  PsGetCurrentThreadId(), MsgPrefix, errors, File, Line));

    DbgBreakPoint();

    return;
}


ULONG
UMRxAsyncEngShortStatus(
    IN ULONG Status
    )
/*++

Routine Description:

    This routine calculates the short status.

Arguments:

    Status - The status value passed in.

Return Value:

    ULONG - The short status for the value passed in.

--*/
{
    ULONG ShortStatus;

    PAGED_CODE();

    ShortStatus = Status & 0xc0003fff;
    ShortStatus = ShortStatus | (ShortStatus >> 16);
    return(ShortStatus);
}


VOID
UMRxAsyncEngUpdateHistory(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Tag1,
    ULONG Tag2
    )
/*++

Routine Description:

    This routine updates the histroy of the AsynEngineContext.

Arguments:

    AsyncEngineContext - The exchange to be conducted.

    Tag1, Tag2 - Tags used for the update.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    ULONG MyIndex, Long0, Long1;

    PAGED_CODE();

    MyIndex = InterlockedIncrement(&AsyncEngineContext->History.Next);
    MyIndex = (MyIndex - 1) & (UMRX_ASYNCENG_HISTORY_SIZE - 1);
    Long0 = (Tag1 << 16) | (Tag2 & 0xffff);
    Long1 = (UMRxAsyncEngShortStatus(AsyncEngineContext->Status) << 16)
            | AsyncEngineContext->Flags;
    AsyncEngineContext->History.Markers[MyIndex].Longs[0] = Long0;
    AsyncEngineContext->History.Markers[MyIndex].Longs[1] = Long1;
}

#endif


NTSTATUS
UMRxResumeAsyncEngineContext(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine resumes processing on an exchange. This is called when work is
   required to finish processing a request that cannot be completed at DPC
   level.  This happens either because the parse routine needs access to
   structures that are not locks OR because the operation is asynchronous and
   there maybe more work to be done. The two cases are regularized by delaying
   the parse if we know that we're going to post: this is indicated by the
   presense of a resume routine.

Arguments:

    RxContext  - The RDBSS context of the operation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;

    PAGED_CODE();

    AsyncEngineContext = (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0];

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxResumeAsyncEngineContext.\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxResumeAsyncEngineContext: "
                  "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    UMRxAsyncEngAssertConsistentLinkage("UMRxResumeAsyncEngineContext: ",
                                        AECTX_CHKLINKAGE_FLAG_NO_REQPCKT_CHECK);

    NtStatus = AsyncEngineContext->Status;

    UPDATE_HISTORY_WITH_STATUS('0c');

    UPDATE_HISTORY_WITH_STATUS('4c');
    
    //
    // Remove my references which were added when the AsyncEngineContext was 
    // placed on the KQueue. If I'm the last guy then finalize.
    //
    UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT, 
                 ("%ld: Leaving UMRxResumeAsyncEngineContext with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxSubmitAsyncEngUserModeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine,
    IN PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PrecompletionRoutine
    )
/*++

Routine Description:

   This routine sets some fields (see below) in the AsyncEnineContext structure
   and calls the UMRxEnqueueUserModeCallUp function.

Arguments:

    RxContext - The RDBSS context.

    AsyncEngineContext - The exchange to be conducted.

    FormatRoutine - The routine that formats the arguments of the I/O request
                    which is handled by a usermode process.

    PrecompletionRoutine - The routine that handles the post processing of an
                           I/O request. By post processing we mean after the 
                           request returns from the user mode.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN AsyncOperation = FlagOn(AsyncEngineContext->Flags,
                                    UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT, 
                 ("%ld: Entering UMRxSubmitAsyncEngUserModeRequest!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT, 
                 ("%ld: UMRxSubmitAsyncEngUserModeRequest: AsyncEngineContext:"
                  " %08lx, RxContext: %08lx.\n", 
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    UMRxAsyncEngAssertConsistentLinkage("UMRxSubmitAsyncEngUserModeRequest:", 0);

    //
    // Set the Format, Precompletion and Secondary routines of the context.
    //
    AsyncEngineContext->UserMode.FormatRoutine = FormatRoutine;
    AsyncEngineContext->UserMode.PrecompletionRoutine = PrecompletionRoutine;

    if (AsyncOperation) {
        AsyncEngineContext->AsyncOperation = TRUE;
    }

    KeInitializeEvent(&RxContext->SyncEvent, NotificationEvent, FALSE);

    //
    // We need to add a reference to the AsyncEngineContext before adding it to
    // the Device object's KQueue.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    UPDATE_HISTORY_2SHORTS('eo', AsyncOperation?'!!':0);
    DEBUG_ONLY_CODE(InterlockedIncrement(&AsyncEngineContext->History.Submits);)

    //
    // Queue up the usermode request.
    //
    NtStatus = UMRxEnqueueUserModeCallUp(UMRX_ASYNCENGINE_ARGUMENTS);
    if (NtStatus != STATUS_PENDING) {
        BOOLEAN ReturnVal = FALSE;
        //
        // Too bad. We couldn't queue the request. Remove our reference on the
        // AsyncEngineContext and leave.
        //
        UMRxDbgTrace(UMRX_TRACE_ERROR, 
                     ("%ld: ERROR: UMRxSubmitAsyncEngUserModeRequest/"
                      "UMRxEnqueueUserModeCallUp: NtStatus = %08lx.\n",
                      PsGetCurrentThreadId(), NtStatus));
        ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        ASSERT(!ReturnVal);
        AsyncEngineContext->Status = NtStatus;
        return NtStatus;
    }

    //
    // If this is an Async operation, we set this information in the context
    // and leave right away.
    //
    if (AsyncOperation) {
        UMRxDbgTrace(UMRX_TRACE_DETAIL, 
                     ("%ld: UMRxSubmitAsyncEngUserModeRequest: "
                      "Async Operation!!\n", PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    UPDATE_HISTORY_WITH_STATUS('1o');

    RxWaitSync(RxContext);

    UMRxAsyncEngAssertConsistentLinkage("BeforeResumeAsyncEngineContext: ", 0);

    NtStatus = UMRxResumeAsyncEngineContext(RxContext);

    UPDATE_HISTORY_WITH_STATUS('9o');

EXIT_THE_FUNCTION:
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT, 
                 ("%ld: Leaving UMRxSubmitAsyncEngUserModeRequest with "
                  "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

   return(NtStatus);
}


PUMRX_ASYNCENGINE_CONTEXT
UMRxCreateAsyncEngineContext(
    IN PRX_CONTEXT RxContext,
    IN ULONG       SizeToAllocate
    )
/*++

Routine Description:

   This routine allocates and initializes a miniredir's context.

Arguments:

    RxContext      -  The RDBSS context.

    SizeToAllocate - The size to allocate for the new context. This value is
                     equal to the size of the miniredirs context which
                     encapsulates the AsynEngineContext.

Return Value:

    A miniredir context buffer ready to go, OR NULL.

Notes:

--*/
{
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    BOOLEAN ReadWriteIrp = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCreateAsyncEngineContext!!!!\n",
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCreateAsyncEngineContext: RxContext: %08lx.\n", 
                  PsGetCurrentThreadId(), RxContext));

    //
    // Allocate the miniredir context. If the resources are unavailable, then
    // return NULL.
    //
    AsyncEngineContext = (PUMRX_ASYNCENGINE_CONTEXT)
                         RxAllocatePoolWithTag(NonPagedPool,
                                               SizeToAllocate,
                                               UMRX_ASYNCENGINECONTEXT_POOLTAG);
    if (AsyncEngineContext == NULL) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCreateAsyncEngineContext/"
                      "RxAllocatePoolWithTag.\n", PsGetCurrentThreadId()));
        return ((PUMRX_ASYNCENGINE_CONTEXT)NULL);
    }

    //
    // Initialize the header of the new (context) node.
    //
    ZeroAndInitializeNodeType(AsyncEngineContext,
                              UMRX_NTC_ASYNCENGINE_CONTEXT,
                              SizeToAllocate);
    //
    // Place a reference on the context until we are finished.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    DEBUG_ONLY_CODE(AsyncEngineContext->SerialNumber = RxContext->SerialNumber);

    //
    // Place a reference on the RxContext until we are finished.
    //
    InterlockedIncrement( &(RxContext->ReferenceCount) );

    //
    // Capture the RxContext.
    //
    AsyncEngineContext->RxContext = RxContext;

    InitializeListHead( &(AsyncEngineContext->AllocationList) );

    //
    // Capture the IRP.
    //
    DEBUG_ONLY_CODE(AsyncEngineContext->RxContextCapturedRequestPacket
                    = RxContext->CurrentIrp);

    //
    // Save MRxContext[0] incase we use it. The saved context is restored
    // just before returning back to RDBSS. This is done because the RDBSS
    // may have used MRxContext[0] for storing some information.
    //
    AsyncEngineContext->SavedMinirdrContextPtr = RxContext->MRxContext[0];
    RxContext->MRxContext[0] = (PVOID)AsyncEngineContext;

    //
    // If this is a Read or a Write IRP, we need to set ReadWriteIrp to TRUE.
    //
    if ( (RxContext->MajorFunction == IRP_MJ_READ) || (RxContext->MajorFunction == IRP_MJ_WRITE) ) {
        ReadWriteIrp = TRUE;
    }

    //
    // If ReadWriteIrp is TRUE, then we do not add the AsyncEngineContext that
    // was created to the global UMRxAsyncEngineContextList. This is because
    // we do not cancel read/write operations in the DAV Redir, so there is no
    // point in adding them to this list. Also, if the MappedPageWriter thread
    // is blocked on acquiring the UMRxAsyncEngineContextListLock, it can cause
    // a deadlock since the thread that has acquired the lock could be waiting
    // for the MM to free up some pages. MM (in this case) ofcourse is waiting
    // for the MappedPageWriter to finish.
    //
    if (ReadWriteIrp == FALSE) {

        //
        // Add the context to the global UMRxAsyncEngineContextList. We need to
        // synchronize this operation.
        //
        ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
        InsertHeadList(&(UMRxAsyncEngineContextList), &(AsyncEngineContext->ActiveContextsListEntry));
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));

        //
        // Set the current system time as the creation time of the context.
        //
        KeQueryTickCount( &(AsyncEngineContext->CreationTimeInTickCount) );

    }

    return(AsyncEngineContext);
}


BOOLEAN
UMRxFinalizeAsyncEngineContext(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT *AEContext
    )
/*++

Routine Description:

    This finalizes an AsyncEngineContext. If the reference on the context after
    the finalization is zero, it is freed. This function is not pagable. See
    below for details.

Arguments:

    AEContext - Pointer to the address of the AECTX to be finalized.

Return Value:

    TRUE if the context is freed occurs otherwise FALSE.

Notes:

--*/
{
    LONG result = 0;
    PIRP irp = NULL;
    PLIST_ENTRY listEntry;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = *AEContext;
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    BOOLEAN AsyncOperation = FALSE, ReadWriteIrp = FALSE;

    FINALIZE_TRACKING_SETUP()

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxFinalizeAsyncEngineContext\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxFinalizeAsyncEngineContext: "
                  "AsyncEngineContext: %08lx, RxContext: %08lx\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    result =  InterlockedDecrement( &(AsyncEngineContext->NodeReferenceCount) );
    if (result != 0) {
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Returning w/o "
                      "finalizing: (%d)\n", PsGetCurrentThreadId(), result));
        return FALSE;
    }

    FINALIZE_TRACKING(0x1);

    ASSERT(RxContext != NULL);

    //
    // If this is a Read or a Write IRP, we need to set ReadWriteIrp to TRUE.
    //
    if ( (RxContext->MajorFunction == IRP_MJ_READ) || (RxContext->MajorFunction == IRP_MJ_WRITE) ) {
        ReadWriteIrp = TRUE;
    }

    //
    // If the IRP was for Read or Write, we would not have added the context to
    // the global UMRxAsyncEngineContextList. For an explanation of why we do
    // not add AsyncEngineContexts that deal with read/write IRPs to this list,
    // look at the comment in UMRxCreateAsyncEngineContext where the context is
    // added to this list.
    //
    if (ReadWriteIrp == FALSE) {
        //
        // Remove the context from the global UMRxAsyncEngineContextList now that we
        // are going to free if after we do a few things. We need to synchronize
        // this operation.
        //
        ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
        RemoveEntryList( &(AsyncEngineContext->ActiveContextsListEntry) );
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
    }

    while ( !IsListEmpty(&AsyncEngineContext->AllocationList) ) {
        
        PUMRX_SECONDARY_BUFFER buf = NULL;

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Freeing the "
                      "AllocationList of the AsyncEngineContext.\n",
                      PsGetCurrentThreadId()));

        listEntry = AsyncEngineContext->AllocationList.Flink;

        buf = CONTAINING_RECORD(listEntry,
                                UMRX_SECONDARY_BUFFER,
                                ListEntry);

        UMRxFreeSecondaryBuffer(AsyncEngineContext, (PBYTE)&buf->Buffer);

        //
        // If it didn't remove this from the list, we're looping.
        //
        ASSERT(listEntry != AsyncEngineContext->AllocationList.Flink);
    
    }

    AsyncOperation = FlagOn(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    irp = AsyncEngineContext->CalldownIrp;

    //
    // If the CallDownIrp is not NULL, then we need to do the following.
    //
    if (irp != NULL) {

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Freeing IRP = %08lx, MajorFn = %d\n",
                      PsGetCurrentThreadId(), irp, RxContext->MajorFunction));

        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }
        
        //
        // We are done with this irp, so free it.
        //
        IoFreeIrp(irp);
        
        FINALIZE_TRACKING(0x20);

    }

    //
    // If this was an Async Operation, then we need to complete the original
    // irp since we would have returned STATUS_PENDING back earlier. To do
    // this, we do one of two things.
    // 1. Call into the RxLowIoCompletion function if the LowIoCompletion
    //    routine exists.
    // 2. Just complete the IRP if no such routine  exists.
    // Also, we do this only if ShouldCallLowIoCompletion is set to TRUE since
    // some Async calls do not need this. Eg: CreateSrvCall is async but doesn't
    // need it. Ofcourse, if the operation was cancelled then there is no need
    // to call this since the routine that handles the cancelling would have
    // taken care of this.
    //
    if (AsyncOperation && 
        AsyncEngineContext->ShouldCallLowIoCompletion &&
        AsyncEngineContext->AsyncEngineContextState != UMRxAsyncEngineContextCancelled) {

        ASSERT(RxContext != NULL);

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Async Operation\n",
                      PsGetCurrentThreadId()));

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Completing Irp = %08lx\n",
                      PsGetCurrentThreadId(), RxContext->CurrentIrp));

        if (RxContext->LowIoContext.CompletionRoutine) {
            //
            // Set the status and information values in the RxContext. These are
            // the values returned by the underlying file system for the read
            // or the write operation that was issued to them.
            //
            RxContext->StoredStatus = AsyncEngineContext->Status;
            RxContext->InformationToReturn = AsyncEngineContext->Information;
            //
            // Finally, call RxLowIoCompletion.
            //
            RxLowIoCompletion(RxContext);
        } else {
            //
            // Complete the request by calling RxCompleteRequest.
            //
            RxContext->CurrentIrp->IoStatus.Status = AsyncEngineContext->Status;
            RxContext->CurrentIrp->IoStatus.Information = AsyncEngineContext->Information;
            RxCompleteRequest(RxContext, AsyncEngineContext->Status);
        }

    }

    //
    // We took a reference on the RxContext when we created the AsyncEngineContext.
    // Since we are done with the AsyncEngineContext, we need to remove it now.
    //
    RxDereferenceAndDeleteRxContext(AsyncEngineContext->RxContext);

    FINALIZE_TRACE("Ready to Discard Exchange");

    RxFreePool(AsyncEngineContext);

    //
    // Set the AsyncEngineContext pointer to NULL.
    //
    *AEContext = NULL;

    FINALIZE_TRACKING(0x3000);

    FINALIZE_TRACKING(0x40000);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxFinalizeAsyncEngineContext. Final State = "
                  "%x\n", PsGetCurrentThreadId(), Tracking.finalstate));

    return(TRUE);
}


NTSTATUS
UMRxAsyncEngineCalldownIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp OPTIONAL,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    DeviceObject - The device object in play.

    CalldownIrp -

    Context -

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;
    
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext =
                            (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0];
    
    BOOLEAN AsyncOperation = FlagOn(AsyncEngineContext->Flags,
                                    UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    //
    // This is not Pageable code.
    //

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAsyncEngineCalldownIrpCompletion!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                  "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    UPDATE_HISTORY_WITH_STATUS('ff');
    
    UMRxAsyncEngAssertConsistentLinkage("UMRxCalldownCompletion: ", 0);

    //
    // If the CallDownIrp is not NULL, then this means that the underlying
    // filesystem has completed the read or the write IRP that we had given it
    // using the IoCallDriver call.
    //
    if (CalldownIrp != NULL) {
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                      "CallDownIrp = %08lx, MajorFunction = %d\n",
                      PsGetCurrentThreadId(), CalldownIrp, RxContext->MajorFunction));
        AsyncEngineContext->Status = CalldownIrp->IoStatus.Status;
        AsyncEngineContext->Information = CalldownIrp->IoStatus.Information;
    }

    if (AsyncOperation) {
        
        NTSTATUS PostStatus = STATUS_SUCCESS;
        
        if (RxContext->pRelevantSrvOpen) {
        
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                          "ASync Resume. AsyncEngineContext = %08lx, RxContext "
                          "= %08lx, FileName = %wZ\n", 
                          PsGetCurrentThreadId(), AsyncEngineContext, RxContext,
                          RxContext->pRelevantSrvOpen->pAlreadyPrefixedName));
        }
        
        IF_DEBUG {
            //
            // Fill the workqueue structure with deadbeef. All the better to
            // diagnose a failed post.
            //
            ULONG i;
            for (i=0;
                 i + sizeof(ULONG) - 1 < sizeof(AsyncEngineContext->WorkQueueItem);
                 i += sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&AsyncEngineContext->WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }
        
        PostStatus = RxPostToWorkerThread(RxContext->RxDeviceObject,
                                          CriticalWorkQueue,
                                          &(AsyncEngineContext->WorkQueueItem),
                                          UMRxResumeAsyncEngineContext,
                                          RxContext);
        
        ASSERT(PostStatus == STATUS_SUCCESS);
    
    } else {

        if (RxContext->pRelevantSrvOpen) {
        
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                          "Sync Resume. AsyncEngineContext = %08lx, RxContext "
                          "= %08lx, FileName = %wZ\n", 
                          PsGetCurrentThreadId(), AsyncEngineContext, RxContext,
                          RxContext->pRelevantSrvOpen->pAlreadyPrefixedName));
        
        }
        
        //
        // Signal the thread that is waiting after queuing the workitem on the
        // KQueue.
        //
        RxSignalSynchronousWaiter(RxContext);
    
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
UMRxPostOperation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PVOID PostedOpContext,
    IN PUMRX_POSTABLE_OPERATION Operation
    )
/*++

Routine Description:

Arguments:

    RxContext  - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status,PostStatus;

    PAGED_CODE();

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    KeInitializeEvent(&RxContext->SyncEvent,
                      NotificationEvent,
                      FALSE);

    AsyncEngineContext->PostedOpContext = PostedOpContext;

    IF_DEBUG {
        //
        // Fill the workqueue structure with deadbeef. All the better to
        // diagnose a failed post
        //
        ULONG i;
        for (i = 0; 
             i + sizeof(ULONG) - 1 < sizeof(AsyncEngineContext->WorkQueueItem);
             i += sizeof(ULONG)) {
            PBYTE BytePtr = ((PBYTE)&AsyncEngineContext->WorkQueueItem)+i;
            PULONG UlongPtr = (PULONG)BytePtr;
            *UlongPtr = 0xdeadbeef;
        }
    }

    PostStatus = RxPostToWorkerThread(RxContext->RxDeviceObject,
                                      DelayedWorkQueue,
                                      &AsyncEngineContext->WorkQueueItem,
                                      Operation,
                                      AsyncEngineContext);

    ASSERT(PostStatus == STATUS_SUCCESS);

    RxWaitSync(RxContext);

    Status = AsyncEngineContext->PostedOpStatus;

    return(Status);
}


NTSTATUS
UMRxAcquireMidAndFormatHeader(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    )
/*++

Routine Description:

    This routine gets a mid and formats the header. It waits until it can get a
    MID if all the MIDs are currently passed out.

Arguments:

    RxContext - The RDBSS context.

    AsyncEngineContext - The Reflector's AsynEngine's context.

    UMRefDeviceObject - The UMRef device object.

    WorkItemHeader - The work item header buffer.

Return Value:

    STATUS_SUCCESS. Later could be STATUS_CANCELLED.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader = NULL;
    ULONG WorkItemHeaderLength = 0;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAcquireMidAndFormatHeader!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAcquireMidAndFormatHeader: WorkItem = %08lx, "
                  "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                  PsGetCurrentThreadId(), WorkItemHeader, AsyncEngineContext,
                  RxContext));

    PrivateWorkItemHeader = (PUMRX_WORKITEM_HEADER_PRIVATE)WorkItemHeader;

    //
    // We are going to zero the entire WorkItemHeader below. Before we do that
    // we need to store the value of "WorkItemHeader->WorkItemLength" on the
    // stack. After we zero this structure, we copy this value back.
    //
    WorkItemHeaderLength = WorkItemHeader->WorkItemLength;

    RtlZeroMemory(WorkItemHeader, sizeof(UMRX_USERMODE_WORKITEM_HEADER));

    WorkItemHeader->WorkItemLength = WorkItemHeaderLength;

    ExAcquireFastMutex(&UMRefDeviceObject->MidManagementMutex);

    //
    // Taken away as we disassociate the mid.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    if (IsListEmpty(&UMRefDeviceObject->WaitingForMidListhead)) {
        
        NtStatus = RxAssociateContextWithMid(UMRefDeviceObject->MidAtlas,
                                             AsyncEngineContext,
                                             &AsyncEngineContext->UserMode.CallUpMid);
        if (NtStatus != STATUS_SUCCESS) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAcquireMidAndFormatHeader/"
                          "RxAssociateContextWithMid: NtStatus = %08lx\n", 
                          PsGetCurrentThreadId(), NtStatus));
        }
    
    } else {
        
        NtStatus = STATUS_UNSUCCESSFUL;
        
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAcquireMidAndFormatHeader. "
                      "WaitingForMidList is not empty.\n", PsGetCurrentThreadId()));
    
    }

    if (NtStatus == STATUS_SUCCESS) {
        
        ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
    
    } else {

        KeInitializeEvent(&AsyncEngineContext->UserMode.WaitForMidEvent,
                          NotificationEvent,
                          FALSE);
        
        InsertTailList(&UMRefDeviceObject->WaitingForMidListhead,
                                &AsyncEngineContext->UserMode.WorkQueueLinks);
        
        ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
        
        KeWaitForSingleObject(&AsyncEngineContext->UserMode.WaitForMidEvent,
                              Executive,
                              UserMode,
                              FALSE,
                              NULL);

        NtStatus = STATUS_SUCCESS;
    }

    PrivateWorkItemHeader->AsyncEngineContext = AsyncEngineContext;
    
    AsyncEngineContext->UserMode.CallUpSerialNumber 
             = PrivateWorkItemHeader->SerialNumber
                  = InterlockedIncrement(&UMRefDeviceObject->NextSerialNumber);
    
    PrivateWorkItemHeader->Mid = AsyncEngineContext->UserMode.CallUpMid;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAcquireMidAndFormatHeader with NtStatus = "
                  "%08lx\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxPrepareUserModeRequestBuffer(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN  PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN  ULONG WorkItemHeaderLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine dispatches to a usermode guy using the info in the asyncengine
    context. The workerirp is represented by the captureheader.

Arguments:

   AsyncEngineContext - The context associated with the request that is being
                        sent to the usermode.

    UMRefDeviceObject - The device object in play.

    WorkItemHeader - The workitem buffer.

    WorkItemHeaderLength - Length of the WorkItemHeader buffer.

    IoStatus - The reults of the assignment.

Return Value:

    STATUS_SUCCESS if the thread should be released with the IoStatus returned
    otherwise, don't release the thread.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext;
    PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine;
    BOOL MidAcquired = FALSE, lockAcquired = FALSE, OperationCancelled = TRUE;

    PAGED_CODE();

    RxContext = AsyncEngineContext->RxContext;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                ("%ld: Entering UMRxPrepareUserModeRequestBuffer!!!!\n",
                 PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxPrepareUserModeRequestBuffer: "
                  "WorkItemHeader = %08lx, AsyncEngineContext = %08lx, "
                  "RxContext = %08lx\n", PsGetCurrentThreadId(), WorkItemHeader,
                  AsyncEngineContext, RxContext));
    
    ASSERT(NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT);
    ASSERT(AsyncEngineContext->RxContext == RxContext);

    //
    // We need to make sure that the request has not been cancelled since it 
    // was put on the KQueue. If it has been cancelled, then we don't need to
    // go to the usermode and can do the finalization right away. If it has not
    // been cancelled, the we keep the global ContextListlock, complete the
    // format routine and then release the lock.
    //

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
    lockAcquired = TRUE;

    if (AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextInUserMode) {
    
        //
        // Need checks that things are the right size.
        //
        if (UMRefDeviceObject != (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject)) {
            NtStatus = STATUS_INVALID_PARAMETER;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer: "
                          "Invalid DevObj.\n", PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        FormatRoutine = AsyncEngineContext->UserMode.FormatRoutine;

        NtStatus = UMRxAcquireMidAndFormatHeader(UMRX_ASYNCENGINE_ARGUMENTS,
                                                 UMRefDeviceObject,
                                                 WorkItemHeader);
        if (NtStatus != STATUS_SUCCESS) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer/"
                          "UMRxAcquireMidAndFormatHeader: Error Val = %08lx.\n",
                          PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        } 

        MidAcquired = TRUE;

        if (FormatRoutine != NULL) {
            NtStatus = FormatRoutine(UMRX_ASYNCENGINE_ARGUMENTS,
                                     WorkItemHeader,
                                     WorkItemHeaderLength,
                                     &IoStatus->Information);
            if (NtStatus != STATUS_SUCCESS) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer/"
                              "FormatRoutine: Error Val = %08lx.\n",
                              PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            } 
        }

        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;

    } else {

        BOOLEAN ReturnVal;

        NtStatus = STATUS_CANCELLED;

        ASSERT(AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextCancelled);

        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer: OperationCancelled\n",
                      PsGetCurrentThreadId()));

        OperationCancelled = TRUE;

        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;

        //
        // If this is an AsyncOperation, we need to Finalize the context now.
        // There MUST be 3 references on it. One was taken when the context was
        // created. The second was taken in the UMRxSubmitAsyncEngUserModeRequest
        // routine just before the context was placed on the KQueue. The third
        // one was taken in UMRxEnqueueUserModeCallUp to account for the cancel
        // logic. Read the comment in UMRxEnqueueUserModeCallUp for the reason.
        //
        if (AsyncEngineContext->AsyncOperation) {
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!ReturnVal);
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!ReturnVal);
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(ReturnVal == TRUE);
        } else {
            //
            // If this is a synchronous operation, then there must be just one
            // reference on it which was taken in UMRxEnqueueUserModeCallUp. The
            // other two would have been taken out by the sync thread handling
            // the operation when it was cancelled.
            //
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        }

    }

EXIT_THE_FUNCTION:

    IoStatus->Status = NtStatus;

    //
    // If some error occured while preparing the user mode buffer, then we
    // need to complete the request, returning the error and not go to the user
    // mode.
    //
    if (NtStatus != STATUS_SUCCESS) {

        NTSTATUS LocalStatus;

        //
        // If we failed after acquiring the MID, we need to release it.
        //
        if (MidAcquired) {
            LocalStatus = UMRxVerifyHeader(UMRefDeviceObject,
                                           WorkItemHeader,
                                           REASSIGN_MID,
                                           &(AsyncEngineContext));
            if (LocalStatus != STATUS_SUCCESS) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer/UMRxVerifyHeader:"
                              " NtStatus = %08lx.\n", PsGetCurrentThreadId(), LocalStatus));
                goto EXIT_THE_FUNCTION;
            }
        }

        //
        // If the operation was cancelled, we did not even Format the request,
        // so there is no point in calling UMRxCompleteUserModeErroneousRequest.
        // If this was an Async request, we would have already finalized the
        // AsyncEngineContext above.
        //
        if (!OperationCancelled) {
            AsyncEngineContext->Status = NtStatus;
            LocalStatus = UMRxCompleteUserModeErroneousRequest(AsyncEngineContext,
                                                               UMRefDeviceObject,
                                                               WorkItemHeader,
                                                               WorkItemHeaderLength);
        }

    }

    //
    // If we have the global context lock acquired, we need to release it now.
    // UMRxCompleteUserModeErroneousRequest has to be called (if needed) before
    // the lock is freed. This is very important.
    //
    if (lockAcquired) {
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxPrepareUserModeRequestBuffer with "
                  "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxCompleteUserModeErroneousRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemHeaderLength
    )
/*++

Routine Description:

    This routine is called to complete a request that failed while the user
    buffer was being formatted. 
    
    IMPORTANT!!!
    This can ONLY be called at one place, in the failure case of
    UMRxPrepareUserModeRequestBuffer. It cannot be used as a general routine.
    Its very important to keep this in mind.

Arguments:

   AsyncEngineContext - The context associated with the request that is being
                        sent to the usermode.

    UMRefDeviceObject - The device object in play.

    WorkItemHeader - The workitem buffer.

    WorkItemHeaderLength - Length of the WorkItemHeader buffer.

Return Value:

    STATUS_SUCCESS or the approprate error status value.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext;
    PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PreCompletionRoutine;
    BOOL Call = FALSE;

    PAGED_CODE();

    RxContext = AsyncEngineContext->RxContext;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCompleteUserModeErroneousRequest!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCompleteUserModeErroneousRequest: "
                  "WorkItemHeader = %08lx, AsyncEngineContext = %08lx, "
                  "RxContext = %08lx\n", PsGetCurrentThreadId(), WorkItemHeader,
                  AsyncEngineContext, RxContext));

    PreCompletionRoutine = AsyncEngineContext->UserMode.PrecompletionRoutine;

    if (PreCompletionRoutine != NULL) {
        Call = PreCompletionRoutine(UMRX_ASYNCENGINE_ARGUMENTS,
                                    WorkItemHeader,
                                    WorkItemHeaderLength,
                                    FALSE);
    }

    //
    // We now need to remove the reference taken to handle the cancel logic
    // of the timer thread correctly in UMRxEnqueueUserModeCallUp.
    //
    UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    //
    // The PreCompletion routine can finalize the AsyncEngineContext. In such 
    // a situation, we are done. All that the routine below does is to signal
    // the thread that is waiting for this request to complete.
    //
    if (Call) {
        UMRxAsyncEngineCalldownIrpCompletion(&UMRefDeviceObject->DeviceObject,
                                             NULL,
                                             RxContext);
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxCompleteUserModeErroneousRequest with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxVerifyHeader(
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG ReassignmentCmd,
    OUT PUMRX_ASYNCENGINE_CONTEXT *capturedAsyncEngineContext
    )
/*++

Routine Description:

    This routine makes sure that the header passed in is valid. That is, that
    it really refers to the operation encoded. if it does, then it reasigns or
    releases the MID as appropriate.

Arguments:

    UMRefDeviceObject - The reflctor's device object.

    WorkItemHeader - The work item buffer

    ReassignmentCmd -

    capturedAsyncEngineContext - The context associated with the WorkItemHeader.

Return Value:

    STATUS_SUCCESS if the header is good
    STATUS_INVALID_PARAMETER otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    UMRX_USERMODE_WORKITEM_HEADER capturedHeader;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader = NULL;

    PAGED_CODE();

    PrivateWorkItemHeader = (PUMRX_WORKITEM_HEADER_PRIVATE)(&capturedHeader);

    capturedHeader = *WorkItemHeader;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxVerifyHeader!!!!\n", 
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxVerifyHeader: UMRefDeviceObject = %08lx, "
                  "WorkItemHeader = %08lx.\n", PsGetCurrentThreadId(), 
                  UMRefDeviceObject, WorkItemHeader)); 

    ExAcquireFastMutex( &(UMRefDeviceObject->MidManagementMutex) );

    AsyncEngineContext = RxMapMidToContext(UMRefDeviceObject->MidAtlas,
                                           PrivateWorkItemHeader->Mid);

    if ( (AsyncEngineContext == NULL) ||
         (AsyncEngineContext != PrivateWorkItemHeader->AsyncEngineContext) ||
         (AsyncEngineContext->UserMode.CallUpMid != PrivateWorkItemHeader->Mid) ||
         (AsyncEngineContext->UserMode.CallUpSerialNumber != PrivateWorkItemHeader->SerialNumber) ||
         (&UMRefDeviceObject->RxDeviceObject != AsyncEngineContext->RxContext->RxDeviceObject) ) {

        //
        // This is a bad packet. Just release and get out.
        //
        ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);

        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxVerifyHeader/RxMapMidToContext.\n",
                      PsGetCurrentThreadId()));

        NtStatus = STATUS_INVALID_PARAMETER;

    } else {

        BOOLEAN Finalized;

        RxContext = AsyncEngineContext->RxContext;

        UMRxAsyncEngAssertConsistentLinkage("UMRxVerifyHeaderAndReAssignMid: ", 0);

        *capturedAsyncEngineContext = AsyncEngineContext;

        if (ReassignmentCmd == DONT_REASSIGN_MID) {

            ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);

        } else {

            //
            // Remove the reference I put before I went off.
            //
            Finalized = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!Finalized);

            //
            // Now give up the MID. If there is someone waiting then give it to
            // him. Otherwise, just give it back
            //
            if (IsListEmpty(&UMRefDeviceObject->WaitingForMidListhead)) {

                PVOID DummyContext;

                UMRxDbgTrace(UMRX_TRACE_DETAIL,
                             ("%ld: UMRxVerifyHeader: Giving up mid.\n",
                              PsGetCurrentThreadId()));

                RxMapAndDissociateMidFromContext(UMRefDeviceObject->MidAtlas,
                                                 PrivateWorkItemHeader->Mid,
                                                 &DummyContext);

                ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);

            } else {

                PLIST_ENTRY ThisEntry = RemoveHeadList(&UMRefDeviceObject->WaitingForMidListhead);

                AsyncEngineContext = CONTAINING_RECORD(ThisEntry,
                                                       UMRX_ASYNCENGINE_CONTEXT,
                                                       UserMode.WorkQueueLinks);

                UMRxAsyncEngAssertConsistentLinkage("UMRxVerifyHeaderAndReAssignMid: ", 0);

                UMRxDbgTrace(UMRX_TRACE_DETAIL,
                             ("%ld: UMRxVerifyHeader: Reassigning MID: %08lx.\n",
                              PsGetCurrentThreadId(), PrivateWorkItemHeader->Mid));

                RxReassociateMid(UMRefDeviceObject->MidAtlas,
                                 PrivateWorkItemHeader->Mid,
                                 AsyncEngineContext);

                ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);

                AsyncEngineContext->UserMode.CallUpMid = PrivateWorkItemHeader->Mid;

                KeSetEvent(&AsyncEngineContext->UserMode.WaitForMidEvent,
                           IO_NO_INCREMENT,
                           FALSE);

            }

        }

    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxVerifyHeader with NtStatus = %08lx.\n", 
                  PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxCompleteUserModeRequest(
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemHeaderLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine dispatches to a usermode guy using the info in the asyncengine
    context. The workerirp is represented by the captureheader.

Arguments:

    UMRefDeviceObject - The device object in play.

    WorkItemHeader - The workitem buffer.

    WorkItemHeaderLength - Length of the WorkItemHeader buffer.

    IoStatus - The results of the assignment.

Return Value:

    STATUS_SUCCESS if the thread should be released with the IoStatus returned,
    otherwise don't release the thread.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PreCompletionRoutine = NULL;
    BOOL Call = FALSE, OperationCancelled = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCompleteUserModeRequest!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCompleteUserModeRequest: UMRefDeviceObject: %08lx,"
                  " WorkItemHeader = %08lx.\n", PsGetCurrentThreadId(), 
                  UMRefDeviceObject, WorkItemHeader));

    NtStatus = UMRxVerifyHeader(UMRefDeviceObject,
                                WorkItemHeader,
                                REASSIGN_MID,
                                &AsyncEngineContext);
    if (NtStatus != STATUS_SUCCESS) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCompleteUserModeRequest/UMRxVerifyHeader:"
                      " NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the request has not been cancelled, then we change the state of the
    // context to UMRxAsyncEngineContextBackFromUserMode. If it has been cancelled,
    // we only need to do the cleanup.
    //

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);

    if (AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextInUserMode) {
        AsyncEngineContext->AsyncEngineContextState = UMRxAsyncEngineContextBackFromUserMode;
    } else {
        ASSERT(AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextCancelled);
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCompleteUserModeRequest: UMRxAsyncEngineContextCancelled. AsyncEngineContext = %08lx\n",
                      PsGetCurrentThreadId(), AsyncEngineContext));
        OperationCancelled = TRUE;
    }

    ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));

    RxContext =  AsyncEngineContext->RxContext;

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxCompleteUserModeRequest: AsyncEngineContext = %08lx"
                  ", RxContext = %08lx\n", PsGetCurrentThreadId(), 
                  AsyncEngineContext, RxContext));
    
    PreCompletionRoutine = AsyncEngineContext->UserMode.PrecompletionRoutine;
    
    AsyncEngineContext->Status = WorkItemHeader->Status;

    if (PreCompletionRoutine != NULL) {
        Call = PreCompletionRoutine(UMRX_ASYNCENGINE_ARGUMENTS,
                                    WorkItemHeader,
                                    WorkItemHeaderLength,
                                    OperationCancelled);
    }

    //
    // We now need to remove the reference taken to handle the cancel logic
    // of the timer thread correctly in UMRxEnqueueUserModeCallUp.
    //
    UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    //
    // The PreCompletion routine can finalize the AsyncEngineContext. In such 
    // a situation, we are done. All that the routine below does is to signal
    // the thread that is waiting for this request to complete. So, if the
    // operation has been cancelled, we do not need to call
    // UMRxAsyncEngineCalldownIrpCompletion.
    //
    if (Call && !OperationCancelled) {
        UMRxAsyncEngineCalldownIrpCompletion(&UMRefDeviceObject->DeviceObject,
                                             NULL,
                                             RxContext);
    }

EXIT_THE_FUNCTION:

    IoStatus->Status = NtStatus;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxCompleteUserModeRequest with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxEnqueueUserModeCallUp(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This routine enqueues a work request and returns STATUS_PENDING.

Arguments:

    RxContext - The RDBSS context.

    AsyncEngineContext - The reflector's context.

Return Value:

    STATUS_PENDING.

--*/
{
    NTSTATUS NtStatus = STATUS_PENDING;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;

    PAGED_CODE();

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxEnqueueUserModeCallUp!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxEnqueueUserModeCallUp: AsyncEngineContext: %08lx, "
                  "RxContext: %08lx.\n", PsGetCurrentThreadId(), 
                  AsyncEngineContext, RxContext));

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxEnqueueUserModeCallUp: Try to Queue up the request.\n",
                  PsGetCurrentThreadId()));

    //
    // Before placing an item on the queue, we check to see if the user mode 
    // DAV process is still alive and accepting requests. If its not, we return
    // an error code.
    //
    ExAcquireResourceExclusiveLite(&(UMRefDeviceObject->Q.QueueLock), TRUE);
    if (!UMRefDeviceObject->Q.WorkersAccepted) {
        NtStatus = STATUS_REDIRECTOR_NOT_STARTED;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: UMRxEnqueueUserModeCallUp: Requests no longer"
                      "accepted by the usermode process. NtStatus = %08lx.\n",
                       PsGetCurrentThreadId(), NtStatus));
        ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));
        return NtStatus;
    }
    ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));

    //
    // We need to make sure that the request has not been cancelled. If it has,
    // then we just return STATUS_CANCELLED.
    //
    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);

    if (AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextCancelled) {
        NtStatus = STATUS_CANCELLED;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: UMRxEnqueueUserModeCallUp: NtStatus = %08lx.\n",
                       PsGetCurrentThreadId(), NtStatus));
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        return NtStatus;
    }

    //
    // We now change the state of the context to reflect that is has been sent
    // to the usermode.
    //
    AsyncEngineContext->AsyncEngineContextState = UMRxAsyncEngineContextInUserMode;

    ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));

    //
    // At this stage the reference count of the AsyncEngineContext should be 2.
    // We need to take another reference to make sure that the context stays 
    // alive in case this request was a synchronous one and got cancelled by
    // the Timeout thread. If the request is synchronous and is cancelled by 
    // the timeout thread, then the thread will remove both the references that
    // we have taken so far. This reference is taken out in before the request
    // is sent to the Format routine or the Precomplete routine depending on
    // when (and if) the request was cancelled.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    //
    // Increment the number of workitems.
    //
    InterlockedIncrement(&UMRefDeviceObject->Q.NumberOfWorkItems);

    KeInsertQueue(&UMRefDeviceObject->Q.Queue,
                  &AsyncEngineContext->UserMode.WorkQueueLinks);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxEnqueueUserModeCallUp with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


VOID
UMRxAssignWork(
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER InputWorkItem,
    IN ULONG InputWorkItemLength,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER OutputWorkItem,
    IN ULONG OutputWorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine assigns work to a worker thread. If no work is available then
    the thread is captured until work shows up.

Arguments:

    UMRefDeviceObject - The deviceobject that is in play.

    IoControlCode - The control code of the operation.

    InputWorkItem - The Input buffer that came down from the user mode.

    InputWorkItemLength - Length of the InputBuffer.

    OutputWorkItem - The Output buffer that came down from the user mode.

    OutputWorkItemLength - Length of the OutputBuffer.

    IoStatus - The results of the assignment.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;
    PETHREAD CurrentThread = PsGetCurrentThread();
    ULONG i;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    PLIST_ENTRY pListEntry;
    ULONG NumberOfWorkerThreads;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAssignWork!!!!\n",
                 PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: UMRefDevObj: %08lx\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: CurrentThread: %08lx\n", 
                  PsGetCurrentThreadId(), CurrentThread));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: InputWorkItem: %08lx\n", 
                  PsGetCurrentThreadId(), InputWorkItem));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: OutputWorkItem: %08lx\n", 
                  PsGetCurrentThreadId(), OutputWorkItem));

    IoStatus->Information = 0;
    IoStatus->Status = STATUS_CANNOT_IMPERSONATE;

    if (!UMRefDeviceObject->Q.WorkersAccepted) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAssignWork: No Workers accepted\n",
                      PsGetCurrentThreadId()));
        return;
    }

    if (OutputWorkItem != NULL) {
        if (OutputWorkItemLength < sizeof(UMRX_USERMODE_WORKITEM_HEADER)) {
            IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork: Output request buffer is too small\n",
                          PsGetCurrentThreadId()));
            return;
        }
    }

    if (InputWorkItem != NULL) {
        if (InputWorkItemLength < sizeof(UMRX_USERMODE_WORKITEM_HEADER)) {
            IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork: Input request buffer is too small\n",
                          PsGetCurrentThreadId()));
            return;
        }
    }

    //
    // We need to check if this IOCTL carries a response to an earlier request
    // with it. The response is present if the InputWorkItem is != NULL. If it 
    // does carry a response, we need to process that response.
    //
    if (InputWorkItem != NULL) {
        
        //
        // If this thread was impersonating a client, we need to revert back
        // and clear the flag.
        //
        if( (InputWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAssignWork: InputWorkItem had Impersonating"
                          " flag set.\n", PsGetCurrentThreadId()));
            UMRxRevertClient();
            InputWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
        }
        
        //
        // We need to disable APCs on this thread now.
        //
        FsRtlEnterFileSystem();
        
        //
        // Complete the request for which the response has been received.
        //
        NtStatus = UMRxCompleteUserModeRequest(UMRefDeviceObject,
                                               InputWorkItem,
                                               InputWorkItemLength,
                                               IoStatus);
        if (NtStatus != STATUS_SUCCESS) {
            
            IoStatus->Status = NtStatus;
            
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork/UMRxCompleteUserModeRequest:"
                         " NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            
            FsRtlExitFileSystem();

            return;
        }
    
        FsRtlExitFileSystem();

    } else {
        
        ASSERT(OutputWorkItem != NULL);
        
        //
        // If this thread was impersonating a client, we need to revert back
        // and clear the flag.
        //
        if( (OutputWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAssignWork: OutputWorkItem had Impersonating"
                          " flag set.\n", PsGetCurrentThreadId()));
            UMRxRevertClient();
            OutputWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
        }
    
    }

    //
    // If this thread only carried a response, we should return now.
    //
    if (OutputWorkItem == NULL) {
        IoStatus->Status = NtStatus;
        return;
    }

    //
    // Now, increment the number of threads.
    //
    InterlockedIncrement( &(UMRefDeviceObject->Q.NumberOfWorkerThreads) );

    for (i = 1; ;i++) {
        
        pListEntry = KeRemoveQueue(&UMRefDeviceObject->Q.Queue, UserMode, NULL); // &UMRefDeviceObject->Q.TimeOut);
        
        if ((ULONG_PTR)pListEntry == STATUS_TIMEOUT) {
            ASSERT(!"STATUS_TIMEOUT Happened");
            if ((i % 5) == 0) {
                UMRxDbgTrace(UMRX_TRACE_DETAIL,
                             ("%ld: UMRxAssignWork/KeRemoveQueue: RepostCnt = "
                              "%d\n", PsGetCurrentThreadId(), i));
            }
            continue;
        }
        
        if ((ULONG_PTR)pListEntry == STATUS_USER_APC) {
            IoStatus->Status = STATUS_USER_APC;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: UMRxAssignWork/KeRemoveQueue: UsrApc.\n",
                          PsGetCurrentThreadId()));
            break;
        }
        
        //
        // Check to see if the entry is a Poison one. If it is, it means that
        // the usermode process wants to cleanup the worker threads.
        //
        if (pListEntry == &UMRefDeviceObject->Q.PoisonEntry) {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAssignWork/KeRemoveQueue: Poison Entry.\n",
                          PsGetCurrentThreadId()));
            KeInsertQueue(&UMRefDeviceObject->Q.Queue, pListEntry);
            goto FINALLY;
        }

        //
        // We need to disable APCs on this thread now.
        //
        FsRtlEnterFileSystem();

        //
        // Decrement the number of workitems.
        //
        InterlockedDecrement(&UMRefDeviceObject->Q.NumberOfWorkItems);
        
        AsyncEngineContext = CONTAINING_RECORD(pListEntry,
                                               UMRX_ASYNCENGINE_CONTEXT,
                                               UserMode.WorkQueueLinks);
        
        ASSERT(NodeType(AsyncEngineContext) == UMRX_NTC_ASYNCENGINE_CONTEXT);

        NtStatus = UMRxPrepareUserModeRequestBuffer(AsyncEngineContext,
                                                    UMRefDeviceObject,
                                                    OutputWorkItem,
                                                    OutputWorkItemLength,
                                                    IoStatus);
        if (NtStatus != STATUS_SUCCESS) {
            
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork/"
                          "UMRxPrepareUserModeRequestBuffer: NtStatus = %08lx\n", 
                          PsGetCurrentThreadId(), NtStatus));
            
            FsRtlExitFileSystem();

            continue;
        }

        ASSERT(((IoStatus->Status == STATUS_SUCCESS) ||
                (IoStatus->Status == STATUS_INVALID_PARAMETER)));

        FsRtlExitFileSystem();

        break;
    
    }

FINALLY:
    //
    // Now, decrement the number of threads.
    //
    NumberOfWorkerThreads =
            InterlockedDecrement(&UMRefDeviceObject->Q.NumberOfWorkerThreads);

    //
    // Check to see if the threads are being cleaned up by the user mode 
    // process. When this happens, the WorkersAccepted field of the device
    // object is set to FALSE. If the threads are being cleaned up and if I was
    // the last thread waiting on the KQUEUE, its my responsibility to set the
    // RunDownEvent.
    //
    if ((NumberOfWorkerThreads == 0) && !UMRefDeviceObject->Q.WorkersAccepted){
        KeSetEvent(&UMRefDeviceObject->Q.RunDownEvent,
                   IO_NO_INCREMENT,
                   FALSE);
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxAssignWork: Last Thread.\n",
                      PsGetCurrentThreadId()));
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAssignWork with IoStatus->Status = %08lx\n",
                 PsGetCurrentThreadId(), IoStatus->Status));

    return;
}


VOID
UMRxReleaseCapturedThreads(
    IN OUT PUMRX_DEVICE_OBJECT UMRefDeviceObject
    )
/*++

Routine Description:

    

Arguments:

    UMRefDeviceObject - Device object whose threads are to be released.

Return Value:

    none.
    
--*/
{
    LONG NumberWorkerThreads;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxReleaseCapturedThreads!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxReleaseCapturedThreads: UMRefDeviceObject: %08lx.\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));

    //
    // We need to disable APCs on this thread now.
    //
    FsRtlEnterFileSystem();
    
    //
    // The WorkersAccepted field is initialized to TRUE when the device object
    // gets created and it set to FALSE here. If more than one thread tries to
    // release the threads, only the first one should do the job. The rest
    // should just return. This check is performed below before the thread is
    // allowed to proceed with the release of ser mode worker threads.
    //
    ExAcquireResourceExclusiveLite(&(UMRefDeviceObject->Q.QueueLock), TRUE);

    if (!UMRefDeviceObject->Q.WorkersAccepted) {
        
        ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));
        
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: Worker threads have already returned.\n",
                      PsGetCurrentThreadId()));

        FsRtlExitFileSystem();

        return;
    
    }

    UMRefDeviceObject->Q.WorkersAccepted = FALSE;

    ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));

    //
    // Insert the poison entry. When a worker thread sees this, it realizes that
    // the usermode process intends to cleanup the worker threads.
    //
    KeInsertQueue(&UMRefDeviceObject->Q.Queue,
                  &UMRefDeviceObject->Q.PoisonEntry);

    NumberWorkerThreads =
         InterlockedCompareExchange(&UMRefDeviceObject->Q.NumberOfWorkerThreads,
                                    0,
                                    0);

    if (NumberWorkerThreads != 0) {
        //
        // The RunDownEvent is set by the last thread just before it returns to
        // the usermode.
        //
        KeWaitForSingleObject(&UMRefDeviceObject->Q.RunDownEvent,
                              Executive,
                              UserMode,
                              FALSE,
                              NULL);
    }

    FsRtlExitFileSystem();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxReleaseCapturedThreads.\n",
                  PsGetCurrentThreadId()));
    
    return;
}


PBYTE
UMRxAllocateSecondaryBuffer(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    SIZE_T Length
    )
/*++

Routine Description:

    This routine allocates memory for the secondary buffer of the
    AsyncEngineContext.

Arguments:

    AsyncEngineContext - The reflector's context.

    Length - The length in bytes of the buffer to be allocated.

Return Value:

    Pointer to the buffer or NULL.

--*/
{
    PBYTE rv = NULL;
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject;
    PUMRX_SECONDARY_BUFFER buf = NULL;
    PUMRX_SHARED_HEAP sharedHeap;
    PLIST_ENTRY listEntry;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAllocateSecondaryBuffer.\n",
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAllocateSecondaryBuffer: AsyncEngineContext: %08lx,"
                  " Bytes Asked: %d.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, Length));

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject);
    
    if (Length > UMRefDeviceObject->NewHeapSize) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAllocateSecondaryBuffer: Length > NewHeapSize.\n",
                      PsGetCurrentThreadId()));
        return NULL;
    }

    ExAcquireResourceExclusiveLite(&UMRefDeviceObject->HeapLock, TRUE);

    listEntry = UMRefDeviceObject->SharedHeapList.Flink;

    //
    // We search the list of heaps for just the added safety of not letting
    // the user mode corrupt the pointer and us going off corrupting random
    // memory. Only the local shared heap should have the chance at corruption.
    //
    while (listEntry != &UMRefDeviceObject->SharedHeapList && buf == NULL) {

        sharedHeap = (PUMRX_SHARED_HEAP) CONTAINING_RECORD(listEntry,
                                                           UMRX_SHARED_HEAP,
                                                           HeapListEntry);
        listEntry = listEntry->Flink;

        if (sharedHeap->HeapFull) {
            continue;
        }

        buf = (PUMRX_SECONDARY_BUFFER)RtlAllocateHeap(
                                       sharedHeap->Heap,
                                       HEAP_NO_SERIALIZE,
                                       Length + sizeof(UMRX_SECONDARY_BUFFER));
        if (buf != NULL) {
            break;
        }
    }

    if (buf == NULL) {

        //
        // We won't get into the situation where the heap is too small for
        // the object we're trying to allocate even though we just allocated
        // a fresh heap.
        //

        SIZE_T heapSize = max(UMRefDeviceObject->NewHeapSize, 2 * Length);

        sharedHeap = UMRxAddSharedHeap(UMRefDeviceObject, heapSize);

        if (sharedHeap != NULL) {

            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAllocateSecondaryBuffer: sharedHeap: %08lx.\n", 
                          PsGetCurrentThreadId(), sharedHeap));

            buf = (PUMRX_SECONDARY_BUFFER)
                               RtlAllocateHeap(
                                        sharedHeap->Heap,
                                        HEAP_NO_SERIALIZE,
                                        Length + sizeof(UMRX_SECONDARY_BUFFER));
        }
    }

    if (buf != NULL) {
        //
        // We insert into the list while holding the HeapLock so that we
        // don't have to worry about the list getting corrupted.
        //

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxAllocateSecondaryBuffer: buf: %08lx.\n", 
                      PsGetCurrentThreadId(), buf));

        sharedHeap->HeapAllocationCount++;

        buf->Signature = UMRX_SECONDARY_BUFFER_SIGNATURE;
        buf->AllocationSize = Length;
        buf->SourceSharedHeap = sharedHeap;

        InsertHeadList(&AsyncEngineContext->AllocationList, &buf->ListEntry);

        rv = (PCHAR) &buf->Buffer[0];
    }

    ExReleaseResourceLite(&UMRefDeviceObject->HeapLock);

    if (rv == NULL) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAllocateSecondaryBuffer allocation failed"
                      ". Size = %08lx\n", PsGetCurrentThreadId(), Length));
        return(NULL);
    }
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAllocateSecondaryBuffer. rv = %08lx.\n",
                  PsGetCurrentThreadId(), rv));
    
    return rv;
}


NTSTATUS
UMRxFreeSecondaryBuffer(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    PBYTE BufferToFree
    )
/*++

Routine Description:

    This routine frees up the memory allocated for the secondary buffer of the
    AsyncEngineContext.

Arguments:

    AsyncEngineContext - The reflector's context.

Return Value:

    none.

--*/
{
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject;
    PUMRX_SECONDARY_BUFFER buf;
    PUMRX_SHARED_HEAP sharedHeap;
    PLIST_ENTRY listEntry;
    BOOLEAN checkVal = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: Entering UMRxFreeSecondaryBuffer.\n",
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxFreeSecondaryBuffer: AsyncEngineContext: %08lx,"
                  " BufferToFree: %08lx.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, BufferToFree));
    
    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    ASSERT(BufferToFree != NULL);

    buf = CONTAINING_RECORD(BufferToFree, UMRX_SECONDARY_BUFFER, Buffer);
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxFreeSecondaryBuffer: buf: %08lx.\n", 
                  PsGetCurrentThreadId(), buf));
    
    ASSERT(buf->SourceSharedHeap);

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxFreeSecondaryBuffer: buf->SourceSharedHeap: %08lx.\n", 
                  PsGetCurrentThreadId(), buf->SourceSharedHeap));
    

    ExAcquireResourceExclusiveLite(&UMRefDeviceObject->HeapLock, TRUE);

    listEntry = UMRefDeviceObject->SharedHeapList.Flink;

    //
    // We search the list of heaps for just the added safety of not letting
    // the user mode corrupt the pointer and us going off corrupting random
    // memory.  only the local shared heap should have the chance at corruption.
    //
    while (listEntry != &UMRefDeviceObject->SharedHeapList) {
        sharedHeap = (PUMRX_SHARED_HEAP) CONTAINING_RECORD(listEntry,
                                                           UMRX_SHARED_HEAP,
                                                           HeapListEntry);
        ASSERT(sharedHeap);
        
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFreeSecondaryBuffer: sharedHeap: %08lx.\n", 
                      PsGetCurrentThreadId(), sharedHeap));
        
        if (sharedHeap == buf->SourceSharedHeap) {
            break;
        }
        listEntry = listEntry->Flink;
    }

    ASSERT(listEntry != &UMRefDeviceObject->SharedHeapList);

    if (listEntry == &UMRefDeviceObject->SharedHeapList) {

        //
        // Ouch. This block isn't in any that we know about.
        //
        ExReleaseResourceLite(&UMRefDeviceObject->HeapLock);
        return STATUS_INVALID_PARAMETER;
    }

    RemoveEntryList(&buf->ListEntry);

    sharedHeap->HeapAllocationCount--;

    checkVal = RtlFreeHeap(sharedHeap->Heap, 0, buf);
    if (!checkVal) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxFreeSecondaryBuffer/RtlFreeHeap.\n",
                      PsGetCurrentThreadId()));
    }
    
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxFreeSecondaryBuffer: sharedHeap->Heap = %08lx.\n",
                  PsGetCurrentThreadId(), sharedHeap->Heap));
    
    sharedHeap->HeapFull = FALSE;

    if (sharedHeap->HeapAllocationCount == 0) {
        //
        //  If this was the last allocation in this heap, let's see if there's
        //  any other empty heaps. If there are, we'll free one of them.
        //  This prevents us from holding the max number of heaps during
        //  varying loads.
        //

        PUMRX_SHARED_HEAP secondarySharedHeap;

        listEntry = UMRefDeviceObject->SharedHeapList.Flink;

        while (listEntry != &UMRefDeviceObject->SharedHeapList) {

            secondarySharedHeap = (PUMRX_SHARED_HEAP) 
                                            CONTAINING_RECORD(listEntry,
                                                              UMRX_SHARED_HEAP,
                                                              HeapListEntry);
            
            if ( (secondarySharedHeap->HeapAllocationCount == 0) &&
                 (secondarySharedHeap != sharedHeap) ) {
                break;
            }
            listEntry = listEntry->Flink;
        }

        if (listEntry != &UMRefDeviceObject->SharedHeapList) {
            PVOID HeapHandle;
            
            RemoveEntryList(listEntry);
            
            HeapHandle = RtlDestroyHeap(secondarySharedHeap->Heap);
            if (HeapHandle != NULL) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxFreeSecondaryBuffer/RtlDestroyHeap.\n",
                              PsGetCurrentThreadId()));
            }
            
            ZwFreeVirtualMemory(NtCurrentProcess(),
                                &secondarySharedHeap->VirtualMemoryBuffer,
                                &secondarySharedHeap->VirtualMemoryLength,
                                MEM_RELEASE);
            
            RxFreePool(secondarySharedHeap);
        }
    }

    ExReleaseResourceLite(&UMRefDeviceObject->HeapLock);
    
    return STATUS_SUCCESS;
}


PUMRX_SHARED_HEAP
UMRxAddSharedHeap(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    SIZE_T HeapSize
    )
/*++

Routine Description:

    This routine allocates the shared heap which is used to pass stuff onto the 
    user mode. It allocated virtual memory, creates a heap and returns a pointer
    to it. If the functions fails a NULL is returned.

Arguments:

    UMRefDeviceObject - The Reflector's device object.
    
    HeapSize - The size of the heap being allocated.

Return Value:

    Pointer to the creatted heap or NULL.

--*/
{
    PBYTE buff = NULL;
    NTSTATUS err;
    PUMRX_SHARED_HEAP sharedHeap = NULL;

    PAGED_CODE();

    //
    //  We assume the device object's heap lock is held coming in here.
    //

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAddSharedHeap.\n", PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAddSharedHeap: UMRefDeviceObject: %08lx, "
                  "HeapSize: %d.\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject, HeapSize));
    
    //
    // We allocate the heap structure in paged pool rather than in virtual
    // memory so that there is zero possiblity that user mode code could
    // corrupt our list of heaps.  It can still corrupt a heap, but that's
    // something we'll have to live with for now.
    //

    sharedHeap = RxAllocatePoolWithTag(PagedPool,
                                       sizeof(UMRX_SHARED_HEAP),
                                       UMRX_SHAREDHEAP_POOLTAG);
    if (sharedHeap == NULL) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAddSharedHeap/RxAllocatePoolWithTag: "
                      "Couldn't get the sharedHeap structure!\n",
                      PsGetCurrentThreadId()));
        return NULL;
    }

    sharedHeap->VirtualMemoryLength = HeapSize;
    sharedHeap->VirtualMemoryBuffer = NULL;
    sharedHeap->Heap = NULL;
    sharedHeap->HeapAllocationCount = 0;
    sharedHeap->HeapFull = FALSE;

    err = ZwAllocateVirtualMemory(NtCurrentProcess(),
                                  (PVOID *) &buff,
                                  0,
                                  &sharedHeap->VirtualMemoryLength,
                                  MEM_COMMIT,
                                  PAGE_READWRITE);
    if (NT_SUCCESS(err)) {
        SIZE_T ReserveSize = HeapSize;
        sharedHeap->Heap = RtlCreateHeap(HEAP_NO_SERIALIZE,
                                         (PVOID) buff,
                                         ReserveSize,
                                         PAGE_SIZE,
                                         NULL,
                                         0);
        if (sharedHeap->Heap == NULL) {
            err = STATUS_NO_MEMORY;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAddSharedHeap/RtlCreateHeap: "
                         "NtStatus = %08lx\n", PsGetCurrentThreadId(), err));
            ZwFreeVirtualMemory(NtCurrentProcess(),
                                (PVOID *) &buff,
                                &HeapSize,
                                MEM_RELEASE);
            RxFreePool(sharedHeap);
            sharedHeap = NULL;
        } else {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAddSharedHeap: sharedHeap->Heap = %08lx.\n",
                          PsGetCurrentThreadId(), sharedHeap->Heap));

            sharedHeap->VirtualMemoryBuffer = buff;
            
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAddSharedHeap: "
                          "&UMRefDeviceObject->SharedHeapList: %08lx.\n",
                          PsGetCurrentThreadId(),
                          &UMRefDeviceObject->SharedHeapList));
            
            InsertHeadList(&UMRefDeviceObject->SharedHeapList,
                            &sharedHeap->HeapListEntry);
        }
    } else {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAddSharedHeap/ZwAllocateVirtualMemory:"
                      " NtStatus = %08lx.\n", PsGetCurrentThreadId(), err));
        RxFreePool(sharedHeap);
        sharedHeap = NULL;
    }
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAddSharedHeap.\n", PsGetCurrentThreadId()));
    
    return sharedHeap;
}

#if DBG
#define UMRX_DEBUG_KEY L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\MRxDAV\\Parameters"
#define UMRX_DEBUG_VALUE L"UMRxDebugFlag"
#endif

NTSTATUS
UMRxInitializeDeviceObject(
    OUT PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN USHORT MaxNumberMids,
    IN USHORT InitialMids,
    IN SIZE_T HeapSize
    )
/*++

Routine Description:

    This initializes the UMRX_DEVICE_OBJECT structure.  The shared heap
    is created for shared memory between kernel and user.

Arguments:

    UMRefDeviceObject - The reflector's device object to be initialized.

    MaxNumberMids - Maximum number of mids to be used.

    InitialMids - Initial number of mids allocated.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS err = STATUS_SUCCESS;
    PRX_MID_ATLAS MidAtlas = NULL;

    PAGED_CODE();

    //
    // This is the first reflector routine called by the Mini-Redir and so is
    // the place where the UMRxDebugVector should be initialized.
    //
#if DBG
    UMRxReadDWORDFromTheRegistry(UMRX_DEBUG_KEY, UMRX_DEBUG_VALUE, &(UMRxDebugVector));
#endif

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxInitializeDeviceObject!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxInitializeDeviceObject: UMRefDeviceObject: %08lx\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));
    
    //
    // MidAtlas.
    //
    MidAtlas = RxCreateMidAtlas(MaxNumberMids, InitialMids);
    if (MidAtlas == NULL) {
        err = STATUS_INSUFFICIENT_RESOURCES;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxInitializeDeviceObject/RxCreateMidAtlas:"
                      " NtStatus = %08lx.\n", PsGetCurrentThreadId(), err));
        return(err);
    }
    UMRefDeviceObject->MidAtlas = MidAtlas;
    InitializeListHead(&UMRefDeviceObject->WaitingForMidListhead);
    ExInitializeFastMutex(&UMRefDeviceObject->MidManagementMutex);

    //
    // Initialize the global AsyncEngineContext list and the mutex that is used
    // to synchronize access to it.
    //
    InitializeListHead( &(UMRxAsyncEngineContextList) );
    ExInitializeResourceLite( &(UMRxAsyncEngineContextListLock) );

    //
    // Heap.
    //
    UMRefDeviceObject->NewHeapSize = HeapSize;
    InitializeListHead(&UMRefDeviceObject->SharedHeapList);
    ExInitializeResourceLite(&UMRefDeviceObject->HeapLock);

    //
    // KQUEUE.
    //
    KeInitializeQueue(&UMRefDeviceObject->Q.Queue, 0);
    ExInitializeResourceLite(&(UMRefDeviceObject->Q.QueueLock));
    UMRefDeviceObject->Q.TimeOut.QuadPart  = -10 * TICKS_PER_SECOND;
    KeInitializeEvent(&UMRefDeviceObject->Q.RunDownEvent,
                      NotificationEvent,
                      FALSE);
    UMRefDeviceObject->Q.NumberOfWorkerThreads = 0;
    UMRefDeviceObject->Q.NumberOfWorkItems = 0;
    UMRefDeviceObject->Q.WorkersAccepted = TRUE;

    //
    // This specifies the alignment requirement for unbuffered writes. Assuming
    // that the sector size on disks is 512 bytes, the size of the writes should
    // be a multiple of the 512 (SectorSize).
    //
    UMRefDeviceObject->SectorSize = 512;

    RxMakeLateDeviceAvailable(&UMRefDeviceObject->RxDeviceObject);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxInitializeDeviceObject with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), STATUS_SUCCESS));

    return STATUS_SUCCESS;
}

NTSTATUS
UMRxCleanUpDeviceObject(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject
    )
/*++

Routine Description:

    This destorys the instance data for a UMReflector device object.

Arguments:

    UMRefDeviceObject - The reflector's device object to be destroyed.

Return Value:

    NTSTATUS

--*/
{
    PLIST_ENTRY pFirstListEntry, pNextListEntry;
    BOOLEAN FoundPoisoner = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCleanUpDeviceObject!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCleanUpDeviceObject: UMRefDeviceObject: %08lx.\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));

    //
    // Delete the resource that was created to synchronize access to the 
    // AsyncEngineContext list.
    //
    ExDeleteResourceLite( &(UMRxAsyncEngineContextListLock) );

    //
    // Delete the resource that was created to synchronize access to the heap.
    //
    ExDeleteResourceLite(&UMRefDeviceObject->HeapLock);
    
    //
    // If we created a MidAtlas structure, we need to destroy it now.
    //
    if (UMRefDeviceObject->MidAtlas != NULL) {
        RxDestroyMidAtlas(UMRefDeviceObject->MidAtlas, NULL);
    }

    //
    // Run down the KQUEUE to make sure that they are no outstanding queued
    // requests. There shouldn't be any.
    //
    pFirstListEntry = KeRundownQueue(&UMRefDeviceObject->Q.Queue);
    if (pFirstListEntry != NULL) {
        pNextListEntry = pFirstListEntry;
        do {
            PLIST_ENTRY ThisEntry =  pNextListEntry;
            pNextListEntry = pNextListEntry->Flink;
            if (ThisEntry != &UMRefDeviceObject->Q.PoisonEntry) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxCleanUpDeviceObject: Non Poisoner In The KQueue: %08lx\n",
                              PsGetCurrentThreadId(), ThisEntry));
            } else {
                FoundPoisoner = TRUE;
            }
        } while (pNextListEntry != pFirstListEntry);
    }

    ExDeleteResourceLite(&(UMRefDeviceObject->Q.QueueLock));

    if (!FoundPoisoner) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCleanUpDeviceObject: No Poisoner in queue.\n",
                      PsGetCurrentThreadId()));
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxCleanUpDeviceObject.\n",
                  PsGetCurrentThreadId()));

    return STATUS_SUCCESS;
}


NTSTATUS
UMRxImpersonateClient(
    IN PSECURITY_CLIENT_CONTEXT SecurityClientContext,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    )
/*++

Routine Description:

    This routine impersonates a worker thread to get the credentials of the
    client of the I/O operation.

Arguments:

    SecurityClientContext - The security context of the client used in the
                            impersonation call.
                            
    WorkItemHeader - The workitem associated with this request. If the 
                     impersonation succeeds, the UMRX_WORKITEM_IMPERSONATING
                     flag is set in the workitem.

Return Value:

    An NTSTATUS value.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(SecurityClientContext != NULL);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxImpersonateClient!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxImpersonateClient: SecurityClientContext: %08lx.\n",
                  PsGetCurrentThreadId(), SecurityClientContext));

    NtStatus = SeImpersonateClientEx(SecurityClientContext, NULL);
    if (!NT_SUCCESS(NtStatus)) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxImpersonateClient/SeImpersonateClientEx"
                     ". NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    } else {
        //
        // Set the impersonating flag in the workitem.
        //
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxImpersonateClient: Setting the Impersonation"
                      " Flag.\n", PsGetCurrentThreadId()));
        WorkItemHeader->Flags |= UMRX_WORKITEM_IMPERSONATING;
    }

    return NtStatus;
}


NTSTATUS
UMRxAsyncEngOuterWrapper(
    IN PRX_CONTEXT RxContext,
    IN ULONG AdditionalBytes,
    IN PUMRX_ASYNCENG_CONTEXT_FORMAT_ROUTINE ContextFormatRoutine,
    USHORT FormatContext,
    IN PUMRX_ASYNCENG_CONTINUE_ROUTINE Continuation,
    IN PSZ RoutineName
    )
/*++

Routine Description:

   This routine is common to guys who use the async context engine. It has the
   responsibility for getting a context, initing, starting and finalizing it, 
   but the internal guts of the procesing is via the continuation routine 
   that is passed in.

Arguments:

    RxContext  - The RDBSS context.
    
    AdditionalBytes - The Additional bytes to be allocated for the context.
                      Some Mini-Redirs might need them.
    
    ContextFormatRoutine - The routine that formats the Mini-Redirs portion of
                           the context. This may be NULL if the Mini-Redir does
                           not need any extra context fields.              
                           
    FormatContext - The context passed to the ContextFormatRoutine. Its 
                    not relvant if the ContextFormatRoutine is NULL.                          
    
    Continuation - The Continuation routine which handles this I/O Request once 
                   AsynEngineContext has been setup.
                   
    RotuineName - The name of the entry routine that called this function.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    ULONG SizeToAllocateInBytes;

    PAGED_CODE();
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAsyncEngOuterWrapper!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAsyncEngOuterWrapper: "
                  "RxContext: %08lx, Calling Routine: %s.\n", 
                  PsGetCurrentThreadId(), RxContext, RoutineName));

    SizeToAllocateInBytes = SIZEOF_UMRX_ASYNCENGINE_CONTEXT + AdditionalBytes;

    //
    // Try to create an AsyncEngContext for this operation. If unsuccessful,
    // return failure.
    //
    AsyncEngineContext = UMRxCreateAsyncEngineContext(RxContext,
                                                      SizeToAllocateInBytes);

    if (AsyncEngineContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAsyncEngOuterWrapper/"
                      "UMRxCreateAsyncEngineContext: Error Val = %08lx\n", 
                      PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set the continuation routine.
    //
    AsyncEngineContext->Continuation = Continuation;

    //
    // If the Mini-Redir supplied a ContextFormatRoutine, now is the time to
    // call it.
    //
    if (ContextFormatRoutine) {
        NtStatus = ContextFormatRoutine(AsyncEngineContext, FormatContext);
        if (NtStatus != STATUS_SUCCESS) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAsyncEngOuterWrapper/"
                          "ContextFormatRoutine: Error Val = %08lx\n", 
                          PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // Now that we have the context ready, call the continuation routine.
    //
    if (Continuation) {
        NtStatus = Continuation(UMRX_ASYNCENGINE_ARGUMENTS);
        if ( NtStatus != STATUS_SUCCESS && NtStatus != STATUS_PENDING ) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAsyncEngOuterWrapper/Continuation:"
                          " Error Val = %08lx, Calling Routine: %s.\n", 
                          PsGetCurrentThreadId(), NtStatus, RoutineName));
        }
    }

EXIT_THE_FUNCTION:

    if (NtStatus != STATUS_PENDING) {
        if (AsyncEngineContext) {
            BOOLEAN FinalizationComplete;
            FinalizationComplete = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        }
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAsyncEngOuterWrapper with NtStatus = "
                  "%08lx\n", PsGetCurrentThreadId(), NtStatus));

    return (NtStatus);
}


NTSTATUS
UMRxReadDWORDFromTheRegistry(
    IN PWCHAR RegKey,
    IN PWCHAR ValueToRead,
    OUT LPDWORD DataRead
    )
/*++

Routine Description:

    This routine reads a DWORD value from the registry.

Arguments:

    RegKey - The registry key who value needs to be read.
    
    ValueToRead - The DWORD value to be read.
    
    DataRead - The data is copied into this and returned back to the caller.

Return Value:

    NTSTATUS value.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HKEY SubKey = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeKeyName, UnicodeValueName;
    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = NULL;
    ULONG SizeInBytes = 0, SizeReturned = 0;

    PAGED_CODE();

    RtlInitUnicodeString(&(UnicodeKeyName), RegKey);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&(SubKey), KEY_READ, &(ObjectAttributes));
    if (NtStatus != STATUS_SUCCESS) {
        DbgPrint("%ld: ERROR: UMRxReadDWORDFromTheRegistry/ZwOpenKey: NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus);
        goto EXIT_THE_FUNCTION;
    }

    RtlInitUnicodeString(&(UnicodeValueName), ValueToRead);

    //
    // The size we need has to be the size of the structure plus the size of a 
    // DWORD since thats what we are going to be reading.
    //
    SizeInBytes = ( sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD) );

    PartialInfo = RxAllocatePool(PagedPool, SizeInBytes);
    if (PartialInfo == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DbgPrint("%ld: ERROR: UMRxReadDWORDFromTheRegistry/RxAllocatePool: NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus);
        goto EXIT_THE_FUNCTION;
    }

    NtStatus = ZwQueryValueKey(SubKey,
                               &(UnicodeValueName),
                               KeyValuePartialInformation,
                               (PVOID)PartialInfo,
                               SizeInBytes,
                               &(SizeReturned));
    if (NtStatus != STATUS_SUCCESS) {
        DbgPrint("%ld: ERROR: UMRxReadDWORDFromTheRegistry/ZwQueryValueKey: NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus);
        goto EXIT_THE_FUNCTION;
    }

    RtlCopyMemory(DataRead, PartialInfo->Data, PartialInfo->DataLength);

EXIT_THE_FUNCTION:

    if (SubKey) {
        NtClose(SubKey);
        SubKey = NULL;
    }

    if (PartialInfo) {
        RxFreePool(PartialInfo);
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\getreq.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    getreq.c

Abstract:

    This code handles getting requests and sending responses to the kernel for
    the user mode reflector library.  This implements UMReflectorGetRequest
    and UMReflectorSendResponse.

Author:

    Andy Herron (andyhe) 19-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

ULONG
UMReflectorGetRequest (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER ResponseWorkItem,
    PUMRX_USERMODE_WORKITEM_HEADER ReceiveWorkItem,
    BOOL revertAlreadyDone
    )
/*++

Routine Description:

    This routine sends down an IOCTL to get a request and in some cases
    send a response.

Arguments:

    Handle - The reflector's handle.

    ResponseWorkItem - Response to an earlier request.

    ReceiveWorkItem - Buffer to receive another request.
    
    revertAlreadyDone - If this is TRUE, it means that the thread that is 
                        executing this function has been reverted back to its
                        original state. When the request is picked up from the 
                        kernel, in some cases the thread impersonates the client
                        that issued the request. If we revert back in the 
                        usermode for some reason, then we don't need to revert
                        back in the kernel.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    PUMRX_USERMODE_WORKITEM_ADDON previousWorkItem = NULL;
    BOOL SuccessfulOperation;
    ULONG NumberOfBytesTransferred;
    ULONG rc;

    if (WorkerHandle == NULL || ReceiveWorkItem == NULL) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorGetRequest. Invalid Parameter.\n",
                       GetCurrentThreadId()));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // this is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON) (PCHAR)((PCHAR)ReceiveWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState == WorkItemStateNotYetSentToKernel);
    workItem->WorkItemState = WorkItemStateInKernel;

    if (ResponseWorkItem != NULL) {
        //
        // If we have a response to send, then we don't have to go check the
        // free pending list. Just do it now.
        //
        previousWorkItem = (PUMRX_USERMODE_WORKITEM_ADDON)
                           (PCHAR)((PCHAR)ResponseWorkItem -
                           FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

        ASSERT(previousWorkItem->WorkItemState != WorkItemStateFree);
        ASSERT(previousWorkItem->WorkItemState != WorkItemStateAvailable);

        previousWorkItem->WorkItemState = WorkItemStateResponseNotYetToKernel;
        
        if (WorkerHandle->IsImpersonating) {
            ASSERT( (ResponseWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) );
            WorkerHandle->IsImpersonating = FALSE;
            //
            // If we have already reverted back to the threads original context,
            // then we clear this flag as we don't need to revert back in the
            // kernel.
            //
            if (revertAlreadyDone) {
                ResponseWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
            }
        }

        SuccessfulOperation = DeviceIoControl(WorkerHandle->ReflectorHandle,
                                              IOCTL_UMRX_RESPONSE_AND_REQUEST,
                                              ResponseWorkItem,
                                              ResponseWorkItem->WorkItemLength,
                                              ReceiveWorkItem,
                                              ReceiveWorkItem->WorkItemLength,
                                              &NumberOfBytesTransferred,
                                              NULL);

        previousWorkItem->WorkItemState = WorkItemStateResponseFromKernel;
    } else {
        //
        // If this thread was impersonating a client when it came up, store that
        // info in the workitem that is being sent down to get the request. In the
        // kernel, the reflector will look at this flag and revert back. After 
        // setting the flag, we set the IsImpersonating value to FALSE.
        //
        if (WorkerHandle->IsImpersonating) {
            
            //
            // If we have already reverted back to the threads original context,
            // then we do not set this flag as we don't need to revert back in 
            // the kernel.
            //
            if (!revertAlreadyDone) {
                ReceiveWorkItem->Flags |= UMRX_WORKITEM_IMPERSONATING;
            }
            WorkerHandle->IsImpersonating = FALSE;
        }
        SuccessfulOperation = DeviceIoControl(WorkerHandle->ReflectorHandle,
                                              IOCTL_UMRX_GET_REQUEST,
                                              NULL,
                                              0,
                                              ReceiveWorkItem,
                                              ReceiveWorkItem->WorkItemLength,
                                              &NumberOfBytesTransferred,
                                              NULL);
    }
    
    if (!SuccessfulOperation) {
        rc = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorGetRequest/DeviceIoControl: Error Val = "
                       "%08lx.\n", GetCurrentThreadId(), rc));
        workItem->WorkItemState = WorkItemStateNotYetSentToKernel;
    } else {
        rc = STATUS_SUCCESS;
        workItem->WorkItemState = WorkItemStateReceivedFromKernel;
        //
        // If the thread is Impersonating a client, store that info. This is 
        // needed to tell the kernel to revert the thread back when it goes to
        // collect another request.
        //
        if( (ReceiveWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
            WorkerHandle->IsImpersonating = TRUE;
        }
    }

    return rc;
}


ULONG
UMReflectorSendResponse (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER ResponseWorkItem
    )
/*++

Routine Description:

    This routine sends down an IOCTL to get send a response for an asynchronous
    request.

Arguments:

    Handle - The reflector's handle.

    ResponseWorkItem - Response to an earlier request.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON   workItem = NULL;
    BOOL                            SuccessfulOperation;
    ULONG                           NumberOfBytesTransferred;
    ULONG                           rc;

    if (WorkerHandle == NULL || ResponseWorkItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR)ResponseWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState == WorkItemStateReceivedFromKernel);
    workItem->WorkItemState = WorkItemStateResponseNotYetToKernel;

    if( (ResponseWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
        ResponseWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
    }

    SuccessfulOperation = DeviceIoControl(WorkerHandle->ReflectorHandle,
                                          IOCTL_UMRX_RESPONSE,
                                          ResponseWorkItem,
                                          ResponseWorkItem->WorkItemLength,
                                          NULL,
                                          0,
                                          &NumberOfBytesTransferred,
                                          NULL);
    if (!SuccessfulOperation) {
        rc = GetLastError();
    } else {
        rc = ERROR_SUCCESS;
    }

    workItem->WorkItemState = WorkItemStateResponseFromKernel;

    return rc;
}

// getreq.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\security.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This code handles impersonating and reverting for the user mode
    reflector library.  This implements UMReflectorImpersonate and
    UMReflectorRevert.

Author:

    Andy Herron (andyhe) 20-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


ULONG
UMReflectorImpersonate(
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem,
    HANDLE ImpersonationToken
    )
/*++

Routine Description:

   This routine impersonates the calling thread. 

Arguments:

    IncomingWorkItem - The workitem being handled by the thread.
    
    ImpersonationToken - The handle used to impersonate.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG rc = STATUS_SUCCESS;
    BOOL ReturnVal;

    if (IncomingWorkItem == NULL || ImpersonationToken == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR) IncomingWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState != WorkItemStateFree);
    ASSERT(workItem->WorkItemState != WorkItemStateAvailable);

    ReturnVal = ImpersonateLoggedOnUser(ImpersonationToken);
    if (!ReturnVal) {
        rc = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorImpersonate/ImpersonateLoggedOnUser: "
                       "WStatus = %08lx.\n", GetCurrentThreadId(), rc));
    }

    return rc;
}

ULONG
UMReflectorRevert(
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem
    )
/*++

Routine Description:

   This routine reverts the calling thread which was impersonated earlier. 

Arguments:

    IncomingWorkItem - The workitem being handled by the thread.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG rc = STATUS_SUCCESS;
    BOOL ReturnVal;

    if (IncomingWorkItem == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR) IncomingWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ReturnVal = RevertToSelf();
    if (!ReturnVal) {
        rc = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorRevert/RevertToSelf: "
                       "WStatus = %08lx.\n", GetCurrentThreadId(), rc));
    }

    return rc;
}

// security.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\init.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This is the init/term entry points for the user mode library of the
    user mode reflector.  This implements UMReflectorRegister,
    UMReflectorUnregister, & UMReflectorReleaseThreads.

Author:

    Andy Herron (andyhe) 19-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include <shlobj.h>


typedef 
BOOL 
(*PFN_GETWININET_CACHE_PATH) (
    HWND hwnd, 
    LPWSTR pszPath, 
    int csidl, 
    BOOL fCreate
    );


ULONG
UMReflectorRegister (
    PWCHAR DriverDeviceName,
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK *Reflector
    )
/*++

Routine Description:

    This routine registers the user mode process with the kernel mode component.
    We'll register this user mode process with the driver's reflector.

Arguments:

    DriverDeviceName - Must be a valid name of the form L"\\Device\\foobar",
                       where foobar is the device name registered with
                       RxRegisterMinirdr.

    ReflectorVersion - The version of the library.

    Reflector - This is returned by the call and points to an opaque structure 
                that should be passed to subsequent calls.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG rc = STATUS_SUCCESS;
    ULONG sizeRequired;
    PUMRX_USERMODE_REFLECT_BLOCK reflectorInstance = NULL;
    UNICODE_STRING UMRxDeviceName;
    UNICODE_STRING DeviceObjectName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG driverDeviceNameLength;

    if (ReflectorVersion != UMREFLECTOR_CURRENT_VERSION) {
        //
        // Whoops. Mismatch here. We should support backward levels but right
        // now there aren't any so we just bail.
        //
        rc = ERROR_NOT_SUPPORTED;
        goto errorExit;
    }

    if (DriverDeviceName == NULL || Reflector == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        goto errorExit;
    }

    //
    // Calculate the size to be allocated for the UMRX_USERMODE_REFLECT_BLOCK
    // and the device name following it.
    //
    sizeRequired = sizeof(UMRX_USERMODE_REFLECT_BLOCK);
    driverDeviceNameLength = lstrlenW(DriverDeviceName) + 1;
    sizeRequired += driverDeviceNameLength * sizeof(WCHAR);

    reflectorInstance = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeRequired);
    *Reflector = reflectorInstance;
    if (reflectorInstance == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto errorExit;
    }

    try {
        InitializeCriticalSection( &(reflectorInstance->Lock) );
    } except(EXCEPTION_EXECUTE_HANDLER) {
          rc = GetExceptionCode();
          RlDavDbgPrint(("%ld: ERROR: UMReflectorRegister/InitializeCriticalSection: "
                         "Exception Code = %08lx\n", GetCurrentThreadId(), rc));
          goto errorExit;
    }
    
    InitializeListHead(&reflectorInstance->WorkerList);
    InitializeListHead(&reflectorInstance->WorkItemList);
    InitializeListHead(&reflectorInstance->AvailableList);

    //
    // For being alive add a reference to the block.
    //
    reflectorInstance->ReferenceCount = 1;  
    reflectorInstance->Closing = FALSE;
    reflectorInstance->DeviceHandle = INVALID_HANDLE_VALUE;

    //
    // We copy the driver names into the bottom of our buffer so that we have
    // copies of them later on if needed.
    //
    reflectorInstance->DriverDeviceName = &reflectorInstance->DeviceNameBuffers[0];
    lstrcpyW(reflectorInstance->DriverDeviceName, DriverDeviceName);

    //
    // Attempt to connect up with the driver.
    //
    RtlInitUnicodeString(&UMRxDeviceName, reflectorInstance->DriverDeviceName);
    InitializeObjectAttributes(&ObjectAttributes,
                               &UMRxDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    rc = NtOpenFile(&reflectorInstance->DeviceHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    FILE_SHARE_VALID_FLAGS,
                    FILE_SYNCHRONOUS_IO_NONALERT);
    if (rc == STATUS_SUCCESS) {
        ASSERT( reflectorInstance->DeviceHandle != INVALID_HANDLE_VALUE );
    } else {
        rc = RtlNtStatusToDosError(rc);
    }

errorExit:

    if (rc != STATUS_SUCCESS) {
        //
        // Things failed here. Let's clean up.
        //
        (void) UMReflectorUnregister(reflectorInstance);
        *Reflector = NULL;
    }

    return rc;
}


VOID
DereferenceReflectorBlock (
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    This routine dereferences the reflector block and if the reference becomes
    zero, finalizes it.

Arguments:

    Reflector - This is returned by the call and points to an opaque structure 
                that should be passed to subsequent calls.

Return Value:

    none.
    
--*/
{
    PLIST_ENTRY listEntry;
    PUMRX_USERMODE_WORKITEM_ADDON workItem;

    //
    //  The lock MUST be held coming in here.  This could free the block.
    //
    if (--Reflector->ReferenceCount > 0) {
        LeaveCriticalSection(&Reflector->Lock);
        return;
    }

    //
    // We're done with this block now, so let's delete it.
    //
    RlDavDbgPrint(("%ld: Finalizing the Reflector BLock: %08lx.\n",
                   GetCurrentThreadId(), Reflector));

    LeaveCriticalSection(&Reflector->Lock);
    DeleteCriticalSection(&Reflector->Lock);

    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(Reflector->DeviceHandle);
        Reflector->DeviceHandle = INVALID_HANDLE_VALUE;
    }

    //
    // The work item list at this point really should be empty. If it isn't,
    // we're hosed as we've closed the device and shutdown all threads.
    //
    ASSERT(IsListEmpty(&Reflector->WorkItemList));

    //
    // Free up the AvailableList since this instance is now history.
    //
    while (!IsListEmpty(&Reflector->AvailableList)) {
        listEntry = RemoveHeadList(&Reflector->AvailableList);
        workItem = CONTAINING_RECORD(listEntry,
                                     UMRX_USERMODE_WORKITEM_ADDON,
                                     ListEntry);
        workItem->WorkItemState = WorkItemStateFree;
        LocalFree(workItem);
    }

    LocalFree(Reflector);

    return;
}


ULONG
UMReflectorUnregister (
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    Unregister us with the kernel driver and free all resources.

Arguments:

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UMRxDeviceName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              UMRdrHandle;
    ULONG               rc = ERROR_SUCCESS;

    if (Reflector == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    Reflector->Closing = TRUE;

    // rc = UMReflectorReleaseThreads(Reflector);

    EnterCriticalSection(&Reflector->Lock);

    //
    // If we don't have any worker threads active, delete this guy now.
    //
    DereferenceReflectorBlock(Reflector);

    return rc;
}


ULONG
ReflectorSendSimpleFsControl(
    PUMRX_USERMODE_REFLECT_BLOCK Reflector,
    ULONG IoctlCode
    )
/*++

Routine Description:

    This sends an FSCTL to the device object associated with the Reflector 
    block.

Arguments:

    Relector - The datastructure associated which was returned to the usermode
               process at initialization time.
               
    IoctlCode - The FsCtl code for the operation.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG rc;
    IO_STATUS_BLOCK IoStatusBlock;

    if (Reflector == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    //
    // Send the FSCTL to the Mini-Redir.
    //
    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        rc = NtFsControlFile(Reflector->DeviceHandle,
                             0,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             IoctlCode,
                             NULL,
                             0,
                             NULL,
                             0);
    } else {
        rc = ERROR_OPEN_FAILED;
    }

    return rc;
}


ULONG
UMReflectorStart(
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    This routine sends an FSCTL to start the Mini-Redir. Before we send the 
    Fsctl, we find out the path to the WinInet cache on the local machine. We
    then send this down to the kernel via the Fsctl. The Dav MiniRedir stores
    the value of this path in a global variable and uses it to answer any volume
    information queries.

Arguments:

    ReflectorVersion - The reflector's version.

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_DATA DavUserModeData = NULL;
    PFN_GETWININET_CACHE_PATH pfnSHGetSpecialFolderPath;
    HMODULE hShell32 = NULL;
    BOOL ReturnVal;
    IO_STATUS_BLOCK IoStatusBlock;
    
    if (ReflectorVersion != UMREFLECTOR_CURRENT_VERSION) {
        //
        // Whoops. Mismatch here. We should support backward levels but right
        // now there aren't any so we just bail.
        //
        return ERROR_NOT_SUPPORTED;
    }

    if (Reflector == NULL) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart. Reflector == NULL\n",
                       GetCurrentThreadId()));
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavUserModeData = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), sizeof(DAV_USERMODE_DATA));
    if (DavUserModeData == NULL) {
        WStatus = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/LocalAlloc. WStatus = %d\n",
                       GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Get the Path of the WinInet cache. To do this we need to load shell32.dll,
    // get the address of the function SHGetSpecialFolderPath and call it with
    // CSIDL_INTERNET_CACHE.
    //

    //
    // Store the Pid of the process.
    //
    DavUserModeData->ProcessId = GetCurrentProcessId();
    
    hShell32 = LoadLibraryW(L"shell32.dll");
    if (hShell32 == NULL) {
        WStatus = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/LoadLibrary:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    pfnSHGetSpecialFolderPath = (PFN_GETWININET_CACHE_PATH) 
                                        GetProcAddress(hShell32, 
                                                       "SHGetSpecialFolderPathW");
    if (pfnSHGetSpecialFolderPath == NULL) {
        WStatus = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/GetProcAddress:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    ReturnVal = pfnSHGetSpecialFolderPath(NULL,
                                          (LPWSTR)DavUserModeData->WinInetCachePath,
                                          CSIDL_INTERNET_CACHE,
                                          FALSE);
    if (!ReturnVal) {
        WStatus = ERROR_INVALID_PARAMETER;
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/pfnSHGetSpecialFolderPath:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // Now issue an FSCTL down to the MiniRedir.
    //
    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        WStatus = NtFsControlFile(Reflector->DeviceHandle,
                                  0,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_UMRX_START,
                                  DavUserModeData,
                                  sizeof(DAV_USERMODE_DATA),
                                  NULL,
                                  0);
        if (WStatus != ERROR_SUCCESS) {
            RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/NtFsControlFile:"
                           " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
            goto EXIT_THE_FUNCTION;
        }
    } else {
        WStatus = ERROR_OPEN_FAILED;
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart. DeviceHandle == INVALID_HANDLE_VALUE\n",
                       GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (DavUserModeData) {
        LocalFree(DavUserModeData);
    }

    return WStatus;
}


ULONG
UMReflectorStop(
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    This routine sends an FSCTL to stop the Mini-Redir.

Arguments:

    ReflectorVersion - The reflector's version.

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    return ReflectorSendSimpleFsControl(Reflector, FSCTL_UMRX_STOP);
}


ULONG
UMReflectorReleaseThreads (
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    If any user mode threads are waiting for requests, they'll return
    immediately.

Arguments:

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    OVERLAPPED OverLapped;
    BOOL SuccessfulOperation;
    ULONG rc = ERROR_SUCCESS;

    if (Reflector == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        RtlZeroMemory(&OverLapped, sizeof(OverLapped));
        SuccessfulOperation = DeviceIoControl(Reflector->DeviceHandle,
                                              IOCTL_UMRX_RELEASE_THREADS,
                                              NULL,
                                              0,
                                              NULL,
                                              0,
                                              NULL,
                                              &OverLapped);
        if (!SuccessfulOperation) {
            rc = GetLastError();
        }
    }

    return rc;
}


ULONG
UMReflectorOpenWorker(
    IN PUMRX_USERMODE_REFLECT_BLOCK Reflector,
    OUT PUMRX_USERMODE_WORKER_INSTANCE *WorkerHandle
    )
/*++

Routine Description:

    This allocates a "per worker thread" structure for the app so that it can
    have multiple IOCTLs pending down into kernel on different threads.  If
    we just open them up asynchronous, then we don't use the fast path.  If
    we open them up synchronous and use the same handle, then only one thread
    gets past the I/O manager at any given time.

Arguments:

    Reflector - The reflector block allocated for the Mini-Redir. 
    
    WorkerHandle - The worker handle that is created and returned.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG rc = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKER_INSTANCE worker;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DeviceObjectName;

    worker = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                        sizeof(UMRX_USERMODE_WORKER_INSTANCE));

    *WorkerHandle = worker;

    if (worker == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto errorExit;
    }

    worker->ReflectorInstance = Reflector;

    EnterCriticalSection( &(Reflector->Lock) );
    
    RtlInitUnicodeString(&DeviceObjectName, Reflector->DriverDeviceName);
    
    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    rc = NtOpenFile(&worker->ReflectorHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    FILE_SHARE_VALID_FLAGS,
                    FILE_SYNCHRONOUS_IO_ALERT);
    if (rc != STATUS_SUCCESS) {
        LeaveCriticalSection(&Reflector->Lock);
        rc = RtlNtStatusToDosError(rc);
        goto errorExit;
    }

    //
    // Now we just add it to the list and we're done.
    //
    Reflector->ReferenceCount++;
    InsertTailList(&Reflector->WorkerList, &worker->WorkerListEntry);

    LeaveCriticalSection( &(Reflector->Lock) );

errorExit:

    if (rc != STATUS_SUCCESS) {
        //
        // Things failed here. Let's clean up.
        //
        if (worker != NULL) {
            LocalFree(worker);
        }
        *WorkerHandle = NULL;
    }
    
    return rc;
}


VOID
UMReflectorCloseWorker(
    PUMRX_USERMODE_WORKER_INSTANCE Worker
    )
/*++

Routine Description:

    This routine finalizes a worker structure.

Arguments:

    Worker - The worker structure for this thread.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    EnterCriticalSection( &(Worker->ReflectorInstance->Lock) );

    if (Worker->ReflectorHandle != INVALID_HANDLE_VALUE) {
        NtClose( Worker->ReflectorHandle );
        Worker->ReflectorHandle = INVALID_HANDLE_VALUE;
    }

    RemoveEntryList(&Worker->WorkerListEntry);

    DereferenceReflectorBlock(Worker->ReflectorInstance);

    LocalFree(Worker);

    return;
}


VOID
UMReflectorCompleteRequest(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    )
/*++

Routine Description:

    This routine completes an async request being handled by an async queue 
    thread. These threads should not be confused with the worker threads that
    are spun by the DAV user mode process to reflect requests. This will just
    send a response down and come back.

Arguments:

    ReflectorHandle - Address of the Reflector block strucutre for this process.
    
    WorkItemHeader - The user mode work item header.

Return Value:

    none.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle = NULL;

    //
    // Get a worker instance for this thread.
    //
    WStatus = UMReflectorOpenWorker(ReflectorHandle, &WorkerHandle);
    if (WStatus != ERROR_SUCCESS || WorkerHandle == NULL) {
        if (WStatus == ERROR_SUCCESS) {
            WStatus = ERROR_INTERNAL_ERROR;
        }
        RlDavDbgPrint(("%ld: ERROR: UMReflectorCompleteRequest/UMReflectorOpenWorker:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Send the response.
    //
    WStatus = UMReflectorSendResponse(WorkerHandle, WorkItemHeader);
    if (WStatus != ERROR_SUCCESS) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorCompleteRequest/UMReflectorSendResponse:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
    }

    //
    // If the request got cancelled in the kernelmode and we need to do some
    // cleanup, then the callWorkItemCleanup flag will be set to TRUE by the
    // Precomplete routine in the kernel. If it is TRUE then we call the cleanup
    // routine.
    //
    if (WorkItemHeader->callWorkItemCleanup) {
        DavCleanupWorkItem(WorkItemHeader);
    }

    //
    // Complete the work item.
    //
    WStatus = UMReflectorCompleteWorkItem(WorkerHandle, WorkItemHeader);
    if (WStatus != ERROR_SUCCESS) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorCompleteRequest/UMReflectorCompleteWorkItem:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
    }

EXIT_THE_FUNCTION:

    //
    // Free the worker instance now, since our job is done.
    //
    if (WorkerHandle) {  
        UMReflectorCloseWorker(WorkerHandle);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\davrpc_client.c ===
#include <davrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\workitem.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    workitem.c

Abstract:

    This code handles allocating and freeing work items for the user mode
    reflector library.  This implements UMReflectorAllocateWorkItem and
    UMReflectorCompleteWorkItem.

Author:

    Andy Herron (andyhe) 19-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


PUMRX_USERMODE_WORKITEM_HEADER
UMReflectorAllocateWorkItem (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    ULONG AdditionalBytes
    )
/*++

Routine Description:

    Allocate a new work item or pull one out of the Available list and return.

Arguments:

    Handle - The reflector's handle.

    AdditionalBytes - Number of extra bytes.

Return Value:

    The return status for the operation

--*/
{
    PUMRX_USERMODE_REFLECT_BLOCK reflector;
    ULONG rc;
    PLIST_ENTRY listEntry;
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG entrySize;
    PUMRX_USERMODE_WORKITEM_HEADER workItemHeader = NULL;

    if (WorkerHandle == NULL) {
        return NULL;
    }

    reflector = WorkerHandle->ReflectorInstance;

    EnterCriticalSection(&reflector->Lock);

    if (reflector->Closing) {
        LeaveCriticalSection(&reflector->Lock);
        return NULL;
    }

    entrySize = sizeof(UMRX_USERMODE_WORKITEM_ADDON) + AdditionalBytes;

    //
    // Check the AvailableList for one thats big enough and free.
    //
    if (reflector->NumberAvailable) {
        listEntry = reflector->AvailableList.Flink;
        while ((listEntry != &reflector->AvailableList) &&
               (workItem == NULL)) {
            workItem = CONTAINING_RECORD(listEntry,
                                         UMRX_USERMODE_WORKITEM_ADDON,
                                         ListEntry);
            if (workItem->EntrySize < entrySize) {
                workItem = NULL;
            }
            listEntry = listEntry->Flink;
        }
        if (workItem != NULL) {
            //
            // Reuse it by taking it off the free list.
            //
            reflector->NumberAvailable--;
            RemoveEntryList( &workItem->ListEntry );
            entrySize = workItem->EntrySize;
        }
    }

    if (workItem == NULL) {
        workItem = LocalAlloc(LMEM_FIXED, entrySize);
        if (workItem == NULL) {
            LeaveCriticalSection(&reflector->Lock);
            return NULL;
        }
    }

    //
    // Reset everything back to known.
    //
    RtlZeroMemory(workItem, entrySize);
    workItem->EntrySize = entrySize;
    workItem->ReflectorInstance = reflector;
    workItem->WorkItemState = WorkItemStateNotYetSentToKernel;
    InsertHeadList(&reflector->WorkItemList, &workItem->ListEntry);

    workItemHeader = &workItem->Header;
    workItemHeader->WorkItemLength = sizeof(UMRX_USERMODE_WORKITEM_HEADER) +
                                     AdditionalBytes;

    LeaveCriticalSection(&reflector->Lock);

    return workItemHeader;
}


ULONG
UMReflectorCompleteWorkItem (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem
    )
/*++

Routine Description:

    Complete a WorkItem that has come back from the kernel.

Arguments:

    WorkerHandle - The worker thread's handle.

    IncomingWorkItem - The workitem to be completed.

Return Value:

    The return status for the operation

--*/
{
    PUMRX_USERMODE_REFLECT_BLOCK reflector;
    ULONG rc;
    PLIST_ENTRY listEntry;
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG entrySize;

    if (WorkerHandle == NULL || IncomingWorkItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    reflector = WorkerHandle->ReflectorInstance;

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR)IncomingWorkItem -
                           FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState != WorkItemStateFree);
    ASSERT(workItem->WorkItemState != WorkItemStateAvailable);

    EnterCriticalSection(&reflector->Lock);

    RemoveEntryList(&workItem->ListEntry);

    if (!reflector->Closing && (reflector->CacheLimit > 0)) {

        workItem->WorkItemState = WorkItemStateAvailable;
        InsertHeadList(&reflector->AvailableList, &workItem->ListEntry);
        reflector->NumberAvailable++;

        //
        // If we already have too many cached, then we free up an old one and 
        // put this one on the free list. We do this so that if the app changes
        // the size of the blocks then it will not get stuck with a cache full
        // of ones that are too small.
        //
        if (reflector->NumberAvailable >= reflector->CacheLimit) {

            reflector->NumberAvailable--;

            //
            // We remove from the tail because we just put the new one onto
            // the head. No use freeing the same one we're trying to put on.
            //
            listEntry = RemoveTailList(&reflector->AvailableList);

            workItem = CONTAINING_RECORD(listEntry,
                                         UMRX_USERMODE_WORKITEM_ADDON,
                                         ListEntry);
        } else {
            workItem = NULL;
        }
    }

    if (workItem != NULL) {
        workItem->WorkItemState = WorkItemStateFree;
        LocalFree( workItem );
    }

    LeaveCriticalSection( &reflector->Lock );
    
    return STATUS_SUCCESS;
}

// workitem.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\makefile.inc ===
#
# These are common to all sources files in this project.
# (Each sources file includes this file.)
#

C_DEFINES=-DWIN32 -DUNICODE -D_UNICODE
MSC_WARNING_LEVEL=/W3 /WX
RCOPTIONS=-N
UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\debug.h ===
/*++

Copyright (c) 1994-7  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:


--*/

extern WCHAR DavClientDisplayName[MAX_PATH];

#if DBG

extern ULONG DavClientDebugFlag;

//
// The Debug flags.
//
#define DEBUG_DEBUG             0x00000001  // General debugging.
#define DEBUG_ERRORS            0x00000002  // Hard error.
#define DEBUG_MISC              0x00000004  // Misc info.
#define DEBUG_ENTRY             0x00000008  // Function entry.
#define DEBUG_EXIT              0x00000010  // Function exit.

#define IF_DEBUG(flag) if (DavClientDebugFlag & (DEBUG_ ## flag))

#define IF_DEBUG_PRINT(flag, args) {     \
        if (DavClientDebugFlag & flag) { \
            DbgPrint args;               \
        }                                \
}

#else

#define IF_DEBUG(flag) if (0)

#define IF_DEBUG_PRINT(flag, args)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\global.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.h

Abstract:

    This file contains globals and prototypes for user mode webdav client.

Author:

    Andy Herron (andyhe)  30-Mar-1999

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DAVGLOBAL_H
#define _DAVGLOBAL_H

#pragma once

#include <debug.h>
#include <davrpc.h>
#include <winsock2.h>
#include <align.h>
#include <winbasep.h>
#include <icanon.h>

#define DAV_PATH_SEPARATOR L'\\'

#define DAV_DUMMY_SHARE L"DavWWWRoot"

#define RESOURCE_SHAREABLE      0x00000006

typedef enum _DAV_REMOTENAME_TYPE {
    DAV_REMOTENAME_TYPE_INVALID = 0,
    DAV_REMOTENAME_TYPE_WORKGROUP,
    DAV_REMOTENAME_TYPE_DFS,
    DAV_REMOTENAME_TYPE_SERVER,
    DAV_REMOTENAME_TYPE_SHARE,
    DAV_REMOTENAME_TYPE_PATH
} DAV_REMOTENAME_TYPE, *PDAV_REMOTENAME_TYPE;

typedef enum _DAV_ENUMNODE_TYPE {
    DAV_ENUMNODE_TYPE_USE = 0,
    DAV_ENUMNODE_TYPE_CONTEXT,
    DAV_ENUMNODE_TYPE_SHARE,
    DAV_ENUMNODE_TYPE_SERVER,
    DAV_ENUMNODE_TYPE_DOMAIN,
    DAV_ENUMNODE_TYPE_EMPTY
} DAV_ENUMNODE_TYPE;

typedef struct _DAV_ENUMNODE {
    
    DAV_ENUMNODE_TYPE DavEnumNodeType;
    
    DWORD dwScope;
    
    DWORD dwType;
    
    DWORD dwUsage;
    
    //
    // Are we done returning all the requested entries. If we are this is set
    // to TRUE, so that on the next call, we can return WN_NO_MORE_ENTRIES.
    //
    BOOL Done;

    //
    // Start with the entry at this index. This means that the entries of 
    // lower indices have already been sent to the caller previously.
    //
    DWORD Index;
    
    LPNETRESOURCE lpNetResource;

} DAV_ENUMNODE, *PDAV_ENUMNODE;

#endif // DAVGLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\dllmain.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

Revision History:

--*/

#include "pch.h"
#pragma hdrstop
#include <debug.h>

CRITICAL_SECTION g_csLock;

HINSTANCE g_hinst;

#if DBG
ULONG DavClientDebugFlag = 0;
#define DAVNP_PARAMETERS_KEY L"System\\CurrentControlSet\\Services\\WebClient\\Parameters"
#define DAVNP_DEBUG_KEY L"ClientDebug"
#endif

extern LONG g_cRefCount;

#define DAV_NETWORK_PROVIDER L"SYSTEM\\CurrentControlSet\\Services\\WebClient\\NetworkProvider"
#define DAV_NETWORK_PROVIDER_NAME L"Name"

WCHAR DavClientDisplayName[MAX_PATH];

BOOL
WINAPI
DllMain (
    HINSTANCE hinst,
    DWORD dwReason,
    LPVOID pvReserved
    )
/*++

Routine Description:

    The DllMain routine for the davclnt.dll. DllMain should do as little work 
    as possible.

Arguments:

    hinst - Instance handle of the DLL.
    
    dwReason - The reason for this function to be called by the system.
    
    pvReserved - Indicated whether the DLL was implicitly or explicitly loaded.

Return Value:

    TRUE.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    HKEY KeyHandle = NULL;
    ULONG ValueType = 0, ValueSize = 0;

    if (DLL_PROCESS_ATTACH == dwReason) {

        //
        // DisableThreadLibraryCalls tells the loader we don't need to
        // be informed of DLL_THREAD_ATTACH and DLL_THREAD_DETACH events.
        //
        DisableThreadLibraryCalls (hinst);

        //
        // Syncrhonization support --
        // Unless you have *measured* lock contention, you should only need
        // one lock for the entire DLL.  (and maybe you don't even need one.)
        //
        try {
            InitializeCriticalSection ( &(g_csLock) );
        } except(EXCEPTION_EXECUTE_HANDLER) {
              ULONG WStatus = GetExceptionCode();
        }

        // Save our instance handle in a global variable to be used
        // when loading resources etc.
        //
        g_hinst = hinst;
        g_cRefCount = 0;

        //
        // Read the DAV Network Provider Name out of the registry.
        //
        DavClientDisplayName[0] = L'\0';
        
        WStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                DAV_NETWORK_PROVIDER,
                                0,
                                KEY_QUERY_VALUE,
                                &(KeyHandle));
        
        if (WStatus == ERROR_SUCCESS) {

            ValueSize = sizeof(DavClientDisplayName);

            WStatus = RegQueryValueExW(KeyHandle,
                                       DAV_NETWORK_PROVIDER_NAME,
                                       0,
                                       &(ValueType),
                                       (LPBYTE)&(DavClientDisplayName),
                                       &(ValueSize));
            RegCloseKey(KeyHandle);
        
        } else {

            DavClientDisplayName[0] = L'\0';

        }

#if DBG

        //
        // Read DebugFlags value from the registry. If the entry exists, the global
        // filter "DavClientDebugFlag" is set to this value. This value is used in
        // filtering the debug messages.
        //
        WStatus = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                DAVNP_PARAMETERS_KEY,
                                0,
                                KEY_QUERY_VALUE,
                                &(KeyHandle));
        
        if (WStatus == ERROR_SUCCESS) {

            ValueSize = sizeof(DavClientDebugFlag);

            WStatus = RegQueryValueExW(KeyHandle,
                                       DAVNP_DEBUG_KEY,
                                       0,
                                       &(ValueType),
                                       (LPBYTE)&(DavClientDebugFlag),
                                       &(ValueSize));
            RegCloseKey(KeyHandle);
        
        }

#endif
        
    } else if (DLL_PROCESS_DETACH == dwReason) {
        DeleteCriticalSection (&g_csLock);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\dllmain2.cpp ===
#include <windows.h>
#include <olectl.h>
#include <advpub.h>     // REGINSTALL

#include "volclean.h"

/*
**------------------------------------------------------------------------------
** Global variables
**------------------------------------------------------------------------------
*/
extern "C" {
LONG g_cRefCount = 0;
}

typedef HRESULT (WINAPI *PFNCREATEINSTANCE)(REFIID, void **);

/*
**------------------------------------------------------------------------------
** DllCanUnloadNow
**
** Purpose:       Answers if the DLL can be free, that is, if there are no
**                references to anything this DLL provides.
** Return:        TRUE, if OK to unload (i.e. nobody is using us or has us locked)
**                FALSE, otherwise
** Notes;
**------------------------------------------------------------------------------
*/
STDAPI DllCanUnloadNow(void) 
{
    //  
    // Are there any outstanding references?
    //
    return (g_cRefCount == 0 ? S_OK : S_FALSE);
}


STDAPI_(void) DllAddRef(void) 
{
    InterlockedIncrement(&g_cRefCount);
}


STDAPI_(void) DllRelease(void) 
{
    InterlockedDecrement(&g_cRefCount);
}


class CWebDavCleanerClassFactory : IClassFactory
{
    LONG m_cRef;
    PFNCREATEINSTANCE m_pfnCreateInstance;

public:
    CWebDavCleanerClassFactory(PFNCREATEINSTANCE pfnCreate) 
        : m_cRef(1), 
          m_pfnCreateInstance(pfnCreate) 
    {
        Trace(L"CWebDavCleanerClassFactory::CWebDavCleanerClassFactory");
        DllAddRef();
    }

    ~CWebDavCleanerClassFactory() 
    {
        Trace(L"CWebDavCleanerClassFactory::~CWebDavCleanerClassFactory");
        DllRelease();
    }

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


/*
**------------------------------------------------------------------------------
** DllGetClassObject
**
** Purpose:    Provides an IClassFactory for a given CLSID that this DLL is
**             registered to support.  This DLL is placed under the CLSID
**             in the registration database as the InProcServer.
** Parameters:
**  clsID   -  REFCLSID that identifies the class factory desired.
**             Since this parameter is passed this DLL can handle
**             any number of objects simply by returning different
**             different class factories here for different CLSIDs.
**  riid    -  REFIID specifying the interface the caller wants
**             on the class object, usually IID_ClassFactory.
**  ppvOut  -  pointer in which to return the interface pointer.
** Return:     NOERROR on success, otherwise an error code
** Notes;
**------------------------------------------------------------------------------
*/
STDAPI DllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    OUT void **ppv
    )
{
    HRESULT hr = E_FAIL;
    PFNCREATEINSTANCE pfnCreateInstance = NULL;
    Trace(L"DllGetClassObject");

    *ppv = NULL;

    //
    // Is the request for our cleaner object?
    //
    if (IsEqualCLSID(rclsid, CLSID_WebDavVolumeCleaner)) {
        pfnCreateInstance = CWebDavCleaner::CreateInstance;
    }
    else {
        //
        // Error - we don't know about this object
        //
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // 
    // Get our IClassFactory for making CWebDavCleaner objects
    //
    CWebDavCleanerClassFactory *pClassFactory = new CWebDavCleanerClassFactory(pfnCreateInstance);
    if (pClassFactory) {
        //
        // Make sure the new class factory likes the requested interface
        //
        hr = pClassFactory->QueryInterface(riid, ppv);
        if (FAILED(hr)) {
            // 
            // Error - interface rejected
            //
            delete pClassFactory;
        }
        else {
            //
            // Release initial ref
            //
            pClassFactory->Release();
        }
    }
    else {
          //
          // Error - couldn't make factory object
          //
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP 
CWebDavCleanerClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    Trace(L"CWebDavCleanerClassFactory::QueryInterface");
    if (!ppv) {
        return E_POINTER;
    }

    if (riid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    }
    else  {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;

}


STDMETHODIMP_(ULONG) 
CWebDavCleanerClassFactory::AddRef()
{
    Trace(L"CWebDavCleanerClassFactory::AddRef");
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) 
CWebDavCleanerClassFactory::Release()
{
    Trace(L"CWebDavCleanerClassFactory::Release");
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}


STDMETHODIMP 
CWebDavCleanerClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_UNEXPECTED;
    Trace(L"CWebDavCleanerClassFactory::CreateInstance");

    *ppv = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if (m_pfnCreateInstance)
        hr = m_pfnCreateInstance(riid, ppv);

    return hr;
}


STDMETHODIMP 
CWebDavCleanerClassFactory::LockServer(BOOL fLock)
{
    Trace(L"CWebDavCleanerClassFactory::LockServer");
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\test\davtest.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apitest.c

Abstract:

    Program to test DAV

Author:

    Shishir Pardikar (shishirp) 4-24-97

Environment:

    User Mode - Win32

Revision History:

--*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <wininet.h>
#include <winnetwk.h>

//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
//=================================================================================

// The order of these must match the order in GlobalCommandInfo[]
typedef enum _COMMAND_CODE {
    CmdDAVGetProp,
    CmdDAVSetProp,
    CmdDAVEnumServer,
    CmdGetSpace,
    CmdFreeSpace,
    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPSTR CommandName;
    LPSTR CommandParams;
    COMMAND_CODE CommandCode;
} COMMAND_INFO, *LPCOMMAND_INFO;

DWORD
ProcessDAVSetProp(
    DWORD    argc,
    LPSTR   *argv
    );

DWORD
ProcessDAVGetProp(
    DWORD    argc,
    LPSTR   *argv
    );

DWORD
ProcessDAVEnumServer(
    DWORD   argc,
    LPSTR   *argv
    );


DWORD
ProcessDAVGetSpace(
    DWORD   argc,
    LPSTR   *argv
    );
    
DWORD
ProcessDAVFreeSpace(
    DWORD   argc,
    LPSTR   *argv
    );

DWORD
APIENTRY
DavFreeUsedDiskSpace(
    DWORD   dwPercent
    );


DWORD
APIENTRY
DavGetDiskSpaceUsage(
    LPWSTR      lptzLocation,
    DWORD       *lpdwSize,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    );
//=================================================================================
FILE *UncList = NULL;
LPSTR g_lpWriteFileBuf = NULL;
FILE *DumpUncList = NULL;
DWORD cCommands = 0;
DWORD cFails = 0;
DWORD g_dwNumIterations = 1;
DWORD g_dwIteration = 0;
DWORD g_dwNumCmdIterations = 1;
DWORD g_dwCmdIteration = 0;
DWORD g_dwFileSize = 0;
DWORD g_dwDiskCache = 0;
BOOL g_bWriteFile = FALSE;
BOOL g_bQuietMode = FALSE;
BOOL g_bPerfMode = FALSE;
BOOL g_bUseFile = FALSE;

COMMAND_INFO GlobalCommandInfo[] = {
    {"GetProp",        "Server",                        CmdDAVGetProp},
    {"SetProp",        "Server Property Value",         CmdDAVSetProp},
    {"Enum",            "Enumerate shares",             CmdDAVEnumServer},
    {"GetSpace",        "Get Used Disk Space",          CmdGetSpace},
    {"FreeSpace",       "FreeSpace <percent of cache in decimal>",         CmdFreeSpace},
    {"Help",        "",                                 CmdHelp},
    {"Quit",         "",                                CmdQuit}
};

char szTestBuff[] = "00000888";
char szDavProviderName[] = "Web Client Network";

DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...);
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz);
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);

//=================================================================================

DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    );


DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    );


char rgXmlHeader[] = "Content-Type: text/xml; charset=\"utf-8\"";
char rgXmlData[] = 
//"<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r <D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"http://www.w3.com\"> \r <D:set><D:prop><Z:Win32FileAttributes>3</Z:Win32FileAttributes></D:prop></D:set></D:propertyupdate>";
"<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r <D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"http://www.w3.com\"> \r <D:set><D:prop><Z:Win32lastModifiedTime> 1000 2000 </Z:Win32lastModifiedTime></D:prop></D:set></D:propertyupdate>";
char rgXmlDataHeader[] = "<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r <D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"http://www.w3.com\"> \r <D:set><D:prop>";
char rgXmlDataTrailer[] = "</D:prop></D:set></D:propertyupdate>";
char rgLastModifiedTimeTagHeader[] = "<Z:Win32lastModifiedTime>";
char rgLastModifiedTimeTagTrailer[] = "</Z:Win32lastModifiedTime>";

char Buffer[4096];


//=================================================================================
#if DBG

#define TestDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TestDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
TestDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else

#define TestDbgAssert(_x_)

#endif // DBG

//=================================================================================
VOID
ParseArguments(
    LPSTR InBuffer,
    LPSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

#ifdef MAYBE
//=================================================================================
LPSTR
GetUncFromFile ()
{
    if (!UncList)
    {
        UncList = fopen ("Unclist", "r");
        if (UncList == NULL)
            return NULL;
    }
    if (fgets( UncBuffer, DEFAULT_BUFFER_SIZE, UncList))
    {
        UncBuffer[strlen(UncBuffer) -1] = '\0';  //kill line feed for no param cmds
        return UncBuffer;
    }
    else
    {
        fclose (UncList);
        UncList = NULL;
        return GetUncFromFile();
    }
}

#endif
//=================================================================================
COMMAND_CODE
DecodeCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if(( lstrcmpi( CommandName, GlobalCommandInfo[i].CommandName ) == 0 )){
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

//=================================================================================
VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        fprintf(stderr, "    %s (%s)\n",
            GlobalCommandInfo[i].CommandName,
            GlobalCommandInfo[i].CommandParams );
    }
}

//=================================================================================
VOID
DisplayUsage(
    VOID
    )
{
    DWORD dwTemp;
    char InBuffer[    DEFAULT_BUFFER_SIZE];

    memset(    InBuffer, 0, sizeof(InBuffer));
    if (dwTemp = GetEnvironmentVariable("USERPROFILE", InBuffer, DEFAULT_BUFFER_SIZE))
    {
        fprintf(stderr, "Got var %x\n", dwTemp );
        fprintf(stderr, "%S\n", InBuffer );
    }
    else
    {
        fprintf(stderr, "No var\n" );
        fprintf(stderr, "Error %x\n", GetLastError());
    }
    
    fprintf(stderr, "Usage: command <command parameters>\n" );
    
    sscanf(szTestBuff, "%x", &dwTemp);
    fprintf(stderr, "%x \n", dwTemp);

    fprintf(stderr, "Commands : \n");

        
    PrintCommands();

    return;
}

//=================================================================================
FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}

//=================================================================================

//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;

        switch( CommandCode ) {
            case CmdDAVGetProp:
                Error = ProcessDAVGetProp(CommandArgc, CommandArgv);
                break;
            case CmdDAVSetProp:
                Error = ProcessDAVSetProp(CommandArgc, CommandArgv);
                break;
            case CmdDAVEnumServer:
                Error = ProcessDAVEnumServer(CommandArgc, CommandArgv);
            case CmdGetSpace:
                Error = ProcessDAVGetSpace(CommandArgc, CommandArgv);
                break;
            case CmdFreeSpace:
                Error = ProcessDAVFreeSpace(CommandArgc, CommandArgv);
                break;
            case CmdHelp:
                DisplayUsage();
            break;
            case CmdQuit :
                exit (0);

        default:
            TestDbgAssert( FALSE );
            fprintf(stderr, "Unknown Command Specified.\n");
            DisplayUsage();
            break;
        }
        cCommands++;

        if( Error != ERROR_SUCCESS ) {
            LPSTR lpstr;

            cFails++;
            Format_Error(Error, &lpstr);
            printf("FAILED (%s), %ld-%s.\n",
                GlobalCommandInfo[CommandCode].CommandName, Error, lpstr );
            LocalFree(lpstr);
        }
        else {
            if(!g_bQuietMode)
                printf("Command (%s) successfully completed.\n", GlobalCommandInfo[CommandCode].CommandName );
        }
        return Error;
}


//=================================================================================
VOID
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    DWORD Error;
    COMMAND_CODE CommandCode;
    CHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPSTR CArgv[MAX_COMMAND_ARGS];
    unsigned u1 = 1, u2 = 0xffffffff;

    DWORD CommandArgc;
    LPSTR *CommandArgv;



    /* must check for batch mode.  if there are command line parms, assume batch mode */
    if (argc > 1)
    {
        //this means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            printf("Unknown Command Specified.\n");
            return;
        }

        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

        if (DumpUncList)
            fclose(DumpUncList);
        if (UncList)
            fclose(UncList);

        return;
    }

    DisplayUsage();

    for(;;) {

        fprintf(stderr,  "Command : " );

        gets( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            fprintf(stderr, "Unknown Command Specified.\n");
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }

    return;
}

//=================================================================================
DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    )
{
    DWORD len;
    LPSTR   lpT;

    if(!lpszPath)
        return(0);

    len = lstrlen(lpszPath);

    if (len == 0) {

        return (len);

    }

    lpT = lpszPath+len-1;
    if (*lpT =='\\') {
        --lpT;
    }
    for (; lpT >= lpszPath; --lpT) {
        if (*lpT == '\\') {
            break;
        }
    }
    return (lstrlen(lpT));
}

//=================================================================================
DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...)
{
    const char c_Func_Name[] = "[Format_String] ";
    DWORD dwRet;
    va_list vArgs;

    va_start (vArgs, lpszFmt);
    dwRet = Format_StringV(plpsz, lpszFmt, &vArgs);
    va_end (vArgs);

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz)
{
    DWORD dwRet;

    if(dwErr != ERROR_SUCCESS)
    {
        dwRet = Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            dwErr, plpsz, NULL, NULL);
    }
    else
    {
        const char szMsg[] = "No Error";
        Format_String(plpsz, (LPSTR)szMsg);
        dwRet = lstrlen(szMsg);
    }

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    return(Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        0, plpsz, lpszFmt, vArgs));
}

// ***************************************************************************
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    const char c_Func_Name[] = "[Format_MessageV]";

    DWORD dwRet;
    DWORD dwGLE;

    *plpsz = NULL;
    dwRet = FormatMessage(dwFlags, lpszFmt, dwErr, 0, (LPSTR) plpsz, 0, vArgs);

    if (!dwRet || !*plpsz)
    {
        dwGLE = GetLastError();
        printf("%s FormatMessage Failed: %s. dwRet: %#lx!. *plpsz:%#lx! GLE:%d\r\n", c_Func_Name, lpszFmt, dwRet, *plpsz, dwGLE);

        if (*plpsz)
            LocalFree ((HLOCAL) *plpsz);
        *plpsz = NULL;
        return 0;
    }

    return(dwRet);
}



DWORD
ProcessDAVGetProp(
    DWORD   argc,
    LPSTR   *argv
    )
{
    HINTERNET hDavOpen=NULL, hDavConnect = NULL, hRequest = NULL;
    DWORD   dwError = ERROR_SUCCESS;    
    LPSTR   lpRequestHeader=NULL, lpOptionalData = NULL, lpTemp;    

    if (argc < 2)
    {
        printf("GetProp Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    hDavOpen = InternetOpen("DAVtest",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0);
    if (hDavOpen == NULL) {
        dwError = GetLastError();
        goto bailout;
    }

    hDavConnect = InternetConnect(  hDavOpen,
                                    argv[0],
                                    INTERNET_DEFAULT_HTTP_PORT,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0);
    if (hDavConnect == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }

    hRequest = HttpOpenRequest(hDavConnect,
                                "PROPFIND",
                                argv[1],
                                HTTP_VERSION,
                                NULL,
                                NULL,
                                INTERNET_FLAG_KEEP_CONNECTION |
                                INTERNET_FLAG_RELOAD          |
                                INTERNET_FLAG_NO_AUTO_REDIRECT,
                                0);
    if (hRequest == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }
    
     if (!HttpSendRequest(hRequest, NULL, 0, NULL, 0))
    {
        dwError = GetLastError();
    }
                
bailout:

    if (hRequest)
    {
        InternetCloseHandle(hRequest);    
    }
    if (hDavConnect)
    {
        InternetCloseHandle(hDavConnect);    
    }
    if (hDavOpen)
    {
        InternetCloseHandle(hDavOpen);    
    }
    
    return dwError;
}

DWORD
ProcessDAVSetProp(
    DWORD   argc,
    LPSTR   *argv
    )
{
    HINTERNET hDavOpen=NULL, hDavConnect = NULL, hRequest = NULL;
    DWORD   dwError = ERROR_SUCCESS, dwLen;    
    LPSTR   lpRequestHeader=NULL, lpOptionalData = NULL, lpTemp;    
    SYSTEMTIME  sSystemTime;
    char sTimeBuff[INTERNET_RFC1123_BUFSIZE+10];    
    
    if (argc < 2)
    {
        printf("SetProp Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    hDavOpen = InternetOpen("DAVtest",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0);
    if (hDavOpen == NULL) {
        dwError = GetLastError();
        goto bailout;
    }

    hDavConnect = InternetConnect(  hDavOpen,
                                    argv[0],
                                    INTERNET_DEFAULT_HTTP_PORT,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0);
    if (hDavConnect == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }

#if 0
    hRequest = HttpOpenRequest(hDavConnect,
                                "PROPFIND",
                                argv[1],
                                HTTP_VERSION,
                                NULL,
                                NULL,
                                INTERNET_FLAG_KEEP_CONNECTION |
                                INTERNET_FLAG_RELOAD          |
                                INTERNET_FLAG_NO_AUTO_REDIRECT,
                                0);
    if (hRequest == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }
    
     if (!HttpSendRequest(hRequest, NULL, 0, NULL, 0))
    {
        dwError = GetLastError();
    }
#endif

    hRequest = HttpOpenRequest(hDavConnect,
                                "PROPPATCH",
                                argv[1],
                                HTTP_VERSION,
                                NULL,
                                NULL,
                                INTERNET_FLAG_KEEP_CONNECTION |
                                INTERNET_FLAG_RELOAD          |
                                INTERNET_FLAG_NO_AUTO_REDIRECT,
                                0);
    if (hRequest == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }

    memset(Buffer, 0, sizeof(Buffer));
    
    lpTemp = Buffer;
    
    strcpy(lpTemp, rgXmlDataHeader);

    lpTemp += (sizeof(rgXmlDataHeader)-1);

    memcpy(lpTemp, rgLastModifiedTimeTagHeader, (sizeof(rgLastModifiedTimeTagHeader)-1));
    
    lpTemp += (sizeof(rgLastModifiedTimeTagHeader)-1);
    
    GetSystemTime(&sSystemTime);

    InternetTimeFromSystemTimeA(&sSystemTime, INTERNET_RFC1123_FORMAT, sTimeBuff, sizeof(sTimeBuff));

    dwLen = strlen(sTimeBuff);
    
    memcpy(lpTemp, sTimeBuff, dwLen);
    
    lpTemp += dwLen;
        
    memcpy(lpTemp, rgLastModifiedTimeTagTrailer, (sizeof(rgLastModifiedTimeTagTrailer)-1));
    
    lpTemp += (sizeof(rgLastModifiedTimeTagTrailer)-1);
    
    strcpy(lpTemp, rgXmlDataTrailer);
        
     if (!HttpSendRequest(hRequest,
                                (LPVOID)rgXmlHeader,
                                strlen(rgXmlHeader),
                                (LPVOID)Buffer,
                                strlen(Buffer)))
    {
        dwError = GetLastError();
    }
                
bailout:

    if (hRequest)
    {
        InternetCloseHandle(hRequest);    
    }
    if (hDavConnect)
    {
        InternetCloseHandle(hDavConnect);    
    }
    if (hDavOpen)
    {
        InternetCloseHandle(hDavOpen);    
    }
    
    return dwError;
}


DWORD
ProcessDAVEnumServer(
    DWORD   argc,
    LPSTR   *argv
    )
{
    HINTERNET hDavOpen=NULL, hDavConnect = NULL, hRequest = NULL;
    DWORD   dwError = ERROR_SUCCESS;    
    LPSTR   lpRequestHeader=NULL, lpOptionalData = NULL, lpTemp;    
    NETRESOURCEA    sRes;
    HANDLE  hEnum = 0;
    char Buffer[4096];
    
        
    if (argc < 1)
    {
        printf("EnumResource Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }

    memset(&sRes, 0, sizeof(sRes));
    sRes.lpRemoteName = argv[0];
    sRes.lpProvider = szDavProviderName;
        
    if(WNetOpenEnumA(RESOURCE_GLOBALNET, RESOURCETYPE_DISK, RESOURCEUSAGE_CONTAINER, &sRes, &hEnum) == NO_ERROR)
    {
        DWORD   dwCount, dwSize;
        dwCount = 1;
        dwSize = sizeof(Buffer);
        while (WNetEnumResourceA(hEnum, &dwCount, Buffer, &dwSize)== NO_ERROR)
        {
            dwCount = 1;
            dwSize = sizeof(Buffer);
            printf("%s \n", ((LPNETRESOURCE)Buffer)->lpRemoteName);
        }
        WNetCloseEnum(hEnum);
    }
    else
    {
        dwError = GetLastError();
    }
    return dwError;
}

DWORD
ProcessDAVGetSpace(
    DWORD   argc,
    LPSTR   *argv
    )
{
    DWORD   dwError = ERROR_SUCCESS;
    ULARGE_INTEGER MaxSpace, UsedSpace;
    WCHAR   tzLocation[MAX_PATH];
    DWORD   dwSize;

    dwSize = sizeof(tzLocation);    
    if ((dwError = DavGetDiskSpaceUsage(tzLocation, &dwSize, &MaxSpace, &UsedSpace)) == ERROR_SUCCESS)
    {
        printf("Location=%ls MaxSpace=%I64d UsedSpace=%I64d\n", tzLocation, MaxSpace, UsedSpace);
    }
    
    return dwError;
}


DWORD
ProcessDAVFreeSpace(
    DWORD   argc,
    LPSTR   *argv
    )
{
    DWORD   dwError = ERROR_SUCCESS, dwPercent;
    
    if (argc < 1)
    {
        printf("FreeSpace Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    if(sscanf(argv[0], "%d", &dwPercent) == 1)
    {
        dwError = DavFreeUsedDiskSpace(dwPercent);
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by volclean.rc
//
#define IDS_DISKCLEAN_DISPLAY           1
#define IDS_DISKCLEAN_DESCRIPTION       2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\version.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    version.h

Abstract:

Revision History:

--*/

#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Web DAV Client DLL"
#define VER_INTERNALNAME_STR            "davclnt.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\midluser.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    
    25-Apr-1991    JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.
    
    03-July-1991   JimK
        Moved to a common directory so services available to more than just
        LM code.
    
    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.

    10-Feb-1993     RitaW
        Copied to the NetWare tree so that the LPC transport can used for
        the local case.

--*/

#include <nt.h>
#include <ntrtl.h>              // needed for nturtl.h
#include <nturtl.h>             // needed for windows.h
#include <windows.h>            // win32 typedefs
#include <rpc.h>                // rpc prototypes

#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <winbase.h>            // LocalAlloc

#include <debug.h>

PVOID
MIDL_user_allocate (
    IN unsigned int NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    LPVOID NewPointer;

    NewPointer = (LPVOID) LocalAlloc(
                              LMEM_ZEROINIT,
                              NumBytes
                              );

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_allocate



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    ASSERT( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    (void) LocalFree((HLOCAL) MemPointer);

} // MIDL_user_free

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN unsigned long NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.


    ASSERT( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = (LPVOID) LocalAlloc(
                                  LMEM_ZEROINIT,
                                  NewByteCount
                                  );

    } else if (NewByteCount == 0) {

        (void) LocalFree((HLOCAL) OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        ASSERT(hOldMem != NULL);

        hNewMem = (PVOID) LocalReAlloc(
                              hOldMem,               // old handle
                              NewByteCount,          // new size in bytes
                              LMEM_ZEROINIT |        // flags
                                  LMEM_MOVEABLE      //  (motion okay)
                              );

        if (hNewMem == NULL) {
            return (NULL);
        }

        NewPointer = (LPVOID) hNewMem;

    } // must be realloc of something to something else

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


ULONG_PTR
MIDL_user_size(
    IN void * Pointer
    )
{
    ULONG_PTR ByteCount;
    HANDLE hMemory;

    ASSERT( Pointer != NULL );
    ASSERT( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    ASSERT( hMemory != NULL );

    ByteCount = LocalSize( hMemory );

    ASSERT( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\provider.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    provider.c

Abstract:

    This module contains WebDav's Network Provider code.  It is the client-side 
    wrapper for APIs supported by the Dav Client service.

Author:

    Rohan Kumar   01-Dec-1999

Revision History:

--*/

#include "pch.h"
#pragma hdrstop

#include <global.h>

#define SECURITY_WIN32
#include <security.h>
#include <wincred.h>
#include <wincred.h>
#include <npapi.h>

//
// Local Function Prototypes.
//

BOOL
DavWorkstationStarted(
    VOID
    );

DWORD
DavMapRpcErrorToProviderError(
    IN DWORD RpcError
    );

DWORD
DavBindTheRpcHandle(
    handle_t *dav_binding_h
    );

DAV_REMOTENAME_TYPE 
DavParseRemoteName (
    IN  LPWSTR  RemoteName,
    OUT LPWSTR  CanonName,
    IN  DWORD   CanonNameSize,
    OUT PULONG  PathStart
    );

BOOL
DavServerExists(
    IN PWCHAR PathName,
    OUT PWCHAR Server
    );

BOOL
DavShareExists(
    PWCHAR PathName
    );

BOOL
DavConnectionExists(
    PWCHAR ConnName
    );

DWORD 
DavDisplayTypeToUsage(
    DWORD dwDisplayType
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_PROMPTFORCREDENTIALS)(
    PCREDUI_INFOW pUiInfo,
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR pszUserName,
    ULONG ulUserNameMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
DWORD
(WINAPI
*PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)(
    PCWSTR pszTargetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserMaxChars,
    PWSTR pszPassword,
    ULONG ulPasswordMaxChars,
    PBOOL pfSave,
    DWORD dwFlags
    );

typedef
void
(WINAPI
*PFN_CREDUI_CONFIRMCREDENTIALS)(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    );

HMODULE
DavInitCredUI(
    PWCHAR RemoteName,
    WCHAR ServerName[CRED_MAX_STRING_LENGTH + 1],
    PFN_CREDUI_CONFIRMCREDENTIALS *pfnCredUIConfirmCredentials,
    PFN_CREDUI_PROMPTFORCREDENTIALS *pfnCredUIPromptForCredentials,
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS *pfnCredUICmdlinePromptForCredentials
    );

ULONG
DavCheckAndConvertHttpUrlToUncName(
    IN PWCHAR RemoteName,
    OUT PWCHAR *UncRemoteName,
    OUT PBOOLEAN MemoryAllocated,
    IN BOOLEAN AddDummyShare,
    OUT PDAV_REMOTENAME_TYPE pRemoteType,
    OUT PULONG pPathStart,
    IN BOOLEAN bCanonicalize
    );

ULONG
DavCheckResourceType(
   IN DWORD dwType
   );

ULONG
DavCheckLocalName(
    IN PWCHAR LocalName
    );

VOID 
DavDisplayNetResource(
    LPNETRESOURCE netRes, 
    LPWSTR dispMesg
    );

VOID 
DavDisplayEnumNode(
    PDAV_ENUMNODE enumNode, 
    LPWSTR dispMesg
    );

VOID
DavDebugBreakPoint(
    VOID
    );

DWORD
DavGetTheLockOwnerOfTheFile(
    IN PWCHAR FileName,
    OUT PWCHAR LockOwnerName,
    IN OUT PULONG LockOwnerNameLengthInBytes
    );

//
// Implementation of functions begins here.
//

DWORD
APIENTRY
NPGetCaps(
    IN DWORD QueryVal
    )
/*++

Routine Description:

    This function returns the functionality supported by the DAV network
    provider.

Arguments:

    QueryVal - Supplies a value which determines the type of information
               queried regarding the network provider's support in this area.

Return Value:

    Returns a value which indicates the level of support given by this
    provider.

--*/
{

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetCaps: QueryVal = %d\n", QueryVal));

    //
    // Some of the flags are commented out, since they are not supported.
    //

    switch (QueryVal) {

    case WNNC_SPEC_VERSION:
        return WNNC_SPEC_VERSION51;

    case WNNC_NET_TYPE:
        return WNNC_NET_DAV;

    case WNNC_DRIVER_VERSION:
        return 0x00010000;      // driver version 1.0

    case WNNC_USER:
        return WNNC_USR_GETUSER;

    case WNNC_CONNECTION:
        return ( WNNC_CON_ADDCONNECTION  |
                 WNNC_CON_ADDCONNECTION3 |
                 //
                 // Not supported for now.
                 //
                 //WNNC_CON_GETPERFORMANCE |
                 //
                 // DEFERRED connections are not supported for now.
                 //
                 //WNNC_CON_DEFER          |
                 WNNC_CON_GETCONNECTIONS |
                 WNNC_CON_CANCELCONNECTION );

    case WNNC_ENUMERATION:
        return ( WNNC_ENUM_GLOBAL  |
                 WNNC_ENUM_LOCAL   |
                 // 
                 // We are not supporting this option since we have no concept
                 // of DOMAIN in DAV. Hence cannot show any thing in  
                 // "network neighbourhood" view.
                 // 
                 // WNNC_ENUM_CONTEXT |
                 WNNC_ENUM_SHAREABLE );
    
    case WNNC_START:
        if ( DavWorkstationStarted() ) {
            return 1;
        }
        else {
            return 0xffffffff;   // don't know
        }

    case WNNC_DIALOG:
        return ( WNNC_DLG_GETRESOURCEPARENT      | 
                 //
                 //This flag is Obselete and is not supported.
                 //
                 //WNNC_DLG_DEVICEMODE             |
                 //
                 // Both of these Dialog options are not supported for now.
                 //
                 //WNNC_DLG_PROPERTYDIALOG         |
                 //WNNC_DLG_SEARCHDIALOG           |
                 WNNC_DLG_FORMATNETWORKNAME      |
                 WNNC_DLG_GETRESOURCEINFORMATION );

    case WNNC_ADMIN:
        return  0; 
                // 
                // None of functions given below are supported.
                //
                //( WNNC_ADM_GETDIRECTORYTYPE  |
                //WNNC_ADM_DIRECTORYNOTIFY );

    case WNNC_CONNECTION_FLAGS:
        return  ( WNNC_CF_DEFAULT |
                 //
                 // DEFERRED Connections are not supported for now.
                 //
                 //CONNECT_DEFERRED | 
                  CONNECT_COMMANDLINE |
                  CONNECT_CMD_SAVECRED );

        //
        // The rest are not supported by the DAV provider.
        //
        default:
            return 0;
    
    }

}


DWORD 
NPGetUser(
    IN LPTSTR lpName,
    OUT LPTSTR lpUserName,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function determines the user name that created the connection.

Arguments:

    lpName - Name of the local drive or the remote name that the user has made
             a connection to. If NULL, return currently logged on user.
    
    lpUserName - The buffer to be filled in with the requested user name.
    
    lpBufferSize - Contains the length (in chars not bytes )of the lpUserName 
                   buffer. If the length is insufficient, this place is used to 
                   inform the user the actual length needed. 

Return Value:

    WN_SUCCESS - Successful. OR

    The appropriate network error code.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    handle_t dav_binding_h;
    BOOL getUser = FALSE, bindRpcHandle = FALSE;
    DWORD NumOfChars = 0;
    BOOLEAN didAllocate = FALSE, getLogonUserName = FALSE, doRpcCall = FALSE;
    PWCHAR ConnectionName = NULL, LocalUserName = NULL;
    ULONG LocalUserNameLengthInBytes = 0;
    DWORD npStatus = ERROR_SUCCESS;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetUser Entered.\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NOT_CONNECTED;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Checking for invalid parameters. 
    //
    if (lpBufferSize  == NULL || (lpUserName == NULL && *lpBufferSize != 0) ) {
        NPStatus = ERROR_INVALID_PARAMETER;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser. Invalid parameters. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if the given connectin name (lpName) is L"" or NULL, in which case we
    // returns user-id of the logon user.
    //
    if (lpName != NULL && lpName[0] != L'\0') {
        if (DavCheckLocalName(lpName) != WN_SUCCESS) {
            // 
            // Check if it is a valid format remote connection: it can be a
            // URL form string or can be a UNC format string.
            //
            NPStatus = DavCheckAndConvertHttpUrlToUncName(lpName,
                                                          &(ConnectionName),
                                                          &(didAllocate),
                                                          FALSE,
                                                          &remNameType,
                                                          NULL,
                                                          TRUE);
            if (NPStatus != ERROR_SUCCESS) {
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUser/DavCheckAndConvertHttpUrlToUncName."
                                " NPStatus = %08lx\n", NPStatus));
                if (NPStatus == WN_BAD_NETNAME) {
                     NPStatus = WN_NOT_CONNECTED;
                }
                goto EXIT_THE_FUNCTION;
            }
            // 
            // Connection names are allowed only to shares or sub-directories
            // inside them. So RemoteName should have atleast \\server\share
            // part in it.
            //
            if (remNameType != DAV_REMOTENAME_TYPE_SHARE && 
                remNameType != DAV_REMOTENAME_TYPE_PATH) {
               IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/DavCheckAndConvertHttpUrlToUncName."
                        " remNameType = %d\n", remNameType));
               NPStatus = WN_NOT_CONNECTED;
               goto EXIT_THE_FUNCTION;
            }

            //
            // Given connection is a valid format remote connection name and
            // this connection name is converted to a UNC name.
            // 
            doRpcCall = TRUE;
        } else {
            //
            // Given connection is a valid format local DOS-device name.
            // 
            ConnectionName = lpName;
            doRpcCall = TRUE;
        }
    } else {
        // 
        // Connection name (lpName) passed to this function is L"" or NULL in which
        // case we returns user-id of the logon-user.
        //
        getLogonUserName = TRUE;
    }

    if (doRpcCall == TRUE) {
        
        ASSERT(ConnectionName != NULL);
        
        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetUser/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }
        bindRpcHandle = TRUE;

        RpcTryExcept {
            NPStatus = DavrGetUser(dav_binding_h, ConnectionName, &(LocalUserName));
            if (NPStatus != WN_SUCCESS) {
               IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUser/DavrGetUser(1). NPStatus = %08lx\n",
                                NPStatus));
               if (NPStatus == ERROR_NOT_FOUND || NPStatus == NERR_UseNotFound) {
                    NPStatus = WN_NOT_CONNECTED;
               }
               if (NPStatus == ERROR_INSUFFICIENT_BUFFER) {
                    NPStatus = WN_MORE_DATA;
               }
               goto EXIT_THE_FUNCTION;
           } else {
               // 
               // NPStatus == WN_SUCCESS. We are done. Exit.
               //
               LocalUserNameLengthInBytes = ( (1 + wcslen(LocalUserName)) * sizeof(WCHAR) );
               if ( *lpBufferSize < LocalUserNameLengthInBytes ) {
                   IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUser: WStatus = WN_MORE_DATA\n"));
                   *lpBufferSize = LocalUserNameLengthInBytes;
                   NPStatus = WN_MORE_DATA;
                   goto EXIT_THE_FUNCTION;
               }
               wcscpy(lpUserName, LocalUserName);
               //
               // The memory for LocalUserName was allocated by the RPC client stub
               // based on the string returned by the RPC server. We need to free
               // it now since we're done using it.
               //
               MIDL_user_free(LocalUserName);
               LocalUserName = NULL;
               goto EXIT_THE_FUNCTION;
           }
        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
              RPC_STATUS RpcStatus;
              RpcStatus = RpcExceptionCode();
              IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUser/DavrGetUser."
                                            " RpcExceptionCode = %d\n", RpcStatus));
              NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
              goto EXIT_THE_FUNCTION;
        }
        RpcEndExcept

    }

    // 
    // We should come here only in case when logged-on user name is to be
    // returned.
    //
    if (getLogonUserName == FALSE) {
        //
        // Neither the connection exist, nor this function call is called with
        // null connection parameter in which case it should return logon-userid
        // So we quit here with error WN_NOT_CONNECTED.
        //
        NPStatus = WN_NOT_CONNECTED;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(getLogonUserName == TRUE);

    //
    // Get the required length for storing the name of the currently logged on
    // user.
    //

    NumOfChars = 0;
    getUser = GetUserName( NULL, &NumOfChars );
    npStatus = GetLastError();
    if (getUser != FALSE || npStatus != ERROR_INSUFFICIENT_BUFFER) {
        NPStatus = npStatus;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/GetUserName. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check to see if the buffer passed-in is of the required length. (It also
    // includes the null terminator).
    //
    if ( *lpBufferSize < NumOfChars  || lpUserName == NULL ) {
        NPStatus = WN_MORE_DATA;
        *lpBufferSize = NumOfChars;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUser: WStatus = WN_MORE_DATA\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Now, get the user name.
    //
    getUser = GetUserName( lpUserName, lpBufferSize);
    if (!getUser) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUser/GetUserName. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    NPStatus = WN_SUCCESS;

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetUser: NPStatus = %d\n", NPStatus));

    if(didAllocate == TRUE && ConnectionName != NULL) {
        LocalFree((HLOCAL)ConnectionName);
        didAllocate = FALSE;
        ConnectionName = NULL;
    }

    //
    // The memory for LocalUserName was allocated by the RPC client stub
    // based on the string returned by the RPC server. We need to free
    // it now if we came down an error path after calling the server.
    //
    if (LocalUserName != NULL) {
        MIDL_user_free(LocalUserName);
        LocalUserName = NULL;
    }

    return NPStatus;
}


DWORD
NPGetConnection(
    LPWSTR lpLocalName,
    LPWSTR lpRemoteName,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function determines the remote name associated with the local name
    passed in.

Arguments:

    lpLocalName - Name of the local drive redirected to the remote name.
    
    lpRemoteName - The remote name to find.
    
    lpBufferSize - Contains the length (in chars not bytes ) of the lpRemoteName 
                   buffer. If the length is insufficient, this place is used to 
                   inform the user the actual length needed. 

Return Value:

    WN_SUCCESS - Successful. OR

    WN_NOT_CONNECTED - The device specified by lpLocalName is not redirected by 
                       this provider.

    WN_MORE_DATA - The buffer is too small.
    
    WN_NO_NETWORK - Network is not present.

--*/
{
    DWORD NPStatus = WN_SUCCESS, WStatus = ERROR_SUCCESS;
    PWCHAR DeviceName = NULL;
    DWORD DeviceNameLen = 0, LengthWritten = 0, LocalBufLen = 0, ReqLen = 0;
    PWCHAR ServerStart = NULL, SymLink = NULL, LocalAllocBuf = NULL;
    WCHAR LocalBuf[MAX_PATH + 1] = L"";
    DWORD LocalBufMaxLen = sizeof(LocalBuf)/sizeof(WCHAR);

    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetConnection: LocalName = %ws\n", lpLocalName));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    if ( lpLocalName == NULL || lpBufferSize == NULL || (lpRemoteName == NULL && *lpBufferSize != 0) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. Invalid parameters. NPStatus = %d\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Initialize some local variables.
    //
    DeviceName = DD_DAV_DEVICE_NAME_U;
    DeviceNameLen = DeviceName == NULL ? 0: wcslen(DD_DAV_DEVICE_NAME_U);
    LocalBufLen = 0;
    SymLink = NULL;
    LengthWritten = 0;
    ServerStart = NULL;
    ReqLen = 0;
    
    // 
    // Make sure that WebDAV redirector has valid device name set = 
    // DD_DAV_DEVICE_NAME_U != L""
    //
    if (DeviceNameLen == 0) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. DeviceName=NULL. NPStatus=%d\n", NPStatus));
        // 
        // This should never happen. Break here and investigate.
        //
        ASSERT(FALSE);
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Find out from QueryDosDevice, the information about symlink associated
    // to it. This call will fail for bad lpLocalName, or for non-existent
    // lpLocalName devices. When successful, it will tell the length of buffer
    // required to contain symbolic link of the given local device (lpLocalName).
    //

    //
    // We are going to use a local buffer to get the symbolic link. It that
    // buffer falls short, then we will try allocating buffer and use them.
    // 
    SymLink = LocalBuf;
    LocalBufLen = LocalBufMaxLen;

    do {

        LengthWritten = QueryDosDeviceW(lpLocalName, SymLink, LocalBufLen);
        
        if ( LengthWritten == 0 ) {

            WStatus = GetLastError();
            if (WStatus != ERROR_INSUFFICIENT_BUFFER) {
                NPStatus = WN_NOT_CONNECTED;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetConnection/QueryDosDevice. GLE=%d, NPStatus=%d\n",
                            WStatus, NPStatus));
                goto EXIT_THE_FUNCTION;
            }

            // 
            // Allocate the buffer to hold the symlink to be returned from 
            // QueryDosDevice call.
            //
        
            // 
            // We are going to allocate more buffer to contain the symbolic link.
            // We don't want to allocate more and more and more - so putting a cap
            // on max-size that can be allocated or else some error in API QueryDosDevice
            // can take this API in trouble.
            //
            if (LocalBufLen > (MAX_PATH * 10)) {
                NPStatus = WN_OUT_OF_MEMORY;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetConnection/LocalAlloc. NPStatus=%d\n",
                            NPStatus));
                ASSERT(FALSE);
                goto EXIT_THE_FUNCTION;
            }
            
            if (LocalAllocBuf != NULL) {
                LocalFree((HLOCAL)LocalAllocBuf);
                LocalAllocBuf = NULL;
            }

            // 
            // Add MAX_PATH to length of buffer used in last call of QueryDosDevice.
            // Allocate buffer of new length and use it in next call of 
            // QueryDosDevice.
            //
            LocalBufLen += MAX_PATH; 
        
            LocalAllocBuf = LocalAlloc ( (LMEM_FIXED | LMEM_ZEROINIT), 
                                         (LocalBufLen * sizeof(WCHAR)) );
            if (LocalAllocBuf == NULL) {
                NPStatus = WN_OUT_OF_MEMORY;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPGetConnection/LocalAlloc. NPStatus=%d\n",
                            NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            SymLink = LocalAllocBuf;

        }

    } while (LengthWritten == 0);

    //
    // Check if the given local-name belongs to our device DD_DAV_DEVICE_NAME_U.
    // SymLink should be of form (an example):
    // \Device\WebDavRedirector\;Z:0000000000000e197\webdav-server\dav-share
    // And DeviceName is of form (an example): \Device\WebDavRedirector.
    //

    if (_wcsnicmp(SymLink, DeviceName, DeviceNameLen) != 0) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. Non-DAV device. SymLink=%ws, "
                        "NPStatus=%d\n", SymLink, NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    // 
    // Check if local-drive letter in symbolic mapping is same as the 
    // lpLocalName given to this function.
    //
    // \Device\WebDavRedirector\;Z:0000000000000e197\webdav-server\dav-share
    // And
    // lpLocalNname is (in example): Z:
    //
    if (_wcsnicmp((PWCHAR)(SymLink + DeviceNameLen + 2), lpLocalName, 2) != 0) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. SymLink has different drive name. "
                        "SymLink=%ws, NPStatus=%d\n", SymLink, NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // The control comes here when symbolic-link returned by QueryDosDevice
    // belongs to our device and is associated to the local device given in 
    // this function (lpLocalName).
    //
    IF_DEBUG_PRINT(DEBUG_MISC,
                       ("ERROR: NPGetConnection. WebDAV symlink FOUND. SymLink=%ws\n",
                        SymLink));

    //
    // Now get remote-name stored in symbolic link.
    // Example SymLink: \Device\WebDavRedirector\;Z:0000000000000e197\webdav-server\dav-share
    //                                                               ^
    //                                                               |
    //                                                               ServerStart
    // This example has remote name = \\webdav-server\dav-share.
    //
    // Note: an extra L'\' is added in front of "ServerStart" to make it
    // valid UNC remote-name.
    //
    ServerStart = wcschr((PWCHAR)(SymLink + DeviceNameLen + 2), L'\\');
    if (ServerStart == NULL) {
        NPStatus = WN_NOT_CONNECTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. SymLink do not has remote name. "
                        "SymLink=%ws, NPStatus=%d\n", SymLink, NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Symbolic string returned by QueryDosDevice function is a double-null
    // terminated string. So subtract 1 from LengthWritten to get length of Symbolic
    // string with only 1 null termination character.
    //
    ReqLen = (LengthWritten - 1) - (DWORD)(ServerStart - SymLink) + 1; // +1 for extra L'\'

    if (*lpBufferSize < ReqLen) {
        // 
        // Passed length is shorter than required to store remote name.
        //
        NPStatus = WN_MORE_DATA;
        *lpBufferSize = ReqLen;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetConnection. RequiredLen=%d, NPStatus=%d\n",
                        ReqLen, NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Given buffer is enough to contain buffer.
    //

    wsprintf(lpRemoteName, L"\\%s", ServerStart);
    NPStatus = WN_SUCCESS;
    IF_DEBUG_PRINT(DEBUG_MISC , ("NPGetConnection: lpRemoteName = %ws\n", lpRemoteName));

EXIT_THE_FUNCTION:

    if (LocalAllocBuf != NULL ) {
        LocalFree((HLOCAL)LocalAllocBuf);
        LocalAllocBuf = NULL;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetConnection: NPStatus = %d\n", NPStatus));
    
    return NPStatus;
}


DWORD
APIENTRY
NPAddConnection3(
    HWND  hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword, 
    LPTSTR lpUserName,
    DWORD  dwFlags
    )
/*++

Routine Description:

    This function is used to redirect (connect) a local device to a network 
    resource.

Arguments:

    hwndOwner - A handle to a window which should be the owner for any messages 
                or dialogs. This is only valid if  CONNECT_INTERACTIVE is set in 
                dwFlags, and should only be used to produce dialogs needed for 
                authentication.

    lpNetResource - Specifies the network resource to connect to. This structure 
                    is defined the section describing Enumeration APIs. The 
                    following fields must be set when making a connection, the 
                    others are ignored.
        
                    lpRemoteName - Specifies the network resource to connect to.
                    
                    lpLocalName - This specifies the name of a local device to 
                                  be redirected, such as "F:" or "LPT1". The 
                                  string is treated in a case insensitive manner, 
                                  and may be the empty string (or NULL pointer) 
                                  in which case a connection to the network 
                                  resource is made without making a redirection.
                                  
                    dwType - Specifies the type of resource to connect to. It 
                             can be RESOURCETYPE_DISK, RESOURCETYPE_PRINT, or 
                             RESOURCETYPE_ANY. The value RESOURCETYPE_ANY is 
                             used if the caller does not care or does not know.
                             
    lpPassword - Specifies the password to be used in making the connection, 
                 normally the password associated with lpUserName. The NULL 
                 value may be passed in to indicate to the function to use the 
                 default password. An empty string may be used to indicate no 
                 password.
                  
    lpUserName - This specifies the username used to make the connection. If 
                 NULL, the default username (currently logged on user) will be 
                 applied. This is used when the user wishes to connect to a 
                 resource, but has a different user name or account assigned to 
                 him for that resource.
                 
    dwFlags - Any combination of the following values:

              CONNECT_TEMPORARY - The connection is being established for 
                                  browsing purposes and will probably be 
                                  released quickly.

              CONNECT_INTERACTIVE - May have interaction with the user for 
                                    authentication purposes.

              CONNECT_PROMPT - Do no use any defaults for usernames or passwords 
                               without offering user the chance to supply an 
                               alternative. This flag is only valid if  
                               CONNECT_INTERACTIVE is set.

              CONNECT_DEFERRED - Do not perform any remote network operations to 
                                 make the network connection; instead, restore 
                                 the connection in a "disconnected state".  
                                 Attempt the actual connection only when some 
                                 process attempts to use it. If this bit is set, 
                                 the caller must supply lpLocalName. This feature 
                                 is used to speed the restoring of network 
                                 connections at logon. A provider that supports 
                                 it should return the WNNC_CON_DEFERRED bit in 
                                 NPGetCaps.

              The provider should ignore any other bits of dwFlags that may be 
              set.

    Return Value:
    
    WN_SUCCESS - The call is successful. Otherwise, the an error code is 
                 returned, which may include:
    
    WN_BAD_NETNAME - lpRemoteName in the lpNetResource structure is not 
                     acceptable to this provider.
    
    WN_BAD_LOCALNAME - lpLocalName in lpNetResource is invalid.
    
    WN_BAD_PASSWORD - Invalid password.
    
    WN_ALREADY_CONNECTED - lpLocalName already connected.
    
    WN_ACCESS_DENIED - Access denied.
    
    WN_NO_NETWORK - Network is not present.
    
    WN_CANCEL - The attempt to make the connection was cancelled by the user via 
                a dialog box displayed by the provider.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    handle_t dav_binding_h;
    BOOL bindRpcHandle = FALSE;
    WCHAR UIServerName[CRED_MAX_STRING_LENGTH + 1] = L"";
    PFN_CREDUI_CONFIRMCREDENTIALS pfnCredUIConfirmCredentials = NULL;
    PFN_CREDUI_PROMPTFORCREDENTIALS pfnCredUIPromptForCredentials = NULL;
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS pfnCredUICmdlinePromptForCredentials = NULL;
    HMODULE hCredUI = NULL;
    CREDUI_INFOW uiInfo = { sizeof(uiInfo), hwndOwner, NULL };
    DWORD dwCreduiFlags = 0;
    PWCHAR szCaption = NULL, szMessage = NULL, Password = NULL, UserName = NULL;
    SIZE_T szCaptionLength = 0, szMessageLength =0;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    if ( lpNetResource == NULL ) {
        NPStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ("Entering NPAddConnection3. LocalName = %ws, RemoteName = %ws,"
                    " dwFlags = %08lx\n",
                    lpNetResource->lpLocalName, lpNetResource->lpRemoteName, dwFlags));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if dwType is set and is set to some valid value.
    // It can be only of type RESOURCETYPE_DISK for our provider.
    //
    NPStatus = DavCheckResourceType(lpNetResource->dwType);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3. NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    if (lpNetResource->lpLocalName != NULL &&
        lpNetResource->lpLocalName[0] != L'\0' && 
        lpNetResource->dwType != RESOURCETYPE_DISK) {
        NPStatus = WN_BAD_DEV_TYPE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3(2). NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                  &(RemoteName),
                                                  &(didAllocate),
                                                  FALSE,
                                                  &remNameType,
                                                  NULL,
                                                  TRUE);
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavCheckAndConvertHttpUrlToUncName."
                        " NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    if (remNameType != DAV_REMOTENAME_TYPE_SHARE && 
        remNameType != DAV_REMOTENAME_TYPE_PATH) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavCheckAndConvertHttpUrlToUncName."
                        " remNameType = %d\n", remNameType));
        NPStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("NPAddConnection3: RemoteName = %ws\n", RemoteName));

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_MISC,
                       ("ERROR: NPAddConnection3/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    bindRpcHandle = TRUE;

    RpcTryExcept {
        NPStatus = DavrCreateConnection(dav_binding_h,
                                        lpNetResource->lpLocalName,
                                        RemoteName,
                                        lpNetResource->dwType,
                                        lpPassword,
                                        lpUserName);
        if (NPStatus == NO_ERROR) {
            //
            // If default credentials were used, return WN_CONNECTED_OTHER_PASSWORD_DEFAULT
            // to let the MPR know we used the default credentials to connect.
            //
            if (lpUserName == NULL && lpPassword == NULL) {
                NPStatus = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
            } else {
                NPStatus = WN_SUCCESS;
            }
            goto EXIT_THE_FUNCTION;
        } else {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPAddConnection3/DavrCreateConnection. "
                            "NPStatus = %08lx\n", NPStatus));
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPAddConnection3/DavrCreateConnection."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    //
    // If the error returned was not one of the following, we return the error 
    // and don't query for the users credentials.
    //
    if ( NPStatus != ERROR_ACCESS_DENIED && 
         NPStatus != ERROR_LOGON_FAILURE &&
         NPStatus != ERROR_INVALID_PASSWORD ) {
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // If the CONNECT_INTERACTIVE flag was not specified, then we don't pop up 
    // the UI.
    //
    if ( !(dwFlags & CONNECT_INTERACTIVE) ) {
        goto EXIT_THE_FUNCTION;
    } 

    if (lpUserName != NULL && (wcslen(lpUserName) > CREDUI_MAX_USERNAME_LENGTH) ) {
        NPStatus = WN_BAD_USER;
        goto EXIT_THE_FUNCTION;
    }

    ZeroMemory( UIServerName, ((CRED_MAX_STRING_LENGTH + 1) * sizeof(WCHAR)) );

    hCredUI = DavInitCredUI(RemoteName, 
                            UIServerName, 
                            &(pfnCredUIConfirmCredentials),
                            &(pfnCredUIPromptForCredentials),
                            &(pfnCredUICmdlinePromptForCredentials));
    if (hCredUI == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/DavInitCredUI = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // We need to allocate memory for a few things.
    //

    Password = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                          (CREDUI_MAX_PASSWORD_LENGTH + 1) * sizeof(WCHAR));
    if (Password == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    UserName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), 
                          (CREDUI_MAX_USERNAME_LENGTH + 1) * sizeof(WCHAR));
    if (UserName == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // The extra bytes are for the WCHARS "Connect to " and the L'\0' at 
    // the end. See the wcsncpy (szCaption) below for understanding this.
    //
    szCaptionLength = ( ( wcslen(UIServerName) + 
                          wcslen(L"Connect to ") + 
                          1 ) * sizeof(WCHAR) );
    szCaption = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), szCaptionLength);
    if (szCaption == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // The extra 30 bytes is for the 14 WCHARS "Connecting to " and the L'\0' at 
    // the end. See the wcsncpy (szMessage) below for understanding this.
    //
    szMessageLength = ( ( wcslen(UIServerName) + 
                          wcslen(L"Connecting to ") + 
                          1) * sizeof(WCHAR) );
    szMessage = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT), szMessageLength);
    if (szMessage == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection3/LocalAlloc = %d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the caption.
    //
    wcscpy( szCaption, L"Connect to ");
    wcscat( szCaption, UIServerName);
    
    //
    // Copy the message.
    //
    wcscpy( szMessage, L"Connecting to ");
    wcscat( szMessage, UIServerName);
    
    //
    // Set the message and caption copied above in the uiInfo field.
    //
    uiInfo.pszMessageText = szMessage;
    uiInfo.pszCaptionText = szCaption;
    
    if (lpUserName != NULL) {
        wcsncpy( UserName, lpUserName, wcslen(lpUserName) );
    }
    
    //
    // We loop till the user hits the cancel button or the credentials are
    // valid and the connection gets created.
    //
    for ( ; ; ) {
        
        BOOL fCredWritten = FALSE;
        DWORD dwAuthErr = NPStatus;
        LPWSTR lpNewPassword = NULL;

        Password[0] = L'\0';

        //
        // Require confirmation of the stored credentials.
        //
        dwCreduiFlags = CREDUI_FLAGS_EXPECT_CONFIRMATION;

        if (dwFlags & CONNECT_COMMANDLINE) {
            
            //
            // Set the appropriate flags to set the behavior of the common UI.
            //

            //
            // CredMgr does not (yet) know how to handle certificates.
            //
            dwCreduiFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES;

            //
            // Ensure that the username syntax is correct.
            //
            dwCreduiFlags |= CREDUI_FLAGS_VALIDATE_USERNAME;

            //
            // If the caller wants to save both username and password,
            // create an enterprise peristed cred.
            //
            if ( dwFlags & CONNECT_CMD_SAVECRED ) {
                dwCreduiFlags |= CREDUI_FLAGS_PERSIST;
            } else {
                dwCreduiFlags |= CREDUI_FLAGS_DO_NOT_PERSIST;
            }

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPAddConnection3: pfnCredUICmdlinePromptForCredentials."
                            " RemoteName = %ws\n", RemoteName));

            NPStatus = pfnCredUICmdlinePromptForCredentials(UIServerName,
                                                            NULL,
                                                            0,
                                                            UserName,
                                                            CREDUI_MAX_USERNAME_LENGTH,
                                                            Password,
                                                            CREDUI_MAX_PASSWORD_LENGTH,
                                                            &fCredWritten,
                                                            dwCreduiFlags);
        } else {

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPAddConnection3: pfnCredUIPromptForCredentials."
                            " RemoteName = %ws\n", RemoteName));

            NPStatus = pfnCredUIPromptForCredentials(&(uiInfo),
                                                     UIServerName,
                                                     NULL,
                                                     0,
                                                     UserName,
                                                     CREDUI_MAX_USERNAME_LENGTH,
                                                     Password,
                                                     CREDUI_MAX_PASSWORD_LENGTH,
                                                     &fCredWritten,
                                                     dwCreduiFlags);
        }

        if (NPStatus != ERROR_SUCCESS) {
            SetLastError(NPStatus);
            goto EXIT_THE_FUNCTION;
        } else {
            lpUserName = (L'\0' == UserName[0]) ? NULL : UserName;
            lpNewPassword = (L'\0' == Password[0]) ? NULL : Password;
        }
        
        //
        // Try to connect to the server again with the new credentials the user 
        // entered.
        //
        RpcTryExcept {
            NPStatus = DavrCreateConnection(dav_binding_h,
                                            lpNetResource->lpLocalName,
                                            RemoteName,
                                            lpNetResource->dwType,
                                            lpNewPassword,
                                            lpUserName);
            if (NPStatus != NO_ERROR) {
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPAddConnection3/DavrCreateConnection(2). "
                                "NPStatus = %08lx\n", NPStatus));
                //
                // Report cred as not working.
                //
                pfnCredUIConfirmCredentials(UIServerName, FALSE);
                SetLastError(NPStatus);
            } else {
                //
                // Since we succeeded, we can/should confirm these credentials.
                //
                NPStatus = WN_SUCCESS;
                pfnCredUIConfirmCredentials(UIServerName, TRUE);
                //
                // If the credentials were not stored in credman, tell MPR so it
                // can prompt the user when restoring peristent connections. If
                // the credentials were stored in credman, tell MPR that the
                // default credential was used.
                //
                if (fCredWritten) {
                    NPStatus = WN_CONNECTED_OTHER_PASSWORD_DEFAULT;
                } else if ( (lpPassword == NULL) || (wcscmp(lpPassword, lpNewPassword) != 0) ) {
                    NPStatus = WN_CONNECTED_OTHER_PASSWORD;
                }
                goto EXIT_THE_FUNCTION;
            }
        } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
              RPC_STATUS RpcStatus;
              RpcStatus = RpcExceptionCode();
              IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPAddConnection3/DavrCreateConnection."
                                            " RpcExceptionCode = %d\n", RpcStatus));
              NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
              //
              // Report cred as not working.
              //
              pfnCredUIConfirmCredentials(UIServerName, FALSE);
              goto EXIT_THE_FUNCTION;
        }
        RpcEndExcept

        //
        // For command line prompting, only prompt once.
        //
        if ( dwFlags & CONNECT_COMMANDLINE ) {
            break;
        }
    
    } // end of for loop.

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName && didAllocate) {
        LocalFree(RemoteName);
        RemoteName = NULL;
    }

    if (hCredUI) {
        FreeLibrary(hCredUI);
        hCredUI = NULL;
    }

    //
    // Clear the password from memory before freeing it.
    //
    if (Password != NULL) {
        SecureZeroMemory(Password, ((CREDUI_MAX_PASSWORD_LENGTH + 1) * sizeof(WCHAR)));
        LocalFree(Password);
        Password = NULL;
    }

    if (UserName != NULL) {
        LocalFree(UserName);
        UserName = NULL;
    }

    if (szCaption != NULL) {
        LocalFree(szCaption);
        szCaption = NULL;
    }

    if (szMessage != NULL) {
        LocalFree(szMessage);
        szMessage = NULL;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPAddConnection3: NPStatus = %d\n", NPStatus));

    return NPStatus;
}


DWORD
APIENTRY
NPAddConnection(
    LPNETRESOURCEW lpNetResource,
    LPWSTR lpPassword,
    LPWSTR lpUserName
    )
/*++

Routine Description:

    This function creates a remote connection.

Arguments:

    lpNetResource - Supplies the NETRESOURCE structure which specifies the local
                    DOS device to map, the remote resource to connect to and 
                    other attributes related to the connection.

    lpPassword - Supplies the password to connect with.

    lpUserName - Supplies the username to connect with.

Return Value:

    WN_SUCCESS - Successful.

    WN_BAD_VALUE - Invalid value specifed in lpNetResource.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_BAD_LOCALNAME - Invalid local DOS device name.

    WN_BAD_PASSWORD - Invalid password.

    WN_ALREADY_CONNECTED - Local DOS device name is already in use.
    
    WN_ACCESS_DENIED - Unable to connect with the given credentials.

--*/
{
    DWORD NPStatus = WN_SUCCESS;

    NPStatus = NPAddConnection3(NULL,
                                lpNetResource,
                                lpPassword,
                                lpUserName,
                                0);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection/NPAddConnection3. "
                        "NPStatus = %08lx\n", NPStatus));
    }

    return NPStatus;
}

DWORD
APIENTRY
NPCancelConnection(
    LPWSTR lpName,
    BOOL fForce
    )
/*++

Routine Description:

    This function deletes a remote connection.

Arguments:

    lpName - Supplies the local DOS device, or the remote resource name
             if it is a UNC connection to delete.

    fForce - Supplies the force level to break the connection.  TRUE means to
             forcefully delete the connection, FALSE means end the connection
             only if there are no opened files.

Return Value:

    NO_ERROR - Successful.

    WN_BAD_NETNAME - Invalid remote resource name.

    WN_NOT_CONNECTED - Connection could not be found.

    WN_OPEN_FILES - fForce is FALSE and there are opened files on the
                    connection.

    Other network errors.

--*/
{
    DWORD NPStatus;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ( "NPCancelConnection: Name = %ws, Force = %s\n",
                     lpName, (fForce == 0 ? "FALSE" : "TRUE") ));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPCancelConnection/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    if ( lpName == NULL || lpName[0] == L'\0' ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPCancelConnection. lpName is not valid"));
        NPStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the name supplied is a local name then the second char will be a L':'.
    // If its not a local name, then we should check to see if the remote name
    // is of the form http:. If it is, we convert it to the UNC format and send
    // it to the RPC server.
    //
    if (DavCheckLocalName(lpName) != WN_SUCCESS ) {

        NPStatus = DavCheckAndConvertHttpUrlToUncName(lpName,
                                                      &(RemoteName),
                                                      &(didAllocate),
                                                      FALSE /*TRUE*/,
                                                      &remNameType,
                                                      NULL,
                                                      TRUE);
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPCancelConnection/DavCheckAndConvertHttpUrlToUncName."
                            " NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        if (remNameType != DAV_REMOTENAME_TYPE_SHARE && 
            remNameType != DAV_REMOTENAME_TYPE_PATH) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPCancelConnection/DavCheckAndConvertHttpUrlToUncName."
                            " remNameType=%d\n", remNameType));
            NPStatus = WN_BAD_NETNAME;
            goto EXIT_THE_FUNCTION;
        }
    
    } else {

        //
        // If we are removing a local name, set the RemoteName value to be the
        // local name.
        //
        RemoteName = lpName;

    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("NPCancelConnection: RemoteName = %ws\n", RemoteName));

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPAddConnection/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        NPStatus = DavrDeleteConnection(dav_binding_h, RemoteName, fForce);
        if (NPStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPCancelConnection/DavDeleteConnection. "
                            "NPStatus = %08lx\n", NPStatus));
            if (NPStatus == ERROR_NOT_FOUND || NPStatus == NERR_UseNotFound) {
                NPStatus = WN_NOT_CONNECTED;
            }
            goto EXIT_THE_FUNCTION;
        } else {
            NPStatus = WN_SUCCESS;
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCancelConnection/DavrDeleteConnection."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName && didAllocate) {
        LocalFree(RemoteName);
        RemoteName = NULL;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPCancelConnection: NPStatus = %d\n", NPStatus));
    
    return NPStatus;
}


DWORD
NPOpenEnum(
    IN DWORD dwScope,
    IN DWORD dwType,
    IN DWORD dwUsage,
    IN LPNETRESOURCE lpNetResource,
    OUT LPHANDLE lphEnum
    )
/*++

Routine Description:

    This API is used to Open an enumeration of network resources or existing
    connections.

Arguments:

    dwScope - Determines the scope of the enumeration. This can be one of:
              RESOURCE_CONNECTED - All currently connected resources.
              RESOURCE_GLOBALNET - All resources on the network.
              RESOURCE_CONTEXT - The resources associated with the user's 
                                 current and default network context. Used for
                                 a "Network Neighbourhood" view.
    
    dwType - Used to specify the type of resources of interest. This is a 
             bitmask which may be any combination of:
             RESOURCETYPE_DISK  - All disk resources.
             RESOURCETYPE_PRINT - All print resources.
             RESOURCEUSAGE_ATTACHED - Specifies that the function should fail if
                                      the caller is not authenticated (even if 
                                      the network permits enumeration without 
                                      authentication).
             If dwType is 0, or is just RESOURCEUSAGE_ATTACHED, all types of 
             resources are returned. If a provider does not have the capability
             to distinguish between print and disk resources at a level, 
             it may return all resources.                                       
    
    dwUsage - Used to specify the usage of resources of interested. This is a 
              bitmask which may be any combination of:
              RESOURCEUSAGE_CONNECTABLE - All connectable resources.
              RESOURCEUSAGE_CONTAINER - All container resources.
              The bitmask may be 0 to match all. This parameter may be ignored 
              if dwScope is not RESOURCE_GLOBALNET.

    lpNetResource - This specifies the container to perform the enumeration. The
                    NETRESOURCE could have been obtained via a previous 
                    NPEnumResource, or constructed by the caller or NULL. If it 
                    is NULL, or if the lpRemoteName field of the NETRESOURCE is 
                    NULL, the provider should enumerate the top level of its 
                    network. (Note: This means that a provider cannot use an 
                    lpRemoteName of NULL to represent any network resource.) A 
                    caller would normally start off by calling NPOpenEnum with 
                    this parameter set to NULL, and then use the returned 
                    results for further enumeration. If the calling program 
                    knows exactly the provider and remote path to enumerate from,
                    it may build its own NETRESOURCE structure to pass in, 
                    filling in the lpProvider and lpRemoteName fields. Note that
                    if dwScope is RESOURCE_CONNECTED or RESOURCE_CONTEXT this 
                    parameter will be NULL.
    
    lphEnum - If function call is successful, a handle will be returned here 
              that can then be used for enumeration.

Return Value:

    WN_SUCCESS- If the call is successful. Otherwise, an error code is returned, 
                which may include:

    WN_NOT_SUPPORTED - The provider does not support the type of enumeration 
                       being requested, or the specific network resource cannot 
                       be browsed.
    
    WN_NOT_CONTAINER - lpNetResource does not point to a container.

    WN_BAD_VALUE - Invalid dwScope or dwUsage or dwType, or bad combination of 
                   parameters is specified.

    WN_NO_NETWORK - Network is not present.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PDAV_ENUMNODE DavEnumNode = NULL;
    BOOL isThisDavServer = FALSE, bRetEnumNode = FALSE;
    LPNETRESOURCEW lpNROut = NULL;
    ULONG RemoteNameSizeInBytes = 0;
    PWCHAR RemoteName = NULL, pRemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ("NPOpenEnum: Entered. dwScope=0x%x, dwType=0x%x "
                    "dwUsage=0x%x, lpNetResource=0x%x\n",
                    dwScope, dwType, dwUsage, lpNetResource));
    
    DavDisplayNetResource(lpNetResource, L"lpNetResource in NPOpenEnum");

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPOpenEnum/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to perform some basic checks before moving ahead.
    //

    if (lphEnum == NULL) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPOpenEnum: lphEnum == NULL. NPStatus = %d\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Validate dwType parameter - it can have RESOURCEUSAGE_ATTACHED in addition
    // to its standard set of values - but currently RESOURCEUSAGE_ATTACHED is
    // a NO-OP for us.
    //
    if (dwType == 0 || dwType == RESOURCEUSAGE_ATTACHED ) {
         dwType = RESOURCETYPE_DISK;
    }

    if ( dwType & ~RESOURCETYPE_DISK ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum: Invalid dwType."
                                "NPStatus=%d\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    DavEnumNode = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(DAV_ENUMNODE));
    if (DavEnumNode == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum/LocalAlloc: NPStatus"
                                     " = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    bRetEnumNode = FALSE;

    switch (dwScope) {
        
    case RESOURCE_CONNECTED: {
            
        //
        // We are looking for current uses.
        //

        IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: RESOURCE_CONNECTED\n"));

        // 
        // lpNetResource should be == NULL for this dwScope.
        //
        if (lpNetResource != NULL) {
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_CONNECTED. lpNetRes != NULL."
                            "NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        bRetEnumNode = TRUE;
        DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_USE;
        pRemoteName = NULL;
        
        break;
    
    }

    case RESOURCE_CONTEXT: {

        //
        // We are looking for servers in the domain. We don't support this 
        // search in the DAV NP since there is no way of enumerating the DAV
        // servers in the domain. DAV doesn't even support the domain concept.
        //

        NPStatus = WN_NOT_SUPPORTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                      ("ERROR: NPOpenEnum: RESOURCE_CONTEXT not supported."
                       " NPStatus = %d\n",
                       NPStatus));
        goto EXIT_THE_FUNCTION;

        break;
        
    }

    case RESOURCE_SHAREABLE: {

        //
        // We are looking for shareable resources. lpNetResource should contain
        // lpRemoteName for a server in UNC/URL form. In this case, enumerate
        // shares under this server.
        //

        IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: RESOURCE_SHAREABLE\n"));

        if ( lpNetResource == NULL || lpNetResource->lpRemoteName == NULL ) {
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_SHAREABLE. Bad parameter "
                            "lpNetResource or lpRemoteName == NULL. NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        // 
        // Need to convert lpRemoteName to UNC form if possible. This
        // can be a URL name originally.
        //
        NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                      &(RemoteName),
                                                      &(didAllocate),
                                                      FALSE,
                                                      &remNameType,
                                                      NULL,
                                                      TRUE);
        if (NPStatus != ERROR_SUCCESS || remNameType != DAV_REMOTENAME_TYPE_SERVER) {
            NPStatus = WN_BAD_NETNAME;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                            ("ERROR: NPOpenEnum: RESOURCE_SHAREABLE. lpRemoteName != SERVER."
                             " NPStatus = %d\n",NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        // 
        // We need to check if the given server is a DAV server.
        //
        if (DavServerExists(RemoteName, NULL) != TRUE) {
            NPStatus = WN_BAD_NETNAME;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_SHAREABLE. Server does not exist."
                            "NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // RemoteName is a valid server name in UNC form (\\server)
        //
        pRemoteName = RemoteName;
        bRetEnumNode = TRUE;
        DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_SHARE;

        break;

    }

    case RESOURCE_GLOBALNET: {
            
        //
        // Only - RemoteName == UNC/URL-server or RemoteName == UNC/URL-share or 
        // RemoteName == UNC/URL-path are supported in this scope. In this cases,
        // shares under this RemoteName are enumerated. Top level (when RemoteName
        // == NULL or non-UNC-URL entity) is not supported.
        //

        //
        // Look for the combination of all bits and substitute "All" for them.
        // Ignore bits we don't know about.
        // Note: RESOURCEUSAGE_ATTACHED is a no-op for us.
        //

        IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: RESOURCE_GLOBALNET\n"));
           
        // 
        // Check for presence of valid flags. If dwUsage is 0 we set it to
        // RESOURCEUSAGE_ALL since thats what is implied by the caller.
        //
        if (dwUsage == 0) {
            dwUsage = RESOURCEUSAGE_ALL;
        }

        //
        // We return WN_BAD_VALUE if the caller gave us a dwUsage value which
        // we do not support.
        //
        if ( !( dwUsage & (RESOURCEUSAGE_ALL | RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) ) ) {
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET - dwUsage invalid value."
                            "NPStatus = %d\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Only RESOURCEUSAGE_CONNECTABLE & RESOURCEUSAGE_CONTAINER are
        // supported, hence filter out flags which are not related to these.
        //
#if 0
        if (dwUsage & RESOURCEUSAGE_ALL) {
            dwUsage |= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);
        }
#endif
        dwUsage &= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);

        //
        // We are looking for global resources out on the net. Since we do NOT
        // have a concept of domains in the DAV NP, the top level resources in
        // the network are servers. Our hierarchy is
        // 1. Entire Network ===> 2. Web Client Network ===> 3. Servers ===>
        // 4. Shares.
        //
        if ( lpNetResource == NULL || lpNetResource->lpRemoteName == NULL ) {
                
            //
            // We have been asked to enumerate the top level containers in the
            // network. In the DAV NP, these are the DAV servers we know about.
            // The caller should have set the dwUsage to RESOURCEUSAGE_CONTAINER
            // since its asking us to enumerate the container types.
            //
            if ( (dwUsage & RESOURCEUSAGE_CONTAINER) == 0 ) {
                NPStatus = WN_BAD_VALUE;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET. "
                                "(dwUsage & RESOURCEUSAGE_CONTAINER)."
                                "NPStatus = %d\n", NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            //
            // At top level, therefore enumerating domains. If the user asked 
            // for connectable, well, there aint none. We don't support the 
            // concept of enumerating domains in the DAV NP. Rather we will return
            // the list of servers that are access from this client.
            // 
            pRemoteName = NULL;
            bRetEnumNode = TRUE;
            DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_SERVER;

        } else {

            //
            // If we come here, it implies that we have a name. At this point we
            // assume that we have been given a server and have been asked to
            // enumerate the shares exposed by the server.
            //

            //
            // Since we have been asked to enumerate the shares, the dwUsage
            // value should have the RESOURCEUSAGE_CONNECTABLE flag set.
            //
            if ( (dwUsage & RESOURCEUSAGE_CONNECTABLE) == 0 ) {
                NPStatus = WN_BAD_VALUE;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET. "
                                "(dwUsage & RESOURCEUSAGE_CONNECTABLE)."
                                "NPStatus = %d\n", NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            
            // 
            // We are assured of lpRemoteName != NULL. Check that the given
            // lpNetResource is a CONTAINER. It has to be a container since we
            // assume that its a server. Remember that below we are checking the
            // dwUsage values of the lpNetResource.
            //
            if ( (lpNetResource->dwUsage != 0) && 
                 ((lpNetResource->dwUsage & RESOURCEUSAGE_CONTAINER) != RESOURCEUSAGE_CONTAINER) ) {
                NPStatus = WN_NOT_CONTAINER;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum: RESOURCE_GLOBALNET. lpNetRes != CONTAINER."
                                "NPStatus = %d\n", NPStatus));
                goto EXIT_THE_FUNCTION;
            }

            NPStatus = WN_SUCCESS;
            
            NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                          &(RemoteName),
                                                          &(didAllocate),
                                                          FALSE,
                                                          &remNameType,
                                                          NULL,
                                                          TRUE);
            if ( NPStatus != ERROR_SUCCESS || remNameType != DAV_REMOTENAME_TYPE_SERVER ) {
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPOpenEnum/DavCheckAndConvertHttpUrlToUncName "
                                "RESOURCE_GLOBALNET. NPStatus = %u\n", NPStatus));
                NPStatus = WN_BAD_NETNAME;
                goto EXIT_THE_FUNCTION;
            }

            // 
            // RemoteName is UNC here - it is of form UNC-server.
            // We support both CONTAINERS (sub-directories) and CONNECTABLES (sub-dir)
            // on all these remote forms.
            //
            
            ASSERT(RemoteName != NULL);

            //
            // Check if the server given in RemoteName is a valid DAV server.
            //
            if (DavServerExists(RemoteName, NULL) != TRUE ) {
                NPStatus = WN_BAD_NETNAME;
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                                ("ERROR: NPOpenEnum/DavServerExists. RESOURCE_GLOBALNET."
                                 "NPStatus = %u\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }

            bRetEnumNode = TRUE;
            DavEnumNode->DavEnumNodeType = DAV_ENUMNODE_TYPE_SHARE;
            pRemoteName = RemoteName;

        }
            
        break;
        
    }
        
    default: {
        
            NPStatus = WN_BAD_VALUE;
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum: default: InvPar dwScope\n"));
            goto EXIT_THE_FUNCTION;

        }
    
    };

    //
    // If the EnumNodeType is not one of DAV_ENUMNODE_TYPE_SHARE OR
    // DAV_ENUMNODE_TYPE_USE, then we return WN_NOT_SUPPORTED. The only kind
    // of enumeration we support in the DAV NP is USE and SHAREs on a server.
    //
    if ( (DavEnumNode->DavEnumNodeType != DAV_ENUMNODE_TYPE_SHARE) &&
         (DavEnumNode->DavEnumNodeType != DAV_ENUMNODE_TYPE_SERVER) && 
         (DavEnumNode->DavEnumNodeType != DAV_ENUMNODE_TYPE_USE) && 
         (bRetEnumNode == TRUE) ) {
        bRetEnumNode = FALSE;
        NPStatus = WN_NOT_SUPPORTED;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum: WN_NOT_SUPPORTED!!!\n"));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // We are returning valid handle to object DAV_ENUMNODE.
    //
    ASSERT(bRetEnumNode == TRUE);

    DavEnumNode->dwScope = dwScope;
    DavEnumNode->dwType = dwType;
    DavEnumNode->dwUsage = dwUsage;
    DavEnumNode->Done = FALSE;
    DavEnumNode->Index = 0;

    //
    // If the lpNetResource is not NULL, then we create a copy of it and store
    // it in the DavEnumNode
    //
    if (lpNetResource != NULL) {

        //
        // Allocate memory for the lpNetResource for this DavEnumNode.
        //
        lpNROut = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(NETRESOURCEW));
        if (lpNROut == NULL) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum/LocalAlloc: NPStatus"
                                         " = %08lx\n", NPStatus));
            bRetEnumNode = FALSE;
            goto EXIT_THE_FUNCTION;
        }

        lpNROut->dwScope = lpNetResource->dwScope;
        lpNROut->dwType = lpNetResource->dwType;
        lpNROut->dwDisplayType = lpNetResource->dwDisplayType;
        lpNROut->dwUsage = lpNetResource->dwUsage;

        //
        // If the lpRemoteName field is not NULL, then we copy the name into the
        // structure that we are creating. lpRemoteName field in lpNROut will
        // always point to a valid UNC form or a valid non-UNC form. For this,
        // we are creating this name from the remotename we got from function
        // DavCheckAndConvertHttpUrlToUncName.
        //
        if (pRemoteName != NULL && didAllocate == FALSE) {

            //
            // We need to copy the remote name since thats all what we are 
            // interested in.
            //
            RemoteNameSizeInBytes = ( ( wcslen(pRemoteName) + 1 ) * sizeof(WCHAR) );
            
            lpNROut->lpRemoteName = LocalAlloc((LMEM_FIXED | LMEM_ZEROINIT),
                                               RemoteNameSizeInBytes);
            if (lpNROut->lpRemoteName == NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPOpenEnum/LocalAlloc: NPStatus"
                                             " = %08lx\n", NPStatus));
                bRetEnumNode = FALSE;
                goto EXIT_THE_FUNCTION;
            }

            //
            // Finally copy the remote name from the lpNetResource.
            //
            wcscpy(lpNROut->lpRemoteName, pRemoteName);

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPOpenEnum: lpNROut->lpRemoteName = %ws\n",
                            lpNROut->lpRemoteName));

        } else if (pRemoteName != NULL && didAllocate == TRUE) {
            
            lpNROut->lpRemoteName = pRemoteName;
            
            didAllocate = FALSE;
            
            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPOpenEnum: lpNROut->lpRemoteName(2) = %ws\n",
                            lpNROut->lpRemoteName));
        
        }

        DavEnumNode->lpNetResource = lpNROut;

    }

    //
    // Set DavEnumNode to be the handle. We will get called back in 
    // NpEnumResource with this value.
    //
    *lphEnum = (HANDLE)DavEnumNode;
    NPStatus = WN_SUCCESS;

    DavDisplayEnumNode(DavEnumNode, L"DavEnumNode in NPOpenEnum");

    IF_DEBUG_PRINT(DEBUG_MISC, ("NPOpenEnum: DavEnumNode = %08lx\n", DavEnumNode));

EXIT_THE_FUNCTION:

    //
    // If we did not succeed, then we should be freeing the memory if we 
    // allocated any. Also, set *lphEnum to NULL just to be on the safe side.
    //
    if (NPStatus != WN_SUCCESS || bRetEnumNode == FALSE) {
        if (lpNROut) {
            if (lpNROut->lpRemoteName) {
                LocalFree(lpNROut->lpRemoteName);
                lpNROut->lpRemoteName = NULL;
            }
            LocalFree(lpNROut);
            lpNROut = NULL;
        }
        if (DavEnumNode) {
            LocalFree(DavEnumNode);
            DavEnumNode = NULL;
        }

        if (lphEnum) {
            *lphEnum = NULL;
        }
    }
    
    if (didAllocate == TRUE && RemoteName != NULL) {
        LocalFree(RemoteName);
        RemoteName = NULL;
        didAllocate = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPOpenEnum: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();

    return NPStatus;
}


DWORD
NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    LPDWORD lpBufferSize
    )
/*++

Routine Description:

    Perform an enumeration based on handle returned by NPOpenEnum.

Arguments:

    hEnum - This must be a handle obtained from NPOpenEnum call.
    
    lpcCount - Specifies the number of entries requested. It may be 0xFFFFFFFF 
               to request as many as possible. On successful call, this location 
               will receive the number of entries actually read.
    
    lpBuffer - A pointer to the buffer to receive the enumeration result, which 
               are returned as an array of NETRESOURCE entries. The buffer is 
               valid until the next call using hEnum.
    
    lpBufferSize - This specifies the size in bytes of the buffer passed to the 
                   function call on entry. On exit, if the buffer is too small 
                   for even one entry, this will contain the number of bytes 
                   needed to read one entry. The value is only set if the 
                   return code is WN_MORE_DATA.

Return Value:

    WN_SUCCESS - If the call is successful, the caller may continue to call 
                NPEnumResource to continue the enumeration.
    
    WN_NO_MORE_ENTRIES - No more entries found, the enumeration completed 
                         successfully (the contents of the return buffer is 
                         undefined).
    
    WN_MORE_DATA - The buffer is too small even for one entry.
    
    WN_BAD_HANDLE - hEnum is not a valid handle.
    
    WN_NO_NETWORK - Network is not present. This condition is checked for before 
                    hEnum is tested for validity.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PDAV_ENUMNODE DavEnumNode = NULL;
    BOOL SrvExists = FALSE, RpcBindSucceeded = FALSE;
    handle_t dav_binding_h = NULL;
    DWORD cRequested = 0, Index = 0, EntryLengthNeededInBytes = 0, BufferSizeRemaining = 0;
    LPNETRESOURCEW lpNROut = NULL;
    PWCHAR lpszNext = NULL;
    BOOLEAN AreWeDone = FALSE;
    PWCHAR FromEnd = NULL;
    DWORD LocalNameLength = 0, RemoteNameLength = 0, DisplayNameLength = 0;
    PWCHAR LocalName = NULL;
    PWCHAR RemoteName = NULL, ServerName = NULL;
    DWORD ServerNameMaxLen = 0;
    BOOLEAN ServerNameAllocated = FALSE;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPEnumResource: Entered.\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPEnumResource/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    if ( lpcCount == NULL || lpBufferSize == NULL || (lpBuffer == NULL && *lpBufferSize != 0)) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource: Invalid Parameter\n"));
        NPStatus = WN_BAD_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    if ( hEnum == NULL ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource: Invalid Handle\n"));
        NPStatus = WN_BAD_HANDLE;
        goto EXIT_THE_FUNCTION;
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: hEnum = %08lx\n", hEnum));
    IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: Count = %u\n", *lpcCount));

    DavEnumNode = (PDAV_ENUMNODE)hEnum;

    DavDisplayEnumNode(DavEnumNode, L"DavEnumNode in NPEnumResources");
    
    if ( DavEnumNode->Done == TRUE ) {
        IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: Done == TRUE\n"));
        NPStatus = WN_NO_MORE_ENTRIES;
        goto EXIT_THE_FUNCTION;
    }

    BufferSizeRemaining = *lpBufferSize;
    
    lpNROut = (LPNETRESOURCEW)lpBuffer;
    lpszNext = (LPWSTR)(lpNROut + 1);
    FromEnd = (PWCHAR) ( ( (PBYTE)lpNROut ) +  BufferSizeRemaining );

    cRequested = *lpcCount;
    *lpcCount = 0;

    if ( (DavEnumNode->DavEnumNodeType == DAV_ENUMNODE_TYPE_SERVER) &&
         (DavEnumNode->lpNetResource == NULL ||
          DavEnumNode->lpNetResource->lpRemoteName == NULL) ) {
        
        // 
        // Return the list of servers that are accessed from this machine.
        // Make sure that only servers accessed from a user's view
        // should be shown.

        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }

        RpcBindSucceeded = TRUE;

        do {

            //
            // If we have already filled in the requested number, we are done.
            // If NumRequested was 0xFFFFFFFF then we try to return as many
            // entries as we can.
            //
            if ( cRequested != ((DWORD)-1 )&& *lpcCount >= cRequested ) {
                NPStatus = WN_SUCCESS;
                DavEnumNode->Done = TRUE;
                goto EXIT_THE_FUNCTION;
            }

            Index = DavEnumNode->Index;

            RpcTryExcept {
                NPStatus = DavrEnumServers(dav_binding_h, &(Index), &(RemoteName), &(AreWeDone));
                if (NPStatus != NO_ERROR) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumServers. NPStatus = "
                                    "%08lx\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                  RPC_STATUS RpcStatus;
                  RpcStatus = RpcExceptionCode();
                  IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavrEnumServers."
                                                " RpcExceptionCode = %d\n", RpcStatus));
                  NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
                  goto EXIT_THE_FUNCTION;
            }
            RpcEndExcept

            //
            // Don't change the if below to if (AreWeDone) because the RPC call
            // can fill in some +ve value in AreWeDone. So the check should be
            // if ( AreWeDone == TRUE ).
            //
            if ( AreWeDone == TRUE ) {
                if ( *lpcCount == 0 ) {
                    //
                    // No net uses at all.
                    //
                    NPStatus = WN_NO_MORE_ENTRIES;
                    DavEnumNode->Done = TRUE;
                } else {
                    NPStatus = WN_SUCCESS;
                    DavEnumNode->Done = TRUE;
                }
                goto EXIT_THE_FUNCTION;
            }
        
            IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: ServerName = %ws\n", RemoteName));
        
            RemoteNameLength = wcslen(RemoteName) + 1;
            DisplayNameLength = wcslen(DavClientDisplayName) + 1;

            //
            // We need to see if the (remaining) buffer size is large enough to
            // hold this entry.
            //

            //
            // Calculate the total length needed for this entry in bytes.
            //
            EntryLengthNeededInBytes = ( sizeof(NETRESOURCEW)                 +
                                         ( RemoteNameLength * sizeof(WCHAR) ) +
                                         ( DisplayNameLength * sizeof(WCHAR) ) );

            //
            // If the value of BufferSizeRemaining is less than the value of
            // EntryLengthNeededInBytes for this entry we do one of two things.
            // If we have already filled atleast one entry into the buffer,
            // we return success, but if we could not even fill in one entry,
            // we return WN_MORE_DATA with BufferSize set to the size in bytes
            // needed to fill in this entry.
            //
            if ( BufferSizeRemaining < EntryLengthNeededInBytes ) {
                if ( *lpcCount == 0 ) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource: NPStatus = WN_MORE_DATA. "
                                    "Supplied=%d, Required=%d\n", 
                                    BufferSizeRemaining, EntryLengthNeededInBytes));
                    NPStatus = WN_MORE_DATA;
                    *lpBufferSize = EntryLengthNeededInBytes;
                    goto EXIT_THE_FUNCTION;
                } else {
                    NPStatus = WN_SUCCESS;
                    goto EXIT_THE_FUNCTION;
                }
            }

            //
            // If we've come till here, it means that the BufferSizeRemaining
            // is large enough to hold this entry. So fill it in the buffer.
            //
            ZeroMemory(lpNROut, sizeof(NETRESOURCEW));

            lpNROut->lpComment = NULL;
            lpNROut->dwScope = RESOURCE_GLOBALNET;

            //
            // Fill in the DisplayName.
            //
            FromEnd -= DisplayNameLength;
            wcscpy(FromEnd, DavClientDisplayName);
            lpNROut->lpProvider = FromEnd;
        
            //
            // When we are enumerating servers, we don't have a LocalName.
            //
            lpNROut->lpLocalName = NULL;
        
            //
            // Fill in the RemoteName.
            //
            FromEnd -= RemoteNameLength;
            wcscpy(FromEnd, RemoteName);
            lpNROut->lpRemoteName = FromEnd;

            lpNROut->dwType = RESOURCETYPE_DISK;
            lpNROut->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
            BufferSizeRemaining -= EntryLengthNeededInBytes;

            //
            // Note: Do not change Index, it is updated inside the rpc 
            // function (DavrEnumServers).
            //
            DavEnumNode->Index = Index;


            //
            // Increment the count of the number of items returned.
            //
            (*lpcCount)++;

            DavDisplayNetResource(lpNROut, L"lpNROut in NPEnumResources(0)");

            //
            // lpNROut now needs to point to the next item in the array.
            //
            lpNROut = (LPNETRESOURCE)lpszNext;
            lpszNext = (PWCHAR)(lpNROut + 1);

            //
            // The memory for RemoteName was allocated by the RPC client stub
            // based on the string returned by the RPC server. We need to free
            // it now since we're done using it.
            //
            MIDL_user_free(RemoteName);
            RemoteName = NULL;

        } while (TRUE);

    } else if (DavEnumNode->DavEnumNodeType == DAV_ENUMNODE_TYPE_SHARE &&
               DavEnumNode->lpNetResource != NULL &&
               DavEnumNode->lpNetResource->lpRemoteName != NULL) {

        //
        // Return list of shares for given UNC server name.
        //

        // 
        // Allocate Memory for ServerName
        //
        ServerNameMaxLen = (MAX_PATH + 1);
        ServerName = LocalAlloc(LPTR, (ServerNameMaxLen * sizeof(WCHAR)));
        if (ServerName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        ServerNameAllocated = TRUE;

        //
        // Note: The remotename here is already converted to valid UNC
        // form in NPOpenEnum function.
        //
        SrvExists = DavServerExists(DavEnumNode->lpNetResource->lpRemoteName,
                                    ServerName);
        if ( !SrvExists ) {
            NPStatus = WN_BAD_HANDLE;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavServerExists.NPStatus = %d\n",
                            NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        ServerName[(ServerNameMaxLen - 1)] = L'\0';

        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavBindTheRpcHandle. NPStatus = %08lx\n",
                            NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }

        RpcBindSucceeded = TRUE;

        do {

            //
            // If we have already filled in the requested number, we are done.
            // If NumRequested was 0xFFFFFFFF then we try to return as many
            // entries as we can.
            //
            if ( cRequested != ((DWORD)-1 )&& *lpcCount >= cRequested ) {
                NPStatus = WN_SUCCESS;
                DavEnumNode->Done = TRUE;
                goto EXIT_THE_FUNCTION;
            }

            Index = DavEnumNode->Index;

            //
            // BUGBUG: We can support enumeration of resources on server. Beside this
            // , we can also support the enumeration of the shares - but we are not doing that
            // for now.
            //
            RpcTryExcept {
                NPStatus = DavrEnumShares(dav_binding_h, &(Index), ServerName, &(RemoteName), &(AreWeDone));
                if (NPStatus != NO_ERROR) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumShares. NPStatus = "
                                    "%08lx\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                  RPC_STATUS RpcStatus;
                  RpcStatus = RpcExceptionCode();
                  IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavrEnumShares."
                                                " RpcExceptionCode = %d\n", RpcStatus));
                  NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
                  goto EXIT_THE_FUNCTION;
            }
            RpcEndExcept

            //
            // Don't change the if below to if (AreWeDone) because the RPC call
            // can fill in some +ve value in AreWeDone. So the check should be
            // if ( AreWeDone == TRUE ).
            //
            if ( AreWeDone == TRUE ) {
                if ( *lpcCount == 0 ) {
                    //
                    // No net uses at all.
                    //
                    NPStatus = WN_NO_MORE_ENTRIES;
                    DavEnumNode->Done = TRUE;
                } else {
                    NPStatus = WN_SUCCESS;
                    DavEnumNode->Done = TRUE;
                }
                goto EXIT_THE_FUNCTION;
            }
        
            IF_DEBUG_PRINT(DEBUG_MISC, ("NPEnumResource: ShareName = %ws\n", RemoteName));
        
            RemoteNameLength = wcslen(RemoteName) + 1;
            DisplayNameLength = wcslen(DavClientDisplayName) + 1;

            //
            // We need to see if the (remaining) buffer size is large enough to
            // hold this entry.
            //

            //
            // Calculate the total length needed for this entry in bytes.
            //
            EntryLengthNeededInBytes = ( sizeof(NETRESOURCEW)                 +
                                         ( RemoteNameLength * sizeof(WCHAR) ) +
                                         ( DisplayNameLength * sizeof(WCHAR) ) );

            //
            // If the value of BufferSizeRemaining is less than the value of
            // EntryLengthNeededInBytes for this entry we do one of two things.
            // If we have already filled atleast one entry into the buffer,
            // we return success, but if we could not even fill in one entry,
            // we return WN_MORE_DATA with BufferSize set to the size in bytes
            // needed to fill in this entry.
            //
            if ( BufferSizeRemaining < EntryLengthNeededInBytes ) {
                if ( *lpcCount == 0 ) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource: NPStatus = WN_MORE_DATA."
                                    "Supplied=%d, Required=%d\n", 
                                    BufferSizeRemaining, EntryLengthNeededInBytes));
                    NPStatus = WN_MORE_DATA;
                    *lpBufferSize = EntryLengthNeededInBytes;
                    goto EXIT_THE_FUNCTION;
                } else {
                    NPStatus = WN_SUCCESS;
                    goto EXIT_THE_FUNCTION;
                }
            }

            //
            // If we've come till here, it means that the BufferSizeRemaining
            // is large enough to hold this entry. So fill it in the buffer.
            //
            ZeroMemory(lpNROut, sizeof(NETRESOURCEW));

            lpNROut->lpComment = NULL;
            lpNROut->dwScope = RESOURCE_SHAREABLE;

            //
            // Fill in the DisplayName.
            //
            FromEnd -= DisplayNameLength;
            wcscpy(FromEnd, DavClientDisplayName);
            lpNROut->lpProvider = FromEnd;
        
            //
            // When we are enumerating shares, we don't have a LocalName.
            //
            lpNROut->lpLocalName = NULL;
        
            //
            // Fill in the RemoteName.
            //
            FromEnd -= RemoteNameLength;
            wcscpy(FromEnd, RemoteName);
            lpNROut->lpRemoteName = FromEnd;

            lpNROut->dwType = RESOURCETYPE_DISK;
            lpNROut->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
            BufferSizeRemaining -= EntryLengthNeededInBytes;

            //
            // Increment the index to point to the next entry to be returned.
            //
            (DavEnumNode->Index)++;

            //
            // Increment the count of the number of items returned.
            //
            (*lpcCount)++;

            DavDisplayNetResource(lpNROut, L"lpNROut in NPEnumResources(1)");

            //
            // lpNROut now needs to point to the next item in the array.
            //
            lpNROut = (LPNETRESOURCE)lpszNext;
            lpszNext = (PWCHAR)(lpNROut + 1);

            //
            // The memory for RemoteName was allocated by the RPC client stub
            // based on the string returned by the RPC server. We need to free
            // it now since we're done using it.
            //
            MIDL_user_free(RemoteName);
            RemoteName = NULL;

        } while (TRUE);

    } else if (DavEnumNode->DavEnumNodeType == DAV_ENUMNODE_TYPE_USE) {

        // 
        // Allocate Memory for ServerName
        //
        ServerNameMaxLen = (MAX_PATH + 1);
        ServerName = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, ServerNameMaxLen*sizeof(WCHAR));
        if (ServerName == NULL ) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/LocalAlloc. NPStatus = %08lx\n", NPStatus));
            goto EXIT_THE_FUNCTION;
        }
        ServerNameAllocated = TRUE;

        NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
        if (NPStatus != ERROR_SUCCESS) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: NPEnumResource/DavBindTheRpcHandle. "
                            "NPStatus = %08lx\n", NPStatus));
            NPStatus = WN_NO_NETWORK;
            goto EXIT_THE_FUNCTION;
        }

        RpcBindSucceeded = TRUE;

        do {

            //
            // If we have already filled in the requested number, we are done.
            // If NumRequested was 0xFFFFFFFF then we try to return as many
            // entries as we can.
            //
            if ( cRequested != ((DWORD)-1) && *lpcCount >= cRequested ) {
                NPStatus = WN_SUCCESS;
                DavEnumNode->Done = TRUE;
                goto EXIT_THE_FUNCTION;
            }

            Index = DavEnumNode->Index;

            RpcTryExcept {
                NPStatus = DavrEnumNetUses(dav_binding_h, &(Index), &(LocalName), &(RemoteName), &(AreWeDone));
                if (NPStatus != NO_ERROR) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource/DavrEnumNetUses. NPStatus = "
                                    "%08lx\n", NPStatus));
                    goto EXIT_THE_FUNCTION;
                }
            } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
                  RPC_STATUS RpcStatus;
                  RpcStatus = RpcExceptionCode();
                  IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPEnumResource/DavrEnumNetUses."
                                                " RpcExceptionCode = %d\n", RpcStatus));
                  NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
                  goto EXIT_THE_FUNCTION;
            }
            RpcEndExcept

            //
            // Don't change the if below to if (AreWeDone) because the RPC call
            // can fill in some +ve value in AreWeDone. So the check should be
            // if ( AreWeDone == TRUE ).
            //
            if ( AreWeDone == TRUE ) {
                if ( *lpcCount == 0 ) {
                    //
                    // No net uses at all.
                    //
                    NPStatus = WN_NO_MORE_ENTRIES;
                    DavEnumNode->Done = TRUE;
                } else {
                    NPStatus = WN_SUCCESS;
                    DavEnumNode->Done = TRUE;
                }
                goto EXIT_THE_FUNCTION;
            }

            IF_DEBUG_PRINT(DEBUG_MISC,
                           ("NPEnumResource: LocalName = %ws, RemoteName = %ws\n",
                            LocalName, RemoteName));

            //
            // The LocalName may or may not exist. If the user does 
            // net use \\server\share, there is no local name.
            //
            if (LocalName == NULL) {
                LocalNameLength = 0;
            } else {
                LocalNameLength = wcslen(LocalName) + 1;
                if (LocalNameLength == 1) {
                    LocalNameLength = 0;
                }
            }

            RemoteNameLength = wcslen(RemoteName) + 1;
            DisplayNameLength = wcslen(DavClientDisplayName) + 1;

            //
            // We need to see if the (remaining) buffer size is large enough to
            // hold this entry.
            //

            //
            // Calculate the total length needed for this entry in bytes.
            //
            EntryLengthNeededInBytes = ( sizeof(NETRESOURCEW)                 +
                                         ( LocalNameLength * sizeof(WCHAR) )  +
                                         ( RemoteNameLength * sizeof(WCHAR) ) +
                                         ( DisplayNameLength * sizeof(WCHAR) ) );

            //
            // If the value of BufferSizeRemaining is less than the value of
            // EntryLengthNeededInBytes for this entry we do one of two things.
            // If we have already filled atleast one entry into the buffer,
            // we return success, but if we could not even fill in one entry,
            // we return WN_MORE_DATA with BufferSize set to the size in bytes
            // needed to fill in this entry.
            //
            if ( BufferSizeRemaining < EntryLengthNeededInBytes ) {
                if ( *lpcCount == 0 ) {
                    IF_DEBUG_PRINT(DEBUG_ERRORS,
                                   ("ERROR: NPEnumResource: NPStatus = WN_MORE_DATA\n"));
                    NPStatus = WN_MORE_DATA;
                    *lpBufferSize = EntryLengthNeededInBytes;
                    goto EXIT_THE_FUNCTION;
                } else {
                    NPStatus = WN_SUCCESS;
                    goto EXIT_THE_FUNCTION;
                }
            }
            ZeroMemory(lpNROut, sizeof(NETRESOURCEW));

            //
            // If we've come till here, it means that the BufferSizeRemaining
            // is large enough to hold this entry. So fill it in the buffer.
            //

            lpNROut->lpComment = NULL;
            lpNROut->dwScope = RESOURCE_CONNECTED;

            //
            // Fill in the DisplayName.
            //
            FromEnd -= DisplayNameLength;
            wcscpy(FromEnd, DavClientDisplayName);
            lpNROut->lpProvider = FromEnd;
        
            //
            // Fill in the LocalName if one exists.
            //
            if ( LocalNameLength != 0 ) {
                FromEnd -= LocalNameLength;
                wcscpy(FromEnd, LocalName);
                lpNROut->lpLocalName = FromEnd;
            }
        
            //
            // Fill in the RemoteName.
            //
            FromEnd -= RemoteNameLength;
            wcscpy(FromEnd, RemoteName);
            lpNROut->lpRemoteName = FromEnd;

            lpNROut->dwType = RESOURCETYPE_DISK;
            lpNROut->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
            BufferSizeRemaining -= EntryLengthNeededInBytes;

            //
            // Increment the index to point to the next entry to be returned.
            //
            (DavEnumNode->Index)++;

            //
            // Increment the count of the number of items returned.
            //
            (*lpcCount)++;
            DavDisplayNetResource(lpNROut, L"lpNROut in NPEnumResources(1)");

            //
            // lpNROut now needs to point to the next item in the array.
            //
            lpNROut = (LPNETRESOURCE)lpszNext;
            lpszNext = (PWCHAR)(lpNROut + 1);
        
            //
            // The memory for RemoteName was allocated by the RPC client stub
            // based on the string returned by the RPC server. We need to free
            // it now since we're done using it.
            //
            MIDL_user_free(RemoteName);
            RemoteName = NULL;
            MIDL_user_free(LocalName);
            LocalName = NULL;

        } while ( TRUE );

    } else {
        
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPEnumResource: DavEnumNodeType = %d\n",
                        DavEnumNode->DavEnumNodeType));
        NPStatus = WN_BAD_HANDLE;
        goto EXIT_THE_FUNCTION;
    
    }

EXIT_THE_FUNCTION:

    //
    // If RPC binding was successfully done, we need to free it now.
    //
    if (RpcBindSucceeded) {
        RpcBindingFree( &(dav_binding_h) );
        RpcBindSucceeded = FALSE;
    }

    if (ServerNameAllocated == TRUE && ServerName != NULL) {
        LocalFree((HLOCAL)ServerName);
        ServerName = NULL;
        ServerNameAllocated = FALSE;
    }

    //
    // The memory for RemoteName was allocated by the RPC client stub
    // based on the string returned by the RPC server. We need to free
    // it now if we came down an error path after calling the server.
    //
    if (RemoteName != NULL) {
        MIDL_user_free(RemoteName);
        RemoteName = NULL;
    }

    //
    // The memory for LocalName was allocated by the RPC client stub
    // based on the string returned by the RPC server. We need to free
    // it now if we came down an error path after calling the server.
    //
    if (LocalName != NULL) {
        MIDL_user_free(LocalName);
        LocalName = NULL;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPEnumResource: NPStatus = %d\n", NPStatus));

    DavDebugBreakPoint();

    return NPStatus;
}

    
DWORD
NPCloseEnum (
    HANDLE hEnum
    )
/*++

Routine Description:

    This routine closes an enumeration and frees up the resources.

Arguments:

    hEnum - This must be a handle obtained from NPOpenEnum call.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is returned, 
                 which may include:
    
    WN_NO_NETWORK - Network is not present. This condition is checked for before 
                    hEnum is tested for validity.
    
    WN_BAD_HANDLE - hEnum is not a valid handle.
    
--*/
{
    DWORD NPStatus = WN_SUCCESS;
    PDAV_ENUMNODE DavEnumNode;
    HLOCAL Handle;
    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPCloseEnum: hEnum = %08lx\n", hEnum));
    
    DavEnumNode = (PDAV_ENUMNODE)hEnum;

    DavDisplayEnumNode(DavEnumNode, L"DavEnumNode in NPCloseEnum");
    //
    // If the hEnum sent in was NULL, we return right away.
    //
    if (DavEnumNode == NULL) {
        return NPStatus;
    }

    if (DavEnumNode->lpNetResource) {

        if (DavEnumNode->lpNetResource->lpRemoteName) {
            //
            // Free the memory we allocated for the RemoteName in NPOpenEnum.
            //
            Handle = LocalFree(DavEnumNode->lpNetResource->lpRemoteName);
            if (Handle != NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCloseEnum/LocalFree: NPStatus ="
                                             " %08lx\n", NPStatus));
            }
            DavEnumNode->lpNetResource->lpRemoteName = NULL;
        }

        //
        // Free the memory we allocated for the NetResource in NPOpenEnum.
        //
        Handle = LocalFree(DavEnumNode->lpNetResource);
        if (Handle != NULL) {
            NPStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCloseEnum/LocalFree: NPStatus ="
                                     " %08lx\n", NPStatus));
        }
        DavEnumNode->lpNetResource = NULL;

    }
    
    //
    // Finally, free the DavEnumNode.
    //
    Handle = LocalFree(DavEnumNode);
    if (Handle != NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPCloseEnum/LocalFree: NPStatus ="
                                     " %08lx\n", NPStatus));
    }
    DavEnumNode = NULL;
    
    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPCloseEnum: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    return NPStatus;
}


DWORD
NPGetResourceInformation(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer,
    LPTSTR *lplpSystem
    )
/*++

Routine Description:

    NPGetResourceInformation determines whether this provider is the right 
    provider to respond to a request for a specified network resource, and 
    returns information about the resource's type. This routine closes an 
    enumeration and frees up the resources.

Arguments:

    lpNetResource - Specifies the network resource for which information is 
                    required. The lpRemoteName field specifies the remote name 
                    of the resource. The calling program should fill in the 
                    values for the lpProvider and dwType fields if it knows 
                    them; otherwise, it should set them to NULL. All other 
                    fields in the NETRESOURCE are ignored and are not initialized.
                    If the lpRemoteName string contains a portion that is 
                    accessed through WNet APIs and a portion that is accessed 
                    through other system APIs specific to the resource type, 
                    the function should only return information about the 
                    network portion of the resource (except for lplpSystem as 
                    described below). For example, if the resource is 
                    "\\server\share\dir1\dir2" where "\\server\share" is 
                    accessed through WNet APIs and "\dir1\dir2" is accessed 
                    through file system APIs, the provider should verify that it 
                    is the right provider for "\\server\share", but need not 
                    check whether "\dir1\dir2" actually exists.
                    
    lpBuffer - A pointer to the buffer to receive the result. The first field in 
               the result is a single NETRESOURCE structure (and associated 
               strings) representing that portion of the input resource that is 
               accessed through WNet APIs, rather than system APIs specific to 
               the resource type. (For example, if the input remote resource 
               name was "\\server\share\dir1\dir2", then the output NETRESOURCE 
               contains information about the resource "\\server\share"). The 
               lpRemoteName, lpProvider, dwType, dwDisplayType and dwUsage 
               fields are returned, all other fields being set to NULL. 
               lpRemoteName should be returned in the same syntax as that 
               returned from an enumeration by the NPEnumResource function, so 
               that the caller can perform a case sensitive string comparison to 
               determine whether the output network resource is the same as one 
               returned by NPEnumResource. The provider should not do purely 
               syntactic checking to determine whether it owns the resource, as 
               this could produce incorrect results when two networks are running 
               on the client and the provider doing syntactic checking is called 
               first.
                
    lpcbBuffer - Points to a location that specifies the size, in bytes, of the 
                 buffer pointed to by lpBuffer. If the buffer is too small for 
                 the result, the function places the required buffer size at 
                 this location and returns the error WN_MORE_DATA.                    

    lplpSystem - On a successful return, points to a string in the output buffer 
                 that specifies the part of the resource that is accessed through 
                 system APIs specific to the resource type rather than WNet APIs. 
                 If there is no such part, lplpSystem is set to NULL. For example, 
                 if the input remote resource name was "\\server\share\dir", then 
                 lpRemoteName is returned pointing to "\\server\share" and 
                 lplpSystem points to "\dir", both strings being stored in the 
                 buffer pointed to by lpBuffer.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, an error code is returned, 
                 which may include:
    
    WN_MORE_DATA - Input buffer is too small.
    
    WN_BAD_NETNAME - The resource is not recognized by this provider.
    
    WN_BAD_VALUE - Invalid dwUsage or dwType.
    
    WN_BAD_DEV_TYPE - The caller passed in a non-zero dwType that does not match 
                      the actual type of the network resource.
    
    WN_NOT_AUTHENTICATED - The caller has not been authenticated to the network.
    
    WN_ACCESS_DENIED - The caller has been authenticated to the network, but 
                       does not have sufficient permissions (access rights).
    
--*/
{
    ULONG NPStatus = WN_SUCCESS;
    BOOL fExists = FALSE;
    DWORD iBackslash = 0;
    LPNETRESOURCEW lpNROut = NULL;
    LPWSTR lpszNext = NULL;
    DWORD cbNeeded = 0, dwDisplayType = 0, cbProvider = 0, cbRemote = 0;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;
    PWCHAR PathPtr = NULL;
    DWORD cbPath = 0;
    
    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetResourceInformation.\n"));
    
    DavDisplayNetResource(lpNetResource, L"lpNetResource in NPGetResourceInformation");
    
    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    // 
    // Validate the parameters passed to the function.
    //
    if ( lpNetResource == NULL               || 
         lpNetResource->lpRemoteName == NULL ||
         lpcbBuffer == NULL                  || 
         lplpSystem == NULL                  || 
         (lpBuffer == NULL && *lpcbBuffer != 0) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation(1). NPStatus = %d.\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if dwType is set and is set to some valid value.
    // It can be only of type RESOURCETYPE_DISK for our provider.
    //
    NPStatus = DavCheckResourceType(lpNetResource->dwType);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation(2). NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Initialize local variables.
    //
    cbNeeded = sizeof(NETRESOURCEW);
    lpNROut = (LPNETRESOURCEW)lpBuffer;
    lpszNext = lpBuffer == NULL? NULL : (LPWSTR)(lpNROut + 1);

    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPGetResourceInformation: lpRemoteName = %ws.\n",
                    lpNetResource->lpRemoteName));

    
    // 
    // Check remote name passed to this function - and convert it to UNC name
    // if it is in URL form. After converting to UNC name - canonicalize it
    // which checks for validity of UNC name more strictly.
    // 
    NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                  &(RemoteName),
                                                  &(didAllocate),
                                                  FALSE,
                                                  &remNameType,
                                                  &(iBackslash),
                                                  TRUE);
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation/DavCheckAndConvertHttpUrlToUncName."
                        " NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    NPStatus = WN_SUCCESS;
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPGetResourceInformation: RemoteName = %ws, NameType=%d\n", 
                    RemoteName, remNameType));

    // 
    // Remote name is successfully converted to a valid UNC form. It is either a 
    // UNC-server name (this is added with DUMMY share), or UNC-share name or UNC-path name.
    //
    
    //
    // Set a few default values.
    //
    if ( *lpcbBuffer >= cbNeeded ) {
        ZeroMemory(lpNROut, sizeof(NETRESOURCEW));
    }
    *lplpSystem = NULL;


    switch (remNameType) {

        case DAV_REMOTENAME_TYPE_SERVER: {

            // 
            // RemoteName = \\server
            // 
            fExists = DavServerExists(RemoteName, NULL);
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            break;
        }
    
        case DAV_REMOTENAME_TYPE_PATH: {

            // 
            // RemoteName = \\server\share\path
            //

            //
            // Set the lplpSystem pointer.
            //
            
            PathPtr = (RemoteName + iBackslash);
            cbPath = ( ( 1 + wcslen(PathPtr) ) * sizeof(WCHAR) );
            cbNeeded += cbPath;
            if (*lpcbBuffer >= cbNeeded ) {
                *lplpSystem = lpszNext;
                wcscpy(*lplpSystem, PathPtr);
                lpszNext += ( cbPath / sizeof(WCHAR));
            }
            
            //
            // Fall through.
            //
        }

        case DAV_REMOTENAME_TYPE_SHARE: {

            // 
            // RemoteName = \\server\share
            //
            
            // 
            // Control comes here for both cases - when remote name is of type
            // UNC-share or UNC-path    AND 
            // when remote name is or type UNC-server. DUMMYShare is added to it
            // above - making it of UNC-share form (\\server\DUMMYShare).
            //
            fExists = DavShareExists(RemoteName);
            dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            break;
        }
        
        default:{
        
            // 
            // Control should not come here. DavCheckAndConvertHttpUrlToUncName
            // returns successful only for valid cases considered above.
            //

            ASSERT(FALSE);
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetResourceInformation: Invalid "
                                         "DavRemoteNameType = %d\n", remNameType));
            NPStatus = WN_BAD_NETNAME;
            goto EXIT_THE_FUNCTION;
        }
    }
    
    // 
    // UNC - server/share do not exists - quit with error.
    //
    if (fExists == FALSE) {
        if (remNameType == DAV_REMOTENAME_TYPE_SERVER) {
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetResourceInformation: Server in"
                                         " path %ws does not do DAV\n", RemoteName));
        } else {
            // 
            // remNameType = DAV_REMOTENAME_TYPE_SHARE
            //
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetResourceInformation: Share in"
                                         " path %ws does not exist\n", RemoteName));
        }
        NPStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Server/Share given in lpRemoteName exists.
    //

    //
    // Set the lpProvider pointer.
    //
    cbProvider = ( (1 + wcslen(DavClientDisplayName) ) * sizeof(WCHAR) );
    cbNeeded += cbProvider;
    if (*lpcbBuffer >= cbNeeded ) {
        lpNROut->lpProvider = lpszNext;
        wcscpy(lpNROut->lpProvider, DavClientDisplayName);
        lpszNext += ( cbProvider / sizeof(WCHAR) );
    }

    //
    // Set the lpRemoteName pointer. If iBackslash (=offset of \dir portion in
    // \\server\share\dir...) is > 0, then the lpRemoteName that was sent has 
    // the form \\server\share\dir... . 
    // If it is = 0, then the RemoteName form is \\server\share or \\server.
    //
    if (iBackslash > 0) {
        //
        // RemoteName = \\server\share\dir
        //                            ^
        //                            |
        //                            iBackslash
        cbRemote = ( (1 + iBackslash) * sizeof(WCHAR) );
        cbNeeded += cbRemote;
        if ( *lpcbBuffer >= cbNeeded ) {
            lpNROut->lpRemoteName = lpszNext;
            RtlCopyMemory( lpNROut->lpRemoteName, RemoteName, (iBackslash * sizeof(WCHAR)) );
            lpNROut->lpRemoteName[iBackslash] = L'\0';
            lpszNext += ( cbRemote / sizeof(WCHAR) );
        }
    } else {
        //
        // RemoteName = \\server\share or  \\server
        //
        cbRemote = ( ( 1 + wcslen(RemoteName) ) * sizeof(WCHAR) );
        cbNeeded += cbRemote;
        if (*lpcbBuffer >= cbNeeded ) {
            lpNROut->lpRemoteName = lpszNext;
            wcscpy(lpNROut->lpRemoteName, RemoteName);
            lpszNext += ( cbRemote / sizeof(WCHAR) );
        }
    }
    
    if ( *lpcbBuffer >= cbNeeded ) {
        //
        // All data is filled and supplied buffer is long enough to contain it.
        //
        lpNROut->dwType = RESOURCETYPE_DISK;
        lpNROut->dwDisplayType = dwDisplayType;
        lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
        NPStatus = WN_SUCCESS;
        DavDisplayNetResource(lpNROut, L"lpNROut in NPGetResourceInformation");
        goto EXIT_THE_FUNCTION;
    } else {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceInformation: Need more "
                        "buffer space. Supplied = %d, Required = %d\n",
                        *lpcbBuffer, cbNeeded));
        *lpcbBuffer = cbNeeded;
        NPStatus = WN_MORE_DATA;
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName != NULL && didAllocate == TRUE) {
        LocalFree(RemoteName);
        RemoteName = NULL;
        didAllocate = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetResourceInformation: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    
    return NPStatus;
}


DWORD
NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD lpcbBuffer
    )
/*++

Routine Description:

    NPGetResourceParent returns the parent of a specified network resource in 
    the browse hierarchy.  This function is typically called for resources that 
    were returned by the same provider from prior calls to NPEnumResource or 
    NPGetResourceInformation.

Arguments:

    lpNetResource - This specifies the network resource whose parent name is 
                    required. The NETRESOURCE could have been obtained via a 
                    previous call to NPEnumResource or NPGetResourceInformation, 
                    or constructed by the caller. The lpRemoteName field 
                    specifies the remote name of the network resource whose 
                    parent is required. The lpProvider field specifies the 
                    provider to call. This must be supplied. The dwType field is 
                    filled in if the calling program knows its value, otherwise 
                    it is set to NULL. All other fields in the NETRESOURCE are 
                    ignored and are not initialized.
                    
    lpBuffer - Points to a buffer to receive the result, which is a single 
               NETRESOURCE structure representing the parent resource. The 
               lpRemoteName, lpProvider, dwType, dwDisplayType and dwUsage 
               fields are returned; all other fields are set to NULL. The output 
               lpRemoteName should be in the same syntax as that returned from 
               an enumeration by NPEnumResource, so that the caller can perform 
               a case sensitive string comparison to determine whether the 
               parent resource is the same as one returned by NPEnumResource. 
               If the input resource syntactically has a parent, the provider 
               can return it, without determining whether the input resource or 
               its parent actually exist. If a resource has no browse parent on 
               the network, then lpRemoteName is returned as NULL. The 
               RESOURCEUSAGE_CONNECTABLE bit in the returned dwUsage field does 
               not necessarily indicate that the resource can currently be 
               connected to, only that the resource is connectable when it is 
               available on the network.
                    
    lpcbBuffer - Points to a location that specifies the size, in bytes, of the 
                 buffer pointed to by lpBuffer. If the buffer is too small for 
                 the result, the function places the required buffer size at 
                 this location and returns the error WN_MORE_DATA.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.
    
    WN_BAD_NETNAME - This provider does not own the resource specified by 
                     lpNetResource (or the resource is syntactically invalid).

    WN_BAD_VALUE - Invalid dwUsage or dwType, or bad combination of parameters 
                   is specified (e.g. lpRemoteName is syntactically invalid for 
                   dwType).

    WN_NOT_AUTHENTICATED - The caller has not been authenticated to the network.

    WN_ACCESS_DENIED - The caller has been authenticated to the network, but 
                       does not have sufficient permissions (access rights).

--*/
{
    ULONG NPStatus = WN_SUCCESS;
    ULONG iBackslash = 0;
    LPNETRESOURCEW lpNROut = NULL;
    LPWSTR lpszNext = NULL;
    DWORD cbNeeded = 0, dwDisplayType = 0, cbProvider = 0;
    PWCHAR RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DAV_REMOTENAME_TYPE remNameType = DAV_REMOTENAME_TYPE_INVALID;
    
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetResourceParent\n"));
    
    DavDisplayNetResource(lpNetResource, L"lpNetResource in NPGetResourceParent");

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    // 
    // Check for validity of the parameters passed to this function.
    //
    if (lpNetResource == NULL               || 
        lpNetResource->lpRemoteName == NULL ||
        lpcbBuffer == NULL                  || 
        (lpBuffer == NULL && *lpcbBuffer != 0)) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent(1). NPStatus = %08lx\n",
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Check if dwType is set and is set to some valid value.
    // It can be only of type RESOURCETYPE_DISK for our provider.
    //
    NPStatus = DavCheckResourceType(lpNetResource->dwType);
    if (NPStatus != WN_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent(2). NPStatus=%d.\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Initialize local variables.
    //
    cbNeeded = sizeof(NETRESOURCEW);
    lpNROut = (LPNETRESOURCEW)lpBuffer;
    lpszNext = lpNROut == NULL ? NULL : (LPWSTR)(lpNROut + 1);
    
    // 
    // Check remote name passed to this function - and convert it to UNC name
    // if it is in URL form. After converting to UNC name - canonicalize it
    // which checks for validity of UNC name more strictly.
    //
    NPStatus = DavCheckAndConvertHttpUrlToUncName(lpNetResource->lpRemoteName,
                                                  &(RemoteName),
                                                  &(didAllocate),
                                                  FALSE,
                                                  &remNameType,
                                                  &(iBackslash),
                                                  TRUE);
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent/DavCheckAndConvertHttpUrlToUncName."
                        " NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    NPStatus = WN_SUCCESS;
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPGetResourceParent : RemoteName = %ws.\n", RemoteName));

    // 
    // Remote name is successfully converted to a valid UNC form. It is either a 
    // UNC-server name, or UNC-share name or UNC-path name.
    //
    
    //
    // Set a few default values.
    //
    if ( *lpcbBuffer >= cbNeeded ) {
        ZeroMemory(lpNROut, sizeof(NETRESOURCEW));
    }

    switch (remNameType) {

        case DAV_REMOTENAME_TYPE_SERVER: {

            //
            // There is no domain concept for DAV servers. So return NULL for lpRemoteName
            // to indicate that server is the top level resource of this provider.
            //
            lpNROut->lpRemoteName = NULL;
            dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
            
            break;
        }

        case DAV_REMOTENAME_TYPE_SHARE: {
            
            // 
            // RemoteName = \\server\share(\)
            //
        
            DWORD Count = 0, cbRemote = 0;
            PWCHAR Ptr1 = NULL;
        
            Ptr1 = wcschr (&(RemoteName[2]), L'\\');

            // 
            // A trick: Share name here can be DAV_DUMMY_SHARE. If that is the case,
            // then \\server\DAV_DUMMY_SHARE is actually <==> \\server in which 
            // case, it has no parent.
            //
            if (_wcsnicmp( (Ptr1 + 1),
                           DAV_DUMMY_SHARE,
                           wcslen(DAV_DUMMY_SHARE) ) == 0) {
                IF_DEBUG_PRINT(DEBUG_MISC,
                               ("NPGetResourceParent. RemoteName has DUMMYShare = %ws\n",
                                RemoteName));
                lpNROut->lpRemoteName = NULL;
                dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
                break;
            }
        
            //  
            // Copy the lpRemoteName.
            //  
            Count = (DWORD) ( Ptr1 - RemoteName );
            cbRemote = (Count + 1) * sizeof(WCHAR);
            cbNeeded += cbRemote;
            if (*lpcbBuffer >= cbNeeded ) {
                lpNROut->lpRemoteName = lpszNext;
                RtlCopyMemory( lpNROut->lpRemoteName, RemoteName, Count * sizeof(WCHAR) );
                lpNROut->lpRemoteName[Count] = L'\0';
                lpszNext += ( cbRemote / sizeof(WCHAR) );
            }
            
            dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            
            break;
        
        }

        case DAV_REMOTENAME_TYPE_PATH: {
            
            // 
            // RemoteName = \\server\share\path\...
            // OR
            // RemoteName = \\server\share\path\...\
            //
            
            DWORD Count = 0, cbRemote = 0;
            PWCHAR Ptr1 = NULL, Ptr2 = NULL, Ptr3 = NULL;
            BOOLEAN LastCharIsWack = FALSE;
            PWCHAR ResourceStart = NULL;

            Ptr3 = &(RemoteName[0]);
            while (Ptr3[0] != L'\0') {
                if (Ptr3[0] == L'\\') {
                        Ptr1 = Ptr2;
                        Ptr2 = Ptr3;
                        Count++;
                }
                Ptr3++;
            }
            
            if (Ptr2[1] == L'\0') {
                LastCharIsWack = TRUE;
                ResourceStart = Ptr1;
            } else {
                ResourceStart = Ptr2;
            }
            
            //
            // After this while loop:
            // \\server\share\pathname\
            //               ^        ^
            //               |        | 
            //               Ptr1     Ptr2
            //  Ptr2 points to last L'\', while Ptr1 points to second last L'\'.
            //  And Count = Number of L'\' in the RemoteName.
            //

            if ((Count < 5) || (Count == 5 && LastCharIsWack == TRUE)) {
                dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            } else {
                dwDisplayType = RESOURCEDISPLAYTYPE_DIRECTORY;
            }

            //  
            // Copy the lpRemoteName.
            //  
            Count = (DWORD) ( ResourceStart - RemoteName);
            cbRemote = (Count + 1) * sizeof(WCHAR);
            cbNeeded += cbRemote;
            if ( *lpcbBuffer >= cbNeeded ) {
                lpNROut->lpRemoteName = lpszNext;
                RtlCopyMemory( lpNROut->lpRemoteName, RemoteName, Count * sizeof(WCHAR) );
                lpNROut->lpRemoteName[Count] = L'\0';
                lpszNext += ( cbRemote / sizeof(WCHAR) );
            }

            break;
        }
        
        default:{
            
            // 
            // Control should not come here - DavCheckAnd... API returns successfully
            // only for valid cases considered above.
            //

            ASSERT(FALSE);
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                            ("ERROR: NPGetResourceParent: Invalid "
                             "DavRemoteNameType = %d\n", remNameType));
            NPStatus = WN_BAD_NETNAME;
            
            goto EXIT_THE_FUNCTION;
        
        }

    }

    //
    // Set the lpProvider pointer.
    //
    cbProvider = ( (1 + wcslen(DavClientDisplayName) ) * sizeof(WCHAR) );
    cbNeeded += cbProvider;
    if ( *lpcbBuffer >= cbNeeded ) {
        lpNROut->lpProvider = lpszNext;
        wcscpy(lpNROut->lpProvider, DavClientDisplayName);
        lpszNext += ( cbProvider / sizeof(WCHAR) );
    }

    // 
    // If supplied buffer is long enough to contain whole data then return success.
    // 
    if ( *lpcbBuffer >= cbNeeded ) {
        lpNROut->dwType = RESOURCETYPE_DISK;
        lpNROut->dwDisplayType = dwDisplayType;
        lpNROut->dwUsage = DavDisplayTypeToUsage(lpNROut->dwDisplayType);
        NPStatus = WN_SUCCESS;
        DavDisplayNetResource(lpNetResource, L"lpNROut in NPGetResourceParent");
        goto EXIT_THE_FUNCTION;
    } else {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetResourceParent: Need more "
                        "buffer space. Supplied = %d, Required = %d\n",
                        *lpcbBuffer, cbNeeded));
        *lpcbBuffer = cbNeeded;
        NPStatus = WN_MORE_DATA;
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    //
    // If RemoteName != NULL && didAllocate == TRUE, then we did allocate memory 
    // for the RemoteName field.
    //
    if (RemoteName != NULL && didAllocate == TRUE) {
        LocalFree(RemoteName);
        RemoteName = NULL;
        didAllocate = FALSE;
    }

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPGetResourceParent: NPStatus = %d\n", NPStatus));
    
    DavDebugBreakPoint();
    return NPStatus;
}


DWORD
NPGetUniversalName(
    IN LPCWSTR lpLocalPath,
    IN DWORD dwInfoLevel,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns the UNC name of the network resource associated with
    a redirected local device.

Arguments:

    lpLocalPath - Specifies the name of the redirected local drive, like
                  W:\bar\foo1.txt
                  
    dwInfoLevel - UniversalName or RemoteName (See the def of WNetGetUniversalName).

    lpBuffer - The NameInfo is filled in if the call is successful.
    
    lpBufferSize - Contains the size of the buffer lpBuffer. If the call fails
                   with WN_MORE_DATA, this contains the size of buffer needed.

Return Value:

    WN_SUCCESS - Success.
    
    WN_NOT_CONNECTED - lpLocalPath is not a redirected local path.
    
    WN_BAD_VALUE - 
    
    WN_MORE_DATA - Buffer was too small.
    
    WN_OUT_OF_MEMORY - Cannot allocate buffer due memory shortage.
    
    WN_NET_ERROR - Other network error.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    DWORD cbNeeded = 0, LocalPathLen = 0, UncNameLen = 0, RemoteNameLen = 0;
    WCHAR localDrive[3]=L"";
    WCHAR CanonName[MAX_PATH+1]=L"";
    ULONG CanonNameSize = sizeof(CanonName);
    ULONG CanonNameLen = 0;
    ULONG CanonNameMaxLen = sizeof(CanonName)/sizeof(WCHAR);
    NET_API_STATUS NetApiStatus = NERR_Success;
    LPUNIVERSAL_NAME_INFO lpUNOut = NULL;
    LPREMOTE_NAME_INFO lpRNOut = NULL;
    PWCHAR lpszNext = NULL, RemoteName = NULL;
    BOOLEAN didAllocate = FALSE;
    DWORD PathType = 0;

    IF_DEBUG_PRINT(DEBUG_ENTRY, 
                   ("NPGetUniversalName: lpLocalPath = %ws, dwInfoLevel = %d"
                    "lpBuffer=0x%x, lpBufferSize=0x%x, *lpBufferSize=%d\n",
                    lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize,
                    lpBufferSize == NULL?-1:*lpBufferSize));
    
    //
    // Initialize local variables
    //
    didAllocate = FALSE;
    lpRNOut = NULL;
    lpUNOut = NULL;
    lpszNext = NULL;
    RemoteName = NULL;
    
    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUniversalName/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check for bad info level.
    //
    if ( (dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL) && (dwInfoLevel != REMOTE_NAME_INFO_LEVEL) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad InfoLevel\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check for validity of the parameters passed to this function.
    //
    if ( lpLocalPath == NULL || lpBufferSize == NULL || (lpBuffer == NULL && *lpBufferSize != 0) ) {
        NPStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad Pointers\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Local path must at least have "X:".
    //
    LocalPathLen = wcslen(lpLocalPath) + 1;
    if ( (LocalPathLen < 3)       ||
         (lpLocalPath[1] != L':') ||
         ((LocalPathLen > 3) && (lpLocalPath[2] != L'\\')) ) {
        NPStatus = WN_BAD_LOCALNAME;
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad LocalPath\n"));
        goto EXIT_THE_FUNCTION;
    }

    // 
    // Canonicalize the local path to take care of invalid forms + 
    // macros expansion like '.' and '..'
    //
    PathType = 0;
    NetApiStatus = I_NetPathCanonicalize(NULL,
                                         (PWCHAR)lpLocalPath,
                                         CanonName,
                                         CanonNameSize,
                                         NULL,
                                         &PathType,
                                         0);
    if ( (NetApiStatus != NERR_Success) || 
         ( (PathType != ITYPE_DEVICE_DISK) && // lpLocalPath=C:
           ( !(PathType & ITYPE_PATH) ||      // lpLocalPath=C:\abc\..\asds
             !(PathType & ITYPE_DPATH) )
           ) ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: NPGetUniversalName/I_NetPathCanonicalize: "
                        "NetApiStatus = %08lx\n", NetApiStatus));
        NPStatus = WN_BAD_LOCALNAME;
        goto EXIT_THE_FUNCTION;
    }

    CanonName[CanonNameMaxLen-1] = L'\0';
    CanonNameLen = wcslen(CanonName) + 1;
    
    //
    // Now onwards, use Canonicalized name instead of lpLocalPath to return more meaningful
    // values.
    //

    localDrive[0]=CanonName[0];
    localDrive[1]=CanonName[1];
    localDrive[2]=L'\0';
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("ERROR: NPGetUniversalName/I_NetPathCanonicalize: "
                                "CanonName= %ws, LocalDrive=%ws\n", CanonName, localDrive));

    //
    // Use the available buffer for storing remote name for now. We will allocate 
    // local copy of remote name later if required.
    //
    RemoteNameLen = (*lpBufferSize)/sizeof(WCHAR);
    NPStatus = NPGetConnection(localDrive, lpBuffer, &RemoteNameLen);
    
    if (NPStatus != WN_MORE_DATA && NPStatus != WN_SUCCESS) {
        //
        // The local drive is not valid for our provider - or some other error occured.
        // Return error.
        //
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName/NPGetConnection: "
                                      "NPStatus = %08lx\n", NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    if ( NPStatus == WN_SUCCESS ) {
        RemoteNameLen = wcslen(lpBuffer) + 1;
        IF_DEBUG_PRINT(DEBUG_MISC,
                       ("ERROR: NPGetUniversalName/NPGetConnection: "
                        "RemoteUncName = %ws, RemoteNameLen = %d\n",
                        lpBuffer, RemoteNameLen));
    }

    // 
    // NPStatus = WN_SUCCESS OR NPStatus = WN_MORE_DATA. In either case cbRemote will
    // have the sizeof(RemoteName-for-local-drive) for given local drive.
    //

    // 
    // UNC path = "RemoteName-for-local-drive" + "RemainingPath-in-local-path"
    // Where RemainingPath-in-local-path is path remaining after removing local-drive
    // portion (ex. "C:") from the local-path.
    // So len(UNC Path) = len(RemoteName) + (CanonNameLen-2).
    // Where subtract=2 denote removing local-drive portion (ex "C:" from localpath).
    // Subtract 1 from RemoteNameLen to remove NULL character from RemoteName,
    // a NULL character is already accounted in CanonName
    //
    UncNameLen = (RemoteNameLen - 1) + (CanonNameLen - 2);
    
    switch (dwInfoLevel) {
    
        case UNIVERSAL_NAME_INFO_LEVEL: {
            
            cbNeeded = sizeof(UNIVERSAL_NAME_INFO);
            lpUNOut = (LPUNIVERSAL_NAME_INFO)lpBuffer;
            lpszNext = lpBuffer == NULL ? NULL:(LPWSTR)(lpUNOut + 1);
            
            //
            // Calculate the bytes we really need = sizeof(STRUCTURE) + sizeof(UNC Path).
            //
            cbNeeded += ((UncNameLen)*sizeof(WCHAR));
            IF_DEBUG_PRINT(DEBUG_MISC, ("ERROR: NPGetUniversalName: BufReq=%d\n", cbNeeded));

            //
            // If the number of bytes that were passed in is not sufficient, we 
            // return WN_MORE_DATA.
            //
            if (*lpBufferSize < cbNeeded) {
                *lpBufferSize = cbNeeded;
                NPStatus = WN_MORE_DATA;
                goto EXIT_THE_FUNCTION;
            }

            // 
            // Create local copy of remote name. Deallocate it in the end.
            //
            ASSERT (RemoteName == NULL);
            RemoteName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                              (RemoteNameLen * sizeof(WCHAR)) ) ;
            if (RemoteName == NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUniversalName/LocalAlloc. NPStatus = %08lx\n", 
                                NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            didAllocate = TRUE;
            wcscpy(RemoteName, lpBuffer);

            ZeroMemory(lpUNOut,sizeof(UNIVERSAL_NAME_INFO));
            //
            // Now, we have enough buffer, copy the information into the buffer.
            //

            lpUNOut->lpUniversalName = lpszNext;
            wcscpy(lpUNOut->lpUniversalName, RemoteName);

            //
            // We concatenate the name afterthe drive letter to the RemoteBuffer
            // we copied above.
            //
            wcscat( lpUNOut->lpUniversalName, (CanonName + 2) );
            NPStatus = WN_SUCCESS;
        
            break;
        }

        case REMOTE_NAME_INFO_LEVEL: {
       
            cbNeeded = sizeof(REMOTE_NAME_INFO);
            lpRNOut = (LPREMOTE_NAME_INFO)lpBuffer;
            lpszNext = lpBuffer == NULL ? NULL:(LPWSTR)(lpRNOut + 1);
        
            //
            // Calculate the bytes we really need = sizeof(STRUCTURE) + sizeof(UNC Path) +
            // sizeof(ConnectionPath) + sizeof(RemainingPath).
            //
            cbNeeded += ( ( UncNameLen    +                           // UNC Path
                            RemoteNameLen +                           // ConnectionPath
                            (CanonNameLen - 2) ) * sizeof(WCHAR) );   // RemainingPath

            IF_DEBUG_PRINT(DEBUG_MISC, ("ERROR: NPGetUniversalName: BufReq=%d\n", cbNeeded));
            //
            // If the number of bytes that were passed in is not sufficient, we 
            // return WN_MORE_DATA.
            //
            if (*lpBufferSize < cbNeeded) {
                *lpBufferSize = cbNeeded;
                NPStatus = WN_MORE_DATA;
                goto EXIT_THE_FUNCTION;
            }

            // 
            // Create local copy of remote name. Deallocate it in the end.
            //
            ASSERT (RemoteName == NULL);
            RemoteName = (PWCHAR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, 
                                                    RemoteNameLen*sizeof(WCHAR)) ;
            if (RemoteName == NULL) {
                NPStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                               ("ERROR: NPGetUniversalName/LocalAlloc. NPStatus = %08lx\n", 
                                NPStatus));
                goto EXIT_THE_FUNCTION;
            }
            didAllocate = TRUE;
            
            wcscpy(RemoteName, lpBuffer);

            ZeroMemory(lpRNOut,sizeof(REMOTE_NAME_INFO));
            
            //
            // Now, we have enough buffer, copy the information into the buffer.
            //

            lpRNOut->lpUniversalName = lpszNext;
            lpszNext += UncNameLen;
            wcscpy(lpRNOut->lpUniversalName, RemoteName);

            //
            // We concatenate the name afterthe drive letter to the RemoteBuffer
            // we copied above.
            //
            wcscat( lpRNOut->lpUniversalName, (CanonName + 2) );
            
            //
            // Copy the connection name.
            //
            lpRNOut->lpConnectionName = lpszNext;
            lpszNext += RemoteNameLen;
            wcscpy(lpRNOut->lpConnectionName, RemoteName);

            //
            // Copy the remaining path.
            //
            lpRNOut->lpRemainingPath = lpszNext;
            wcscpy( lpRNOut->lpRemainingPath, (CanonName+ 2) );
            
            NPStatus = WN_SUCCESS;

            break;
        }

        default: {

            //
            // We should never come here since we make this check above.
            //
            NPStatus = WN_BAD_VALUE ;
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: NPGetUniversalName: Bad InfoLevel\n"));
            ASSERT(FALSE);
            goto EXIT_THE_FUNCTION;
        }
    }

EXIT_THE_FUNCTION:

    if (RemoteName != NULL && didAllocate == TRUE) {
        LocalFree(RemoteName);
        didAllocate = FALSE;
        RemoteName = NULL;
    }

    return NPStatus;
}


DWORD
NPFormatNetworkName(
    LPWSTR lpRemoteName,
    LPWSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    )
/*++

Routine Description:

    This API allows the provider to trim or modify network names before they are 
    presented to the user.

Arguments:

    lpRemoteName - Network name to be formatted.
    
    lpFormattedName - Pointer to string buffer that will receive the formatted 
                      name.
                      
    lpnLength - Pointer to DWORD that specifies the size of the buffer (in 
                characters) passed in.  If the result is WN_MORE_DATA, this will 
                contain the buffer size required (in characters).
                
    dwFlags - Bitfield indicating the type of format being requested. Can be one 
              of:
        
              WNFMT_MULTILINE (0x01) - The provider should place the '\n' 
                                       character where line breaks should appear 
                                       in the name.  The full name should be 
                                       expressed.
 
              WNFMT_ABBREVIATED (0x02) - The provider should ellipsize or 
                                         otherwise shorten the network name such 
                                         that the most useful information will be 
                                         available to the user in the space 
                                         provided.
                                         
              In addition, the following flags may be 'or'ed in and act as 
              modifiers to the above flags:
              
              WNFMT_INENUM (0x10) - The network name is being presented in the 
                                    context of an enumeration where the 
                                    "container" of this object is presented 
                                    immediately prior to this object. This may 
                                    allow network providers to remove redundant 
                                    information from the formatted name, 
                                    providing a less cluttered display for the 
                                    user.

    dwAveCharPerLine - This is the average number of characters that will fit on 
                       a single line where the network name is being presented. 
                       Specifically, this value is defined as the width of the 
                       control divided by the tmAveCharWidth of the TEXTMETRIC 
                       structure from the font used for display in the control.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_MORE_DATA - If input buffer is too small.
    
    All other errors will be ignored by the caller and the unformatted network 
    name will be used.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    ULONG NameLength = 0;
    LPWSTR pszCopyFrom = NULL, pszThird = NULL;

    IF_DEBUG_PRINT(DEBUG_ENTRY,
                   ("NPFormatNetworkName: RemoteName = %ws\n",
                    lpRemoteName));

    //
    // We do some checks before proceeding further.
    //

    if ( (dwFlags & WNFMT_MULTILINE) && (dwFlags & WNFMT_ABBREVIATED) ) {
        NPStatus  = WN_BAD_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    if ( lpRemoteName == NULL || lpnLength == NULL || (lpFormattedName == NULL && (*lpnLength != 0)) ) {
        NPStatus  = WN_BAD_VALUE;
        goto EXIT_THE_FUNCTION;
    }

    pszCopyFrom = lpRemoteName;
    
    if ( (dwFlags & WNFMT_ABBREVIATED) && (dwFlags & WNFMT_INENUM) ) {

        if (lpRemoteName[0] == L'\\' && lpRemoteName[1] == L'\\') {

            pszThird = wcschr( (lpRemoteName + 2), L'\\' );

            if (pszThird != NULL) {

                //
                // In the form "\\server\share" => get the share name.
                //
                pszCopyFrom = (pszThird + 1);

            } else {

                //
                // In the form "\\server" => get rid of "\\".
                //
                pszCopyFrom = (lpRemoteName + 2);

            }

        }

    }

    //
    // Check to see if the supplied buffer is of the required size. If not
    // return WN_MORE_DATA and fill lpnLength with the needed size in the number
    // of chars.
    //
    NameLength = ( wcslen(pszCopyFrom) + 1 );
    if (NameLength > *lpnLength) {
        *lpnLength = NameLength;
        NPStatus  = WN_MORE_DATA;
        goto EXIT_THE_FUNCTION;
    }

    //
    // If we've come, we're ready to copy the name.
    //
    wcsncpy(lpFormattedName, pszCopyFrom, NameLength);

    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("NPFormatNetworkName: lpFormattedName = %ws\n",
                    lpFormattedName));

    NPStatus = WN_SUCCESS;

EXIT_THE_FUNCTION:

    IF_DEBUG_PRINT(DEBUG_EXIT, ("NPFormatNetworkName: NPStatus = %d\n", NPStatus));

    return NPStatus;
}


DWORD
DavMapRpcErrorToProviderError(
    IN DWORD RpcError
    )
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful windows
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{
    switch (RpcError) {

    case RPC_S_UNKNOWN_IF:
    case RPC_S_SERVER_UNAVAILABLE:
    case ERROR_UNEXP_NET_ERR:
    case EPT_S_NOT_REGISTERED:
        return WN_NO_NETWORK;

    case RPC_S_INVALID_BINDING:
    case RPC_X_SS_IN_NULL_CONTEXT:
    case RPC_X_SS_CONTEXT_DAMAGED:
    case RPC_X_SS_HANDLES_MISMATCH:
    case ERROR_INVALID_HANDLE:
        return ERROR_INVALID_HANDLE;

    case RPC_X_NULL_REF_POINTER:
    case ERROR_INVALID_PARAMETER:
        return WN_BAD_VALUE;

    case ERROR_NOACCESS:
    case EXCEPTION_ACCESS_VIOLATION:
        return ERROR_INVALID_ADDRESS;

    case ERROR_OPEN_FILES:
        return WN_OPEN_FILES;

    case ERROR_ALREADY_ASSIGNED:
        return WN_ALREADY_CONNECTED;

    case ERROR_REM_NOT_LIST:
        return WN_BAD_NETNAME;

    case ERROR_BAD_DEVICE:
        return WN_BAD_LOCALNAME;

    case ERROR_INVALID_PASSWORD:
        return WN_BAD_PASSWORD;

    case ERROR_NOT_FOUND:
        return WN_NOT_CONNECTED;

    default:
        return RpcError;
    }
}


DWORD
DavBindTheRpcHandle(
    handle_t *dav_binding_h
    )
/*++

Routine Description:

    This routine binds the RPC handle to the local server.

Arguments:

    dav_binding_h - The pointer to the handle that will be bound to the server
                    in this routine.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

--*/
{
    DWORD WStatus = ERROR_SUCCESS;
    handle_t Handle;

    //
    // Binds the RPC handle to the DAV RPC server.
    //
    WStatus = NetpBindRpc(NULL,
                          L"DAV RPC SERVICE",
                          NULL,
                          &(Handle));
    if (WStatus != RPC_S_OK) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavBindTheRpcHandle/NetpBindRpc. "
                        "WStatus = %08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set the handle that was passed into the function.
    //
    *dav_binding_h = Handle;

EXIT_THE_FUNCTION:

    return WStatus;
}


BOOL
DavWorkstationStarted(
    VOID
    )
/*++

Routine Description:

    This function queries the service controller to see if the Dav client
    service has started.  If in doubt, it returns FALSE.

Arguments:

    None.

Return Value:

    Returns TRUE if the DAV client service has started, FALSE otherwise.

--*/
{
    DWORD WStatus;
    SC_HANDLE ScManager;
    SC_HANDLE Service;
    SERVICE_STATUS ServiceStatus;
    BOOL IsStarted = FALSE;

    ScManager = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT);
    if (ScManager == NULL) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWorkstationStarted/OpenSCManagerW. "
                        "WStatus = %08lx\n", WStatus));
        return FALSE;
    }

    Service = OpenServiceW(ScManager, SERVICE_DAVCLIENT, SERVICE_QUERY_STATUS);
    if (Service == NULL) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWorkstationStarted/OpenServiceW. "
                        "WStatus = %08lx\n", WStatus));
        CloseServiceHandle(ScManager);
        return FALSE;
    }

    if ( !QueryServiceStatus(Service, &ServiceStatus) ) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWorkstationStarted/QueryServiceStatus. "
                        "WStatus = %08lx\n", WStatus));
        CloseServiceHandle(ScManager);
        CloseServiceHandle(Service);
        return FALSE;
    }


    if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING)          ||
         (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING)    ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {
        IF_DEBUG_PRINT(DEBUG_MISC, ("DavWorkstationStarted. WebClient Running!!!\n"));
        IsStarted = TRUE;
    } else {
        IF_DEBUG_PRINT(DEBUG_MISC, ("DavWorkstationStarted. WebClient Stopped!!!\n"));
    }

    CloseServiceHandle(ScManager);
    CloseServiceHandle(Service);

    return IsStarted;
}


DAV_REMOTENAME_TYPE 
DavParseRemoteName (
    IN  LPWSTR  RemoteName,
    OUT LPWSTR  CanonName,
    IN  DWORD   CanonNameSize,
    OUT PULONG  PathStart
    )
/*++

Routine Description:

    This function canonicalizes a remote resource name and determines its type.

Arguments:

    RemoteName - Remote resource name to be parsed: Expects UNC name here.
        
    CanonName - Buffer for canonicalized name, assumed to be MAX_PATH characters 
                long.
        
    CanonNameSize - Size, in bytes, of output buffer.
    
    PathStart - Set to the offset, in characters, of the start
                of the "\path" portion (in the DAV_REMOTENAME_TYPE_PATH case)
                within CanonName.  Not set in other cases. Otherwise set to 0.

Return Value:

    If RemoteName is like    Then return
    ---------------------    ------------
    workgroup                DAV_REMOTENAME_TYPE_WORKGROUP
    \\server                 DAV_REMOTENAME_TYPE_SERVER
    \\server\share           DAV_REMOTENAME_TYPE_SHARE
    \\server\share\path      DAV_REMOTENAME_TYPE_PATH
    (other)                  DAV_REMOTENAME_TYPE_INVALID

--*/
{
    NET_API_STATUS NetApiStatus = NERR_Success;
    DWORD PathType = 0;
    PWCHAR wszDummy = NULL;
    ULONG  ReqLen = 0;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavParseRemoteName: RemoteName = %ws\n", RemoteName));
    
    NetApiStatus = I_NetPathType(NULL, RemoteName, &PathType, 0);
    if (NetApiStatus != NERR_Success) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetPathType: "
                                     "NetApiStatus = %08lx\n", NetApiStatus));
        return DAV_REMOTENAME_TYPE_INVALID;
    }

    if ( PathStart != NULL) {
        *PathStart = 0;
    }
    //
    // I_NetPathType doesn't give us quite as fine a classification of path 
    // types as we need, so we still need to do a little more parsing.
    //
    switch (PathType) {
        
        case ITYPE_PATH_RELND:
            
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavParseRemoteName: ITYPE_PATH_RELND\n"));
            
            //
            // A driveless relative path. A valid workgroup or domain name would be 
            // classified as such, but it still needs to be validated as a workgroup 
            // name.
            //
            NetApiStatus = I_NetNameCanonicalize(NULL,
                                                 RemoteName,
                                                 CanonName,
                                                 CanonNameSize,
                                                 NAMETYPE_WORKGROUP,
                                                 0);
            if (NetApiStatus == NERR_Success) {
                return DAV_REMOTENAME_TYPE_WORKGROUP;
            } else {
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetNameCanonicalize: "
                                             "NetApiStatus = %08lx\n", NetApiStatus));
                return DAV_REMOTENAME_TYPE_INVALID;
            }

            break;

        case ITYPE_UNC_COMPNAME:
            
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavParseRemoteName: ITYPE_UNC_COMPNAME\n"));
            
            //
            // A UNC computername, "\\server".
            //
                
            //
            // HACK: I_NetPathCanonicalize likes "\\server\share" but not
            // "\\server", so append a dummy share name to canonicalize.
            // We assume that the CanonName buffer will still be big
            // enough (which it will, in the calls made from this file).
            //
            ReqLen = wcslen(RemoteName) + 2 + 1;
            wszDummy = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                          (ReqLen * sizeof(WCHAR)) );
            if (wszDummy == NULL) {
                ULONG WStatus = GetLastError();
                IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavParseRemoteName/LocalAlloc. WStatus = %08lx\n", 
                            WStatus));
                return DAV_REMOTENAME_TYPE_INVALID; 
            }
            
            wcscpy(wszDummy, RemoteName);
            wcscat(wszDummy, L"\\a");
            
            PathType = ITYPE_UNC;
            NetApiStatus = I_NetPathCanonicalize(NULL,
                                                 wszDummy,
                                                 CanonName,
                                                 CanonNameSize,
                                                 NULL,
                                                 &PathType,
                                                 0);
            if(wszDummy) {
                LocalFree((HLOCAL)wszDummy);
                wszDummy = NULL;
            }
            if (NetApiStatus != NERR_Success) {
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetPathCanonicalize: "
                                             "NetApiStatus = %08lx\n", NetApiStatus));
                return DAV_REMOTENAME_TYPE_INVALID;
            }
            CanonName[(CanonNameSize/sizeof(WCHAR))-1]=L'\0';

            // 
            // Remove the dummy portion added to remote name = L"\a".
            //
            CanonName[ wcslen(CanonName) - 2 ] = L'\0';
            return DAV_REMOTENAME_TYPE_SERVER;

            break;

        case ITYPE_UNC: {
            
            PWCHAR pShareStart = NULL;
            PWCHAR pPathStart = NULL;
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavParseRemoteName: ITYPE_UNC\n"));
            
            //
            // A UNC path, either "\\server\share" or "\\server\share\path".
            // Canonicalize and determine which one.
            //
            PathType = ITYPE_UNC;
            NetApiStatus = I_NetPathCanonicalize(NULL,
                                                 RemoteName,
                                                 CanonName,
                                                 CanonNameSize,
                                                 NULL,
                                                 &PathType,
                                                 0);
            if (NetApiStatus != NERR_Success) {
                IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName/I_NetPathCanonicalize: "
                                             "NetApiStatus = %08lx\n", NetApiStatus));
                return DAV_REMOTENAME_TYPE_INVALID;
            }
            CanonName[(CanonNameSize/sizeof(WCHAR))-1]=L'\0';
                
            pShareStart = wcschr( (CanonName + 2), DAV_PATH_SEPARATOR );
            //
            // Look for a fourth slash. Also, if the form is \\server\share\,
            // we will have 4 slashes but no extra path. Hence the extra check
            // is made.
            //
            pPathStart = wcschr( (pShareStart + 1), DAV_PATH_SEPARATOR );

            if ( pPathStart != NULL &&  *(pPathStart + 1) != L'\0') {
                if(PathStart) {
                    *PathStart = (ULONG)(pPathStart - CanonName);
                }
                return DAV_REMOTENAME_TYPE_PATH;

            } else {
                if(PathStart) {
                    *PathStart = 0;
                }
                return DAV_REMOTENAME_TYPE_SHARE;
            }
            break;
        }
        default: {
            
            IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavParseRemoteName: Invalid PathType\n"));
            return DAV_REMOTENAME_TYPE_INVALID;
            break;
        }
    } // end switch(PathType);

}


BOOL
DavServerExists(
    IN PWCHAR PathName,
    OUT PWCHAR Server
    )
/*++

Routine Description:

    This function figures out if the Server in the PathName is a valid DAV 
    server.

Arguments:

    PathName - A UNC path (\\server\share\dir....). Assuming that it is a valid string.
               It can be of form \\server OR \\server\share  OR \\server\share\dir...
    
    Server - If non NULL, the server in the PathName is filled in on return.

Return Value:

    TRUE - Valid DAV server and 
    
    FALSE - Its not.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    handle_t dav_binding_h;
    BOOLEAN serverExists = FALSE, RpcBindingSucceeded = FALSE;
    ULONG iBackslash = 0;
    ULONG_PTR ServerLength = 0;
    PWCHAR ServerName = NULL;
    PWCHAR Ptr1 = NULL, Ptr2 = NULL;


    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavServerExists: PathName = %ws\n", PathName));
    
    serverExists = FALSE;

    //
    // The PathName is of the form \\server or \\server\share or \\server\share\path.
    //
    
    ASSERT(PathName[0] == L'\\' && PathName[1] == L'\\');

    Ptr1 = Ptr2 = &(PathName[2]);
    while(Ptr2[0] != L'\\' && Ptr2[0] != L'\0') {
        Ptr2++;
    }

    ServerLength = (ULONG_PTR) ( (Ptr2 - Ptr1) + 1 );
    ServerName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                      (ServerLength * sizeof(WCHAR)) );
    if (ServerName == NULL) {
        ULONG WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavServerExists/LocalAlloc. WStatus = %08lx\n", 
                        WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the chars that make the ServerName.
    //
    RtlCopyMemory(ServerName, Ptr1, (ServerLength-1) * sizeof(WCHAR));
    ServerName[ServerLength-1] = L'\0';

    //
    // We now need to RPC the server name into the DAV service process which
    // figures out if this server is a valid DAV server.
    //

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavServerExists/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    RpcBindingSucceeded = TRUE;

    RpcTryExcept {
        NPStatus = DavrDoesServerDoDav(dav_binding_h, ServerName, &serverExists);
        if (NPStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavServerExists/DavrDoesServerDoDav. "
                            "NPStatus = %08lx\n", NPStatus));
            SetLastError(NPStatus);
            serverExists = FALSE;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;

          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavServerExists/DavrDoesServerDoDav."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          serverExists = FALSE;
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    IF_DEBUG_PRINT(DEBUG_MISC, ("DavServerExists: serverExists = %d\n", serverExists));
    
EXIT_THE_FUNCTION:

    if (ServerName != NULL) {
        //
        // If the Server is not NULL, then we need to copy the ServerName.
        //
        if (Server != NULL) {
            wcscpy(Server, ServerName);
        }
        LocalFree(ServerName);
        ServerName = NULL;
    }

    if (RpcBindingSucceeded) {
        RpcBindingFree( &(dav_binding_h) );
        RpcBindingSucceeded = FALSE;
    }

    return serverExists;
}


BOOL
DavShareExists(
    PWCHAR PathName
    )
/*++

Routine Description:

    This function figures out if the Share in the PathName is a valid DAV 
    share.

Arguments:

    PathName - A UNC path (\\server\share\dir....) : Assuming that this is valid.

Return Value:

    TRUE - Valid DAV share and 
    
    FALSE - Its not.

--*/
{
    DWORD NPStatus = WN_SUCCESS;
    BOOLEAN shareExists = FALSE, RpcBindingSucceeded = FALSE;
    handle_t dav_binding_h;
    PWCHAR ServerName = NULL, ShareName = NULL;
    PWCHAR serverStart = NULL, shareStart = NULL, shareEnd = NULL;
    DWORD count = 0;
    ULONG_PTR ServerLength = 0, ShareLength = 0;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavShareExists: PathName = %ws\n", PathName));

    ASSERT(PathName[0]==L'\\' && PathName[1]==L'\\');
    serverStart = &(PathName[2]);
    shareExists = FALSE;

    //
    // The PathName could be of the following forms.
    // 1. \\server\share OR
    // 2. \\server\share\path
    // We need to extract the share name from the path and find out if its a
    // valid share.
    //
    shareStart = wcschr(serverStart ,L'\\');

    ASSERT(shareStart != NULL);

    //
    // Copy the ServerName to local copy. Last char is for L'\0' char.
    //
    ServerLength = (ULONG_PTR)(shareStart - serverStart) + 1;
    ServerName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                      (ServerLength * sizeof(WCHAR)) );
    if (ServerName == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavShareExists/LocalAlloc. NPStatus = %08lx\n", 
                        NPStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the chars that make the ServerName.
    //
    RtlCopyMemory(ServerName, serverStart, (ServerLength-1) * sizeof(WCHAR));
    ServerName[ServerLength-1] = L'\0';
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: ServerName = %ws\n", ServerName));
    
    //
    // \\server\share\path
    //          ^
    //          |
    //          shareStart
    shareStart++;

    //
    // We need to find out if the PathName is of the form
    // 1. \\server\share OR
    // 2. \\server\share\path
    // If it is of form 1, then wcschr(shareStart, L'\\'); should return NULL
    // and if it is of form 2 wcschr(shareStart, L'\\'); points to the 4th L'\\'.
    //
    shareEnd = shareStart+1;
    while(shareEnd[0] != L'\\' && shareEnd[0] != L'\0') {
        shareEnd++;
    }

    ShareLength = (ULONG_PTR)(shareEnd - shareStart) + 1;
    ShareName = (PWCHAR) LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), 
                                          (ShareLength * sizeof(WCHAR)) );
    if (ShareName == NULL) {
        NPStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavShareExists/LocalAlloc. NPStatus = %08lx\n", 
                         NPStatus));
        goto EXIT_THE_FUNCTION;
    }
    //
    // Copy the chars that make the ShareName.
    //
    RtlCopyMemory(ShareName, shareStart, (ShareLength-1) * sizeof(WCHAR));
    ShareName[ShareLength-1]=L'\0';
    
    IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: ShareName = %ws\n", ShareName));

    //
    // If the share is DAV_DUMMY_SHARE, then we just need to check if server is a 
    // valid DAV server. If it is a DAV server, then return SUCCESS as 
    // DAV_DUMMY_SHARE is only name given to root level of DAV server.
    //
    if ( _wcsicmp(ShareName, DAV_DUMMY_SHARE) == 0 ) {
        IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: DUMMY_SHARE. ShareName=%ws\n", 
                                ShareName));
        if (DavServerExists(PathName, NULL) == TRUE) {
            shareExists = TRUE;
            NPStatus = WN_SUCCESS;
            goto EXIT_THE_FUNCTION;
        } else {
            shareExists = FALSE;
            NPStatus = WN_SUCCESS;
            IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists/DavServerExists: DUMMY_SHARE."
                                    "Server do not exist=%ws\n", PathName));
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // We now need to RPC the server name and the share name into the DAV 
    // service process which figures out if this share is valid share of the 
    // server.
    //

    NPStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (NPStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavShareExists/DavBindTheRpcHandle. "
                        "NPStatus = %08lx\n", NPStatus));
        NPStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }

    RpcBindingSucceeded = TRUE;

    RpcTryExcept {
        NPStatus = DavrIsValidShare(dav_binding_h, ServerName, ShareName, &shareExists);
        if (NPStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavShareExists/DavrIsValidShare. "
                            "NPStatus = %08lx\n", NPStatus));
            SetLastError(NPStatus);
            shareExists = FALSE;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavShareExists/DavrIsValidShare."
                                        " RpcExceptionCode = %d\n", RpcStatus));
          NPStatus = DavMapRpcErrorToProviderError(RpcStatus);
          shareExists = FALSE;
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    IF_DEBUG_PRINT(DEBUG_MISC, ("DavShareExists: shareExists = %d\n", shareExists));
    
EXIT_THE_FUNCTION:

    if (ServerName) {
        LocalFree(ServerName);
        ServerName = NULL;
    }

    if (ShareName) {
        LocalFree(ShareName);
        ShareName = NULL;
    }

    if (RpcBindingSucceeded) {
        RpcBindingFree( &(dav_binding_h) );
        RpcBindingSucceeded = FALSE;
    }
    
    return shareExists;
}


HMODULE
DavInitCredUI(
    PWCHAR RemoteName,
    WCHAR ServerName[CRED_MAX_STRING_LENGTH + 1],
    PFN_CREDUI_CONFIRMCREDENTIALS *pfnCredUIConfirmCredentials,
    PFN_CREDUI_PROMPTFORCREDENTIALS *pfnCredUIPromptForCredentials,
    PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS *pfnCredUICmdlinePromptForCredentials
    )
/*++

Routine Description:

    This function initializes the credential management stuff.

Arguments:

    RemoteName - RemoteName to be mapped.
    
    ServerName - On return, contains the ServerName which is a part of the 
                 RemoteName.
                 
    pfnCredUIGetPassword - On return contains a pointer to the 
                           "CredUIGetPasswordW" function of credui.dll.

Return Value:

    Handle returned by LoadLibrary or NULL.

--*/
{
    PWCHAR StartName = NULL, EndName = NULL;
    DWORD NameLength = 0;
    HMODULE hCredUI = NULL;

    //
    // Assume the first 2 characters are path separators (L'\\').
    //

    StartName = RemoteName + 2;

    EndName = wcschr(StartName, L'\\');

    //
    // If EndName is NULL, it implies that the RemoteName is of the form
    // \\server.
    //
    if (EndName == NULL) {
        EndName = StartName + wcslen(StartName);
    }

    NameLength = (DWORD)(EndName - StartName);

    if ( (NameLength == 0) || (NameLength > CRED_MAX_STRING_LENGTH) ) {
        //
        // The server is either an empty string or has more than the maximum
        // number of characters we support:
        //
        SetLastError(WN_BAD_NETNAME);
        return NULL;
    }

    wcsncpy(ServerName, StartName, NameLength);
    ServerName[NameLength] = L'\0';

    //
    // Load the DLL here and find the function we need.
    //
    hCredUI = LoadLibraryW(L"credui.dll");
    if (hCredUI != NULL) {
        *pfnCredUIConfirmCredentials = (PFN_CREDUI_CONFIRMCREDENTIALS)
                                  GetProcAddress(hCredUI, "CredUIConfirmCredentialsW");

        *pfnCredUIPromptForCredentials = (PFN_CREDUI_PROMPTFORCREDENTIALS)
                                  GetProcAddress(hCredUI, "CredUIPromptForCredentialsW");

        *pfnCredUICmdlinePromptForCredentials = (PFN_CREDUI_CMDLINE_PROMPTFORCREDENTIALS)
                                  GetProcAddress(hCredUI, "CredUICmdLinePromptForCredentialsW");

        if (*pfnCredUIConfirmCredentials == NULL ||
            *pfnCredUIPromptForCredentials == NULL ||
            *pfnCredUICmdlinePromptForCredentials == NULL ) {
            FreeLibrary(hCredUI);
            hCredUI = NULL;
        }
    }

    return hCredUI;
}


DWORD 
DavDisplayTypeToUsage(
    DWORD dwDisplayType
    )
/*++

Routine Description:

    This routine maps the display type to usage type.

Arguments:

    dwDisplayType - The display type to be mapped.

Return Value:

    The Usage Type or 0 if none matches.

--*/
{
    switch (dwDisplayType) {
    
    case RESOURCEDISPLAYTYPE_NETWORK:
    case RESOURCEDISPLAYTYPE_DOMAIN:
    case RESOURCEDISPLAYTYPE_SERVER:
        return RESOURCEUSAGE_CONTAINER;

    case RESOURCEDISPLAYTYPE_SHARE:
        return RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_NOLOCALDEVICE;

    case RESOURCEDISPLAYTYPE_SHAREADMIN:
        return RESOURCEUSAGE_NOLOCALDEVICE;

    default:
        break;
    
    }
    
    return 0L;
}


ULONG
DavCheckResourceType(
   IN DWORD dwType
   )
/*++

Routine Description:

    This routine checks for valid resource types allowed for our provider.
    Currently only RESOURCETYPE_DISK is valid for our resources.

Arguments:

    dwType - Supplies the resource type to be checked for the validity.

Return Value:

    WN_SUCCESS or the appropriate Win32/WNet error code.

--*/
{
    // 
    // Check if dwType is set and is set to some valid value. It can be only of
    // type RESOURCETYPE_DISK for our provider.
    //
    if ( (dwType != RESOURCETYPE_ANY) &&
         (dwType & ~(RESOURCETYPE_PRINT | RESOURCETYPE_DISK)) ){
        return WN_BAD_VALUE;
    }

    if (dwType == RESOURCETYPE_ANY || (dwType & RESOURCETYPE_DISK) ) {
        return WN_SUCCESS;
    } else {
        return WN_BAD_DEV_TYPE;
    }
}


ULONG
DavCheckLocalName(
    IN PWCHAR LocalName
    )
/*++

Routine Description:

    This only handles NULL, empty string, and L"X:" formats.

Arguments:

    LocalName - Supplies the local device name to map to the created tree
                connection.  Only drive letter device names are accepted.  (No
                LPT or COM).

Return Value:

    WN_SUCCESS or the appropriate Win32/WNet error code.

--*/
{
    DWORD LocalNameLength;

    LocalNameLength = ( LocalName == NULL ) ? 0 : wcslen( LocalName );

    if (LocalNameLength != 2 || !iswalpha(*LocalName) || LocalName[1] != L':') {
        return WN_BAD_LOCALNAME;
    }

    return WN_SUCCESS;
}


ULONG
DavCheckAndConvertHttpUrlToUncName(
    IN PWCHAR RemoteName,
    OUT PWCHAR *UncRemoteName,
    OUT PBOOLEAN MemoryAllocated,
    IN BOOLEAN AddDummyShare,
    OUT PDAV_REMOTENAME_TYPE premNameType,
    OUT LPDWORD pathOffset,
    IN BOOLEAN bCanonicalize
    )
/*++

Routine Description:

    This routine checks to see if the name is valid (atleast 3 chars long). It
    then converts a Http URL (if the remote name was one) into a UNC name. Its 
    possible that the NP APIs get called with the URLs as RemoteNames. We need 
    to convert them to UNC before proceeding further. It also adds a dummy share
    DavWWWRoot if one was not supplied with the request. This is because its 
    possible to map a drive to the root of the DAV server.

Arguments:

    RemoteName - The Http URL that came in. An important thing to note is that 
                 this need not be a HTTP URL. If its not, then we don't do any 
                 conversion.
    
    UncRemoteName - The UNC name that is returned to the caller. The returned 
                    name will have the format \\server\share.
                    
    MemoryAllocated - TRUE if memory was allocated for the returned UNC name.                    

    AddDummyShare - If TRUE, and the RemoteName is \\server or http://server,
                    a dummy share DavWWWRoot is added to the UNC name.

    premNameType - Pointer to location to receive the type of UNC path returned by 
                   I_NetPathType/Canonicalization. If NULL, no value is set.
                   This has meaning only when Canonicalization is done.

    pathOffset - Offset of "\path" in remotename when remotename is of type 
                 \\server\share\path... . Otherwise it is zero. If NULL, no value
                 is set. This has meaning only when Canonicalization is done.
                 
    bCanonicalize - IF TRUE, the remote name returned from URL to UNC will be 
                    canonicalized before return.

Return Value:

    ERROR_SUCCESS or the appropriate Win32 error code.

Notes: 

       This function returns WN_BAD_NETNAME also for remotes names which are 
       correct in syntax but have length > MAX_PATH.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PWCHAR ReturnedUncName = NULL, TempName = NULL, SrvName = NULL;
    PWCHAR CanonicalName = NULL, ColonPtr = NULL;
    BOOLEAN didAllocate = FALSE;
    ULONG ReturnedUncNameLen = 0, index = 0, DummyShareNameLen = 0, CanonicalNameMaxLen = 0;

    if (MemoryAllocated == NULL || UncRemoteName == NULL) {
        WStatus = WN_BAD_VALUE;
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName: (MemoryAllocated"
                        " == NULL || UncRemoteName == NULL)\n"));
        goto EXIT_THE_FUNCTION;
    }

    *UncRemoteName = NULL;
    *MemoryAllocated = FALSE;
    if(pathOffset != NULL) {
        *pathOffset = 0;
    }

    // 
    // 1. First we will check if this is a URL form remotename. If this is, then
    //    we will convert it to UNC name. 
    // 2. After converting to UNC name, we will add DummyShare name depending on
    //    parameter value passed to this function.
    // 3. After this, we will canonicalize the converted UNC name depending on
    //    the parameter value passed to this function.
    //

    //
    // If RemoteName is NULL, we have nothing to do.
    //
    if (RemoteName == NULL) {
        WStatus = WN_BAD_NETNAME;
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName: RemoteName == NULL\n"));
        goto EXIT_THE_FUNCTION;
    }

    //
    // The remote name must be atleast 3 chars long. It cannot be \\.
    //
    if ( wcslen(RemoteName) < 3 ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName: wcslen(RemoteName) < 3\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Check to see if the remote name being suppiled is http:.
    //
    //
    // We could get the names in the following formats.
    // 1. http://servername/sharename OR
    // 2. \\http://servername/sharename OR
    // 3. http://servername OR
    // 4. \\http://servername
    // 5. \\servername.....
    //
    
    SrvName = NULL;
    ColonPtr = wcschr(RemoteName, L':');
    
    if( (ColonPtr != NULL) && 
        ( (ColonPtr - RemoteName == 4) || (ColonPtr - RemoteName == 6)) ) {
        if( (RemoteName[0] == L'\\') && (RemoteName[1] == L'\\') && 
            (_wcsnicmp((RemoteName + 2), L"http:", 5) == 0) )  {
            //
            // RemoteName is \\HTTP name. \\http://server....
            //
            SrvName = (RemoteName + 7);
        } else if (_wcsnicmp(RemoteName, L"http:", 5) == 0) {
            //
            // RemoteName is HTTP name. http://server....
            //
            SrvName = (RemoteName + 5);
        } else {
            IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName(1): Invalid URL string\n"));
            WStatus = WN_BAD_NETNAME;
            goto EXIT_THE_FUNCTION;
        }
    } else if (RemoteName[0] == L'\\' && RemoteName[1] == L'\\') {
        //
        // RemoteName is UNC name
        //
        SrvName = RemoteName;
    } else {
        // 
        // RemoteName is neither "http://..." name NOR UNC name.
        //
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName(1): Invalid remote string\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT (SrvName != NULL);

    // 
    // SrvName is pointing to start of servername portion. Servername portion 
    // can be of type L"\\..." or L"//...".
    //
    
    //
    // Our parsing code below that converts the supplied http name into
    // a UNC name looks at the first charactter to decide the format.
    // We need to add the additional \\ in front of http to fool shell
    // into sending the http name to us.
    //

    ReturnedUncNameLen = wcslen( SrvName ) ;
    if ( ( ReturnedUncNameLen < 3 )                    || 
         ( SrvName[0] != L'\\' && SrvName[0] != L'/' ) || 
         ( SrvName[1] != L'\\' && SrvName[1] != L'/' ) ) {
        //
        // The following cases will be eliminated here.
        // 1. http:// 2. http:/aaa 3. \aaa 4. aaaa
        //
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName(2): Invalid URL string\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // We will allocate space for DAV_DUMMY_SHARE in this name so that
    // if we are to add the Dummy name later, we don't have to reallocate memory
    // for new name with Dummy share. String that will be added = L"\dummyshare"
    // 
    if (AddDummyShare == TRUE) {
        DummyShareNameLen = 1 + wcslen (DAV_DUMMY_SHARE);
    }

    ReturnedUncName = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                  ( (ReturnedUncNameLen +
                                     DummyShareNameLen + 
                                     1) * sizeof(WCHAR) ) );
    if (ReturnedUncName == NULL) {
        WStatus = GetLastError();
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName/LocalAlloc. "
                        "WStatus = %08lx\n", WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to keep track of the fact that we allocated memory in this
    // routine.
    //
    didAllocate = TRUE;

    //
    // Copy the name in the UNC format. Replace '/' by '\'.
    //
    for (index = 0; index < ReturnedUncNameLen; index++) {
        if (SrvName[index] == L'/') {
            ReturnedUncName[index] = L'\\';
        } else {
            ReturnedUncName[index] = SrvName[index];
        }
    }
    ReturnedUncName[ReturnedUncNameLen] = L'\0';

    //
    // If the final char of the RemoteName is a '\' or a '/' remove it. For 
    // some reason, the DAV servers do not like a / at the end.
    //
    if ( ReturnedUncName[ReturnedUncNameLen - 1] == L'/' ||
         ReturnedUncName[ReturnedUncNameLen - 1] == L'\\' ) {
        ReturnedUncName[ReturnedUncNameLen - 1] = L'\0';
        ReturnedUncNameLen--;
    }
    
    if ( ReturnedUncNameLen < 3) {
        //
        // The following cases will be eliminated here.
        // 1. http:/// 2. \\\
        // 
        IF_DEBUG_PRINT(DEBUG_ERRORS, 
                       ("ERROR: DavCheckAndConvertHttpUrlToUncName(3): Invalid remote string\n"));
        WStatus = WN_BAD_NETNAME;
        goto EXIT_THE_FUNCTION;
    }

    // 
    // At this point, any URL remotename is already converted to UNC name.
    //

    //
    // Add the dummy share only if we were asked to.
    //
    if (AddDummyShare == TRUE) {

        //
        // If the format is \\server, we need to add a dummy share just to get 
        // through the file system since it does not understand a CreateFile on a 
        // server name. This is valid in case of a DAV server since \\server maps
        // to the root http://www.foo.com/.
        //
        TempName = wcschr( &(ReturnedUncName[2]), L'\\' );
        if (TempName == NULL) {

            //
            // We need to add a dummy share. We are assuming that space for
            // storing DAV_DUMMY_SHARE name is already allocated above.
            //
            ReturnedUncName[ReturnedUncNameLen] = L'\\';
            ReturnedUncName[ReturnedUncNameLen+1] = L'\0';
            wcscpy( &(ReturnedUncName[ReturnedUncNameLen+1]), DAV_DUMMY_SHARE );
            ReturnedUncNameLen += DummyShareNameLen;
            ReturnedUncName[ReturnedUncNameLen] = L'\0';
        }
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC, 
                   ("DavCheckAndConvertSrvNameUrlToUncName: RemoteName = %ws\n",
                    ReturnedUncName));

    // 
    // At this point, any URL remotename is already converted to UNC name + 
    // DAV_DUMMY_SHARE is added to the remote name (if asked so).
    //

    if (bCanonicalize == TRUE) {
        
        DAV_REMOTENAME_TYPE nameType = DAV_REMOTENAME_TYPE_INVALID;
        
        // 
        // Allocate another buffer to contain canonicalize name
        //
        CanonicalName = NULL;
        CanonicalNameMaxLen = MAX_PATH + 1;
        CanonicalName = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT),
                                  ( CanonicalNameMaxLen * sizeof(WCHAR) ) );
        if (CanonicalName == NULL) {
            WStatus = GetLastError();
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName/LocalAlloc. "
                        "WStatus = %08lx\n", WStatus));
            goto EXIT_THE_FUNCTION;
        }
        
        nameType = DavParseRemoteName (ReturnedUncName,
                                       CanonicalName,
                                       (CanonicalNameMaxLen * sizeof(WCHAR)),
                                       pathOffset);
        
        CanonicalName[(CanonicalNameMaxLen - 1)] = L'\0';

        // 
        // We will allow only UNC names of type UNC-server, UNC-share or 
        // UNC-path to pass from this function. All other type of names returned
        // from canonicalization will rejected (function will return failure
        // status) as INVALID_NAMES.
        //
        if (nameType != DAV_REMOTENAME_TYPE_SERVER && 
            nameType != DAV_REMOTENAME_TYPE_SHARE &&
            nameType != DAV_REMOTENAME_TYPE_PATH) {
            WStatus = WN_BAD_NETNAME;
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavCheckAndConvertSrvNameUrlToUncName/DavParseRemoteName. "
                            "nameType = %d\n", nameType));
            goto EXIT_THE_FUNCTION;
        }
        
        // 
        // Free the previous buffer allocate in ReturnedUncName and point
        // this variable to new canonical name just allocated here.
        //
        LocalFree((HLOCAL)ReturnedUncName);
        ReturnedUncName = NULL;
        ReturnedUncNameLen = 0;
        didAllocate = FALSE;
        
        ReturnedUncName = CanonicalName;
        ReturnedUncNameLen = wcslen(CanonicalName);
        didAllocate = TRUE;
        CanonicalName = NULL;
            
        if (premNameType != NULL) {
            *premNameType = nameType;
        }
    
    }

    if ( ReturnedUncNameLen > MAX_PATH ) {
        WStatus = WN_BAD_NETNAME;
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavCheckAndConvertSrvNameUrlToUncName. ReturnedUncNameLen=%d ",
                        ReturnedUncNameLen));
        goto EXIT_THE_FUNCTION;
    }

    *UncRemoteName = ReturnedUncName;
    *MemoryAllocated = didAllocate;
    WStatus = ERROR_SUCCESS;

EXIT_THE_FUNCTION:

    if (WStatus != ERROR_SUCCESS) {
        if (ReturnedUncName && didAllocate) {
            LocalFree(ReturnedUncName);
            ReturnedUncName = NULL;
            didAllocate = FALSE;
        }
        if (CanonicalName != NULL) {
            LocalFree(CanonicalName);
            CanonicalName = NULL;
        }
    }

    return WStatus;
}


DWORD
WINAPI
DavWinlogonLogonUserEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs on to the system.

Arguments:

    lpParam - This is of no interest to us.

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavWinlogonLogonUserEvent: Entered\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogonUserEvent/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    WStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (WStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogonUserEvent/DavBindTheRpcHandle. "
                        "WStatus = %08lx\n", WStatus));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        WStatus = DavrWinlogonLogonEvent(dav_binding_h);
        if (WStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavWinlogonLogonUserEvent/DavrWinlogonLogonEvent. "
                            "WStatus = %08lx\n", WStatus));
            SetLastError(WStatus);
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS,
                         ("ERROR: DavWinlogonLogonUserEvent/DavrWinlogonLogonEvent. "
                          " RpcExceptionCode = %d\n", RpcStatus));
          WStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
    }

    return WStatus;
}


DWORD
WINAPI
DavWinlogonLogoffUserEvent(
    LPVOID lpParam
    )
/*++

Routine Description:

    The routine is called by winlogon when a user logs off the system.

Arguments:

    lpParam - This is of no interest to us.

Returns:

    ERROR_SUCCESS if all went well, otherwise the appropriate error code.

Notes:

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;

    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavWinlogonLogoffUserEvent: Entered\n"));

    //
    // If the WebClient service is not running we bail out right away.
    //
    if ( !DavWorkstationStarted() ) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogoffUserEvent/DavWorkstationStarted. "
                        "Service NOT Running\n"));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    
    WStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (WStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavWinlogonLogoffUserEvent/DavBindTheRpcHandle. "
                        "WStatus = %08lx\n", WStatus));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        WStatus = DavrWinlogonLogoffEvent(dav_binding_h);
        if (WStatus != NO_ERROR) {
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavWinlogonLogoffUserEvent/DavrWinlogonLogoffEvent. "
                            "WStatus = %08lx\n", WStatus));
            SetLastError(WStatus);
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS,
                         ("ERROR: DavWinlogonLogoffUserEvent/DavrWinlogonLogoffEvent. "
                          " RpcExceptionCode = %d\n", RpcStatus));
          WStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
    }

    return WStatus;
}


VOID 
DavDisplayNetResource(
    LPNETRESOURCE netRes, 
    LPWSTR dispMesg
    )
/*++

Routine Description:

    The routine prints out the contents of an NetResource and a display message.

Arguments:

    netRes - The NetResource whose contents will be printed out.
    
    dispMesg - The caller can use this to identify itself.

Returns:

    None.

--*/
{

    if(dispMesg != NULL ) {
        IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavDisplayNetResource: Entered: %ws\n", dispMesg));
    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("netRes = 0x%x\n", netRes));

    if (netRes == NULL) {
        return;
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("netRes->[dwScope = 0x%x , dwType = 0x%x ,"
                    " dwUsage = 0x%x , dwDisplayType = 0x%x]\n", 
                    netRes->dwScope, netRes->dwType, netRes->dwUsage,
                    netRes->dwDisplayType));

    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("netRes->[dwLocalName = %ws , dwRemoteName = %ws  ,"
                    " dwComment = %ws , dwProvider = %ws]\n",
                    netRes->lpLocalName, netRes->lpRemoteName, netRes->lpComment,
                    netRes->lpProvider));

    return;
}


VOID 
DavDisplayEnumNode(
    PDAV_ENUMNODE enumNode, 
    LPWSTR dispMesg
    )
/*++

Routine Description:

    The routine prints out the contents of an enumNode and a display message.

Arguments:

    enumNode - The enumNode whose contents will be printed out.
    
    dispMesg - The caller can use this to identify itself.

Returns:

    None.

--*/
{

    if(dispMesg != NULL ) {
        IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavDisplayEnumNode: Entered: %ws\n", dispMesg));
    }

    IF_DEBUG_PRINT(DEBUG_MISC, ("enumNode = 0x%x\n", enumNode));
    
    if (enumNode == NULL) {
        return;
    }
    
    IF_DEBUG_PRINT(DEBUG_MISC,
                   ("enumNode->[dwScope = 0x%x , dwType = 0x%x ,"
                    " dwUsage = 0x%x , DavEnumNodeType = %d ,"
                    " Done = %d , Index = %d]\n", 
                    enumNode->dwScope, enumNode->dwType, enumNode->dwUsage,
                    enumNode->DavEnumNodeType, enumNode->Done,
                    enumNode->Index));

    DavDisplayNetResource(enumNode->lpNetResource, L"lpNetResource in enumNode");

    return;
}


VOID DavDebugBreakPoint(
    VOID
    )
/*++

Routine Description:

    The routine is used for debugging purposes to add breakpoints where needed.

Arguments:

    None.

Returns:

    None.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("DavDebugBreakPoint.\n"));
    return;
}


DWORD
APIENTRY
DavGetDiskSpaceUsage(
    LPWSTR lptzLocation,
    DWORD *lpdwSize,
    ULARGE_INTEGER *lpMaxSpace,
    ULARGE_INTEGER *lpUsedSpace
    )
/*++

Routine Description:

    Finds out the amount of disk being consumed by wininet urlcache due to
    Webdav.

Arguments:

    lptzLocation - Buffer to return Cache location string. As much of the
                   location string as can fit in the buffer is returned.
    
    lpdwSize - Size of the cache location buffer. On return this will contain
               the actual size of the location string. 
                    
    lpMaxSpace - Size of disk Quota set for webdav.

    lpUsedSpace - Size of disk consumed by the urlcache used by webdav.
    
Return Value:

    Win32 error code.

--*/
{
    DWORD dwError;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    WCHAR Buffer[MAX_PATH];
    DWORD dwSize;
        
    dwError = DavBindTheRpcHandle( &(dav_binding_h) );
    if (dwError != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavrDiskSpaceUsage/DavBindTheRpcHandle. "
                        "dwError = %08lx\n", dwError));
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;
    
    RpcTryExcept {
        dwError = DavrGetDiskSpaceUsage(dav_binding_h, Buffer, MAX_PATH, &dwSize, lpMaxSpace, lpUsedSpace);
        if (dwError == ERROR_SUCCESS) {
            memset(lptzLocation, 0, *lpdwSize);
            memcpy(lptzLocation, Buffer, min(*lpdwSize, dwSize));
            *lpdwSize = dwSize;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        RPC_STATUS RpcStatus;
        RpcStatus = RpcExceptionCode();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavrGetDiskSpaceUsage/DavrGetDiskSpaceUsage."
                                            " RpcExceptionCode = %d\n", RpcStatus));
        dwError = DavMapRpcErrorToProviderError(RpcStatus);
        goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    return dwError;    
}


DWORD
APIENTRY
DavFreeUsedDiskSpace(
    DWORD dwPercent
    )
/*++

Routine Description:

    Frees up dwPercent of the local persistent cache.

Arguments:

    dwPercent - A number between 0 and 100.

Returns:

    ERROR_SUCCESS if successful, else returns the win32 errorcode.

--*/
{
    DWORD dwError;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    
    dwError = DavBindTheRpcHandle( &(dav_binding_h) );
    if (dwError != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavFreeUsedDiskSpace/DavBindTheRpcHandle. "
                        "dwError = %08lx\n", dwError));
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;
    
    RpcTryExcept {
        DavrFreeUsedDiskSpace(dav_binding_h, dwPercent);
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
        RPC_STATUS RpcStatus;
        RpcStatus = RpcExceptionCode();
        IF_DEBUG_PRINT(DEBUG_ERRORS, ("ERROR: DavFreeUsedDiskSpace/DavrFreeUsedDiskSpace."
                                            " RpcExceptionCode = %d\n", RpcStatus));
        dwError = DavMapRpcErrorToProviderError(RpcStatus);
        goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
        bindRpcHandle = FALSE;
    }

    return dwError;    
}


DWORD
DavGetTheLockOwnerOfTheFile(
    IN PWCHAR FileName,
    OUT PWCHAR LockOwnerName,
    IN OUT PULONG LockOwnerNameLengthInBytes
    )
/*++

Routine Description:

    This routine is called by applications to find out who owns the LOCK on
    a particular file. When the CreateFile call fails with ERROR_LOCK_VIOLATION
    applications can call this API to find out who the owner is and display 
    that information to the user.

Arguments:

    FileName - The name of the file which is LOCKed on the server. The caller
               fills in this value. This should be a NULL terminated string. So,
               ((1 + wcslen(FileName)) * sizeof(WCHAR)) should give the length
               of the FileName (including the final L'\0' char) in bytes.

    LockOwnerName - On success, the API fills in the name of the person who owns
                    the LOCK on the file. The caller is responsible for
                    allocating memory for this pointer.

    LockOwnerNameLengthInBytes - Contains the length of the LockOwnerName
                                 buffer in bytes. If the buffer length is not
                                 enough to fill in the LockOwners name, the
                                 return value is ERROR_INSUFFICIENT_BUFFER
                                 and this pointer contains the size of the
                                 buffer needed.

Returns:

    ERROR_SUCCESS - The call was successful. The LockOwnerName buffer contains
                    the name of the person who owns the lock.

    ERROR_INSUFFICIENT_BUFFER - The LockOwnerName buffer was not of the
                                required length. LockOwnerNameLengthInBytes
                                contains the length in bytes needed to hold
                                this buffer.

    Some other Win32 error code.                                

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    BOOL bindRpcHandle = FALSE;
    handle_t dav_binding_h;
    PWCHAR OutputBuffer = NULL;
    ULONG OutputBufferLengthInBytes = 0, count = 0;

    //
    // Perform some basic checks first.
    //

    if (FileName == NULL) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    if ( (LockOwnerName == NULL) && (*LockOwnerNameLengthInBytes != 0) ) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    WStatus = DavBindTheRpcHandle( &(dav_binding_h) );
    if (WStatus != ERROR_SUCCESS) {
        IF_DEBUG_PRINT(DEBUG_ERRORS,
                       ("ERROR: DavGetTheLockOwnerOfTheFile/DavBindTheRpcHandle. "
                        "WStatus = %08lx\n", WStatus));
        WStatus = WN_NO_NETWORK;
        goto EXIT_THE_FUNCTION;
    }
    bindRpcHandle = TRUE;

    RpcTryExcept {
        WStatus = DavrGetTheLockOwnerOfTheFile(dav_binding_h, FileName, &(OutputBuffer));
        if (WStatus != NO_ERROR) {
            //
            // We have supplied a buffer that should be big enough for any
            // LockOwner string. Hence we should never get back the following
            // error code.
            //
            ASSERT(WStatus != ERROR_INSUFFICIENT_BUFFER);
            IF_DEBUG_PRINT(DEBUG_ERRORS,
                           ("ERROR: DavGetTheLockOwnerOfTheFile/DavrGetTheLockOwnerOfTheFile. "
                            "WStatus = %08lx\n", WStatus));
            SetLastError(WStatus);
            goto EXIT_THE_FUNCTION;
        }
    } RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
          RPC_STATUS RpcStatus;
          RpcStatus = RpcExceptionCode();
          IF_DEBUG_PRINT(DEBUG_ERRORS,
                         ("ERROR: DavGetTheLockOwnerOfTheFile/DavrGetTheLockOwnerOfTheFile. "
                          " RpcExceptionCode = %d\n", RpcStatus));
          WStatus = DavMapRpcErrorToProviderError(RpcStatus);
          goto EXIT_THE_FUNCTION;
    }
    RpcEndExcept

    OutputBufferLengthInBytes = ( (1 + wcslen(OutputBuffer)) * sizeof(WCHAR) );

    //
    // Make sure that the buffer supplied by the caller is large enough to hold
    // the LockOwner string. If its not, fill in the needed bytes in the
    // LockOwnerNameLengthInBytes pointer and retrun the error code
    // ERROR_INSUFFICIENT_BUFFER.
    //
    if ( (LockOwnerName == NULL) || (OutputBufferLengthInBytes > *LockOwnerNameLengthInBytes) ) {
        WStatus = ERROR_INSUFFICIENT_BUFFER;
        *LockOwnerNameLengthInBytes = OutputBufferLengthInBytes;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Copy the LockOwner in the LockOwnerName buffer supplied by the
    // caller.
    //
    wcsncpy(LockOwnerName, OutputBuffer, OutputBufferLengthInBytes);

    WStatus = ERROR_SUCCESS;

EXIT_THE_FUNCTION:

    if (bindRpcHandle) {
        RpcBindingFree( &(dav_binding_h) );
    }

    //
    // The memory for OutputBuffer was allocated by the RPC client stub
    // based on the string returned by the RPC server. We need to free
    // it now if we came down an error path after calling the server.
    //
    if (OutputBuffer != NULL) {
        MIDL_user_free(OutputBuffer);
        OutputBuffer = NULL;
    }

    return WStatus;
}


//
// The functions below are a part of the NP spec but have NOT been implemented
// by the DAV NP. We do not claim to support these in the NPGetCaps function.
//

#if 0

DWORD
NPGetPropertyText(
    DWORD iButtonDlg,
    DWORD nPropSel,
    LPTSTR lpFileName,
    LPTSTR lpButtonName,
    DWORD cchButtonName,
    DWORD nType
    )
/*++

Routine Description:

    This function is used to determine the names of buttons added to a property 
    dialog for some particular resources. It is called every time such a dialog 
    is brought up, and prior to displaying the dialog. If the user clicks a 
    button added through this API by the Winnet provider, NPPropertyDialog will 
    be called with the appropriate parameters.

Arguments:

    iButtonDlg - Indicates the index (starting at 0) of the button. The File 
                 Manager will support at most 6 buttons. The parameter is 
                 numbered 1-6 for each of the possible buttons if only one file 
                 is selected, or 11-16 if multiple files are selected.

    nPropSel - Specifies what items the property dialog focuses on. It can be 
               one of the following values:
    
               WNPS_FILE (0) - Single file.
               
               WNPS_DIR (1) - Single directory.
               
               WNPS_MULT (2) - Multiple selection of files and/or directories.

    lpFileName - Specifies the names of the item or items to be viewed or edited 
                 by the dialog. Currently, the items are files (and directories), 
                 so the item names are file names. These will be unambiguous, 
                 contain no wildcard characters and will be fully qualified 
                 (e.g., C:\LOCAL\FOO.BAR).  Multiple filenames will be separated 
                 with spaces. Any filename may be quoted (e.g., "C:\My File") in 
                 which case it will be treated as a single name. The caret 
                 character '^' may also be used as the quotation mechanism for 
                 single characters (e.g., C:\My^"File, "C:\My^"File" both refer 
                 to the file C:\My"File).

    lpButtonName - Points to a buffer where the Winnet provider should copy the 
                   name of the property button. On success, the buffer pointed 
                   to by lpButtonName will contain the name of the property 
                   button. If this buffer, on exit, contains the empty string, 
                   then the corresponding button and all succeeding buttons will 
                   be removed from the dialog box. The network provider cannot 
                   "skip" a button.

    cchButtonName - Specifies the size of the lpButtonName buffer in characters.

    nType - Specifies the item type. Currently, only WNTYPE_FILE will be used.

Return Value:

    WN_SUCCESS - If the call is successful and lpButtonName can be used.
    
    WN_OUT_OF_MEMORY - Couldn't load string from resources.

    WN_MORE_DATA - The given buffer is too small to fit the text of the button.

    WN_BAD_VALUE - The lpFileName parameter takes an unexpected form.

    WN_NOT_SUPPORTED - Property dialogs are not supported for the given object 
                       type (nType).

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetPropertyText Entered.\n"));
    return WN_NOT_SUPPORTED;
}


DWORD
NPPropertyDialog(
    HWND hwndParent,
    DWORD iButtonDlg,
    DWORD nPropSel,
    LPTSTR lpFileName,
    DWORD nType
)
/*++

Routine Description:

    This function is called out to when the user clicks a button added through 
    the NPGetPropertyText API. Currently, this will only be called for file and 
    directory network properties.

Arguments:

    hwndParent - Specifies the parent window which should own the file property 
                 dialog.

    iButtonDlg - Indicates the index (starting at 0) of the button that was 
                 pressed.
    
    nPropSel - Specifies what items the property dialog should act on. It can be 
               one of the following values:
               
               WNPS_FILE (0) - Single file.
               
               WNPS_DIR (1) - Single directory.
               
               WNPS_MULT (2) - Multiple selection of files and/or directories.

    lpFileName - Points to the names of the items that the property dialog 
                 should act on. See the NPGetPropertyText API for a description 
                 of the format of what lpFileName points to.

    nType - Specifies the item type. Currently, only WNTYPE_FILE will be used.

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, the an error code is 
                 returned which can be one of the following:

    WN_BAD_VALUE - Some parameter takes an unexpected form or value.

    WN_OUT_OF_MEMORY - Not enough memory to display the dialog.

    WN_NET_ERROR - Some other network error occurred.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPPropertyDialog Entered.\n"));
    return WN_NET_ERROR;
}


DWORD
NPSearchDialog(
    HWND hParent,
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpnFlags
    )
/*++

Routine Description:

    This dialog allows network provider to supply its own form of browsing and 
    search beyond the hierarchical view presented in the Connection Dialog.

Arguments:

    hwnd - Specifies the handle of the window that will be used as the dialog 
           box's parent.
    
    lpNetResource - Specifies the currently selected item in the Network 
                    connections dialog. A provider may choose to ignore this 
                    field.

    lpBuffer - Pointer to buffer that will receive the result of the search.
    
    cbBuffer - DWORD that will specify size of buffer passed in.
    
    lpnFlags - Pointer to a DWORD of flags which the provider can set to force 
               certain actions after the dialog is dismissed.  It can be one of:

               WNSRCH_REFRESH_FIRST_LEVEL - Forces MPR to collapse then expand 
                                            (and refresh) the first level below 
                                            this provider after the dialog is 
                                            dismissed.

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_CANCEL - If user cancelled the operation.
    
    WN_MORE_DATA - If input buffer is too small.
    
--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPSearchDialog Entered.\n"));
    return WN_CANCEL;
}


DWORD
NPGetDirectoryType (
    LPTSTR lpName,
    LPINT lpType,
    BOOL bFlushCache
    )
/*++

Routine Description:

    This function is used by the file manager to determine the type of a 
    network directory.

Arguments:

    lpName - This parameter points to the fully qualified name of the directory. 
             The network provider returns the type to the word pointed to by 
             lpType. If the value returned in lpType is 0 or if the network 
             provider returns an error, the File Manager displays the directory 
             as a "normal" directory.
             
    lpType - This is defined by the network provider and is used to modify the 
             display of the drive tree in the File Manager.  In this way, the 
             network provider can show special directories to the user.
             
    bFlushCache - This is set to TRUE when the File Manager call MPR to get the 
                  directory type for the first time while repainting a window on 
                  Refresh. Subsequently, it will be FALSE. This gives a provider 
                  the opportunity to optimize performance if it wishes to just 
                  read the data for a drive once and cache it until the next 
                  Refresh.             

Return Value:

    WN_SUCCESS - If the call is successful.

    WN_NOT_SUPPORTED - This function is not supported.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetDirectoryType Entered.\n"));
    return WN_NOT_SUPPORTED;
}


DWORD
NPDirectoryNotify(
    HWND hwnd,
    LPTSTR lpDir,
    DWORD dwOper
    )
/*++

Routine Description:

    This function is used by the File Manager to notify the network provider of 
    certain directory operations. This function can be used to perform special 
    behaviour for certain directories.
    
Arguments:

    hwnd - Specifies an owner window handle in the event the network provider 
           needs to interact with the user.

    lpDir - This points to the fully qualified name of the directory.
    
    dwOper - Indicates the operation. If dwOper is WNDN_MKDIR (1), then the File 
             Manager is about to create a directory with the given name. If 
             dwOper WNDN_RMDIR (2), the File Manager is about the remove the 
             directory. dwOper may also be WNDN_MVDIR (3) to indicate that the 
             directory is about to be renamed.

Return Value:

    WN_SUCCESS - If the call is successful. This indicates to the caller that it 
                 should continue and perform the operation. Otherwise, the 
                 appropriate code is returned, which may include:

    WN_CANCELLED - The provider would have handled the operation, but the user 
                   cancelled it. The caller should NOT perform the operation.

    WN_CONTINUE - The network provider handled the operation, the caller should 
                  proceed normally but do not perform the operation.

    WN_NOT_SUPPORTED - The network does not have special directory handling, 
                       this is treated as WN_SUCCESS.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPDirectoryNotify Entered.\n"));
    return WN_NOT_SUPPORTED;
}


DWORD
NPGetConnectionPerformance(
    LPCWSTR lpRemoteName,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfo
    )
/*++

Routine Description:

    This function returns information about the expected performance of a 
    connection used to access a network resource. The request can only be for a 
    network resource to which there is currently a connection. The information 
    returned may be an estimate. Note that if the network cannot obtain 
    information about the resource on the network, then it can return 
    information about the network adaptor and its associated performance, 
    setting dwFlags accordingly.

Arguments:

    lpRemoteName - Contains the local name or remote name for a resource for 
                   which a connection exists. 
                   
    lpNetConnectInfo - This is is a pointer to a NETCONNECTINFOSTRUCT structure 
                       which is filled in by the net provider if the provider 
                       has a connection to the network resource. With the 
                       exception of the cbStructure field, all other fields are 
                       zero filled before MPR.DLL passes the request on to the 
                       net providers, and the provider only has to write to 
                       fields for which it has information available. Also, for 
                       rate values, a value of 1 means that the performance is 
                       better than can be represented in the unit.                    

Return Value:

    WN_SUCCESS - If the call is successful. Otherwise, the an error code is 
                 returned, which may include:
    
    WN_NOT_CONNECTED - lpRemoteName is not a connected network resource.
    
    WN_NO_NETWORK - Network is not present.

--*/
{
    IF_DEBUG_PRINT(DEBUG_ENTRY, ("NPGetConnectionPerformance Entered.\n"));
    // 
    // BUGBUG: why is this function supported at all ?? It can result in error
    // if a connection is created and checked for its existence.
    // 
    // LOOK HERE: Not supported for now: return WN_NOT_CONNECTED;
    return WN_NOT_SUPPORTED;
}

#endif // #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inc\davname.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1999  Microsoft Corporation

Module Name:

    davname.h

Abstract:

    This file contains service name strings for the dav redir. it should
    be folded into lmsname.h at some point

Environment:

    User Mode -Win32

--*/

#ifndef _DAVNAME_
#define _DAVNAME_

#if _MSC_VER > 1000
#pragma once
#endif

//
//  Standard LAN Manager service names.
//

#define SERVICE_DAVCLIENT       L"WebClient"

#define DAVCLIENT_DRIVER        L"MRxDAV"

#define DAV_PARAMETERS_KEY       L"System\\CurrentControlSet\\Services\\WebClient\\Parameters"
#define DAV_DEBUG_KEY            L"ServiceDebug"
#define DAV_MAXTHREADS_KEY       L"MaxThreads"
#define DAV_THREADS_KEY          L"Threads"

#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_DAV_DEVICE_NAME    "\\Device\\WebDavRedirector"
#define DD_DAV_DEVICE_NAME_U L"\\Device\\WebDavRedirector"

#define DAV_ENCODE_SEED     0x9C

//
// The file system name as returned by
// NtQueryInformationVolume(FileFsAttributeInformation)
//
#define DD_DAV_FILESYS_NAME "FAT"
#define DD_DAV_FILESYS_NAME_U L"FAT"
// #define DD_DAV_FILESYS_NAME "WebDavRedirector"
// #define DD_DAV_FILESYS_NAME_U L"WebDavRedirector"

#endif


//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_DAV_BASE                  0x400

#define _DAV_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_DAV_BASE, request, method, access)


#define FSCTL_DAV_START                  _DAV_CONTROL_CODE(1, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_DAV_STOP                   _DAV_CONTROL_CODE(2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DAV_SET_CONFIG_INFO        _DAV_CONTROL_CODE(3, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_CONFIG_INFO        _DAV_CONTROL_CODE(4, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_CONNECTION_INFO    _DAV_CONTROL_CODE(5, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_DAV_ENUMERATE_CONNECTIONS  _DAV_CONTROL_CODE(6, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_VERSIONS           _DAV_CONTROL_CODE(7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DAV_DELETE_CONNECTION      _DAV_CONTROL_CODE(8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DAV_GET_STATISTICS         _DAV_CONTROL_CODE(9, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inc\pch.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

#ifndef __cplusplus

#pragma once

#define UNICODE 1
#define _UNICODE 1

//
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Public windows headers.
//
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <rpc.h>
#include <rpcutil.h>
#include <lmcons.h>
#include <lmerr.h>
#include <netlib.h>
#include <netlibnt.h>
#include <wininet.h>
#include <winineti.h>
#include <mpr.h>
#include <npapi.h>
#include "davname.h"

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\volclean.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       volclean.cpp
//
//  Authors;
//    Guhan Suriyanarayanan (guhans)
//
//  Notes;
//    WebDav disk cleanup interface (IEmptyVolumeCache, IEmptyVolumeCache2)
//--------------------------------------------------------------------------

#include <windows.h>
#include "volclean.h"
#include "resource.h"

extern "C" {
extern HINSTANCE g_hinst;


DWORD
APIENTRY
DavFreeUsedDiskSpace(
    DWORD   dwPercent
    );


DWORD
APIENTRY
DavGetDiskSpaceUsage(
    LPWSTR      lptzLocation,
    DWORD       *lpdwSize,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    );

}

HRESULT
CoTaskLoadString(
    HINSTANCE hInstance, 
    UINT idString, 
    LPWSTR *ppwsz
    )
{
    int cchString = 100;      // start with a reasonable default
    BOOL done = TRUE;

    *ppwsz = NULL;

    do {
        done = TRUE;

        *ppwsz = (LPWSTR)CoTaskMemAlloc(cchString * sizeof(WCHAR));
        if (*ppwsz) {

            //
            // Try loading the string into the current buffer
            //
            int nResult = LoadStringW(hInstance, idString, *ppwsz, cchString);
            if (!nResult || (nResult >= (cchString-1))) {
                //
                // We couldn't load the string.  If this is because the 
                // buffer isn't big enough, we'll try again.
                //
                DWORD dwStatus = GetLastError();
                
                //
                // Free the current buffer first
                //
                CoTaskMemFree(*ppwsz);
                *ppwsz = NULL;

                if (nResult >= (cchString-1)) {
                    //
                    // Try again with a bigger buffer
                    //
                    cchString *=2;
                    done = FALSE;
                }
                else {
                    return HRESULT_FROM_WIN32(dwStatus);
                }
            }
        }
        else {
            return E_OUTOFMEMORY;
        }

    } while (!done);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IClassFactory::CreateInstance support                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
CWebDavCleaner::CreateInstance(REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    Trace(L"CWebDavCleaner::CreateInstance");

    CWebDavCleaner *pThis = new CWebDavCleaner();
    if (pThis)
    {
        hr = pThis->QueryInterface(riid, ppv);
        pThis->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IUnknown implementation                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CWebDavCleaner::QueryInterface(REFIID riid, void **ppv)
{

    Trace(L"CWebDavCleaner::QueryInterface");
    if (!ppv) {
        return E_POINTER;
    }

    if (riid == IID_IEmptyVolumeCache) {
        *ppv = static_cast<IEmptyVolumeCache*>(this);
    }
    else if (riid == IID_IEmptyVolumeCache2) {
        *ppv = static_cast<IEmptyVolumeCache2*>(this);
    }
    else  {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) 
CWebDavCleaner::AddRef()
{
    Trace(L"CWebDavCleaner::AddRef");
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) 
CWebDavCleaner::Release()
{
    Trace(L"CWebDavCleaner::Release");
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IEmptyVolumeCache implementation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CWebDavCleaner::Initialize(
    IN  HKEY    hkRegKey,
    IN  LPCWSTR pcwszVolume,
    OUT LPWSTR *ppwszDisplayName,
    OUT LPWSTR *ppwszDescription,
    IN OUT LPDWORD pdwFlags
    )
{

    Trace(L"CWebDavCleaner::Initialize");
    HRESULT hr = E_FAIL;

    if (!pcwszVolume || 
        !ppwszDisplayName || 
        !ppwszDescription || 
        !pdwFlags
        ) {
        return E_POINTER;
    }

    *ppwszDisplayName = NULL;
    *ppwszDescription = NULL;

    //
    // Check the IN flags first
    //
    if ((*pdwFlags) & EVCF_OUTOFDISKSPACE) {
        //
        // The user is out of disk space on the drive, and we should be 
        // aggressive about freeing disk space, even if it results in a 
        // performance loss. 
        //
        m_dwPercent = 100;
    }

    if ((*pdwFlags) & EVCF_SETTINGSMODE) {
        //
        // The disk cleanup manager is being run on a schedule. We must 
        // assign values to the ppwszDisplayName and ppwszDescription 
        // parameters. If this flag is set, the disk cleanup manager will not 
        // call GetSpaceUsed, Purge, or ShowProperties. Because Purge will not 
        // be called, cleanup must be handled by Initialize. The handler should 
        // ignore the pcwszVolume parameter and clean up any unneeded files 
        // regardless of what drive they are on. 
        //
        // Let's just call purge ourselves!
        //
        m_fScheduled = TRUE;
        m_fFilesToDelete = TRUE;
    }

    //
    // And set the OUT flags
    //
    *pdwFlags = EVCF_DONTSHOWIFZERO;

    // 
    // Load the display name and description strings
    //
    hr = CoTaskLoadString(g_hinst, IDS_DISKCLEAN_DISPLAY, ppwszDisplayName);
    if (FAILED(hr)) {
        return hr;
    }
    hr = CoTaskLoadString(g_hinst, IDS_DISKCLEAN_DESCRIPTION, ppwszDescription);
    if (FAILED(hr)) {
        return hr;
    }

    if (m_fScheduled) {
        //
        // Scheduled run:  Purge now.
        //
        Purge(-1, NULL);
    }
    else {
        //
        // Copy the volume path locally
        //
        if (m_szVolume) {
            delete [] m_szVolume;
            m_szVolume = NULL;
        }
        
        m_szVolume = new WCHAR[(wcslen(pcwszVolume) + 1)];
        
        if (!m_szVolume) {
            return E_OUTOFMEMORY;
        }

        wcscpy(m_szVolume, pcwszVolume);
    }

    return S_OK;
}


STDMETHODIMP
CWebDavCleaner::GetSpaceUsed(
    OUT DWORDLONG *pdwlSpaceUsed,
    IN  LPEMPTYVOLUMECACHECALLBACK picb
    )
{
    WCHAR szLocation[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH + 1, 
        dwStatus = ERROR_SUCCESS;
    ULARGE_INTEGER dwMaxSpace,
        dwUsedSpace;

    Trace(L"CWebDavCleaner::GetSpaceUsed");

    ZeroMemory(szLocation, (MAX_PATH+1)*sizeof(WCHAR));

    if (!pdwlSpaceUsed) {
        return E_POINTER;
    }
    if (!m_szVolume) {
        //
        // Initialize should have been called first
        //
        return E_UNEXPECTED;
    }

    *pdwlSpaceUsed = 0;

    //
    // Check if the webdav cache is using this volume, and set the flags 
    // accordingly.
    //
    dwStatus = DavGetDiskSpaceUsage(szLocation, &dwSize, &dwMaxSpace, &dwUsedSpace);

    pToUpperCase(szLocation);
    pToUpperCase(m_szVolume);

    //
    // Check if the volume being cleaned matches the volume holding the
    // Webdav cache
    //
    if ((ERROR_SUCCESS == dwStatus) && (!wcsncmp(szLocation, m_szVolume, wcslen(m_szVolume)))) {
        m_fFilesToDelete = TRUE;
        m_dwlUsedSpace =  (DWORDLONG)(dwUsedSpace.QuadPart);

    }
    else {
        m_fFilesToDelete = FALSE;
        m_dwlUsedSpace = 0;
    }

    //
    // We're done with this, purge doesn't need to know
    // the volume being cleaned.
    //
    delete [] m_szVolume;
    m_szVolume = NULL;

    *pdwlSpaceUsed = m_dwlUsedSpace;

    return HRESULT_FROM_WIN32(dwStatus);

    UNREFERENCED_PARAMETER(picb);
}


STDMETHODIMP
CWebDavCleaner::Purge(
    IN DWORDLONG dwlSpaceToFree,
    IN LPEMPTYVOLUMECACHECALLBACK picb
    )
{
    Trace(L"CWebDavCleaner::Purge");
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // Does this volume have stuff of interest?
    //
    if (m_fFilesToDelete) {
        //
        // Figure out m_dwPercent:  dwlSpaceToFree is set to -1 if
        // we need to free as much as possible
        //
        if (dwlSpaceToFree == (DWORDLONG) -1) {
            m_dwPercent = 100;
        }
        else {
            m_dwPercent = (DWORD)  (dwlSpaceToFree * 100 / m_dwlUsedSpace);
        }

        dwStatus = DavFreeUsedDiskSpace(m_dwPercent);
    }

    return HRESULT_FROM_WIN32(dwStatus);
    UNREFERENCED_PARAMETER(picb);
}


STDMETHODIMP
CWebDavCleaner::ShowProperties(
    IN HWND hwnd 
    )
{
    //
    // No UI to display.  S_FALSE indicates to the caller
    // that no settings were changed by the user.
    //
    return S_FALSE;

    UNREFERENCED_PARAMETER(hwnd);
}

STDMETHODIMP
CWebDavCleaner::Deactivate(
    IN LPDWORD pdwFlags
    )
{
    // 
    // Nothing to do here
    //
    return S_OK;

    UNREFERENCED_PARAMETER(pdwFlags);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IEmptyVolumeCache2 implementation                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CWebDavCleaner::InitializeEx(
    IN  HKEY hkRegKey,
    IN  LPCWSTR pcwszVolume,
    IN  LPCWSTR pcwszKeyName,
    OUT LPWSTR *ppwszDisplayName,
    OUT LPWSTR *ppwszDescription,
    OUT LPWSTR *ppwszBtnText,
    IN OUT LPDWORD pdwFlags
    )
{
    Trace(L"CWebDavCleaner::InitializeEx");

    *ppwszBtnText = NULL;
    return Initialize(hkRegKey,
        pcwszVolume,
        ppwszDisplayName,
        ppwszDescription,
        pdwFlags
        );

    UNREFERENCED_PARAMETER(pcwszKeyName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\volclean.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       volclean.h
//
//--------------------------------------------------------------------------

#ifndef _VOLFREE_H_
#define _VOLFREE_H_

#include <windows.h>
#include <emptyvc.h>
#include <initguid.h>
#include <stdio.h>

#define Trace(x) 

// {E3BF1126-BA29-4850-AF33-5BDB654F4774}
DEFINE_GUID(CLSID_WebDavVolumeCleaner, 
    0xE3BF1126, 0xBA29, 0x4850, 
    0xAF, 0x33, 0x5B, 0xDB, 
    0x65, 0x4F, 0x47, 0x74
    );


STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

class CWebDavCleaner : public IEmptyVolumeCache2
{
    LONG m_cRef;
    DWORDLONG m_dwlUsedSpace;
    DWORD m_dwPercent;
    BOOL m_fScheduled;
    BOOL m_fFilesToDelete;
    PWSTR m_szVolume;

public:
    CWebDavCleaner() 
      : m_cRef(1), 
        m_dwlUsedSpace(0), 
        m_fScheduled(FALSE),
        m_fFilesToDelete(FALSE),
        m_dwPercent(90),
        m_szVolume(NULL)

    {
        Trace(L"CWebDavCleaner::CWebDavCleaner");
        ::DllAddRef();
    }

    ~CWebDavCleaner()
    {
        Trace(L"CWebDavCleaner::~CWebDavCleaner");
        if (m_szVolume) {
            delete [] m_szVolume;
            m_szVolume = NULL;
        }

        ::DllRelease();
    }

    static HRESULT WINAPI CreateInstance(REFIID riid, LPVOID *ppv);

    // 
    // IUnknown methods
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // 
    // IEmptyVolumeCache methods
    //
    STDMETHODIMP Initialize(HKEY hkRegKey,
        LPCWSTR pcwszVolume,
        LPWSTR *ppwszDisplayName,
        LPWSTR *ppwszDescription,
        LPDWORD pdwFlags
        );

    STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwlSpaceUsed,
        LPEMPTYVOLUMECACHECALLBACK picb
        );

    STDMETHODIMP Purge(DWORDLONG dwlSpaceToFree,
        LPEMPTYVOLUMECACHECALLBACK picb
        );

    STDMETHODIMP ShowProperties(HWND hwnd);
    STDMETHODIMP Deactivate(LPDWORD pdwFlags);

    // 
    // IEmptyVolumeCache2 methods
    //
    STDMETHODIMP InitializeEx(HKEY hkRegKey,
        LPCWSTR pcwszVolume,
        LPCWSTR pcwszKeyName,
        LPWSTR *ppwszDisplayName,
        LPWSTR *ppwszDescription,
        LPWSTR *ppwszBtnText,
        LPDWORD pdwFlags
        );

private:
    VOID pToUpperCase(IN PWSTR sz) 
    {
        for (UINT i = 0; i < wcslen(sz); i++) {
            if ((sz[i] >= L'a') && (sz[i] <= L'z')) {
                sz[i] += L'A' - L'a';
            }
        }
    }


};

#endif  // _VOLFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v

$(O)\netdav.inf: $(_INX)\netdav.inx $(_LNG)\netdav.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\inc\usrmddav.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usrmddav.h

Abstract:

    This module defines the data structures which are shared by the user mode
    and the kernel mode components of the WebDav miniredirector.

Author:

    Rohan Kumar      [RohanK]      30-March-1999

Revision History:

--*/

#ifndef _USRMDDAV_H
#define _USRMDDAV_H

//
// The subset of DAV file attributes (common with NTFS attributes) which get 
// returned on a PROPFIND call. The structure also include the properties that
// get returned when a LOCK or any other DAV request is issued.
//
typedef struct _DAV_FILE_ATTRIBUTES {
    BOOL InvalidNode;
    ULONG FileIndex;
    DWORD dwFileAttributes;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastModifiedTime;
    LARGE_INTEGER DavCreationTime;
    LARGE_INTEGER DavLastModifiedTime;
    LARGE_INTEGER FileSize;
    LIST_ENTRY NextEntry;
    BOOL isHidden;
    BOOLEAN isCollection;
    ULONG FileNameLength;
    PWCHAR FileName;
    PWCHAR Status;
    BOOL fReportsAvailableSpace;
    LARGE_INTEGER TotalSpace;
    LARGE_INTEGER AvailableSpace;
    ULONG LockTimeout;
    PWCHAR OpaqueLockToken;
    PWCHAR LockOwner;
} DAV_FILE_ATTRIBUTES, *PDAV_FILE_ATTRIBUTES;

#ifndef __cplusplus

//
// The fileinfo that gets filled in by the user mode process and returned to the
// kernel mode miniredir.
//
typedef struct _DAV_USERMODE_CREATE_RETURNED_FILEINFO {

    //
    // File's Basic Info.
    //
    union {
        ULONG ForceAlignment1;
        FILE_BASIC_INFORMATION BasicInformation;
    };

    //
    // File's Standard Info.
    //
    union {
        ULONG ForceAlignment2;
        FILE_STANDARD_INFORMATION StandardInformation;
    };

} DAV_USERMODE_CREATE_RETURNED_FILEINFO,*PDAV_USERMODE_CREATE_RETURNED_FILEINFO;

//
// Structure used in create/close requests.
//
typedef struct _DAV_HANDLE_AND_USERMODE_KEY {

    //
    // The handle of the file being opened.
    //
    HANDLE Handle;

    //
    // This is set to the handle value and is used for debugging purposes.
    //
    PVOID UserModeKey;

} DAV_HANDLE_AND_USERMODE_KEY, *PDAV_HANDLE_AND_USERMODE_KEY;

//
// The Dav create request flags and buffer.
//
#define DAV_SECURITY_DYNAMIC_TRACKING   0x01
#define DAV_SECURITY_EFFECTIVE_ONLY     0x02

typedef struct _DAV_USERMODE_CREATE_REQUEST {

    //
    // The complete path name of the create request. The user mode process
    // parses this path name and creates a URL to be sent to the server.
    //
    PWCHAR CompletePathName;

    //
    // The server's unique id which was got during the CreateSrvCall.
    //
    ULONG ServerID;

    //
    // The user/session's LogonID.
    //
    LUID LogonID;

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    ULONG SdLength;

    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;

    ULONG SecurityFlags;

    ACCESS_MASK DesiredAccess;

    LARGE_INTEGER AllocationSize;

    ULONG FileAttributes;

    ULONG ShareAccess;

    ULONG CreateDisposition;

    ULONG CreateOptions;

    PVOID EaBuffer;

    ULONG EaLength;

    BOOLEAN FileInformationCached;
    BOOLEAN FileNotExists;
    BOOLEAN ParentDirInfomationCached;
    BOOLEAN ParentDirIsEncrypted;

} DAV_USERMODE_CREATE_REQUEST, *PDAV_USERMODE_CREATE_REQUEST;

//
// The create response returned by the user mode.
//
typedef struct _DAV_USERMODE_CREATE_RESPONSE {

    //
    // The filename of the local file that represents the file on the DAV server
    // which got created/opened. Locally, the files are cached in the IE cache.
    //
    WCHAR FileName[MAX_PATH];

    WCHAR Url[MAX_PATH * 2];

    //
    // If this was a new file created on the server, do we need to set the 
    // attributes on Close ?
    //
    BOOL NewFileCreatedAndSetAttributes;

    //
    // If a new file or directory is created, we need to PROPPATCH the time
    // values on close. This is because we use the time values from the client
    // when the name cache entry is created for this new file. The same time
    // value needs to be on the server.
    //
    BOOL PropPatchTheTimeValues;

    //
    // If this is TRUE, it means that the file exists on the server, but 
    // "FILE_OVERWRITE_IF" was specified as the CreateDisposition. So, the file
    // was created locally and the new file needs to be PUT (overwrite) over the
    // old file on the server on close.
    //
    BOOL ExistsAndOverWriteIf;

    //
    // Was "FILE_DELETE_ON_CLOSE" specified as one of the CreateOptions ?
    //
    BOOL DeleteOnClose;

    //
    // We haven't really opened the file as the caller is either deleting or 
    // reading/setting attributes.
    //
    BOOL fPsuedoOpen;

    BOOL LocalFileIsEncrypted;

    //
    // If the file is LOCKed on the server during the create, the LockKoken
    // returned by the server is filled here.
    //
    WCHAR OpaqueLockToken[MAX_PATH];

    //
    // If the Create fails because the file is LOCKed on the server, the LockOwner
    // returned by the server is filled here. Maximum length of the LockOwner
    // field. The worst case is <User>@<DnsDomain>.
    //
    WCHAR LockOwner[(256 + 1 + 256)];

    //
    // If the file is LOCKed on the server during the create, the Lock Timeout
    // returned by the server is filled here.
    //
    ULONG LockTimeout;

    //
    // This is set to TRUE if this create involved taking a LOCK on the file
    // on the server and the LOCK was successfully taken.
    //
    BOOL LockWasTakenOnThisCreate;

    //
    // This is set to TRUE if this create involved taking a LOCK on the file
    // on the server and the LOCK request failed because someone else has
    // already locked the file.
    //
    BOOL FileWasAlreadyLocked;

    union {
        DAV_HANDLE_AND_USERMODE_KEY;
        DAV_HANDLE_AND_USERMODE_KEY HandleAndUserModeKey;
    };

    union {
        DAV_USERMODE_CREATE_RETURNED_FILEINFO;
        DAV_USERMODE_CREATE_RETURNED_FILEINFO CreateReturnedFileInfo;
    };

} DAV_USERMODE_CREATE_RESPONSE, *PDAV_USERMODE_CREATE_RESPONSE;

//
// Create SrvCall request buffer.
//
typedef struct _DAV_USERMODE_CREATE_SRVCALL_REQUEST {

    //
    // The name of the server for which a SrvCall is being created. The user
    // mode process verifies whether this server exists and whether it speaks
    // DAV.
    //
    PWCHAR ServerName;

    //
    // The user/session's LogonID.
    //
    LUID LogonID;

    //
    // Am I the thread that is creating and initializing this ServerHashEntry?
    //
    BOOL didICreateThisSrvCall;

    //
    // Am I a thread that did a wait and took a reference while some other
    // thread was creating and initializing this ServerHashEntry?
    //
    BOOL didIWaitAndTakeReference;

} DAV_USERMODE_CREATE_SRVCALL_REQUEST, *PDAV_USERMODE_CREATE_SRVCALL_REQUEST;

//
// The Create SrvCall response.
//
typedef struct _DAV_USERMODE_CREATE_SRVCALL_RESPONSE {

    //
    // The Server ID is generated in the user mode when a create srvcall
    // request comes up. This is stored in the mini-redir's portion of the
    // srvcall structure and is sent up along with future reflections against
    // this server.
    //
    ULONG ServerID;

} DAV_USERMODE_CREATE_SRVCALL_RESPONSE, *PDAV_USERMODE_CREATE_SRVCALL_RESPONSE;

//
// Finalize SrvCall request buffer.
//
typedef struct _DAV_USERMODE_FINALIZE_SRVCALL_REQUEST {

    //
    // The server whose entry is being finalized.
    //
    PWCHAR ServerName;

    //
    // The ServerID for the server.
    //
    ULONG ServerID;

} DAV_USERMODE_FINALIZE_SRVCALL_REQUEST, *PDAV_USERMODE_FINALIZE_SRVCALL_REQUEST;

//
// The QueryDirectory request buffer.
//
typedef struct _DAV_USERMODE_QUERYDIR_REQUEST {

    //
    // Is the DavFileAttributes list for this directory created ? This is set 
    // to TRUE after the fisrt call to QueryDirectory gets satisfied.
    //
    BOOL AlreadyDone;

    //
    // The template that came with the QueryDirectory request does not contain
    // wild cards.
    //
    BOOL NoWildCards;
    
    //
    // LogonID of this session.
    //
    LUID LogonID;

    //
    // The server being queried.
    //
    PWCHAR ServerName;

    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
    //
    // The path of the direcotry being queried on the server.
    //
    PWCHAR PathName;

} DAV_USERMODE_QUERYDIR_REQUEST, *PDAV_USERMODE_QUERYDIR_REQUEST;

//
// The QueryDirectory response buffer.
//
typedef struct _DAV_USERMODE_QUERYDIR_RESPONSE {

    //
    // The list of DavFileAttributes for the files under the directory being
    // queried.
    //
    PDAV_FILE_ATTRIBUTES DavFileAttributes;

    //
    // Number of entries in the DavFileAttributes list.
    //
    ULONG NumOfFileEntries;

} DAV_USERMODE_QUERYDIR_RESPONSE, *PDAV_USERMODE_QUERYDIR_RESPONSE;

//
// The Close request buffer.
//
typedef struct _DAV_USERMODE_CLOSE_REQUEST {

    union {
        DAV_HANDLE_AND_USERMODE_KEY;
        DAV_HANDLE_AND_USERMODE_KEY HandleAndUserModeKey;
    };

    //
    // LogonID of this session.
    //
    LUID LogonID;

    //
    // The server being queried.
    //
    PWCHAR ServerName;

    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
    //
    // The path of the direcotry being queried on the server.
    //
    PWCHAR PathName;

    //
    // The OpaqueLockToken returned by the server when the file was LOCKed
    // during the CreateFile call.
    //
    PWCHAR OpaqueLockToken;

    //
    // Should this file be deleted on Close ?
    //
    BOOL DeleteOnClose;

    //
    // Was the file modified ? If it was, then we need to PUT the modified
    // file back to the server.
    //
    BOOL FileWasModified;

    //
    // Was the handle to this file created in the kernel.
    //
    BOOL createdInKernel;

    //
    // Is this a Directory ?
    //
    BOOL isDirectory;
    
    //
    // Basic Information change
    //
    BOOLEAN fCreationTimeChanged;
    
    BOOLEAN fLastAccessTimeChanged;
    
    BOOLEAN fLastModifiedTimeChanged;    
    
    BOOLEAN fFileAttributesChanged;

    LARGE_INTEGER CreationTime;
    
    LARGE_INTEGER LastAccessTime;
    
    LARGE_INTEGER LastModifiedTime;
    
    LARGE_INTEGER  AvailableSpace;
    
    DWORD dwFileAttributes;
    ULONG FileSize;

    //
    // The local file name of the file created/opened on the DAV server.
    //
    WCHAR FileName[MAX_PATH];
    WCHAR Url[MAX_PATH * 2];

} DAV_USERMODE_CLOSE_REQUEST, *PDAV_USERMODE_CLOSE_REQUEST;

//
// The Finalize Fobx request buffer.
//
typedef struct _DAV_USERMODE_FINALIZE_FOBX_REQUEST {

    //
    // The list of DavFileAttributes for the files under the directory being
    // queried.
    //
    PDAV_FILE_ATTRIBUTES DavFileAttributes;

} DAV_USERMODE_FINALIZE_FOBX_REQUEST, *PDAV_USERMODE_FINALIZE_FOBX_REQUEST;

//
// The  request buffer.
//
typedef struct _DAV_USERMODE_SETFILEINFORMATION_REQUEST {

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
    //
    // The server name on which the file/dir resides
    //
    PWCHAR ServerName;

    //
    // The path name of the file or directory
    //
    PWCHAR PathName;

    //
    // The OpaqueLockToken returned by the server when the file was LOCKed
    // during the CreateFile call.
    //
    PWCHAR OpaqueLockToken;

    //
    // Basic Information change
    //
    BOOLEAN fCreationTimeChanged;
    
    BOOLEAN fLastAccessTimeChanged;
    
    BOOLEAN fLastModifiedTimeChanged;    
    
    BOOLEAN fFileAttributesChanged;

    //
    // For now we will set only the basic info. In future we may want to expand
    // this filed to FILE_ALL_INFORMATION.
    //
    FILE_BASIC_INFORMATION FileBasicInformation;

} DAV_USERMODE_SETFILEINFORMATION_REQUEST, *PDAV_USERMODE_SETFILEINFORMATION_REQUEST;

typedef struct _DAV_USERMODE_RENAME_REQUEST {

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;

    //
    // If the destination file exists, replace it if this is TRUE. If its FALSE,
    // fail.
    //
    BOOLEAN ReplaceIfExists;
    
    //
    // The server name on which the file being renamed resides.
    //
    PWCHAR ServerName;

    //
    // The old path name of the file.
    //
    PWCHAR OldPathName;

    //
    // The new path name of the file.
    //
    PWCHAR NewPathName;

    //
    // The OpaqueLockToken returned by the server when the file was LOCKed
    // during the CreateFile call.
    //
    PWCHAR OpaqueLockToken;

    WCHAR Url[MAX_PATH * 2];

} DAV_USERMODE_RENAME_REQUEST, *PDAV_USERMODE_RENAME_REQUEST;


//
// The Create V_NET_ROOT request buffer.
//
typedef struct _DAV_USERMODE_CREATE_V_NET_ROOT_REQUEST {

    //
    // ServerName.
    //
    PWCHAR ServerName;

    //
    // ShareName. We need to find out if this share exists or not.
    //
    PWCHAR ShareName;

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
} DAV_USERMODE_CREATE_V_NET_ROOT_REQUEST, *PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST;

//
// The CreateVNetRoot response buffer.
//
typedef struct _DAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE {

    //
    // Is this an Office Web Server share?
    //
    BOOL isOfficeShare;

    //
    // Is this a Tahoe share?
    //
    BOOL isTahoeShare;

    //
    // OK to do PROPPATCH?
    //
    BOOL fAllowsProppatch;    

    //
    // Does it report available space?
    //    
    BOOL fReportsAvailableSpace;

} DAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE, *PDAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE;

//
// The finalize VNetRoot request buffer.
//
typedef struct _DAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST {

    //
    // ServerName.
    //
    PWCHAR ServerName;

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;

} DAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST, *PDAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST;

//
// The QueryVolumeInformation request buffer.
//
typedef struct _DAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST {

    //
    // ServerName.
    //
    PWCHAR ServerName;

    //
    // ShareName. We need to find out if this share exists or not.
    //
    PWCHAR ShareName;

    //
    // LogonID of this session.
    //
    LUID LogonID;
    
    //
    // The ID of the server being queried.
    //
    ULONG ServerID;
    
} DAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST, *PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST;

//
// The QueryVolumeInformation response buffer.
//
typedef struct _DAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE {

    //
    // If someone reports available space, keep it.
    //    
    LARGE_INTEGER   TotalSpace;
    LARGE_INTEGER   AvailableSpace;

} DAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE, *PDAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE;

//
// The LockRefresh request buffer.
//
typedef struct _DAV_USERMODE_LOCKREFRESH_REQUEST {

    //
    // ServerName of the server on which the LOCKed file is shared.
    //
    PWCHAR ServerName;

    //
    // PathName on which the LOCK was taken.
    //
    PWCHAR PathName;

    //
    // The LockToken (returned by the server) which needs to be refreshed.
    //
    PWCHAR OpaqueLockToken;

    //
    // The server's unique id which was got during the CreateSrvCall.
    //
    ULONG ServerID;

    //
    // The user/session's LogonID.
    //
    LUID LogonID;

} DAV_USERMODE_LOCKREFRESH_REQUEST, *PDAV_USERMODE_LOCKREFRESH_REQUEST;

//
// The LockRefresh response buffer.
//
typedef struct _DAV_USERMODE_LOCKREFRESH_RESPONSE {

    //
    // The new timeout value returned by the server when this request is
    // refreshed.
    //
    ULONG NewTimeOutInSec;

} DAV_USERMODE_LOCKREFRESH_RESPONSE, *PDAV_USERMODE_LOCKREFRESH_RESPONSE;

//
// The various types of usermode work requests handled by the reflector. These
// requests are filled in by the kernel.
//
typedef union _DAV_USERMODE_WORK_REQUEST {
    DAV_USERMODE_CREATE_SRVCALL_REQUEST CreateSrvCallRequest;
    DAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest;
    DAV_USERMODE_FINALIZE_SRVCALL_REQUEST FinalizeSrvCallRequest;
    DAV_USERMODE_FINALIZE_V_NET_ROOT_REQUEST FinalizeVNetRootRequest;
    DAV_USERMODE_CREATE_REQUEST CreateRequest;
    DAV_USERMODE_QUERYDIR_REQUEST QueryDirRequest;
    DAV_USERMODE_CLOSE_REQUEST CloseRequest;
    DAV_USERMODE_FINALIZE_FOBX_REQUEST FinalizeFobxRequest;
    DAV_USERMODE_RENAME_REQUEST ReNameRequest;
    DAV_USERMODE_SETFILEINFORMATION_REQUEST SetFileInformationRequest;
    DAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest;
    DAV_USERMODE_LOCKREFRESH_REQUEST LockRefreshRequest;
} DAV_USERMODE_WORK_REQUEST, *PDAV_USERMODE_WORK_REQUEST;

//
// The various types of usermode work responses send down to the kernel by the
// reflector.
//
typedef union _DAV_USERMODE_WORK_RESPONSE {
    DAV_USERMODE_CREATE_SRVCALL_RESPONSE CreateSrvCallResponse;
    DAV_USERMODE_CREATE_RESPONSE CreateResponse;
    DAV_USERMODE_QUERYDIR_RESPONSE QueryDirResponse;
    DAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE CreateVNetRootResponse;
    DAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE QueryVolumeInformationResponse;
    DAV_USERMODE_LOCKREFRESH_RESPONSE LockRefreshResponse;
} DAV_USERMODE_WORK_RESPONSE, *PDAV_USERMODE_WORK_RESPONSE;

//
// The DAV operations which need callbacks. These are the operations which are
// performed asynchronously. NOTE!!!! The order of these is important. Do not
// change them. If you need to add an operation, add it at the end.
//
typedef enum _DAV_OPERATION {
    DAV_CALLBACK_INTERNET_CONNECT = 0,
    DAV_CALLBACK_HTTP_OPEN,
    DAV_CALLBACK_HTTP_SEND,
    DAV_CALLBACK_HTTP_END,
    DAV_CALLBACK_HTTP_READ,
    DAV_CALLBACK_MAX
} DAV_OPERATION;

typedef enum _DAV_WORKITEM_TYPES {
    UserModeCreate = 0,
    UserModeCreateVNetRoot,
    UserModeQueryDirectory,
    UserModeClose,
    UserModeCreateSrvCall,
    UserModeFinalizeSrvCall,
    UserModeFinalizeFobx,
    UserModeFinalizeVNetRoot,
    UserModeReName,
    UserModeSetFileInformation,
    UserModeQueryVolumeInformation,
    UserModeLockRefresh,
    UserModeMaximum
} DAV_WORKITEM_TYPES;

//
// We expose the signatures of the HASH_SERVER_ENTRY and PER_USER_ENTRY structs
// in this file. This is done so that we can use these names (for type checking
// by the compiler) in the DavWorkItem structure instead of using PVOID.
//
typedef struct _HASH_SERVER_ENTRY *PHASH_SERVER_ENTRY;
typedef struct _PER_USER_ENTRY *PPER_USER_ENTRY;

//
// A Create call is mapped to two DAV calls. A PROPFIND, followed by the GET of
// the file. This is a list of calls that could be sent to the server during
// create.
//
typedef enum _DAV_ASYNC_CREATE_STATES {
    AsyncCreatePropFind = 0,
    AsyncCreateQueryParentDirectory,
    AsyncCreateGet,
    AsyncCreateMkCol,
    AsyncCreatePut
} DAV_ASYNC_CREATE_STATES;

typedef enum _DAV_MINOR_OPERATION {
    DavMinorQueryInfo = 0,
    DavMinorReadData,
    DavMinorPushData,
    DavMinorWriteData,
    DavMinorDeleteFile,
    DavMinorPutFile,
    DavMinorProppatchFile
} DAV_MINOR_OPERATION;

//
// The Dav usermode workitem that gets passed between user and kernel mode.
// This structure also gets used as a callback context in async DAV operations.
//
typedef struct _DAV_USERMODE_WORKITEM {

    //
    // WorkItem Header. This header is used by the reflector library and is
    // shared across miniredirs.
    //
    union {
        UMRX_USERMODE_WORKITEM_HEADER;
        UMRX_USERMODE_WORKITEM_HEADER Header;
    };

    //
    // The kernel mode operation that got reflected upto the user mode.
    //
    DAV_WORKITEM_TYPES WorkItemType;

    //
    // The DAV operation for which this callback is being returned.
    //
    DAV_OPERATION DavOperation;

    //
    // The Minor operation. Used for handling Async reads.
    //
    DAV_MINOR_OPERATION DavMinorOperation;

    //
    // This restart routine is called after we've finished doing an async
    // operation on a worker thread. Type: LPTHREAD_START_ROUTINE.
    //
    LPVOID RestartRoutine;

    //
    // The Handle used to impersonate the user thread which initiated the
    // request.
    //
    HANDLE ImpersonationHandle;

    //
    // This keeps the list of InternetStatus the callback function was called
    // with for this workitem. This is just for debugging purposes.
    //
    USHORT InternetStatusList[200];

    //
    // This is the index of the above array.
    //
    ULONG InternetStatusIndex;

    //
    // The thread that is handling this request. This is helpful in debugging
    // the threads that get stuck in WinInet.
    //
    ULONG ThisThreadId;

    //
    // Pointer to the structure that contains the handles created by the
    // asynchronous calls.
    //
#ifdef WEBDAV_KERNEL
    LPVOID AsyncResult;
#else
    LPINTERNET_ASYNC_RESULT AsyncResult;
#endif

    //
    // Union of structs used in Async operations.
    //
    union {

        //
        // Async Create SrvCall.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The InternetConnect handle.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavConnHandle;
#else
            HINTERNET DavConnHandle;
#endif

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncCreateSrvCall;

        //
        // Async Create CreateVNetRoot.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // If a reference was taken on the PerUserEntry while creating the
            // VNetRoot, this is set to TRUE. If we fail and this is TRUE, we
            // decrement the reference.
            //
            BOOL didITakeReference;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncCreateVNetRoot;

        //
        // AsyncQueryDirectoryCall.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // Does the template that came with the QueryDirectory request
            // contain wildcards ?
            //
            BOOL NoWildCards;

            //
            // Data Buffer for reads.
            //
            PCHAR DataBuff;

            //
            // DWORD for storing the number of bytes read.
            //
            LPDWORD didRead;

            //
            // The context pointers used for parsing the XML data.
            //
            PVOID Context1;
            PVOID Context2;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncQueryDirectoryCall;
        //
        // Async AsyncQueryVolumeInformation
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncQueryVolumeInformation;


        //
        // Async Close.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The modified file is copied into this buffer and is "PUT" on the
            // server
            //
            PBYTE DataBuff;

            //
            // LocalAlloc takes the ULONG allocation size, no reason to declare ULONGLONG
            //
            ULONG DataBuffSizeInBytes;
            ULONG DataBuffAllocationSize;

#ifdef WEBDAV_KERNEL
            LPVOID InternetBuffers;
#else
            LPINTERNET_BUFFERS InternetBuffers;
#endif

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif

        } AsyncClose;

        //
        // Async ReName.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The header which is added to the "MOVE" request to be sent to
            // the server and contains the destination URI.
            //
            PWCHAR HeaderBuff;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif
        
        } AsyncReName;

        //
        // Async Create.
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // Is this a PROPFIND or a GET call.
            //
            DAV_ASYNC_CREATE_STATES AsyncCreateState;

            //
            // Data Buffer for reads.
            //
            PCHAR DataBuff;

            //
            // DWORD for storing the number of bytes read.
            //
            LPDWORD didRead;

            //
            // The FileHandle used in writing the file locally.
            //
            HANDLE FileHandle;

            //
            // Does the file being created exist on the server ?
            //
            BOOL doesTheFileExist;

            //
            // The context pointers used for parsing the XML data.
            //
            PVOID Context1;
            PVOID Context2;

            //
            // The remaining path name. For example in \\server\share\dir\f.txt
            // this would correspond to dir\f.txt.
            //
            PWCHAR RemPathName;

            //
            // The file name being created. From the above example, this would
            // correspond to f.txt.
            //
            PWCHAR FileName;

            //
            // The URL used to create an entry in the WinInet cache.
            //
            PWCHAR UrlBuffer;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif
            LPVOID  lpCEI;  // cache entry info

        } AsyncCreate;
        
        struct {
            
            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;
            
            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;
        
        } ServerUserEntry;
        //
        // Async SetFileInformation
        //
        struct {

            //
            // The per user entry which hangs of the server entry in the
            // hash table.
            //
            PPER_USER_ENTRY PerUserEntry;

            //
            // The server entry in the hash table.
            //
            PHASH_SERVER_ENTRY ServerHashEntry;

            //
            // The header which is added to the "MOVE" request to be sent to
            // the server and contains the destination URI.
            //
            PWCHAR HeaderBuff;

            //
            // Handle returned by HttpOpen and is used in http send, end etc.
            // calls.
            //
#ifdef WEBDAV_KERNEL
            LPVOID DavOpenHandle;
#else
            HINTERNET DavOpenHandle;
#endif
        
        } AsyncSetFileInformation;

    };

    //
    // The request and response types.
    //
    struct {
        union {
            DAV_USERMODE_WORK_REQUEST;
            DAV_USERMODE_WORK_REQUEST WorkRequest;
        };
        union {
            DAV_USERMODE_WORK_RESPONSE;
            DAV_USERMODE_WORK_RESPONSE WorkResponse;
        };
    };

    WCHAR UserName[MAX_PATH];
    WCHAR Password[MAX_PATH];

} DAV_USERMODE_WORKITEM, *PDAV_USERMODE_WORKITEM;

//
// The default HTTP/DAV port.
//
#define DEFAULT_HTTP_PORT 80

//
// The number of bytes to read in a single InternetReadFile call.
//
#define NUM_OF_BYTES_TO_READ 4096

#define EA_NAME_USERNAME            "UserName"
#define EA_NAME_PASSWORD            "Password"
#define EA_NAME_TYPE                "Type"
#define EA_NAME_WEBDAV_SIGNATURE    "mrxdav"

#endif // no __cplusplus

#endif // _USRMDDAV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\ea.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements the DAV Mini-Redir call down routines pertaining to
    query/set ea/security.

Author:

    Shishir Pardikar [ShishirP] 04/24/2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVQueryEaInformation)
#pragma alloc_text(PAGE, MRxDAVSetEaInformation)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVQueryEaInformation(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles Query EA Info requests for the DAV Mini-Redir. For now,
   we just return STATUS_EAS_NOT_SUPPORTED.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    PAGED_CODE();

    NtStatus = STATUS_EAS_NOT_SUPPORTED;

    return NtStatus;
}


NTSTATUS
MRxDAVSetEaInformation(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles Set EA Info requests for the DAV Mini-Redir. For now,
   we just return STATUS_EAS_NOT_SUPPORTED.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    NtStatus = STATUS_EAS_NOT_SUPPORTED;

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\fcbfobx.c ===
/*++ 

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fcbfobx.c

Abstract:

    This code manages the finalizing of the FCB and FOBX strucutres of the 
    DAV Mini-Redir.

Author:

    Rohan Kumar        [RohanK]       26-Sept-1999

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVDeallocateForFobxContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeFobxFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeFobxFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

VOID
DavLogDelayedWriteError(
    PUNICODE_STRING PathName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVDeallocateForFobx)
#pragma alloc_text(PAGE, MRxDAVDeallocateForFobxContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeFobxFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeFobxFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVCleanupFobx)
#pragma alloc_text(PAGE, MRxDAVDeallocateForFcb)
#pragma alloc_text(PAGE, DavLogDelayedWriteError)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVDeallocateForFobx(
    IN OUT PMRX_FOBX pFobx
    )
/*++

Routine Description:

    This routine is called when the wrapper is about to deallocate a FOBX.

Arguments:

    pFobx - the Fobx being deallocated.

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_FOBX DavFobx = NULL;
    PRX_CONTEXT RxContext = NULL;
    PMRX_SRV_CALL SrvCall;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PUNICODE_STRING RemainingName = NULL;

    PAGED_CODE();

    SrvCall = (PMRX_SRV_CALL)pFobx->pSrvOpen->pFcb->pNetRoot->pSrvCall;
    ASSERT(SrvCall);
    RxDeviceObject = SrvCall->RxDeviceObject;

    DavFobx = MRxDAVGetFobxExtension(pFobx);
    ASSERT(DavFobx != NULL);

    RemainingName = pFobx->pSrvOpen->pAlreadyPrefixedName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeallocateForFobx. RemainingName = %wZ.\n",
                  PsGetCurrentThreadId(), RemainingName));

    //
    // If this FOBX does not have a list of DavFileAttributes, we are done.
    //
    if (DavFobx->DavFileAttributes == NULL) {
        return NtStatus;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDeallocateForFobx. DavFileAttributes = %08lx.\n", 
                 PsGetCurrentThreadId(), DavFobx->DavFileAttributes));
    
    //
    // We need to finalize the list of DavFileAttributes.
    //

    //
    // Unfortunately, we do not have an RxContext here and hence have to create
    // one. An RxContext is required for a request to be reflected up.
    //
    RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
    if (RxContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVDeallocateForFobx/RxCreateRxContext: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // We need to send the Fobx to the format routine and use the 
    // MRxContext[1] pointer of the RxContext structure to store it.
    //
    RxContext->MRxContext[1] = (PVOID)pFobx;
    
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX,
                                        MRxDAVDeallocateForFobxContinuation,
                                        "MRxDAVDeallocateForFobx");
    if (NtStatus != ERROR_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVDeallocateForFobx/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    }

EXIT_THE_FUNCTION:

    if (RxContext) {
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVDeallocateForFobx with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));
    
    return(NtStatus);
}


NTSTATUS
MRxDAVDeallocateForFobxContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This is the continuation routine which finalizes an Fobx.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeallocateForFobxContinuation.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVDeallocateForFobxContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeFobxFinalizeRequest,
                              MRxDAVPrecompleteUserModeFobxFinalizeRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCallContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeFobxFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the Fobx finalize request being sent to the user 
    mode for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_FINALIZE_FOBX_REQUEST FinFobxReq = NULL;
    PMRX_FOBX Fobx = NULL;
    PWEBDAV_FOBX DavFobx = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeFobxFinalizeRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeFobxFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // We dont impersonate the user before going up to the user mode since
    // all we do in the user mode is free memory and the users credentials are 
    // not needed to do this.
    //

    //
    // Fobx was set to MRxContext[1] in MRxDAVDeallocateForFobx. We need it to
    // get the pointer to the DavFileAttributes list.
    //
    Fobx = (PMRX_FOBX)RxContext->MRxContext[1];
    DavFobx = MRxDAVGetFobxExtension(Fobx);
    ASSERT(DavFobx != NULL);
    ASSERT(DavFobx->DavFileAttributes != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeFobxFinalizeRequest. DavFileAttributes = %08lx.\n", 
                 PsGetCurrentThreadId(), DavFobx->DavFileAttributes));
    
    DavWorkItem->WorkItemType = UserModeFinalizeFobx;

    FinFobxReq = &(DavWorkItem->FinalizeFobxRequest);

    FinFobxReq->DavFileAttributes = DavFobx->DavFileAttributes;

    DavDbgTrace(DAV_TRACE_DETAIL,
            ("%ld: Leaving MRxDAVFormatUserModeFobxFinalizeRequest "
             "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeFobxFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the finalize Fobx request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeFobxFinalizeRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeFobxFinalizeRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // A FinalizeFobx request can never by Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the CloseSrvOpen case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeFobxFinalizeRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    NtStatus = AsyncEngineContext->Status;

    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeFobxFinalizeRequest: "
                     "Finalize Fobx failed in user mode.\n",
                     PsGetCurrentThreadId()));
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeFobxFinalizeRequest.\n",
                 PsGetCurrentThreadId()));
    
    return TRUE;
}


NTSTATUS
MRxDAVCleanupFobx(
      IN PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine cleansup a file system object. Normally a no op.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb);
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCleanupFobx: RemainingName: %wZ\n", 
                 PsGetCurrentThreadId(), RemainingName));
    
    IF_DEBUG {
        RxCaptureFobx;
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  
    }
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );
    ASSERT (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT));
    

    //
    // Because we only have one handle on the file, we do nothing for each
    // individual handle being closed. In this way we avoid doing paging ios.
    // We close the handle when the final close for the fcb comes down.
    //
    
    return(Status);
}

NTSTATUS
MRxDAVDeallocateForFcb(
    IN OUT PMRX_FCB pFcb
    )
/*++

Routine Description:

    This routine is called when the wrapper is about to deallocate a FCB.

Arguments:

    pFcb - the Fcb being deallocated.

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_FCB DavFcb = (PWEBDAV_FCB)(pFcb->Context);
    PWCHAR NtFileName = NULL;
    LONG FileWasModified = 0;
    
    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDeallocateForFcb: FileName: %ws\n",
                 PsGetCurrentThreadId(), DavFcb->FileName));

    //
    // If we allocated the FCB resource to synchronize the "read-modify-write"
    // sequence, we need to uninitialize and deallocate it now.
    //
    if (DavFcb->DavReadModifyWriteLock) {
        ExDeleteResourceLite(DavFcb->DavReadModifyWriteLock);
        RxFreePool(DavFcb->DavReadModifyWriteLock);
        DavFcb->DavReadModifyWriteLock = NULL;
    }

    //
    // If the value of DavFcb->FileWasModified is TRUE, it means that some write
    // never made it to the server. This is a delayed write failure in WebDav.
    // We need to notify this to the user. Hence we log an entry in the EventLog
    // and call IoRaiseInformationalHardError to inform the user.
    //

    FileWasModified = InterlockedCompareExchange(&(DavFcb->FileWasModified), 0, 0);

    if (FileWasModified != 0) {

        BOOLEAN RaiseHardError = FALSE;

        ASSERT(DavFcb->FileNameInfo.Buffer != NULL);

        //
        // Log that the write failed in the event log.
        //
        DavLogDelayedWriteError( &(DavFcb->FileNameInfo) );

        RaiseHardError = IoRaiseInformationalHardError(STATUS_LOST_WRITEBEHIND_DATA,
                                                       &(DavFcb->FileNameInfo),
                                                       NULL);
        if (!RaiseHardError) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVDeallocateForFcb/IoRaiseInformationalHardError",
                         PsGetCurrentThreadId()));
        }

    }

    //
    // If we allocated any memory for the FileNameInfo, we need to free it now.
    //
    if (DavFcb->FileNameInfo.Buffer) {
        ASSERT(DavFcb->FileNameInfoAllocated == TRUE);
        RxFreePool(DavFcb->FileNameInfo.Buffer);
        DavFcb->FileNameInfo.Buffer = NULL;
        DavFcb->FileNameInfo.Length = 0;
        DavFcb->FileNameInfo.MaximumLength = 0;
        DavFcb->FileNameInfoAllocated = FALSE;
    }

    //
    // Delete the EFS file cache at the end of the Fcb lifetime. If the file is
    // opened again, the EFS file cache will be restored from the WinInet cache
    // in backup formate. This way, WinInet does not involved in delete the EFS
    // file cache which will be denied in the context of LocalService.
    //
    if (DavFcb->LocalFileIsEncrypted) {
        NTSTATUS LocalNtStatus = STATUS_SUCCESS;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeFileName;
        ULONG SizeInBytes = 0;
        
        SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
        
        NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
        
        if (NtFileName == NULL) {
            //
            // cannot do much, bailout
            //
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVDeallocateForFcb/RxAllocatePoolWithTag failed", PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(NtFileName, SizeInBytes);

        wcscpy( NtFileName, L"\\??\\" );
        wcscpy( &(NtFileName[4]), DavFcb->FileName );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVDeallocateForFcb: NtFileName = %ws\n",
                     PsGetCurrentThreadId(), NtFileName));

        RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

        InitializeObjectAttributes( &ObjectAttributes,
                            &UnicodeFileName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

        LocalNtStatus = ZwDeleteFile( &(ObjectAttributes) );
        
        if (!NT_SUCCESS(LocalNtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVDeallocateForFcb/ZwDeleteFile"
                         ". NtStatus = %08lx %ws \n", PsGetCurrentThreadId(), LocalNtStatus,DavFcb->FileName));
        }
    }

EXIT_THE_FUNCTION:
    
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

    RtlZeroMemory(DavFcb, sizeof(WEBDAV_FCB));
    
    return(NtStatus);
}


VOID
DavLogDelayedWriteError(
    PUNICODE_STRING PathName
    )
/*++

Routine Description:

   This routine logs a delayed write error to the event log.

Arguments:

    PathName - The PathName for which the delayed write failed.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT RemainingLength = 0;
    UNICODE_STRING ErrorLog[1];
    
    PAGED_CODE();

    RemainingLength = ERROR_LOG_MAXIMUM_SIZE;
    RemainingLength -= sizeof(IO_ERROR_LOG_PACKET);
    RemainingLength -=  sizeof(UNICODE_NULL);

    //
    // If the length of the PathName is less than the RemainingLength, then we
    // print the entire path, otherwise we print the max amount allowed. This is
    // because the length of the error log message is limited by the
    // ERROR_LOG_MAXIMUM_SIZE.
    //
    if (PathName->Length > RemainingLength) {
        ErrorLog[0].Length = RemainingLength;
    } else {
        ErrorLog[0].Length = PathName->Length;
    }

    ErrorLog[0].MaximumLength = ErrorLog[0].Length;
    ErrorLog[0].Buffer = PathName->Buffer;

    RxLogEventWithAnnotation((PRDBSS_DEVICE_OBJECT)MRxDAVDeviceObject,
                             EVENT_DAV_REDIR_DELAYED_WRITE_FAILED,
                             STATUS_LOST_WRITEBEHIND_DATA,
                             NULL,
                             0,
                             ErrorLog,
                             1);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\cancel.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cancel.c

Abstract:

    This module implements the routines relating to the cancel logic in the 
    DAV MiniRedir.

Author:

    Rohan Kumar     [RohanK]    10-April-2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "netevent.h"
#include "nvisible.h"
#include "webdav.h"
#include "ntddmup.h"
#include "rxdata.h"
#include "fsctlbuf.h"

//
// The timeout values for various operations used by the MiniRedir. If an
// operation is not completed within the timeout value specified for it, is
// cancelled. The user can set the value to 0xffffffff to disable the
// timeout/cancel logic. In other words, if the timeout value is 0xffffffff,
// the requests will never timeout.
//
ULONG CreateRequestTimeoutValueInSec;
ULONG CreateVNetRootRequestTimeoutValueInSec;
ULONG QueryDirectoryRequestTimeoutValueInSec;
ULONG CloseRequestTimeoutValueInSec;
ULONG CreateSrvCallRequestTimeoutValueInSec;
ULONG FinalizeSrvCallRequestTimeoutValueInSec;
ULONG FinalizeFobxRequestTimeoutValueInSec;
ULONG FinalizeVNetRootRequestTimeoutValueInSec;
ULONG ReNameRequestTimeoutValueInSec;
ULONG SetFileInfoRequestTimeoutValueInSec;
ULONG QueryFileInfoRequestTimeoutValueInSec;
ULONG QueryVolumeInfoRequestTimeoutValueInSec;
ULONG LockRefreshRequestTimeoutValueInSec;

//
// The timer thread wakes up every "TimerThreadSleepTimeInSec" and cancels all
// the requests which haven't completed in their specified timeout value. This
// value is set to the min of the timeout values of all the requests mentioned
// above.
//
ULONG TimerThreadSleepTimeInSec;

//
// The timer object used by the timer thread that cancels the requests which
// have not completed in a specified time.
//
KTIMER DavTimerObject;

//
// This is used to indicate the timer thread to shutdown. When the system is
// being shutdown this is set to TRUE. MRxDAVTimerThreadLock is the resource
// used to gain access to this variable.
//
BOOL TimerThreadShutDown;
ERESOURCE MRxDAVTimerThreadLock;

//
// The handle of the timer thread that is created using PsCreateSystemThread
// is stored this global.
//
HANDLE TimerThreadHandle;

//
// This event is signalled by the timer thread right before its going to
// terminate itself.
//
KEVENT TimerThreadEvent;

//
// If QueueLockRefreshWorkItem is TRUE, the TimerThread (which cancels all the
// AsyncEngineContexts that haven't completed in a specified time) queues a 
// WorkItem to refresh the locks. After the WorkItem has been queued the value 
// of QueueLockRefreshWorkItem is set to FALSE. Once the worker thread is 
// done refreshing all the locks, it resets this value to TRUE. We have a
// corresponding lock QueueLockRefreshWorkItemLock to synchronize access to
// QueueLockRefreshWorkItem.
//
BOOL QueueLockRefreshWorkItem;
ERESOURCE QueueLockRefreshWorkItemLock;

//
// The WorkQueueItem used in the MRxDAVContextTimerThread function to refresh
// the LOCKs taken by this client.
//
RX_WORK_QUEUE_ITEM LockRefreshWorkQueueItem;

NTSTATUS
MRxDAVCancelTheContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVCompleteTheCancelledRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleGeneralCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleQueryDirCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCloseSrvOpenCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleSetFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCreateCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCreateSrvCallCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleSrvCallFinalizeCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCreateVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleFinalizeVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleCleanupFobxCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleRenameCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleQueryFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

NTSTATUS
MRxDAVHandleLockRefreshCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    );

VOID
MRxDAVRefreshTheServerLocks(
    PVOID DummyContext
    );

NTSTATUS
MRxDAVRefreshTheServerLocksContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeRefreshTheServerLockRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeRefreshTheServerLockRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVCancelRoutine(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine initiates the cancellation of an I/O request.

Arguments:

    RxContext - The RX_CONTEXT instance which needs to be cancelled.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PLIST_ENTRY listEntry = NULL;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    BOOL lockAcquired = FALSE, contextFound = FALSE;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCancelRoutine. RxContext = %08lx\n",
                 PsGetCurrentThreadId(), RxContext));

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
    lockAcquired = TRUE;

    listEntry = UMRxAsyncEngineContextList.Flink;

    while ( listEntry != &(UMRxAsyncEngineContextList) ) {

        //
        // Get the pointer to the UMRX_ASYNCENGINE_CONTEXT structure.
        //
        AsyncEngineContext = CONTAINING_RECORD(listEntry,
                                               UMRX_ASYNCENGINE_CONTEXT,
                                               ActiveContextsListEntry);

        listEntry = listEntry->Flink;

        //
        // Check to see if this entry is for the RxContext in question.
        //
        if (AsyncEngineContext->RxContext == RxContext) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVCancelRoutine: RxContext: %08lx FOUND\n",
                         PsGetCurrentThreadId(), RxContext));
            contextFound = TRUE;
            break;
        }

    }

    if (!contextFound) {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCancelTheContext: RxContext: %08lx NOT FOUND\n",
                     PsGetCurrentThreadId(), RxContext));
        goto EXIT_THE_FUNCTION;
    }

    NtStatus = MRxDAVCancelTheContext(AsyncEngineContext, TRUE);

EXIT_THE_FUNCTION:

    //
    // If we acquired the UMRxAsyncEngineContextListLock, then we need to
    // release it now.
    //
    if (lockAcquired) {
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCancelTheContext: Returning NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}

VOID
MRxDAVContextTimerThread(
    PVOID DummyContext
    )
/*++

Routine Description:

   This timer thread is created with this routine. The thread waits on a timer
   object which gets signalled TimerThreadSleepTimeInSec after it has been
   inserted into the timer queue.

Arguments:

    DummyContext - A dummy context that is supplied.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LONGLONG DueTimeInterval;
    LONG CopyTheRequestTimeValue;
    BOOLEAN setTimer = FALSE, lockAcquired = FALSE;

    CopyTheRequestTimeValue = TimerThreadSleepTimeInSec;

    do {

        //
        // If TimerThreadShutDown is set to TRUE, it means that the system is
        // being shutdown. The job of this thread is done. We check here after
        // we have gone through the context list and before we restart the wait.
        // We also check this below as soon as the DavTimerObject is signalled.
        //
        ExAcquireResourceExclusiveLite(&(MRxDAVTimerThreadLock), TRUE);
        lockAcquired = TRUE;
        if (TimerThreadShutDown) {
            break;
        }
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));
        lockAcquired = FALSE;

        //
        // We set the DueTimeInterval to be -ve TimerThreadSleepTimeInSec in 100
        // nano seconds. This is because this tells KeSetTimerEx that the 
        // expiration time is relative to the current system time.
        //
        DueTimeInterval = ( -CopyTheRequestTimeValue * 1000 * 1000 * 10 );

        //
        // Call KeSetTimerEx to insert the TimerObject in the system's timer
        // queue. Also, the return value should be FALSE since this timer
        // should not exist in the system queue.
        //
        setTimer = KeSetTimerEx(&(DavTimerObject), *(PLARGE_INTEGER)&(DueTimeInterval), 0, NULL);
        ASSERT(setTimer == FALSE);

        //
        // Wait for the timer object to be signalled. This call should only 
        // return if the wait has been satisfied, which implies that the return
        // value is STATUS_SUCCESS.
        //
        NtStatus = KeWaitForSingleObject(&(DavTimerObject),
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         NULL);
        ASSERT(NtStatus == STATUS_SUCCESS);

        //
        // If TimerThreadShutDown is set to TRUE, it means that the system is
        // being shutdown. The job of this thread is done. We check as soon as 
        // the DavTimerObject is signalled. We also check this above as soon
        // as we complete cycling through the context list.
        //
        ExAcquireResourceExclusiveLite(&(MRxDAVTimerThreadLock), TRUE);
        lockAcquired = TRUE;
        if (TimerThreadShutDown) {
            break;
        }
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));
        lockAcquired = FALSE;

        //
        // Now call MRxDAVTimeOutTheContexts which cycles through all the
        // currently active contexts and cancels the ones that have been hanging
        // around for more than their timeout values.
        //
        MRxDAVTimeOutTheContexts(FALSE);

        //
        // Now call MRxDAVCleanUpTheLockConflictList to delete all the expired
        // entries from the global LockConflictEntryList.
        //
        MRxDAVCleanUpTheLockConflictList(FALSE);

        //
        // We now post a workitem to a system worker thread. This calls the
        // function MRxDAVRefreshTheServerLocks which refreshes all the
        // currently active LOCKs. This is done if QueueLockRefreshWorkItem
        // is TRUE. After posting the workitem, its set to FALSE. Once the
        // workitem is dequeued and the locks are refreshed, its reset to
        // TRUE by the worker thread.
        //
        ExAcquireResourceExclusiveLite(&(QueueLockRefreshWorkItemLock), TRUE);
        if (QueueLockRefreshWorkItem) {
            NtStatus = RxPostToWorkerThread((PRDBSS_DEVICE_OBJECT)MRxDAVDeviceObject,
                                            CriticalWorkQueue,
                                            &(LockRefreshWorkQueueItem),
                                            MRxDAVRefreshTheServerLocks,
                                            NULL);
            ASSERT(NtStatus == STATUS_SUCCESS);
            QueueLockRefreshWorkItem = FALSE;
        }
        ExReleaseResourceLite(&(QueueLockRefreshWorkItemLock));

    } while (TRUE);

    //
    // If the lock is still acquired, we need to release it.
    //
    if (lockAcquired) {
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));
        lockAcquired = FALSE;
    }

    //
    // Set the timer thread event signalling that the timer thread is done
    // with the MRxDAVTimerThreadLock and that it can be deleted.
    //
    KeSetEvent(&(TimerThreadEvent), 0, FALSE);

    //
    // Close the thread handle to remove the reference on the object. We need 
    // to do this before we call PsTerminateSystemThread.
    //
    ZwClose(TimerThreadHandle);

    //
    // Terminate this thread since we are going to shutdown now.
    //
    PsTerminateSystemThread(STATUS_SUCCESS);

    return;
}


VOID
MRxDAVTimeOutTheContexts(
    BOOL WindDownAllContexts
    )
/*++

Routine Description:

   This routine is called by the thread that wakes up every "X" minutes to see
   if some AsyncEngineContext has been hanging around in the active contexts
   list for more than "X" minutes. If it finds some such context, it just cancels
   the operation. The value "X" is read from the registry and is stored in the
   global variable MRxDAVRequestTimeoutValueInSec at driver init time. This value
   defaults to 10 min. In other words, if an operation has not completed in "X"
   minutes, it is cancelled. The user can set this value to 0xffffffff to turn
   off the timeout. 
   
   It can also be called by the thread that is trying to complete all the 
   requests and stop the MiniRedir. This happens when the WebClient service 
   is being stopped.

Arguments:

    WindDownAllContexts - If this is set to TRUE, then all the contexts are
                          cancelled no matter when they were added to the list.
                          This is set to FALSE by the timer thread and to TRUE
                          by the thread that is stopping the MiniRedir.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PLIST_ENTRY listEntry = NULL;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    PWEBDAV_CONTEXT DavContext = NULL;
    BOOL lockAcquired = FALSE;
    LARGE_INTEGER CurrentSystemTickCount, TickCountDifference;
    LARGE_INTEGER RequestTimeoutValueInTickCount;
    ULONG RequestTimeoutValueInSec = 0;

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
    lockAcquired = TRUE;

    listEntry = UMRxAsyncEngineContextList.Flink;

    while ( listEntry != &(UMRxAsyncEngineContextList) ) {

        //
        // Get the pointer to the UMRX_ASYNCENGINE_CONTEXT structure.
        //
        AsyncEngineContext = CONTAINING_RECORD(listEntry,
                                               UMRX_ASYNCENGINE_CONTEXT,
                                               ActiveContextsListEntry);

        listEntry = listEntry->Flink;

        DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

        if (!WindDownAllContexts) {

            switch (DavContext->EntryPoint) {

            case DAV_MINIRDR_ENTRY_FROM_CREATE:
                RequestTimeoutValueInSec = CreateRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX:
                RequestTimeoutValueInSec = FinalizeFobxRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL:
                RequestTimeoutValueInSec = CreateSrvCallRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT:
                RequestTimeoutValueInSec = CreateVNetRootRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL:
                RequestTimeoutValueInSec = FinalizeSrvCallRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT:
                RequestTimeoutValueInSec = FinalizeVNetRootRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN:
                RequestTimeoutValueInSec = CloseRequestTimeoutValueInSec;
                break;
            
            case DAV_MINIRDR_ENTRY_FROM_RENAME:
                RequestTimeoutValueInSec = ReNameRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_QUERYDIR:
                RequestTimeoutValueInSec = QueryDirectoryRequestTimeoutValueInSec;
                break;
            
            case DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION:
                RequestTimeoutValueInSec = SetFileInfoRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION:
                RequestTimeoutValueInSec = QueryFileInfoRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_QUERYVOLUMEINFORMATION:
                RequestTimeoutValueInSec = QueryVolumeInfoRequestTimeoutValueInSec;
                break;

            case DAV_MINIRDR_ENTRY_FROM_REFRESHTHELOCK:
                RequestTimeoutValueInSec = LockRefreshRequestTimeoutValueInSec;
                break;

            default:
                DbgPrint("MRxDAVTimeOutTheContexts: EntryPoint = %d\n", DavContext->EntryPoint);
                ASSERT(FALSE);
            
            }

            //
            // Calculate the timeout value in TickCount (100 nano seconds) using
            // the timeout value in seconds) which we got from above. Step1 below
            // calculates the number of ticks that happen in one second. Step2
            // below calculates the number of ticks in RequestTimeoutValueInSec.
            //
            RequestTimeoutValueInTickCount.QuadPart = ( (1000 * 1000 * 10) / KeQueryTimeIncrement() );
            RequestTimeoutValueInTickCount.QuadPart *= RequestTimeoutValueInSec;
            
            KeQueryTickCount( &(CurrentSystemTickCount) );

            //
            // Get the time elapsed (in system tick counts) since the time this
            // AsyncEngineContext was created.
            //
            TickCountDifference.QuadPart = (CurrentSystemTickCount.QuadPart - AsyncEngineContext->CreationTimeInTickCount.QuadPart);

            //
            // If the amount of time that has elapsed since this context was added
            // to the list is greater than the timeout value, then cancel the
            // request.
            //
            if (TickCountDifference.QuadPart > RequestTimeoutValueInTickCount.QuadPart) {
                NtStatus = MRxDAVCancelTheContext(AsyncEngineContext, FALSE);
            }

        } else {

            //
            // If we were asked to wind down all the contexts then we cancel
            // every request no matter when it was inserted into the active
            // context list.
            //
            NtStatus = MRxDAVCancelTheContext(AsyncEngineContext, FALSE);

        }

    }

    if (lockAcquired) {
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;
    }

    return;
}


NTSTATUS
MRxDAVCancelTheContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles the cancellation of an I/O request. The caller of this
   routine needs to acquire the global UMRxAsyncEngineContextListLock before
   the call is made.

Arguments:

    AsyncEngineContext - The UMRX_ASYNCENGINE_CONTEXT instance which needs to be
                         cancelled.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = NULL;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCancelTheContext. AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    //
    // We do not cancel read and wrtie operations.
    //
    switch (DavContext->EntryPoint) {
    case DAV_MINIRDR_ENTRY_FROM_READ:
    case DAV_MINIRDR_ENTRY_FROM_WRITE:
        goto EXIT_THE_FUNCTION;
    }

    //
    // We shouldn't be getting cancel I/O calls for which the MiniRedir callouts
    // which cannot be cancelled by the user. These can however be cancelled
    // by the timeout thread.
    //
    if (UserInitiatedCancel) {
        switch (DavContext->EntryPoint) {
        case DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL:
        case DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL:
        case DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX:
        case DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT:
        case DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT:
        case DAV_MINIRDR_ENTRY_FROM_CREATE:
            DbgPrint("MRxDAVCancelTheContext: Invalid EntryPoint = %d\n", DavContext->EntryPoint);
            ASSERT(FALSE);
            goto EXIT_THE_FUNCTION;
        }
    }

    switch (AsyncEngineContext->AsyncEngineContextState) {

    case UMRxAsyncEngineContextAllocated:
    case UMRxAsyncEngineContextInUserMode:
        AsyncEngineContext->AsyncEngineContextState = UMRxAsyncEngineContextCancelled;
        break;

    default:
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCancelTheContext: NOT Being Cancelled. AsyncEngineContextState: %d\n",
                     PsGetCurrentThreadId(), AsyncEngineContext->AsyncEngineContextState));
        goto EXIT_THE_FUNCTION;

    }

    NtStatus = MRxDAVCompleteTheCancelledRequest(AsyncEngineContext, UserInitiatedCancel);

EXIT_THE_FUNCTION:

    return NtStatus;
}


NTSTATUS
MRxDAVCompleteTheCancelledRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion if the request that has been cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context of the operation that is being
                         cancelled.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCompleteTheCancelledRequest. AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    switch (DavContext->EntryPoint) {
    
    case DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL:
        NtStatus = MRxDAVHandleCreateSrvCallCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT:
        NtStatus = MRxDAVHandleCreateVNetRootCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_FINALIZESRVCALL:
        NtStatus = MRxDAVHandleSrvCallFinalizeCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_FINALIZEVNETROOT:
        NtStatus = MRxDAVHandleFinalizeVNetRootCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CREATE:
        NtStatus = MRxDAVHandleCreateCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_QUERYDIR:
        NtStatus = MRxDAVHandleQueryDirCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CLOSESRVOPEN:
        NtStatus = MRxDAVHandleCloseSrvOpenCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION:
        NtStatus = MRxDAVHandleSetFileInfoCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_CLEANUPFOBX:
        NtStatus = MRxDAVHandleCleanupFobxCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_RENAME:
        NtStatus = MRxDAVHandleRenameCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_QUERYFILEINFORMATION:
        NtStatus = MRxDAVHandleQueryFileInfoCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    case DAV_MINIRDR_ENTRY_FROM_REFRESHTHELOCK:
        NtStatus = MRxDAVHandleLockRefreshCancellation(AsyncEngineContext, UserInitiatedCancel);
        goto EXIT_THE_FUNCTION;

    default:
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCancelTheContext: EntryPoint: %d\n",
                     PsGetCurrentThreadId(), DavContext->EntryPoint));
        goto EXIT_THE_FUNCTION;

    }

EXIT_THE_FUNCTION:

    return NtStatus;
}


NTSTATUS
MRxDAVHandleGeneralCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the some requests which has been cancelled.
   Its called by those rotuines whose completion is straight forward and does
   not require any special handling.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;

    //
    // Only an AsyncOperation which would have returned STATUS_IO_PENDING
    // can be cancelled by a user.
    //
    if (UserInitiatedCancel) {
        ASSERT(AsyncEngineContext->AsyncOperation == TRUE);
    }

    RxContext = AsyncEngineContext->RxContext;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVHandleGeneralCancellation: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // If this cancel operation was initiated by the user, we return
    // STATUS_CANCELLED. If it was initiated by the timeout thread, we return
    // STATUS_IO_TIMEOUT.
    //
    if (UserInitiatedCancel) {
        AsyncEngineContext->Status = STATUS_CANCELLED;
    } else {
        AsyncEngineContext->Status = STATUS_IO_TIMEOUT;
    }

    AsyncEngineContext->Information = 0;

    //
    // We take different course of action depending upon whether this request
    // was a synchronous or an asynchronous request.
    //
    if (AsyncEngineContext->AsyncOperation) {
        //
        // Complete the request by calling RxCompleteRequest.
        //
        RxContext->CurrentIrp->IoStatus.Status = AsyncEngineContext->Status;
        RxContext->CurrentIrp->IoStatus.Information = AsyncEngineContext->Information;
        RxCompleteRequest(RxContext, AsyncEngineContext->Status);
    } else {
        //
        // This was a synchronous request. There is a thread waiting for this
        // request to finish and be signalled. Signal the thread that is waiting
        // after queuing the workitem on the KQueue.
        //
        RxSignalSynchronousWaiter(RxContext);
    }

    return NtStatus;
}


NTSTATUS
MRxDAVHandleQueryDirCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the QueryDirectory request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleQueryDirCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCloseSrvOpenCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CloseSrvOpen request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_FCB Fcb = AsyncEngineContext->RxContext->pRelevantSrvOpen->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(Fcb);

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCloseSrvOpenCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    //
    // If we had reset FileWasModified to 0 in the FormatCloseSrvOpen function,
    // then we need to reset it to 1.
    //
    if (DavFcb->FileModifiedBitReset) {
        InterlockedExchange(&(DavFcb->FileWasModified), 1);
        DavFcb->FileModifiedBitReset = FALSE;
    }

    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleSetFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the SetFileInfo request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleSetFileInfoCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCreateCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the Create request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCreateCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCreateSrvCallCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CreateSrvCall request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;

    RxContext = AsyncEngineContext->RxContext;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCreateSrvCallCancellation: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    //
    // A CreateSrvCall operation is always Async.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == TRUE);

    SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
    ASSERT(SCCBC != NULL);
    SrvCalldownStructure = SCCBC->SrvCalldownStructure;
    ASSERT(SrvCalldownStructure != NULL);
    SrvCall = SrvCalldownStructure->SrvCall;
    ASSERT(SrvCall != NULL);

    //
    // We allocated memory for it, so it better not be NULL.
    //
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);

    if (DavSrvCall->SCAlreadyInitialized) {
        ASSERT(RxContext->MRxContext[2] != NULL);
        SeDeleteClientSecurity((PSECURITY_CLIENT_CONTEXT)RxContext->MRxContext[2]);
        RxFreePool(RxContext->MRxContext[2]);
        RxContext->MRxContext[2] = NULL;
        DavSrvCall->SCAlreadyInitialized = FALSE;
    }

    //
    // Set the status in the callback structure. If a CreateSrvCall is being
    // cancelled, this implies that it is being done by the timeout thread
    // since a user can never cancel a create request. Hence the status we set
    // is STATUS_IO_TIMEOUT.
    //
    ASSERT(UserInitiatedCancel == FALSE);
    SCCBC->Status = STATUS_IO_TIMEOUT;
    
    //
    // Call the callback function supplied by RDBSS.
    //
    SrvCalldownStructure->CallBack(SCCBC);
    
    return NtStatus;
}


NTSTATUS
MRxDAVHandleSrvCallFinalizeCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the SrvCallFinalize request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleSrvCallFinalizeCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCreateVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CreateVNetRoot request which has been 
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;

    RxContext = AsyncEngineContext->RxContext;
    
    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCreateVNetRootCancellation: "
                 "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
    // RxContext structure. This is done in the MRxDAVCreateVNetRoot
    // function.
    //
    VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
    DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
    ASSERT(DavVNetRoot != NULL);

    DavVNetRoot->createVNetRootUnSuccessful = TRUE;

    //
    // Set the status in the AsyncEngineContext. If a CreateSrvCall is being
    // cancelled, this implies that it is being done by the timeout thread
    // since a user can never cancel a create request. Hence the status we set
    // is STATUS_IO_TIMEOUT.
    //
    ASSERT(UserInitiatedCancel == FALSE);
    AsyncEngineContext->Status = STATUS_IO_TIMEOUT;

    //
    // This was a synchronous request. There is a thread waiting for this
    // request to finish and be signalled. Signal the thread that is waiting
    // after queuing the workitem on the KQueue.
    //
    ASSERT(AsyncEngineContext->AsyncOperation == FALSE);
    RxSignalSynchronousWaiter(RxContext);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleFinalizeVNetRootCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the FinalizeVNetRoot request which has
   been cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleFinalizeVNetRootCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleCleanupFobxCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the CleanupFobx request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleCleanupFobxCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));
    
    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleRenameCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the Rename request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleRenameCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleQueryFileInfoCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the QueryFileInfo request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleQueryFileInfoCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


NTSTATUS
MRxDAVHandleLockRefreshCancellation(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    BOOL UserInitiatedCancel
    )
/*++

Routine Description:

   This routine handles completion of the QueryFileInfo request which has been
   cancelled.

Arguments:

    AsyncEngineContext - The DAV Redir's context describing the CreateSrvCall
                         operation.

    UserInitiatedCancel - TRUE - This cancel was initiated by a user request.
                          FALSE - This cancel was initiated by the timeout
                                  mechanism.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DavDbgTrace(DAV_TRACE_ERROR,
                ("%ld: MRxDAVHandleLockRefreshCancellation: "
                 "AsyncEngineContext = %08lx\n",
                 PsGetCurrentThreadId(), AsyncEngineContext));

    NtStatus = MRxDAVHandleGeneralCancellation(AsyncEngineContext, UserInitiatedCancel);

    return NtStatus;
}


VOID
MRxDAVRefreshTheServerLocks(
    PVOID DummyContext
    )
/*++

Routine Description:

   This routine is called by the timer thread to refresh the LOCKs that have
   been taken on various files which are shared on different servers. The
   LOCKs are granted by the server for a limited period of time and if the
   client wants to hold the LOCK for a longer period than that, it needs to
   send a refresh request to the server.

Arguments:

    DummyContext - A dummy context that is supplied.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PLIST_ENTRY TokenListEntry = NULL;
    PWEBDAV_LOCK_TOKEN_ENTRY LockTokenEntry = NULL;
    BOOL lockAcquired = FALSE;
    LARGE_INTEGER CurrentSystemTickCount, TickCountDifference;
    LARGE_INTEGER LockTimeoutValueInTickCount;
    PRX_CONTEXT RxContext = NULL;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = (PRDBSS_DEVICE_OBJECT)MRxDAVDeviceObject;

    ExAcquireResourceExclusiveLite(&(LockTokenEntryListLock), TRUE);
    lockAcquired = TRUE;

    TokenListEntry = LockTokenEntryList.Flink;

    while ( TokenListEntry != &(LockTokenEntryList) ) {

        //
        // Get the pointer to the WEBDAV_LOCK_TOKEN_ENTRY structure.
        //
        LockTokenEntry = CONTAINING_RECORD(TokenListEntry,
                                           WEBDAV_LOCK_TOKEN_ENTRY,
                                           listEntry);

        TokenListEntry = TokenListEntry->Flink;

        //
        // An RxContext is required for a request to be reflected up.
        //
        RxContext = RxCreateRxContext(NULL, RxDeviceObject, 0);
        if (RxContext == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVRefreshTheServerLocks/RxCreateRxContext: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        //
        // Calculate the timeout value in TickCount (100 nano seconds) using
        // the timeout value in seconds). Step1 below calculates the number of
        // ticks that happen in one second. Step2 below calculates the number
        // of ticks in LockTimeoutValueInSec.
        //
        LockTimeoutValueInTickCount.QuadPart = ( (1000 * 1000 * 10) / KeQueryTimeIncrement() );
        LockTimeoutValueInTickCount.QuadPart *= LockTokenEntry->LockTimeOutValueInSec;

        KeQueryTickCount( &(CurrentSystemTickCount) );

        //
        // Get the time elapsed (in system tick counts) since the time this
        // LockTokenEntry was created.
        //
        TickCountDifference.QuadPart = (CurrentSystemTickCount.QuadPart - LockTokenEntry->CreationTimeInTickCount.QuadPart);

        //
        // If the time difference betweeen the current time and the last time
        // this LOCK was refreshed is greater than LockTimeOut/2, we need to
        // refresh this LOCK. To refresh the LOCK, we need to go to the usermode
        // to send the request. Also, we only refresh this lock if the value of
        // LockTokenEntry->ShouldThisEntryBeRefreshed is TRUE.
        //
        if ( LockTokenEntry->ShouldThisEntryBeRefreshed && 
             TickCountDifference.QuadPart > (LockTimeoutValueInTickCount.QuadPart / 2) ) {

            //
            // We need to store the LockTokenEntry in the RxContext since it
            // will be needed to impersonate the client and refresh the LOCK.
            //
            RxContext->MRxContext[1] = LockTokenEntry;

            NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                                SIZEOF_DAV_SPECIFIC_CONTEXT,
                                                MRxDAVFormatTheDAVContext,
                                                DAV_MINIRDR_ENTRY_FROM_REFRESHTHELOCK,
                                                MRxDAVRefreshTheServerLocksContinuation,
                                                "MRxDAVRefreshTheServerLocks");
            if (NtStatus != ERROR_SUCCESS) {
                //
                // Even if we fail to refresh one LOCK we continue to refresh
                // the remaining LOCKs in the LockTokenEntryList.
                //
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: MRxDAVRefreshTheServerLocks/UMRxAsyncEngOuterWrapper: "
                             "LockTokenEntry = %08lx, NtStatus = %08lx.\n",
                             PsGetCurrentThreadId(), LockTokenEntry, NtStatus));
            }

        }

        //
        // We take the reference out on the RxContext we allocated above. If
        // NtStatus is not STATUS_CANCELLED, this also lands up freeing the 
        // RxContext since this would be the last reference on the RxContext.
        // If NtStatus is STATUS_CANCELLED then the AsyncEngineContext associated
        // with this RxContext might have a reference on this RxContext (if the
        // request hasn't come back from the usermode). In such a scenario, the
        // RxContext is freed up when request comes back from the usermode.
        //
        RxDereferenceAndDeleteRxContext(RxContext);

    }

EXIT_THE_FUNCTION:

    if (lockAcquired) {
        ExReleaseResourceLite(&(LockTokenEntryListLock));
        lockAcquired = FALSE;
    }

    //
    // Before we exit, we need to set QueueLockRefreshWorkItem to TRUE so
    // that a new WorkItem can get queued to refresh the active locks.
    //
    ExAcquireResourceExclusiveLite(&(QueueLockRefreshWorkItemLock), TRUE);
    QueueLockRefreshWorkItem = TRUE;
    ExReleaseResourceLite(&(QueueLockRefreshWorkItemLock));

    return;
}


NTSTATUS
MRxDAVRefreshTheServerLocksContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:

    This is the continuation routine which refreshes a LOCK.

Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVRefreshTheServerLocksContinuation\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVRefreshTheServerLocksContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeRefreshTheServerLockRequest,
                              MRxDAVPrecompleteUserModeRefreshTheServerLockRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFinalizeSrvCallContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeRefreshTheServerLockRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the LOCK refresh request being sent to the user mode
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PWEBDAV_LOCK_TOKEN_ENTRY LockTokenEntry = NULL;
    PDAV_USERMODE_LOCKREFRESH_REQUEST LockRefreshRequest = NULL;
    PBYTE ServerName = NULL, PathName = NULL, OpaqueLockToken = NULL;
    ULONG ServerNameLengthInBytes = 0, PathNameLengthInBytes = 0, OpaqueLockTokenLengthInBytes = 0;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeRefreshTheServerLockRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeRefreshTheServerLockRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    LockRefreshRequest = &(DavWorkItem->LockRefreshRequest);

    //
    // LockTokenEntry was set to MRxContext[1] in the MRxDAVRefreshTheServerLocks
    // routine.
    //
    LockTokenEntry = (PWEBDAV_LOCK_TOKEN_ENTRY)RxContext->MRxContext[1];

    DavWorkItem->WorkItemType = UserModeLockRefresh;

    //
    // Copy the ServerName.
    //

    ServerNameLengthInBytes = (1 + wcslen(LockTokenEntry->ServerName)) * sizeof(WCHAR);
    ServerName = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                             ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeRefreshTheServerLockRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    LockRefreshRequest->ServerName = (PWCHAR)ServerName;

    wcscpy(LockRefreshRequest->ServerName, LockTokenEntry->ServerName);

    //
    // Copy the PathName.
    //

    PathNameLengthInBytes = (1 + wcslen(LockTokenEntry->PathName)) * sizeof(WCHAR);
    PathName = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                           PathNameLengthInBytes);
    if (PathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeRefreshTheServerLockRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    LockRefreshRequest->PathName = (PWCHAR)PathName;

    wcscpy(LockRefreshRequest->PathName, LockTokenEntry->PathName);

    //
    // Copy the OpaqueLockToken.
    //

    OpaqueLockTokenLengthInBytes = (1 + wcslen(LockTokenEntry->OpaqueLockToken)) * sizeof(WCHAR);
    OpaqueLockToken = UMRxAllocateSecondaryBuffer(AsyncEngineContext, 
                                                  OpaqueLockTokenLengthInBytes);
    if (OpaqueLockToken == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: MRxDAVFormatUserModeRefreshTheServerLockRequest/"
                     "UMRxAllocateSecondaryBuffer: ERROR: NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    LockRefreshRequest->OpaqueLockToken = (PWCHAR)OpaqueLockToken;

    wcscpy(LockRefreshRequest->OpaqueLockToken, LockTokenEntry->OpaqueLockToken);

    LockRefreshRequest->ServerID = LockTokenEntry->ServerID;

    LockRefreshRequest->LogonID.LowPart = LockTokenEntry->LogonID.LowPart;
    LockRefreshRequest->LogonID.HighPart = LockTokenEntry->LogonID.HighPart;

    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(LockTokenEntry->SecurityClientContext, WorkItemHeader);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeRefreshTheServerLockRequest/"
                     "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVFormatUserModeRefreshTheServerLockRequest "
                 "with NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeRefreshTheServerLockRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the LOCK refresh request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PDAV_USERMODE_LOCKREFRESH_REQUEST LockRefreshRequest = NULL;
    PDAV_USERMODE_LOCKREFRESH_RESPONSE LockRefreshResponse = NULL;
    PWEBDAV_LOCK_TOKEN_ENTRY LockTokenEntry = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVPrecompleteUserModeRefreshTheServerLockRequest\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeRefreshTheServerLockRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    LockRefreshRequest = &(DavWorkItem->LockRefreshRequest);
    LockRefreshResponse = &(DavWorkItem->LockRefreshResponse);

    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeRefreshTheServerLockRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }
    
    //
    // We need to free up the heap we allocated in the format routine.
    //
    
    if (LockRefreshRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)LockRefreshRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeRefreshTheServerLockRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }
    
    if (LockRefreshRequest->PathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)LockRefreshRequest->PathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeRefreshTheServerLockRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }
    
    if (LockRefreshRequest->OpaqueLockToken != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext,
                                           (PBYTE)LockRefreshRequest->OpaqueLockToken);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeRefreshTheServerLockRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
        }

    }

    if (!OperationCancelled) {

        //
        // LockTokenEntry was set to MRxContext[1] in the MRxDAVRefreshTheServerLocks
        // routine.
        //
        LockTokenEntry = (PWEBDAV_LOCK_TOKEN_ENTRY)RxContext->MRxContext[1];

        //
        // Get the new timeout value returned by the server.
        //
        LockTokenEntry->LockTimeOutValueInSec = LockRefreshResponse->NewTimeOutInSec;

        //
        // Set the current system time as the new creation time of the entry.
        //
        KeQueryTickCount( &(LockTokenEntry->CreationTimeInTickCount) );

    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVPrecompleteUserModeRefreshTheServerLockRequest\n",
                 PsGetCurrentThreadId()));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\davwmik.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DavWmiK.h

Abstract:

    This module contains the global definitions and macros needed for the WMI 
    Logging feature in the kernel for the DAV MiniRedir.

Author:

    Rohan Kumar     [RohanK]    06-June-2000

Revision History:

--*/

#ifndef _DAVWMIK_H_
#define _DAVWMIK_H_

typedef struct _RTL_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[32];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[32];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;

#ifndef _WMIKM_
#define _WMIKM_
#endif

//
// Include the header files which exist in the rdr2\wmi directory.
//
#include "..\..\..\..\wmi\wmlkm.h"
#include "..\..\..\..\wmi\wmlmacro.h"

//
// DAV Streams.
//
#define _DAV_TRACE_STREAM               0x00
#define _DAV_PERF_STREAM                0x01
#define _DAV_INSTR_STREAM               0x02

#define _DAV_ENABLE_ERROR               0x0001
#define _DAV_ENABLE_LOG                 0x0002
#define _DAV_ENABLE_TRACE               0x0004
#define _DAV_ENABLE_SERVER              0x0008
#define _DAV_ENABLE_NETROOT             0x0010
#define _DAV_ENABLE_VNETROOT            0x0020
#define _DAV_ENABLE_FCB                 0x0040
#define _DAV_ENABLE_SRVOPEN             0x0080
#define _DAV_ENABLE_FOBX                0x0100
#define _DAV_ENABLE_TRANSPORT           0x0200
#define _DAV_ENABLE_RXCONTEXT           0x0400
#define _DAV_ENABLE_SESSION             0x0800
#define _DAV_ENABLE_SECURITY            0x1000
#define _DAV_ENABLE_EXCHANGE            0x2000
#define _DAV_ENABLE_UNUSED2             0x4000
#define _DAV_ENABLE_UNUSED1             0x8000

#define _DAV_LEVEL_DETAIL               0x1
#define _DAV_LEVEL_NORM                 0x2
#define _DAV_LEVEL_BRIEF                0x4

#define DAV_LOG_STREAM(_stream)   _DAV_ ## _stream ## _STREAM
#define DAV_LOG_FLAGS(_flag)      _DAV_ENABLE_ ## _flag
#define DAV_LOG_LEVEL(_level)     _DAV_LEVEL_ ## _level

#define DAV_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(MRxDav_, DAV_LOG_STREAM(_why), DAV_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,

#define DavTrace(_flag, _type, _arg)              \
            DAV_LOG(TRACE, DETAIL, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DavLog(_flag, _type, _arg)              \
            DAV_LOG(TRACE, BRIEF, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DavTraceError(_status, _flag, _type, _arg)    \
            DAV_LOG(TRACE, DETAIL, (DAV_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DAV_LOG_FLAGS(ERROR))), _type, _arg)

#define DavLogError(_status, _flag, _type, _arg)    \
            DAV_LOG(TRACE, BRIEF, (DAV_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : DAV_LOG_FLAGS(ERROR))), _type, _arg)

#if 0
#define DAV_PERF(_flag, _type, _arg)                    \
            DAV_LOG (PERF, HIGH, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DAV_INSTR(_flag, _type, _arg)                   \
            DAV_LOG (INSTR, HIGH, DAV_LOG_FLAGS(_flag), _type, _arg)

#define DAV_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, DAV_LOG_STREAM(_why), DAV_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define DAV_DBG_PRINT(_flag, _fmtstr, _arg)             \
            DAV_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define DAV_ERR_PRINT(_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                DAV_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }
#endif


enum DAV_WMI_ENUM {
  MSG_ID_DavDefault = 1,
  MSG_ID_MRxDavFsdDispatch_1 = 2
}; 

#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)

extern WML_CONTROL_GUID_REG MRxDav_ControlGuids[];

extern BOOLEAN DavEnableWmiLog;

#endif // _DAVWMIK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\chngnote.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    chngnote.c

Abstract:

    This module will someday implement change notify. currently it just returns
    not_implemented. when we have async upcalls, we will revisit this.

Author:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
//  The local debug trace level
//


//BUGBUG we need to implement change directory........
typedef struct _UMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT_ {
   PRX_CONTEXT                         pRxContext;
   //REQ_NOTIFY_CHANGE                   NotifyRequest;
} UMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT, *PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT;

VOID
UMRxNotifyChangeDirectoryCompletion(
   PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext)
/*++

Routine Description:

   This routine is invokde when a directory change notification operation is completed

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine will always be called. This is true even if the change directory
    notification is cancelled. In such cases the memory allocated is freed without
    any inteaction with the wrapped. In cases os successful directory change
    notification completion the appropriate completion routine is invoked and the
    RxContext modified to prevent any cancellation from proceeding further.

--*/
{
    NTSTATUS           Status;
    PRX_CONTEXT        pRxContext;
    PUMRX_RX_CONTEXT pUMRxContext;

    MRxDAVAcquireGlobalSpinLock();

    pRxContext     = pNotificationContext->pRxContext;

    if (pRxContext != NULL) {
        // This is a case of successful completion of the change directory
        // notification, i.e., the request was not cancelled. In such cases
        // prevent all race conditions by modifying the RxContext under lock
        // to turn back cancellation request.

        pUMRxContext = UMRxGetMinirdrContext(pRxContext);

        pUMRxContext->pCancelContext   = NULL;
        pNotificationContext->pRxContext = NULL;
    }

    MRxDAVReleaseGlobalSpinLock();

    // Complete the Context if it was not previously cancelled
    if (pRxContext != NULL) {
        //pResumptionContext  = &(pNotificationContext->ResumptionContext);
        //pRxContext->StoredStatus = pResumptionContext->FinalStatusFromServer;

        Status = RxSetMinirdrCancelRoutine(pRxContext,NULL);
        if (Status == STATUS_SUCCESS) {
            RxLowIoCompletion(pRxContext);
        }
    }

#if 0
    // Free the associated exchange.
    if (pExchange != NULL) {
        UMRxCeDereferenceAndDiscardExchange(pExchange);
    }
#endif //0

    // Free the notification context.
    RxFreePool(pNotificationContext);
}

NTSTATUS
UMRxNotifyChangeDirectoryCancellation(
   PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine is invokde when a directory change notification operation is cancelled.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    //NTSTATUS Status;

    BOOLEAN ChangeDirectoryNotificationCompleted;

    PUMRX_RX_CONTEXT pUMRxContext = UMRxGetMinirdrContext(RxContext);

    PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

    MRxDAVAcquireGlobalSpinLock();

    pNotificationContext = (PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT)pUMRxContext->pCancelContext;
    ChangeDirectoryNotificationCompleted = (pNotificationContext == NULL);

    if (!ChangeDirectoryNotificationCompleted) {
        // This is a case of successful cancellation of the change directory
        // notification. In such cases prevent all race conditions by modifying
        // the RxContext under lock to prevent successful completion

        pNotificationContext->pRxContext = NULL;
        pUMRxContext->pCancelContext   = NULL;
    }

    MRxDAVReleaseGlobalSpinLock();

    if (ChangeDirectoryNotificationCompleted) {
        // The cancellation is trivial since the request has already been completed
        return STATUS_SUCCESS;
    }

    // Complete the request.
    RxContext->StoredStatus = STATUS_CANCELLED;

    RxLowIoCompletion(RxContext);

    return STATUS_SUCCESS;
}

NTSTATUS
UMRxNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

BUGBUG THIS STUFF IS WRONG!!!!! It refers to the smbmini implementation.
i am leaving most stuff in to guide the implementation for the reflector.


    A directory change notification opertaion is an asychronous operation. It
    consists of sending a change notification whose response is
    obtained when the desired change is affected on the server.

    Some important points to remember are as follows .....

      1) The response is not obtained till the desired change is affected on
      the server. Therefore an additional MID needs to be reserved on those
      connections which permit multiple MID's so that a cancel can be sent to
      the server when a change notification is active.

      2) The Change notification is typical of a long term ( response time
      dictated by factors beyond the servers control). Another example is
      the query FSCTL operation in CAIRO. For all these operations we initiate
      an asychronous transact exchange.

      3) The corresponding LowIo completion routine is invoked asynchronously.

      4) This is an example of an operation for which the MINI RDR has to
      register a context for handling cancellations initiated locally.

--*/
{
   NTSTATUS Status;
   RxCaptureFcb;
   PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

   //PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT pNotificationContext;

#if 0
   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;
#endif //0

   // RxDbgTrace(+1, Dbg, ("MRxNotifyChangeDirectory...Entry\n", 0));

#if 0
   pNotificationContext =
         (PUMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT)
         RxAllocatePoolWithTag(
            NonPagedPool,
            sizeof(UMRX_NOTIFY_CHANGE_DIRECTORY_CONTEXT),
            DAV_FSCTL_POOLTAG);

   if (pNotificationContext != NULL) {
      PREQ_NOTIFY_CHANGE                  pNotifyRequest;
      PUMRX_SRV_OPEN                   pUMRxSrvOpen;

      IF_DEBUG {
          RxCaptureFobx;
          ASSERT (capFobx != NULL);
          ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  //ok
      }

      Status = UMRxDeferredCreate(RxContext);

      if (Status==STATUS_SUCCESS) {

          pUMRxSrvOpen = UMRxGetSrvOpenExtension(RxContext->pRelevantSrvOpen);

          pNotificationContext->pRxContext = RxContext;

          pNotifyRequest      = &(pNotificationContext->NotifyRequest);
          pTransactionOptions = &(pNotificationContext->Options);
          pResumptionContext  = &(pNotificationContext->ResumptionContext);

          pNotifyRequest->CompletionFilter = pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;
          pNotifyRequest->Fid              = pUMRxSrvOpen->Fid;
          pNotifyRequest->WatchTree        = pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;
          pNotifyRequest->Reserved         = 0;

          OutputDataBufferLength  = pLowIoContext->ParamsFor.NotifyChangeDirectory.NotificationBufferLength;
          pOutputDataBuffer       = pLowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer;

          *pTransactionOptions = RxDefaultTransactionOptions;
          pTransactionOptions->NtTransactFunction = NT_TRANSACT_NOTIFY_CHANGE;
          pTransactionOptions->TimeoutIntervalInMilliSeconds = SMBCE_TRANSACTION_TIMEOUT_NOT_USED;
          pTransactionOptions->Flags = SMB_XACT_FLAGS_INDEFINITE_DELAY_IN_RESPONSE;

          UMRxCeInitializeAsynchronousTransactionResumptionContext(
                pResumptionContext,UMRxNotifyChangeDirectoryCompletion,pNotificationContext);

          Status = UMRxCeAsynchronousTransact(
                         RxContext,                    // the RXContext for the transaction
                         pTransactionOptions,          // transaction options
                         pNotifyRequest,               // the setup buffer
                         sizeof(REQ_NOTIFY_CHANGE),    // setup buffer length
                         pInputParamBuffer,            // Input Param Buffer
                         InputParamBufferLength,       // Input param buffer length
                         pOutputParamBuffer,           // Output param buffer
                         OutputParamBufferLength,      // output param buffer length
                         pInputDataBuffer,             // Input data buffer
                         InputDataBufferLength,        // Input data buffer length
                         pOutputDataBuffer,            // output data buffer
                         OutputDataBufferLength,       // output data buffer length
                         pResumptionContext            // the resumption context
                         );

          if (Status == STATUS_PENDING) {
             PUMRX_RX_CONTEXT pUMRxContext;

             pUMRxContext = UMRxGetMinirdrContext(RxContext);
             pUMRxContext->pCancelContext = pNotificationContext;

             // Ensure that the appropriate cancel routine is set because this is a long term
             // operation and the cancelling mechanism needs to be in place.

             Status = RxSetMinirdrCancelRoutine(RxContext,UMRxNotifyChangeDirectoryCancellation);
             if (Status == STATUS_SUCCESS) {
                Status = STATUS_PENDING;
             } else if (Status == STATUS_CANCELLED) {
                UMRxNotifyChangeDirectoryCancellation(RxContext);
                Status = STATUS_PENDING;
             }
          } else {
             // On exit from this routine the request would have been completed in all
             // the cases. The asynchronous case and synchronous case are folded into
             // one async response by returning STATUS_PENDING.

             Status = STATUS_PENDING;
          }
      }  else {
          NOTHING; //just return the status from the deferred open call
      }
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }
#endif //0

   Status = STATUS_NOT_SUPPORTED;

   // RxDbgTrace(-1, Dbg, ("UMRxNotifyChangeDirectory -> %08lx\n", Status ));
   return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\devfcb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements all ioctls and fsctls that can be applied to
    a device fcb.

Author:

    Joe Linn
    
    Rohan Kumar    [RohanK]   13-March-1999
    
--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVOuterStart(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVOuterStop(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxDAVDeleteConnection(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS      
MRxDavDeleteConnection(
    IN OUT PRX_CONTEXT RxContext
    );      

VOID
MRxDAVGetLockOwnerFromFileName(
    IN PWEBDAV_DEVICE_OBJECT MRxDAVDeviceObject,
    IN OUT PWCHAR InputBuffer,
    IN ULONG InputBufferLength,
    OUT PWCHAR OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVDevFcbXXXControlFile)
#pragma alloc_text(PAGE, MRxDAVOuterStart)
#pragma alloc_text(PAGE, MRxDAVStart)
#pragma alloc_text(PAGE, MRxDAVOuterStop)
#pragma alloc_text(PAGE, MRxDAVStop)
#pragma alloc_text(PAGE, MRxDAVDeleteConnection)
#pragma alloc_text(PAGE, MRxDAVFastIoDeviceControl)
#pragma alloc_text(PAGE, MRxDAVFormatTheDAVContext)
#pragma alloc_text(PAGE, MRxDavDeleteConnection)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVDevFcbXXXControlFile(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS - The Startup sequence was successfully completed. Any other 
                     value indicates the appropriate error in the startup 
                     sequence.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RxCaptureFobx;
    UCHAR MajorFunctionCode = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext = &(RxContext->LowIoContext);
    UCHAR MinorFunctionCode = LowIoContext->ParamsFor.FsCtl.MinorFunction;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;
    LUID LocalServiceLogonID = LOCALSERVICE_LUID, ClientLogonID;
    LUID SystemLogonID = SYSTEM_LUID;
    BOOLEAN IsInLocalServiceProcess = FALSE, IsInSystemProcess = FALSE;
    SECURITY_SUBJECT_CONTEXT ClientContext;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;
    PVOID OutputBuffer = NULL;

    PAGED_CODE();

    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVDevFcbXXXControlFile!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVDevFcbXXXControlFile: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: MajorFunctionCode = %d, MinorFunctionCode = %d, ControlCode = %08lx\n",
                 PsGetCurrentThreadId(), MajorFunctionCode, MinorFunctionCode, ControlCode));

    SeCaptureSubjectContext( &(ClientContext) );
    SeLockSubjectContext( &(ClientContext) );

    NtStatus = SeQueryAuthenticationIdToken(SeQuerySubjectContextToken(&(ClientContext)),
                                            &(ClientLogonID));
    if (NtStatus == STATUS_SUCCESS) {
        IsInLocalServiceProcess = RtlEqualLuid( &(ClientLogonID), &(LocalServiceLogonID) );
        IsInSystemProcess = RtlEqualLuid( &(ClientLogonID), &(SystemLogonID) );
    } else {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVDevFcbXXXControlFile/SeQueryAuthenticationIdToken: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
    }

    SeUnlockSubjectContext( &(ClientContext) );
    SeReleaseSubjectContext( &(ClientContext) );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: IsInLocalServiceProcess = %d, IsInSystemProcess = %d\n",
                 PsGetCurrentThreadId(), IsInLocalServiceProcess, IsInSystemProcess));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVDevFcbXXXControlFile: ClientLogonID.HighPart = %x, ClientLogonID.LowPart = %x\n",
                 PsGetCurrentThreadId(), ClientLogonID.HighPart, ClientLogonID.LowPart));

    switch (MajorFunctionCode) {

    case IRP_MJ_FILE_SYSTEM_CONTROL: {

        switch (MinorFunctionCode) {

        case IRP_MN_USER_FS_REQUEST: {

            switch (ControlCode) {

            case FSCTL_UMRX_START:
                if (!IsInLocalServiceProcess && !IsInSystemProcess) {
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: !IsInLocalServiceProcess AND !IsInSystemProcess(1)\n",
                                 PsGetCurrentThreadId()));
                    NtStatus = STATUS_ACCESS_DENIED;
                    goto EXIT_THE_FUNCTION;
                }
                ASSERT (!capFobx);
                NtStatus = MRxDAVOuterStart(RxContext);
                break;

            case FSCTL_UMRX_STOP:
                if (!IsInLocalServiceProcess && !IsInSystemProcess) {
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: !IsInLocalServiceProcess AND !IsInSystemProcess(2)\n",
                                 PsGetCurrentThreadId()));
                    NtStatus = STATUS_ACCESS_DENIED;
                    goto EXIT_THE_FUNCTION;
                }
                ASSERT (!capFobx);
                if (RxContext->RxDeviceObject->NumberOfActiveFcbs > 0) {
                    return STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
                } else {
                    NtStatus = MRxDAVOuterStop(RxContext);
                }
                break;

            case FSCTL_DAV_DELETE_CONNECTION:
                NtStatus = MRxDavDeleteConnection(RxContext);
                break;

            default:
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: "
                             "ControlCode = %d\n",
                             PsGetCurrentThreadId(), ControlCode));
                NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;

            }

        }
        break;

        default :
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: "
                         "MinorFunctionCode = %d\n",
                         PsGetCurrentThreadId(), MinorFunctionCode));
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;

        }

    }
    break;

    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL: {

        switch (ControlCode) {

        case IOCTL_UMRX_RELEASE_THREADS:
            if (!IsInLocalServiceProcess && !IsInSystemProcess) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: !IsInLocalServiceProcess AND !IsInSystemProcess(1)\n",
                             PsGetCurrentThreadId()));
                NtStatus = STATUS_ACCESS_DENIED;
                goto EXIT_THE_FUNCTION;
            }
            UMRxReleaseCapturedThreads(UMRefDeviceObject);
            RxContext->CurrentIrp->IoStatus.Status = STATUS_SUCCESS;
            RxContext->CurrentIrp->IoStatus.Information = 0;
            NtStatus = STATUS_SUCCESS;
            break;

            case IOCTL_UMRX_GET_REQUEST:
            case IOCTL_UMRX_RESPONSE_AND_REQUEST:
            case IOCTL_UMRX_RESPONSE:
                if (!IsInLocalServiceProcess && !IsInSystemProcess) {
                    DavDbgTrace(DAV_TRACE_ERROR,
                                ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: !IsInLocalServiceProcess AND !IsInSystemProcess(1)\n",
                                 PsGetCurrentThreadId()));
                    NtStatus = STATUS_ACCESS_DENIED;
                    goto EXIT_THE_FUNCTION;
                }
                //
                // The above IOCTLs are "METHOD_OUT_DIRECT" type. 
                // The InputBuffer is stored at this location:
                // "RxContext->CurrentIrp->AssociatedIrp.SystemBuffer"
                // The OutputBuffer is an MDL stored at this location:
                // "RxContext->CurrentIrp->MdlAddress"
                //
                if (RxContext->CurrentIrp->MdlAddress != NULL) {
                    OutputBuffer = MmGetSystemAddressForMdlSafe(RxContext->CurrentIrp->MdlAddress, LowPagePriority);
                    if (OutputBuffer == NULL) {
                        DavDbgTrace(DAV_TRACE_ERROR,
                                    ("%ld: ERROR: MRxDAVDevFcbXXXControlFile/MmGetSystemAddressForMdlSafe\n",
                                     PsGetCurrentThreadId()));
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto EXIT_THE_FUNCTION;
                    }
                }
                UMRxAssignWork(UMRefDeviceObject,
                               RxContext->CurrentIrp->AssociatedIrp.SystemBuffer,
                               RxContext->CurrentIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                               OutputBuffer,
                               RxContext->CurrentIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                               &(RxContext->CurrentIrp->IoStatus));
                NtStatus = RxContext->CurrentIrp->IoStatus.Status;
                break;

            case IOCTL_UMRX_GET_LOCK_OWNER:
                MRxDAVGetLockOwnerFromFileName(DavDeviceObject,
                                               RxContext->CurrentIrp->AssociatedIrp.SystemBuffer,
                                               RxContext->CurrentIrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                               RxContext->CurrentIrp->AssociatedIrp.SystemBuffer,
                                               RxContext->CurrentIrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                               &(RxContext->CurrentIrp->IoStatus));
                NtStatus = RxContext->CurrentIrp->IoStatus.Status;
                break;

            default :
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: ControlCode = %d\n",
                             PsGetCurrentThreadId(), ControlCode));
                NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;

        }

    }
    break;

    default:
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVDevFcbXXXControlFile: "
                     "MajorFunction = %d\n",
                     PsGetCurrentThreadId(), MajorFunctionCode));
        NtStatus = STATUS_INVALID_DEVICE_REQUEST;
        break;
    
    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVDevFcbXXXControlFile with NtStatus = "
                 "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    //
    // This suppresses the second call to my lowio Fsctl routine.
    //
    RxContext->pFobx = NULL;

    return(NtStatus);
}


NTSTATUS
MRxDAVOuterStart(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine starts the Mini-Redir if it hasn't been started already.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS or the appropriate error code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;
    PLOWIO_CONTEXT LowIoContext = NULL;
    PDAV_USERMODE_DATA DavUserModeData = NULL;
    ULONG DavUserModeDataLength = 0;
    
    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVOuterStart!!!!\n", 
                 PsGetCurrentThreadId()));
    
    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVOuterStart: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVOuterStart: Try to Start the Mini-Redir\n",
                 PsGetCurrentThreadId()));

    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);

    LowIoContext= &(RxContext->LowIoContext);

    //
    // The WinInet cache path and the process id are stored in the input buffer 
    // of the FSCTL.
    //
    DavUserModeData = (PDAV_USERMODE_DATA)LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ASSERT(DavUserModeData != NULL);
    DavUserModeDataLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;
    ASSERT(DavUserModeDataLength == sizeof(DAV_USERMODE_DATA));

    //
    // Set the DeviceFcb, now that we have an RxContext.
    //
    DavDeviceObject->CachedRxDeviceFcb = RxContext->pFcb;
    
    //
    // We call ExAcquireFastMutexUnsafe instead of ExAcquireFastMutex because the
    // APCs have already been disabled by the FsrtlEnterFileSystem() call in the
    // RxFsdCommonDispatch function. This is done because a ExAcquireFastMutex
    // raises the IRQL level to APC_LEVEL (1) which is wrong since we are calling
    // into RxStartMiniRedir which calls FsrtlRegisterUncProvider which lands 
    // up calling into the Dav MiniRedir again. If the IRQL level is raised here,
    // the MiniRedir will get called at a raised IRQL which is wrong.
    //
    ExAcquireFastMutexUnsafe( &(MRxDAVSerializationMutex) );
    
    try {

        if (DavDeviceObject->IsStarted) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStart: Mini-Redir already started.\n",
                         PsGetCurrentThreadId()));
            try_return(NtStatus = STATUS_REDIRECTOR_STARTED);
        }
        
        NtStatus = RxStartMinirdr(RxContext, &RxContext->PostRequest);
        
        if (NtStatus == STATUS_SUCCESS) {
            
            DavDeviceObject->IsStarted = TRUE;
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStart: Mini-Redir started.\n",
                         PsGetCurrentThreadId()));
            
            //
            // Copy the DavWinInetCachePath value into the global variable. This
            // value is used to satisy the volume relalted queries.
            //
            wcscpy(DavWinInetCachePath, DavUserModeData->WinInetCachePath);
            
            //
            // Copy the ProcessId of the svchost.exe process that loads the
            // webclnt.dll.
            //
            DavSvcHostProcessId = DavUserModeData->ProcessId;
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStart: DavWinInetCachePath = %ws, DavSvcHostProcessId = %x\n",
                         PsGetCurrentThreadId(), DavWinInetCachePath, DavSvcHostProcessId));

            //
            // Start the timer thread. This thread wakes up every few minutes
            // (RequestTimeoutValueInSec) and cancels all the requests that 
            // have not completed for more than RequestTimeoutValueInSec.
            //
            NtStatus = PsCreateSystemThread(&(TimerThreadHandle),
                                            PROCESS_ALL_ACCESS,
                                            NULL,
                                            NULL,
                                            NULL,
                                            MRxDAVContextTimerThread,
                                            NULL);
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVOuterStart/PsCreateSystemThread: NtStatus"
                             " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            }

        } else {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVOuterStart/RxStartMinirdr: NtStatus"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            
            try_return(NtStatus);
        
        }
        
        try_exit: NOTHING;

    } finally {

        //
        // Since we called ExAcquireFastMutexUnsafe to acquire this mutex, we 
        // call ExReleaseFastMutexUnsafe to release it.
        //
        ExReleaseFastMutexUnsafe( &(MRxDAVSerializationMutex) );

    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVOuterStart with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    return NtStatus;
}


NTSTATUS
MRxDAVOuterStop(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine stops the Mini-Redir if it has been started.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS or the appropriate error code.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = NULL;
    PVOID HeapHandle = NULL;
    PLIST_ENTRY pFirstListEntry = NULL;
    PUMRX_SHARED_HEAP sharedHeap = NULL;
    BOOLEAN TimerState = FALSE;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVOuterStop!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVOuterStop: RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), RxContext));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVOuterStop: Try to Stop the Mini-Redir.\n",
                 PsGetCurrentThreadId()));

    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);
    
    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);

    //
    // Tell the timer thread that its time to shutdown to its job is done.
    //
    ExAcquireResourceExclusiveLite(&(MRxDAVTimerThreadLock), TRUE);

    if (!TimerThreadShutDown) {

        TimerThreadShutDown = TRUE;

        //
        // Read the state of the timer. If its NOT signalled, call KeSetTimerEx
        // with 0 DueTime (2nd argument) to signal it.
        //
        TimerState = KeReadStateTimer( &(DavTimerObject) );
        if (!TimerState) {
            LARGE_INTEGER TimeOutNow;
            TimeOutNow.QuadPart = 0;
            KeSetTimerEx(&(DavTimerObject), TimeOutNow, 0, NULL);
        }

        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));

        //
        // We now call MRxDAVCleanUpTheLockConflictList to free up all the
        // entries from the global LockConflictEntryList.
        //
        MRxDAVCleanUpTheLockConflictList(TRUE);

        //
        // Complete all the currently active contexts.
        //
        MRxDAVTimeOutTheContexts(TRUE);

    } else {

        //
        // If we have already shutdown the timer thread, then we don't need to
        // do it again. Just release the resource and move on.
        //
        ExReleaseResourceLite(&(MRxDAVTimerThreadLock));

    }

    //
    // Free the list of shared memory heaps. This has to happen in the context
    // of the DAV's usermode process. It cannot happen at Unload time since
    // unload happens in the context of a system thread.
    //
    while (!IsListEmpty(&UMRefDeviceObject->SharedHeapList)) {

        pFirstListEntry = RemoveHeadList(&UMRefDeviceObject->SharedHeapList);

        sharedHeap = (PUMRX_SHARED_HEAP) CONTAINING_RECORD(pFirstListEntry,
                                                           UMRX_SHARED_HEAP,
                                                           HeapListEntry);

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVOuterStop: sharedHeap: %08lx.\n",
                     PsGetCurrentThreadId(), sharedHeap));

        // ASSERT(sharedHeap->HeapAllocationCount == 0);

        HeapHandle = RtlDestroyHeap(sharedHeap->Heap);
        if (HeapHandle != NULL) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVOuterStop/RtlDestroyHeap.\n",
                         PsGetCurrentThreadId()));
        }

        ZwFreeVirtualMemory(NtCurrentProcess(),
                            &sharedHeap->VirtualMemoryBuffer,
                            &sharedHeap->VirtualMemoryLength,
                            MEM_RELEASE);

        RxFreePool(sharedHeap);
    
    }

    //
    // We call ExAcquireFastMutexUnsafe instead of ExAcquireFastMutex because the
    // APCs have already been disabled by the FsrtlEnterFileSystem() call in the
    // RxFsdCommonDispatch function. This is done because a ExAcquireFastMutex
    // raises the IRQL level to APC_LEVEL (1) which is wrong since we are calling
    // into RxStartMiniRedir which calls FsrtlRegisterUncProvider which lands 
    // up calling into the Dav MiniRedir again. If the IRQL level is raised here,
    // the MiniRedir will get called at a raised IRQL which is wrong.
    //
    ExAcquireFastMutexUnsafe(&MRxDAVSerializationMutex);
    try {
        if (!DavDeviceObject->IsStarted) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStop: Mini-Redir not started.\n",
                         PsGetCurrentThreadId()));
            try_return(NtStatus = STATUS_REDIRECTOR_NOT_STARTED);
        }
        NtStatus = RxStopMinirdr(RxContext, &RxContext->PostRequest);
        if (NtStatus == STATUS_SUCCESS) {
            DavDeviceObject->IsStarted = FALSE;
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVOuterStop: Mini-Redir stopped.\n",
                         PsGetCurrentThreadId()));
        } else {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVOuterStop/RxStopMinirdr: NtStatus"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            try_return(NtStatus);
        }
    try_exit: NOTHING;
    } finally {
        //
        // Since we called ExAcquireFastMutexUnsafe to acquire this mutex, we 
        // call ExReleaseFastMutexUnsafe to release it.
        //
        ExReleaseFastMutexUnsafe(&MRxDAVSerializationMutex);
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVOuterStop with NtStatus = %08lx.\n", 
                 PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
MRxDAVStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    return NtStatus;
}


NTSTATUS
MRxDAVDeleteConnection(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    RxCaptureFobx;
    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    PNET_ROOT NetRoot;
    PV_NET_ROOT VNetRoot;

    PAGED_CODE();

    if (!Wait) {
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    try {
        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PV_NET_ROOT)capFobx;
            NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
            NetRoot = (PNET_ROOT)capFobx;
            VNetRoot = NULL;
        }

        Status = RxFinalizeConnection(NetRoot,VNetRoot,TRUE);

        try_return(Status);

try_exit:NOTHING;
    } finally {
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}


BOOLEAN
MRxDAVFastIoDeviceControl(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine handles the Fast I/O path of the WebDav miniredir.

Arguments:

    FileObject - The file object of the file involved in the I/O request.

    Wait -

    InputBuffer - Buffer which holds the inputs for the I/O request.

    InputBufferLength - Length of the InputBuffer.

    OutputBuffer - Where the results of the I/O request are placed.

    OutputBufferLength - Length of the OutputBuffer.

    IoControlCode - The controlcode describing the I/O to be done.

    IoStatus - The results of the assignment.

    DeviceObject - The device object which handles the I/O request.

Return Value:

    TRUE - The I/O operation was handled and FALSE otherwise.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)DeviceObject;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)DeviceObject;
    LUID LocalServiceLogonID = LOCALSERVICE_LUID, ClientLogonID;
    LUID SystemLogonID = SYSTEM_LUID;
    BOOLEAN IsInLocalServiceProcess = FALSE, IsInSystemProcess = FALSE;
    SECURITY_SUBJECT_CONTEXT ClientContext;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFastIoDeviceControl. IoControlCode = %08lx\n",
                 PsGetCurrentThreadId(), IoControlCode));

    if (FileObject->FsContext != DavDeviceObject->CachedRxDeviceFcb) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFastIoDeviceControl: Wrong DeviceFcb!!\n",
                     PsGetCurrentThreadId()));
        return FALSE;
    }

    SeCaptureSubjectContext( &(ClientContext) );
    SeLockSubjectContext( &(ClientContext) );

    NtStatus = SeQueryAuthenticationIdToken(SeQuerySubjectContextToken(&(ClientContext)),
                                            &(ClientLogonID));
    if (NtStatus == STATUS_SUCCESS) {
        IsInLocalServiceProcess = RtlEqualLuid( &(ClientLogonID), &(LocalServiceLogonID) );
        IsInSystemProcess = RtlEqualLuid( &(ClientLogonID), &(SystemLogonID) );
    } else {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFastIoDeviceControl/SeQueryAuthenticationIdToken: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
    }

    SeUnlockSubjectContext( &(ClientContext) );
    SeReleaseSubjectContext( &(ClientContext) );

    //
    // It's the right kind of fileobject. Go for it.
    //
    switch (IoControlCode) {

    case IOCTL_UMRX_RELEASE_THREADS:
        if (!IsInLocalServiceProcess && !IsInSystemProcess) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFastIoDeviceControl: !IsInLocalServiceProcess AND !IsInSystemProcess(1)\n",
                         PsGetCurrentThreadId()));
            IoStatus->Status = STATUS_ACCESS_DENIED;
            IoStatus->Information = 0;
            return (FALSE);
        }
        UMRxReleaseCapturedThreads(UMRefDeviceObject);
        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;
        return (TRUE);

    case IOCTL_UMRX_GET_REQUEST:
    case IOCTL_UMRX_RESPONSE_AND_REQUEST:
    case IOCTL_UMRX_RESPONSE:
        if (!IsInLocalServiceProcess && !IsInSystemProcess) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFastIoDeviceControl: !IsInLocalServiceProcess AND !IsInSystemProcess(1)\n",
                         PsGetCurrentThreadId()));
            IoStatus->Status = STATUS_ACCESS_DENIED;
            IoStatus->Information = 0;
            return (FALSE);
        }
        UMRxAssignWork(UMRefDeviceObject,
                       InputBuffer,
                       InputBufferLength,
                       OutputBuffer,
                       OutputBufferLength,
                       IoStatus);
        return(TRUE);

    case IOCTL_UMRX_GET_LOCK_OWNER:
        //
        // Validate the InputBuffer sent by the application.
        //
        try {
            ProbeForRead(InputBuffer, InputBufferLength, sizeof(UCHAR));
        } except (EXCEPTION_EXECUTE_HANDLER) {
              DavDbgTrace(DAV_TRACE_ERROR,
                          ("%ld: ERROR: MRxDAVFastIoDeviceControl. STATUS_INVALID_USER_BUFFER(1)\n",
                           PsGetCurrentThreadId()));
              IoStatus->Status = STATUS_INVALID_USER_BUFFER;
              IoStatus->Information = 0;
              return (FALSE);
        }
        //
        // Validate the OutputBuffer sent by the application.
        //
        try {
            ProbeForWrite(OutputBuffer, OutputBufferLength, sizeof(UCHAR));
        } except (EXCEPTION_EXECUTE_HANDLER) {
              DavDbgTrace(DAV_TRACE_ERROR,
                          ("%ld: ERROR: MRxDAVFastIoDeviceControl. STATUS_INVALID_USER_BUFFER(2)\n",
                           PsGetCurrentThreadId()));
              IoStatus->Status = STATUS_INVALID_USER_BUFFER;
              IoStatus->Information = 0;
              return (FALSE);
        }
        MRxDAVGetLockOwnerFromFileName(DavDeviceObject,
                                       InputBuffer,
                                       InputBufferLength,
                                       OutputBuffer,
                                       OutputBufferLength,
                                       IoStatus);
        return(TRUE);

    default:
            break;

    }

    //
    // The I/O operation could not be handled.
    //
    return(FALSE);
}


NTSTATUS
MRxDAVFormatTheDAVContext(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    USHORT EntryPoint
    )
/*++

Routine Description:

    This routine formats the DAV Mini-Redir portion of the context.

Arguments:

    AsyncEngineContext  - The Reflector's context.
    
    EntryPoint - The operation being performed.
    
Return Value:

    none.
    
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWEBDAV_CONTEXT DavContext = (PWEBDAV_CONTEXT)AsyncEngineContext;
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    PNT_CREATE_PARAMETERS NtCP = &(RxContext->Create.NtCreateParameters);
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PSECURITY_CLIENT_CONTEXT SecClnCtx = NULL;
    BOOL AlreadyInitialized = FALSE, SecurityClientContextCreated = FALSE;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PSECURITY_SUBJECT_CONTEXT SecSubCtx = NULL;
    PSECURITY_QUALITY_OF_SERVICE SecQOS = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatTheDAVContext!!!!\n",
                PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatTheDAVContext: AsyncEngineContext: %08lx, "
                 "EntryPoint: %d.\n", PsGetCurrentThreadId(), 
                 AsyncEngineContext, EntryPoint));


    ASSERT(DavContext != NULL);
    ASSERT(RxContext != NULL);

    //
    // Set the EntryPoint field. If this is not a Create operation, we can 
    // return.
    //
    DavContext->EntryPoint = EntryPoint;
    if (EntryPoint != DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL &&
        EntryPoint != DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT) {
        return NtStatus;
    }

    //
    // Since this is a create call, get the client's security context. This is 
    // used to impersonate the client before sending the requests to the server.
    //
    
    if ( NtCP->SecurityContext != NULL && 
         NtCP->SecurityContext->AccessState != NULL ) {
        
        //
        // Check whether its a CreateSrvCall call or a CreateVNetRoot call.
        //
        if ( EntryPoint != DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL ) {
            
            //
            // This is s CreateVNetRoot call.
            //
            ASSERT(EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT);
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVFormatTheDAVContext. CreateVNetRoot.\n",
                         PsGetCurrentThreadId()));

            //
            // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
            // RxContext structure. This is done in the MRxDAVCreateVNetRoot function.
            //
            VNetRoot = RxContext->MRxContext[1];
            
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVFormatTheDAVContext. VNetRoot = %08lx\n",
                         PsGetCurrentThreadId(), VNetRoot));
            
            //
            // The context pointer of the V_NET_ROOT already points to a blob of
            // memory, the size of which is sizeof(WEBDAV_V_NET_ROOT). This 
            // should never be NULL.
            //
            DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
            if(DavVNetRoot == NULL) {
                ASSERT(FALSE);
                goto EXIT_THE_FUNCTION;
            }

            SecClnCtx = &(DavVNetRoot->SecurityClientContext);

            //
            // Only need to initialize on the first create call by the user.
            //
            if (DavVNetRoot->SCAlreadyInitialized) {
                AlreadyInitialized = TRUE;
            }
        
        } else {
            
            //
            // This is a CreateSrvCall call.
            //
            ASSERT(EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL);

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVFormatTheDAVContext. CreateSrvCall.\n",
                         PsGetCurrentThreadId()));

            //
            // The SrvCall pointer is stored in the SCCBC structure which is
            // stored in the MRxContext[1] pointer of the RxContext structure.
            // This is done in the MRxDAVCreateSrvCall function.
            //
            ASSERT(RxContext->MRxContext[1] != NULL);
            SCCBC = (PMRX_SRVCALL_CALLBACK_CONTEXT)RxContext->MRxContext[1];
            
            SrvCall = SCCBC->SrvCalldownStructure->SrvCall;
            ASSERT(SrvCall != NULL);

            DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
            ASSERT(DavSrvCall != NULL);
            
            //
            // At this time, we don't have a V_NET_ROOT and hence cannot store 
            // the SecurityClientContext. We just use MRxContext[2] of RxContext
            // to pass the SecurityClientContext.
            //
            SecClnCtx = RxAllocatePoolWithTag(NonPagedPool,
                                              sizeof(SECURITY_CLIENT_CONTEXT),
                                              DAV_SRVCALL_POOLTAG);
            if (SecClnCtx == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVFormatTheDAVContext/RxAllocatePoolWithTag.\n",
                             PsGetCurrentThreadId()));
                goto EXIT_THE_FUNCTION;
            }

            ASSERT(RxContext->MRxContext[2] == NULL);
            RxContext->MRxContext[2] = (PVOID)SecClnCtx;
        
        }
        
        if (!AlreadyInitialized) {

            SecSubCtx = &(NtCP->SecurityContext->AccessState->SubjectSecurityContext);
            
            SecQOS = ( (NtCP->SecurityContext->SecurityQos) ? 
                       (NtCP->SecurityContext->SecurityQos) : &(SecurityQos) );

            //
            // If the user did not specify the security QOS structure, create 
            // one. We set the value of SecurityQos.EffectiveOnly to FALSE
            // to keep the privilege so that we can do certain operations
            // later on. This is specifically needed for the EFS operations.
            // If set to TRUE, any privilege not enabled at this time will be
            // lost. In the EFS case, the "restore" privilege is lost.
            //
            if (NtCP->SecurityContext->SecurityQos == NULL) {
                SecurityQos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
                SecurityQos.ImpersonationLevel = DEFAULT_IMPERSONATION_LEVEL;
                SecurityQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQos.EffectiveOnly = FALSE;
            }

            //
            // This call sets the SecurityClientContext of the user. This is 
            // stored in the V_NET_ROOT since its a per user thing. This 
            // strucutre is used later on in impersonating the client that 
            // issued the I/O request.
            //
            NtStatus = SeCreateClientSecurityFromSubjectContext(SecSubCtx,
                                                                SecQOS,
                                                                // Srv Remote ?
                                                                FALSE, 
                                                                SecClnCtx);
            //
            // If unsuccessful, return NULL.
            //
            if (NtStatus != STATUS_SUCCESS) {
                DavDbgTrace(DAV_TRACE_ERROR,
                            ("%ld: ERROR: MRxDAVFormatTheDAVContext/"
                             "SeCreateClientSecurityFromSubjectContext. Error "
                             "Val = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            }

            SecurityClientContextCreated = TRUE;

            //
            // If this was a create call, set the bool in the DavVNetRoot to 
            // indicate that the SecurityClientContext has been initialized.
            //
            if (EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT) {
                DavVNetRoot->SCAlreadyInitialized = TRUE;
            } else{
                ASSERT(EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL);
                DavSrvCall->SCAlreadyInitialized = TRUE;
            }
        
        }
    
    } else {
        
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatTheDAVContext. Could not get SecClnCtx."
                     "EntryPoint = %d.\n", PsGetCurrentThreadId(), EntryPoint));
    
    }

EXIT_THE_FUNCTION:

    if (NtStatus != STATUS_SUCCESS) {
        if (EntryPoint == DAV_MINIRDR_ENTRY_FROM_CREATESRVCALL && SecClnCtx != NULL) {
            if (SecurityClientContextCreated) {
                SeDeleteClientSecurity(SecClnCtx);
                DavSrvCall->SCAlreadyInitialized = FALSE;
            }
            RxFreePool(SecClnCtx);
            RxContext->MRxContext[2] = NULL;
        }
    }
    
    DavDbgTrace(DAV_TRACE_DETAIL, 
                ("%ld: Leaving MRxDAVFormatTheDAVContext with NtStatus = %08lx.\n",
                PsGetCurrentThreadId(), NtStatus));
    
    return NtStatus;
}


NTSTATUS
MRxDavDeleteConnection(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine deletes a VNetroot. The result depends on the forcelevel. If called
   with maximum force, this will delete all connections and orphan the fileobjects
   working on files for this VNetRoot.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;
    
    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    ULONG Level;

    PMRX_V_NET_ROOT VNetRoot;
    PMRX_NET_ROOT NetRoot;

    PAGED_CODE();

#if 0
    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }
#endif

    try {

        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PMRX_V_NET_ROOT)capFobx;
            NetRoot = (PMRX_NET_ROOT)VNetRoot->pNetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
        }

        if (InputBufferLength < sizeof(DWORD)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        Level = *((DWORD *)InputBuffer);
        
        if (Level <= USE_LOTS_OF_FORCE) {
            if (VNetRoot != NULL && Level == USE_LOTS_OF_FORCE) {
            }
            
            Status = RxFinalizeConnection(
                         (PNET_ROOT)NetRoot,
                         (PV_NET_ROOT)VNetRoot,
                         (BOOLEAN)(Level == USE_LOTS_OF_FORCE));
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {

#if 0
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }
#endif
    }

    return Status;
}


VOID
MRxDAVGetLockOwnerFromFileName(
    IN PWEBDAV_DEVICE_OBJECT MRxDAVDeviceObject,
    IN OUT PWCHAR InputBuffer,
    IN ULONG InputBufferLength,
    OUT PWCHAR OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine goes through the global LockConflictEntryList and deletes
    all the expired entries. It then looks at the entry whose CompletePathName
    matches the FileName of the InputBuffer and fills in the LockOwner of
    that entry in the OutputBuffer.

Arguments:

    MRxDAVDeviceObject - The WebDav deviceobject that is in play.

    InputBuffer - The Input buffer that came down from the user mode. This 
                  contains the CompletePathName of the file in question.

    InputBufferLength - Length of the InputBuffer.

    OutputBuffer - The Output buffer that came down from the user mode. The
                   LockOwner (if one is found) is filled here.

    OutputBufferLength - Length of the OutputBuffer.

    IoStatus - The results of the assignment.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PLIST_ENTRY ConflictListEntry = NULL;
    PWEBDAV_LOCK_CONFLICT_ENTRY LockConflictEntry = NULL;
    BOOL lockAcquired = FALSE, entryFound = FALSE;

    //
    // Note: InputBuffer and OutputBuffer may point to the same address since
    // this IOCTL is METHOD_BUFFERED, and we could have enterd it via the IRP
    // path instead of Fast I/O path.
    //

    //
    // We need to disable APCs on this thread now.
    //
    FsRtlEnterFileSystem();

    //
    // First, go through the list and free up all the old entries. We supply 
    // FALSE since we only want to cleanup the expired entries.
    //
    MRxDAVCleanUpTheLockConflictList(FALSE);

    //
    // Now that we have cleaned up all the old entries, go through the list
    // and find out the entry that matches the PathName. Fill the OutputBuffer
    // with the LockOwner string.
    //

    ExAcquireResourceExclusiveLite(&(LockConflictEntryListLock), TRUE);
    lockAcquired = TRUE;

    ConflictListEntry = LockConflictEntryList.Flink;

    while ( ConflictListEntry != &(LockConflictEntryList) ) {

        //
        // Get the pointer to the WEBDAV_LOCK_CONFLICT_ENTRY structure.
        //
        LockConflictEntry = CONTAINING_RECORD(ConflictListEntry,
                                              WEBDAV_LOCK_CONFLICT_ENTRY,
                                              listEntry);

        ConflictListEntry = ConflictListEntry->Flink;

        //
        // If the SizeInBytes of the LockConflictEntry->CompletePathName is
        // greater than the InputBufferLength, then we continue.
        //
        if ( ((1 + wcslen(LockConflictEntry->CompletePathName)) * sizeof(WCHAR)) > InputBufferLength ) {
            continue;
        }

        try {
            //
            // If the CompletePathName exactly matches the InputBuffer string
            // that was passed then this is the LockConflictEntry we are 
            // interested in.
            //
            if ( !_wcsnicmp(LockConflictEntry->CompletePathName, InputBuffer, wcslen(LockConflictEntry->CompletePathName)) ) {
                if ( InputBuffer[wcslen(LockConflictEntry->CompletePathName)] == L'\0' ) {
                    entryFound = TRUE;
                    break;
                }
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
              NtStatus = STATUS_INVALID_USER_BUFFER;
              goto EXIT_THE_FUNCTION;
        }

    }

    if (entryFound) {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVGetLockOwnerFromFileName. entryFound == TRUE\n",
                     PsGetCurrentThreadId()));

        //
        // We need to make sure that the OutputBuffer is large enough to hold
        // the LockOwner string.
        //
        if ( OutputBufferLength < ((1 + wcslen(LockConflictEntry->LockOwner)) * sizeof(WCHAR)) ) {
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVGetLockOwnerFromFileName. STATUS_BUFFER_TOO_SMALL\n",
                         PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        try {
            wcsncpy(OutputBuffer, LockConflictEntry->LockOwner, wcslen(LockConflictEntry->LockOwner));
            OutputBuffer[wcslen(LockConflictEntry->LockOwner)] = L'\0';
        } except (EXCEPTION_EXECUTE_HANDLER) {
              NtStatus = STATUS_INVALID_USER_BUFFER;
              DavDbgTrace(DAV_TRACE_ERROR,
                          ("%ld: ERROR: MRxDAVGetLockOwnerFromFileName. STATUS_INVALID_USER_BUFFER(3)\n",
                           PsGetCurrentThreadId()));
              goto EXIT_THE_FUNCTION;
        }

        NtStatus = STATUS_SUCCESS;

    } else {

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVGetLockOwnerFromFileName. entryFound == FALSE\n",
                     PsGetCurrentThreadId()));

        NtStatus = STATUS_NO_SUCH_FILE;

    }

EXIT_THE_FUNCTION:

    IoStatus->Status = NtStatus;

    //
    // If NtStatus is STATUS_BUFFER_TOO_SMALL, we need to return the size
    // needed to hold the LoackOwner name.
    //
    if (NtStatus == STATUS_SUCCESS || NtStatus == STATUS_BUFFER_TOO_SMALL) {
        IoStatus->Information = ( (1 + wcslen(LockConflictEntry->LockOwner)) * sizeof(WCHAR) );
    } else {
        IoStatus->Information = 0;
    }

    if (lockAcquired) {
        ExReleaseResourceLite(&(LockConflictEntryListLock));
        lockAcquired = FALSE;
    }

    FsRtlExitFileSystem();

    return;
}


VOID
MRxDAVCleanUpTheLockConflictList(
    BOOL CleanUpAllEntries
    )
/*++

Routine Description:

    This routine goes through the global LockConflictEntryList and deletes
    all the expired entries or all the entries depending upon the value of
    CleanUpAllEntries.

Arguments:

    CleanUpAllEntries - If TRUE, it cleans up all the entries.
                        If FALSE, it cleans up only the expired items.

Return Value:

    None.

--*/
{
    PLIST_ENTRY ConflictListEntry = NULL;
    PWEBDAV_LOCK_CONFLICT_ENTRY LockConflictEntry = NULL;
    LARGE_INTEGER CurrentSystemTickCount, TickCountDifference;
    LARGE_INTEGER EntryTimeoutValueInTickCount;

    //
    // Go through the list and free up all the old entries. Acquire the LOCK
    // first.
    //

    ExAcquireResourceExclusiveLite(&(LockConflictEntryListLock), TRUE);

    ConflictListEntry = LockConflictEntryList.Flink;

    while ( ConflictListEntry != &(LockConflictEntryList) ) {

        //
        // Get the pointer to the WEBDAV_LOCK_CONFLICT_ENTRY structure.
        //
        LockConflictEntry = CONTAINING_RECORD(ConflictListEntry,
                                              WEBDAV_LOCK_CONFLICT_ENTRY,
                                              listEntry);

        ConflictListEntry = ConflictListEntry->Flink;

        //
        // Calculate the timeout value in TickCount (100 nano seconds) using
        // the timeout value in seconds). Step1 below calculates the number of
        // ticks that happen in one second. Step2 below calculates the number
        // of ticks in WEBDAV_LOCKCONFLICTENTRY_LIFETIMEINSEC.
        //
        EntryTimeoutValueInTickCount.QuadPart = ( (1000 * 1000 * 10) / KeQueryTimeIncrement() );
        EntryTimeoutValueInTickCount.QuadPart *= WEBDAV_LOCKCONFLICTENTRY_LIFETIMEINSEC;

        KeQueryTickCount( &(CurrentSystemTickCount) );

        //
        // Get the time elapsed (in system tick counts) since the time this
        // LockConflictEntry was created.
        //
        TickCountDifference.QuadPart = (CurrentSystemTickCount.QuadPart - LockConflictEntry->CreationTimeInTickCount.QuadPart);

        //
        // If the TickCountDifference is greater than EntryTimeoutValueInTickCount
        // we need to remove this this entry from the list and free it. If
        // CleanUpAllEntries is TRUE, we free it whether its expired or not.
        //
        if ( (CleanUpAllEntries) ||
             (TickCountDifference.QuadPart > EntryTimeoutValueInTickCount.QuadPart) ) {

            RemoveEntryList( &(LockConflictEntry->listEntry) );

            RxFreePool(LockConflictEntry->CompletePathName);
            LockConflictEntry->CompletePathName = NULL;

            RxFreePool(LockConflictEntry->LockOwner);
            LockConflictEntry->LockOwner = NULL;

            RxFreePool(LockConflictEntry);
            LockConflictEntry = NULL;

        }

    }

    ExReleaseResourceLite(&(LockConflictEntryListLock));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\fsctl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    file system control(FSCTL) and Io Device Control (IOCTL) operations on file
    system objects.

Author:

    Yun Lin      [YunLin]      27-Oct-2000

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#include "webdav.h"

NTSTATUS
MrxDAVEfsControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
MrxDAVEfsControl(
      IN OUT PRX_CONTEXT RxContext
      );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVFsCtl)
#pragma alloc_text(PAGE, MrxDAVEfsControl)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVFsCtl(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories.
    In the first category are those FSCTL's whose implementation are shared between
    RDBSS and the mini rdr's and in the second category are those FSCTL's which
    are totally implemented by the mini rdr's. To this a third category can be
    added, i.e., those FSCTL's which should never be seen by the mini rdr's. The
    third category is solely intended as a debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;
    RxCaptureFcb;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL, ("MRxDAVFsCtl: FsControlCode = %08lx\n", FsControlCode));

    switch (pLowIoContext->ParamsFor.FsCtl.MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
    case IRP_MN_KERNEL_CALL    :
        switch (FsControlCode) {
        case FSCTL_ENCRYPTION_FSCTL_IO :
        case FSCTL_SET_ENCRYPTION      :
        case FSCTL_READ_RAW_ENCRYPTED  :
        case FSCTL_WRITE_RAW_ENCRYPTED :
        case FSCTL_SET_COMPRESSION     :
        case FSCTL_SET_SPARSE          :
        case FSCTL_QUERY_ALLOCATED_RANGES :
            Status = MrxDAVEfsControl(RxContext);
            break;

        default:
            Status =  STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return Status;
}


NTSTATUS
MrxDAVEfsControl(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine redirects an EFS FSCTL operation on a remote file to its local cache

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:
    
    IMPORTANT!!!
    We acquire the FCB exclusively in this routine. Its very critical that this
    routine has a single exit point. Need to remember this while modifying the
    file.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT pLowIoContext = NULL;
    ULONG FsControlCode = 0, EncryptionOperation = 0;
    PIRP TopIrp = NULL, irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;
    PWEBDAV_FCB DavFcb = NULL;
    PDEVICE_OBJECT DeviceObject = NULL;
    PENCRYPTION_BUFFER EncryptionBuffer = NULL;
    BOOLEAN ShouldUpdateNameCache = FALSE, ExclusiveFcbAcquired = FALSE;
    BOOLEAN FileWasModified = FALSE;
    KEVENT Event;
    RxCaptureFobx;
    RxCaptureFcb;

    PAGED_CODE();

    pLowIoContext = &RxContext->LowIoContext;
    FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;
    davSrvOpen = MRxDAVGetSrvOpenExtension(RxContext->pRelevantSrvOpen);
    DavFcb = MRxDAVGetFcbExtension(RxContext->pRelevantSrvOpen->pFcb);
    DeviceObject = davSrvOpen->UnderlyingDeviceObject; 

    //
    // When we come here we do not acquire the FCB. The asserts below confirm
    // this.
    //
    ASSERT(RxIsFcbAcquiredExclusive(RxContext->pRelevantSrvOpen->pFcb) == FALSE);
    ASSERT(RxIsFcbAcquiredShared(RxContext->pRelevantSrvOpen->pFcb) == FALSE);

    //
    // Since we might be changing the attributes of the FCB, we acquire it
    // exclusive.
    //
    RxAcquireExclusiveFcbResourceInMRx(RxContext->pRelevantSrvOpen->pFcb);
    ExclusiveFcbAcquired = TRUE;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("MrxDAVEfsControl: IRP = %x, capFcb = %x, capFobx = %x\n",
                 RxContext->CurrentIrp, capFcb, capFobx));

    //
    // We cannot encrypt a SYSTEM file.
    //
    if ((capFcb->Attributes & FILE_ATTRIBUTE_SYSTEM) &&
        !(capFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {
        DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControlrol: FILE_ATTRIBUTE_SYSTEM\n"));
        Status = STATUS_ACCESS_DENIED;
        goto EXIT_THE_FUNCTION;
    }

    if (FsControlCode == FSCTL_SET_ENCRYPTION || FsControlCode == FSCTL_ENCRYPTION_FSCTL_IO) {
        
        ULONG InputBufferLength = 0;
        
        EncryptionBuffer = (PENCRYPTION_BUFFER)RxContext->CurrentIrpSp->Parameters.FileSystemControl.Type3InputBuffer;
        InputBufferLength = RxContext->CurrentIrpSp->Parameters.FileSystemControl.InputBufferLength;

        if (EncryptionBuffer == NULL) {
            DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControlrol: EncryptionBuffer == NULL\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

        //
        // The InputBufferLength should be atleast sizeof(ENCRYPTION_BUFFER).
        //
        if (InputBufferLength < sizeof(ENCRYPTION_BUFFER)) {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto EXIT_THE_FUNCTION;
        }

        try {
            if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
                ProbeForRead(EncryptionBuffer, InputBufferLength, sizeof(UCHAR));
            }
            EncryptionOperation = EncryptionBuffer->EncryptionOperation;
        } except (EXCEPTION_EXECUTE_HANDLER) {
              Status = STATUS_INVALID_USER_BUFFER;
              goto EXIT_THE_FUNCTION;
        }
    
    }

    if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
        UNICODE_STRING FileName;

        if (FsControlCode == FSCTL_SET_ENCRYPTION) {
            switch (EncryptionOperation) {
            case FILE_SET_ENCRYPTION:
            case STREAM_SET_ENCRYPTION: 
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                ShouldUpdateNameCache = TRUE;

                MRxDAVGetFullDirectoryPath(RxContext,NULL,&FileName);

                if (FileName.Buffer != NULL) {
                    Status = MRxDAVCreateEncryptedDirectoryKey(&FileName);
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("MrxDAVEfsControl: Encrypt Directory. capFcb = %x\n",
                             capFcb));
                break;

            case FILE_CLEAR_ENCRYPTION:
            case STREAM_CLEAR_ENCRYPTION:
                capFcb->Attributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                ShouldUpdateNameCache = TRUE;
                
                MRxDAVGetFullDirectoryPath(RxContext,NULL,&FileName);

                if (FileName.Buffer != NULL) {
                    Status = MRxDAVRemoveEncryptedDirectoryKey(&FileName);
                }

                DavDbgTrace(DAV_TRACE_DETAIL,
                            ("MrxDAVEfsControl: Decrypt Directory. capFcb = %x\n",
                             capFcb));
                break;

            default:
                Status = STATUS_NOT_SUPPORTED;
            }

            goto EXIT_THE_FUNCTION;

        } else {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ERROR: MrxDAVEfsControl: FSCTL NOT supported. capFcb = %x, "
                         "FsControlCode = %x\n", capFcb, FsControlCode));
            Status = STATUS_NOT_SUPPORTED;
            goto EXIT_THE_FUNCTION;
        }
    }

    if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {
        Status = STATUS_NOT_SUPPORTED;
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(davSrvOpen->UnderlyingFileObject != NULL);
    ASSERT(davSrvOpen->UnderlyingDeviceObject != NULL);

    KeInitializeEvent(&(Event), NotificationEvent, FALSE);

    irp = RxCeAllocateIrpWithMDL(DeviceObject->StackSize, FALSE, NULL);
    if (!irp) {
        DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControl/RxCeAllocateIrpWithMDL\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // We set the requestor mode to whatever the original IRP had. This is 
    // because the underlying filesystem can make the appropriate checks 
    // if the original IRP had usermode buffers.
    //
    irp->RequestorMode = RxContext->CurrentIrp->RequestorMode;

    irp->UserBuffer = RxContext->CurrentIrp->UserBuffer;

    irp->AssociatedIrp.SystemBuffer = RxContext->CurrentIrp->AssociatedIrp.SystemBuffer;

    if (RxContext->CurrentIrp->MdlAddress &&
        RxContext->CurrentIrp->MdlAddress->ByteCount != 0) {
        irp->MdlAddress = IoAllocateMdl(irp->UserBuffer,
                                        RxContext->CurrentIrp->MdlAddress->ByteCount,
                                        FALSE,
                                        FALSE,
                                        NULL);
        if (!irp->MdlAddress) {
            DavDbgTrace(DAV_TRACE_ERROR, ("ERROR: MrxDAVEfsControl/IoAllocateMdl\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked. This is where the function codes and the parameters are set.
    //
    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MajorFunction = (UCHAR)RxContext->MajorFunction;

    irpSp->MinorFunction = (UCHAR)RxContext->MinorFunction;

    irpSp->FileObject = davSrvOpen->UnderlyingFileObject;

    irpSp->Flags = RxContext->CurrentIrpSp->Flags;

    irpSp->Parameters.FileSystemControl.OutputBufferLength = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.OutputBufferLength;

    irpSp->Parameters.FileSystemControl.InputBufferLength = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.InputBufferLength;

    irpSp->Parameters.FileSystemControl.FsControlCode = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.FsControlCode;

    irpSp->Parameters.FileSystemControl.Type3InputBuffer = 
        RxContext->CurrentIrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    IoSetCompletionRoutine(irp,
                           MrxDAVEfsControlCompletion, 
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    try {

        //
        // Save the TopLevel Irp.
        //
        TopIrp = IoGetTopLevelIrp();

        //
        // Tell the underlying guy he's all clear.
        //
        IoSetTopLevelIrp(NULL);

        Status = IoCallDriver(DeviceObject,irp);

    } finally {

        //
        // Restore my context for unwind.
        //
        IoSetTopLevelIrp(TopIrp);

    }

    if ((Status == STATUS_PENDING) || (Status == STATUS_SUCCESS)) {

        Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        ASSERT(Status == STATUS_SUCCESS);

        Status = irp->IoStatus.Status;

        if ((Status == STATUS_SUCCESS) && (FsControlCode == FSCTL_SET_ENCRYPTION)) {
            
            DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FSCTL_SET_ENCRYPTION\n"));
            
            switch (EncryptionOperation) {

            case FILE_SET_ENCRYPTION:
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FILE_SET_ENCRYPTION\n"));
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;

            case FILE_CLEAR_ENCRYPTION:
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FILE_CLEAR_ENCRYPTION\n"));
                capFcb->Attributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;

            case STREAM_SET_ENCRYPTION: 
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: STREAM_SET_ENCRYPTION\n"));
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;

            }

        }

        if ( (Status == STATUS_SUCCESS) && (FsControlCode == FSCTL_ENCRYPTION_FSCTL_IO) ) {
            
            PWEBDAV_FCB DavFcb = NULL;
            DavFcb = MRxDAVGetFcbExtension(RxContext->pRelevantSrvOpen->pFcb);
            
            DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: FSCTL_ENCRYPTION_FSCTL_IO\n"));
            
            switch (EncryptionOperation) {
            case STREAM_SET_ENCRYPTION: 
                DavDbgTrace(DAV_TRACE_DETAIL, ("MrxDAVEfsControl: STREAM_SET_ENCRYPTION\n"));
                capFcb->Attributes |= FILE_ATTRIBUTE_ENCRYPTED;
                DavFcb->fFileAttributesChanged = TRUE;
                FileWasModified = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
                ShouldUpdateNameCache = TRUE;
                break;
            }
        
        }
    
    }
    
EXIT_THE_FUNCTION:

    //
    // If we modified the attributes, we need to update the name cache to
    // reflect this change.
    //
    if (Status == STATUS_SUCCESS && ShouldUpdateNameCache) {
        MRxDAVUpdateBasicFileInfoCache(RxContext, capFcb->Attributes, NULL);
    }

    //
    // If FileWasModified is TRUE and Status is STATUS_SUCCESS, we need to
    // mark this file as having been modified.
    //
    if (Status == STATUS_SUCCESS && FileWasModified) {
        InterlockedExchange(&(DavFcb->FileWasModified), 1);
    }

    if (ExclusiveFcbAcquired) {
        RxReleaseFcbResourceInMRx(RxContext->pRelevantSrvOpen->pFcb);
    }

    if (irp) {
        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }
        RxCeFreeIrp(irp);
    }

    return Status;
}


NTSTATUS
MrxDAVEfsControlCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    //
    // Since this is an IRP Completion routine, this cannot be paged code.
    //
    
    if (Context != NULL) {
        KeSetEvent((PKEVENT )Context, 0, FALSE);
    }
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\fileinfo.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the DAV mini redirector call down routines pertaining
    to query/set file/volume information.

Author:

    Rohan Kumar [RohanK] 27-Sept-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"


#define DEFAULT_BYTES_PER_SECTOR    512
#define DEFAULT_SECTORS_PER_ALLOCATION_UNIT 1

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVReNameContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeReNameRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeReNameRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVSetFileInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );
    
NTSTATUS
MRxDAVFormatUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );
    
BOOL
MRxDAVPrecompleteUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVQueryVolumeInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );
    
NTSTATUS
MRxDAVFormatUserModeQueryVolumeInformationRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );
    
BOOL
MRxDAVPrecompleteUserModeQueryVolumeInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

BOOL
DavIsValidDate(
    PLARGE_INTEGER pFileTime
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVQueryVolumeInformation)
#pragma alloc_text(PAGE, MRxDAVQueryFileInformation)
#pragma alloc_text(PAGE, MRxDAVSetFileInformation)
#pragma alloc_text(PAGE, MRxDAVReNameContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeReNameRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeReNameRequest)
#pragma alloc_text(PAGE, MRxDAVSetFileInformationContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeSetFileInformationRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeSetFileInformationRequest)
#pragma alloc_text(PAGE, MRxDAVQueryVolumeInformationContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeQueryVolumeInformationRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeQueryVolumeInformationRequest)
#pragma alloc_text(PAGE, DavIsValidDate)
#pragma alloc_text(PAGE, MRxDAVIsValidDirectory)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVQueryVolumeInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles query volume info requests for the DAV MiniRedir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    FS_INFORMATION_CLASS FsInfoClass;
    PVOID Buffer;
    ULONG BufferLength = 0, BufferLengthUsed = 0;
    PFILE_FS_SIZE_INFORMATION FileFsSizeInfo = NULL;
    PFILE_FS_FULL_SIZE_INFORMATION FileFsFullSizeInfo = NULL;
    PFILE_FS_VOLUME_INFORMATION FileFsVolInfo = NULL;
    PFILE_FS_DEVICE_INFORMATION FileFsDeviceInfo = NULL;
    PFILE_FS_ATTRIBUTE_INFORMATION FileFsAttributeInfo = NULL;
    RxCaptureFcb;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    BOOLEAN SynchronousIo = FALSE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeFileName;
    PWCHAR NtFileName = NULL;
    FILE_FS_FULL_SIZE_INFORMATION SizeInfo;
    ULONG SizeInBytes = 0;
    PWEBDAV_V_NET_ROOT DavVNetRoot = (PWEBDAV_V_NET_ROOT)RxContext->pRelevantSrvOpen->pVNetRoot->Context;

    PAGED_CODE();

    FsInfoClass = RxContext->Info.FsInformationClass;
    BufferLength = RxContext->Info.LengthRemaining;
    Buffer = RxContext->Info.Buffer;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVQueryVolumeInformation. FsInfoClass = %d.\n", 
                 PsGetCurrentThreadId(), FsInfoClass));

    if ( FsInfoClass == FileFsSizeInformation || 
         FsInfoClass == FileFsFullSizeInformation ) {

        //
        // If the Driver initialization went smoothly then DavWinInetCachePath 
        // should be containing the WinInetCachePath value.
        //
        ASSERT(DavWinInetCachePath[0] != L'\0');

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryVolumeInformation: DavWinInetCachePath: %ws\n",
                     PsGetCurrentThreadId(), DavWinInetCachePath));

        //
        // Create an NT path name for the cached file. This is used in the 
        // NtCreateFile call below. If c:\foo\bar is the DOA path name,
        // the NT path name is \??\c:\foo\bar. 
        //

        SizeInBytes = ( MAX_PATH + wcslen(L"\\??\\") + 1 ) * sizeof(WCHAR);
        NtFileName = RxAllocatePoolWithTag(PagedPool, SizeInBytes, DAV_FILENAME_POOLTAG);
        if (NtFileName == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAVQueryVolumeInformation/RxAllocatePool: Error Val"
                         " = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(NtFileName, SizeInBytes);

        wcscpy( NtFileName, L"\\??\\" );
        wcscpy( &(NtFileName[4]), DavWinInetCachePath );

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryVolumeInformation: NtFileName = %ws\n",
                     PsGetCurrentThreadId(), NtFileName));

        RtlInitUnicodeString( &(UnicodeFileName), NtFileName );

        InitializeObjectAttributes(&(ObjectAttributes),
                                   &(UnicodeFileName),
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = ZwOpenFile(&(FileHandle),
                              (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                              &(ObjectAttributes),
                              &(IoStatusBlock),
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY);
        if ( !NT_SUCCESS(NtStatus) ) {
            FileHandle = NULL;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation/NtOpenFile: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        NtStatus = ZwQueryVolumeInformationFile(FileHandle,
                                                &(IoStatusBlock),
                                                &(SizeInfo),
                                                sizeof(SizeInfo),
                                                FileFsFullSizeInformation);
        if ( !NT_SUCCESS(NtStatus) ) {
            NtStatus = IoStatusBlock.Status;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation/NtQueryVolumeInformationFile: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    switch (FsInfoClass) {
    
    case FileFsVolumeInformation:
    
        if ( BufferLength < sizeof(FILE_FS_VOLUME_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileFsVolInfo = (PFILE_FS_VOLUME_INFORMATION)Buffer;

        FileFsVolInfo->VolumeCreationTime.LowPart = 0;
        FileFsVolInfo->VolumeCreationTime.HighPart = 0;

        FileFsVolInfo->VolumeSerialNumber = 0;

        FileFsVolInfo->SupportsObjects = FALSE;

        FileFsVolInfo->VolumeLabelLength = 0;

        FileFsVolInfo->VolumeLabel[0] = 0;

        BufferLengthUsed += sizeof(FILE_FS_VOLUME_INFORMATION);
        
        break;
    
    case FileFsSizeInformation:

        if ( BufferLength < sizeof(FILE_FS_SIZE_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        if (!DavVNetRoot->fReportsAvailableSpace)
        {
            FileFsSizeInfo = (PFILE_FS_SIZE_INFORMATION)Buffer;

            FileFsSizeInfo->AvailableAllocationUnits.LowPart = SizeInfo.ActualAvailableAllocationUnits.LowPart;
            FileFsSizeInfo->AvailableAllocationUnits.HighPart = SizeInfo.ActualAvailableAllocationUnits.HighPart;

            FileFsSizeInfo->BytesPerSector = SizeInfo.BytesPerSector;

            FileFsSizeInfo->SectorsPerAllocationUnit = SizeInfo.SectorsPerAllocationUnit;

            FileFsSizeInfo->TotalAllocationUnits.LowPart = SizeInfo.TotalAllocationUnits.LowPart;
            FileFsSizeInfo->TotalAllocationUnits.HighPart = SizeInfo.TotalAllocationUnits.HighPart;

            BufferLengthUsed += sizeof(FILE_FS_SIZE_INFORMATION);
        }
        else
        {
            NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                                SIZEOF_DAV_SPECIFIC_CONTEXT,
                                                MRxDAVFormatTheDAVContext,
                                                (USHORT)DAV_MINIRDR_ENTRY_FROM_QUERYVOLUMEINFORMATION,
                                                MRxDAVQueryVolumeInformationContinuation,
                                                "MRxDAVQueryVolumeInformation");
            if (NtStatus == STATUS_SUCCESS)
            {
                BufferLengthUsed += sizeof(FILE_FS_SIZE_INFORMATION);
            }
        }
        break;

    case FileFsFullSizeInformation:

        if ( BufferLength < sizeof(FILE_FS_FULL_SIZE_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }
        if (!DavVNetRoot->fReportsAvailableSpace)
        {
            FileFsFullSizeInfo = (PFILE_FS_FULL_SIZE_INFORMATION)Buffer;

            FileFsFullSizeInfo->ActualAvailableAllocationUnits.LowPart = SizeInfo.ActualAvailableAllocationUnits.LowPart;
            FileFsFullSizeInfo->ActualAvailableAllocationUnits.HighPart = SizeInfo.ActualAvailableAllocationUnits.HighPart;

            FileFsFullSizeInfo->BytesPerSector = SizeInfo.BytesPerSector;

            FileFsFullSizeInfo->CallerAvailableAllocationUnits.LowPart = SizeInfo.CallerAvailableAllocationUnits.LowPart;
            FileFsFullSizeInfo->CallerAvailableAllocationUnits.HighPart = SizeInfo.CallerAvailableAllocationUnits.HighPart;

            FileFsFullSizeInfo->SectorsPerAllocationUnit = SizeInfo.SectorsPerAllocationUnit;

            FileFsFullSizeInfo->TotalAllocationUnits.LowPart = SizeInfo.TotalAllocationUnits.LowPart;
            FileFsFullSizeInfo->TotalAllocationUnits.HighPart = SizeInfo.TotalAllocationUnits.HighPart;

            BufferLengthUsed += sizeof(FILE_FS_FULL_SIZE_INFORMATION);
        }
        else
        {
            NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                                SIZEOF_DAV_SPECIFIC_CONTEXT,
                                                MRxDAVFormatTheDAVContext,
                                                (USHORT)DAV_MINIRDR_ENTRY_FROM_QUERYVOLUMEINFORMATION,
                                                MRxDAVQueryVolumeInformationContinuation,
                                                "MRxDAVQueryVolumeInformation");
        
            if (NtStatus == STATUS_SUCCESS)
            {
                BufferLengthUsed += sizeof(FILE_FS_FULL_SIZE_INFORMATION);
            }
        }

        break;

    case FileFsDeviceInformation:

        if ( BufferLength < sizeof(FILE_FS_DEVICE_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileFsDeviceInfo = (PFILE_FS_DEVICE_INFORMATION)Buffer;

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVQueryVolumeInformation. DeviceType = %d.\n", 
                     PsGetCurrentThreadId(), NetRoot->DeviceType));
        
        FileFsDeviceInfo->DeviceType = NetRoot->DeviceType;

        FileFsDeviceInfo->Characteristics = FILE_REMOTE_DEVICE;

        BufferLengthUsed += sizeof(FILE_FS_DEVICE_INFORMATION);
        
        break;
    
    case FileFsAttributeInformation: {

        ULONG LengthNeeded, FileSystemNameLength;
         
        LengthNeeded = sizeof(FILE_FS_ATTRIBUTE_INFORMATION);
        LengthNeeded += ( wcslen(DD_DAV_FILESYS_NAME_U) * sizeof(WCHAR) );

        if ( BufferLength < LengthNeeded ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryVolumeInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileFsAttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)Buffer;

        FileFsAttributeInfo->FileSystemAttributes = (FILE_CASE_PRESERVED_NAMES | FILE_SUPPORTS_ENCRYPTION);

        FileFsAttributeInfo->MaximumComponentNameLength = 255;
        
        FileSystemNameLength = ( 1 + wcslen(DD_DAV_FILESYS_NAME_U) ) * sizeof(WCHAR);

        FileFsAttributeInfo->FileSystemNameLength = FileSystemNameLength;

        wcscpy(&(FileFsAttributeInfo->FileSystemName[0]), DD_DAV_FILESYS_NAME_U);

        BufferLengthUsed += LengthNeeded;

    }
        
        break;

    default:
        
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVQueryVolumeInformation. FsInfoClass = %d.\n", 
                     PsGetCurrentThreadId(), FsInfoClass));
        
        NtStatus = STATUS_NOT_IMPLEMENTED;
        
        break;
    
    }

EXIT_THE_FUNCTION:

    RxContext->Info.LengthRemaining -= BufferLengthUsed;

    //
    // Close the handle if we opened the handle to the WinInetCachePath.
    //
    if (FileHandle) {
        NtClose(FileHandle);
    }

    //
    // Free the NtFileName buffer if we allocated one.
    //
    if (NtFileName) {
        RxFreePool(NtFileName);
    }

    return NtStatus;
}


NTSTATUS
MRxDAVQueryFileInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles query file info requests for the DAV mini--redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    FS_INFORMATION_CLASS FsInfoClass;
    PFCB thisFcb = NULL;
    PVOID Buffer = NULL;
    ULONG BufferLength = 0, BufferLengthUsed = 0, fileAttributes = 0;
    PFILE_BASIC_INFORMATION FileBasicInfo = NULL;
    PFILE_STANDARD_INFORMATION FileStandardInfo = NULL;
    PFILE_INTERNAL_INFORMATION FileInternalInfo = NULL;
    PFILE_EA_INFORMATION FileEaInfo = NULL;
    PFILE_ATTRIBUTE_TAG_INFORMATION FileAttTagInfo = NULL;
    PFILE_NAME_INFORMATION FileAltNameInfo = NULL;
    PFILE_STREAM_INFORMATION FileStreamInfo = NULL;

    PAGED_CODE();

    FsInfoClass = RxContext->Info.FsInformationClass;
    BufferLength = RxContext->Info.LengthRemaining;
    Buffer = RxContext->Info.Buffer;
    thisFcb = (PFCB)RxContext->pFcb;

    //
    // If the file attributes is 0, then we set return FILE_ATTRIBUTE_ARCHIVE.
    // We fake this since the apps expect this.
    //
    fileAttributes = thisFcb->Attributes;
    if (fileAttributes == 0) {
        fileAttributes = FILE_ATTRIBUTE_ARCHIVE;
    }

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVQueryFileInformation. FsInfoClass = %d.\n", 
                 PsGetCurrentThreadId(), FsInfoClass));

    switch (FsInfoClass) {
    
    case FileBasicInformation:

        FileBasicInfo = (PFILE_BASIC_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_BASIC_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileBasicInfo->ChangeTime.LowPart = thisFcb->LastChangeTime.LowPart;
        FileBasicInfo->ChangeTime.HighPart = thisFcb->LastChangeTime.HighPart;

        FileBasicInfo->CreationTime.LowPart = thisFcb->CreationTime.LowPart;
        FileBasicInfo->CreationTime.HighPart = thisFcb->CreationTime.HighPart;

        FileBasicInfo->LastAccessTime.LowPart = thisFcb->LastAccessTime.LowPart;
        FileBasicInfo->LastAccessTime.HighPart = thisFcb->LastAccessTime.HighPart;

        FileBasicInfo->LastWriteTime.LowPart = thisFcb->LastWriteTime.LowPart;
        FileBasicInfo->LastWriteTime.HighPart = thisFcb->LastWriteTime.HighPart;

        FileBasicInfo->FileAttributes = fileAttributes;

        BufferLengthUsed += sizeof(FILE_BASIC_INFORMATION);

        break;

    case FileStandardInformation:

        FileStandardInfo = (PFILE_STANDARD_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_STANDARD_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileStandardInfo->AllocationSize.LowPart = thisFcb->Header.AllocationSize.LowPart;
        FileStandardInfo->AllocationSize.HighPart = thisFcb->Header.AllocationSize.HighPart;

        FileStandardInfo->EndOfFile.LowPart = thisFcb->Header.FileSize.LowPart;
        FileStandardInfo->EndOfFile.HighPart = thisFcb->Header.FileSize.HighPart;

        FileStandardInfo->DeletePending = 0;

        FileStandardInfo->Directory = (BOOLEAN)(fileAttributes & FILE_ATTRIBUTE_DIRECTORY);

        FileStandardInfo->NumberOfLinks = thisFcb->NumberOfLinks;

        BufferLengthUsed += sizeof(FILE_STANDARD_INFORMATION);
        
        break;

    case FileInternalInformation:

        FileInternalInfo = (PFILE_INTERNAL_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_INTERNAL_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileInternalInfo->IndexNumber.LowPart = 0;
        FileInternalInfo->IndexNumber.HighPart = 0;
        
        BufferLengthUsed += sizeof(FILE_INTERNAL_INFORMATION);
        
        break;

    case FileEaInformation:

        FileEaInfo = (PFILE_EA_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_EA_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileEaInfo->EaSize = 0;

        BufferLengthUsed += sizeof(FILE_EA_INFORMATION);
        
        break;

    case FileAttributeTagInformation:

        FileAttTagInfo = (PFILE_ATTRIBUTE_TAG_INFORMATION)Buffer;
    
        if ( BufferLength < sizeof(FILE_ATTRIBUTE_TAG_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        FileAttTagInfo->FileAttributes = fileAttributes;

        FileAttTagInfo->ReparseTag = 0;

        BufferLengthUsed += sizeof(FILE_ATTRIBUTE_TAG_INFORMATION);
        
        break;

    case FileAlternateNameInformation:

        FileAltNameInfo = (PFILE_NAME_INFORMATION)Buffer;
    
        if ( BufferLength < sizeof(FILE_NAME_INFORMATION) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        //
        // We don't return any alternate names.
        //

        FileAltNameInfo->FileNameLength = 0;

        FileAltNameInfo->FileName[0] = L'\0';

        BufferLengthUsed += sizeof(FILE_NAME_INFORMATION);
        
        break;

    case FileStreamInformation: {
        
        FileStreamInfo = (PFILE_STREAM_INFORMATION)Buffer;

        if ( BufferLength < sizeof(FILE_STREAM_INFORMATION) + 6 * sizeof(WCHAR) ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVQueryFileInformation. Insufficient Buffer.\n",
                         PsGetCurrentThreadId()));
            break;
        }

        // Return the default stream information of the dav file

        FileStreamInfo->NextEntryOffset = 0;
        FileStreamInfo->StreamNameLength = 7 * sizeof(WCHAR);
        FileStreamInfo->StreamSize.QuadPart = thisFcb->Header.FileSize.QuadPart;
        FileStreamInfo->StreamAllocationSize.QuadPart = thisFcb->Header.AllocationSize.QuadPart;
        RtlCopyMemory(&FileStreamInfo->StreamName[0], L"::$DATA", 7 * sizeof(WCHAR));

        BufferLengthUsed += sizeof(FILE_STREAM_INFORMATION) + 6 * sizeof(WCHAR);
        /*
        PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
        PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

        NtStatus = DavXxxInformation(IRP_MJ_QUERY_INFORMATION,
                                     davSrvOpen->UnderlyingFileObject,
                                     FileStreamInformation,
                                     RxContext->Info.Length,
                                     RxContext->Info.Buffer,
                                     NULL);*/
        } 

        break;

    default:
        
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVQueryFileInformation. FsInfoClass = %d.\n",
                     PsGetCurrentThreadId(), FsInfoClass));
        
        NtStatus = STATUS_NOT_IMPLEMENTED;
        
        break;

    }

    RxContext->Info.LengthRemaining -= BufferLengthUsed;

    return NtStatus;
}


NTSTATUS
MRxDAVSetFileInformation(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles query file info requests for the DAV mini--redir.

Arguments:

    RxContext - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PFCB thisFcb = NULL;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(SrvOpen->pFcb);
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer = NULL;
    PFILE_DISPOSITION_INFORMATION FileDispInfo = NULL;
    PFILE_RENAME_INFORMATION FileRenInfo = NULL;
    PFILE_END_OF_FILE_INFORMATION FileEOFInfo = NULL;
    PFILE_BASIC_INFORMATION FileBasicInfo = NULL;
    PFILE_ALLOCATION_INFORMATION FileAllocInfo = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    BOOLEAN FileAttributesChanged = FALSE;

    PAGED_CODE();

    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    thisFcb = (PFCB)RxContext->pFcb;
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVSetFileInformation: FileInformationClass = %d\n",
                 PsGetCurrentThreadId(), FileInformationClass));

    switch (FileInformationClass) {
    
    case FileDispositionInformation:

        FileDispInfo = (PFILE_DISPOSITION_INFORMATION)Buffer;

        //
        // If we have been asked to delete this file or directory and its read
        // only, then we return STATUS_CANNOT_DELETE.
        //
        if ( FileDispInfo->DeleteFile && (thisFcb->Attributes & (FILE_ATTRIBUTE_READONLY)) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAvSetFileInformation: STATUS_CANNOT_DELETE %wZ\n",
                         PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));
            NtStatus = STATUS_CANNOT_DELETE;
            goto EXIT_THE_FUNCTION;
        }

        if (FileDispInfo->DeleteFile) {
            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAvSetFileInformation: DELETE %wZ\n",
                         PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));
        }

        //
        // This file needs to be deleted on close OR a previous delete of this
        // file is being nullified.
        //
        DavFcb->DeleteOnClose = ( (FileDispInfo->DeleteFile == TRUE) ? TRUE : FALSE );

        break;

    case FileRenameInformation:

        FileRenInfo = (PFILE_RENAME_INFORMATION)Buffer;

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAvSetFileInformation: NewFileName = %ws\n",
                     PsGetCurrentThreadId(), FileRenInfo->FileName));

        //
        // If the FileNameLength is greater than (MAX_PATH * sizeof(WCHAR)),
        // we return STATUS_NAME_TOO_LONG since the NewFileName in the FCB
        // cannot hold names greater than this size.
        //
        if ( FileRenInfo->FileNameLength > (MAX_PATH * sizeof(WCHAR)) ) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: MRxDAvSetFileInformation: STATUS_NAME_TOO_LONG %wZ\n",
                         PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));
            NtStatus = STATUS_NAME_TOO_LONG;
            goto EXIT_THE_FUNCTION;
        }

        //
        // Copy the new file name.
        //
        RtlCopyMemory(DavFcb->NewFileName, FileRenInfo->FileName, FileRenInfo->FileNameLength);

        DavFcb->NewFileNameLength = FileRenInfo->FileNameLength;

        NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                            SIZEOF_DAV_SPECIFIC_CONTEXT,
                                            MRxDAVFormatTheDAVContext,
                                            DAV_MINIRDR_ENTRY_FROM_RENAME,
                                            MRxDAVReNameContinuation,
                                            "MRxDAVSetFileInformation");
        if (NtStatus != ERROR_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVSetFileInformation/UMRxAsyncEngOuterWrapper: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        } else {
            //
            // We need to set this value in the DAV Fcb. We look at this value on 
            // Close to figure out the new file name to do the PUT on.
            //
            DavFcb->FileWasRenamed = TRUE;
            //
            // Create the name based file not found cache.
            //
            MRxDAVCacheFileNotFound(RxContext);
            //
            // Invalidate the file not found cache for the new name if it exists.
            //
            MRxDAVInvalidateFileNotFoundCacheForRename(RxContext);
            MRxDAVInvalidateFileInfoCache(RxContext);

            if ((thisFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) &&
                (thisFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED)) {
                UNICODE_STRING DirName;
                UNICODE_STRING RenameName;
                PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;

                //
                // Remove the old directory name from the registry
                //
                MRxDAVRemoveEncryptedDirectoryKey(&DavFcb->FileNameInfo);

                RenameName.Buffer = &RenameInformation->FileName[0];
                RenameName.Length = (USHORT)RenameInformation->FileNameLength;

                NtStatus = MRxDAVGetFullDirectoryPath(RxContext,&RenameName,&DirName);

                if (NtStatus != STATUS_SUCCESS) {
                    goto EXIT_THE_FUNCTION;
                }

                if (DirName.Buffer != NULL) {
                    //
                    // Create the new directory in the registry
                    //
                    NtStatus = MRxDAVCreateEncryptedDirectoryKey(&DirName);

                    // The buffer was allocated in MRxDAVGetFullDirectoryPath
                    RxFreePool(DirName.Buffer);
                }
            }
        }

        break;

    case FileEndOfFileInformation: {
        
            PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

            //
            // If the FileEndOfFileInformation is being done on a directory,
            // return STATUS_INVALID_PARAMETER since it doesn't make sense to
            // do this.
            //
            if (DavFcb->isDirectory) {
                NtStatus = STATUS_INVALID_PARAMETER;
                goto EXIT_THE_FUNCTION;
            }
        
            NtStatus = DavXxxInformation(IRP_MJ_SET_INFORMATION,
                                         davSrvOpen->UnderlyingFileObject,
                                         FileEndOfFileInformation,
                                         RxContext->Info.Length,
                                         RxContext->Info.Buffer,
                                         NULL);
           if (NtStatus == STATUS_SUCCESS) {
               thisFcb->Header.FileSize = ((PFILE_END_OF_FILE_INFORMATION)(RxContext->Info.Buffer))->EndOfFile;
               InterlockedExchange(&(DavFcb->FileWasModified), 1);
               DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
               MRxDAVUpdateFileInfoCacheFileSize(RxContext,&thisFcb->Header.FileSize);
           } else {
               DavDbgTrace(DAV_TRACE_ERROR,
                           ("%ld: ERROR: MRxDAvSetFileInformation/DavXxxInformation"
                            ". FileInfoClass = %d\n", PsGetCurrentThreadId(), FileInformationClass));
           }

    }
        break;

    case FileBasicInformation:

        if (!DavVNetRoot->fAllowsProppatch) {
            NtStatus = STATUS_ACCESS_DENIED;
            break;
        }

        FileBasicInfo = (PFILE_BASIC_INFORMATION)Buffer;

        //
        // If the user specified -1 for a field, it means that we should leave
        // the field unchanged. We set the field to 0 then so we know not to
        // actually set the field to the user-specified (in this case, illegal)
        // value.
        //

        if (FileBasicInfo->LastWriteTime.QuadPart == -1) {
            FileBasicInfo->LastWriteTime.QuadPart = 0;
        }

        if (FileBasicInfo->LastAccessTime.QuadPart == -1) {
            FileBasicInfo->LastAccessTime.QuadPart = 0;
        }

        if (FileBasicInfo->CreationTime.QuadPart == -1) {
            FileBasicInfo->CreationTime.QuadPart = 0;
        }

        //
        // Let us first find what changed, we will try to change it on the server
        // if that succeeds, we will set it on the FCB.
        //

        if (FileBasicInfo->ChangeTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->ChangeTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->LastChangeTime.LowPart != FileBasicInfo->ChangeTime.LowPart)||
                (thisFcb->LastChangeTime.HighPart != FileBasicInfo->ChangeTime.HighPart)) {
                thisFcb->LastChangeTime.LowPart = FileBasicInfo->ChangeTime.LowPart;
                thisFcb->LastChangeTime.HighPart = FileBasicInfo->ChangeTime.HighPart;
            }
        }

        if (FileBasicInfo->CreationTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->CreationTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->CreationTime.LowPart != FileBasicInfo->CreationTime.LowPart)||
                (thisFcb->CreationTime.HighPart != FileBasicInfo->CreationTime.HighPart)) {
                DavFcb->fCreationTimeChanged = TRUE;
            }
        }

        if (FileBasicInfo->LastAccessTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->LastAccessTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->LastAccessTime.LowPart != FileBasicInfo->LastAccessTime.LowPart)||
                (thisFcb->LastAccessTime.HighPart != FileBasicInfo->LastAccessTime.HighPart)) {
                DavFcb->fLastAccessTimeChanged = TRUE;
            }
        }

        if (FileBasicInfo->LastWriteTime.QuadPart != 0) {
            if (!DavIsValidDate(&FileBasicInfo->LastWriteTime)) {
                NtStatus = STATUS_INVALID_PARAMETER;
                break;
            }
            if ((thisFcb->LastWriteTime.LowPart != FileBasicInfo->LastWriteTime.LowPart)||
                (thisFcb->LastWriteTime.HighPart != FileBasicInfo->LastWriteTime.HighPart)) {
                DavFcb->fLastModifiedTimeChanged = TRUE;
                DavFcb->DoNotTakeTheCurrentTimeAsLMT = TRUE;
            }
        }

        if ((FileBasicInfo->FileAttributes != 0) && (thisFcb->Attributes != FileBasicInfo->FileAttributes)) {

            DavDbgTrace(DAV_TRACE_DETAIL,
                        ("%ld: MRxDAVSetFileInformation: thisFcb->Attributes = %x, "
                         "FileBasicInfo->FileAttributes = %x\n", PsGetCurrentThreadId(),
                         thisFcb->Attributes, FileBasicInfo->FileAttributes));

            //
            // If this is a directory then when we OR the attributes with
            // FILE_ATTRIBUTE_DIRECTORY. This is because this gets filtered
            // by the time it comes to us and we have code in the usermode
            // which makes some validity checks when a user tries to set
            // attributes on a directory.
            //
            if ( (thisFcb->Attributes & FILE_ATTRIBUTE_DIRECTORY) ) {

                FileBasicInfo->FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                
            }

            DavFcb->fFileAttributesChanged = TRUE;
            FileAttributesChanged = TRUE;

        }

        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVSetFileInformation: fCreationTimeChanged = %d, "
                     "fLastAccessTimeChanged = %d, fLastModifiedTimeChanged = %d, "
                     "fFileAttributesChanged = %d\n", PsGetCurrentThreadId(),
                     DavFcb->fCreationTimeChanged, DavFcb->fLastAccessTimeChanged,
                     DavFcb->fLastModifiedTimeChanged, DavFcb->fFileAttributesChanged));

        NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                            SIZEOF_DAV_SPECIFIC_CONTEXT,
                                            MRxDAVFormatTheDAVContext,
                                            DAV_MINIRDR_ENTRY_FROM_SETFILEINFORMATION,
                                            MRxDAVSetFileInformationContinuation,
                                            "MRxDAVSetFileInformation");
        if (NtStatus != ERROR_SUCCESS) {
            
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVSetFileInformation/UMRxAsyncEngOuterWrapper: "
                         "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        
        } else {

            //
            // Succeeded, modify on the FCB.
            //
            if(DavFcb->fCreationTimeChanged) {
                thisFcb->CreationTime.LowPart = FileBasicInfo->CreationTime.LowPart;
                thisFcb->CreationTime.HighPart = FileBasicInfo->CreationTime.HighPart;
            }

            if(DavFcb->fLastAccessTimeChanged) {
                thisFcb->LastAccessTime.LowPart = FileBasicInfo->LastAccessTime.LowPart;
                thisFcb->LastAccessTime.HighPart = FileBasicInfo->LastAccessTime.HighPart;
            }

            if(DavFcb->fLastModifiedTimeChanged) {
                thisFcb->LastWriteTime.LowPart = FileBasicInfo->LastWriteTime.LowPart;
                thisFcb->LastWriteTime.HighPart = FileBasicInfo->LastWriteTime.HighPart;
            }

            //
            // DavFcb->fFileAttributesChanged could be set on create, and the 
            // FileBasicInfo->FileAttributes could be 0 here. So we should not
            // check DavFcb->fFileAttributesChanged.
            //
            if (FileAttributesChanged) {
                ULONG SavedAttributes = thisFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED;
                thisFcb->Attributes = FileBasicInfo->FileAttributes;
                //
                // SetFileInformation should not affect any extended NT file
                // attributes.
                //
                thisFcb->Attributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
                thisFcb->Attributes |= SavedAttributes;
            }

            MRxDAVUpdateBasicFileInfoCache(RxContext, thisFcb->Attributes, &thisFcb->LastWriteTime);

        }

        //
        // Cleanup the FCB bits.
        //
        DavFcb->fCreationTimeChanged = DavFcb->fFileAttributesChanged = 
        DavFcb->fLastAccessTimeChanged = DavFcb->fLastModifiedTimeChanged = 0;

        break;

    case FileAllocationInformation: {

        PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);

        //
        // If the FileAllocationInformation is being done on a directory,
        // return STATUS_INVALID_PARAMETER since it doesn't make sense to
        // do this.
        //
        if (DavFcb->isDirectory) {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto EXIT_THE_FUNCTION;
        }

        NtStatus = DavXxxInformation(IRP_MJ_SET_INFORMATION,
                                     davSrvOpen->UnderlyingFileObject,
                                     FileAllocationInformation,
                                     RxContext->Info.Length,
                                     RxContext->Info.Buffer,
                                     NULL);
        if (NtStatus == STATUS_SUCCESS) {
            InterlockedExchange(&(DavFcb->FileWasModified), 1);
            DavFcb->DoNotTakeTheCurrentTimeAsLMT = FALSE;
        } else {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAvSetFileInformation/DavXxxInformation"
                         ". FileInfoClass = %d\n", PsGetCurrentThreadId(), FileInformationClass));
        }

    }
        break;

    default:

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAvSetFileInformation: FileInformationClass"
                     " = %d\n", PsGetCurrentThreadId(), FileInformationClass));
        
        NtStatus = STATUS_NOT_IMPLEMENTED;
        
        break;
    
    }

EXIT_THE_FUNCTION:

    return NtStatus;
}


NTSTATUS
MRxDAVReNameContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This is the continuation routine which renames a file.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation
                            
--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVReNameContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVReNameContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeReNameRequest,
                              MRxDAVPrecompleteUserModeReNameRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVReNameContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeReNameRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the ReName request being sent to the user mode for 
    processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(SrvOpen->pFcb);
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWCHAR ServerName = NULL, OldPathName = NULL, NewPathName = NULL;
    ULONG ServerNameLengthInBytes, OldPathNameLengthInBytes, NewPathNameLengthInBytes;
    PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG NetRootNameLengthInBytes, NetRootNameLengthInWChars;
    PFILE_RENAME_INFORMATION FileRenInfo = NULL;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeReNameRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeReNameRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    FileRenInfo = (PFILE_RENAME_INFORMATION)RxContext->Info.Buffer;
    
    DavWorkItem->WorkItemType = UserModeReName;

    DavReNameRequest = &(DavWorkItem->ReNameRequest);

    //
    // If the destination file already exists, then we need to need to replace
    // the file only if ReplaceIfExists is set to TRUE.
    //
    DavReNameRequest->ReplaceIfExists = FileRenInfo->ReplaceIfExists;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: ReplaceIfExists: %d\n",
                 PsGetCurrentThreadId(), DavReNameRequest->ReplaceIfExists));
    
    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavReNameRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: ServerName: %ws\n",
                 PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    DavReNameRequest->ServerID = DavSrvCall->ServerID;

    NetRoot = SrvOpen->pFcb->pNetRoot;

    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
    NetRootNameLengthInWChars = ( NetRootNameLengthInBytes / sizeof(WCHAR) );

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the OldPathName of the Directory.
    //
    OldPathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                 SrvOpen->pAlreadyPrefixedName->Length + 
                                 sizeof(WCHAR) );

    OldPathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                       OldPathNameLengthInBytes);
    if (OldPathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlZeroMemory(OldPathName, OldPathNameLengthInBytes);
    
    RtlCopyBytes(OldPathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    RtlCopyBytes( (OldPathName + NetRootNameLengthInWChars), 
                  SrvOpen->pAlreadyPrefixedName->Buffer, 
                  SrvOpen->pAlreadyPrefixedName->Length );
    
    OldPathName[( ( (OldPathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavReNameRequest->OldPathName = OldPathName;
    wcscpy(DavReNameRequest->Url, DavFcb->Url);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: pAlreadyPrefixedName: %wZ\n",
                 PsGetCurrentThreadId(), SrvOpen->pAlreadyPrefixedName));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: OldPathName: %ws\n",
                 PsGetCurrentThreadId(), OldPathName));

    //
    // Copy the NewPathName of the Directory. If DavFcb->NewFileName starts with
    // a L'\\' then we don't need to add one, but if it doesn't, we need to add
    // one.
    //

    if (DavFcb->NewFileName[0] == L'\\') {
        NewPathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                     DavFcb->NewFileNameLength + 
                                     sizeof(WCHAR) );
    } else {
        NewPathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                                     DavFcb->NewFileNameLength + 
                                     sizeof(WCHAR) +
                                     sizeof(WCHAR) );
    }

    NewPathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                       NewPathNameLengthInBytes);
    if (NewPathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(NewPathName, NewPathNameLengthInBytes);

    RtlCopyBytes(NewPathName, JustTheNetRootName, NetRootNameLengthInBytes);

    //
    // If DavFcb->NewFileName starts with a L'\\' then we don't need to add one,
    // but if it doesn't, we need to copy one before we copy the new name.
    //
    if (DavFcb->NewFileName[0] == L'\\') {
        RtlCopyBytes( (NewPathName + NetRootNameLengthInWChars), 
                      DavFcb->NewFileName, 
                      DavFcb->NewFileNameLength );
    } else {
        RtlCopyBytes( (NewPathName + NetRootNameLengthInWChars), 
                      L"\\",
                      sizeof(WCHAR) );
        RtlCopyBytes( (NewPathName + NetRootNameLengthInWChars + 1), 
                      DavFcb->NewFileName, 
                      DavFcb->NewFileNameLength );
    }

    NewPathName[( ( (NewPathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavReNameRequest->NewPathName = NewPathName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: NewFileName: %ws\n",
                 PsGetCurrentThreadId(), DavFcb->NewFileName));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeReNameRequest: NewPathName: %ws\n",
                 PsGetCurrentThreadId(), NewPathName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    DavReNameRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    DavReNameRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    //
    // If an OpaqueLockToken is associated with this SrvOpen (which means that
    // the file was LOCKed on the server) then we need to add this token to
    // the MOVE request we send to the server to ReName the file.
    //
    if (davSrvOpen->OpaqueLockToken != NULL) {

        ULONG LockTokenLengthInBytes = 0;

        ASSERT(davSrvOpen->LockTokenEntry != NULL);

        LockTokenLengthInBytes = (1 + wcslen(davSrvOpen->OpaqueLockToken)) * sizeof(WCHAR);

        DavReNameRequest->OpaqueLockToken = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                                                 LockTokenLengthInBytes);
        if (DavReNameRequest->OpaqueLockToken == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ld: ERROR: MRxDAVFormatUserModeCloseRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(DavReNameRequest->OpaqueLockToken, LockTokenLengthInBytes);

        RtlCopyBytes(DavReNameRequest->OpaqueLockToken,
                     davSrvOpen->OpaqueLockToken,
                     (wcslen(davSrvOpen->OpaqueLockToken) * sizeof(WCHAR)));

    }

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 

    if(!DavVNetRoot->SCAlreadyInitialized) {
        DbgPrint("Not impersonated in MRxDAVFormatUserModeReNameRequest \n");
        DbgBreakPoint();
    }

    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                     ("%ld: ERROR: MRxDAVFormatUserModeReNameRequest/"
                      "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                      PsGetCurrentThreadId(), NtStatus));
    }   

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeReNameRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeReNameRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the ReName request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus;
    PDAV_USERMODE_RENAME_REQUEST DavReNameRequest = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = NULL;

    PAGED_CODE();

    if (!OperationCancelled) {
        SrvOpen = RxContext->pRelevantSrvOpen;
        davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    }

    DavReNameRequest = &(DavWorkItem->ReNameRequest);

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (DavReNameRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavReNameRequest->OldPathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->OldPathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavReNameRequest->NewPathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->NewPathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavReNameRequest->OpaqueLockToken != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavReNameRequest->OpaqueLockToken);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the Rename case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeReNameRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
        goto EXIT_THE_FUNCTION;
    }

    NtStatus = AsyncEngineContext->Status;
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeReNameRequest:"
                     "Rename failed with NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }

    //
    // If the OpaqueLockToken is non-NULL, we need to free it now. This is
    // because after the MOVE "a", "b" (file "a" is being renamed to file "b") 
    // the OpaqueLockToken associated with file "a" is no longer valid for file
    // "b".
    //
    if (davSrvOpen->OpaqueLockToken != NULL) {

        ASSERT(davSrvOpen->LockTokenEntry != NULL);

        //
        // Remove the LockTokenEntry associated with this OpaqueLockToken from
        // the global LockTokenEntryList.
        //
        ExAcquireResourceExclusiveLite(&(LockTokenEntryListLock), TRUE);
        RemoveEntryList( &(davSrvOpen->LockTokenEntry->listEntry) );
        ExReleaseResourceLite(&(LockTokenEntryListLock));

        //
        // Free the PagedPool that was allocated for the ServerName.
        //
        RxFreePool(davSrvOpen->LockTokenEntry->ServerName);
        davSrvOpen->LockTokenEntry->ServerName = NULL;

        //
        // Free the PagedPool that was allocated for the PathName.
        //
        RxFreePool(davSrvOpen->LockTokenEntry->PathName);
        davSrvOpen->LockTokenEntry->PathName = NULL;

        //
        // Free the PagedPool that was allocated for this LockTokenEntry.
        //
        RxFreePool(davSrvOpen->LockTokenEntry);
        davSrvOpen->LockTokenEntry = NULL;

        //
        // Free the PagedPool that was allocated for this OpaqueLockToken.
        //
        RxFreePool(davSrvOpen->OpaqueLockToken);
        davSrvOpen->OpaqueLockToken = NULL;

    }

EXIT_THE_FUNCTION:

    return(TRUE);
}


NTSTATUS
MRxDAVSetFileInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    The precompletion routine for the SetFileInformation request.

Arguments:


Return Value:

    TRUE or FALSE.

--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVSetFileInformationContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVSetFileInformationContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeSetFileInformationRequest,
                              MRxDAVPrecompleteUserModeSetFileInformationRequest
                              );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVSetFileInformationContinuation with NtStatus"
                 " = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;

}


NTSTATUS
MRxDAVFormatUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the SetFileInformation request being sent to the user mode for 
    processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflector's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PFCB thisFcb = (PFCB)RxContext->pFcb;
    PWEBDAV_FCB DavFcb = MRxDAVGetFcbExtension(SrvOpen->pFcb);
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWCHAR ServerName = NULL, PathName = NULL;
    ULONG ServerNameLengthInBytes, PathNameLengthInBytes;
    PDAV_USERMODE_SETFILEINFORMATION_REQUEST DavSetFileInformationRequest = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG NetRootNameLengthInBytes, NetRootNameLengthInWChars;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeSetFileInformationRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeSetFileInformationRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    DavWorkItem->WorkItemType = UserModeSetFileInformation;

    DavSetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);

    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavSetFileInformationRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeSetFileInformationRequest: ServerName: %ws\n",
                 PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    DavSetFileInformationRequest->ServerID = DavSrvCall->ServerID;

    NetRoot = SrvOpen->pFcb->pNetRoot;

    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);
    NetRootNameLengthInWChars = ( NetRootNameLengthInBytes / sizeof(WCHAR) );

    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the PathName of the Directory.
    //
    PathNameLengthInBytes = ( NetRootNameLengthInBytes + 
                              SrvOpen->pAlreadyPrefixedName->Length + 
                              sizeof(WCHAR) );

    PathName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                       PathNameLengthInBytes);
    if (PathName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlZeroMemory(PathName, PathNameLengthInBytes);
    
    RtlCopyBytes(PathName, JustTheNetRootName, NetRootNameLengthInBytes);
    
    RtlCopyBytes( (PathName + NetRootNameLengthInWChars), 
                  SrvOpen->pAlreadyPrefixedName->Buffer, 
                  SrvOpen->pAlreadyPrefixedName->Length );
    
    PathName[( ( (PathNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    DavSetFileInformationRequest->PathName = PathName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeSetFileInformationRequest: PathName: %ws\n",
                 PsGetCurrentThreadId(), PathName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    DavSetFileInformationRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    DavSetFileInformationRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 

    if(!DavVNetRoot->SCAlreadyInitialized)
    {
        DbgPrint("Not impersonated in MRxDAVFormatUserModeSetFileInformationRequest \n");
        DbgBreakPoint();
    }
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                     "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }   
    
    ASSERT(RxContext->Info.FileInformationClass == FileBasicInformation);
    
    //
    // Set the change bits, we will clear them from the FCB in 
    // MRxDavSetFileInformation routine this is OK because the FCB is exclusive 
    // at this point.
    //
    DavSetFileInformationRequest->FileBasicInformation = *(PFILE_BASIC_INFORMATION)(RxContext->Info.Buffer);

    if (RxContext->pFcb->Attributes & FILE_ATTRIBUTE_ENCRYPTED) {
        //
        // Preserve the FILE_ATTRIBUTE_ENCRYPTED flag on the PROPPATCH request 
        // sent to DAV server. In fact, no extended file attributes should be 
        // changed with a SetFileInformation request.
        //
        DavSetFileInformationRequest->FileBasicInformation.FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
    }

    //
    // If we are setting a particular time value, we need to make sure that it
    // it not zero. If the user is trying to set a subset of the basic information
    // and the other values (which are not being set by the user but need to be)
    // need to be updated as well, we do them now. The time values to be updated
    // are in the FCB. This situation happens in the copy command.
    //

    DavSetFileInformationRequest->fCreationTimeChanged = DavFcb->fCreationTimeChanged;
    if (DavSetFileInformationRequest->fCreationTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart == 0) {
            DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart = thisFcb->CreationTime.QuadPart;
        }
    }

    DavSetFileInformationRequest->fLastAccessTimeChanged = DavFcb->fLastAccessTimeChanged;
    if (DavSetFileInformationRequest->fLastAccessTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.LastAccessTime.QuadPart == 0) {
            DavSetFileInformationRequest->FileBasicInformation.LastAccessTime.QuadPart = thisFcb->LastAccessTime.QuadPart;
        }
    }

    DavSetFileInformationRequest->fLastModifiedTimeChanged = DavFcb->fLastModifiedTimeChanged;
    if (DavSetFileInformationRequest->fLastModifiedTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart == 0) {
            DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart = thisFcb->LastWriteTime.QuadPart;
        }
    }

    //
    // If we are setting both the Creation and LastWrite time values, we need to
    // make sure that the CreationTime <= LastWriteTime.
    //

    if (DavSetFileInformationRequest->fCreationTimeChanged && DavSetFileInformationRequest->fLastModifiedTimeChanged) {
        if (DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart > 
            DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart) {
            DavSetFileInformationRequest->FileBasicInformation.CreationTime.QuadPart = 
                DavSetFileInformationRequest->FileBasicInformation.LastWriteTime.QuadPart;
        }
    }

    DavSetFileInformationRequest->fFileAttributesChanged = DavFcb->fFileAttributesChanged;

    //
    // If an OpaqueLockToken is associated with this SrvOpen (which means that
    // the file was LOCKed on the server) then we need to add this token to
    // the PROPPATCH request we send to the server to SetFileInformation.
    //
    if (davSrvOpen->OpaqueLockToken != NULL) {

        ULONG LockTokenLengthInBytes = 0;

        ASSERT(davSrvOpen->LockTokenEntry != NULL);

        LockTokenLengthInBytes = (1 + wcslen(davSrvOpen->OpaqueLockToken)) * sizeof(WCHAR);

        DavSetFileInformationRequest->OpaqueLockToken = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                                                             LockTokenLengthInBytes);
        if (DavSetFileInformationRequest->OpaqueLockToken == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("ld: ERROR: MRxDAVFormatUserModeSetFileInformationRequest/"
                         "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

        RtlZeroMemory(DavSetFileInformationRequest->OpaqueLockToken, LockTokenLengthInBytes);

        RtlCopyBytes(DavSetFileInformationRequest->OpaqueLockToken,
                     davSrvOpen->OpaqueLockToken,
                     (wcslen(davSrvOpen->OpaqueLockToken) * sizeof(WCHAR)));

    }

EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeSetFileInformationRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeSetFileInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the SetFileInformation request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus;
    PDAV_USERMODE_SETFILEINFORMATION_REQUEST DavSetFileInformationRequest = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();

    DavSetFileInformationRequest = &(DavWorkItem->SetFileInformationRequest);

    //
    // If this operation was cancelled, then we don't need to do anything
    // special in the SetFileInformation case.
    //
    if (OperationCancelled) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeSetFileInformationRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (DavSetFileInformationRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavSetFileInformationRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavSetFileInformationRequest->PathName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavSetFileInformationRequest->PathName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (DavSetFileInformationRequest->OpaqueLockToken != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)DavSetFileInformationRequest->OpaqueLockToken);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    NtStatus = AsyncEngineContext->Status;

    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVPrecompleteUserModeSetFileInformationRequest:"
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
    }

EXIT_THE_FUNCTION:

    return(TRUE);
}


NTSTATUS
MRxDAVQueryVolumeInformationContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the continuation routine for query volume information operation.

Arguments:

    AsyncEngineContext - The Reflectors context.

    RxContext - The RDBSS context.
    
Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS NtStatus;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVQueryVolumeInformationContinuation!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT, 
                ("%ld: MRxDAVQueryVolumeInformationContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));


    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                              UMRX_ASYNCENGINE_ARGUMENTS,
                              MRxDAVFormatUserModeQueryVolumeInformationRequest,
                              MRxDAVPrecompleteUserModeQueryVolumeInformationRequest
                              );

    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVQueryVolumeInformationContinuation with NtStatus "
                 "= %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeQueryVolumeInformationRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the QueryVolumeInformation request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PWEBDAV_SRV_OPEN davSrvOpen = MRxDAVGetSrvOpenExtension(SrvOpen);
    PWCHAR ServerName = NULL, ShareName = NULL, JustTheShareName = NULL;
    ULONG ServerNameLengthInBytes, ShareNameLengthInBytes;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest = NULL;
    PWEBDAV_FOBX DavFobx = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    RxCaptureFobx;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeQueryVolumeInformationRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    
    IF_DEBUG {
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);
    }

    DavWorkItem->WorkItemType = UserModeQueryVolumeInformation;
    
    QueryVolumeInformationRequest = &(DavWorkItem->QueryVolumeInformationRequest);

    DavFobx = MRxDAVGetFobxExtension(capFobx);
    ASSERT(DavFobx != NULL);

    NetRoot = SrvOpen->pFcb->pNetRoot;

    DavVNetRoot = (PWEBDAV_V_NET_ROOT)SrvOpen->pVNetRoot->Context;
    ASSERT(DavVNetRoot != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: SrvCallName = %wZ, "
                 "SrvCallNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pSrvCall->pSrvCallName, NetRoot->pSrvCall->pSrvCallName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: ShareName = %wZ, "
                 "ShareNameLength = %d\n", PsGetCurrentThreadId(), 
                 NetRoot->pNetRootName, NetRoot->pNetRootName->Length));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: PathName = %wZ, "
                 "PathNameLength = %d\n", PsGetCurrentThreadId(), 
                 SrvOpen->pAlreadyPrefixedName, SrvOpen->pAlreadyPrefixedName->Length));

    SrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;
    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryVolumeInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName, 
                 SrvCall->pSrvCallName->Buffer, 
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    QueryVolumeInformationRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest: ServerName: "
                 "%ws\n", PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    QueryVolumeInformationRequest->ServerID = DavSrvCall->ServerID;

    //
    // The ShareName (pShareName) includes the ServerName. Hence to get the
    // ShareNameLengthInBytes, we do the following.
    //
    ShareNameLengthInBytes = (NetRoot->pNetRootName->Length - NetRoot->pSrvCall->pSrvCallName->Length);

    ShareName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheShareName = wcschr(ShareName, L'\\');

    // allocate for NULL
    ShareName = (PWCHAR)UMRxAllocateSecondaryBuffer(AsyncEngineContext, ShareNameLengthInBytes+sizeof(WCHAR));
    
    if (ShareName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryVolumeInformationRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    QueryVolumeInformationRequest->ShareName = (PWCHAR)ShareName;
    
    RtlZeroMemory(QueryVolumeInformationRequest->ShareName, ShareNameLengthInBytes+sizeof(WCHAR));
    
    //
    // Copy the ShareName.
    //
    RtlCopyMemory(ShareName, JustTheShareName, ShareNameLengthInBytes);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. PathName ="
                 " %ws\n", PsGetCurrentThreadId(), ShareName));

    //
    // Set the LogonID stored in the Dav V_NET_ROOT. This value is used in the
    // user mode.
    //
    QueryVolumeInformationRequest->LogonID.LowPart  = DavVNetRoot->LogonID.LowPart;
    QueryVolumeInformationRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. DavVNetRoot"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. LogonID.LowPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeQueryVolumeInformationRequest. LogonID.HighPart"
                 " = %08lx\n", PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));
    
    SecurityClientContext = &(DavVNetRoot->SecurityClientContext); 
    
    if(!DavVNetRoot->SCAlreadyInitialized)
    {
        DbgPrint("Not impersonated in MRxDAVFormatUserModeQueryVolumeInformationRequest \n");
        DbgBreakPoint();
    }
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
    if (!NT_SUCCESS(NtStatus)) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeQueryDirectoryRequest/"
                     "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                     PsGetCurrentThreadId(), NtStatus));
    }   


EXIT_THE_FUNCTION:

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeQueryVolumeInformationRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


BOOL
MRxDAVPrecompleteUserModeQueryVolumeInformationRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the Query Volume Information request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_REQUEST QueryVolumeInformationRequest;
    PDAV_USERMODE_QUERYVOLUMEINFORMATION_RESPONSE QueryVolumeInformationResponse;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Entering MRxDAVPrecompleteUserModeQueryVolumeInformationRequest.\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    QueryVolumeInformationRequest  = &(DavWorkItem->QueryVolumeInformationRequest);
    QueryVolumeInformationResponse = &(DavWorkItem->QueryVolumeInformationResponse);

    //
    // If the operation was cancelled then we don't need to do the following.
    //
    if (!OperationCancelled) {

        //
        // Get the response items only if we succeeded in the user mode and if
        // we got the properties of all the files in the directory.
        //
        if (AsyncEngineContext->Status == STATUS_SUCCESS) {

            if (RxContext->Info.FsInformationClass == FileFsSizeInformation) {
                
                PFILE_FS_SIZE_INFORMATION FileFsSizeInfo = (PFILE_FS_SIZE_INFORMATION)RxContext->Info.Buffer;

                FileFsSizeInfo->BytesPerSector = DEFAULT_BYTES_PER_SECTOR;

                FileFsSizeInfo->SectorsPerAllocationUnit = DEFAULT_SECTORS_PER_ALLOCATION_UNIT;

                *(LONGLONG *)&FileFsSizeInfo->TotalAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->TotalSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            

                *(LONGLONG *)&FileFsSizeInfo->AvailableAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->AvailableSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            


            } else {
                
                PFILE_FS_FULL_SIZE_INFORMATION FileFsFullSizeInfo = (PFILE_FS_FULL_SIZE_INFORMATION)RxContext->Info.Buffer;
                
                ASSERT(RxContext->Info.FsInformationClass == FileFsFullSizeInformation);

                FileFsFullSizeInfo->BytesPerSector = DEFAULT_BYTES_PER_SECTOR;

                FileFsFullSizeInfo->SectorsPerAllocationUnit = DEFAULT_SECTORS_PER_ALLOCATION_UNIT;

                *(LONGLONG *)&FileFsFullSizeInfo->TotalAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->TotalSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            

                *(LONGLONG *)&FileFsFullSizeInfo->ActualAvailableAllocationUnits = 
                *(LONGLONG *)&QueryVolumeInformationResponse->AvailableSpace / (DEFAULT_BYTES_PER_SECTOR * DEFAULT_SECTORS_PER_ALLOCATION_UNIT);            

                FileFsFullSizeInfo->CallerAvailableAllocationUnits.LowPart = FileFsFullSizeInfo->ActualAvailableAllocationUnits.LowPart;
                FileFsFullSizeInfo->CallerAvailableAllocationUnits.HighPart = FileFsFullSizeInfo->ActualAvailableAllocationUnits.HighPart;

            }

        }

    } else {

        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    }

    //  
    // We need to free up the heaps, we allocated in the format routine.
    //
    
    if (QueryVolumeInformationRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)QueryVolumeInformationRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (QueryVolumeInformationRequest->ShareName != NULL) {
    
        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)QueryVolumeInformationRequest->ShareName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeQueryVolumeInformationRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }
    
EXIT_THE_FUNCTION:

    AsyncEngineContext->Status = NtStatus;

    return(TRUE);
}


BOOL
DavIsValidDate(
    PLARGE_INTEGER pFileTime
    )
/*++

Routine Description:

    This routine checks whether the date corresponding to the filetime is valid

Arguments:

    pFileTime - Time to be validated

Return Value:

    TRUE or FALSE.

--*/
{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER NtTime;

    PAGED_CODE();

    NtTime = *pFileTime;        
    
    ExSystemTimeToLocalTime( &NtTime, &NtTime );
    RtlTimeToTimeFields( &NtTime, &TimeFields );

    //
    //  Check the range of the date found in the time field record
    //
    if ((TimeFields.Year < 1980) || (TimeFields.Year > (1980 + 127))) {

        return FALSE;
    }
    
    return TRUE;
}


NTSTATUS
MRxDAVIsValidDirectory(
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING DirectoryName
    )
/*++

Routine Description:

   This routine checks a remote directory. Actually in webdav all we do is make
   sure this is coming from our service which is indicated by the webdav
   signature string in the EAs. This gurantees us that our service has checked
   the path before we came here.

Arguments:

    RxContext - The RDBSS context.

    DirectoryName - The directory needs to be checked.

Return Value:

    RXSTATUS - The return status for the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    PFILE_FULL_EA_INFORMATION Ea = NULL;

    if (RxContext->Create.EaLength) {
        Ea = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        for ( ; ; ) {
            if ( !strcmp(Ea->EaName, EA_NAME_WEBDAV_SIGNATURE) ) {
                ntStatus = STATUS_SUCCESS;
                break;
            } else {
                if (!Ea->NextEntryOffset) {
                    break;
                }
                (ULONG_PTR) Ea += Ea->NextEntryOffset;
            }
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\locks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

Author:

    Balan Sethu Raman      [SethuR]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
UMRxLocks(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("UMRxLocks\n", 0 ));

    IF_DEBUG {
        RxCaptureFobx;
        ASSERT (capFobx != NULL);
        ASSERT (capFobx->pSrvOpen == RxContext->pRelevantSrvOpen);  //ok
    }

    Status = STATUS_NOT_IMPLEMENTED;


    RxDbgTrace(-1, Dbg, ("UMRxLocks  exit with status=%08lx\n", Status ));
    return(Status);

}

#if 0
NTSTATUS
UMRxUnlockRoutine (
    IN PRX_CONTEXT RxContext,
    IN PFILE_LOCK_INFO LockInfo
    )
/*++

Routine Description:

    This routine is called from the RDBSS whenever the fsrtl lock package calls the rdbss unlock routine.
    CODE.IMPROVEMENT what should really happen is that this should only be called for unlockall and unlockbykey;
    the other cases should be handled in the rdbss.

Arguments:

    Context - the RxContext associated with this request
    LockInfo - gives information about the particular range being unlocked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
       return STATUS_SUCCESS;
    case LOWIO_OP_UNLOCKALL:
    case LOWIO_OP_UNLOCKALLBYKEY:
    default:
       return STATUS_NOT_IMPLEMENTED;
    }
}
#endif


NTSTATUS
UMRxCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used. CODE.IMPROVEMENT this param is redundant if the rxcontext is filled out completely

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PMRX_FCB Fcb = SrvOpen->pFcb;

    PUMRX_SRV_OPEN umrxSrvOpen = UMRxGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("UMRxCompleteBufferingStateChangeRequest\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace(0,Dbg,("-->Context %lx\n",pContext));

    Status = STATUS_SUCCESS;

    RxDbgTrace(-1, Dbg, ("UMRxAssertBufferedFileLocks  exit with status=%08lx\n", Status ));
    return(Status);
}



NTSTATUS
UMRxIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    )
{

    PAGED_CODE();
    return(STATUS_SUCCESS);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\infocach.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    infocach.c

Abstract:

    This module implements the name cache for file basic and standard information.

Author:

    Yun Lin      [YunLin]      13-Feburary-2001

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVCacheFileNotFound)
#pragma alloc_text(PAGE, MRxDAVCacheFileNotFoundWithName)
#pragma alloc_text(PAGE, MRxDAVIsFileNotFoundCached)
#pragma alloc_text(PAGE, MRxDAVIsFileNotFoundCachedWithName)
#pragma alloc_text(PAGE, MRxDAVCreateFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVIsFileInfoCacheFound)
#pragma alloc_text(PAGE, MRxDAVInvalidateFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateBasicFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateFileInfoCacheStatus)
#pragma alloc_text(PAGE, MRxDAVCreateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVCreateStandardFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateFileInfoCacheFileSize)
#pragma alloc_text(PAGE, MRxDAVUpdateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateFileNotFoundCache)
#pragma alloc_text(PAGE, MRxDAVUpdateBasicFileInfoCacheAll)
#pragma alloc_text(PAGE, MRxDAVInvalidateBasicFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateBasicFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateBasicFileInfoCacheStatus)
#pragma alloc_text(PAGE, MRxDAVInvalidateStandardFileInfoCache)
#pragma alloc_text(PAGE, MRxDAVInvalidateStandardFileInfoCacheWithName)
#pragma alloc_text(PAGE, MRxDAVUpdateStandardFileInfoCacheStatus)
#endif

extern FAST_MUTEX MRxDAVFileInfoCacheLock;
MRX_DAV_STATISTICS MRxDAVStatistics;

VOID
MRxDAVCreateFileInfoCache(
    PRX_CONTEXT                            RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                               Status
    )
/*++

Routine Description:

   This routine creates name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - the file information package including basic and standard information
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVCreateBasicFileInfoCache(RxContext,&FileInfo->BasicInformation,Status);
    MRxDAVCreateStandardFileInfoCache(RxContext,&FileInfo->StandardInformation,Status);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVCreateFileInfoCache %wZ\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));
}

VOID
MRxDAVCreateFileInfoCacheWithName(
    PUNICODE_STRING            FileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_BASIC_INFORMATION    Basic,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - the file information package including basic and standard information
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVCreateBasicFileInfoCacheWithName(FileName,NetRoot,Basic,Status);
    MRxDAVCreateStandardFileInfoCacheWithName(FileName,NetRoot,Standard,Status);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVCreateFileInfoCacheWithName %wZ\n",FileName));
}


VOID
MRxDAVCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - the file basic information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot;

    PAGED_CODE();

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    MRxDAVCreateBasicFileInfoCacheWithName(OriginalFileName,NetRoot,Basic,Status);
}

VOID
MRxDAVCreateBasicFileInfoCacheWithName(
    PUNICODE_STRING         OriginalFileName,
    PMRX_NET_ROOT           NetRoot,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file basic information.

Arguments:

    OriginalFileName - the name of the file to cache the basic information
    NetRoot   - the Net Root that the file belongs to
    Basic     - the file basic information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    PFILE_BASIC_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_BASIC_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Basic;
        NameCache->PriorStatus = Status;

        if (FileInfoCache->FileAttributes & ~FILE_ATTRIBUTE_NORMAL) {
            FileInfoCache->FileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        }

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            FileInformationCacheLifeTimeInSec,
            MRxDAVStatistics.SmbsReceived.LowPart);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Create File Attrib cache : %x %wZ\n",Basic->FileAttributes,OriginalFileName));
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Create File Attrib cache : %I64X %I64X %wZ\n",Basic->CreationTime,Basic->LastAccessTime,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - the file standard information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();
    
    MRxDAVCreateStandardFileInfoCacheWithName(OriginalFileName,NetRoot,Standard,Status);
}

VOID
MRxDAVCreateStandardFileInfoCacheWithName(
    PUNICODE_STRING            OriginalFileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    )
/*++

Routine Description:

   This routine creates name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - the file standard information package
    Status    - the status returned from server response of query file information

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();
    
    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache == NULL) {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match
    }

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        *FileInfoCache = *Standard;

        NameCache->PriorStatus = Status;

        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            FileInformationCacheLifeTimeInSec,
            MRxDAVStatistics.SmbsReceived.LowPart);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Create Standard cache : %I64x %I64x %I64x %wZ\n",
                     ((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,
                     Standard->AllocationSize,
                     Standard->EndOfFile,
                     OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry as STATUS_OBJECT_NAME_NOT_FOUND
   for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    MRxDAVUpdateBasicFileInfoCacheStatus(RxContext,STATUS_OBJECT_NAME_NOT_FOUND);
    MRxDAVUpdateStandardFileInfoCacheStatus(RxContext,STATUS_OBJECT_NAME_NOT_FOUND);
}

VOID
MRxDAVUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    MRxDAVUpdateBasicFileInfoCacheStatus(RxContext,Status);
    MRxDAVUpdateStandardFileInfoCacheStatus(RxContext,Status);
}

VOID
MRxDAVUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = Status;
        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update status basic    : %x %wZ\n",Status,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    )
/*++

Routine Description:

   This routine updates the status of the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context
    Status    - the status needs to be put on the cache

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = Status;
        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVInvalidateBasicFileInfoCache(RxContext);
    MRxDAVInvalidateStandardFileInfoCache(RxContext);
}

VOID
MRxDAVInvalidateFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for both file basic and standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PAGED_CODE();

    MRxDAVInvalidateBasicFileInfoCacheWithName(OriginalFileName,NetRoot);
    MRxDAVInvalidateStandardFileInfoCacheWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for file basic information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    MRxDAVInvalidateBasicFileInfoCacheWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVInvalidateBasicFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for file basic information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Invalid Baisc    cache : %wZ\n",OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    MRxDAVInvalidateStandardFileInfoCacheWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVInvalidateStandardFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine invalidates the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Invalid Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize
    )
/*++

Routine Description:

   This routine updates file size on the name cache entry for the file standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION FileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        FileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        FileInfoCache->AllocationSize.QuadPart = FileSize->QuadPart;
        FileInfoCache->EndOfFile.QuadPart = FileSize->QuadPart;

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update File size cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime
    )
/*++

Routine Description:

   This routine updates file attributs and last write time on the name cache entry
   for the file basic information.

Arguments:

    RxContext - the RDBSS context
    FileAttributes - new file attributes
    pLastWriteTime - address of file last write time

Return Value:

    none

--*/
{
    FILE_BASIC_INFORMATION Basic;

    Basic.ChangeTime.QuadPart = 0;
    Basic.CreationTime.QuadPart = 0;
    Basic.LastWriteTime.QuadPart = 0;
    Basic.LastAccessTime.QuadPart = 0;

    if (pLastWriteTime != NULL && pLastWriteTime->QuadPart != 0) {
        Basic.LastWriteTime = *pLastWriteTime;
    }

    Basic.FileAttributes = FileAttributes;

    MRxDAVUpdateBasicFileInfoCacheAll(RxContext,&Basic);
}

VOID
MRxDAVUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic
    )
/*++

Routine Description:

   This routine updates the name cache entry for the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic - file basic information

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;
    PFILE_BASIC_INFORMATION BasicFileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        BasicFileInfoCache = (PFILE_BASIC_INFORMATION)NameCache->ContextExtension;

        if (Basic->CreationTime.QuadPart != 0) {
            BasicFileInfoCache->CreationTime = Basic->CreationTime;
        }

        if (Basic->LastAccessTime.QuadPart != 0) {
            BasicFileInfoCache->LastAccessTime = Basic->LastAccessTime;
        }

        if (Basic->LastWriteTime.QuadPart != 0) {
            BasicFileInfoCache->LastWriteTime = Basic->LastWriteTime;
        }

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                   ("Update File Attrib cache 2: %x %wZ\n",BasicFileInfoCache->FileAttributes,OriginalFileName));

        BasicFileInfoCache->FileAttributes = Basic->FileAttributes;

        if (BasicFileInfoCache->FileAttributes & ~FILE_ATTRIBUTE_NORMAL) {
            BasicFileInfoCache->FileAttributes &= ~FILE_ATTRIBUTE_NORMAL;
        }

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update File Attrib cache 3: %x %wZ\n",BasicFileInfoCache->FileAttributes,OriginalFileName));
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("Update File Attrib cache  : %I64X %I64X %wZ\n",BasicFileInfoCache->CreationTime,BasicFileInfoCache->LastAccessTime,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory
    )
/*++

Routine Description:

   This routine updates the name cache entry for the file standard information.

Arguments:

    RxContext   - the RDBSS context
    Standard    - file standard information
    IsDirectory - file is a directory

Return Value:

    none

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    PFILE_STANDARD_INFORMATION StandardFileInfoCache = NULL;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        StandardFileInfoCache = (PFILE_STANDARD_INFORMATION)NameCache->ContextExtension;

        if (Standard != NULL) {
            *StandardFileInfoCache = *Standard;
        } else {
            StandardFileInfoCache->Directory = IsDirectory;
        }

        RxNameCacheActivateEntry(NameCacheCtl,
                                 NameCache,
                                 0,
                                 0);

        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    (" Update Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

BOOLEAN
MRxDAVIsFileInfoCacheFound(
    PRX_CONTEXT                            RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                               *Status,
    PUNICODE_STRING                        OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of both file basic and standard information.

Arguments:

    RxContext - the RDBSS context
    FileInfo  - buffer to return file basic and standard information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    BOOLEAN CacheFound = FALSE;

    if (MRxDAVIsBasicFileInfoCacheFound(RxContext,&FileInfo->BasicInformation,Status,OriginalFileName)) {
        if (*Status == STATUS_SUCCESS) {
            if (MRxDAVIsStandardFileInfoCacheFound(RxContext,&FileInfo->StandardInformation,Status,OriginalFileName)) {
                CacheFound = TRUE;
            }
        } else {

            // if an error stored on the file basic information cache, return cache found
            CacheFound = TRUE;
        }
    }
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVIsFileInfoCacheFound %x %x %wZ\n",*Status,CacheFound,GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    return CacheFound;
}

BOOLEAN
MRxDAVIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file basic information.

Arguments:

    RxContext - the RDBSS context
    Basic     - buffer to return file basic information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot;
    PNAME_CACHE_CONTROL     NameCacheCtl;
    RX_NC_CHECK_STATUS      NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;
    BOOLEAN                 RootFound = FALSE;
    ULONG                   RootAttributes = 0;
    NTSTATUS                RootStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        NetRoot = RxContext->Create.pNetRoot;
    } else {
        ASSERT(capFcb != NULL);
        NetRoot = capFcb->pNetRoot;
    }

    DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    NameCacheCtl = &DavNetRoot->NameCacheCtlGFABasic;
    
    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS &&
            (!RootFound || *Status == RootStatus)) {

            // The name cache matches if it is not expired and the attributes matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Basic = *((PFILE_BASIC_INFORMATION)NameCache->ContextExtension);

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("   Found Basic     cache  : %x %wZ\n",Basic->FileAttributes,OriginalFileName));
            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("   Get File Attrib cache  : %I64X %I64X %wZ\n",Basic->CreationTime,Basic->LastAccessTime,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    } else {
        DavDbgTrace(DAV_TRACE_INFOCACHE,
                    ("   No    Basic     cache  : %wZ\n",OriginalFileName));
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return CacheFound;
}

BOOLEAN
MRxDAVIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName
    )
/*++

Routine Description:

   This routine looks for the name cache entry of the file standard information.

Arguments:

    RxContext - the RDBSS context
    Standard  - buffer to return file standard information
    Status    - status retured on the last reponse from server

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlGFAStandard;
    RX_NC_CHECK_STATUS      NameCacheStatus;

    BOOLEAN                 CacheFound = FALSE;
    BOOLEAN                 RootFound = FALSE;
    NTSTATUS                RootStatus = STATUS_SUCCESS;

    PAGED_CODE();

    if (OriginalFileName == NULL) {
        OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    }
    
    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS &&
            (!RootFound || *Status == RootStatus)) {

            // The name cache matches if it is not expired and the status matches the one of
            // the root file if it is a stream file. If this is a match, return the old status,
            // file info and reactivate the entry but leave expiration time unchanged.

            *Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtl);

            *Standard = *((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension);

            CacheFound = TRUE;

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);

            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("    Get Standard cache : %I64x %wZ\n",((PFILE_STANDARD_INFORMATION)NameCache->ContextExtension)->EndOfFile,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return CacheFound;
}

NTSTATUS
MRxDAVGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine looks for the status of the name cache entry of either file basic or standard information.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - statu of the name cache if found, otherwise, STATUS_SUCCESS

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtlBasic = &DavNetRoot->NameCacheCtlGFABasic;
    PNAME_CACHE_CONTROL     NameCacheCtlStandard = &DavNetRoot->NameCacheCtlGFAStandard;
    NTSTATUS                Status = STATUS_MORE_PROCESSING_REQUIRED;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtlBasic,OriginalFileName);

    if (NameCache != NULL) {
        RX_NC_CHECK_STATUS NameCacheStatus;
        //
        // Found it.  Now check entry for not expired
        //
        NameCacheStatus = RxNameCacheCheckEntry(NameCache,NameCache->Context);

        if (NameCacheStatus == RX_NC_SUCCESS) {
            //
            // If the cache has not expired, return the previous status.
            //
            Status = NameCache->PriorStatus;
            RxNameCacheOpSaved(NameCacheCtlBasic);

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtlBasic, NameCache, 0, 0);

            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("    Get Basic Status   : %x %wZ\n",Status,OriginalFileName));
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtlBasic, NameCache);
        }
    } else {
        NameCache = RxNameCacheFetchEntry(NameCacheCtlStandard,OriginalFileName);

        if (NameCache != NULL) {
            RX_NC_CHECK_STATUS NameCacheStatus;
            //
            // Found it.  Now check entry for not expired
            //
            NameCacheStatus = RxNameCacheCheckEntry(NameCache,NameCache->Context);

            if (NameCacheStatus == RX_NC_SUCCESS) {
                //
                // If the cache has not expired, return the previous status.
                //
                Status = NameCache->PriorStatus;
                RxNameCacheOpSaved(NameCacheCtlStandard);

                // put the entry back to the active list without changing the expire time
                RxNameCacheActivateEntry(NameCacheCtlStandard, NameCache, 0, 0);
            } else {
                // put the entry back to the expire list
                RxNameCacheExpireEntry(NameCacheCtlStandard, NameCache);
            }
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return Status;
}

BOOLEAN
MRxDAVIsFileNotFoundCached(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine checks if the name cache entry exists as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    return MRxDAVIsFileNotFoundCachedWithName(OriginalFileName,NetRoot);
}

BOOLEAN
MRxDAVIsFileNotFoundCachedWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    )
/*++

Routine Description:

   This routine checks if the name cache entry exists as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    BOOLEAN                 CacheFound = FALSE;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RX_NC_CHECK_STATUS NameCacheStatus;
        //
        // Found it.  Now check entry for not expired.
        // Note - The NameCache entry has been pulled off the active list.
        //
        NameCacheStatus = RxNameCacheCheckEntry(
                              NameCache,
                              //MRxDAVStatistics.SmbsReceived.LowPart
                              NameCache->Context);

        if ((NameCacheStatus == RX_NC_SUCCESS) &&
            (NameCache->PriorStatus == STATUS_OBJECT_NAME_NOT_FOUND)) {
            //
            // This is a match.  Return the old status, file info and
            // reactivate the entry but leave expiration time unchanged.
            //

            CacheFound = TRUE;
            DavDbgTrace(DAV_TRACE_INFOCACHE,
                        ("MRxDAVIsFileNotFoundCached %wZ\n",OriginalFileName));

            // put the entry back to the active list without changing the expire time
            RxNameCacheActivateEntry(NameCacheCtl, NameCache, 0, 0);
        } else {
            // put the entry back to the expire list
            RxNameCacheExpireEntry(NameCacheCtl, NameCache);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);

    return CacheFound;
}

VOID
MRxDAVCacheFileNotFound(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    
    PAGED_CODE();

    MRxDAVCacheFileNotFoundWithName(OriginalFileName,NetRoot);
}

VOID
MRxDAVCacheFileNotFoundWithName(
    PUNICODE_STRING  OriginalFileName,
    PMRX_NET_ROOT    NetRoot
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    PNAME_CACHE             NameCache = NULL;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        RxNameCacheActivateEntry(
            NameCacheCtl,
            NameCache,
            FileNotFoundCacheLifeTimeInSec,
            MRxDAVStatistics.SmbsReceived.LowPart);
    } else {
        NameCache = RxNameCacheCreateEntry (
                        NameCacheCtl,
                        OriginalFileName,
                        TRUE);   // case insensitive match

        if (NameCache != NULL) {
            NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            RxNameCacheActivateEntry(
                NameCacheCtl,
                NameCache,
                FileNotFoundCacheLifeTimeInSec,
                MRxDAVStatistics.SmbsReceived.LowPart);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVCacheFileNotFound %wZ\n",OriginalFileName));
}

VOID
MRxDAVCacheFileNotFoundFromQueryDirectory(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine creates the name cache entry for File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PUNICODE_STRING         Template = &capFobx->UnicodeQueryTemplate;
    UNICODE_STRING          FileName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);

    if (NameCache != NULL) {
        if ((NameCache == NULL) &&
            (OriginalFileName->Length > sizeof(WCHAR))) {
            //
            // Do lookup now since we may have skipped it at entry.
            //
            NameCache = RxNameCacheFetchEntry(NameCacheCtl,&FileName);
            if (NameCache == NULL) {
                NameCache = RxNameCacheCreateEntry (
                                NameCacheCtl,
                                OriginalFileName,
                                TRUE);   // case insensitive match
            }
        }
        if (NameCache != NULL) {
            NameCache->PriorStatus = STATUS_OBJECT_NAME_NOT_FOUND;
            RxNameCacheActivateEntry(
                NameCacheCtl,
                NameCache,
                FileNotFoundCacheLifeTimeInSec,
                MRxDAVStatistics.SmbsReceived.LowPart);
        }
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}

VOID
MRxDAVInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    PUNICODE_STRING         OriginalFileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,OriginalFileName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
    
    DavDbgTrace(DAV_TRACE_INFOCACHE,
                ("MRxDAVInvalidateFileNotFoundCache %wZ\n",OriginalFileName));
}

VOID
MRxDAVInvalidateFileNotFoundCacheForRename(
    PRX_CONTEXT     RxContext
    )
/*++

Routine Description:

   This routine invalidates the name cache entry as File Not Found.

Arguments:

    RxContext - the RDBSS context

Return Value:

    BOOLEAN - name cache found

--*/
{
    RxCaptureFcb;
    UNICODE_STRING          RenameName;

    PNAME_CACHE             NameCache = NULL;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PWEBDAV_NET_ROOT        DavNetRoot = (PWEBDAV_NET_ROOT)NetRoot->Context;
    PNAME_CACHE_CONTROL     NameCacheCtl = &DavNetRoot->NameCacheCtlFNF;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("Invalidate FNF cache from rename %wZ\n", &RenameName));

    PAGED_CODE();

    ExAcquireFastMutex(&MRxDAVFileInfoCacheLock);

    NameCache = RxNameCacheFetchEntry(NameCacheCtl,&RenameName);

    if (NameCache != NULL) {
        RxNameCacheExpireEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&MRxDAVFileInfoCacheLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\nvisible.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NVisible.h

Abstract:

    This module declares a number of flag variables that are essentially private
    to various modules but which are exposed so that they can be initialized from
    the registry and/or modified by fsctls. This should not be in precomp.h.

Revision History:

--*/

#ifndef _INVISIBLE_INCLUDED_
#define _INVISIBLE_INCLUDED_

extern ULONG MRxSmbNegotiateMask;  //controls which protocols are not negotiated

extern BOOLEAN MRxSmbDeferredOpensEnabled;
extern BOOLEAN MRxSmbOplocksDisabled;

#endif // _INVISIBLE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\infocach.h ===
typedef REDIR_STATISTICS   MRX_DAV_STATISTICS;
typedef PREDIR_STATISTICS  PMRX_DAV_STATISTICS;

extern MRX_DAV_STATISTICS MRxDAVStatistics;

VOID
MRxDAVCreateFileInfoCache(
    PRX_CONTEXT                            RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                               Status
    );

VOID
MRxDAVCreateFileInfoCacheWithName(
    PUNICODE_STRING            FileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_BASIC_INFORMATION    Basic,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    );

VOID
MRxDAVCreateBasicFileInfoCache(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    );

VOID
MRxDAVCreateBasicFileInfoCacheWithName(
    PUNICODE_STRING         OriginalFileName,
    PMRX_NET_ROOT           NetRoot,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                Status
    );

VOID
MRxDAVCreateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    );

VOID
MRxDAVCreateStandardFileInfoCacheWithName(
    PUNICODE_STRING            OriginalFileName,
    PMRX_NET_ROOT              NetRoot,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   Status
    );

VOID
MRxDAVUpdateFileInfoCacheFromDelete(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVUpdateFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    );

VOID
MRxDAVUpdateBasicFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    );

VOID
MRxDAVUpdateStandardFileInfoCacheStatus(
    PRX_CONTEXT     RxContext,
    NTSTATUS        Status
    );

VOID
MRxDAVInvalidateFileInfoCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVInvalidateBasicFileInfoCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateBasicFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVInvalidateStandardFileInfoCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateStandardFileInfoCacheWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVUpdateFileInfoCacheFileSize(
    PRX_CONTEXT     RxContext,
    PLARGE_INTEGER  FileSize
    );

VOID
MRxDAVUpdateBasicFileInfoCache(
    PRX_CONTEXT     RxContext,
    ULONG           FileAttributes,
    PLARGE_INTEGER  pLastWriteTime
    );

VOID
MRxDAVUpdateBasicFileInfoCacheAll(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic
    );

VOID
MRxDAVUpdateStandardFileInfoCache(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    BOOLEAN                    IsDirectory
    );

BOOLEAN
MRxDAVIsFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PDAV_USERMODE_CREATE_RETURNED_FILEINFO FileInfo,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    );
/*
// these file attributes may be different between streams on a file
ULONG StreamAttributes = FILE_ATTRIBUTE_COMPRESSED |
                         FILE_ATTRIBUTE_DIRECTORY |
                         FILE_ATTRIBUTE_SPARSE_FILE;
*/
BOOLEAN
MRxDAVIsBasicFileInfoCacheFound(
    PRX_CONTEXT             RxContext,
    PFILE_BASIC_INFORMATION Basic,
    NTSTATUS                *Status,
    PUNICODE_STRING         OriginalFileName
    );

BOOLEAN
MRxDAVIsStandardFileInfoCacheFound(
    PRX_CONTEXT                RxContext,
    PFILE_STANDARD_INFORMATION Standard,
    NTSTATUS                   *Status,
    PUNICODE_STRING            OriginalFileName
    );

NTSTATUS
MRxDAVGetFileInfoCacheStatus(
    PRX_CONTEXT RxContext
    );

BOOLEAN
MRxDAVIsFileNotFoundCached(
    PRX_CONTEXT RxContext
    );

BOOLEAN
MRxDAVIsFileNotFoundCachedWithName(
    PUNICODE_STRING OriginalFileName,
    PMRX_NET_ROOT   NetRoot
    );

VOID
MRxDAVCacheFileNotFound(
    PRX_CONTEXT RxContext
    );

VOID
MRxDAVCacheFileNotFoundWithName(
    PUNICODE_STRING  OriginalFileName,
    PMRX_NET_ROOT    NetRoot
    );

VOID
MRxDAVCacheFileNotFoundFromQueryDirectory(
    PRX_CONTEXT RxContext
    );

VOID
MRxDAVInvalidateFileNotFoundCache(
    PRX_CONTEXT     RxContext
    );

VOID
MRxDAVInvalidateFileNotFoundCacheForRename(
    PRX_CONTEXT     RxContext
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\kernel\netroot.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating net roots for the WebDav
    miniredir.

Author:

    Rohan Kumar    [RohanK]    24-April-1999
    
Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "webdav.h"

//
// Mentioned below are the prototypes of functions tht are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
MRxDAVCreateVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeVNetRootCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeVNetRootCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVFinalizeVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxDAVFormatUserModeVNetRootFinalizeRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    );

BOOL
MRxDAVPrecompleteUserModeVNetRootFinalizeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

NTSTATUS
MRxDAVDereferenceNetRootContext(
    IN PWEBDAV_NET_ROOT DavNetRoot
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxDAVUpdateNetRootState)
#pragma alloc_text(PAGE, MRxDAVCreateVNetRoot)
#pragma alloc_text(PAGE, MRxDAVCreateVNetRootContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeVNetRootCreateRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeVNetRootCreateRequest)
#pragma alloc_text(PAGE, MRxDAVFinalizeNetRoot)
#pragma alloc_text(PAGE, MRxDAVExtractNetRootName)
#pragma alloc_text(PAGE, MRxDAVFinalizeVNetRoot)
#pragma alloc_text(PAGE, MRxDAVFinalizeVNetRootContinuation)
#pragma alloc_text(PAGE, MRxDAVFormatUserModeVNetRootFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVPrecompleteUserModeVNetRootFinalizeRequest)
#pragma alloc_text(PAGE, MRxDAVDereferenceNetRootContext)
#endif

//
// Implementation of functions begins here.
//

NTSTATUS
MRxDAVUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot
    )
/*++

Routine Description:

   This routine update the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PAGED_CODE();

   if (pNetRoot->Context == NULL) {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
   } else {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
   }

   return STATUS_SUCCESS;
}


NTSTATUS
MRxDAVCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the 
   information required by the mini redirector.

Arguments:

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PMRX_V_NET_ROOT pVNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PWEBDAV_DEVICE_OBJECT DavDeviceObject = NULL;
    PUMRX_DEVICE_OBJECT UMRxDeviceObject = NULL;
    PMRX_SRV_CALL pSrvCall = NULL;
    PMRX_NET_ROOT pNetRoot = NULL;
    BOOLEAN  SynchronousIo = FALSE;
    NTSTATUS ExNtStatus = STATUS_SUCCESS;
    HANDLE ExDeviceHandle = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ExDeviceName;
    IO_STATUS_BLOCK IoStatusBlock;
    PKEY_VALUE_PARTIAL_INFORMATION DavKeyValuePartialInfo = NULL;
    PIO_STACK_LOCATION IrpSp = NULL;
    PFILE_OBJECT DavFileObject = NULL;
    PWCHAR NewFileName = NULL;
    ULONG NewFileNameLength = 0;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateVNetRoot\n", PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateVNetRoot: pVNetRoot = %08lx\n", 
                 PsGetCurrentThreadId(), pVNetRoot));

    RxContext = pCreateNetRootContext->RxContext;
    pVNetRoot = (PMRX_V_NET_ROOT)pCreateNetRootContext->pVNetRoot;
    DavDeviceObject = (PWEBDAV_DEVICE_OBJECT)(RxContext->RxDeviceObject);
    UMRxDeviceObject = (PUMRX_DEVICE_OBJECT)&(DavDeviceObject->UMRefDeviceObject);
    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;
    DavVNetRoot = MRxDAVGetVNetRootExtension(pVNetRoot);

    ASSERT(DavVNetRoot != NULL);
    ASSERT(NodeType(pNetRoot) == RDBSS_NTC_NETROOT);
    ASSERT(NodeType(pSrvCall) == RDBSS_NTC_SRVCALL);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: NetRootName = %wZ\n", 
                 PsGetCurrentThreadId(), pVNetRoot->pNetRoot->pNetRootName));
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: VNetRoot = %08lx\n", 
                 PsGetCurrentThreadId(), pVNetRoot));
    
    //
    // Copy the LogonID in the MiniRedir's portion of the V_NET_ROOT.
    //
    DavVNetRoot->LogonID.LowPart = pVNetRoot->LogonId.LowPart;
    DavVNetRoot->LogonID.HighPart = pVNetRoot->LogonId.HighPart;
    DavVNetRoot->LogonIDSet = TRUE;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: LogonID.LowPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: LogonID.HighPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));

    //
    // There are cases when we fail, we want the error which SMB returned to be
    // returned to the user. This is becuase SMB could have returned a more 
    // specific error like logon failure or something on the share where as we
    // return share not found. To enable this we return STATUS_BAD_NETWORK_PATH 
    // when the creation of netroot fails instead of STATUS_BAD_NETWORK_NAME 
    // because MUP will overwrite SMBs error with our error if we return 
    // STATUS_BAD_NETWORK_NAME. STATUS_BAD_NETWORK_NAME is a specif error which
    // implies that the share does not exist where as STATUS_BAD_NETWORK_PATH is
    // a more general error.
    //

    //
    // If the share name is a net root or a pipe, we reject it since SMB 
    // Mini-Redir is the only one that handles it.
    //
    if ( pNetRoot->Type == NET_ROOT_PIPE || pNetRoot->Type == NET_ROOT_MAILSLOT ) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateVNetRoot: Invalid NetRootType\n",
                     PsGetCurrentThreadId()));
        //
        // We set the following flag in the DavVNetRoot structure to TRUE. This 
        // is because when the finalize comes, we don't need to go to the 
        // usermode.
        //
        DavVNetRoot->createVNetRootUnSuccessful = TRUE;
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_NAME;
        pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_NAME;
        goto EXIT_THE_FUNCTION;
    }

    SynchronousIo = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVCreateVNetRoot: SynchronousIo = %d\n",
                 PsGetCurrentThreadId(), SynchronousIo));
    
    //
    // We need to pass the server and share names to the user mode to check 
    // whether they actually exist. RxContext has 4 pointers that the mini-redirs 
    // can use. Here we use MRxContext[1]. We store a reference to the pVNetRoot
    // strucutre. MRxContext[0] is used to store a reference to the 
    // AsynEngineContext and this is done when the context gets created in the 
    // function UMRxCreateAsyncEngineContext.
    //
    RxContext->MRxContext[1] = pVNetRoot;
    
    //
    // We now need to go to the user mode and find out if this WebDav share
    // exists on the server.
    //
    NtStatus = UMRxAsyncEngOuterWrapper(RxContext,
                                        SIZEOF_DAV_SPECIFIC_CONTEXT,
                                        MRxDAVFormatTheDAVContext,
                                        DAV_MINIRDR_ENTRY_FROM_CREATEVNETROOT,
                                        MRxDAVCreateVNetRootContinuation,
                                        "MRxDAVCreateVNetRoot");
    if (NtStatus != STATUS_SUCCESS) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateVNetRoot/UMRxAsyncEngOuterWrapper: "
                     "NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));

        if (NtStatus == STATUS_ACCESS_DENIED ||
            NtStatus == STATUS_LOGON_FAILURE ||
            NtStatus == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
            pCreateNetRootContext->VirtualNetRootStatus = NtStatus;
        } else {
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_PATH;
        }

        //
        // Don't set the NetRootStatus here since it is a global data structure
        // shared among different VNetRoots (TS users). Failure on one VNetRoot
        // should not affects the NetRoot.
        //

        goto EXIT_THE_FUNCTION;
    }

    //
    // If we succeeded and the share is not a TAHOE share, nor an Office Web 
    // Server share, then we claim the share name. Otherwise we fail since the 
    // users intends to use the TAHOE specific features in Rosebud, or Office
    // specific features in Shell.
    //
    if ( !DavVNetRoot->isTahoeShare && !DavVNetRoot->isOfficeShare ) {
        pNetRoot->DeviceType = RxDeviceType(DISK);
        pNetRoot->Type = NET_ROOT_DISK;
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
        pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
    } else {
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCreateVNetRoot/UMRxAsyncEngOuterWrapper: "
                     "TAHOE or OFFICE Share\n", PsGetCurrentThreadId()));
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->VirtualNetRootStatus = STATUS_BAD_NETWORK_NAME;
        pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_PATH;
        // pCreateNetRootContext->NetRootStatus = STATUS_BAD_NETWORK_NAME;
    }

    if (pNetRoot->Context == NULL) {
        
        pNetRoot->Context = RxAllocatePoolWithTag(PagedPool,
                                                  sizeof(WEBDAV_NET_ROOT),
                                                  DAV_NETROOT_POOLTAG);

        if (pNetRoot->Context == NULL) {
            
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
            
            pCreateNetRootContext->NetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
        
        } else {
            
            PWEBDAV_NET_ROOT DavNetRoot = (PWEBDAV_NET_ROOT)pNetRoot->Context;

            //
            // Refcount of 2, one is taken away at VNetRoot finalization, another one is taken
            // away at NetRoot finalization.
            //
            DavNetRoot->RefCount = 2;
            DavNetRoot->pRdbssNetRoot = pNetRoot;

            RxNameCacheInitialize(&DavNetRoot->NameCacheCtlGFABasic,
                                  sizeof(FILE_BASIC_INFORMATION),
                                  NameCacheMaxEntries);

            RxNameCacheInitialize(&DavNetRoot->NameCacheCtlGFAStandard,
                                  sizeof(FILE_STANDARD_INFORMATION),
                                  NameCacheMaxEntries);

            RxNameCacheInitialize(&DavNetRoot->NameCacheCtlFNF,
                                  0,
                                  NameCacheMaxEntries);

            pVNetRoot->Context2 = DavNetRoot;
            
            DavDbgTrace(DAV_TRACE_DAVNETROOT,
                        ("MRxDav allocates DavNetRoot %x %x %x 2\n",DavNetRoot,pNetRoot,pVNetRoot));
        
        }
    
    } else {
        
        PWEBDAV_NET_ROOT DavNetRoot = (PWEBDAV_NET_ROOT)pNetRoot->Context;

        pVNetRoot->Context2 = DavNetRoot;
        InterlockedIncrement(&DavNetRoot->RefCount);
        DavDbgTrace(DAV_TRACE_DAVNETROOT,
                    ("MRxDAVCreateVNetRoot ref DavNetRoot %x %x %x %d\n",DavNetRoot,pNetRoot,pVNetRoot,DavNetRoot->RefCount));
    
    }

    //
    // We return from here since the code below was written for accomodating the
    // exchange DAV Redir which was suppose to ship with Office 2000. Since that
    // project (LocalStore which included the Exchange Redir) has been canned,
    // (as of Dec 8th, 2000) we don't need to execute the code below any more. 
    // We will keep it around though, just in case.
    //
    goto EXIT_THE_FUNCTION;
    
    //
    // The Exchange Redir has been installed on the system. Now we need to find 
    // out if its loaded. This is an exchange share. If the exchange Redir is 
    // not installed, we claim the name.
    //

    DavKeyValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DavExchangeDeviceName;
    
    RtlInitUnicodeString( &(ExDeviceName), (PWCHAR)DavKeyValuePartialInfo->Data );

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(ExDeviceName),
                               OBJ_CASE_INSENSITIVE,
                               0,
                               NULL);

    ExNtStatus = NtOpenFile(&(ExDeviceHandle),
                            0,
                            &(ObjectAttributes),
                            &(IoStatusBlock),
                            0,
                            0);
    if (ExNtStatus != STATUS_SUCCESS) {
        //
        // This is an exchange share but the Exchange Redir is not installed.
        // We will handle this.
        //
        ExDeviceHandle = INVALID_HANDLE_VALUE;
        DavDbgTrace(DAV_TRACE_DETAIL,
                    ("%ld: MRxDAVCreateVNetRoot. Exchange BUT No Redir\n",
                     PsGetCurrentThreadId()));
        pNetRoot->DeviceType = RxDeviceType(DISK);
        pNetRoot->Type = NET_ROOT_DISK;
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
        pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
        goto EXIT_THE_FUNCTION;
    }
    
    IrpSp = IoGetCurrentIrpStackLocation(RxContext->CurrentIrp);
    
    DavFileObject = IrpSp->FileObject;

    //
    // The NewFileNameLength is = ExchangeDeviceNameLength + PathName. The 
    // DavKeyValuePartialInfo->DataLength contains an extra 2 bytes for the 
    // \0 char.
    //
    NewFileNameLength = ( DavKeyValuePartialInfo->DataLength + 
                          DavFileObject->FileName.Length );

    //
    // If the first char is not a \, then we need to add another sizeof(WCHAR).
    //
    if (DavFileObject->FileName.Buffer[0] != L'\\') {
        NewFileNameLength += sizeof(WCHAR);
    }

    //
    // Allocate memory for the NewFileName.
    //
    NewFileName = ExAllocatePoolWithTag(PagedPool, NewFileNameLength, DAV_EXCHANGE_POOLTAG);
    if (NewFileName == NULL) {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVCreateVNetRoot/ExAllocatePoolWithTag\n",
                     PsGetCurrentThreadId()));
        pCreateNetRootContext->VirtualNetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
        pCreateNetRootContext->NetRootStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EXIT_THE_FUNCTION;
    }

    RtlZeroMemory(NewFileName, NewFileNameLength);

    //
    // Copy the new device name.
    //
    RtlCopyMemory(NewFileName,
                  DavKeyValuePartialInfo->Data,
                  DavKeyValuePartialInfo->DataLength);

    //
    // If the first char is not a \, then we need to copy it before we copy the
    // rest of the name.
    //
    if (DavFileObject->FileName.Buffer[0] != L'\\') {

        //
        // Copy the \ next.
        //
        RtlCopyMemory( ( NewFileName + DavKeyValuePartialInfo->DataLength ),
                       L"\\",
                       sizeof(WCHAR) );

        //
        // Finally copy the PathName that was sent with this IRP.
        //
        RtlCopyMemory( ( NewFileName + DavKeyValuePartialInfo->DataLength + sizeof(WCHAR) ),
                       DavFileObject->FileName.Buffer,
                       DavFileObject->FileName.Length );

    } else {
        
        //
        // Finally copy the PathName that was sent with this IRP.
        //
        RtlCopyMemory( ( NewFileName + DavKeyValuePartialInfo->DataLength ),
                       DavFileObject->FileName.Buffer,
                       DavFileObject->FileName.Length );
    
    }

    //
    // Free the memory allocated in the FileObject's original filename buffer.
    //
    ExFreePool(DavFileObject->FileName.Buffer);

    //
    // Set the NewFileName in the FileObject.
    //
    DavFileObject->FileName.Buffer = NewFileName;
    DavFileObject->FileName.Length = (USHORT)NewFileNameLength;
    DavFileObject->FileName.MaximumLength = (USHORT)NewFileNameLength;

    //
    // Finally, set the status to STATUS_REPARSE so that the I/O manager will
    // call into the Exchange Redir.
    //
    pCreateNetRootContext->VirtualNetRootStatus = STATUS_REPARSE;
    pCreateNetRootContext->NetRootStatus = STATUS_REPARSE;

EXIT_THE_FUNCTION:

    //
    // Callback the RDBSS for resumption.
    //
    pCreateNetRootContext->Callback(pCreateNetRootContext);

    //
    // If we opened a handle to the exchange redir, we need to close it now.
    //
    if (ExDeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(ExDeviceHandle);
    }
    
    //
    // Map the error code to STATUS_PENDING since this triggers the 
    // synchronization mechanism in the RDBSS.
    //
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateVNetRoot\n", PsGetCurrentThreadId()));

    return STATUS_PENDING;
}


NTSTATUS
MRxDAVCreateVNetRootContinuation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++
                                
Routine Description:
                            
    This routine checks to see if the share for which a VNetRoot is being
    created exists or not.
                            
Arguments:
                            
    AsyncEngineContext - The Reflectors context.
                            
    RxContext - The RDBSS context.
                                
Return Value:
                            
    RXSTATUS - The return status for the operation.
                            
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVCreateVNetRootContinuation\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVCreateVNetRootContinuation: "
                 "AsyncEngineContext: %08lx, RxContext: %08lx\n", 
                 PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    //
    // Try usermode.
    //
    NtStatus = UMRxSubmitAsyncEngUserModeRequest(
                                UMRX_ASYNCENGINE_ARGUMENTS,
                                MRxDAVFormatUserModeVNetRootCreateRequest,
                                MRxDAVPrecompleteUserModeVNetRootCreateRequest
                                );

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Leaving MRxDAVCreateVNetRootContinuation with NtStatus ="
                 " %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


NTSTATUS
MRxDAVFormatUserModeVNetRootCreateRequest(
    IN UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemLength,
    OUT PULONG_PTR ReturnedLength
    )
/*++

Routine Description:

    This routine formats the VNetRoot create request being sent to the user mode 
    for processing.

Arguments:
    
    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.
    
    ReturnedLength - 
    
Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_WORKITEM WorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PMRX_SRV_CALL SrvCall = NULL;
    PWEBDAV_SRV_CALL DavSrvCall = NULL;
    PMRX_NET_ROOT NetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PSECURITY_CLIENT_CONTEXT SecurityClientContext = NULL;
    PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;
    PWCHAR ServerName = NULL, ShareName = NULL;
    PWCHAR NetRootName = NULL, JustTheNetRootName = NULL;
    ULONG ServerNameLengthInBytes = 0, NetRootNameLengthInBytes = 0;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering MRxDAVFormatUserModeVNetRootCreateRequest!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: AsyncEngineContext"
                 " = %08lx, RxContext = %08lx.\n", PsGetCurrentThreadId(),  
                 AsyncEngineContext, RxContext));

     CreateVNetRootRequest = &(WorkItem->CreateVNetRootRequest);

     //
     // We need to set the work item type.
     //
     WorkItem->WorkItemType = UserModeCreateVNetRoot;

    //
    // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
    // RxContext structure. This is done in the MRxDAVCreateVNetRoot function.
    //
    VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
    
    ASSERT(VNetRoot != NULL);
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: "
                 "VNetRoot = %08lx\n", PsGetCurrentThreadId(), VNetRoot));

    DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
    ASSERT(DavVNetRoot != NULL);

    NetRoot = VNetRoot->pNetRoot;
    ASSERT(NetRoot != NULL);

    SrvCall = NetRoot->pSrvCall;
    ASSERT(SrvCall != NULL);

    DavSrvCall = MRxDAVGetSrvCallExtension(SrvCall);
    ASSERT(DavSrvCall != NULL);

    SecurityClientContext = &(DavVNetRoot->SecurityClientContext);

    //
    // Copy the LogonID in the CreateRequest buffer. The LogonId is in the 
    // MiniRedir's portion of the V_NET_ROOT.
    //
    CreateVNetRootRequest->LogonID.LowPart = DavVNetRoot->LogonID.LowPart;
    CreateVNetRootRequest->LogonID.HighPart = DavVNetRoot->LogonID.HighPart;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: LogonID.LowPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.LowPart));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: LogonID.HighPart = %08lx\n",
                 PsGetCurrentThreadId(), DavVNetRoot->LogonID.HighPart));

    //  
    // Copy the ServerName.
    //
    ServerNameLengthInBytes = ( SrvCall->pSrvCallName->Length + sizeof(WCHAR) );
    ServerName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                      ServerNameLengthInBytes);
    if (ServerName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ServerName,
                 SrvCall->pSrvCallName->Buffer,
                 SrvCall->pSrvCallName->Length);

    ServerName[( ( (ServerNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CreateVNetRootRequest->ServerName = ServerName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: ServerName: "
                 "%ws\n", PsGetCurrentThreadId(), ServerName));
    
    //
    // Copy the ServerID.
    //
    CreateVNetRootRequest->ServerID = DavSrvCall->ServerID;
    
    //
    // The NetRootName (pNetRootName) includes the ServerName. Hence to get the
    // NetRootNameLengthInBytes, we do the following.
    //
    NetRootNameLengthInBytes = (NetRoot->pNetRootName->Length - SrvCall->pSrvCallName->Length);

    //
    // For '\0' at the end.
    //
    NetRootNameLengthInBytes += sizeof(WCHAR);
    
    NetRootName = &(NetRoot->pNetRootName->Buffer[1]);
    JustTheNetRootName = wcschr(NetRootName, L'\\');
    
    //
    // Copy the NetRoot (Share) name.
    //
    ShareName = (PWCHAR) UMRxAllocateSecondaryBuffer(AsyncEngineContext,
                                                     NetRootNameLengthInBytes);
    if (ShareName == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest/"
                     "UMRxAllocateSecondaryBuffer. NtStatus = %08lx.\n",
                     PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    RtlCopyBytes(ShareName,
                 JustTheNetRootName,
                 (NetRoot->pNetRootName->Length - SrvCall->pSrvCallName->Length));
    
    ShareName[( ( (NetRootNameLengthInBytes) / sizeof(WCHAR) ) - 1 )] = L'\0';
    CreateVNetRootRequest->ShareName = ShareName;

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVFormatUserModeVNetRootCreateRequest: ShareName: "
                 "%ws\n", PsGetCurrentThreadId(), ShareName));
    
    //
    // Impersonate the client who initiated the request. If we fail to 
    // impersonate, tough luck.
    //
    if (SecurityClientContext != NULL) {
        NtStatus = UMRxImpersonateClient(SecurityClientContext, WorkItemHeader);
        if (!NT_SUCCESS(NtStatus)) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest/"
                         "UMRxImpersonateClient. NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }   
    } else {
        NtStatus = STATUS_INVALID_PARAMETER;
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: ERROR: MRxDAVFormatUserModeVNetRootCreateRequest: "
                     "SecurityClientContext is NULL.\n", 
                     PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    ASSERT(WorkItem->UserName[0] == L'\0' && WorkItem->Password[0] == L'\0');

    if (VNetRoot->pUserName && VNetRoot->pUserName->Length) {
        RtlCopyMemory(WorkItem->UserName,VNetRoot->pUserName->Buffer,VNetRoot->pUserName->Length);
    }

    if (VNetRoot->pPassword && VNetRoot->pPassword->Length) {
        RtlCopyMemory(WorkItem->Password,VNetRoot->pPassword->Buffer,VNetRoot->pPassword->Length);
    }

EXIT_THE_FUNCTION:
    
    DavDbgTrace(DAV_TRACE_ENTRYEXIT,
                ("%ld: Leaving MRxDAVFormatUserModeVNetRootCreateRequest with "
                 "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return NtStatus;
}


BOOL
MRxDAVPrecompleteUserModeVNetRootCreateRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    )
/*++

Routine Description:

    The precompletion routine for the CreateVNetRoot request.

Arguments:

    RxContext - The RDBSS context.
    
    AsyncEngineContext - The reflctor's context.
    
    WorkItem - The work item buffer.
    
    WorkItemLength - The length of the work item buffer.

    OperationCancelled - TRUE if this operation was cancelled by the user.

Return Value:

    TRUE - UMRxAsyncEngineCalldownIrpCompletion is called by the function
           UMRxCompleteUserModeRequest after we return.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDAV_USERMODE_CREATE_V_NET_ROOT_REQUEST CreateVNetRootRequest = NULL;
    PDAV_USERMODE_CREATE_V_NET_ROOT_RESPONSE CreateVNetRootResponse = NULL;
    PDAV_USERMODE_WORKITEM DavWorkItem = (PDAV_USERMODE_WORKITEM)WorkItemHeader;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;

    PAGED_CODE();

    CreateVNetRootRequest = &(DavWorkItem->CreateVNetRootRequest);
    CreateVNetRootResponse = &(DavWorkItem->CreateVNetRootResponse);

    if (!OperationCancelled) {
        //
        // The VNetRoot pointer is stored in the MRxContext[1] pointer of the 
        // RxContext structure. This is done in the MRxDAVCreateVNetRoot
        // function.
        //
        VNetRoot = (PMRX_V_NET_ROOT)RxContext->MRxContext[1];
        DavVNetRoot = MRxDAVGetVNetRootExtension(VNetRoot);
        ASSERT(DavVNetRoot != NULL);
    } else {
        DavDbgTrace(DAV_TRACE_ERROR,
                    ("%ld: MRxDAVPrecompleteUserModeVNetRootCreateRequest: Operation Cancelled. "
                     "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                     PsGetCurrentThreadId(), AsyncEngineContext, RxContext));
    }
    
    //  
    // We need to free up the heaps, we allocated in the format routine.
    //

    if (CreateVNetRootRequest->ServerName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CreateVNetRootRequest->ServerName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (CreateVNetRootRequest->ShareName != NULL) {

        NtStatus = UMRxFreeSecondaryBuffer(AsyncEngineContext, 
                                           (PBYTE)CreateVNetRootRequest->ShareName);
        if (NtStatus != STATUS_SUCCESS) {
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootCreateRequest/"
                         "UMRxFreeSecondaryBuffer: NtStatus = %08lx.\n", 
                         PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }

    }

    if (!OperationCancelled) {
        NtStatus = AsyncEngineContext->Status;
        if (NtStatus != STATUS_SUCCESS) {
            //
            // If the CreateVNetRoot failed in the usermode, we set the following
            // in the DavVNetRoot structure to TRUE. This is because when the 
            // finalize comes, we don't need to go to the usermode.
            //
            DavVNetRoot->createVNetRootUnSuccessful = TRUE;
            DavDbgTrace(DAV_TRACE_ERROR,
                        ("%ld: ERROR: MRxDAVPrecompleteUserModeVNetRootCreateRequest:"
                         " NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        } else {
            //
            // We would have figured out in the usermode if this share is a TAHOE
            // share or an Office Web Server share and whether this share allows 
            // PROPPATCH or not, and resporst available space or not
            //
            DavVNetRoot->isOfficeShare = CreateVNetRootResponse->isOfficeShare;
            DavVNetRoot->isTahoeShare = CreateVNetRootResponse->isTahoeShare;
            DavVNetRoot->fAllowsProppatch = CreateVNetRootResponse->fAllowsProppatch;
            DavVNetRoot->fReportsAvailableSpace = CreateVNetRootResponse->fReportsAvailableSpace;
        }
    }

EXIT_THE_FUNCTION:

    return(TRUE);
}


NTSTATUS
MRxDAVDereferenceNetRootContext(
    IN PWEBDAV_NET_ROOT DavNetRoot
    )
/*++

Routine Description:

    This routine dereferences the Webdav NetRoot instance and free it if the refcount reaches 0.
    
Arguments:

    DavNetRoot - The Webdav NetRoot.

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    if (DavNetRoot != NULL) {
        ULONG RefCount;

        RefCount = InterlockedDecrement(&DavNetRoot->RefCount);
        DavDbgTrace(DAV_TRACE_DAVNETROOT,
                    ("MRxDAVDereferenceNetRootContext %x %d\n",DavNetRoot,RefCount));

        if (RefCount == 0) {
            //
            // Free storage associated with all entries in the name caches.
            //
            RxNameCacheFinalize(&DavNetRoot->NameCacheCtlGFABasic);
            RxNameCacheFinalize(&DavNetRoot->NameCacheCtlGFAStandard);
            RxNameCacheFinalize(&DavNetRoot->NameCacheCtlFNF);
            
            //
            // Reset the Context so that no further reference can be made to this DavNetRoot
            //
            ASSERT(DavNetRoot->pRdbssNetRoot->Context == DavNetRoot);
            DavNetRoot->pRdbssNetRoot->Context = NULL;

            RxFreePool(DavNetRoot);
            DavDbgTrace(DAV_TRACE_DAVNETROOT,
                        ("MRxDav frees DavNetRoot %x\n",DavNetRoot));
        }
    }
    
    return STATUS_SUCCESS;
}

NTSTATUS
MRxDAVFinalizeNetRoot(
    IN PMRX_NET_ROOT pNetRoot,
    IN PBOOLEAN ForceDisconnect
    )
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - The Virtual NetRoot.

    ForceDisconnect - Disconnect is forced.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PWEBDAV_NET_ROOT DavNetRoot = (PWEBDAV_NET_ROOT)pNetRoot->Context;

    PAGED_CODE();

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering UMRxFinalizeNetRoot!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_CONTEXT,
                ("%ld: UMRxFinalizeNetRoot: pNetRoot = %08lx.\n", 
                 PsGetCurrentThreadId(), pNetRoot));
    
    DavDbgTrace(DAV_TRACE_DAVNETROOT,
                ("MRxDAVFinalizeNetRoot deref DavNetRoot %x %x\n",pNetRoot->Context,pNetRoot));
    
    MRxDAVDereferenceNetRootContext((PWEBDAV_NET_ROOT)pNetRoot->Context);

    return STATUS_SUCCESS;
}

VOID
MRxDAVExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:
    
    FilePathName - The filename that came in.
    
    SrvCall - The SrvCall strucutre created by RDBSS.
    
    NetRootName - Pointer to the netroot name.
    
    RestOfName - Pointer to the Rest of the name.

Return Value:

    none.

--*/
{
    UNICODE_STRING xRestOfName;
    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w) + length);
    PWCH wlow;

    PAGED_CODE();

    //
    // The netroot name starts after the SrvCall name.
    //
    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;

    //
    // Calculate the length of the NetRoot name.
    //
    for ( ; ; ) {
        if (w >= wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w != wlow) ){
#if ZZZ_MODE
            if (*(w - 1) == L'z') {
                w++;
                continue;
            }
#endif // if ZZZ_MODE
            break;
        }
        w++;
    }
    
    NetRootName->Length = NetRootName->MaximumLength = (USHORT)((PCHAR)w - (PCHAR)wlow);

    if (!RestOfName) {
        RestOfName = &xRestOfName;
    }
    
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVExtractNetRootName: FilePath = %wZ\n", 
                 PsGetCurrentThreadId(), FilePathName));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: MRxDAVExtractNetRootName: Srv = %wZ, Root = %wZ, "
                 "Rest = %wZ\n", PsGetCurrentThreadId(), 
                 SrvCall->pSrvCallName, NetRootName, RestOfName));

    return;
}


NTSTATUS
MRxDAVFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN ForceDisconnect
    )
/*++

Routine Description:

Arguments:

    pVNetRoot - The virtual net root which has to be finalized.

    ForceDisconnect - Disconnect is forced.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PMRX_SRV_CALL SrvCall = NULL;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = NULL;
    PWEBDAV_V_NET_ROOT DavVNetRoot = NULL;

    PAGED_CODE();
    
    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: Entering UMRxFinalizeVNetRoot!!!!\n",
                 PsGetCurrentThreadId()));

    DavDbgTrace(DAV_TRACE_DETAIL,
                ("%ld: UMRxFinalizeVNetRoot: NetRootName = %wZ\n", 
                 PsGetCurrentThreadId(), pVNetRoot->pNetRoot->pNetRootName));

    SrvCall = pVNetRoot->pNetRoot->pSrvCall;

    RxDeviceObject = SrvCall->RxDeviceObject;

    DavVNetRoot = MRxDAVGetVNetRootExtension(pVNetRoot);
    ASSERT(DavVNetRoot != NULL);

    //
    // If we created the SecurityClientContext, we need to delete it now. We 
    // don't need this when we go up to the usermode to finalize the VNetRoot
    // since we don't impersonate the client when doing this.
    //
    if (DavV