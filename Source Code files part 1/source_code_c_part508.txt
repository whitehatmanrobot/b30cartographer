 Name:

    base.h

Abstract:

    This include file defines the type and constant definitions that are
    shared by the client and server portions of the BASE portion of the
    Windows subsystem.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winbasep.h>
#include <string.h>
#include <stdarg.h>

//
// Define debugging flag as false if not defined already.
//

#ifndef DBG
#define DBG 0
#endif


//
// Define IF_DEBUG macro that can be used to enable debugging code that is
// optimized out if the debugging flag is false.
//

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

//
// Include Windows Subsystem common definitions
//

#include <winss.h>

//
// Include definitions for the runtime DLL shared between the client and
// server portions of the Base portion of the Windows subsystem
//

#include "basertl.h"

#define WIN32_SS_PIPE_FORMAT_STRING    "\\Device\\NamedPipe\\Win32Pipes.%08x.%08x"

typedef struct _BASE_STATIC_SERVER_DATA {
                UNICODE_STRING WindowsDirectory;
                UNICODE_STRING WindowsSystemDirectory;
                UNICODE_STRING NamedObjectDirectory;
                USHORT WindowsMajorVersion;
                USHORT WindowsMinorVersion;
                USHORT BuildNumber;
                WCHAR CSDVersion[ 128 ];
                SYSTEM_BASIC_INFORMATION SysInfo;
                SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;
                PINIFILE_MAPPING IniFileMapping;
                NLS_USER_INFO NlsUserInfo;
                BOOLEAN DefaultSeparateVDM;
                ULONG BaseRtlTag;
                ULONG LogicalDrives;
                UCHAR DriveTypes[ 32 ];
} BASE_STATIC_SERVER_DATA, *PBASE_STATIC_SERVER_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\advpext\util.cpp ===
#include "util.h"
#include "patchdownload.h"
#include "sdsutils.h"

extern "C"
{
#include "crc32.h"
}

#define CR           13
HANDLE g_hLogFile = NULL;
extern HINF g_hInf;
extern HINSTANCE g_hInstance;

struct LangID
{
    DWORD dwLangID;
    char szLanguage[3];
};

const LangID g_LangID [] = 
{
    {0x404, "TW"},   
    {0x804,  "CN"},
    {0x405, "CS"},
    {0x406, "DA"},
    {0x413, "NL"},
    {0x409, "EN"},
    {0x40B, "FI"},
    {0x40C, "FR"},
    {0x407, "DE"},
    {0x408, "EL"},
    {0x40E, "HU"},
    {0x410, "IT"},
    {0x411, "JA"},
    {0x412, "KO"},
    {0x414, "NO"},
    {0x415, "PL"},
    {0x416, "BR"},
    {0x816, "PT"},
    {0x419, "RU"},
    {0x424, "SL"},
    {0xC0A, "ES"},
    {0x41D, "SV"},
    {0x41E, "TH"},
    {0x41F, "TR"},
    {0x42A, "VI"},
    {0x41B, "SK"},
    {0x401, "AR"},
    {0x403, "CA"},
    {0x42D, "EU"},
    {0x40D, "HE"},
    {0x40F, "IS"},
    {-1, NULL}
};


extern PFSetupFindFirstLine              pfSetupFindFirstLine;
extern PFSetupGetStringField             pfSetupGetStringField;
extern PFSetupDecompressOrCopyFile       pfSetupDecompressOrCopyFile;


PVOID __fastcall MyVirtualAlloc(ULONG Size)    
{
    return VirtualAlloc( NULL, Size, MEM_COMMIT, PAGE_READWRITE );    
}


VOID __fastcall MyVirtualFree(PVOID Allocation)    
{
    VirtualFree( Allocation, 0, MEM_RELEASE );    
}


extern "C" HANDLE CreateSubAllocator(IN ULONG InitialCommitSize,  IN ULONG GrowthCommitSize)    
{
    PSUBALLOCATOR SubAllocator;
    ULONG InitialSize;
    ULONG GrowthSize;

    InitialSize = ROUNDUP2( InitialCommitSize, MINIMUM_VM_ALLOCATION );
    GrowthSize  = ROUNDUP2( GrowthCommitSize,  MINIMUM_VM_ALLOCATION );

    SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( InitialSize );

    //
    //  If can't allocate entire initial size, back off to minimum size.
    //  Very large initial requests sometimes cannot be allocated simply
    //  because there is not enough contiguous address space.
    //

    if ( SubAllocator == NULL ) 
    {
         SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( GrowthSize );
    }

    if ( SubAllocator == NULL ) 
    {
         SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( MINIMUM_VM_ALLOCATION );
    }

    if ( SubAllocator != NULL ) 
    {
        SubAllocator->NextAvailable = (PCHAR)SubAllocator + ROUNDUP2( sizeof( SUBALLOCATOR ), SUBALLOCATOR_ALIGNMENT );
        SubAllocator->LastAvailable = (PCHAR)SubAllocator + InitialSize;
        SubAllocator->VirtualList   = (PVOID*)SubAllocator;
        SubAllocator->GrowSize      = GrowthSize;
     }

    return (HANDLE) SubAllocator;    
}


extern "C" PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size)
{
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PCHAR NewVirtual;
    PCHAR Allocation;
    ULONG AllocSize;
    ULONG Available;
    ULONG GrowSize;

    ASSERT( Size < (ULONG)( ~(( SUBALLOCATOR_ALIGNMENT * 2 ) - 1 )));

    AllocSize = ROUNDUP2( Size, SUBALLOCATOR_ALIGNMENT );
    Available = SubAllocator->LastAvailable - SubAllocator->NextAvailable;

    if ( AllocSize <= Available ) 
    {
        Allocation = SubAllocator->NextAvailable;
        SubAllocator->NextAvailable = Allocation + AllocSize;
        return Allocation;
    }

    //
    //  Insufficient VM, so grow it.  Make sure we grow it enough to satisfy
    //  the allocation request in case the request is larger than the grow
    //  size specified in CreateSubAllocator.
    //


    GrowSize = SubAllocator->GrowSize;

    if ( GrowSize < ( AllocSize + SUBALLOCATOR_ALIGNMENT )) 
    {
        GrowSize = ROUNDUP2(( AllocSize + SUBALLOCATOR_ALIGNMENT ), MINIMUM_VM_ALLOCATION );
    }

    NewVirtual = (PCHAR)MyVirtualAlloc( GrowSize );

    //  If failed to alloc GrowSize VM, and the allocation could be satisfied
    //  with a minimum VM allocation, try allocating minimum VM to satisfy
    //  this request.
    //

    if (( NewVirtual == NULL ) && ( AllocSize <= ( MINIMUM_VM_ALLOCATION - SUBALLOCATOR_ALIGNMENT ))) 
    {
        GrowSize = MINIMUM_VM_ALLOCATION;
        NewVirtual = (PCHAR)MyVirtualAlloc( GrowSize );
    }

    if ( NewVirtual != NULL ) 
    {

        //  Set LastAvailable to end of new VM block.
        SubAllocator->LastAvailable = NewVirtual + GrowSize;

        //  Link new VM into list of VM allocations.

        *(PVOID*)NewVirtual = SubAllocator->VirtualList;
        SubAllocator->VirtualList = (PVOID*)NewVirtual;

        //  Requested allocation comes next.
        Allocation = NewVirtual + SUBALLOCATOR_ALIGNMENT;

        //  Then set the NextAvailable for what's remaining.

        SubAllocator->NextAvailable = Allocation + AllocSize;

        //  And return the allocation.

        return Allocation;        
    }

    //  Could not allocate enough VM to satisfy request.
    return NULL;
}


extern "C"  VOID DestroySubAllocator(IN HANDLE hAllocator)    
{
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PVOID VirtualBlock = SubAllocator->VirtualList;
    PVOID NextVirtualBlock;

    do  
    {
        NextVirtualBlock = *(PVOID*)VirtualBlock;
        MyVirtualFree( VirtualBlock );
        VirtualBlock = NextVirtualBlock;

    }while (VirtualBlock != NULL);
}


HLOCAL ResizeBuffer(IN HLOCAL BufferHandle, IN DWORD Size,  IN BOOL Moveable)
{
    if (BufferHandle == NULL) 
    {        
        if (Size != 0) 
        {
            BufferHandle = LocalAlloc(Moveable ? LMEM_MOVEABLE : LMEM_FIXED, Size);
        }

    } 
    else if (Size == 0) 
    {
        BufferHandle = LocalFree(BufferHandle);
        BufferHandle=NULL;

    } 
    else 
    {
        HLOCAL TempBufferHandle = LocalReAlloc(BufferHandle, Size, LMEM_MOVEABLE);
		if ( TempBufferHandle )
		{
			BufferHandle = TempBufferHandle;
		}
		else
		{
			LocalFree(BufferHandle);
			BufferHandle = NULL;
		}
    }

    return BufferHandle;
}

VOID MyLowercase(IN OUT LPSTR String)
{
    LPSTR p;

    for ( p = String; *p; p++ ) 
    {
        if (( *p >= 'A' ) && ( *p <= 'Z' )) 
        {
            *p |= 0x20;
        }
    }
}

void InitLogFile()
{
    char szLogFileName[MAX_PATH], szTmp[MAX_PATH];
    HKEY hKey;
    BYTE cbData[MAX_PATH];
    DWORD dwSize = sizeof(cbData);

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Advanced INF Setup", 0, 
                                                KEY_ALL_ACCESS, &hKey))
    {
        return;
    }

    if(ERROR_SUCCESS != RegQueryValueEx(hKey, "AdvpextLog", 0, 0, cbData, &dwSize) ||
       lstrcmpi((char*)cbData, "yes"))
    {
        RegCloseKey(hKey);
        return;
    }

    RegCloseKey(hKey);
    
    if (GetWindowsDirectory(szTmp, sizeof(szTmp)))
    {
        wsprintf(szLogFileName, "%s\\%s", szTmp, LOGFILENAME);
        if (GetFileAttributes(szLogFileName) != 0xFFFFFFFF)
        {
            // Make a backup of the current log file
            lstrcpyn(szTmp, szLogFileName, lstrlen(szLogFileName) - 2 );    // don't copy extension
            lstrcat(szTmp, "BAK");
            SetFileAttributes(szTmp, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szTmp);
            MoveFile(szLogFileName, szTmp);
        }

        g_hLogFile = CreateFile(szLogFileName, GENERIC_WRITE|GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0,0);
    }

}


void WriteToLog(char *pszFormatString, ...)
{
    va_list args;
    char *pszFullErrMsg = NULL;
    DWORD dwBytesWritten;

    if (g_hLogFile && g_hLogFile != INVALID_HANDLE_VALUE)
    {
        va_start(args, pszFormatString);
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                      (LPCVOID) pszFormatString, 0, 0, (LPTSTR) &pszFullErrMsg, 0, &args);
        if (pszFullErrMsg)
        {
            WriteFile(g_hLogFile, pszFullErrMsg, lstrlen(pszFullErrMsg), &dwBytesWritten, NULL);
            LocalFree(pszFullErrMsg);
        }
    }
}

DWORD GenerateUniqueClientId()
{
    CHAR  MachineName[MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD MachineNameLength;
    DWORD UniqueId;

    MachineNameLength = sizeof( MachineName );
    GetComputerName( MachineName, &MachineNameLength );

    do
    {
        UniqueId = GetTickCount();
        UniqueId = Crc32( UniqueId, MachineName, MachineNameLength );
        UniqueId = UniqueId & 0xFFFFFFF0;

    }while ( UniqueId == 0 );

    return UniqueId;
}

BOOL MySetupDecompressOrCopyFile(IN LPCSTR SourceFile, IN LPCSTR TargetFile)
{
    DWORD ErrorCode = pfSetupDecompressOrCopyFile( SourceFile, TargetFile, 0 );

    if ( ErrorCode != NO_ERROR ) {
        SetLastError( ErrorCode );
        return FALSE;
        }
    else {
        SetFileAttributes( TargetFile, FILE_ATTRIBUTE_NORMAL );
        return TRUE;
        }
}

ULONG __fastcall TextToUnsignedNum(IN LPCSTR Text)    
{
    LPCSTR p = Text;
    ULONG  n = 0;

    //
    //  Very simplistic conversion stops at first non digit character, does
    //  not require null-terminated string, and does not skip any whitespace
    //  or commas.
    //

    while (( *p >= '0' ) && ( *p <= '9' )) {
        n = ( n * 10 ) + ( *p++ - '0' );
        }

    return n;    
}

LPSTR CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath   // can be same as ParentPath if want to append
    )
    {
    ULONG ParentLength = strlen( ParentPath );
    LPSTR p;

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    strcpy( p, ChildPath );

    return TargetPath;
    }

BOOL FixTimeStampOnCompressedFile(IN LPCSTR FileName)    
{

    //
    //  NT4 setupapi uses timestamp on compressed file to set on
    //  the target decompressed file.  With streaming download, we
    //  lose the timestamp on the file.  But, the correct timestamp
    //  lives inside the compressed file, so we'll open the file
    //  to see if it is a diamond compressed file and if so,
    //  extract the timestamp and set it on the compressed file.
    //  Then, when setupapi expands the compressed file, it will
    //  use that timestamp on the expanded file.
    //
    //  A better fix is probably to tunnel the timestamp in the
    //  pstream protocol, but too late to change that at this
    //  point.
    //

    FILETIME LocalFileTime;
    FILETIME UtcFileTime;
    BOOL     TimeSuccess;
    BOOL     MapSuccess;
    HANDLE   hSourceFile;
    PUCHAR   pSourceFileMapped;
    DWORD    dwSourceFileSize;
    DWORD    dwOffset;
    USHORT   DosDate;
    USHORT   DosTime;
    PUCHAR   p;

    TimeSuccess = FALSE;

    MapSuccess = MyMapViewOfFile(FileName, &dwSourceFileSize, &hSourceFile, (void**)&pSourceFileMapped);

    if ( MapSuccess ) 
    {

        __try {

            p = pSourceFileMapped;

            if (( *(DWORD*)( p ) == 'FCSM' ) &&     // "MSCF"
                ( *(BYTE *)( p + 24 ) == 3 ) &&     // minor version
                ( *(BYTE *)( p + 25 ) == 1 ) &&     // major version
                ( *(WORD *)( p + 26 ) == 1 ) &&     // 1 folder
                ( *(WORD *)( p + 28 ) == 1 )) {     // 1 file

                dwOffset = *(DWORD*)( p + 16 );

                if (( dwOffset + 16 ) < dwSourceFileSize ) {

                    DosDate = *(UNALIGNED WORD*)( p + dwOffset + 10 );
                    DosTime = *(UNALIGNED WORD*)( p + dwOffset + 12 );

                    if ( DosDateTimeToFileTime( DosDate, DosTime, &LocalFileTime ) &&
                         LocalFileTimeToFileTime( &LocalFileTime, &UtcFileTime )) {

                        TimeSuccess = TRUE;
                        }
                    }
                }
            }

        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            
        }

        MyUnmapViewOfFile( hSourceFile, pSourceFileMapped );        
    }

    if ( TimeSuccess ) {

        hSourceFile = CreateFile(
                          FileName,
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL
                          );

        if ( hSourceFile != INVALID_HANDLE_VALUE ) {

            if ( ! SetFileTime( hSourceFile, &UtcFileTime, &UtcFileTime, &UtcFileTime )) {
                TimeSuccess = FALSE;
                }

            CloseHandle( hSourceFile );
            }
        }

    return TimeSuccess;
    }

BOOL Assert(LPCSTR szText, LPCSTR szFile, DWORD  dwLine)    
{
    CHAR Buffer[ 256 ];
    wsprintf( Buffer, "ASSERT( %s ) FAILED, %s (%d)\n", szText, szFile, dwLine );
    OutputDebugString( Buffer );
    DebugBreak();
    return FALSE;    
}

BOOL MyMapViewOfFileByHandle(IN  HANDLE  FileHandle, OUT ULONG  *FileSize, OUT PVOID  *MapBase)    
{
    ULONG  InternalFileSize;
    ULONG  InternalFileSizeHigh;
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalFileSize = GetFileSize( FileHandle, &InternalFileSizeHigh );

    if ( InternalFileSizeHigh != 0 ) 
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    if ( InternalFileSize == 0 ) 
    {
        *MapBase  = NULL;
        *FileSize = 0;
        return TRUE;
    }

    if ( InternalFileSize != 0xFFFFFFFF ) 
    {

        InternalMapHandle = CreateFileMapping(
                                FileHandle,
                                NULL,
                                PAGE_WRITECOPY,
                                0,
                                0,
                                NULL
                                );

        if ( InternalMapHandle != NULL ) 
        {

            InternalMapBase = MapViewOfFile(InternalMapHandle, FILE_MAP_COPY, 0, 0, 0);
            CloseHandle( InternalMapHandle );

            if ( InternalMapBase != NULL ) 
            {
                DWORD dw = ROUNDUP2(InternalFileSize, 64);

                if(dw != InternalFileSize)
                {
                    ZeroMemory((PBYTE)InternalMapBase + InternalFileSize, dw - InternalFileSize);
                }

                *MapBase  = InternalMapBase;
                *FileSize = InternalFileSize;

                return TRUE;                
            }            
        }        
    }

    return FALSE;    
}


BOOL MyMapViewOfFile(IN  LPCSTR  FileName, OUT ULONG  *FileSize, OUT HANDLE *FileHandle, OUT PVOID  *MapBase)
{
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) 
    {

        Success = MyMapViewOfFileByHandle(InternalFileHandle, FileSize, MapBase);

        if ( Success ) 
        {

            *FileHandle = InternalFileHandle;
            return TRUE;
        }

        CloseHandle( InternalFileHandle );
    }

    return FALSE;
}

VOID MyUnmapViewOfFile(IN HANDLE FileHandle, IN PVOID  MapBase )
{
    ULONG LastError = GetLastError();
    UnmapViewOfFile( MapBase );
    CloseHandle( FileHandle );
    SetLastError( LastError );
}

VOID __fastcall ConvertToCompressedFileName(IN OUT LPSTR FileName)
{
    ULONG NameLength = strlen( FileName );
    ULONG DotIndex   = NameLength;

    while (( DotIndex > 0 ) && ( FileName[ --DotIndex ] != '.' )) {
        if ( FileName[ DotIndex ] == '\\' ) {   // end of filename part of path
            DotIndex = 0;                       // name has no extension
            break;
            }
        }

    if ( DotIndex > 0 ) {                       // name has an extension
        if (( NameLength - DotIndex ) <= 3 ) {  // extension less than 3 chars
            FileName[ NameLength++ ] = '_';     // append '_' to extension
            FileName[ NameLength   ] = 0;       // terminate
            }
        else {                                  // extension more than 3 chars
            FileName[ NameLength - 1 ] = '_';   // replace last char with '_'
            }
        }
    else {                                      // name has no extension
        FileName[ NameLength++ ] = '.';         // append '.'
        FileName[ NameLength++ ] = '_';         // append '_'
        FileName[ NameLength   ] = 0;           // terminate
        }
}


LPTSTR __fastcall MySubAllocStrDup(IN HANDLE SubAllocator, IN LPCSTR String)
{
    ULONG Length = lstrlen( String );
    LPTSTR Buffer = (LPTSTR)SubAllocate( SubAllocator, Length + 1 );

    if ( Buffer ) 
    {
        memcpy( Buffer, String, Length );   // no need to copy NULL terminator        
    }

    return Buffer;    
}

//
// Copied from Windows 95 unistal.exe cfg.c function CfgGetField
BOOL GetFieldString(LPSTR lpszLine, int iField, LPSTR lpszField, int cbSize)
{
    int cbField;
    LPSTR lpszChar, lpszEnd;
    // Find the field we are looking for

    lpszChar = lpszLine;

    // Each time we see a separator, decrement iField
    while (iField > 0 && (BYTE)*lpszChar > CR) {

        if (*lpszChar == '=' || *lpszChar == ',' || *lpszChar == ' ' ) {
            iField--;
            while (*lpszChar == '=' || *lpszChar== ',' || *lpszChar == ' ' && (BYTE)*lpszChar > 13)
                lpszChar++;
        }
        else
            lpszChar++;
    }

    // If we still have fields remaining then something went wrong
    if (iField)
        return FALSE;

    // Now find the end of this field
    lpszEnd = lpszChar;
    while (*lpszEnd != '=' && *lpszEnd != ',' && *lpszEnd != ' ' && (BYTE)*lpszEnd > CR)
        lpszEnd++;

    // Find the length of this field - make sure it'll fit in the buffer
    cbField = (int)((lpszEnd - lpszChar) + 1);

    if (cbField > cbSize) {     // I return an error if the requested
      //cbField = cbSize;       // data won't fit, rather than truncating
        return FALSE;           // it at some random point! -JTP
    }

    // Note that the C runtime treats cbField as the number of characters
    // to copy from the source, and if that doesn't happen to transfer a NULL,
    // too bad.  The Windows implementation of _lstrcpyn treats cbField as
    // the number of characters that can be stored in the destination, and
    // always copies a NULL (even if it means copying only cbField-1 characters
    // from the source).

    // The C runtime also pads the destination with NULLs if a NULL in the
    // source is found before cbField is exhausted.  _lstrcpyn essentially quits
    // after copying a NULL.


    lstrcpyn(lpszField, lpszChar, cbField);

    return TRUE;
}

#define NUM_VERSION_NUM 4
void ConvertVersionStrToDwords(LPSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
    WORD rwVer[NUM_VERSION_NUM];

    for(int i = 0; i < NUM_VERSION_NUM; i++)
        rwVer[i] = 0;

    for(i = 0; i < NUM_VERSION_NUM && pszVer; i++)
    {
        rwVer[i] = (WORD) StrToInt(pszVer);
        pszVer = ScanForChar(pszVer, '.', lstrlen(pszVer));
        if (pszVer)
            pszVer++;
    }

   *pdwVer = (rwVer[0]<< 16) + rwVer[1];
   *pdwBuild = (rwVer[2] << 16) + rwVer[3];

}

LPSTR FindChar(LPSTR pszStr, char ch)
{
   while( *pszStr != 0 && *pszStr != ch )
      pszStr++;
   return pszStr;
}

DWORD GetStringField(LPSTR szStr, UINT uField, LPSTR szBuf, UINT cBufSize)
{
   LPSTR pszBegin = szStr;
   LPSTR pszEnd;
   UINT i = 0;
   DWORD dwToCopy;

   if(cBufSize == 0)
       return 0;

   szBuf[0] = 0;

   if(szStr == NULL)
      return 0;

   while(*pszBegin != 0 && i < uField)
   {
      pszBegin = FindChar(pszBegin, ',');
      if(*pszBegin != 0)
         pszBegin++;
      i++;
   }

   // we reached end of string, no field
   if(*pszBegin == 0)
   {
      return 0;
   }


   pszEnd = FindChar(pszBegin, ',');
   while(pszBegin <= pszEnd && *pszBegin == ' ')  
      pszBegin++;

   while(pszEnd > pszBegin && *(pszEnd - 1) == ' ')
      pszEnd--;
   
   if(pszEnd > (pszBegin + 1) && *pszBegin == '"' && *(pszEnd-1) == '"')
   {
      pszBegin++;
      pszEnd--;
   }

   dwToCopy = pszEnd - pszBegin + 1;
   
   if(dwToCopy > cBufSize)
      dwToCopy = cBufSize;

   lstrcpynA(szBuf, pszBegin, dwToCopy);
   
   return dwToCopy - 1;
}

BOOL GetHashidFromINF(LPCTSTR lpFileName, LPTSTR lpszHash, DWORD dwSize)
{
    INFCONTEXT InfContext;

    if (pfSetupFindFirstLine(g_hInf, "SourceDisksFiles", lpFileName, &InfContext ))
    {
        if (pfSetupGetStringField(&InfContext, 5, lpszHash, dwSize, NULL )) 
        {
            return TRUE;
        }                
    }

    return FALSE;
}


#ifdef _M_IX86

//
//  Stupid x86 compiler doesn't have an intrinsic memchr, so we'll do our own.
//

#pragma warning( disable: 4035 )    // no return value

LPSTR ScanForChar(
    IN LPSTR Buffer,
    IN CHAR  SearchFor,
    IN ULONG MaxLength
    )
{
    __asm {

        mov     edi, Buffer         // pointer for scasb in edi
        mov     al,  SearchFor      // looking for this char
        mov     ecx, MaxLength      // don't scan past this
        repne   scasb               // find the char
        lea     eax, [edi-1]        // edi points one past the found char
        jz      RETURNIT            // if didn't find it,
        xor     eax, eax            // return NULL

RETURNIT:

        }
}

#pragma warning( default: 4035 )    // no return value

#else   // ! _M_IX86

LPSTR ScanForChar(IN LPSTR Buffer, IN CHAR  SearchFor, IN ULONG MaxLength)    
{
    return memchr( Buffer, SearchFor, MaxLength );
}

#endif  // ! _M_IX86


PCHAR ScanForSequence(IN PCHAR Buffer, IN ULONG BufferLength, IN PCHAR Sequence, IN ULONG SequenceLength)    
{
    if ( BufferLength >= SequenceLength ) 
    {

        PCHAR ScanEnd = Buffer + ( BufferLength - SequenceLength ) + 1;
        PCHAR ScanPtr = Buffer;

        while ( ScanPtr < ScanEnd ) 
        {

            ScanPtr = ScanForChar( ScanPtr, *Sequence, ScanEnd - ScanPtr );

            if ( ScanPtr == NULL ) 
            {
                return NULL;
            }

            if ( memcmp( ScanPtr, Sequence, SequenceLength ) == 0 ) 
            {
                return ScanPtr;
            }

            ++ScanPtr;
        }
    }

    return NULL;
}


//From shlwapi....
#define FAST_CharNext(p)    CharNext(p)
#define FILENAME_SEPARATOR       '\\'
#define CH_WHACK TEXT(FILENAME_SEPARATOR)


LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT = pPath;
    
    if (pPath)
    {
        for ( ; *pPath; pPath = FAST_CharNext(pPath))
        {
            if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
                && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
                pT = pPath + 1;
        }
    }

    return (LPTSTR)pT;   // const -> non const
}

LPTSTR PathFindExtension(LPCTSTR pszPath)
{
    LPCTSTR pszDot = NULL;

    if (pszPath)
    {
        for (; *pszPath; pszPath = FAST_CharNext(pszPath))
        {
            switch (*pszPath) {
            case TEXT('.'):
                pszDot = pszPath;         // remember the last dot
                break;
            case CH_WHACK:
            case TEXT(' '):         // extensions can't have spaces
                pszDot = NULL;       // forget last dot, it was in a directory
                break;
            }
        }
    }

    // if we found the extension, return ptr to the dot, else
    // ptr to end of the string (NULL extension) (cast->non const)
    return pszDot ? (LPTSTR)pszDot : (LPTSTR)pszPath;
}

LPSTR StrDup(LPCSTR psz)
{
    LPSTR pszRet = (LPSTR)LocalAlloc(LPTR, (lstrlenA(psz) + 1) * sizeof(*pszRet));
    if (pszRet) 
    {
        lstrcpyA(pszRet, psz);
    }
    return pszRet;
}


DWORD MyFileSize( PCSTR pszFile )
{
    HFILE hFile;
    OFSTRUCT ofStru;
    DWORD dwSize = 0;

    if ( *pszFile == 0 )
        return 0;

    hFile = OpenFile( pszFile, &ofStru, OF_READ );
    if ( hFile != HFILE_ERROR )
    {
        dwSize = GetFileSize( (HANDLE)hFile, NULL );
        _lclose( hFile );
    }

    return dwSize;
}

void GetLanguageString(LPTSTR lpszLang)
{
    char szTmp[MAX_PATH];
    DWORD dwLang, dwCharSet;

    //default to EN
    lstrcpy(lpszLang, "EN");
    GetModuleFileName( g_hInstance, szTmp, sizeof(szTmp) );
    MyGetVersionFromFile(szTmp, &dwLang, &dwCharSet, FALSE);

    for(int i = 0; g_LangID[i].dwLangID != -1; i++)
    {
        if(g_LangID[i].dwLangID == dwLang)
        {
            lstrcpy(lpszLang, g_LangID[i].szLanguage);
            break;
        }
    }

}

BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent;
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xNew, yNew;
	HDC     hdc;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the display limits
	hdc = GetDC (hwndChild);
	wScreen = GetDeviceCaps (hdc, HORZRES);
	hScreen = GetDeviceCaps (hdc, VERTRES);
	ReleaseDC (hwndChild, hdc);

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < 0) {
		xNew = 0;
	} else if ((xNew+wChild) > wScreen) {
		xNew = wScreen - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < 0) {
		yNew = 0;
	} else if ((yNew+hChild) > hScreen) {
		yNew = hScreen - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL,
		xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\basertl.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basertl.h

Abstract:

    This is the main include file for the runtime routines that are shared
    by the client and server sides of the Windows Base API implementation.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

#if DBG
#undef RTLHEAP_TRACE_CALLS
#else
#undef RTLHEAP_TRACE_CALLS
#endif

NTSTATUS
BaseRtlCreateAtomTable(
    IN ULONG NumberOfBuckets,
    IN ULONG MaxAtomTableSize,
    OUT PVOID *AtomTableHandle
    );

NTSTATUS
BaseRtlDestroyAtomTable(
    IN PVOID AtomTableHandle
    );

NTSTATUS
BaseRtlAddAtomToAtomTable(
    IN PVOID AtomTableHandle,
    IN PUNICODE_STRING AtomName,
    IN PULONG AtomValue OPTIONAL,
    OUT PULONG Atom OPTIONAL
    );

NTSTATUS
BaseRtlLookupAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN PUNICODE_STRING AtomName,
    OUT PULONG AtomValue OPTIONAL,
    OUT PULONG Atom OPTIONAL
    );

NTSTATUS
BaseRtlSetAtomValueInAtomTable(
    IN PVOID AtomTableHandle,
    IN PUNICODE_STRING AtomName,
    IN ULONG AtomValue
    );

NTSTATUS
BaseRtlDeleteAtomFromAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG Atom
    );

NTSTATUS
BaseRtlQueryAtomInAtomTable(
    IN PVOID AtomTableHandle,
    IN ULONG Atom,
    IN OUT PUNICODE_STRING AtomName OPTIONAL,
    OUT PULONG AtomValue OPTIONAL,
    OUT PULONG AtomUsage OPTIONAL
    );

typedef struct _BASE_HANDLE_TABLE_ENTRY {
    USHORT LockCount;
    USHORT Flags;
    union {
        struct _BASE_HANDLE_TABLE_ENTRY *Next;      // Free handle
        PVOID Object;                               // Allocated handle
        ULONG Size;                                 // Handle to discarded obj.
    } u;
} BASE_HANDLE_TABLE_ENTRY, *PBASE_HANDLE_TABLE_ENTRY;

#define BASE_HANDLE_FREE        (USHORT)0x0001
#define BASE_HANDLE_MOVEABLE    (USHORT)0x0002
#define BASE_HANDLE_DISCARDABLE (USHORT)0x0004
#define BASE_HANDLE_DISCARDED   (USHORT)0x0008
#define BASE_HANDLE_SHARED      (USHORT)0x8000

//
// Handles are 32-bit pointers to the u.Object field of a
// BASE_HANDLE_TABLE_ENTRY.  Since this field is 4 bytes into the
// structure and the structures are always on 8 byte boundaries, we can
// test the 0x4 bit to see if it is a handle.
//

#define BASE_HANDLE_MARK_BIT (ULONG)0x00000004
#define BASE_HEAP_FLAG_MOVEABLE  HEAP_SETTABLE_USER_FLAG1
#define BASE_HEAP_FLAG_DDESHARE  HEAP_SETTABLE_USER_FLAG2

typedef struct _BASE_HANDLE_TABLE {
    ULONG MaximumNumberOfHandles;
    PBASE_HANDLE_TABLE_ENTRY FreeHandles;
    PBASE_HANDLE_TABLE_ENTRY CommittedHandles;
    PBASE_HANDLE_TABLE_ENTRY UnusedCommittedHandles;
    PBASE_HANDLE_TABLE_ENTRY UnCommittedHandles;
    PBASE_HANDLE_TABLE_ENTRY MaxReservedHandles;
} BASE_HANDLE_TABLE, *PBASE_HANDLE_TABLE;

NTSTATUS
BaseRtlInitializeHandleTable(
    IN ULONG MaximumNumberOfHandles,
    OUT PBASE_HANDLE_TABLE HandleTable
    );

NTSTATUS
BaseRtlDestroyHandleTable(
    IN OUT PBASE_HANDLE_TABLE HandleTable
    );

PBASE_HANDLE_TABLE_ENTRY
BaseRtlAllocateHandle(
    IN PBASE_HANDLE_TABLE HandleTable
    );

BOOLEAN
BaseRtlFreeHandle(
    IN PBASE_HANDLE_TABLE HandleTable,
    IN PBASE_HANDLE_TABLE_ENTRY Handle
    );


//
// These structures are kept in the global shared memory section created
// in the server and mapped readonly into each client address space when
// they connect to the server.
//

typedef struct _INIFILE_MAPPING_TARGET {
    struct _INIFILE_MAPPING_TARGET *Next;
    UNICODE_STRING RegistryPath;
} INIFILE_MAPPING_TARGET, *PINIFILE_MAPPING_TARGET;

typedef struct _INIFILE_MAPPING_VARNAME {
    struct _INIFILE_MAPPING_VARNAME *Next;
    UNICODE_STRING Name;
    ULONG MappingFlags;
    PINIFILE_MAPPING_TARGET MappingTarget;
} INIFILE_MAPPING_VARNAME, *PINIFILE_MAPPING_VARNAME;

#define INIFILE_MAPPING_WRITE_TO_INIFILE_TOO    0x00000001
#define INIFILE_MAPPING_INIT_FROM_INIFILE       0x00000002
#define INIFILE_MAPPING_READ_FROM_REGISTRY_ONLY 0x00000004
#define INIFILE_MAPPING_APPEND_BASE_NAME        0x10000000
#define INIFILE_MAPPING_APPEND_APPLICATION_NAME 0x20000000
#define INIFILE_MAPPING_SOFTWARE_RELATIVE       0x40000000
#define INIFILE_MAPPING_USER_RELATIVE           0x80000000

typedef struct _INIFILE_MAPPING_APPNAME {
    struct _INIFILE_MAPPING_APPNAME *Next;
    UNICODE_STRING Name;
    PINIFILE_MAPPING_VARNAME VariableNames;
    PINIFILE_MAPPING_VARNAME DefaultVarNameMapping;
} INIFILE_MAPPING_APPNAME, *PINIFILE_MAPPING_APPNAME;

typedef struct _INIFILE_MAPPING_FILENAME {
    struct _INIFILE_MAPPING_FILENAME *Next;
    UNICODE_STRING Name;
    PINIFILE_MAPPING_APPNAME ApplicationNames;
    PINIFILE_MAPPING_APPNAME DefaultAppNameMapping;
} INIFILE_MAPPING_FILENAME, *PINIFILE_MAPPING_FILENAME;


typedef struct _INIFILE_MAPPING {
    PINIFILE_MAPPING_FILENAME FileNames;
    PINIFILE_MAPPING_FILENAME DefaultFileNameMapping;
    PINIFILE_MAPPING_FILENAME WinIniFileMapping;
    ULONG Reserved;
} INIFILE_MAPPING, *PINIFILE_MAPPING;



//
// NLS Information.
//

#define NLS_INVALID_INFO_CHAR  0xffff       /* marks cache string as invalid */

#define MAX_REG_VAL_SIZE       80           /* max size of registry value */

typedef struct _NLS_USER_INFO {
    WCHAR sAbbrevLangName[MAX_REG_VAL_SIZE];
    WCHAR iCountry[MAX_REG_VAL_SIZE];
    WCHAR sCountry[MAX_REG_VAL_SIZE];
    WCHAR sList[MAX_REG_VAL_SIZE];
    WCHAR iMeasure[MAX_REG_VAL_SIZE];
    WCHAR sDecimal[MAX_REG_VAL_SIZE];
    WCHAR sThousand[MAX_REG_VAL_SIZE];
    WCHAR sGrouping[MAX_REG_VAL_SIZE];
    WCHAR iDigits[MAX_REG_VAL_SIZE];
    WCHAR iLZero[MAX_REG_VAL_SIZE];
    WCHAR iNegNumber[MAX_REG_VAL_SIZE];
    WCHAR sCurrency[MAX_REG_VAL_SIZE];
    WCHAR sMonDecSep[MAX_REG_VAL_SIZE];
    WCHAR sMonThouSep[MAX_REG_VAL_SIZE];
    WCHAR sMonGrouping[MAX_REG_VAL_SIZE];
    WCHAR iCurrDigits[MAX_REG_VAL_SIZE];
    WCHAR iCurrency[MAX_REG_VAL_SIZE];
    WCHAR iNegCurr[MAX_REG_VAL_SIZE];
    WCHAR sPosSign[MAX_REG_VAL_SIZE];
    WCHAR sNegSign[MAX_REG_VAL_SIZE];
    WCHAR sTimeFormat[MAX_REG_VAL_SIZE];
    WCHAR sTime[MAX_REG_VAL_SIZE];
    WCHAR iTime[MAX_REG_VAL_SIZE];
    WCHAR iTLZero[MAX_REG_VAL_SIZE];
    WCHAR iTimeMarkPosn[MAX_REG_VAL_SIZE];
    WCHAR s1159[MAX_REG_VAL_SIZE];
    WCHAR s2359[MAX_REG_VAL_SIZE];
    WCHAR sShortDate[MAX_REG_VAL_SIZE];
    WCHAR sDate[MAX_REG_VAL_SIZE];
    WCHAR iDate[MAX_REG_VAL_SIZE];
    WCHAR sLongDate[MAX_REG_VAL_SIZE];
    WCHAR iCalType[MAX_REG_VAL_SIZE];
    WCHAR iFirstDay[MAX_REG_VAL_SIZE];
    WCHAR iFirstWeek[MAX_REG_VAL_SIZE];
    WCHAR sLocale[MAX_REG_VAL_SIZE];
    LCID  UserLocaleId;
    BOOL  fCacheValid;
} NLS_USER_INFO, *PNLS_USER_INFO;


BOOLEAN
BaseRtlInitialize(
    PVOID DllHandle,
    PVOID Heap,
    ULONG TagBase
    );

ULONG BaseRtlTag;
PVOID BaseRtlHeap;

#define MAKE_RTL_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseRtlTag, t ))

#define ATOM_TAG 0

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\basevdm.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basevdm.h

Abstract:

    This module contains private function prototypes
    and types for vdm support.

Author:

    Sudeep Bharati (sudeepb) 15-Sep-1991

Revision History:

--*/

#define ROUND_UP(n,size)	(((ULONG)(n) + (size - 1)) & ~(size - 1))

// Update VDM entry indexes

#define UPDATE_VDM_UNDO_CREATION    0
#define UPDATE_VDM_PROCESS_HANDLE   1
#define UPDATE_VDM_HOOKED_CTRLC     2


// Undo VDM Creation States

#define VDM_PARTIALLY_CREATED	    1
#define VDM_FULLY_CREATED	    2
#define VDM_BEING_REUSED	    4
#define VDM_CREATION_SUCCESSFUL     8

// Defines for BinaryType

#define BINARY_TYPE_DOS 	    0x10
#define BINARY_TYPE_WIN16	    0x20
#define BINARY_SUBTYPE_MASK	    0xF
#define BINARY_TYPE_DOS_EXE	    01
#define BINARY_TYPE_DOS_COM	    02
#define BINARY_TYPE_DOS_PIF	    03

// Defines for VDMState

#define VDM_NOT_PRESENT 	    1
#define VDM_PRESENT_NOT_READY	    2
#define VDM_PRESENT_AND_READY	    4

#define VDM_STATE_MASK		    7


#define EXIT_VDM		    1
#define EXIT_VDM_NOTIFICATION	    2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\basemsg.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basemsg.h

Abstract:

    This include file defines the message formats used to communicate
    between the client and server portions of the BASE portion of the
    Windows subsystem.

Author:

    Steve Wood (stevewo) 25-Oct-1990

Revision History:

--*/

//
// This structure is filled in by the client prior to connecting to the BASESRV
// DLL in the Windows subsystem server.  The server DLL will fill in the OUT
// fields if prior to accepting the connection.
//

typedef struct _BASESRV_API_CONNECTINFO {
    IN ULONG ExpectedVersion;
    OUT HANDLE DefaultObjectDirectory;
    OUT ULONG WindowsVersion;
    OUT ULONG CurrentVersion;
    OUT ULONG DebugFlags;
    OUT WCHAR WindowsDirectory[ MAX_PATH ];
    OUT WCHAR WindowsSystemDirectory[ MAX_PATH ];
} BASESRV_API_CONNECTINFO, *PBASESRV_API_CONNECTINFO;

#define BASESRV_VERSION 0x10000

//
// Message format for messages sent from the client to the server
//

typedef enum _BASESRV_API_NUMBER {
    BasepGlobalAddAtom = BASESRV_FIRST_API_NUMBER,
    BasepGlobalFindAtom,
    BasepGlobalDeleteAtom,
    BasepGlobalGetAtomName,
    BasepCreateProcess,
    BasepCreateThread,
    BasepGetTempFile,
    BasepExitProcess,
    BasepDebugProcess,
    BasepCheckVDM,
    BasepUpdateVDMEntry,
    BasepGetNextVDMCommand,
    BasepExitVDM,
    BasepIsFirstVDM,
    BasepGetVDMExitCode,
    BasepSetReenterCount,
    BasepSetProcessShutdownParam,
    BasepGetProcessShutdownParam,
    BasepNlsSetUserInfo,
    BasepNlsSetMultipleUserInfo,
    BasepNlsCreateSortSection,
    BasepNlsPreserveSection,
    BasepDefineDosDevice,
    BasepSetVDMCurDirs,
    BasepGetVDMCurDirs,
    BasepBatNotification,
    BasepRegisterWowExec,
    BasepSoundSentryNotification,
    BasepRefreshIniFileMapping,
    BasepRefreshDriveType,
#ifdef NTUSERK
    BasepDestroyGlobalAtomTable,
#endif
    BasepMaxApiNumber
} BASESRV_API_NUMBER, *PBASESRV_API_NUMBER;

typedef struct _BASE_NLS_SET_USER_INFO_MSG {
    LPWSTR pValue;
    LPWSTR pCacheString;
    LPWSTR pData;
    ULONG DataLength;
} BASE_NLS_SET_USER_INFO_MSG, *PBASE_NLS_SET_USER_INFO_MSG;

typedef struct _BASE_NLS_SET_MULTIPLE_USER_INFO_MSG {
    ULONG Flags;
    ULONG DataLength;
    LPWSTR pPicture;
    LPWSTR pSeparator;
    LPWSTR pOrder;
    LPWSTR pTLZero;
    LPWSTR pTimeMarkPosn;
} BASE_NLS_SET_MULTIPLE_USER_INFO_MSG, *PBASE_NLS_SET_MULTIPLE_USER_INFO_MSG;

typedef struct _BASE_NLS_CREATE_SORT_SECTION_MSG {
    UNICODE_STRING SectionName;
    HANDLE hNewSection;
    LARGE_INTEGER SectionSize;
} BASE_NLS_CREATE_SORT_SECTION_MSG, *PBASE_NLS_CREATE_SORT_SECTION_MSG;

typedef struct _BASE_NLS_PRESERVE_SECTION_MSG {
    HANDLE hSection;
} BASE_NLS_PRESERVE_SECTION_MSG, *PBASE_NLS_PRESERVE_SECTION_MSG;

typedef struct _BASE_DEFINEDOSDEVICE_MSG {
    ULONG Flags;
    UNICODE_STRING DeviceName;
    UNICODE_STRING TargetPath;
} BASE_DEFINEDOSDEVICE_MSG, *PBASE_DEFINEDOSDEVICE_MSG;

typedef struct _BASE_SHUTDOWNPARAM_MSG {
    ULONG ShutdownLevel;
    ULONG ShutdownFlags;
} BASE_SHUTDOWNPARAM_MSG, *PBASE_SHUTDOWNPARAM_MSG;

//
// Used for Add, Find and GetAtomName
//
typedef struct _BASE_GLOBALATOMNAME_MSG {
    ULONG Atom;
    BOOLEAN AtomNameInClient;
    UNICODE_STRING AtomName;
} BASE_GLOBALATOMNAME_MSG, *PBASE_GLOBALATOMNAME_MSG;

typedef struct _BASE_GLOBALDELETEATOM_MSG {
    ULONG Atom;
} BASE_GLOBALDELETEATOM_MSG, *PBASE_GLOBALDELETEATOM_MSG;

typedef struct _BASE_CREATEPROCESS_MSG {
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
    CLIENT_ID DebuggerClientId;
    ULONG CreationFlags;
    ULONG IsVDM;
    HANDLE hVDM;
} BASE_CREATEPROCESS_MSG, *PBASE_CREATEPROCESS_MSG;

typedef struct _BASE_CREATETHREAD_MSG {
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;
} BASE_CREATETHREAD_MSG, *PBASE_CREATETHREAD_MSG;

typedef struct _BASE_GETTEMPFILE_MSG {
    UINT uUnique;
} BASE_GETTEMPFILE_MSG, *PBASE_GETTEMPFILE_MSG;

typedef struct _BASE_EXITPROCESS_MSG {
    UINT uExitCode;
} BASE_EXITPROCESS_MSG, *PBASE_EXITPROCESS_MSG;

typedef struct _BASE_DEBUGPROCESS_MSG {
    DWORD dwProcessId;
    CLIENT_ID DebuggerClientId;
    PVOID AttachCompleteRoutine;
} BASE_DEBUGPROCESS_MSG, *PBASE_DEBUGPROCESS_MSG;

typedef struct _BASE_CHECKVDM_MSG {
    ULONG  iTask;		// Only for WOW
    HANDLE ConsoleHandle;
    ULONG  BinaryType;
    HANDLE WaitObjectForParent;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    PCHAR  CmdLine;
    PCHAR  Env;
    USHORT CurDrive;
    USHORT CmdLen;
    USHORT VDMState;
    ULONG  EnvLen;
    ULONG  CodePage;
    ULONG  dwCreationFlags;
    LPSTARTUPINFOA StartupInfo;
    PCHAR  Desktop;
    ULONG  DesktopLen;
    PCHAR  Title;
    ULONG  TitleLen;
    PCHAR  Reserved;
    ULONG  ReservedLen;
    PCHAR  CurDirectory;
    ULONG  CurDirectoryLen;
} BASE_CHECKVDM_MSG, *PBASE_CHECKVDM_MSG;

typedef struct _BASE_UPDATE_VDM_ENTRY_MSG {
    ULONG  iTask;		// Only for WOW
    HANDLE ConsoleHandle;
    HANDLE VDMProcessHandle;
    WORD   EntryIndex;
    WORD   VDMCreationState;
    HANDLE WaitObjectForParent;
} BASE_UPDATE_VDM_ENTRY_MSG, *PBASE_UPDATE_VDM_ENTRY_MSG;

typedef struct _BASE_GET_NEXT_VDM_COMMAND_MSG {
    HANDLE ConsoleHandle;
    HANDLE StdIn;
    HANDLE StdOut;
    HANDLE StdErr;
    PCHAR  CmdLine;
    PCHAR  Env;
    USHORT CurrentDrive;
    USHORT CmdLen;
    ULONG  EnvLen;
    ULONG  ExitCode;
    ULONG  VDMState;
    ULONG  iTask;
    HANDLE WaitObjectForVDM;
    ULONG  CodePage;
    ULONG  dwCreationFlags;
    LPSTARTUPINFOA StartupInfo;
    PCHAR  Desktop;
    ULONG  DesktopLen;
    PCHAR  Title;
    ULONG  TitleLen;
    PCHAR  Reserved;
    ULONG  ReservedLen;
    PCHAR  CurDirectory;
    ULONG  CurDirectoryLen;
    ULONG  fComingFromBat;
} BASE_GET_NEXT_VDM_COMMAND_MSG, *PBASE_GET_NEXT_VDM_COMMAND_MSG;

typedef struct _BASE_EXIT_VDM_MSG {
    HANDLE ConsoleHandle;
    ULONG  iWowTask;
    HANDLE WaitObjectForVDM;
} BASE_EXIT_VDM_MSG, *PBASE_EXIT_VDM_MSG;

typedef struct _BASE_SET_REENTER_COUNT {
    HANDLE ConsoleHandle;
    ULONG  fIncDec;
} BASE_SET_REENTER_COUNT_MSG, *PBASE_SET_REENTER_COUNT_MSG;

typedef struct _BASE_IS_FIRST_VDM_MSG {
    BOOL    FirstVDM;
} BASE_IS_FIRST_VDM_MSG, *PBASE_IS_FIRST_VDM_MSG;

typedef struct _BASE_GET_VDM_EXIT_CODE_MSG {
    HANDLE ConsoleHandle;
    HANDLE hParent;
    ULONG  ExitCode;
} BASE_GET_VDM_EXIT_CODE_MSG, *PBASE_GET_VDM_EXIT_CODE_MSG;

typedef struct _BASE_GET_SET_VDM_CUR_DIRS_MSG {
    HANDLE ConsoleHandle;
    PCHAR  lpszzCurDirs;
    ULONG  cchCurDirs;
} BASE_GET_SET_VDM_CUR_DIRS_MSG, *PBASE_GET_SET_VDM_CUR_DIRS_MSG;

typedef struct _BASE_BAT_NOTIFICATION_MSG {
    HANDLE ConsoleHandle;
    ULONG  fBeginEnd;
} BASE_BAT_NOTIFICATION_MSG, *PBASE_BAT_NOTIFICATION_MSG;

typedef struct _BASE_REGISTER_WOWEXEC_MSG {
    HANDLE hwndWowExec;
} BASE_REGISTER_WOWEXEC_MSG, *PBASE_REGISTER_WOWEXEC_MSG;

typedef struct _BASE_SOUNDSENTRY_NOTIFICATION_MSG {
    ULONG  VideoMode;
} BASE_SOUNDSENTRY_NOTIFICATION_MSG, *PBASE_SOUNDSENTRY_NOTIFICATION_MSG;

typedef struct _BASE_REFRESHINIFILEMAPPING_MSG {
    UNICODE_STRING IniFileName;
} BASE_REFRESHINIFILEMAPPING_MSG, *PBASE_REFRESHINIFILEMAPPING_MSG;

typedef struct _BASE_REFRESHDRIVETYPE_MSG {
    ULONG DriveNumber;
} BASE_REFRESHDRIVETYPE_MSG, *PBASE_REFRESHDRIVETYPE_MSG;

#ifdef NTUSERK
typedef struct _BASE_DESTROYGLOBALATOMTABLE_MSG {
    PVOID GlobalAtomTable;
} BASE_DESTROYGLOBALATOMTABLE_MSG, *PBASE_DESTROYGLOBALATOMTABLE_MSG;
#endif

typedef struct _BASE_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        BASE_NLS_SET_USER_INFO_MSG NlsSetUserInfo;
        BASE_NLS_SET_MULTIPLE_USER_INFO_MSG NlsSetMultipleUserInfo;
        BASE_NLS_CREATE_SORT_SECTION_MSG NlsCreateSortSection;
        BASE_NLS_PRESERVE_SECTION_MSG NlsPreserveSection;
        BASE_DEFINEDOSDEVICE_MSG DefineDosDeviceApi;
        BASE_SHUTDOWNPARAM_MSG ShutdownParam;
        BASE_GLOBALATOMNAME_MSG GlobalAtomName;
        BASE_GLOBALDELETEATOM_MSG GlobalDeleteAtom;
        BASE_CREATEPROCESS_MSG CreateProcess;
        BASE_CREATETHREAD_MSG CreateThread;
        BASE_GETTEMPFILE_MSG GetTempFile;
        BASE_EXITPROCESS_MSG ExitProcess;
        BASE_DEBUGPROCESS_MSG DebugProcess;
        BASE_CHECKVDM_MSG CheckVDM;
        BASE_UPDATE_VDM_ENTRY_MSG UpdateVDMEntry;
        BASE_GET_NEXT_VDM_COMMAND_MSG GetNextVDMCommand;
        BASE_EXIT_VDM_MSG ExitVDM;
        BASE_IS_FIRST_VDM_MSG IsFirstVDM;
        BASE_GET_VDM_EXIT_CODE_MSG GetVDMExitCode;
        BASE_SET_REENTER_COUNT_MSG SetReenterCount;
        BASE_GET_SET_VDM_CUR_DIRS_MSG GetSetVDMCurDirs;
        BASE_BAT_NOTIFICATION_MSG BatNotification;
        BASE_REGISTER_WOWEXEC_MSG RegisterWowExec;
        BASE_SOUNDSENTRY_NOTIFICATION_MSG SoundSentryNotification;
        BASE_REFRESHINIFILEMAPPING_MSG RefreshIniFileMapping;
        BASE_REFRESHDRIVETYPE_MSG RefreshDriveType;
#ifdef NTUSERK
        BASE_DESTROYGLOBALATOMTABLE_MSG DestroyGlobalAtomTable;
#endif
    } u;
} BASE_API_MSG, *PBASE_API_MSG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\basedll.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    basedll.h

Abstract:

    This module contains private function prototypes
    and types for the 32-bit windows base APIs.

Author:

    Mark Lucovsky (markl) 18-Sep-1990

Revision History:

--*/

#ifndef _BASEP_
#define _BASEP_

#undef UNICODE
//
// Include Common Definitions.
//

#include <base.h>


//
// Include DLL definitions for CSR
//

#include "ntcsrdll.h"
#include "ntcsrsrv.h"

//
// Include message definitions for communicating between client and server
// portions of the Base portion of the Windows subsystem
//

#include "basemsg.h"

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;

typedef struct _LOAD_MODULE_PARAMS {
    LPVOID lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

typedef struct _RELATIVE_NAME {
    STRING RelativeName;
    HANDLE ContainingDirectory;
} RELATIVE_NAME, *PRELATIVE_NAME;

HANDLE BaseDllHandle;
HANDLE BaseNamedObjectDirectory;

PVOID BaseHeap;
BASE_HANDLE_TABLE BaseHeapHandleTable;


PVOID BaseAtomTable;
UNICODE_STRING BaseWindowsDirectory;
UNICODE_STRING BaseWindowsSystemDirectory;

UNICODE_STRING BasePathVariableName;
UNICODE_STRING BaseTmpVariableName;
UNICODE_STRING BaseTempVariableName;
UNICODE_STRING BaseDotVariableName;
UNICODE_STRING BaseDotTmpSuffixName;
UNICODE_STRING BaseDotComSuffixName;
UNICODE_STRING BaseDotPifSuffixName;
UNICODE_STRING BaseDotExeSuffixName;

UNICODE_STRING BaseDefaultPath;
UNICODE_STRING BaseDefaultPathAppend;
USHORT BaseWindowsMajorVersion;
USHORT BaseWindowsMinorVersion;
USHORT BaseBuildNumber;
PWSTR BaseCSDVersion;

UNICODE_STRING BaseConsoleInput;
UNICODE_STRING BaseConsoleOutput;
UNICODE_STRING BaseConsoleGeneric;
UNICODE_STRING BaseUnicodeCommandLine;
ANSI_STRING BaseAnsiCommandLine;

LPSTARTUPINFOA BaseAnsiStartupInfo;

PBASE_STATIC_SERVER_DATA BaseStaticServerData;

extern ULONG BaseGetTickMagicMultiplier;
extern LARGE_INTEGER BaseGetTickMagicDivisor;
extern CCHAR BaseGetTickMagicShiftCount;
extern BOOLEAN BaseRunningInServerProcess;

ULONG BaseIniFileUpdateCount;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG)(SIZE) + BaseStaticServerData->SysInfo.PageSize - 1) & ~(BaseStaticServerData->SysInfo.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG)(SIZE)) & ~(BaseStaticServerData->SysInfo.PageSize - 1))
#define BASE_COPY_FILE_CHUNK (64*1024)
#define BASE_MAX_PATH_STRING 4080

extern BOOLEAN BasepFileApisAreOem;

NTSTATUS
Basep8BitStringToUnicodeString(
    PUNICODE_STRING DestinationString,
    PANSI_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

NTSTATUS
BasepUnicodeStringTo8BitString(
    PANSI_STRING DestinationString,
    PUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );

ULONG
BasepUnicodeStringTo8BitSize(
    PUNICODE_STRING UnicodeString
    );

ULONG
Basep8BitStringToUnicodeSize(
    PANSI_STRING AnsiString
    );

HANDLE
BaseGetNamedObjectDirectory(
    VOID
    );

NTSTATUS
BaseDllInitializeMemoryManager( VOID );

typedef
NTSTATUS
(*BASECLIENTCONNECTROUTINE)(
    PVOID MustBeNull,
    PVOID ConnectionInformation,
    PULONG ConnectionInformationLength
    );


POBJECT_ATTRIBUTES
BaseFormatObjectAttributes(
    POBJECT_ATTRIBUTES ObjectAttributes,
    PSECURITY_ATTRIBUTES SecurityAttributes,
    PUNICODE_STRING ObjectName
    );

PLARGE_INTEGER
BaseFormatTimeOut(
    PLARGE_INTEGER TimeOut,
    DWORD Milliseconds
    );

ULONG
BaseSetLastNTError(
    NTSTATUS Status
    );

VOID
BaseSwitchStackThenTerminate(
    PVOID CurrentStack,
    PVOID NewStack,
    DWORD ExitCode
    );

VOID
BaseFreeStackAndTerminate(
    PVOID OldStack,
    DWORD ExitCode
    );

NTSTATUS
BaseCreateStack(
    HANDLE Process,
    ULONG StackSize,
    ULONG MaximumStackSize,
    PINITIAL_TEB InitialTeb
    );

VOID
BaseThreadStart(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

typedef DWORD (WINAPI *PPROCESS_START_ROUTINE)(
    VOID
    );

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    );

VOID
BaseThreadStartThunk(
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

VOID
BaseProcessStartThunk(
    LPVOID lpProcessStartAddress,
    LPVOID lpParameter
    );

VOID
BaseInitializeContext(
    PCONTEXT Context,
    PVOID Parameter,
    PVOID InitialPc,
    PVOID InitialSp,
    BOOLEAN NewThread
    );

#if defined (WX86)
NTSTATUS
BaseCreateWx86Tib(
    HANDLE Process,
    HANDLE Thread,
    ULONG InitialPc,
    ULONG CommittedStackSize,
    ULONG MaximumStackSize,
    BOOLEAN EmulateInitialPc
    );
#endif

VOID
BaseFreeThreadStack(
     HANDLE hProcess,
     HANDLE hThread,
     PINITIAL_TEB InitialTeb
     );

BOOL
BasePushProcessParameters(
    HANDLE Process,
    PPEB Peb,
    LPCWSTR ApplicationPathName,
    LPCWSTR CurrentDirectory,
    LPCWSTR CommandLine,
    LPVOID Environment,
    LPSTARTUPINFOW lpStartupInfo,
    DWORD dwCreationFlags,
    BOOL bInheritHandles
    );

LPWSTR
BaseComputeProcessDllPath(
    LPCWSTR ApplicationName,
    LPVOID Environment
    );

DWORD
BaseDebugAttachThread(
    LPVOID ThreadParameter
    );

VOID
BaseAttachCompleteThunk(
    VOID
    );

VOID
BaseAttachComplete(
    PCONTEXT Context
    );

#define BASE_FIND_FIRST_DEVICE_HANDLE (HANDLE)1

HANDLE
BaseFindFirstDevice(
    PUNICODE_STRING FileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

PUNICODE_STRING
BaseIsThisAConsoleName(
    PUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    );


typedef ULONG (FAR WINAPI *CSRREMOTEPROCPROC)(HANDLE, CLIENT_ID *);

#if DBG
VOID
BaseHeapBreakPoint( VOID );
#endif

ULONG
BaseGetTickCount (
   IN LARGE_INTEGER CurrentTime,
   IN LARGE_INTEGER BootTime
   );

ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    );

HANDLE
BaseCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    STORAGE_TYPE StorageType
    );

#ifdef _CAIRO_
BOOL
BaseCopyStructuredStorage(
    HANDLE SourceFile,
    HANDLE DestFile,
    ULONG *CopySize
    );

NTSTATUS
BaseGetStorageType(
    HANDLE Handle,
    STORAGE_TYPE *StorageType
    );

NTSTATUS
BaseCopyOleAllInfo(
    HANDLE SrcHandle,
    HANDLE DstHandle
    );
#endif

BOOL
BaseCopyStream(
    HANDLE SourceFile,
    LPCWSTR lpNewFileName,
    HANDLE hFile,
    LARGE_INTEGER *lpFileSize,
    BOOL bFailIfExists,
    PHANDLE Destfile,
    LPDWORD lpCopySize,
    STORAGE_TYPE StorageType
    );


VOID
BaseMarkFileForDelete(
    HANDLE File,
    DWORD FileAttributes
    );


PVOID
BasepMapModuleHandle(
    IN HMODULE hModule,
    IN BOOLEAN bResourcesOnly
    );

//
// Data structures and interfaces used by dllini.c
//

typedef struct _INIFILE_CACHE {
    struct _INIFILE_CACHE *Next;
    ULONG EnvironmentUpdateCount;
    UNICODE_STRING NtFileName;
    PINIFILE_MAPPING_FILENAME FileMapping;
    HANDLE FileHandle;
    BOOLEAN WriteAccess;
    BOOLEAN UnicodeFile;
    BOOLEAN LockedFile;
    ULONG EndOfFile;
    PVOID BaseAddress;
    ULONG CommitSize;
    ULONG RegionSize;
    ULONG UpdateOffset;
    ULONG UpdateLength;
    ULONG DirectoryInformationLength;
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
} INIFILE_CACHE, *PINIFILE_CACHE;

typedef enum _INIFILE_OPERATION {
    FlushProfiles,
    ReadKeyValue,
    WriteKeyValue,
    DeleteKey,
    ReadKeyNames,
    ReadSectionNames,
    ReadSection,
    WriteSection,
    DeleteSection,
    RefreshIniFileMapping
} INIFILE_OPERATION;

typedef struct _INIFILE_PARAMETERS {
    INIFILE_OPERATION Operation;
    BOOLEAN WriteOperation;
    BOOLEAN Unicode;
    BOOLEAN ValueBufferAllocated;
    PINIFILE_MAPPING_FILENAME IniFileNameMapping;
    PINIFILE_CACHE IniFile;
    UNICODE_STRING BaseFileName;
    UNICODE_STRING FileName;
    UNICODE_STRING NtFileName;
    ANSI_STRING ApplicationName;
    ANSI_STRING VariableName;
    UNICODE_STRING ApplicationNameU;
    UNICODE_STRING VariableNameU;
    BOOLEAN MultiValueStrings;
    union {
        //
        // This structure filled in for write operations
        //
        struct {
            LPSTR ValueBuffer;
            ULONG ValueLength;
            PWSTR ValueBufferU;
            ULONG ValueLengthU;
        };
        //
        // This structure filled in for read operations
        //
        struct {
            ULONG ResultChars;
            ULONG ResultMaxChars;
            LPSTR ResultBuffer;
            PWSTR ResultBufferU;
        };
    };


    //
    // Remaining fields only valid when parsing an on disk .INI file mapped into
    // memory.
    //

    PVOID TextCurrent;
    PVOID TextStart;
    PVOID TextEnd;

    ANSI_STRING SectionName;
    ANSI_STRING KeywordName;
    ANSI_STRING KeywordValue;
    PANSI_STRING AnsiSectionName;
    PANSI_STRING AnsiKeywordName;
    PANSI_STRING AnsiKeywordValue;
    UNICODE_STRING SectionNameU;
    UNICODE_STRING KeywordNameU;
    UNICODE_STRING KeywordValueU;
    PUNICODE_STRING UnicodeSectionName;
    PUNICODE_STRING UnicodeKeywordName;
    PUNICODE_STRING UnicodeKeywordValue;
} INIFILE_PARAMETERS, *PINIFILE_PARAMETERS;

NTSTATUS
BaseDllInitializeIniFileMappings(
    PBASE_STATIC_SERVER_DATA StaticServerData
    );

NTSTATUS
BasepAcquirePrivilege(
    ULONG Privilege,
    PVOID *ReturnedState
    );

NTSTATUS
BasepAcquirePrivilegeEx(
    ULONG Privilege,
    PVOID *ReturnedState
    );

VOID
BasepReleasePrivilege(
    PVOID StatePointer
    );

ULONG BaseDllTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( BaseDllTag, t ))

#define TMP_TAG 0
#define BACKUP_TAG 1
#define INI_TAG 2
#define FIND_TAG 3
#define GMEM_TAG 4
#define LMEM_TAG 5
#define ENV_TAG 6
#define RES_TAG 7
#define VDM_TAG 8


#include <vdmapi.h>
#include "vdm.h"
#include "basevdm.h"

#include "stdlib.h"     // for atol
#include "stdio.h"     // for atol

#endif // _BASEP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\cabpack.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* CABPACK.C - Wizard to build a Win32 Self-Extracting and self-installing *
//*             EXE from a Cabinet (CAB) file.                              *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "cabpack.h"
#include <memory.h>
#include "sdsutils.h"

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
#define MAX_TARGVER     0xFFFFFFFF

#define FLAG_BLK        "OK"
#define FLAG_PMTYN      "YesNo"
#define FLAG_PMTOC      "OkCancel"

//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************

//---------------------------------------------------------------------------
// attention: 3\18\97: Update notes:
//                    We are changing our batch directive file extension from
//                    CDF to SED.  But all the internal data structure name 
//                    remain unchanged.  So if you see CDF, it means old CDF file
//                    or new SED file data.
//---------------------------------------------------------------------------

HINSTANCE    g_hInst        = NULL;     // Pointer to Instance
WIZARDSTATE *g_pWizardState = NULL;     // Pointer to global wizard state
BOOL         g_fQuitWizard  = FALSE;    // Global flag used to signal that we
                                        // want to terminate the wizard
                                        // ourselves
HFONT        g_hBigFont     = NULL;     // Bigger font used by dialogs.
extern CDF   g_CDF;                     // Contains stuff that we want to
                                        // store in the CABPack Directive
                                        // File
BOOL        g_fBuildNow;
FARPROC     g_lpfnOldMEditWndProc;
CHAR        g_szOverideCDF[MAX_PATH];
CHAR        g_szOverideSec[SMALL_BUF_LEN];
WORD        g_wQuietMode = 0;
WORD        g_wSilentMode = 0;
WORD        g_wRunDiamondMinimized = 0;
HFONT       g_hFont = NULL;

extern char         g_szInitialDir[];

BOOL IsOSNT3X(VOID);

// This table defines the dialog id's and functions for processing each page.
// Pages need only provide functions when they want non-default behavior for
// certain action (init,buttons,notifications,next/back/finish,cancel).

PAGEINFO PageInfo[NUM_WIZARD_PAGES] = {
    { IDD_WELCOME,    WelcomeInit,    WelcomeCmd,    NULL,        WelcomeOK,    NULL },
    { IDD_MODIFY,     ModifyInit,     NULL,          NULL,        ModifyOK,     NULL },
    { IDD_PACKPURPOSE,PackPurposeInit,PackPurposeCmd,NULL,        PackPurposeOK,NULL },
    { IDD_TITLE,      TitleInit,      NULL,          NULL,        TitleOK,      NULL },
    { IDD_PROMPT,     PromptInit,     PromptCmd,     NULL,        PromptOK,     NULL },
    { IDD_LICENSETXT, LicenseTxtInit, LicenseTxtCmd, NULL,        LicenseTxtOK, NULL },
    { IDD_FILES,      FilesInit,      FilesCmd,      FilesNotify, FilesOK,      NULL },
    { IDD_COMMAND,    CommandInit,    NULL,          NULL,        CommandOK,    NULL },
    { IDD_SHOWWINDOW, ShowWindowInit, NULL,          NULL,        ShowWindowOK, NULL },
    { IDD_FINISHMSG,  FinishMsgInit,  FinishMsgCmd,  NULL,        FinishMsgOK,  NULL },
    { IDD_TARGET,     TargetInit,     TargetCmd,     NULL,        TargetOK,     NULL },
    { IDD_TARGET_CAB, TargetCABInit,  TargetCABCmd,  NULL,        TargetCABOK,  NULL },
    { IDD_CABLABEL,   CabLabelInit,   CabLabelCmd,   NULL,        CabLabelOK,   NULL },
    { IDD_REBOOT,     RebootInit,     RebootCmd,     NULL,        RebootOK,     NULL },
    { IDD_SAVE,       SaveInit,       SaveCmd,       NULL,        SaveOK,       NULL },
    { IDD_CREATE,     CreateInit,     NULL,          NULL,        CreateOK,     NULL },
};

CDFSTRINGINFO CDFStrInfo[] = {
    { SEC_OPTIONS,  KEY_INSTPROMPT,     "", g_CDF.achPrompt,    sizeof(g_CDF.achPrompt),    g_szOverideSec, &g_CDF.fPrompt },
    { SEC_OPTIONS,  KEY_DSPLICENSE,     "", g_CDF.achLicense,   sizeof(g_CDF.achLicense),   g_szOverideSec, &g_CDF.fLicense },
    { SEC_OPTIONS,  KEY_ENDMSG,         "", g_CDF.achFinishMsg, sizeof(g_CDF.achFinishMsg), g_szOverideSec, &g_CDF.fFinishMsg },
    { SEC_OPTIONS,  KEY_PACKNAME,       "", g_CDF.achTarget,    sizeof(g_CDF.achTarget),    g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_FRIENDLYNAME,   "", g_CDF.achTitle,     sizeof(g_CDF.achTitle),     g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_APPLAUNCH,      "", g_CDF.achOrigiInstallCmd,sizeof(g_CDF.achInstallCmd),g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_POSTAPPLAUNCH,  "", g_CDF.achOrigiPostInstCmd,sizeof(g_CDF.achPostInstCmd),g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_ADMQCMD,        "", g_CDF.szOrigiAdmQCmd,    sizeof(g_CDF.szOrigiAdmQCmd),    g_szOverideSec, NULL },
    { SEC_OPTIONS,  KEY_USERQCMD,       "", g_CDF.szOrigiUsrQCmd,    sizeof(g_CDF.szOrigiUsrQCmd),    g_szOverideSec, NULL },
} ;

CDFOPTINFO CDFOptInfo[] = {
    { KEY_NOEXTRACTUI,  EXTRACTOPT_UI_NO },
    { KEY_USELFN,       EXTRACTOPT_LFN_YES },
    { KEY_PLATFORM_DIR, EXTRACTOPT_PLATFORM_DIR },
    { KEY_NESTCOMPRESSED, EXTRACTOPT_COMPRESSED },
    { KEY_UPDHELPDLLS,  EXTRACTOPT_UPDHLPDLLS },
    { KEY_CHKADMRIGHT,  EXTRACTOPT_CHKADMRIGHT },
    { KEY_PASSRETURN,   EXTRACTOPT_PASSINSTRET },
    { KEY_PASSRETALWAYS,EXTRACTOPT_PASSINSTRETALWAYS },
    { KEY_CMDSDEPENDED, EXTRACTOPT_CMDSDEPENDED },
};

CHAR *AdvDlls[] = { ADVANCEDLL, ADVANCEDLL32, ADVANCEDLL16 };
PSTR pResvSizes[] = { CAB_0K, CAB_2K, CAB_4K, CAB_6K };
void SetControlFont();
void TermApp();

//***************************************************************************
//*                                                                         *
//* NAME:       WinMain                                                     *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the program.                           *
//*                                                                         *
//* REQUIRES:   hInstance:      Handle to the program instance              *
//*             hPrevInstance:  Handle to the previous instance (NULL)      *
//*             lpszCmdLine:    Command line arguments                      *
//*             nCmdShow:       How to show the window                      *
//*                                                                         *
//* RETURNS:    int:            Always 0                                    *
//*                                                                         *
//***************************************************************************
INT WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPSTR lpszCmdLine, INT nCmdShow )
{
    g_hInst = hInstance;
    g_fBuildNow = FALSE;
    g_szOverideCDF[0] = 0;
    g_szOverideSec[0] = 0;

    // init CDF filenaem
    g_CDF.achFilename[0] = '\0';
    g_CDF.achVerInfo[0] = '\0';
    g_CDF.lpszCookie = NULL;

    InitItemList();                     // Initilize our file item list.
    // Get the command line args.  If there is a "/N", then we want to
    // build NOW!


    if ( !ParseCmdLine( lpszCmdLine ) )
    {
        ErrorMsg( NULL, IDS_ERR_BADCMDLINE );
        return 1;  //error return case
    }

    if ( g_fBuildNow && lstrlen( g_CDF.achFilename ) > 0 )
    {
        // batch mode did not update the CDF file, no need for writeCDF
        if ( ReadCDF( NULL ) && MakePackage( NULL ) )
        {
            return 0;
        }
        else
        {
            return 1;
        }
    }

    // Allocate global structures
    g_pWizardState = (PWIZARDSTATE) malloc( sizeof( WIZARDSTATE) );

    if ( ! g_pWizardState )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
    } else  {
        SetControlFont();

        RunCABPackWizard();

        if (g_hFont)
            DeleteObject(g_hFont);
    }

    // Clean up dialog title font
    DestroyBigFont();
    TermApp();

    // Free global structures
    if ( g_pWizardState )  {
        free( g_pWizardState );
    }

    return 0;
}


// Free up the allocated resource
//
void TermApp()
{
    if ( g_CDF.lpszCookie )
    {
        LocalFree( g_CDF.lpszCookie );
    }

    if ( g_CDF.pVerInfo )
        LocalFree( g_CDF.pVerInfo );
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunCABPackWizard                                            *
//*                                                                         *
//* SYNOPSIS:   Creates property sheet pages, initializes wizard property   *
//*             sheet and runs wizard.                                      *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if user runs wizard to completion, FALSE   *
//*                         if user cancels or an error occurs.             *
//*                                                                         *
//* NOTES:      Wizard pages all use one dialog proc (GenDlgProc). They may *
//*             specify their own handler procs to get called at init time  *
//*             or in response to Next, Cancel or a dialog control, or use  *
//*             the default behavior of GenDlgProc.                         *
//*                                                                         *
//***************************************************************************
BOOL RunCABPackWizard( VOID )
{
    HPROPSHEETPAGE  hWizPage[NUM_WIZARD_PAGES]; // array to hold handles to pages
    PROPSHEETPAGE   psPage;     // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;   // struct used to run wizard property sheet
    UINT            nPageIndex;
    UINT            nFreeIndex;
    INT_PTR         iRet;


    ASSERT( g_pWizardState );

    // initialize the app state structure
    InitWizardState( g_pWizardState );

    // zero out structures
    memset( &hWizPage, 0, sizeof(hWizPage) );
    memset( &psPage, 0, sizeof(psPage) );
    memset( &psHeader, 0, sizeof(psHeader) );

    // fill out common data property sheet page struct
    psPage.dwSize       = sizeof(psPage);
    psPage.dwFlags      = PSP_DEFAULT;
    psPage.hInstance    = g_hInst;
    psPage.pfnDlgProc   = GenDlgProc;

    // create a property sheet page for each page in the wizard
    for ( nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++ )  {
        psPage.pszTemplate = MAKEINTRESOURCE( PageInfo[nPageIndex].uDlgID );
        // set a pointer to the PAGEINFO struct as the private data for this
        // page
        psPage.lParam = (LPARAM) &PageInfo[nPageIndex];

        hWizPage[nPageIndex] = CreatePropertySheetPage( &psPage );

        if ( !hWizPage[nPageIndex] ) {
            // creating page failed, free any pages already created and bail
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            for ( nFreeIndex = 0; nFreeIndex < nPageIndex; nFreeIndex++ ) {
                DestroyPropertySheetPage( hWizPage[nFreeIndex] );
            }

            return FALSE;
        }
    }

    // fill out property sheet header struct
    psHeader.dwSize     = sizeof(psHeader);
    psHeader.dwFlags    = PSH_WIZARD | PSH_USEICONID;
    psHeader.hwndParent = NULL;
    psHeader.hInstance  = g_hInst;
    psHeader.nPages     = NUM_WIZARD_PAGES;
    psHeader.phpage     = hWizPage;
    psHeader.pszIcon    = (LPSTR) IDI_ICON;

    // run the Wizard
    iRet = PropertySheet( &psHeader );

    if ( iRet < 0 ) {
        // property sheet failed, most likely due to lack of memory
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
    }

    // If the user Cancels out of the Wizard, there may be items
    // left in the file list.  Clean them up.
    DeleteAllItems();
    return ( iRet > 0 );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GenDlgProc                                                  *
//*                                                                         *
//* SYNOPSIS:   Generic dialog proc for all wizard pages.                   *
//*                                                                         *
//* REQUIRES:   hDlg:                                                       *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//*                                                                         *
//* NOTES:      This dialog proc provides the following default behavior:   *
//*               init:       back and next buttons enabled                 *
//*               next btn:   switches to page following current page       *
//*               back btn:   switches to previous page                     *
//*               cancel btn: prompts user to confirm, and cancels wizard   *
//*               dlg ctrl:   does nothing (in response to WM_COMMANDs)     *
//*             Wizard pages can specify their own handler functions (in    *
//*             the PageInfo table) to override default behavior for any of *
//*             the above actions.                                          *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK GenDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch ( uMsg ) {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************
        {
            LPPROPSHEETPAGE lpsp;       // get propsheet page struct passed in
            PPAGEINFO pPageInfo;        // fetch our private page info from
                                        // propsheet struct

            lpsp = (LPPROPSHEETPAGE) lParam;
            ASSERT( lpsp );
            pPageInfo = (PPAGEINFO) lpsp->lParam;
            ASSERT( pPageInfo );

            // store pointer to private page info in window data for later
            SetWindowLongPtr( hDlg, DWLP_USER, (LPARAM) pPageInfo );

            // set title text to large font
            InitBigFont( hDlg, IDC_BIGTEXT );

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT |
                                                               PSWIZB_BACK );

            // call init proc for this page if one is specified
            if ( pPageInfo->InitProc )  {
                return pPageInfo->InitProc( hDlg, TRUE );
            }

            return TRUE;

            break;
        }


      //*********************************************************************
        case WM_NOTIFY:
      //*********************************************************************
        {
            // get pointer to private page data out of window data
            PPAGEINFO pPageInfo;
            BOOL      fRet;
            BOOL      fKeepHistory = TRUE;
            NMHDR    *lpnm         = (NMHDR *) lParam;
            UINT      uNextPage    = 0;


            pPageInfo = (PPAGEINFO) GetWindowLongPtr( hDlg, DWLP_USER );
            ASSERT( pPageInfo );

            switch ( lpnm->code )  {

                //***********************************************************
                case PSN_SETACTIVE:
                //***********************************************************
                    // initialize 'back' and 'next' wizard buttons, if
                    // page wants something different it can fix in init proc
                    PropSheet_SetWizButtons( GetParent(hDlg), PSWIZB_NEXT |
                                                               PSWIZB_BACK );

                    // call init proc for this page if one is specified
                    if ( pPageInfo->InitProc )  {
                        return pPageInfo->InitProc(hDlg,FALSE);
                    }

                    return TRUE;

                    break;


                //***********************************************************
                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                //***********************************************************
                    // call OK proc for this page if one is specified
                    if ( pPageInfo->OKProc )
                        if ( ! pPageInfo->OKProc( hDlg, ( lpnm->code != PSN_WIZBACK ), &uNextPage, &fKeepHistory ) )
                        {
                            // stay on this page
                            SetPropSheetResult( hDlg, -1 );
                            return TRUE;
                        }

                    if ( lpnm->code != PSN_WIZBACK )  {
                        // 'next' pressed
                        ASSERT( g_pWizardState->uPagesCompleted <
                                                          NUM_WIZARD_PAGES );

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if ( fKeepHistory ) {
                            g_pWizardState->uPageHistory
                                            [g_pWizardState->uPagesCompleted]
                                            = g_pWizardState->uCurrentPage;
                            g_pWizardState->uPagesCompleted++;
                        }

                        // if no next page specified or no OK proc,
                        // advance page by one
                        if ( !uNextPage )  {
                            uNextPage = g_pWizardState->uCurrentPage + 1;
                        }
                    } else  {
                        // 'back' pressed
                        ASSERT( g_pWizardState->uPagesCompleted > 0 );

                        // get the last page from the history list
                        g_pWizardState->uPagesCompleted--;
                        uNextPage = g_pWizardState->
                                    uPageHistory[g_pWizardState->
                                    uPagesCompleted];
                    }

                    // if we need to exit the wizard now, send a 'cancel'
                    // message to ourselves (to keep the prop. page mgr happy)

                    if ( g_fQuitWizard ) {
                        PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                        SetPropSheetResult( hDlg, -1 );
                        return TRUE;
                    }

                    // set next page, only if 'next' or 'back' button
                    // was pressed

                    if ( lpnm->code != PSN_WIZFINISH )  {
                        // set the next current page index
                        g_pWizardState->uCurrentPage = uNextPage;

                        // tell the prop sheet mgr what the next page to
                        // display is
                        SetPropSheetResult( hDlg,
                                            GetDlgIDFromIndex( uNextPage ) );
                        return TRUE;
                    }

                    break;


                //***********************************************************
                case PSN_QUERYCANCEL:
                //***********************************************************

                    // if global flag to exit is set, then this cancel
                    // is us pretending to push 'cancel' so prop page mgr
                    // will kill the wizard.  Let this through...

                    if ( g_fQuitWizard )  {
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, FALSE );
                        return TRUE;
                    }

                    // if this page has a special cancel proc, call it
                    if ( pPageInfo->CancelProc )
                        fRet = pPageInfo->CancelProc( hDlg );
                    else {
                        // default behavior: pop up a message box confirming
                        // the cancel
                        fRet = ( MsgBox( hDlg, IDS_QUERYCANCEL,
                                 MB_ICONQUESTION, MB_YESNO |
                                 MB_DEFBUTTON2 ) == IDYES );
                    }

                    // return the value thru window data
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, !fRet );
                    return TRUE;
                    break;


                //***********************************************************
                default:
                //***********************************************************

                    if ( pPageInfo->NotifyProc )  {
                        pPageInfo->NotifyProc( hDlg, wParam, lParam );
                    }
            }

            break;
        }


      //*********************************************************************
        case WM_COMMAND:
      //*********************************************************************
        {
            // get pointer to private page data out of window data
            PPAGEINFO pPageInfo;
            UINT      uNextPage    = 0;
            BOOL      fGotoPage    = FALSE;
            BOOL      fKeepHistory = TRUE;

            pPageInfo = (PPAGEINFO) GetWindowLongPtr( hDlg, DWLP_USER );
            ASSERT( pPageInfo );

            // if this page has a command handler proc, call it
            if ( pPageInfo->CmdProc )  {
                pPageInfo->CmdProc( hDlg, (UINT) LOWORD(wParam), &fGotoPage,
                                                 &uNextPage, &fKeepHistory );

                if ( fGotoPage )  {
                    ASSERT(   g_pWizardState->uPagesCompleted
                            < NUM_WIZARD_PAGES );
                    ASSERT( g_pWizardState->uPagesCompleted > 0 );

                    SetPropSheetResult( hDlg, uNextPage );
                    g_pWizardState->uCurrentPage = uNextPage;

                    if ( fKeepHistory ) {
                        g_pWizardState->uPageHistory[g_pWizardState->
                            uPagesCompleted] = g_pWizardState->uCurrentPage;
                        g_pWizardState->uPagesCompleted++;
                    }

                    // set the next current page index
                    g_pWizardState->uCurrentPage = uNextPage;

                    // tell the prop sheet mgr what the next page to
                    // display is
                    SetPropSheetResult( hDlg,
                                        GetDlgIDFromIndex( uNextPage ) );
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       InitWizardState                                             *
//*                                                                         *
//* SYNOPSIS:   Initializes wizard state structure.                         *
//*                                                                         *
//* REQUIRES:   pWizardState:                                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID InitWizardState( WIZARDSTATE *pWizardState )
{
    ASSERT( pWizardState );

    // zero out structure
    memset( pWizardState, 0, sizeof(WIZARDSTATE) );

    // set starting page
    pWizardState->uCurrentPage = ORD_PAGE_WELCOME;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MEditSubClassWnd                                            *
//*                                                                         *
//* SYNOPSIS:   Subclasses a multiline edit control so that a edit message  *
//*             to select the entire contents is ignored.                   *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle of the edit window                   *
//*             fnNewProc:      New window handler proc                     *
//*             lpfnOldProc:    (returns) Old window handler proc           *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//* NOTE:       A selected edit message is not generated when the user      *
//*             selects text with the keyboard or mouse.                    *
//*                                                                         *
//***************************************************************************
VOID NEAR PASCAL MEditSubClassWnd( HWND hWnd, FARPROC fnNewProc )
{
    g_lpfnOldMEditWndProc = (FARPROC) GetWindowLongPtr( hWnd, GWLP_WNDPROC );

    SetWindowLongPtr( hWnd, GWLP_WNDPROC, (LONG_PTR) MakeProcInstance( fnNewProc,
                   (HINSTANCE) GetWindowWord( hWnd, GWW_HINSTANCE ) ) );
}


//***************************************************************************
//*                                                                         *
//* NAME:       MEditSubProc                                                *
//*                                                                         *
//* SYNOPSIS:   New multiline edit window procedure to ignore selection of  *
//*             all contents.                                               *
//*                                                                         *
//* REQUIRES:   hWnd:                                                       *
//*             msg:                                                        *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    LONG:                                                       *
//*                                                                         *
//* NOTE:       A selected edit message is not generated when the user      *
//*             selects text with the keyboard or mouse.                    *
//*                                                                         *
//***************************************************************************
LRESULT CALLBACK MEditSubProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    if ( msg == EM_SETSEL )  {
        return 0;
        wParam = lParam;
        lParam = MAKELPARAM( LOWORD(lParam), LOWORD(lParam) );
    }

    return CallWindowProc( (WNDPROC) g_lpfnOldMEditWndProc, hWnd, msg,
                           wParam, lParam );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetDlgIDFromIndex                                           *
//*                                                                         *
//* SYNOPSIS:   For a given zero-based page index, returns the              *
//*             corresponding dialog ID for the page.                       *
//*                                                                         *
//* REQUIRES:   uPageIndex:                                                 *
//*                                                                         *
//* RETURNS:    UINT:                                                       *
//*                                                                         *
//***************************************************************************
UINT GetDlgIDFromIndex( UINT uPageIndex )
{
    ASSERT( uPageIndex < NUM_WIZARD_PAGES );

    return PageInfo[uPageIndex].uDlgID;
}


//***************************************************************************
//*                                                                         *
//* NAME:       EnableWizard                                                *
//*                                                                         *
//* SYNOPSIS:   Enables or disables the wizard buttons and the wizard page  *
//*             itself (so it can't receive focus).                         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fEnable:        TRUE to enable the wizard, FALSE to disable *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID EnableWizard( HWND hDlg, BOOL fEnable )
{
    HWND hwndWiz = GetParent( hDlg );

    // disable/enable back, next, cancel
    EnableWindow( GetDlgItem( hwndWiz, IDD_BACK ), fEnable );
    EnableWindow( GetDlgItem( hwndWiz, IDD_NEXT ), fEnable );
    EnableWindow( GetDlgItem( hwndWiz, IDCANCEL ), fEnable );

    // disable/enable wizard page
    EnableWindow( hwndWiz, fEnable );

    UpdateWindow( hwndWiz );

    if ( fEnable ) {
        SetForegroundWindow( hDlg );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgWaitForMultipleObjectsLoop                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   hEvent:                                                     *
//*                                                                         *
//* RETURNS:    DWORD:                                                      *
//*                                                                         *
//***************************************************************************
DWORD MsgWaitForMultipleObjectsLoop( HANDLE hEvent )
{
    MSG msg;
    DWORD dwObject;

    while (1)
    {
        dwObject = MsgWaitForMultipleObjects( 1, &hEvent, FALSE,INFINITE,
                                                           QS_ALLINPUT );
        // Are we done waiting?
        switch ( dwObject )  {
            case WAIT_OBJECT_0:

            case WAIT_FAILED:
                return dwObject;

            case WAIT_OBJECT_0 + 1:
                // got a message, dispatch it and wait again
                while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
                    DispatchMessage(&msg);
                }
                break;
        }
    }

}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgBox2Param                                                *
//*                                                                         *
//* SYNOPSIS:   Displays a message box with the specified string ID using   *
//*             2 string parameters.                                        *
//*                                                                         *
//* REQUIRES:   hWnd:           Parent window                               *
//*             nMsgID:         String resource ID                          *
//*             szParam1:       Parameter 1 (or NULL)                       *
//*             szParam2:       Parameter 2 (or NULL)                       *
//*             uIcon:          Icon to display (or 0)                      *
//*             uButtons:       Buttons to display                          *
//*                                                                         *
//* RETURNS:    INT:            ID of button pressed                        *
//*                                                                         *
//* NOTES:      Macros are provided for displaying 1 parameter or 0         *
//*             parameter message boxes.  Also see ErrorMsg() macros.       *
//*                                                                         *
//***************************************************************************
INT MsgBox2Param( HWND hWnd, UINT nMsgID, LPCSTR szParam1, LPCSTR szParam2,
                  UINT uIcon, UINT uButtons )
{
    CHAR achMsgBuf[STRING_BUF_LEN];
    CHAR achSmallBuf[SMALL_BUF_LEN];
    LPSTR szMessage;
    INT   nReturn;


    if ( !(g_wQuietMode == 1) )
    {
        LoadSz( IDS_APPNAME, achSmallBuf, sizeof(achSmallBuf) );
        LoadSz( nMsgID, achMsgBuf, sizeof(achMsgBuf) );

        if ( szParam2 != NULL )  {
            szMessage = (LPSTR) LocalAlloc( LPTR,   lstrlen( achMsgBuf )
                                                  + lstrlen( szParam1 )
                                                  + lstrlen( szParam2 ) + 100 );
            if ( ! szMessage )  {
                return -1;
            }

            wsprintf( szMessage, achMsgBuf, szParam1, szParam2 );
        } else if ( szParam1 != NULL )  {
            szMessage = (LPSTR) LocalAlloc( LPTR,   lstrlen( achMsgBuf )
                                                + lstrlen( szParam1 ) + 100 );
            if ( ! szMessage )  {
                return -1;
            }

            wsprintf( szMessage, achMsgBuf, szParam1, szParam2 );
        } else  {
            szMessage = (LPSTR) LocalAlloc( LPTR, lstrlen( achMsgBuf ) + 1 );
            if ( ! szMessage )  {
                return -1;
            }

            lstrcpy( szMessage, achMsgBuf );
        }

        MessageBeep( uIcon );

        nReturn = MessageBox( hWnd, szMessage, achSmallBuf, uIcon | uButtons |
                            MB_APPLMODAL | MB_SETFOREGROUND | 
                            ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0) );

        LocalFree( szMessage );

        return nReturn;
    } else {
        return MB_OK;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       DisplayFieldErrorMsg                                        *
//*                                                                         *
//* SYNOPSIS:   Pops up a warning message about a field, sets focus to the  *
//*             field and selects any text in it.                           *
//*                                                                         *
//* REQUIRES:   hDlg:           parent windows                              *
//*             uCtrlID:        ID of control left blank                    *
//*             uStrID:         ID of string resource with warning message  *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DisplayFieldErrorMsg( HWND hDlg, UINT uCtrlID, UINT uStrID )
{
    ErrorMsg( hDlg, uStrID );
    SetFocus( GetDlgItem( hDlg, uCtrlID ) );
    SendDlgItemMessage( hDlg, uCtrlID, EM_SETSEL, 0, -1 );
}


//***************************************************************************
//*                                                                         *
//* NAME:       FileExists                                                  *
//*                                                                         *
//* SYNOPSIS:   Checks if a file exists.                                    *
//*                                                                         *
//* REQUIRES:   pszFilename                                                 *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if it exists, FALSE otherwise              *
//*                                                                         *
//***************************************************************************
BOOL FileExists( LPCSTR pszFilename )
{
    HANDLE hFile;

    ASSERT( pszFilename );

    hFile = CreateFile( pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    CloseHandle( hFile );

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       InitBigFont                                                 *
//*                                                                         *
//* SYNOPSIS:   Sets the font of the specifed control to the large (title)  *
//*             font. Creates the font if it doesn't already exist.         *
//*                                                                         *
//* REQUIRES:   hwnd:                                                       *
//*             uCtrlID:                                                    *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//* NOTES:      Make sure to call DestroyBigFont before the app exits to    *
//*             dispose of the font.                                        *
//*                                                                         *
//*             Borrowed from Win 95 setup code.                            *
//*                                                                         *
//***************************************************************************
VOID InitBigFont( HWND hwnd, UINT uCtrlID )
{
    HFONT   hFont;
    HWND    hwndCtl;
    LOGFONT lFont;
    int     nLogPixelsY;
    HDC     hDC;

    // get the window for the specified control
    if ( ( hwndCtl = GetDlgItem( hwnd, uCtrlID ) ) == NULL ) {
        return;
    }

    // get the logical y pixels
    hDC = GetDC( NULL );
    ASSERT( hDC );
    if ( !hDC ) {
        return;
    }

    nLogPixelsY = GetDeviceCaps( hDC, LOGPIXELSY );
    ReleaseDC( NULL, hDC );

    if ( ! g_hBigFont ) {
        if ( ( hFont = (HFONT) (WORD) SendMessage( hwndCtl, WM_GETFONT, 0, 0L ) ) != NULL ) {
            if ( GetObject( hFont, sizeof(LOGFONT), (LPSTR) &lFont ) ) {
                lFont.lfWeight = FW_BOLD;
                LoadString( g_hInst, IDS_MSSERIF, lFont.lfFaceName, LF_FACESIZE - 1 );
                lFont.lfHeight = -1 * ( nLogPixelsY * LARGE_POINTSIZE / 72 );

                g_hBigFont = CreateFontIndirect( (LPLOGFONT) &lFont );
            }
        }
    }

    if ( g_hBigFont ) {
        SendMessage( hwndCtl, WM_SETFONT, (WPARAM) g_hBigFont, 0L );
    }
    else {
        // couldn't create font
//        DEBUGTRAP( "Couldn't create large font" );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       DestroyBigFont                                              *
//*                                                                         *
//* SYNOPSIS:   Destroys the large font used for dialog titles, if it has   *
//*             been created.                                               *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DestroyBigFont( VOID )
{
    if ( g_hBigFont ) {
        DeleteObject( g_hBigFont );
        g_hBigFont = NULL;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       EnableDlgItem                                               *
//*                                                                         *
//* SYNOPSIS:   Makes it a little simpler to enable a dialog item.          *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog handle                               *
//*             uID:            ID of control                               *
//*             fEnable:        TRUE to enable, FALSE to disable            *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successfull, FALSE otherwise        *
//*                                                                         *
//***************************************************************************
BOOL EnableDlgItem( HWND hDlg, UINT uID, BOOL fEnable )
{
    return EnableWindow( GetDlgItem( hDlg, uID ), fEnable );
}


//***************************************************************************
//*                                                                         *
//* NAME:       LoadSz                                                      *
//*                                                                         *
//* SYNOPSIS:   Loads specified string resource into buffer.                *
//*                                                                         *
//* REQUIRES:   idString:                                                   *
//*             lpszBuf:                                                    *
//*             cbBuf:                                                      *
//*                                                                         *
//* RETURNS:    LPSTR:      Pointer to the passed-in buffer.                *
//*                                                                         *
//* NOTES:      If this function fails (most likely due to low memory), the *
//*             returned buffer will have a leading NULL so it is generally *
//*             safe to use this without checking for failure.              *
//*                                                                         *
//***************************************************************************
LPSTR LoadSz( UINT idString, LPSTR lpszBuf, UINT cbBuf )
{
    ASSERT( lpszBuf );

    // Clear the buffer and load the string
    if ( lpszBuf ) {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }

    return lpszBuf;
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsDuplicate                                                 *
//*                                                                         *
//* SYNOPSIS:   Checks if a file being added to the list view is already    *
//*             in the listview.                                            *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*             nDlgItem:       ID of list view control                     *
//*             szFilename:     Name of file to check for a dupe.           *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if it's a duplicate, FALSE otherwise   *
//*                                                                         *
//***************************************************************************
BOOL WINAPI IsDuplicate( HWND hDlg, INT nDlgItem, LPSTR szFilename, BOOL chkIsListbox )
{
    INT     nItems;
    HWND    hwndFiles;
    LV_ITEM lviCheck;
    PMYITEM pItem = NULL;
    INT     nIndex;


    if ( chkIsListbox )
    {
        hwndFiles = GetDlgItem( hDlg, nDlgItem );

        nItems = ListView_GetItemCount( hwndFiles );

        for ( nIndex = 0; nIndex < nItems; nIndex += 1 )  {
            lviCheck.mask     = LVIF_PARAM;
            lviCheck.iItem    = nIndex;
            lviCheck.iSubItem = 0;
            lviCheck.lParam   = (LPARAM) pItem;

            ListView_GetItem( hwndFiles, &lviCheck );

            if ( lstrcmpi( ((PMYITEM)(lviCheck.lParam))->aszCols[0],
                           szFilename ) == 0 )
            {
                return TRUE;
            }
        }
    }
    else  // check through the file item list
    {
        pItem = GetFirstItem();
        while ( ! LastItem( pItem ) )
        {
            if ( !lstrcmpi( szFilename, GetItemSz( pItem, 0 ) ) )
            {
                return TRUE;
            }
            pItem = GetNextItem( pItem );
        }
    }
    return FALSE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       IsMyKeyExists                                               *
//*                                                                         *
//* SYNOPSIS:   Checks if a specific key in the given section and given file*
//*             is defined.  IF so, get the value.  OW return -1            *
//*                                                                         *
//*                                                                         *
//***************************************************************************

LONG IsMyKeyExists( LPCSTR lpSec, LPCSTR lpKey, LPSTR lpBuf, UINT uSize, LPCSTR lpFile )
{
    LONG lRet;

    lRet = (LONG)GetPrivateProfileString( lpSec, lpKey, SYS_DEFAULT, lpBuf, uSize, lpFile );

    if ( lpSec && lpKey && (lRet == (LONG)(uSize-1)) || !lpKey && (lRet == (LONG)(uSize-2)) )
    {
        // not enough buffer size to read the string
        lRet = -2;
    }
    else if ( !lstrcmp( lpBuf, SYS_DEFAULT ) )
    {
         // no key defined
         lRet = -1;
    }
    return lRet;
}

ULONG FileSize( LPSTR lpFile )
{
    ULONG ulFileSize;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile;

    if ( *lpFile == 0 )
        return 0;

    hFile = FindFirstFile( lpFile, &FindFileData );
    ulFileSize = (FindFileData.nFileSizeHigh * MAXDWORD) + FindFileData.nFileSizeLow;
    FindClose( hFile );

    return ulFileSize;
}

void NotifyBadString( PCSTR pszBadname, UINT uMaxSize )
{
    char szSize[20];

    _itoa(uMaxSize, szSize, 10);
    MsgBox2Param( NULL, IDS_ERR_BADSTRING, pszBadname, szSize, MB_ICONSTOP, MB_OK );
}

//***************************************************************************
//
// FormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc, LPCSTR lpFile, UINT uSize );
//
// This function can be easily described by giving examples of what it
// does:
//        Input:  GenFormStrWithoutPlaceHolders(dest,"desc=%MS_XYZ%", hinf) ;
//                INF file has MS_VGA="Microsoft XYZ" in its [Strings] section!
//                    
//        Output: "desc=Microsoft XYZ" in buffer dest when done.
//
//
// ENTRY:
//  szDst         - the destination where the string after the substitutions
//                  for the place holders (the ones enclosed in "%' chars!)
//                  is placed. This buffer should be big enough (LINE_LEN)
//  szSrc         - the string with the place holders.
//  uSize         - the size of the output buffer
//
// EXIT:
//
// NOTES:
//  To use a '%' as such in the string, one would use %% in szSrc! BUGBUG For
//  the sake of simplicity, we have placed a restriction that the place
//  holder name string cannot have a '%' as part of it! If this is a problem
//  for internationalization, we can revisit this and support it too! Also,
//  the way it is implemented, if there is only one % in the string, it is
//  also used as such! Another point to note is that if the key is not
//  found in the [Strings] section, we just use the %strkey% as such in the
//  destination. This should really help in debugging.
//
//  BTW, CH_STRINGKEY, in the code below, is the symbolic name for '%'.
//
//  Get/modified it from setupx: gen1.c
//***************************************************************************

LONG FormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc, UINT uSize )
{
    int    uCnt ;
    LONG   lRet;
    CHAR   *pszTmp;
    LPSTR  pszSaveDst;

    pszSaveDst = szDst;
    // Do until we reach the end of source (null char)
    while( (*szDst++ = *szSrc) )
    {
        // Increment source as we have only incremented destination above
        if(*szSrc++ == CH_STRINGKEY)
        {
            if (*szSrc == CH_STRINGKEY)
            {
                // One can use %% to get a single percentage char in message
                szSrc++ ;
                continue ;
            }

            // see if it is well formed -- there should be a '%' delimiter
            if ( (pszTmp = strchr( szSrc, CH_STRINGKEY)) != NULL )
            {
                szDst--; // get back to the '%' char to replace

                // yes, there is a STR_KEY to be looked for in [Strings] sect.
                *pszTmp = '\0' ; // replace '%' with a NULL char

                // szSrc points to the replaceable key now as we put the NULL char above.

                if ( (g_szOverideCDF[0] == 0) || (g_CDF.achStrings[0] == 0) ||
                    (lRet = IsMyKeyExists( g_CDF.achStrings, szSrc, szDst, uSize, g_szOverideCDF )) == -1 )
                {
                    lRet = IsMyKeyExists( SEC_STRINGS, szSrc, szDst, uSize, g_CDF.achFilename );
                }

                if ( lRet == -1 )
                {
                    // key is missing in [Strings] section!
                    if ( MsgBox1Param( NULL, IDS_WARN_MISSSTRING, (LPSTR)szSrc, MB_ICONQUESTION, MB_YESNO ) == IDNO )
                        return lRet;

                    *pszTmp = CH_STRINGKEY;      // put back original character
                    szSrc-- ;                    // get back to first '%' in Src
                    uCnt = (INT)((pszTmp - szSrc) + 1); // include 2nd '%'

                    // UGHHH... It copies 1 less byte from szSrc so that it can put
                    // in a bad NULL character, that I don't care about!!!
                    // Different from the normal API I am used to...
                    lstrcpyn( szDst, szSrc, uCnt + 1 ) ;
                }
                else if ( lRet == -2 )
                {
                    NotifyBadString( szSrc, uSize );
                    return lRet;
                }
                else
                {
                    // all was well, Dst filled right, but unfortunately count not passed
                    // back, like it used too... :-( quick fix is a lstrlen()...
                    uCnt = lstrlen( szDst ) ;
                }

                *pszTmp = CH_STRINGKEY  ; // put back original character
                szSrc = pszTmp + 1 ;      // set Src after the second '%'
                szDst += uCnt ;           // set Dst also right.
            }
            // else it is ill-formed -- we use the '%' as such!
            else
            {
                if ( MsgBox1Param( NULL, IDS_ERR_READ_CDF, (LPSTR)(szSrc - 1), MB_ICONQUESTION, MB_YESNO ) == IDNO )
                    return -1;
            }
        }

    } /* while */
    return lstrlen(pszSaveDst);

} /* GenFormStrWithoutPlaceHolders */

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileString                                   *
//*                                                                         *
//* SYNOPSIS:   get key string vale from overide CDF if exists. Otherwise,  *
//*             get it from Main CDF. And expand to its real string value   *
//*             return -1 if key-string define error and user stops         *
//*                                                                         *
//***************************************************************************

LONG MyGetPrivateProfileString( LPCSTR lpSec, LPCSTR lpKey, LPCSTR lpDefault,
                                LPSTR lpBuf, UINT uSize, LPCSTR lpOverSec )
{
    PSTR pszNewLine;
    LONG lRet;

    if ( g_szOverideCDF[0] == 0 || *lpOverSec == 0 ||
         (lRet= IsMyKeyExists( lpOverSec, lpKey, lpBuf, uSize, g_szOverideCDF )) == -1 )
    {
        lRet = (LONG)GetPrivateProfileString( lpSec, lpKey, lpDefault, lpBuf, uSize, g_CDF.achFilename );
    }

    if ( lpKey == NULL )
    {
        return lRet;
    }

    pszNewLine = (LPSTR)LocalAlloc( LPTR, uSize );
    if ( pszNewLine )
    {
        lRet = FormStrWithoutPlaceHolders( pszNewLine, lpBuf, uSize );
        if ( lRet >= 0 )
            lstrcpy( lpBuf, pszNewLine );

        LocalFree( pszNewLine );
    }

    return lRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileInt                                      *
//*                                                                         *
//* SYNOPSIS:   get key INT vale from overide CDF if exists. Otherwise,     *
//*             get it from Main CDF. And expand to its real string value   *
//*                                                                         *
//***************************************************************************

UINT MyGetPrivateProfileInt( LPCSTR lpSec, LPCSTR lpKey, int idefault, LPCSTR lpOverSec )
{
    UINT uRet = 999;    // means not valid value

    if ( g_szOverideCDF[0] && *lpOverSec )
         uRet = GetPrivateProfileInt( lpOverSec, lpKey, 999, g_szOverideCDF );

    if ( uRet == 999 )
        uRet = GetPrivateProfileInt( lpSec, lpKey, idefault, g_CDF.achFilename );

    return uRet;

}

//***************************************************************************
//*                                                                         *
//* NAME:       MyGetPrivateProfileSection                                  *
//*                                                                         *
//* SYNOPSIS:   get section from overide CDF if exists. Otherwise,          *
//*             get it from Main CDF.                                       *
//*                                                                         *
//***************************************************************************

LONG MyGetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, int size, BOOL bSingleCol )
{
    LONG lRet;


    if ( g_szOverideCDF[0] == 0 || (lRet=RO_GetPrivateProfileSection( lpSec, lpBuf, size, g_szOverideCDF, bSingleCol )) == 0 )
    {
        lRet = RO_GetPrivateProfileSection( lpSec, lpBuf, size, g_CDF.achFilename, bSingleCol );
    }
    return lRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MyWritePrivateProfileString                                 *
//*                                                                         *
//* SYNOPSIS:   Write out all String value Key in its localizable format    *
//*             %...% If previouse keyname=%used-define% exists, reuse      *
//*             user-define as key in Strings section.  Otherwise, use      *
//*             %keyname% and define keyname in Strings section             *
//*                                                                         *
//***************************************************************************

void MyWritePrivateProfileString( LPCSTR lpSec, LPCSTR lpKey, LPSTR lpBuf, UINT uSize, BOOL fQuotes )
{
    CHAR   szTmpBuf[MAX_PATH];
    LPSTR   pszTmpBuf2 = NULL;
    BOOL    fUseDefault;

	pszTmpBuf2 = (LPSTR)LocalAlloc( LPTR, uSize+32 );
	if ( !pszTmpBuf2 )
		return;

    // when we write the string value out, we write it in a localizable fashion
    // if the item has %strKey% format, we re-use the %strKey% as its String refer key
    // otherwise, we use %item-name% as the string refer key
    GetPrivateProfileString( lpSec, lpKey, "", szTmpBuf, uSize, g_CDF.achFilename );

    if ( (szTmpBuf[0] == CH_STRINGKEY) && (szTmpBuf[lstrlen(szTmpBuf)-1] == CH_STRINGKEY) )
    {
        szTmpBuf[lstrlen(szTmpBuf)-1] = '\0';
        fUseDefault = FALSE;
    }
    else
    {
        lstrcpy( szTmpBuf, "%" );
        lstrcat( szTmpBuf, lpKey );
        lstrcat( szTmpBuf, "%" );
        WritePrivateProfileString( lpSec, lpKey, szTmpBuf, g_CDF.achFilename );
        fUseDefault = TRUE;
    }

    if ( fQuotes ) {
        lstrcpy( pszTmpBuf2, "\"" );
        lstrcat( pszTmpBuf2, lpBuf );
        lstrcat( pszTmpBuf2, "\"" );
    } else {
        lstrcpy( pszTmpBuf2, lpBuf );
    }

    WritePrivateProfileString( SEC_STRINGS, fUseDefault?lpKey:(szTmpBuf+1), pszTmpBuf2, g_CDF.achFilename );

	if ( pszTmpBuf2 )
		LocalFree( pszTmpBuf2 );

    return;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanStringKey                                              *
//*                                                                         *
//* SYNOPSIS:   Cleanup the leftover File%d stuff in Strings                *
//*                                                                         *
//***************************************************************************

void CleanStringKey( LPSTR lpstrKey )
{
    LPSTR pszTmp;

    if ( lpstrKey == NULL )
        return;

    while ( *lpstrKey )
    {
       if ( *lpstrKey++ == CH_STRINGKEY )
       {
           if (*lpstrKey == CH_STRINGKEY)
           {
               // One can use %% to get a single percentage char in message
               lpstrKey++ ;
               continue ;
           }

           // see if it is well formed -- there should be a '%' delimiter
           if ( (pszTmp = strchr( lpstrKey, CH_STRINGKEY)) != NULL )
           {
               // yes, there is a STR_KEY to be looked for in [Strings] sect.
               *pszTmp = '\0' ; // replace '%' with a NULL char
               WritePrivateProfileString( SEC_STRINGS, lpstrKey, NULL, g_CDF.achFilename);
               *pszTmp = CH_STRINGKEY;
               lpstrKey = pszTmp+1;
           }
           else
               break;
       }
    }

}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanupSection                                              *
//*                                                                         *
//* SYNOPSIS:   Cleanup the any given section with key=%xxxx% and its       *
//*             strings                                                     *
//*                                                                         *
//***************************************************************************

BOOL CleanupSection( LPSTR lpSec, BOOL fSingleCol )
{
    LPSTR  lpBuf, lpSave;
    CHAR   szStrKey[SMALL_BUF_LEN];
    int     size;

    size = FileSize( g_CDF.achFilename );
    lpBuf = (LPSTR) LocalAlloc( LPTR, size );
    if ( !lpBuf )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    lpSave = lpBuf;
    if ( fSingleCol )
        RO_GetPrivateProfileSection( lpSec, lpBuf, size, g_CDF.achFilename, TRUE );
    else
        GetPrivateProfileString( lpSec, NULL, "", lpBuf, size, g_CDF.achFilename );


    while ( *lpBuf )
    {
        if ( fSingleCol )
            CleanStringKey( lpBuf );
        else
        {
            GetPrivateProfileString( lpSec, lpBuf, "", szStrKey, sizeof(szStrKey), g_CDF.achFilename );
            CleanStringKey( szStrKey );
        }

        lpBuf += lstrlen(lpBuf);
        lpBuf++; //jump over the single '\0'
    }

    WritePrivateProfileString( lpSec, NULL, NULL, g_CDF.achFilename );
    LocalFree( lpSave );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanSourceFiles                                            *
//*                                                                         *
//* SYNOPSIS:   Cleanup the leftover SourceFile%d stuff                     *
//*                                                                         *
//***************************************************************************

BOOL CleanSourceFiles( LPSTR lpSection )
{
    LPSTR  lpBuf, lpSave;
    int     size;

    size = FileSize( g_CDF.achFilename );
    lpBuf = (LPSTR) LocalAlloc( LPTR, size );
    if ( !lpBuf )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    lpSave = lpBuf;

    GetPrivateProfileString( lpSection, NULL, "", lpBuf, size, g_CDF.achFilename );

    while ( *lpBuf )
    {
        if ( !CleanupSection( lpBuf, TRUE ) )
        {
            LocalFree( lpSave );
            return FALSE;
        }

        lpBuf += (lstrlen(lpBuf) + 1);
    }
    WritePrivateProfileString( lpSection, NULL, NULL, g_CDF.achFilename );
    LocalFree( lpSave );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MergerSection                                               *
//*                                                                         *
//***************************************************************************

BOOL MergeSection( LPSTR lpSec, LPSTR lpOverideSec )
{
    // always merge the lpOverideSec keys to lpSec
    LPSTR lpBuf, lpSave;
    CHAR  szValue[MAX_PATH];
    int    size;

    size =  __max( FileSize( g_CDF.achFilename ), FileSize( g_szOverideCDF ) ) ;
    lpBuf = (LPSTR) LocalAlloc( LPTR, size );
    if ( !lpBuf )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    lpSave = lpBuf;

    GetPrivateProfileString( lpOverideSec, NULL, "", lpBuf, size, g_szOverideCDF );

    while ( *lpBuf )
    {
        if ( MyGetPrivateProfileString( lpSec, lpBuf, "", szValue, sizeof(szValue), lpOverideSec ) == -1 )
        {
            LocalFree( lpSave );
            return FALSE;
        }

        MyWritePrivateProfileString( lpSec, lpBuf, szValue, sizeof(szValue), FALSE );

        lpBuf += (lstrlen(lpBuf) + 1);
    }

    LocalFree( lpSave );
    return TRUE;

}

//   If the next token in *pszData is delimited by the DeLim char, replace DeLim
//   in *pszData by chEos, set *pszData to point to the char after the chEos and return
//   ptr to the beginning of the token; otherwise, return NULL
//
LPSTR GetNextToken(LPSTR *pszData, char DeLim)
{
    LPSTR szPos;

    if (pszData == NULL  ||  *pszData == NULL  ||  **pszData == 0)
        return NULL;

    if ((szPos = strchr(*pszData, DeLim)) != NULL)
    {
        LPSTR szT = *pszData;

        *pszData = CharNext(szPos);
        *szPos = '\0';              
        szPos = szT;
    }
    else                          
    {
        szPos = *pszData;
        *pszData = szPos + lstrlen(szPos);
    }

    return szPos;
}


void SetVerUnlimit( PVERRANGE pVer )
{
    pVer->toVer.dwMV = MAX_TARGVER;
    pVer->toVer.dwLV = MAX_TARGVER;
    pVer->toVer.dwBd = MAX_TARGVER;
}



// given the str version range:  ver1-ver2
void SetVerRange( PVERRANGE pVR, LPSTR pstrVer, BOOL bFile )
{     
    LPSTR pTmp, pArg, pSubArg;
    DWORD dwVer[4];
    int   i, j;
    BOOL  bSingleVer;

    pArg = pstrVer;
    bSingleVer = strchr( pstrVer, '-' ) ? FALSE : TRUE;
    for ( i=0; i<2; i++ )
    {
        pTmp = GetNextToken( &pArg, '-' );

        if ( !pTmp ) 
        {
            if ( !bSingleVer )
            {
                // case1 -4.0.0  == 0.0.0-4.0.0
                // case2 4.0.0-  == 4.0.0-NoLimit
                //
                if ( i == 0 )
                    continue;
                else
                    SetVerUnlimit( pVR ); 
            }
            break;
        }

        for ( j=0; j<4; j++ )
        {
            dwVer[j] = strtoul( pTmp, &pSubArg, 10 );
            pTmp = CharNext(pSubArg);
        }

        if ( bFile )
        {
            DWORD dwMV, dwLV;

            dwMV = MAKELONG( (WORD)dwVer[1], (WORD)dwVer[0] );
            dwLV = MAKELONG( (WORD)dwVer[3], (WORD)dwVer[2] );

            if ( i == 0 )
            {
                pVR->frVer.dwMV = dwMV;
                pVR->frVer.dwLV = dwLV;
            }
            else
            {
                pVR->toVer.dwMV = dwMV;
                pVR->toVer.dwLV = dwLV;
            }
        }
        else
        {                           
            if ( i == 0 )  // start version (from version)
            {         
                pVR->frVer.dwMV = dwVer[0];
                pVR->frVer.dwLV = dwVer[1];
                pVR->frVer.dwBd = dwVer[2];
            }
            else
            {
                pVR->toVer.dwMV = dwVer[0];
                pVR->toVer.dwLV = dwVer[1];
                pVR->toVer.dwBd = dwVer[2];
            }
        }
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetTargetVerCheck                                           *
//*                                                                         *
//* SYNOPSIS:   Get author specifined target versions                       *
//*                                                                         *
//***************************************************************************

BOOL ParseTargetVerCheck( LPSTR szBuf, PVERCHECK pVerCheck, LPSTR szMsg, BOOL bFile)
{
    int i, j;
    LPSTR pArg, pSubArg, pTmp;
    DWORD dwVer[4];

    *szMsg = 0;
    if ( szBuf[0] == 0 )
    {
        // this is the case that no versions are specified, meaning applying to all
        SetVerUnlimit( &(pVerCheck->vr[0]) );
        return TRUE;
    }
    
    // the loop for possible 3 fields: <ver range> : str : flags
    //
    pArg = szBuf;
    for ( i=0; i<3; i++ )
    {
        pTmp = GetNextToken( &pArg, ':' );

        if ( !pTmp )
            break;
        else if ( *pTmp == 0 )
        {
            if ( i == 0 )             
            {
                // empty version range field no bother further!
                SetVerUnlimit( &(pVerCheck->vr[0]) );
                break;
            }
            continue;
        }

        if ( i == 0 )
        {
            LPSTR pRange;

            // version range format:  ver1-ver2 , ver1-ver2 : 
            //
            for ( j = 0; j<2; j++)
            {
                pRange = GetNextToken( &pTmp, ',' );

                if ( !pRange )
                    break;
                else if ( *pRange == 0 ) 
                    continue;
                else
                    SetVerRange( &(pVerCheck->vr[j]), pRange, bFile );
            }
        }
        else if ( i == 1 )
        {
            // string field        
            lstrcpy( szMsg, pTmp );                    
        }
        else
        {
            // flag field
            if ( !lstrcmpi(pTmp, FLAG_BLK) )
                pVerCheck->dwFlag |= VERCHK_OK;
            else if ( !lstrcmpi(pTmp, FLAG_PMTYN) )
                pVerCheck->dwFlag |= VERCHK_YESNO;
            else if ( !lstrcmpi(pTmp, FLAG_PMTOC) )
                pVerCheck->dwFlag |= VERCHK_OKCANCEL;
            else
            {
                ErrorMsg1Param( NULL, IDS_ERR_VCHKFLAG, pTmp );
                return FALSE;
            }
        }        
    }

    // Just in case, we broke out early or user's to-ver is empty fill with from-ver.
    //
    for ( j = 0; j<2; j++ )
    {
        if ( !pVerCheck->vr[j].toVer.dwMV && !pVerCheck->vr[j].toVer.dwLV && !pVerCheck->vr[j].toVer.dwBd )
        {
            pVerCheck->vr[j].toVer = pVerCheck->vr[j].frVer;
        }
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       OutFileListSection                                          *
//*                                                                         *
//* SYNOPSIS:   Write out the file list from the internal ItemList          *
//*                                                                         *
//***************************************************************************

BOOL OutFileListSection()
{
    PMYITEM pItem;
    LPSTR  lpFileStr;
    CHAR   szCurrSection[MAX_SECLEN];
    CHAR   szCurrFile[MAX_SECLEN];
    CHAR   szCurrSecValue[MAX_PATH];
    BOOL    fAllDone;
    int     idxSec = 0, idxFile = 0;
    LPSTR  pFileList;
    CHAR   achFilename[MAX_PATH+10];

// this will allocate enough space to build file key list
#define FILEKEYSIZE 20

    pFileList = (LPSTR) LocalAlloc( LPTR, g_CDF.cbFileListNum*FILEKEYSIZE );
    if ( !pFileList )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    do
    {
        fAllDone = TRUE;
        pItem = g_CDF.pTop;
        lpFileStr = pFileList;
        szCurrSection[0] = 0;
        *lpFileStr = '\0';

        while ( pItem )
        {
           if ( !pItem->fWroteOut )
           {
               if ( fAllDone )
                    fAllDone = FALSE;

               // if this section is not write out yet, write now
               if ( pItem->aszCols[1] && (szCurrSection[0] == 0) )
               {
                   lstrcpy( szCurrSection, KEY_FILELIST );
                   lstrcat( szCurrSection, _itoa(idxSec++, szCurrFile, 10 ) );

                   WritePrivateProfileString( g_CDF.achSourceFile, szCurrSection, pItem->aszCols[1], g_CDF.achFilename );
                   lstrcpy( szCurrSecValue, pItem->aszCols[1] );
               }

               if ( !lstrcmpi( szCurrSecValue,  pItem->aszCols[1] ) )
               {
                   pItem->fWroteOut = TRUE;
                   wsprintf( szCurrFile, KEY_FILEBASE, idxFile++ );
                   lstrcpy( achFilename, pItem->aszCols[0] );
                   MyWritePrivateProfileString( SEC_STRINGS, szCurrFile, achFilename, sizeof(achFilename), TRUE );
                   // build file list of this section
                   lstrcpy( lpFileStr, "%" );
                   lstrcat( lpFileStr, szCurrFile );
                   lstrcat( lpFileStr, "%=" );

                   lpFileStr += lstrlen(lpFileStr);
                   lpFileStr++; // jump over the '\0'
               }
           }
           pItem = pItem->Next;
        }

        if ( !fAllDone )
        {
            *lpFileStr = '\0';
            WritePrivateProfileSection( szCurrSection, pFileList, g_CDF.achFilename );
        }

    } while ( !fAllDone );

    LocalFree( pFileList );
    return TRUE;
}

// return the number of entries in the section
//
DWORD GetSecNumLines( LPCSTR pSec, LPCSTR pFile )
{
    char    szBuf[MAX_PATH];
    DWORD   dwNum = 0;
    int     i = 0;
    
    GetPrivateProfileString( pSec, NULL, "", szBuf, sizeof(szBuf), pFile );
    while ( szBuf[i] )
    {
        dwNum++;
        i += lstrlen( &szBuf[i] );
        i++;  // jump over the fence
    }

    return dwNum;
}
    
// check if need to alloc and how much is needed
//
BOOL AllocTargetVerInfo( LPSTR pInfFile )
{
    char    achBuf[MAX_INFLINE];
    DWORD   dwNumFiles = 0;
    BOOL    bRet = TRUE;
    DWORD   dwSize;

    if ( IsMyKeyExists( SEC_OPTIONS, KEY_SYSFILE, achBuf, sizeof(achBuf), pInfFile ) != -1 )
    {
        if (achBuf[0] == '@')
        {
            // process the file section
            dwNumFiles = GetSecNumLines( &achBuf[1], pInfFile );
        }
        else
            dwNumFiles = 1;
    }


    if ( dwNumFiles || 
         (IsMyKeyExists( SEC_OPTIONS, KEY_NTVERCHECK, achBuf, sizeof(achBuf), pInfFile ) != -1) ||
         (IsMyKeyExists( SEC_OPTIONS, KEY_WIN9XVERCHECK, achBuf, sizeof(achBuf), pInfFile ) != -1) )         
    {
        // alloc structure: fixed potion, Message string pool and variable number of filever check struct
        //
        dwSize = sizeof(TARGETVERINFO) + (3*MAX_PATH) + (sizeof(VERCHECK) + MAX_PATH)*dwNumFiles;
        if ( g_CDF.pVerInfo = (PTARGETVERINFO)LocalAlloc( LPTR, dwSize )  )
        {
            g_CDF.pVerInfo->dwNumFiles = dwNumFiles;
        }
        else
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            bRet = FALSE;
        }        
    }

    return bRet;
}

void SetAuthorStr( LPCSTR szMsg, DWORD *pdwOffset )
{   
    int     len = 0;
    LPSTR   pTmp;
    BOOL    bDup = FALSE;

    if ( szMsg[0] )
    {
        pTmp = &(g_CDF.pVerInfo->szBuf[1]);
        // there is an author defined message
        while ( pTmp && *pTmp )
        {
            if ( !lstrcmpi( pTmp, szMsg ) )
            {
                bDup = TRUE;
                break;
            }
            len = (lstrlen( pTmp )+1);
            pTmp += len;
        }

        if ( pTmp )
        {
            // only store the offset to szBuf 
            *pdwOffset = (DWORD)(pTmp - g_CDF.pVerInfo->szBuf);            

            if ( !bDup )
            {
                // meaning there is no existing one!
                // 
                lstrcpy( pTmp, szMsg );
                
                // store the end of the last string data offset
                g_CDF.pVerInfo->dwFileOffs = *pdwOffset + lstrlen(pTmp) + 1;
            }

        }
    }
}
 

BOOL ParseTargetFiles( LPCSTR pBuf, PVERCHECK pVer )
{
    LPSTR lpTmp1, lpTmp2;
    BOOL  bRet = FALSE;
    char  szPath[MAX_PATH];

    lpTmp1 = strchr( pBuf, ':' );
    if ( lpTmp1 )
    {
        char ch = (char)toupper(pBuf[1]);

        lpTmp2 = CharNext( lpTmp1 );
        *(lpTmp1) = '\0';
        if ( (pBuf[0] == '#') && ( (ch == 'S') || (ch == 'W') || (ch == 'A') ) )
        {
            if ( ParseTargetVerCheck( lpTmp2, pVer, szPath, TRUE ) )
            {               
                SetAuthorStr( szPath, &(pVer->dwstrOffs) );
                SetAuthorStr( pBuf, &(pVer->dwNameOffs) );
                bRet = TRUE;
            }
        }        
    }

    return bRet;
}

//***************************************************************************
//*                                                                         *
//* NAME:       WriteCDF                                                    *
//*                                                                         *
//* SYNOPSIS:   Write a CABPack Directive File. Uses information from       *
//*             Global CDF structure (g_CDF).                               *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************

BOOL WriteCDF( HWND hDlg )
{
    CHAR    achBuf[2 * MAX_PATH];
    int      i, arraySize;

    // write class name.
    WritePrivateProfileString( SEC_VERSION, KEY_CLASS, IEXPRESS_CLASS, g_CDF.achFilename );

    // delete the old CDFVersion= line and add SEFVersion= line
    WritePrivateProfileString( SEC_VERSION, KEY_VERSION, NULL, g_CDF.achFilename );
    WritePrivateProfileString( SEC_VERSION, KEY_NEWVER, IEXPRESS_VER, g_CDF.achFilename );

    // Write the config info, numeric value.

    // if user has old ExtractOnly key, delete it first and re-create the new key PackagePurpose instead
    WritePrivateProfileString( SEC_OPTIONS, KEY_EXTRACTONLY, NULL, g_CDF.achFilename );

    switch ( g_CDF.uPackPurpose )
    {
        case IDC_CMD_RUNCMD:
        default:
            lstrcpy( achBuf, STR_INSTALLAPP );
            break;

        case IDC_CMD_EXTRACT:
            lstrcpy( achBuf, STR_EXTRACTONLY );
            break;

        case IDC_CMD_CREATECAB:
            lstrcpy( achBuf, STR_CREATECAB );
            break;
    }
    WritePrivateProfileString( SEC_OPTIONS, KEY_PACKPURPOSE, achBuf, g_CDF.achFilename );

    WritePrivateProfileString( SEC_OPTIONS, KEY_SHOWWIN, _itoa(g_CDF.uShowWindow, achBuf,10), g_CDF.achFilename );

    WritePrivateProfileString( SEC_OPTIONS, KEY_NOEXTRACTUI, _itoa( (g_CDF.uExtractOpt&EXTRACTOPT_UI_NO)?1:0, achBuf, 10), g_CDF.achFilename );
    WritePrivateProfileString( SEC_OPTIONS, KEY_USELFN, _itoa( (g_CDF.uExtractOpt&EXTRACTOPT_LFN_YES)?1:0, achBuf, 10), g_CDF.achFilename );
    WritePrivateProfileString( SEC_OPTIONS, KEY_NESTCOMPRESSED, _itoa( (g_CDF.uExtractOpt&EXTRACTOPT_COMPRESSED)?1:0, achBuf, 10), g_CDF.achFilename );

    WritePrivateProfileString( SEC_OPTIONS, KEY_CABFIXEDSIZE,
                               _itoa( (g_CDF.uExtractOpt & CAB_FIXEDSIZE)?1:0, achBuf, 10), g_CDF.achFilename );

    if ( g_CDF.uExtractOpt & CAB_RESVSP2K )
        i = 1;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP4K )
        i = 2;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP6K )
        i = 3;
    else
        i = 0;

    lstrcpy( achBuf, pResvSizes[i] );
    WritePrivateProfileString( SEC_OPTIONS, KEY_CABRESVCODESIGN, achBuf, g_CDF.achFilename );

    // get reboot settings
    achBuf[0] = 0;
    if ( g_CDF.dwReboot & REBOOT_YES )
    {
        if ( g_CDF.dwReboot & REBOOT_ALWAYS )
            lstrcpy( achBuf, "A" );
        else
            lstrcpy( achBuf, "I" );

        if ( g_CDF.dwReboot & REBOOT_SILENT )
            lstrcat( achBuf, "S" );
    }
    else
        lstrcpy( achBuf, "N" );

    WritePrivateProfileString( SEC_OPTIONS, KEY_REBOOTMODE, achBuf, g_CDF.achFilename );

    arraySize = ARRAY_SIZE( CDFStrInfo );
    // Start writting out the string value
    for ( i = 0; i < arraySize; i++ )
    {
        if ( CDFStrInfo[i].lpFlag )
        {
            if ( *CDFStrInfo[i].lpFlag )
            {
                MyWritePrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, CDFStrInfo[i].lpBuf, CDFStrInfo[i].uSize, FALSE );
            }
            else
                MyWritePrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, (LPSTR)CDFStrInfo[i].lpDef, CDFStrInfo[i].uSize, FALSE );

        }
        else
            MyWritePrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, CDFStrInfo[i].lpBuf, CDFStrInfo[i].uSize, FALSE );
    }

    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
    {
        MyWritePrivateProfileString( SEC_OPTIONS, KEY_LAYOUTINF, g_CDF.achINF, sizeof(g_CDF.achINF), FALSE );
        MyWritePrivateProfileString( SEC_OPTIONS, KEY_CABLABEL, g_CDF.szCabLabel, sizeof(g_CDF.szCabLabel), FALSE );
    }

    // read in the exist one first
    GetVersionInfoFromFile();

    // cleanup VerInfo left over if needed
    if ( GetPrivateProfileString( SEC_OPTIONS, KEY_VERSIONINFO, "", achBuf, sizeof(achBuf), g_CDF.achFilename ) )
    {
        if ( lstrcmpi( achBuf, g_CDF.achVerInfo) )
        {
            if ( !CleanupSection( achBuf, FALSE) )
            {
                return FALSE;
            }
        }
    }

    // write Version information overwite section
    if ( g_CDF.achVerInfo[0] )
    {
        WritePrivateProfileString( SEC_OPTIONS, KEY_VERSIONINFO, g_CDF.achVerInfo, g_CDF.achFilename );
        if ( !MergeSection( g_CDF.achVerInfo, g_CDF.achVerInfo ) )
            return FALSE;
    }

    // if current SourceFiles has different name than the main CDF defined, clean the old one first
    if ( GetPrivateProfileString( SEC_OPTIONS, KEY_FILELIST, "", achBuf, sizeof(achBuf), g_CDF.achFilename ) )
    {
        if ( !CleanSourceFiles( achBuf ) )
            return FALSE;
    }

    WritePrivateProfileString( SEC_OPTIONS, KEY_FILELIST, g_CDF.achSourceFile, g_CDF.achFilename );
    // write the file list section
    return ( OutFileListSection() );
}


//***************************************************************************
//*                                                                         *
//* NAME:       ReadCDF                                                     *
//*                                                                         *
//* SYNOPSIS:   Read a CABPack Directive File into the Global CDF struct.   *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL ReadCDF( HWND hDlg )
{
    CHAR    achBuf[2 * MAX_PATH];
    LPSTR   lpSave1=NULL, lpSave2=NULL;
    LPSTR   szFileList=NULL, szFileListKeys=NULL;
    ULONG   ulFileSize, uData;
    PMYITEM pMyItem;
    CHAR    szPath[MAX_PATH];
    int     i, arraySize;
    LONG    lRet;
    BOOL    bRetVal = FALSE;
    UINT    uErrid = 0;

    achBuf[0] = '\0';
    szPath[0] = '\0';

    if ( !FileExists(g_CDF.achFilename) )
    {
        uErrid = IDS_ERR_OPEN_CDF;
        goto EXIT;
    }

    // Check to make sure it's a CDF file.
    if ( MyGetPrivateProfileString( SEC_VERSION, KEY_CLASS, "", achBuf, sizeof(achBuf), g_szOverideSec ) < 0 )
        goto EXIT;

    if ( lstrcmpi( achBuf, "IEXPRESS" ) != 0 )
    {
        uErrid = IDS_ERR_CLASSNAME;
        goto EXIT;
    }
    
    if ( !AllocTargetVerInfo( g_CDF.achFilename ) )
        goto EXIT;
    
    // get string section name from overideCDF if there
    if ( g_szOverideCDF[0] && g_szOverideSec[0] )
    {
        if ( !AllocTargetVerInfo( g_szOverideCDF ) )
            goto EXIT;

        GetPrivateProfileString( g_szOverideSec, KEY_STRINGS, SEC_STRINGS, g_CDF.achStrings, sizeof(g_CDF.achStrings), g_szOverideCDF );
    }

    // Read the config info INT vaules.

    // If old ExtractOnly key exists, read it for compatiable purpose.
    // IExpress will never create both OLD and NEW keys.
    // If Old ExtractOnly key is not set to 1 or does not exist, read the New key.
    //
    if (  MyGetPrivateProfileInt( SEC_OPTIONS, KEY_EXTRACTONLY, 0, g_szOverideSec ) )
    {
        g_CDF.uPackPurpose = IDC_CMD_EXTRACT;
    }
    else
    {
        // if the old key is not set, check the new key
        //
        MyGetPrivateProfileString( SEC_OPTIONS, KEY_PACKPURPOSE, STR_INSTALLAPP, achBuf, sizeof(achBuf), g_szOverideSec );

        if ( !lstrcmpi( achBuf, STR_INSTALLAPP ) )
        {
            g_CDF.uPackPurpose = IDC_CMD_RUNCMD;
        }
        else if ( !lstrcmpi( achBuf, STR_EXTRACTONLY) )
        {
            g_CDF.uPackPurpose = IDC_CMD_EXTRACT;
        }
        else
            g_CDF.uPackPurpose = IDC_CMD_CREATECAB;
    }

    g_CDF.uShowWindow = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_SHOWWIN, 0, g_szOverideSec );

    g_CDF.uExtractOpt = 0;
    arraySize = ARRAY_SIZE( CDFOptInfo );
    // Start writting out the string value
    for ( i = 0; i < arraySize; i++ )
    {
        uData = MyGetPrivateProfileInt( SEC_OPTIONS, CDFOptInfo[i].lpKey, 0, g_szOverideSec );
        if ( uData )
        {
            g_CDF.uExtractOpt |= CDFOptInfo[i].dwOpt;
        }
    }

    // get OneInstance check info
    MyGetPrivateProfileString( SEC_OPTIONS, KEY_INSTANCECHK, "", achBuf, sizeof(achBuf), g_szOverideSec );
    switch ( toupper( achBuf[0]) )
    {
        case 'P':
            g_CDF.uExtractOpt |= EXTRACTOPT_INSTCHKPROMPT;
            break;

        case 'B':
            g_CDF.uExtractOpt |= EXTRACTOPT_INSTCHKBLOCK;
            break;

        default:
            break;
    }

    if ( (g_CDF.uExtractOpt & EXTRACTOPT_INSTCHKPROMPT) ||
         (g_CDF.uExtractOpt & EXTRACTOPT_INSTCHKBLOCK) )
    {
        if ( !(lpSave1 = strchr( achBuf, '"' )) )
        {
            uErrid = IDS_ERR_COOKIE;
            goto EXIT;
        }

        lpSave2 = strchr( ++lpSave1, '"' );
        if ( lpSave2 )
        {
            *lpSave2 = '\0';
            g_CDF.lpszCookie = (LPSTR)LocalAlloc( LPTR, lstrlen(lpSave1)+1 );
            if ( g_CDF.lpszCookie )
            {
                lstrcpy( g_CDF.lpszCookie, lpSave1 );
            }
            else
            {
                uErrid = IDS_ERR_NO_MEMORY;
                goto EXIT;
            }
        }
        else
        {
           uErrid = IDS_ERR_COOKIE;
           goto EXIT;
        }
    }

    uData = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_CABFIXEDSIZE, 0, g_szOverideSec );
    if ( uData )
    {
        g_CDF.uExtractOpt |= CAB_FIXEDSIZE;
    }

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_LAYOUTINF, "", g_CDF.achINF, sizeof(g_CDF.achINF), g_szOverideSec );
    MyGetPrivateProfileString( SEC_OPTIONS, KEY_CABLABEL, CAB_DEFSETUPMEDIA, g_CDF.szCabLabel, sizeof(g_CDF.szCabLabel), g_szOverideSec );

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_CABRESVCODESIGN, CAB_6K, achBuf, sizeof(achBuf), g_szOverideSec );
    if ( !lstrcmpi(achBuf, pResvSizes[1]) )
        g_CDF.uExtractOpt |= CAB_RESVSP2K;
    else if ( !lstrcmpi(achBuf, pResvSizes[2]) )
        g_CDF.uExtractOpt |= CAB_RESVSP4K;
    else if ( !lstrcmpi(achBuf, pResvSizes[3]) )
        g_CDF.uExtractOpt |= CAB_RESVSP6K;

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_COMPRESSTYPE, "", achBuf, sizeof(achBuf), g_szOverideSec );
    if ( achBuf[0] == 0 )
    {
        // Get the compression type:  For MS Internal, "QUANTUM=value" can be set.
        g_CDF.uCompressionLevel = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_QUANTUM, 999, g_szOverideSec );
        if ( g_CDF.uCompressionLevel == 999 ) 
        {
            g_CDF.szCompressionType = achMSZIP;
            g_CDF.uCompressionLevel = 7;
        } 
        else
        {
            g_CDF.szCompressionType = achQUANTUM;
        }
    }
    else
    {
        if ( !lstrcmpi( achBuf, achLZX ) )
        {
            g_CDF.szCompressionType = achLZX;
        }
        else if ( !lstrcmpi( achBuf, achQUANTUM ) )
        {
            g_CDF.szCompressionType = achQUANTUM;
        }
        else if ( !lstrcmpi( achBuf, achNONE ) )
        {
            g_CDF.szCompressionType = achNONE;
        }
        else 
        {
            g_CDF.szCompressionType = achMSZIP;            
        }        

        g_CDF.uCompressionLevel = 7;
    }

    // get reboot info
    g_CDF.dwReboot = 0;
    i = 0;
    MyGetPrivateProfileString( SEC_OPTIONS, KEY_REBOOTMODE, "I", achBuf, sizeof(achBuf), g_szOverideSec );
    while ( achBuf[i] != 0 )
    {
         switch ( toupper(achBuf[i++]) )
         {
             case 'A':
                 g_CDF.dwReboot |= REBOOT_ALWAYS;
                 g_CDF.dwReboot |= REBOOT_YES;
                 break;

             case 'S':
                 g_CDF.dwReboot |= REBOOT_SILENT;
                 break;

             case 'N':
                 g_CDF.dwReboot &= ~(REBOOT_YES);
                 break;

             case 'I':
                 g_CDF.dwReboot &= ~(REBOOT_ALWAYS);
                 g_CDF.dwReboot |= REBOOT_YES;
                 break;

             default:
                 break;
         }
    }

    // get package install space
    g_CDF.cbPackInstSpace = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_PACKINSTSPACE, 0, g_szOverideSec );

    // use CDFStrInfo table to do read for a list of key strings
    arraySize = ARRAY_SIZE( CDFStrInfo );
    for ( i=0; i<arraySize; i++ )
    {
        if ( MyGetPrivateProfileString( CDFStrInfo[i].lpSec, CDFStrInfo[i].lpKey, 
                                             CDFStrInfo[i].lpDef, CDFStrInfo[i].lpBuf, 
                                             CDFStrInfo[i].uSize, CDFStrInfo[i].lpOverideSec ) < 0 )
            goto EXIT;

        if ( CDFStrInfo[i].lpFlag )
        {
            if ( CDFStrInfo[i].lpBuf[0] )
                *(CDFStrInfo[i].lpFlag) = TRUE;
            else
                *(CDFStrInfo[i].lpFlag) = FALSE;
        }
    }

    // generate cab name properly!
    if ( (g_CDF.uPackPurpose == IDC_CMD_CREATECAB ) &&
          !MakeCabName( hDlg, g_CDF.achTarget, g_CDF.achCABPath ) )
          goto EXIT;

    // Read the file list, adding it to our Item list as we go along.
    if ( MyGetPrivateProfileString( SEC_OPTIONS, KEY_FILELIST, "", g_CDF.achSourceFile, sizeof(g_CDF.achSourceFile), g_szOverideSec ) <= 0 )
    {
        uErrid = IDS_ERR_NOSOURCEFILE;
        goto EXIT;
    }

    ulFileSize = __max( FileSize( g_CDF.achFilename ), FileSize( g_szOverideCDF ) );

    //BUGBUG: be smart about buf size to allocate
    szFileList = (LPSTR) LocalAlloc( LPTR, ulFileSize );
    szFileListKeys = (LPSTR) LocalAlloc( LPTR, ulFileSize );
    if ( !szFileList || !szFileListKeys )
    {
        uErrid = IDS_ERR_NO_MEMORY;
        goto EXIT;
    }

    lpSave1 = szFileList;
    lpSave2 = szFileListKeys;
    MyGetPrivateProfileString( g_CDF.achSourceFile, NULL, "", szFileListKeys, ulFileSize/2, g_CDF.achSourceFile );

    while ( *szFileListKeys )
    {
        lstrcpy( achBuf, szFileListKeys );
        szFileListKeys += lstrlen(szFileListKeys);
        szFileListKeys++;  // jump over the single '\0'

        MyGetPrivateProfileString( g_CDF.achSourceFile, achBuf, "", szPath, sizeof(szPath), g_CDF.achSourceFile );

        lRet = MyGetPrivateProfileSection( achBuf, szFileList, ulFileSize, TRUE );

        if ( lRet == 0 )
        {
            // the current CDF format is not match with OS version
            uErrid = IDS_ERR_CDFFORMAT;
            LocalFree( lpSave1 );
            LocalFree( lpSave2 );
            goto EXIT;
        }
        else if ( lRet < 0 )
        {
            uErrid = IDS_ERR_INVALID_CDF;
            LocalFree( lpSave1 );
            LocalFree( lpSave2 );
            goto EXIT;
        }

        // make sure there is a '\' at the end of path
        AddPath( szPath, "" );

        while ( *szFileList )
        {
            FormStrWithoutPlaceHolders( achBuf, szFileList, sizeof(achBuf) );

            pMyItem = AddItem( achBuf, szPath );

            szFileList += lstrlen( szFileList );
            szFileList++;  // jump over the single '\0'
        }
        szFileList = lpSave1;
    }
    LocalFree( lpSave1 );
    LocalFree( lpSave2 );

    // get the target version check info
    //
    if ( g_CDF.pVerInfo )
    {
        lRet = MyGetPrivateProfileString( SEC_OPTIONS, KEY_NTVERCHECK, "", achBuf, sizeof(achBuf), g_szOverideSec );
        if ( (lRet<0) || !ParseTargetVerCheck( achBuf, &(g_CDF.pVerInfo->ntVerCheck), szPath, FALSE ) )
        {
            goto EXIT;
        }
        SetAuthorStr( szPath, &(g_CDF.pVerInfo->ntVerCheck.dwstrOffs) );

        lRet = MyGetPrivateProfileString( SEC_OPTIONS, KEY_WIN9XVERCHECK, "", achBuf, sizeof(achBuf), g_szOverideSec );
        if ( (lRet < 0) || !ParseTargetVerCheck( achBuf, &(g_CDF.pVerInfo->win9xVerCheck), szPath, FALSE ) )
        {
            goto EXIT;
        }
        SetAuthorStr( szPath, &(g_CDF.pVerInfo->win9xVerCheck.dwstrOffs) );

        lRet = MyGetPrivateProfileString( SEC_OPTIONS, KEY_SYSFILE, "", achBuf, sizeof(achBuf), g_szOverideSec );
        if ( lRet < 0 )
            goto EXIT;

        if ( achBuf[0] && g_CDF.pVerInfo->dwNumFiles )
        {
            PVERCHECK pVerChk = NULL;
            
            pVerChk = (PVERCHECK) LocalAlloc( LPTR, g_CDF.pVerInfo->dwNumFiles * (sizeof(VERCHECK)) );
            if ( !pVerChk )
            {
                uErrid = IDS_ERR_NO_MEMORY;
                goto EXIT;
            }

            if ( achBuf[0] == '@' )
            {
                char szLine[MAX_PATH];
                PVERCHECK pVerTmp;

                i = 0;

                pVerTmp = pVerChk;
                MyGetPrivateProfileString( &achBuf[1], NULL, "", szPath, sizeof(szPath), g_szOverideSec );
                while ( szPath[i] )
                {
                    MyGetPrivateProfileString( &achBuf[1], &szPath[i], "", szLine, sizeof(szLine), g_szOverideSec );
                    if ( !ParseTargetFiles( szLine, pVerTmp ) )
                    {
                        LocalFree( pVerChk );
                        uErrid = IDS_ERR_VCHKFILE;
                        goto EXIT;
                    }
                    
                    pVerTmp++;
                    i += lstrlen( &szPath[i] ) + 1;
                }
            }
            else if ( !ParseTargetFiles( achBuf, pVerChk ) )
            {
                LocalFree( pVerChk );
                uErrid = IDS_ERR_VCHKFILE;
                goto EXIT;
            }
            // up to now all the strings have been processed. Put the File data into the struct
            //
            memcpy( (g_CDF.pVerInfo->szBuf + g_CDF.pVerInfo->dwFileOffs), pVerChk, g_CDF.pVerInfo->dwNumFiles * sizeof(VERCHECK) );                        
            LocalFree( pVerChk );   

        }

        g_CDF.pVerInfo->dwSize = sizeof(TARGETVERINFO) + g_CDF.pVerInfo->dwFileOffs + sizeof(VERCHECK)*g_CDF.pVerInfo->dwNumFiles;
    }

    // make sure the target file path exist
    MakeDirectory( NULL, g_CDF.achTarget, FALSE );
    
    // if it is LFN command from FileList, make it consistant with filename in the CAB
    //
    MyProcessLFNCmd( g_CDF.achOrigiInstallCmd, g_CDF.achInstallCmd );
    MyProcessLFNCmd( g_CDF.achOrigiPostInstCmd, g_CDF.achPostInstCmd );
    MyProcessLFNCmd( g_CDF.szOrigiAdmQCmd, g_CDF.szAdmQCmd );
    MyProcessLFNCmd( g_CDF.szOrigiUsrQCmd, g_CDF.szUsrQCmd );

    // after file-list has been read in
    // set EXTRACTOPT_ADVDLL if needed, shorten the command name if needed
    // if the .INF file is not from the file list, return FALSE
    //
    if ( (g_CDF.uPackPurpose == IDC_CMD_RUNCMD) && 
         ( !CheckAdvBit( g_CDF.achOrigiInstallCmd ) ||
         !CheckAdvBit( g_CDF.achOrigiPostInstCmd ) ||
         !CheckAdvBit( g_CDF.szOrigiAdmQCmd ) ||
         !CheckAdvBit( g_CDF.szOrigiUsrQCmd ) ) )
    {
        goto EXIT;
    }

    // successful path
    bRetVal = TRUE;

EXIT:
    if ( uErrid )
        ErrorMsg( hDlg, uErrid );

    return bRetVal;
}

#define MAXDISK_SIZE    "1.44M"
#define CDROM_SIZE      "CDROM"

// define

//***************************************************************************
//*                                                                         *
//* NAME:       WriteDDF                                                    *
//*                                                                         *
//* SYNOPSIS:   Writes out a Diamond Directive File.                        *
//*                                                                         *
//* REQUIRES:   hDlg:           dialog window                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL WriteDDF( HWND hDlg )
{
    HANDLE  hFile;
    DWORD   dwAttr;
    DWORD   dwBytes;
    PMYITEM pMyItem;
    CHAR   achHeader[256];
    LPSTR   szTempLine;
    BOOL    fReturn = TRUE;
    CHAR   achShortPath[MAX_PATH];
    int     i, arraySize;
    LPSTR   lpCurrLine;
    LPSTR   lpFName;

    // These are the lines that will be written out.
    CHAR achLine1[]  = ".Set CabinetNameTemplate=%s\r\n";
    CHAR achLine2[]  = ".Set CompressionType=%s\r\n";
    CHAR achLine3[]  = ".Set CompressionLevel=%u\r\n";
    CHAR achLine4[]  = ".Set InfFileName=%s\r\n";
    CHAR achLine5[]  = ".Set RptFileName=%s\r\n";
    CHAR achLine6[]  = ".Set MaxDiskSize=%s\r\n";
    CHAR achLine7[]  = ".Set ReservePerCabinetSize=%s\r\n";
    CHAR achLine8[]  = ".Set InfCabinetLineFormat=""*cab#*=""%s"",""*cabfile*"",0""\r\n";
    CHAR achLine9[]  = ".Set Compress=%s\r\n";
    CHAR achLine10[] = ".Set CompressionMemory=%d\r\n";

    PSTR  pszDDFLine[] = {         //  11 lines no param needed
                ".Set DiskDirectoryTemplate=\r\n",
                ".Set Cabinet=ON\r\n",
                ".Set MaxCabinetSize=999999999\r\n",
                ".Set InfDiskHeader=\r\n",
                ".Set InfDiskLineFormat=\r\n",
                ".Set InfCabinetHeader=""[SourceDisksNames]""\r\n",
                ".Set InfFileHeader=""""\r\n",
                ".Set InfFileHeader1=""[SourceDisksFiles]""\r\n",
                ".Set InfFileLineFormat=""*file*=*cab#*,,*size*,*csum*""\r\n",
                NULL,
                };

    hFile = CreateFile( g_CDF.achDDF, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE )  {
        ErrorMsg( hDlg, IDS_ERR_OPEN_DDF );
        return FALSE;
    }

    // allocate a working buffer once which is big enough for every line
    //
    szTempLine = (LPSTR) LocalAlloc( LPTR,  MAX_STRING );
    if ( ! szTempLine )  {
        ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
        CloseHandle( hFile );
        return FALSE;
    }

    LoadSz( IDS_DDF_HEADER, achHeader, sizeof(achHeader) );
    WriteFile( hFile, achHeader, lstrlen( achHeader ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine1, g_CDF.achCABPath );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine2, g_CDF.szCompressionType );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine3, g_CDF.uCompressionLevel );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine4, g_CDF.achINF );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine5, g_CDF.achRPT );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
        lpCurrLine = MAXDISK_SIZE;
    else
        lpCurrLine = CDROM_SIZE;

    wsprintf( szTempLine, achLine6, lpCurrLine );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    if ( g_CDF.uExtractOpt & CAB_RESVSP2K )
        i = 1;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP4K )
        i = 2;
    else if ( g_CDF.uExtractOpt & CAB_RESVSP6K )
        i = 3;
    else
        i = 0;

    wsprintf( szTempLine, achLine7, pResvSizes[i] );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    wsprintf( szTempLine, achLine8, g_CDF.szCabLabel );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    MyGetPrivateProfileString( SEC_OPTIONS, KEY_COMPRESS, "on", achShortPath, sizeof(achShortPath), g_szOverideSec );    
    wsprintf( szTempLine, achLine9, achShortPath );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    i = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_COMPRESSMEMORY, 21, g_szOverideSec );    
    if ( i <= 0 )
        i = 21;
    wsprintf( szTempLine, achLine10, i );
    WriteFile( hFile, szTempLine, lstrlen( szTempLine ), &dwBytes, NULL );

    i = 0;
    while ( pszDDFLine[i] )
    {
       WriteFile( hFile, pszDDFLine[i], lstrlen( pszDDFLine[i] ), &dwBytes, NULL );
       i++;
    }

    pMyItem = GetFirstItem();
    while ( fReturn && ! LastItem( pMyItem ) )  {

        lstrcpy( szTempLine, GetItemSz( pMyItem, 1 ) );
        lstrcat( szTempLine, GetItemSz( pMyItem, 0 ) );

        dwAttr = GetFileAttributes( szTempLine );
        if ( ( dwAttr == -1 ) || ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) )  {
            ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND2, szTempLine );
            LocalFree( szTempLine );
            CloseHandle( hFile );
            return FALSE;
        }

        if ( g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES )
        {
            lstrcpy( achShortPath, "\"" );
            lstrcat( achShortPath, szTempLine );
            lstrcat( achShortPath, "\"" );
        }
        else
        {
            if ( ! GetShortPathName( szTempLine, achShortPath,
                   sizeof(achShortPath) ) )
            {
                ErrorMsg( hDlg, IDS_ERR_SHORT_PATH );
                LocalFree( szTempLine );
                CloseHandle( hFile );
                return FALSE;
            }
        }

        WriteFile( hFile, achShortPath, lstrlen(achShortPath), &dwBytes, NULL );
        fReturn = WriteFile( hFile, "\r\n", lstrlen("\r\n"), &dwBytes, NULL );

        pMyItem = GetNextItem( pMyItem );
    }

    if ( fReturn && g_CDF.uExtractOpt & EXTRACTOPT_ADVDLL )
    {
        SYSTEM_INFO SystemInfo;
        int         ix86Processor;
        
        GetSystemInfo( &SystemInfo );
        ix86Processor = MyGetPrivateProfileInt( SEC_OPTIONS, KEY_CROSSPROCESSOR, -1, g_szOverideSec );
            
        if ( (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) && 
             (ix86Processor != 0) ||
             (SystemInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) &&
             (ix86Processor == 1) )
        {           
            arraySize = ARRAY_SIZE( AdvDlls );
        }
        else
        {
            arraySize = 1;
        }        
       
        // add 3 advanced DLLS for handling OCX regiester or CustomDestination
        for ( i = 0; (i<arraySize) && fReturn; i++ )
        {
            if ( !IsDuplicate( NULL, 0, AdvDlls[i], FALSE) )
            {
                if ( !GetFileFromModulePath( AdvDlls[i], achShortPath, sizeof(achShortPath) ) )
                {
                    ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND, achShortPath );
                    LocalFree( szTempLine );
                    CloseHandle( hFile );
                    return FALSE;
                }
                lstrcpy( szTempLine, "\"" );
                lstrcat( szTempLine, achShortPath );
                lstrcat( szTempLine, "\"" );
                WriteFile( hFile, szTempLine, lstrlen(szTempLine), &dwBytes, NULL );
                fReturn = WriteFile( hFile, "\r\n", strlen("\r\n"), &dwBytes, NULL );
            }
        }
    }

    LocalFree( szTempLine );
    CloseHandle( hFile );

    if ( fReturn == FALSE )  {
        ErrorMsg( hDlg, IDS_ERR_WRITE_DDF );
        return FALSE;
    } else  {
        return TRUE;
    }
}

//***************************************************************************
//*                                                                         *
//* NAME:       MasskePackage                                                 *
//*                                                                         *
//* SYNOPSIS:   Makes the full package (CAB and EXE).                       *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL MakePackage( HWND hDlg )
{
    CHAR   achDrive[_MAX_DRIVE];
    CHAR   achDir[_MAX_DIR];
    CHAR   achStatus[MAX_STRING];
    CHAR   szExt[6];
    BOOL    fReturn = TRUE;
    PSTR   pTmp;

    // Build the paths to the files, using the target path as a
    // template.  We create the DDF, CAB and INF file in the
    // same directory as the target file.

    _splitpath( g_CDF.achTarget, achDrive, achDir, g_CDF.achTargetBase, szExt);

    lstrcpy( g_CDF.achTargetPath, achDrive );
    lstrcat( g_CDF.achTargetPath, achDir );

    lstrcpy( g_CDF.achDDF, g_CDF.achTargetPath );
    wsprintf( achStatus, CABPACK_TMPFILE, g_CDF.achTargetBase, EXT_DDF );
    AddPath( g_CDF.achDDF, achStatus );

    if ( g_CDF.achINF[0] == 0 )
    {
        lstrcpy( g_CDF.achINF, g_CDF.achTargetPath );
        wsprintf( achStatus, CABPACK_INFFILE, g_CDF.achTargetBase );
        AddPath( g_CDF.achINF, achStatus );
    }

    lstrcpy( g_CDF.achRPT, g_CDF.achTargetPath );
    wsprintf( achStatus, CABPACK_TMPFILE, g_CDF.achTargetBase, EXT_RPT );
    AddPath( g_CDF.achRPT, achStatus );

    if ( g_CDF.uPackPurpose != IDC_CMD_CREATECAB )
    {
        wsprintf( achStatus, CABPACK_TMPFILE, g_CDF.achTargetBase, EXT_CAB );
        lstrcpy( g_CDF.achCABPath, g_CDF.achTargetPath );
        AddPath( g_CDF.achCABPath, achStatus );
        g_CDF.szCompressionType = achLZX;
        g_CDF.uCompressionLevel = 7; 
    }

    if ( g_CDF.fSave )  {
        if ( ! WriteCDF( hDlg ) )  {
            LoadSz( IDS_STATUS_ERROR_CDF, achStatus, sizeof(achStatus) );
            Status( hDlg, IDC_MEDIT_STATUS, achStatus );
            fReturn = FALSE;
            goto done;
        }
    }

    if ( ! MakeCAB( hDlg ) )  {
        LoadSz( IDS_STATUS_ERROR_CAB, achStatus, sizeof(achStatus) );
        Status( hDlg, IDC_MEDIT_STATUS, achStatus );
        fReturn = FALSE;
        goto done;
    }

    // if use choose to create CAB file only, MakeEXE() is not needed
    //
    if ( g_CDF.uPackPurpose != IDC_CMD_CREATECAB )
    {
        if ( ! MakeEXE( hDlg ) )  {
            LoadSz( IDS_STATUS_ERROR_EXE, achStatus, sizeof(achStatus) );
            Status( hDlg, IDC_MEDIT_STATUS, achStatus );
            fReturn = FALSE;
            goto done;
        }

        if ( MyGetPrivateProfileInt( SEC_OPTIONS, KEY_KEEPCABINET, 0, g_szOverideSec )
             == 0 )
        {
            DeleteFile( g_CDF.achCABPath );
        }
    }

    LoadSz( IDS_STATUS_DONE, achStatus, sizeof(achStatus) );
    Status( hDlg, IDC_MEDIT_STATUS, achStatus );

  done:

    // if failure happen, clean the filewriteout flag to prepare for next CDF out
    if ( !fReturn )    
        CleanFileListWriteFlag();


    return fReturn;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MakeCAB                                                     *
//*                                                                         *
//* SYNOPSIS:   Makes the cabinet file if it is out of date.                *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL MakeCAB( HWND hDlg )
{
    CHAR    achMessage[512];            // Used in FormatMessage()
    DWORD    dwError;                    // Used in GetLastError()
    LPSTR   szCommand;
    HANDLE   hFile;
    LPSTR    szTempFile;
    ULONG    ulFileSize;
    LPSTR    szFileContents;
    DWORD    dwBytes;
    CHAR    achDiamondExe[MAX_PATH];
    CHAR    achDiamondPath[MAX_PATH];
    CHAR    achStatus[MAX_STRING];
    BOOL     fFilesModified = FALSE;
    DWORD    dwExitCode;
    STARTUPINFO         sti;
    PROCESS_INFORMATION pi;             // Setup Process Launch
    WIN32_FIND_DATA     FindFileData;
    DWORD     dwCreationFlags;

    //FindClose( hFile );

    LoadSz( IDS_STATUS_MAKE_CAB, achStatus, sizeof(achStatus) );
    Status( hDlg, IDC_MEDIT_STATUS, achStatus );

    if ( ! WriteDDF( hDlg ) )  {
        return FALSE;
    }

    // Make the CAB file

    if ( lstrcmpi( g_CDF.szCompressionType, achQUANTUM ) == 0 ) {
        lstrcpy( achDiamondExe, DIAMONDEXE );
    } else {
        lstrcpy( achDiamondExe, DIANTZEXE );
    }

    if ( !GetFileFromModulePath( achDiamondExe, achDiamondPath, sizeof(achDiamondPath) ) )
    {
        ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND, achDiamondPath );
        return FALSE;
    }

    // The +5 is to handle the " /f " in the wsprintf format string
    // and for the terminating null char.
    //
    szCommand = (LPSTR) LocalAlloc( LPTR,   lstrlen(achDiamondPath)
                                           + lstrlen(g_CDF.achDDF)
                                           + 10 );
    if ( ! szCommand )  {
        ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
        return FALSE;
    }
    wsprintf( szCommand, "%s /f \"%s\"", achDiamondPath, g_CDF.achDDF );

    memset( &sti, 0, sizeof(sti) );
    sti.cb = sizeof(STARTUPINFO);

	if (g_wRunDiamondMinimized) {
        sti.dwFlags = STARTF_USESHOWWINDOW;
        sti.wShowWindow = SW_MINIMIZE;
    }
    else if (g_wQuietMode || g_wSilentMode) {
        sti.dwFlags = STARTF_USESHOWWINDOW;
        sti.wShowWindow = SW_HIDE;
    }

    if (!g_wQuietMode)
        dwCreationFlags = 0;
    else
        dwCreationFlags = CREATE_NO_WINDOW;

    if ( CreateProcess( NULL, szCommand, NULL, NULL, FALSE,
                                     dwCreationFlags, NULL, NULL, &sti, &pi ) )
    {
        CloseHandle( pi.hThread );
        MsgWaitForMultipleObjectsLoop( pi.hProcess );
        GetExitCodeProcess( pi.hProcess, &dwExitCode );
        CloseHandle( pi.hProcess );
    } else  {
        dwError = GetLastError();
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0,
                       achMessage, sizeof(achMessage), NULL );
        ErrorMsg2Param( hDlg, IDS_ERR_START_DIAMOND, szCommand,
                        achMessage );
    }

    LocalFree( szCommand );

    Status( hDlg, IDC_MEDIT_STATUS, "---\r\n" );

    hFile = FindFirstFile( g_CDF.achRPT, &FindFileData );
    ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                 + FindFileData.nFileSizeLow;
    FindClose( hFile );

    hFile = CreateFile( g_CDF.achRPT, GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, 0, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        ErrorMsg1Param( hDlg, IDS_ERR_OPEN_RPT, g_CDF.achRPT );
        return FALSE;
    }

    szFileContents = (LPSTR) LocalAlloc( LPTR, ulFileSize + 1 );
    if ( ! szFileContents )  {
        ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    if ( ! ReadFile( hFile, szFileContents, ulFileSize,
                     &dwBytes, NULL ) ) {
        ErrorMsg1Param( hDlg, IDS_ERR_READ_RPT, g_CDF.achRPT );
        return FALSE;
    }

    CloseHandle( hFile );

    Status( hDlg, IDC_MEDIT_STATUS, szFileContents );

    LocalFree( szFileContents );

    Status( hDlg, IDC_MEDIT_STATUS, "---\r\n" );

    if ( MyGetPrivateProfileInt( SEC_OPTIONS, KEY_KEEPCABINET, 0, g_szOverideSec )
         == 0 )
    {
        DeleteFile( g_CDF.achDDF );
    }
    if ( !(g_CDF.uExtractOpt & CAB_FIXEDSIZE) )
        DeleteFile( g_CDF.achINF );
    DeleteFile( g_CDF.achRPT );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       MakeEXE                                                     *
//*                                                                         *
//* SYNOPSIS:   Copies WEXTRACT.EXE to the target filename and adds         *
//*             resources to it.                                            *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL MakeEXE( HWND hDlg )
{
    HANDLE  hUpdate;
    CHAR   achMessage[512];            // Used in FormatMessage()
    DWORD   dwError;                    // Used in GetLastError()
    PMYITEM pMyItem;
    HANDLE  hFile;
    LPSTR   szTempFile;
    ULONG   ulFileSize;
    LPSTR   szFileContents;
    DWORD   dwBytes;
    CHAR   achWExtractPath[MAX_PATH];
    CHAR   achStatus[MAX_STRING];
    WIN32_FIND_DATA FindFileData;
    DWORD   dwFileSizes[MAX_NUMCLUSTERS+1]; // store the filesize in each cluster sizes.
                            // the last of dwFileSizes is used to store real
                            // total file sizes later used for calculate
                            // progress bar in wextract
    DWORD   clusterCurrSize;
    int     i;
    UINT    idErr = IDS_ERR_UPDATE_RESOURCE;

    // get ExtractorStub based on CDF specification.  Wextract.exe is default one.
    //

    LoadSz( IDS_STATUS_MAKE_EXE, achStatus, sizeof(achStatus) );
    Status( hDlg, IDC_MEDIT_STATUS, achStatus );

    if ( !MyGetPrivateProfileString( SEC_OPTIONS, KEY_STUBEXE, WEXTRACTEXE, achStatus, sizeof(achStatus), g_szOverideSec ) )
    {
        lstrcpy( achStatus, WEXTRACTEXE );
    }

    if ( !GetFileFromModulePath(achStatus, achWExtractPath, sizeof(achWExtractPath) ) )
    {
        ErrorMsg1Param( hDlg, IDS_ERR_FILE_NOT_FOUND, achWExtractPath );
        return FALSE;
    }

    if ( ! CopyFile( achWExtractPath, g_CDF.achTarget, FALSE ) ) {
        dwError = GetLastError();
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0,
                       achMessage, sizeof(achMessage), NULL );
        ErrorMsg2Param( hDlg, IDS_ERR_CREATE_TARGET, g_CDF.achTarget,
                        achMessage );
        return FALSE;
    }

    // make sure the targe file is not read-only file
    SetFileAttributes( g_CDF.achTarget, FILE_ATTRIBUTE_NORMAL );

    // Initialize the EXE file for resource editing
    hUpdate = LocalBeginUpdateResource( g_CDF.achTarget, FALSE );
    if ( hUpdate == NULL ) {
        ErrorMsg1Param( hDlg, IDS_ERR_INIT_RESOURCE, g_CDF.achTarget );
        return FALSE;
    }


    //*******************************************************************
    //* TITLE ***********************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResTitle, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         g_CDF.achTitle, lstrlen( g_CDF.achTitle ) + 1 ) == FALSE )
    {
        goto ERR_OUT;
    }

    //*******************************************************************
    //* PROMPT **********************************************************
    //*******************************************************************

    if ( g_CDF.fPrompt )  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResUPrompt, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             g_CDF.achPrompt, lstrlen( g_CDF.achPrompt ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    } else  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResUPrompt, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* LICENSE FILE ****************************************************
    //*******************************************************************

    if ( g_CDF.fLicense )  {
        hFile = FindFirstFile( g_CDF.achLicense, &FindFileData );
        ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                     + FindFileData.nFileSizeLow;
        FindClose( hFile );

        hFile = CreateFile( g_CDF.achLicense, GENERIC_READ, 0, NULL,
                            OPEN_EXISTING, 0, NULL );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            ErrorMsg1Param( hDlg, IDS_ERR_OPEN_LICENSE, g_CDF.achLicense );
            DeleteFile(g_CDF.achTarget);
            return FALSE;
        }

        szFileContents = (LPSTR) LocalAlloc( LPTR, ulFileSize + 1 );
        if ( ! szFileContents )  {
            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
            DeleteFile(g_CDF.achTarget);
            return FALSE;
        }

        if ( ! ReadFile( hFile, szFileContents, ulFileSize,
                         &dwBytes, NULL ) ) {
            ErrorMsg1Param( hDlg, IDS_ERR_READ_LICENSE, g_CDF.achLicense );
            DeleteFile(g_CDF.achTarget);
            return FALSE;
        }

        CloseHandle( hFile );

        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResLicense, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             szFileContents, ulFileSize+1 ) == FALSE )
        {            
            LocalFree( szFileContents );
            goto ERR_OUT;
        }

        LocalFree( szFileContents );
    } else  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResLicense, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* COMMAND *********************************************************
    //*******************************************************************


    if ( g_CDF.uPackPurpose != IDC_CMD_EXTRACT )
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResRunProgram, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.achInstallCmd, lstrlen(g_CDF.achInstallCmd)+1 ) == FALSE )
        {
            goto ERR_OUT;
        }

        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResPostRunCmd, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.achPostInstCmd, lstrlen(g_CDF.achPostInstCmd)+1 ) == FALSE )
        {
            goto ERR_OUT;
        }

        //write quiet cmds resource
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResAdminQCmd, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.szAdmQCmd[0]?g_CDF.szAdmQCmd : achResNone,
             g_CDF.szAdmQCmd[0]?(lstrlen(g_CDF.szAdmQCmd)+1) : (lstrlen(achResNone)+1) ) == FALSE )
        {
            goto ERR_OUT;
        }

        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResUserQCmd, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
             g_CDF.szUsrQCmd[0]?g_CDF.szUsrQCmd : achResNone,
             g_CDF.szUsrQCmd[0]?(lstrlen(g_CDF.szUsrQCmd)+1) : (lstrlen(achResNone)+1) ) == FALSE )
        {
            goto ERR_OUT;
        }

    }
    else
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResRunProgram, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* SHOW WINDOW *****************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResShowWindow, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.uShowWindow, sizeof(g_CDF.uShowWindow) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* FINISHMSG *******************************************************
    //*******************************************************************

    if ( g_CDF.fFinishMsg )  {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResFinishMsg, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             g_CDF.achFinishMsg, lstrlen( g_CDF.achFinishMsg ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }
    else
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResFinishMsg, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             achResNone, lstrlen( achResNone ) + 1 ) == FALSE )
        {
            goto ERR_OUT;
        }
    }

    //*******************************************************************
    //* CABINET *********************************************************
    //*******************************************************************

    hFile = FindFirstFile( g_CDF.achCABPath, &FindFileData );
    ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                 + FindFileData.nFileSizeLow;
    FindClose( hFile );

    hFile = CreateFile( g_CDF.achCABPath, GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, 0, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        ErrorMsg1Param( hDlg, IDS_ERR_OPEN_CAB, g_CDF.achCABPath );
        DeleteFile(g_CDF.achTarget);
        return FALSE;
    }

    szFileContents = (LPSTR) LocalAlloc( LPTR, ulFileSize + 1 );
    if ( ! szFileContents )  {
        idErr = IDS_ERR_NO_MEMORY;
        goto ERR_OUT;
    }

    if ( ! ReadFile( hFile, szFileContents, ulFileSize, &dwBytes, NULL ) ) {
        ErrorMsg1Param( hDlg, IDS_ERR_READ_CAB, g_CDF.achCABPath );
        DeleteFile(g_CDF.achTarget);        
        return FALSE;
    }

    CloseHandle( hFile );

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResCabinet, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         szFileContents, ulFileSize ) == FALSE )
    {        
        LocalFree( szFileContents );
        goto ERR_OUT;
    }

    LocalFree( szFileContents );


    //*******************************************************************
    //* FILES ***********************************************************
    //*******************************************************************

    pMyItem = GetFirstItem();
    RtlZeroMemory( dwFileSizes, sizeof(dwFileSizes));

    while ( ! LastItem( pMyItem ) )  {

        szTempFile = (LPSTR) LocalAlloc( LPTR,
                       lstrlen( GetItemSz( pMyItem, 0 ) )
                     + lstrlen( GetItemSz( pMyItem, 1 ) ) + 1 );
        if ( ! szTempFile )  {
            idErr = IDS_ERR_NO_MEMORY;
            goto ERR_OUT;
        }
        lstrcpy( szTempFile, GetItemSz( pMyItem, 1 ) );
        lstrcat( szTempFile, GetItemSz( pMyItem, 0 ) );
        hFile = FindFirstFile( szTempFile, &FindFileData );
        ulFileSize =   (FindFileData.nFileSizeHigh * MAXDWORD)
                     + FindFileData.nFileSizeLow;
        FindClose( hFile );
        LocalFree( szTempFile );

        // calculate the file size in different cluster sizes
        clusterCurrSize = CLUSTER_BASESIZE;
        for ( i = 0; i<MAX_NUMCLUSTERS; i++)
        {

            dwFileSizes[i] += ((ulFileSize/clusterCurrSize)*clusterCurrSize +
                                (ulFileSize%clusterCurrSize?clusterCurrSize : 0));
            clusterCurrSize = (clusterCurrSize<<1);
        }

        // this size is not allocated size, just real accumulation
        // of the files for later progress bar UI use
        dwFileSizes[MAX_NUMCLUSTERS] += ulFileSize;

        pMyItem = GetNextItem( pMyItem );
    }

    for ( i = 0; i<MAX_NUMCLUSTERS; i++)
    {
        dwFileSizes[i] = (dwFileSizes[i]+1023)/1024;  //store in KB	
    }

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResSize, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         dwFileSizes, sizeof(dwFileSizes) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* REBOOT    *******************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResReboot, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.dwReboot, sizeof(g_CDF.dwReboot) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* EXTRACTOPT   ****************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResExtractOpt, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.uExtractOpt, sizeof(g_CDF.uExtractOpt) ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* COOKIE       ****************************************************
    //*******************************************************************

    if ( g_CDF.lpszCookie && LocalUpdateResource( hUpdate, RT_RCDATA,
         achResOneInstCheck, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         g_CDF.lpszCookie, lstrlen(g_CDF.lpszCookie)+1 ) == FALSE )
    {
            goto ERR_OUT;
    }

    //*******************************************************************
    //* PACKINSTSPACE  **************************************************
    //*******************************************************************

    if ( LocalUpdateResource( hUpdate, RT_RCDATA,
         achResPackInstSpace, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         &g_CDF.cbPackInstSpace, sizeof(g_CDF.cbPackInstSpace) ) == FALSE )
    {
            goto ERR_OUT;
    }

    // Update the version information. The function calls LocaleUpdateResource.
    if (!DoVersionInfo(hDlg, achWExtractPath, hUpdate))
    {
        idErr = IDS_ERR_VERSION_INFO;
        goto ERR_OUT;
    }

    //*******************************************************************
    //* TARGETVERSION  **************************************************
    //*******************************************************************
    if ( g_CDF.pVerInfo )
    {
        if ( LocalUpdateResource( hUpdate, RT_RCDATA,
             achResVerCheck, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
             g_CDF.pVerInfo, g_CDF.pVerInfo->dwSize ) == FALSE )
        {
                goto ERR_OUT;
        }
    }
    //*******************************************************************
    //* DONE ************************************************************
    //*******************************************************************

    // Write out modified EXE
    if ( LocalEndUpdateResource( hUpdate, FALSE ) == FALSE )
    {
        idErr = IDS_ERR_CLOSE_RESOURCE;
        goto ERR_OUT;
    }

    return TRUE;

ERR_OUT:
    ErrorMsg( hDlg, idErr );
    // error occurs, clean up the uncompleted target file
    DeleteFile(g_CDF.achTarget);
    return FALSE;

}


//***************************************************************************
//*                                                                         *
//* NAME:       MyOpen                                                      *
//*                                                                         *
//* SYNOPSIS:   Makes popping up a common file open dialog simpler.         *
//*                                                                         *
//* REQUIRES:   Some of the members of the OPENFILENAME structure. See      *
//*             the docs on OPENFILENAME for more info.                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL MyOpen( HWND hWnd, UINT idFilter, LPSTR szFilename,
             DWORD dwMaxFilename, DWORD dwFlags, INT *nFileOffset,
             INT *nExtOffset, PSTR pszDefExt )
{
    OPENFILENAME ofn;
    BOOL         fResult;
    LPSTR        szFilter;

    szFilter = (LPSTR) LocalAlloc( LPTR, MAX_STRING );

    if ( ! szFilter )  {
        ErrorMsg( hWnd, IDS_ERR_NO_MEMORY );
        return FALSE;
    }

    LoadSz( idFilter, szFilter, MAX_STRING );

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = hWnd;
    ofn.hInstance           = NULL;
    ofn.lpstrFilter         = szFilter;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFilename;
    ofn.nMaxFile            = dwMaxFilename;
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = g_szInitialDir;
    ofn.lpstrTitle          = NULL;
    ofn.Flags               = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                              OFN_PATHMUSTEXIST | OFN_LONGNAMES    |
                              OFN_NOCHANGEDIR   | OFN_EXPLORER     |
                              OFN_NODEREFERENCELINKS | dwFlags;

    if ( IsOSNT3X() )
    {
        ofn.Flags &= ~OFN_ALLOWMULTISELECT;
    }

    ofn.lpstrDefExt         = pszDefExt;
    ofn.lCustData           = 0;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;

    fResult = GetOpenFileName( &ofn );

    if ( nFileOffset != NULL )  {
        *nFileOffset = ofn.nFileOffset;
    }

    if ( nExtOffset != NULL )  {
        *nExtOffset = ofn.nFileExtension;
    }

    LocalFree( szFilter );

    return( fResult );
}


//***************************************************************************
//*                                                                         *
//* NAME:       MySave                                                      *
//*                                                                         *
//* SYNOPSIS:   Makes popping up a common file save dialog simpler.         *
//*                                                                         *
//* REQUIRES:   Some of the members of the OPENFILENAME structure. See      *
//*             the docs on OPENFILENAME for more info.                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL MySave( HWND hWnd, UINT idFilter, LPSTR szFilename,
             DWORD dwMaxFilename, DWORD dwFlags, INT *nFileOffset,
             INT *nExtOffset, PSTR pszDefExt )
{
    OPENFILENAME ofn;
    BOOL         fResult;
    LPSTR        szFilter;

    szFilter = (LPSTR) LocalAlloc( LPTR, MAX_STRING );
    if ( ! szFilter )  {
        ErrorMsg( hWnd, IDS_ERR_NO_MEMORY );
        return FALSE;
    }
    LoadSz( idFilter, szFilter, MAX_STRING );

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = hWnd;
    ofn.hInstance           = NULL;
    ofn.lpstrFilter         = szFilter;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFilename;
    ofn.nMaxFile            = dwMaxFilename;
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = NULL;
    ofn.lpstrTitle          = NULL;
    ofn.Flags               = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST |
                              OFN_LONGNAMES    | OFN_NOCHANGEDIR   | dwFlags;
    ofn.lpstrDefExt         = pszDefExt;
    ofn.lCustData           = 0;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;

    fResult = GetSaveFileName( &ofn );

    if ( nFileOffset != NULL )  {
        *nFileOffset = ofn.nFileOffset;
    }

    if ( nExtOffset != NULL )  {
        *nExtOffset = ofn.nFileExtension;
    }

    LocalFree( szFilter );
    
    return( fResult );
}


//***************************************************************************
//*                                                                         *
//* NAME:       Status                                                      *
//*                                                                         *
//* SYNOPSIS:   Adds a string to a status list box.                         *
//*                                                                         *
//* REQUIRES:   hDlg:           Handle to the dialog                        *
//*             uID:            ID of the list box.                         *
//*             szStatus:       Status string to add.                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID Status( HWND hDlg, UINT uID, LPSTR szStatus )
{
    ULONG ulLength;

    if ( hDlg != NULL )  {
        ulLength = (ULONG)SendDlgItemMessage( hDlg, uID, WM_GETTEXTLENGTH, 0, 0 );
        SendDlgItemMessage( hDlg, uID, EM_SETSEL, ulLength, ulLength );
        SendDlgItemMessage( hDlg, uID, EM_REPLACESEL,
                            (WPARAM) FALSE, (LPARAM) szStatus );
        SendDlgItemMessage( hDlg, uID, EM_SCROLLCARET, 0, 0 );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       CompareFunc                                                 *
//*                                                                         *
//* SYNOPSIS:   Compares two items and returns result.                      *
//*                                                                         *
//* REQUIRES:   lParam1:        Pointer to the first item.                  *
//*             uID:            Pointer to the second item.                 *
//*             lParamSort:     Type of sorting to do.                      *
//*                                                                         *
//* RETURNS:    int:            -1 if lParam1 goes before lParam2           *
//*                              0 if lParam1 equals lParam2                *
//*                             +1 if lParam1 goes after lParam2            *
//*                                                                         *
//* NOTES:      For some weird reason, sorting the listview causes a        *
//*             really bad GPF (freezes the entire system).  For now it's   *
//*             not worth the effort to fix it, so sorting is disabled.     *
//*                                                                         *
//***************************************************************************
/*
int CALLBACK CompareFunc( LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort )
{
    PMYITEM pMyItem1 = (PMYITEM) lParam1;
    PMYITEM pMyItem2 = (PMYITEM) lParam2;
    int     nReverse = 1;
    UINT    uString  = 0;

    lParamSort = _SORT_DESCENDING | _SORT_FILENAME;

    if ( lParamSort & _SORT_ASCENDING )  {
        nReverse = -1;
    }

    if ( lParamSort & _SORT_PATH )  {
        uString = 1;
    }

    return ( nReverse * lstrcmp( GetItemSz( pMyItem1, uString ),
                                 GetItemSz( pMyItem2, uString ) ) );
}
*/

//***************************************************************************
//*                                                                         *
//* NAME:       InitItemList                                                *
//*                                                                         *
//* SYNOPSIS:   Initializes the item list.                                  *
//*                                                                         *
//* REQUIRES:   Nothing -- uses the global g_CDF.pTop                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID InitItemList()
{
    g_CDF.pTop = NULL;
    g_CDF.cbFileListNum = 0;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DeleteAllItems                                              *
//*                                                                         *
//* SYNOPSIS:   Deletes all the items from our file list.                   *
//*                                                                         *
//* REQUIRES:   Nothing -- uses the global g_CDF.pTop                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DeleteAllItems()
{
    PMYITEM pMyItem;
    PMYITEM pTempItem;

    pMyItem = GetFirstItem();

    while( ! LastItem( pMyItem ) ) {
        pTempItem = pMyItem;
        pMyItem = GetNextItem( pMyItem );

        FreeItem( &(pTempItem) );
    }

    InitItemList();
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetFirstItem                                                *
//*                                                                         *
//* SYNOPSIS:   Returns the first PMYITEM in the list                       *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    PMYITEM         The first item                              *
//*                                                                         *
//***************************************************************************
PMYITEM GetFirstItem( VOID )
{
    return g_CDF.pTop;
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetNextItem                                                 *
//*                                                                         *
//* SYNOPSIS:   Given the current item, returns the next item in the list.  *
//*                                                                         *
//* REQUIRES:   pMyItem:        The current item.                           *
//*                                                                         *
//* RETURNS:    PMYITEM         The next item.                              *
//*                                                                         *
//***************************************************************************
PMYITEM GetNextItem( PMYITEM pMyItem )
{
    ASSERT( pMyItem != NULL );

    return pMyItem->Next;
}

//***************************************************************************
//*                                                                         *
//* NAME:       FreeItem                                                    *
//*                                                                         *
//* SYNOPSIS:   Frees the memory associated with an item.                   *
//*                                                                         *
//* REQUIRES:   *pMyItem        Pointer to a pointer to an item             *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID FreeItem( PMYITEM *pMyItem )
{
    LocalFree( (*pMyItem)->aszCols[0] );
    LocalFree( (*pMyItem)->aszCols[1] );
    LocalFree( (*pMyItem) );
}

//***************************************************************************
//*                                                                         *
//* NAME:       GetItemSz                                                   *
//*                                                                         *
//* SYNOPSIS:   Returns a string associated with an item. You pick the      *
//*             string by passing the number of the string.                 *
//*                                                                         *
//* REQUIRES:   pMyItem:        The item                                    *
//*             nItem:          The string to return                        *
//*                                                                         *
//* RETURNS:    LPSTR:          The string                                  *
//*                                                                         *
//***************************************************************************
LPSTR GetItemSz( PMYITEM pMyItem, UINT nItem )
{
    ASSERT( pMyItem != NULL );
    ASSERT( nItem <= 1 );

    return pMyItem->aszCols[nItem];
}


//***************************************************************************
//*                                                                         *
//* NAME:       LastItem                                                    *
//*                                                                         *
//* SYNOPSIS:   Used to end a while loop when we've reached the end of list *
//*                                                                         *
//* REQUIRES:   pMyItem:        the current item                            *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if at end of list, FALSE otherwise     *
//*                                                                         *
//***************************************************************************
BOOL LastItem( PMYITEM pMyItem )
{
    return( pMyItem == NULL );
}

//***************************************************************************
//*                                                                         *
//* NAME:       AddItem                                                     *
//*                                                                         *
//* SYNOPSIS:   Adds an item to the list.                                   *
//*                                                                         *
//* REQUIRES:   szFilename, szPath - strings to add to structure.           *
//*                                                                         *
//* RETURNS:    PMYITEM         This function allocates memory which will   *
//*                             be freed later by FreeItem()                *
//*                                                                         *
//***************************************************************************
PMYITEM AddItem( LPCSTR szFilename, LPCSTR szPath )
{
    PMYITEM pMyItem;
    PMYITEM pTail;

    ASSERT( szFilename != NULL );
    ASSERT( szPath != NULL );

    pMyItem = (PMYITEM) LocalAlloc( GMEM_FIXED, sizeof(MYITEM) );

    if ( ! pMyItem )  {
        return NULL;
    }

    pMyItem->aszCols[0] = (LPSTR) LocalAlloc( LPTR, lstrlen( szFilename ) + 1 );
    pMyItem->aszCols[1] = (LPSTR) LocalAlloc( LPTR, lstrlen( szPath ) + 1 );

    if ( ! pMyItem->aszCols[0] || ! pMyItem->aszCols[1] )  {
        FreeItem( &pMyItem );
        return NULL;
    }

    lstrcpy( pMyItem->aszCols[0], szFilename );
    lstrcpy( pMyItem->aszCols[1], szPath );

    pMyItem->fWroteOut = FALSE;
    pMyItem->Next = NULL;

    if ( g_CDF.pTop == NULL )
    {
        g_CDF.pTop = pMyItem;
    }
    else
    {
        pTail = g_CDF.pTop;
        while ( pTail->Next != NULL )
        {
            pTail = pTail->Next;
        }

        pTail->Next = pMyItem;
    }

    g_CDF.cbFileListNum++;

    return pMyItem;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RemoveItem                                                  *
//*                                                                         *
//* SYNOPSIS:   Removes an item from the list and frees the memory.         *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID RemoveItem( PMYITEM pMyItem )
{
    PMYITEM pCurItem;
    PMYITEM pLastItem;

    ASSERT( pMyItem != NULL );

    pCurItem = GetFirstItem();

    if ( pMyItem == pCurItem )  {
        g_CDF.pTop = pCurItem->Next;
        FreeItem( &pCurItem );
        return;
    }

    pLastItem = pCurItem;
    pCurItem = GetNextItem( pCurItem );

    while ( ! LastItem( pCurItem ) )  {
        if ( pCurItem == pMyItem )  {
            pLastItem->Next = pCurItem->Next;
            FreeItem( &pCurItem );
            return;
        }
        pLastItem = pCurItem;
        pCurItem = GetNextItem( pCurItem );
    }

    // We should never get here.
    ASSERT( TRUE );
}

//***************************************************************************
//*                                                                         *
//*  ParseCmdLine()                                                     *
//*                                                                         *
//*  Purpose:    Parses the command line looking for switches               *
//*                                                                         *
//*  Parameters: LPSTR lpszCmdLineOrg - Original command line               *
//*                                                                         *
//*                                                                         *
//*  Return:     (BOOL) TRUE if successful                                  *
//*                     FALSE if an error occurs                            *
//*                                                                         *
//***************************************************************************

BOOL ParseCmdLine( LPSTR lpszCmdLine )
{
    LPSTR pSubArg, pArg, pTmp;
    CHAR  szTmpBuf[MAX_PATH];

    if( (!lpszCmdLine) || (lpszCmdLine[0] == 0) )
       return TRUE;

    pArg = strtok( lpszCmdLine, " " );

    while ( pArg )
    {

       if ( lstrcmpi( pArg, "/N" ) == 0 )
       {
           g_fBuildNow = TRUE;
       }
       else if( (*pArg != '/' ) )
       {
           lstrcpyn( g_CDF.achFilename, pArg, sizeof(g_CDF.achFilename) );
           GetFullPathName( g_CDF.achFilename, sizeof(g_CDF.achFilename),
                                g_CDF.achFilename, &pTmp );
       }
       else if ( (*pArg == '/') && (toupper(*(pArg+1)) == 'O') && (*(pArg+2) == ':') )
       {
            lstrcpy( szTmpBuf, (pArg+3) );

            if ( pSubArg = strchr( szTmpBuf, ',' ) )
            {
                *pSubArg = '\0';
                lstrcpy( g_szOverideCDF, szTmpBuf );
                GetFullPathName( g_szOverideCDF, sizeof(g_szOverideCDF),
                                g_szOverideCDF, &pTmp );

                if ( *(pSubArg+1) )
                    lstrcpy( g_szOverideSec, (pSubArg+1) );
            }
       }
       else if ( lstrcmpi( pArg, "/Q" ) == 0 )
       {
            g_wQuietMode = 1;
       }
       else if ( lstrcmpi( pArg, "/S" ) == 0 )
       {
            g_wSilentMode = 1;
       }
       else if ( lstrcmpi( pArg, "/M" ) == 0 )
       {
            g_wRunDiamondMinimized = 1;
       }
       else
       {
           return FALSE;
       }
       pArg = strtok( NULL, " " );
    }

    if ( (g_wQuietMode == 1) && (g_fBuildNow == FALSE) ) {
        g_wQuietMode = 0;
    }

    return TRUE;
}



// RO_GetPrivateProfileSection
//   ensure the file attribute is not read-only.
//
LONG RO_GetPrivateProfileSection( LPCSTR lpSec, LPSTR lpBuf, DWORD dwSize, LPCSTR lpFile, BOOL bSingleCol)
{
    LONG lRealSize;
    DWORD dwAttr;
    int   iCDFVer;

    dwAttr = GetFileAttributes( lpFile );
    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        if ( !SetFileAttributes( lpFile, FILE_ATTRIBUTE_NORMAL ) )
        {
            ErrorMsg1Param( NULL, IDS_ERR_CANT_SETA_FILE, lpFile );
        }
    }

    if ( ( (iCDFVer = GetPrivateProfileInt( SEC_VERSION, KEY_VERSION, -1, lpFile )) == -1 ) &&
         ( (iCDFVer = GetPrivateProfileInt( SEC_VERSION, KEY_NEWVER, -1, lpFile )) == -1 ) )
    {
        return (iCDFVer);
    }

    if ( !bSingleCol )
    {
        lRealSize = (LONG)GetPrivateProfileSection( lpSec, lpBuf, dwSize, lpFile );
    }
    else
    {
        if ( iCDFVer < 3 )
            lRealSize = (LONG)GetPrivateProfileSection( lpSec, lpBuf, dwSize, lpFile );
        else
            lRealSize = (LONG)GetPrivateProfileString( lpSec, NULL, "", lpBuf, dwSize, lpFile );
    }

    if ( (dwAttr != -1) && (dwAttr & FILE_ATTRIBUTE_READONLY) )
    {
        SetFileAttributes( lpFile, dwAttr );
    }

    return lRealSize;

}

BOOL IsOSNT3X(VOID)
{
    OSVERSIONINFO verinfo;        // Version Check


    // Operating System Version Check: For NT versions below 3.50 set flag to
    // prevent use of common controls (progress bar and AVI) not available.

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx( &verinfo ) == FALSE )
    {
        // you definitly not windows 95 or NT 4.0
        return TRUE;
    }

    if ( verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
        if ( verinfo.dwMajorVersion <= 3 )
        {
            return TRUE;
        }
    }
    return FALSE; // windows 95 or NT 4.0 above
}

void SetControlFont()
{
   LOGFONT lFont;
   if (GetSystemMetrics(SM_DBCSENABLED) &&
       (GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof (lFont), &lFont) > 0))
   {
       g_hFont = CreateFontIndirect((LPLOGFONT)&lFont);
   }
}

//==================================================================

BOOL GetThisModulePath( LPSTR lpPath, int size )
{
    LPSTR lpTmp;
    int   len;

    ASSERT(lpPath);
    ASSERT(size);

    *lpPath = 0;
    if ( GetModuleFileName( g_hInst, lpPath, size ) )
    {
        // chop filename off
        //
        lpTmp = ANSIStrRChr( lpPath, '\\' );
        if ( lpTmp )
        {
            *(CharNext(lpTmp)) = '\0';
        }
    }

    return (*lpPath != '\0');
}

// BUGBUG:  we don't need size param, since it is internal, we could assume
// MAX_PATH buffer
//
BOOL GetFileFromModulePath( LPCSTR pFile, LPSTR pPathBuf, int iBufSize )
{
    BOOL bRet;

    bRet = GetThisModulePath( pPathBuf, iBufSize );
    AddPath( pPathBuf, pFile );

    if ( bRet && GetFileAttributes( pPathBuf ) == -1 )
    {
        return FALSE;
    }
    return bRet;
}


//***************************************************************************
//*                                                                         *
//* NAME:       MakeDirectory                                               *
//*                                                                         *
//* SYNOPSIS:   Make sure the directories along the given pathname exist.   *
//*                                                                         *
//* REQUIRES:   pszFile:        Name of the file being created.             *
//*                                                                         *
//* RETURNS:    nothing                                                     *
//*                                                                         *
//***************************************************************************

BOOL MakeDirectory( HWND hwnd, LPCSTR pszPath, BOOL bDoUI )
{
    LPTSTR pchChopper;
    int cExempt;
    DWORD  dwAttr;
    BOOL bRet = FALSE;

    if (pszPath[0] != '\0')
    {
        PSTR pszTmp = NULL;
        char ch;
        UINT umsg = 0;
        UINT ubutton = MB_YESNO;


        cExempt = 0;
        pszTmp = ANSIStrRChr( pszPath, '\\' );
        if ( pszTmp )
        {
            ch = *pszTmp;
            *pszTmp = '\0';
        }

        dwAttr = GetFileAttributes( pszPath );
        if ( bDoUI ) 
        {
            if ( dwAttr == 0xffffffff )
            {
                umsg = IDS_CREATEDIR;            
                ubutton = MB_YESNO;
            }
            else if ( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
            {
                umsg = IDS_INVALIDPATH;
                ubutton = MB_OK;
            }
                
            if ( umsg && ( (MsgBox1Param( hwnd, umsg, (LPSTR)pszPath, MB_ICONQUESTION, ubutton ) == IDNO) ||
                 (ubutton == MB_OK) )  )
            {
                if ( pszTmp ) 
                    *pszTmp = ch;
                return bRet;
            }
        }

        if ( pszTmp ) 
            *pszTmp = ch;

        if ((pszPath[1] == ':') && (pszPath[2] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 3);   /* skip past "C:\" */
        }
        else if ((pszPath[0] == '\\') && (pszPath[1] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 2);   /* skip past "\\" */

            cExempt = 2;                /* machine & share names exempt */
        }
        else
        {
            pchChopper = (LPTSTR) (pszPath + 1);   /* skip past potential "\" */
        }

        while (*pchChopper != '\0')
        {
            if ((*pchChopper == '\\') && (*(pchChopper - 1) != ':'))
            {
                if (cExempt != 0)
                {
                    cExempt--;
                }
                else
                {
                    *pchChopper = '\0';

                    CreateDirectory(pszPath,NULL);

                    *pchChopper = '\\';
                }
            }

            pchChopper = CharNext(pchChopper);
        }

        bRet = TRUE;
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\cabpack.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* CABPACK.H - Wizard to build a Win32 Self-Extracting and self-installing *
//*             EXE from a Cabinet (CAB) file.                              *
//*                                                                         *
//***************************************************************************

#ifndef _CABPACK_H_
#define _CABPACK_H_

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <prsht.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include "resource.h"
#include "res.h"
#include "cpldebug.h"
#include "updres.h"
#include "pagefcns.h"


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************

#define SMALL_BUF_LEN       48          // good size for small text buffers
#define STRING_BUF_LEN      512
#define MAX_STRING          512
#define MAX_INFLINE         MAX_PATH
#define LARGE_POINTSIZE     15
#define SIZE_CHECKSTRING    3

#define ORD_PAGE_WELCOME     0
#define ORD_PAGE_MODIFY      1
#define ORD_PAGE_PURPOSE     2
#define ORD_PAGE_TITLE       3
#define ORD_PAGE_PROMPT      4
#define ORD_PAGE_LICENSETXT  5
#define ORD_PAGE_FILES       6
#define ORD_PAGE_COMMAND     7
#define ORD_PAGE_SHOWWINDOW  8
#define ORD_PAGE_FINISHMSG   9
#define ORD_PAGE_TARGET      10
#define ORD_PAGE_TARGET_CAB  11
#define ORD_PAGE_CABLABEL    12
#define ORD_PAGE_REBOOT     13
#define ORD_PAGE_SAVE       14
#define ORD_PAGE_CREATE     15

#define NUM_WIZARD_PAGES    16  // total number of pages in wizard

//***************************************************************************
//* MACRO DEFINITIONS                                                       *
//***************************************************************************
#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr( hwnd, DWLP_MSGRESULT, result )
#define MsgBox( hWnd, nMsgID, uIcon, uButtons ) \
        MsgBox2Param( hWnd, nMsgID, NULL, NULL, uIcon, uButtons )
#define MsgBox1Param( hWnd, nMsgID, szParam, uIcon, uButtons ) \
        MsgBox2Param( hWnd, nMsgID, szParam, NULL, uIcon, uButtons )
#define ErrorMsg( hWnd, nMsgID ) \
        MsgBox2Param( hWnd, nMsgID, NULL, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg1Param( hWnd, nMsgID, szParam ) \
        MsgBox2Param( hWnd, nMsgID, szParam, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg2Param( hWnd, nMsgID, szParam1, szParam2 ) \
        MsgBox2Param( hWnd, nMsgID, szParam1, szParam2, MB_ICONERROR, MB_OK )


//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
// Structure to hold information about wizard state:
// keeps a history of which pages were visited, so user can
// back up and we know the last page completed in case of reboot.
typedef struct _WIZARDSTATE  {
    UINT  uCurrentPage;                 // index of current page wizard
    UINT  uPageHistory[NUM_WIZARD_PAGES]; // array of page #'s we visited
    UINT  uPagesCompleted;              // # of pages in uPageHistory
    DWORD dwRunFlags;                   // flags passed to us
} WIZARDSTATE, *PWIZARDSTATE;

// handler proc for OK, cancel, etc button handlers
typedef BOOL (* INITPROC)( HWND, BOOL );
typedef BOOL (* CMDPROC)( HWND, UINT, BOOL *, UINT *, BOOL * );
typedef BOOL (* NOTIFYPROC)( HWND, WPARAM, LPARAM );
typedef BOOL (* OKPROC)( HWND, BOOL, UINT *, BOOL * );
typedef BOOL (* CANCELPROC)( HWND );

// Structure with information for each wizard page:
// handler procedures for each page-- any of these can be
// NULL in which case the default behavior is used
typedef struct _PAGEINFO {
    UINT        uDlgID;                 // dialog ID to use for page
    INITPROC    InitProc;
    CMDPROC     CmdProc;
    NOTIFYPROC  NotifyProc;
    OKPROC      OKProc;
    CANCELPROC  CancelProc;
} PAGEINFO, *PPAGEINFO;

typedef struct _CDFSTRINGINFO {
    LPCSTR lpSec;
    LPCSTR lpKey;
    LPCSTR lpDef;
    LPSTR  lpBuf;
    UINT    uSize;
    LPCSTR lpOverideSec;
    BOOL*   lpFlag;
} CDFSTRINGINFO, *PCDFSTRINGINFO;

typedef struct _CDFOPTINFO {
    LPCSTR lpKey;
    DWORD  dwOpt;
} CDFOPTINFO, *PCDFOPTINFO;

//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************

// These two variables are used to check the validity of the CABPack
// Directive File.  The version should be incremented when the format
// of the file changes.  The Check String is just a small character
// string that is used to make sure we're reading a CDF file.

// Since Channel Guy use the CDF as Channel Definition File, we change our
// IExpress batch directive file extension to SED (Self Extracting Directive file)

#define DIAMONDEXE "diamond.exe"

#define DIANTZEXE   "makecab.exe"

#define WEXTRACTEXE "wextract.exe"

//***************************************************************************
//* CDF batch file Key Name defines                                         *
//***************************************************************************

#define IEXPRESS_VER        "3"
#define IEXPRESS_CLASS      "IEXPRESS"

// pre-defined section name
#define SEC_OPTIONS     "Options"
#define SEC_STRINGS     "Strings"

#define SEC_COMMANDS    "AppCommands"

// pre-define key name for version section
#define KEY_CLASS           "Class"
#define KEY_VERSION         "CDFVersion"
#define KEY_NEWVER          "SEDVersion"

// pre-defined Key name for options section
#define KEY_SHOWWIN         "ShowInstallProgramWindow"
#define KEY_NOEXTRACTUI     "HideExtractAnimation"
#define KEY_EXTRACTONLY     "ExtractOnly"
#define KEY_REBOOTMODE      "RebootMode"
#define KEY_LOCALE          "Locale"
#define KEY_USELFN          "UseLongFileName"
#define KEY_QUANTUM         "Quantum"
#define KEY_PLATFORM_DIR    "PlatformDir"

#define KEY_FILELIST        "SourceFiles"
#define KEY_STRINGS         "Strings"
#define KEY_FILEBASE        "FILE%d"
#define KEY_VERSIONINFO     "VersionInfo"

#define KEY_INSTPROMPT      "InstallPrompt"
#define KEY_DSPLICENSE      "DisplayLicense"
#define KEY_APPLAUNCH       "AppLaunched"
#define KEY_POSTAPPLAUNCH   "PostInstallCmd"
#define KEY_ENDMSG          "FinishMessage"
#define KEY_PACKNAME        "TargetName"
#define KEY_FRIENDLYNAME    "FriendlyName"
#define KEY_PACKINSTSPACE   "PackageInstallSpace(KB)"
#define KEY_PACKPURPOSE     "PackagePurpose"
#define KEY_CABFIXEDSIZE    "CAB_FixedSize"
#define KEY_CABRESVCODESIGN "CAB_ResvCodeSigning"
#define KEY_LAYOUTINF       "IEXP_LayoutINF"
#define KEY_CABLABEL        "SourceMediaLabel"
#define KEY_NESTCOMPRESSED  "InsideCompressed"
#define KEY_KEEPCABINET     "KeepCabinet"
#define KEY_UPDHELPDLLS     "UpdateAdvDlls"
#define KEY_INSTANCECHK     "MultiInstanceCheck"
#define KEY_ADMQCMD         "AdminQuietInstCmd"
#define KEY_USERQCMD        "UserQuietInstCmd"
#define KEY_CHKADMRIGHT     "CheckAdminRights"
#define KEY_NTVERCHECK      "TargetNTVersion"
#define KEY_WIN9XVERCHECK   "TargetWin9xVersion"
#define KEY_SYSFILE         "TargetFileVersion"
#define KEY_PASSRETURN      "PropogateCmdExitCode"
#define KEY_PASSRETALWAYS   "AlwaysPropogateCmdExitCode"
#define KEY_STUBEXE         "ExtractorStub"
#define KEY_CROSSPROCESSOR  "PackageForX86"
#define KEY_COMPRESSTYPE    "CompressionType"
#define KEY_CMDSDEPENDED    "AppErrorCheck"
#define KEY_COMPRESS        "Compress"	 	
#define KEY_COMPRESSMEMORY  "CompressionMemory"

// ADVANCED DLL names
#define ADVANCEDLL          "ADVPACK.DLL"
#define ADVANCEDLL32        "W95INF32.DLL"
#define ADVANCEDLL16        "W95INF16.DLL"

//static CHAR achMSZIP[] = "MSZIP";
//static CHAR achQUANTUM[] = "QUANTUM";

// package purpose key string value
#define STR_INSTALLAPP      "InstallApp"
#define STR_EXTRACTONLY     "ExtractOnly"
#define STR_CREATECAB       "CreateCAB"

// code sign resv space
#define CAB_0K      "0"
#define CAB_2K      "2048"
#define CAB_4K      "4096"
#define CAB_6K      "6144"

// define temp filename for diamond to use
#define CABPACK_INFFILE     "~%s_LAYOUT.INF"
#define CABPACK_TMPFILE     "~%s%s"

// file extentions with dot 
#define EXT_RPT      ".RPT"
#define EXT_DDF      ".DDF"
#define EXT_CAB      ".CAB"
#define EXT_CDF      ".CDF"
#define EXT_SED      ".SED"

// file extentions without dot '.' used as default file extention
#define EXT_SED_NODOT    "SED"
#define EXT_CAB_NODOT    "CAB"
#define EXT_TXT_NODOT    "TXT"
#define EXT_EXE_NODOT    "EXE"
#define EXT_INF_NODOT    "INF"

#define CAB_DEFSETUPMEDIA   "Application Source Media"

#define CH_STRINGKEY        '%'
#define SYS_DEFAULT         "ZZZZZZ"
#define KBYTES              1000

//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL             RunCABPackWizard( VOID );
INT_PTR CALLBACK GenDlgProc( HWND, UINT, WPARAM, LPARAM );
VOID             InitWizardState( PWIZARDSTATE );
VOID NEAR PASCAL MEditSubClassWnd( HWND, FARPROC );
LRESULT CALLBACK MEditSubProc( HWND, UINT, WPARAM, LPARAM );
UINT             GetDlgIDFromIndex( UINT );
VOID             EnableWizard( HWND, BOOL );
DWORD            MsgWaitForMultipleObjectsLoop( HANDLE );
INT              MsgBox2Param( HWND, UINT, LPCSTR, LPCSTR, UINT, UINT );
VOID             DisplayFieldErrorMsg( HWND, UINT, UINT );

VOID             InitBigFont( HWND, UINT );
VOID             DestroyBigFont( VOID );
BOOL             EnableDlgItem( HWND, UINT, BOOL );
LPSTR            LoadSz( UINT, LPSTR, UINT );
BOOL WINAPI      IsDuplicate( HWND, INT, LPSTR, BOOL );
BOOL             WriteCDF( HWND );
BOOL             ReadCDF( HWND );
BOOL             WriteDDF( HWND );
BOOL             MyOpen( HWND, UINT, LPSTR, DWORD, DWORD, INT *, INT *, PSTR );
BOOL             MySave( HWND, UINT, LPSTR, DWORD, DWORD, INT *, INT *, PSTR );
BOOL             MakePackage( HWND );
BOOL             MakeCAB( HWND );
BOOL             MakeEXE( HWND );
VOID             Status( HWND, UINT, LPSTR );
//int CALLBACK     CompareFunc( LPARAM, LPARAM, LPARAM );
VOID             InitItemList( VOID );
VOID             DeleteAllItems( VOID );
PMYITEM          GetFirstItem( VOID );
PMYITEM          GetNextItem( PMYITEM );
VOID             FreeItem( PMYITEM * );
LPSTR            GetItemSz( PMYITEM, UINT );
FILETIME         GetItemTime( PMYITEM );
VOID             SetItemTime( PMYITEM, FILETIME );
BOOL             LastItem( PMYITEM );
PMYITEM          AddItem( LPCSTR, LPCSTR );
VOID             RemoveItem( PMYITEM );
BOOL             ParseCmdLine( LPSTR lpszCmdLineOrg );
BOOL             DoVersionInfo(HWND hDlg, LPSTR szFile,HANDLE hUpdate);
LONG             RO_GetPrivateProfileSection( LPCSTR, LPSTR, DWORD, LPCSTR , BOOL );

BOOL            GetFileFromModulePath( LPCSTR pFile, LPSTR pPathBuf, int iBufSize );
BOOL            GetThisModulePath( LPSTR lpPath, int size );
BOOL            GetVersionInfoFromFile();
void            CleanFileListWriteFlag();
BOOL            MakeCabName( HWND hwnd, PSTR pszTarget, PSTR pszCab );
BOOL            MakeDirectory( HWND hwnd,LPCSTR pszPath, BOOL bDoUI );

#endif // _CABPACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\pch.h ===
#include <windows.h>
#include <commctrl.h>
#if WINNT  /* for odds-n-ends not automatically included in \\trango env */
#include <commdlg.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\pagefcns.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* PAGEFCNS.C -                                                            *
//*                                                                         *
//***************************************************************************
// MODIFYORCREATE page should have a button to 'quick display' CDF file

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "cabpack.h"
#include "sdsutils.h"

void SetFontForControl(HWND hwnd, UINT uiID);
//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
CDF   g_CDF = { 0 };                            // Generally, these are settings that
                                        // will be stored in the CABPack
                                        // Directive File.
BOOL  g_fFinish = FALSE;
char  g_szInitialDir[MAX_PATH];
extern HFONT g_hFont;
extern PSTR pResvSizes[];
extern HINSTANCE    g_hInst; // Pointer to Instance

//###########################################################################
//#                      ####################################################
//#  WELCOME PAGE        ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       WelcomeInit                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL WelcomeInit( HWND hDlg, BOOL fFirstInit )
{
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
    SetFontForControl(hDlg, IDC_EDIT_OPEN_CDF);

    if ( fFirstInit )
    {
        if ( lstrlen( g_CDF.achFilename ) > 0 )  {
            CheckDlgButton( hDlg, IDC_RAD_CREATE_NEW,    FALSE );
            CheckDlgButton( hDlg, IDC_RAD_OPEN_EXISTING, TRUE );
            SetDlgItemText( hDlg, IDC_EDIT_OPEN_CDF, g_CDF.achFilename );
        } else  {
            CheckDlgButton( hDlg, IDC_RAD_CREATE_NEW,    TRUE );
            CheckDlgButton( hDlg, IDC_RAD_OPEN_EXISTING, FALSE );
            EnableDlgItem( hDlg, IDC_EDIT_OPEN_CDF, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
        }
    }

    // Initialize the CABPack Directive File information.

    g_CDF.fSave           = TRUE;
    g_CDF.uShowWindow     = bResShowDefault;
    g_CDF.uPackPurpose    = IDC_CMD_RUNCMD;
    g_CDF.dwReboot        |= REBOOT_YES;
    g_CDF.szCompressionType = achMSZIP;
    g_CDF.uCompressionLevel = 7;

    lstrcpy( g_CDF.szCabLabel, CAB_DEFSETUPMEDIA );
    
    lstrcpy( g_CDF.achSourceFile, KEY_FILELIST );
//    g_CDF.wSortOrder      = _SORT_DESCENDING | _SORT_FILENAME;

    // prepare for the GetOpenFileName init dir
    GetCurrentDirectory( sizeof(g_szInitialDir), g_szInitialDir );

    DeleteAllItems();

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       WelcomeCmd                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL WelcomeCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID ) {

        case IDC_RAD_OPEN_EXISTING:
            EnableDlgItem( hDlg, IDC_EDIT_OPEN_CDF, TRUE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
            break;


        case IDC_RAD_CREATE_NEW:
            EnableDlgItem( hDlg, IDC_EDIT_OPEN_CDF, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
            break;


        case IDC_BUT_BROWSE:
            fResult = MyOpen( hDlg, IDS_FILTER_CDF,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_SED_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_OPEN_CDF, achFilename );
            }

            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       WelcomeOK                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL WelcomeOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    LPSTR szTemp;


    ASSERT( puNextPage );
    ASSERT( pfKeepHistory );
    ASSERT( fForward );                 // Only go forward from this page


    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_OPEN_EXISTING ) )  {
            GetDlgItemText( hDlg, IDC_EDIT_OPEN_CDF, g_CDF.achFilename,
                            sizeof(g_CDF.achFilename) );

            if ( lstrlen( g_CDF.achFilename ) != 0 )  {
                GetFullPathName( g_CDF.achFilename, sizeof(g_CDF.achFilename),
                                 g_CDF.achFilename, &szTemp );
            }

            if ( ! FileExists( g_CDF.achFilename ) )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_OPEN_CDF,
                                      IDS_ERR_CDF_DOESNT_EXIST );
                return FALSE;
            } else  {
                if ( ! ReadCDF( hDlg ) )  {
                    return FALSE;
                }
                *puNextPage = ORD_PAGE_MODIFY;
            }
        } else  {
            g_CDF.achFilename[0] = '\0';

            *puNextPage = ORD_PAGE_PURPOSE;
        }
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  MODIFY PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       ModifyInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL ModifyInit( HWND hDlg, BOOL fFirstInit )
{
    CheckDlgButton( hDlg, IDC_RAD_CREATE, TRUE );
    CheckDlgButton( hDlg, IDC_RAD_MODIFY, FALSE );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ModifyOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL ModifyOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );
    ASSERT( pfKeepHistory );

    *pfKeepHistory = FALSE;

    if ( fForward ) {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_CREATE ) )  {
            *puNextPage = ORD_PAGE_CREATE;
        }
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  TITLE PAGE          ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       TitleInit                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL TitleInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_TITLE);
    SendDlgItemMessage( hDlg, IDC_EDIT_TITLE, EM_LIMITTEXT, MAX_TITLE-2, 0L );
    SetDlgItemText( hDlg, IDC_EDIT_TITLE, g_CDF.achTitle );
    
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TitleOK                                                     *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL TitleOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
              BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );
    ASSERT( pfKeepHistory );


    GetDlgItemText( hDlg, IDC_EDIT_TITLE, g_CDF.achTitle,
                    sizeof(g_CDF.achTitle) );

    if ( fForward )  {
        if ( lstrlen( g_CDF.achTitle ) == 0 )  {
            DisplayFieldErrorMsg( hDlg, IDC_EDIT_TITLE, IDS_ERR_NO_TITLE );
            return FALSE;
        }
    }


    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  PROMPT PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       PromptInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL PromptInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_PROMPT);
    SendDlgItemMessage( hDlg, IDC_EDIT_PROMPT, EM_LIMITTEXT, MAX_PROMPT-2, 0L );
    SetDlgItemText( hDlg, IDC_EDIT_PROMPT, g_CDF.achPrompt );


    if ( g_CDF.fPrompt )  {
        CheckDlgButton( hDlg, IDC_RAD_NO_PROMPT,  FALSE );
        CheckDlgButton( hDlg, IDC_RAD_YES_PROMPT, TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_PROMPT, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_NO_PROMPT,  TRUE );
        CheckDlgButton( hDlg, IDC_RAD_YES_PROMPT, FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_PROMPT, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       PromptCmd                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL PromptCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    switch ( uCtrlID ) {
        case IDC_RAD_YES_PROMPT:
            EnableDlgItem( hDlg, IDC_EDIT_PROMPT, TRUE );
            break;


        case IDC_RAD_NO_PROMPT:
            EnableDlgItem( hDlg, IDC_EDIT_PROMPT, FALSE );
            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       PromptOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL PromptOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    GetDlgItemText( hDlg, IDC_EDIT_PROMPT, g_CDF.achPrompt,
                    sizeof(g_CDF.achPrompt) );

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_PROMPT ) )  {
        g_CDF.fPrompt = TRUE;
    } else  {
        g_CDF.fPrompt = FALSE;
    }

    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_PROMPT ) )  {
            if ( lstrlen( g_CDF.achPrompt ) == 0 )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_PROMPT,
                                      IDS_ERR_NO_PROMPT );
                return FALSE;
            }
        }
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  LICENSE PAGE        ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       LicenseTxtInit                                              *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL LicenseTxtInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_LICENSE);
    SetDlgItemText( hDlg, IDC_EDIT_LICENSE, g_CDF.achLicense );

    if ( g_CDF.fLicense )  {
        CheckDlgButton( hDlg, IDC_RAD_NO_LICENSE,  FALSE );
        CheckDlgButton( hDlg, IDC_RAD_YES_LICENSE, TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_LICENSE, TRUE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_NO_LICENSE,  TRUE );
        CheckDlgButton( hDlg, IDC_RAD_YES_LICENSE, FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_LICENSE, FALSE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       LicenseTxtCmd                                               *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL LicenseTxtCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                    BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID ) {

        case IDC_RAD_YES_LICENSE:
            EnableDlgItem( hDlg, IDC_EDIT_LICENSE, TRUE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
            break;


        case IDC_RAD_NO_LICENSE:
            EnableDlgItem( hDlg, IDC_EDIT_LICENSE, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
            break;


        case IDC_BUT_BROWSE:
            fResult = MyOpen( hDlg, IDS_FILTER_TXT,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_TXT_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_LICENSE, achFilename );
            }

            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       LicenseTxtOK                                                *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL LicenseTxtOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                   BOOL *pfKeepHistory )
{
    LPSTR szTemp;


    ASSERT( puNextPage );


    GetDlgItemText( hDlg, IDC_EDIT_LICENSE, g_CDF.achLicense,
                    sizeof(g_CDF.achLicense) );

    if ( lstrlen( g_CDF.achLicense ) != 0 )  {
        GetFullPathName( g_CDF.achLicense, sizeof(g_CDF.achLicense),
                         g_CDF.achLicense, &szTemp );
    }

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_LICENSE ) )  {
        g_CDF.fLicense = TRUE;
    } else  {
        g_CDF.fLicense = FALSE;
    }

    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_LICENSE ) )  {
            if ( lstrlen( g_CDF.achLicense ) == 0 )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_LICENSE,
                                      IDS_ERR_NO_LICENSE );
                return FALSE;
            }

            if ( ! FileExists( g_CDF.achLicense ) )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_LICENSE,
                                      IDS_ERR_LICENSE_NOT_FOUND );
                return FALSE;
            }
        }
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  FILES PAGE          ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       FilesInit                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL FilesInit( HWND hDlg, BOOL fFirstInit )
{
    LV_COLUMN lvc;
    RECT      Rect;
    PMYITEM   pMyItem;
    LV_ITEM   lvi;
    CHAR     achTemp[MAX_STRING];

    // Every time we enter this page, we clean out the list view
    // and add back all the items from our internal list.  This is
    // done because the list of items can change on other pages (like
    // if the user backs up to the first page, then loads another
    // CDF file).

    ListView_DeleteAllItems( GetDlgItem( hDlg, IDC_LV_CAB_FILES ) );

    lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state     = 0;
    lvi.stateMask = 0;
    lvi.pszText   = LPSTR_TEXTCALLBACK;
    lvi.iItem     = 0;
    lvi.iSubItem  = 0;

    pMyItem = GetFirstItem();

    while ( ! LastItem( pMyItem ) )  {
        lvi.lParam = (LPARAM) pMyItem;
        ListView_InsertItem( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), &lvi );
        lvi.iItem += 1;
        pMyItem = GetNextItem( pMyItem );
    }

    if ( fFirstInit )  {

        // Setup the column headers

        GetWindowRect( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), &Rect );

        lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvc.fmt     = LVCFMT_LEFT;
        lvc.cx      = 80;
        LoadSz( IDS_HEADER_FILENAME, achTemp, sizeof(achTemp) );
        lvc.pszText = (LPSTR) LocalAlloc( LPTR, lstrlen(achTemp) + 1 );
        if ( ! lvc.pszText )  {
            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
            return FALSE;
        }
        lstrcpy( lvc.pszText, achTemp );

        ListView_InsertColumn( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), 0, &lvc );

        LocalFree( lvc.pszText );

        lvc.cx = Rect.right - Rect.left - 80;
        LoadSz( IDS_HEADER_PATH, achTemp, sizeof(achTemp) );
        lvc.pszText = (LPSTR) LocalAlloc( LPTR, lstrlen(achTemp) + 1 );
        if ( ! lvc.pszText )  {
            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
            return FALSE;
        }
        lstrcpy( lvc.pszText, achTemp );

        ListView_InsertColumn( GetDlgItem( hDlg, IDC_LV_CAB_FILES ), 1, &lvc );

        LocalFree( lvc.pszText );

        EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FilesCmd                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL FilesCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    LPSTR         achFilename;
    INT           FileOffset         = 0;
    INT           FileExtension      = 0;
    BOOL          fResult            = TRUE;
    char          szPath[MAX_PATH];
    ULONG         ulIndex = 0;
    INT           nIndex = 0;
    LV_ITEM       lvi;
    INT           nItem;
    HWND          hwndFiles;
    SYSTEMTIME    st;


    lvi.mask      = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    lvi.state     = 0;
    lvi.stateMask = 0;
    lvi.pszText   = LPSTR_TEXTCALLBACK;


    hwndFiles = GetDlgItem( hDlg, IDC_LV_CAB_FILES );

    switch ( uCtrlID ) 
    {

        case IDC_BUT_ADD:
            //allocate 8K buff to hold the file name list
            achFilename = LocalAlloc( LPTR, 1024*8 );

            if ( !achFilename ) 
            {
                ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                return FALSE;
            }
            fResult = MyOpen( hDlg, IDS_FILTER_ALL,
                              achFilename, 1024*8,
                              OFN_ALLOWMULTISELECT,
                              &FileOffset, &FileExtension, 0 );

            // We should do some error checking to make sure all the files
            // could fit in the buffer. Currently the buffer is big enough to
            // hold tons of files.

            if ( fResult )  
            {
                lvi.iItem = ListView_GetItemCount( hwndFiles );

                // Add a trailing backslash to the pathname if it's not
                // the root dir

                lstrcpy( szPath, achFilename );
                lstrcpy( g_szInitialDir, szPath );
                AddPath( szPath, "" );

                // The open file common dialog returns two types of strings
                // when in MULTISELECT mode.  The first one is when
                // multiple files are selected -- it returns:
                // "path \0 file1 \0 file2 \0 ... \0 fileN \0 \0"
                // The second is when only 1 file is selected:
                // "path\filename \0 \0"

                ulIndex = lstrlen( achFilename ) + 1;

                while ( achFilename[ulIndex] != '\0' )
                {
                    if ( ! IsDuplicate( hDlg, IDC_LV_CAB_FILES,
                                        &achFilename[ulIndex], TRUE ) )
                    {
                        lvi.lParam = (LPARAM) AddItem( &achFilename[ulIndex],
                                                       szPath );
                        if ( ! lvi.lParam )  {
                            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                            LocalFree( achFilename );
                            return FALSE;
                        }

                        GetSystemTime( &st );
                        //SystemTimeToFileTime( &st, &g_CDF.ftFileListChange );
                        lvi.iItem    += 1;
                        lvi.iSubItem  = 0;
                        ListView_InsertItem( hwndFiles, &lvi );
                    } 
                    else  
                    {
                        ErrorMsg1Param( hDlg, IDS_ERR_DUPE_FILE,
                                        &achFilename[ulIndex] );
                    }

                    ulIndex = ulIndex + lstrlen( &achFilename[ulIndex] ) + 1;
                }

                
                if ( ulIndex == (ULONG)(lstrlen( achFilename ) + 1) )  
                {
                    if ( ! IsDuplicate( hDlg, IDC_LV_CAB_FILES,
                                        &achFilename[FileOffset], TRUE ) )
                    {
                        // should have '\' at the end
                        lstrcpyn( szPath, achFilename, FileOffset+1 );
                        lstrcpy( g_szInitialDir, szPath );
                        lvi.iSubItem = 0;
                        lvi.lParam = (LPARAM) AddItem(
                                                    &achFilename[FileOffset],
                                                    szPath );
                        if ( ! lvi.lParam )  {
                            ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                            LocalFree( achFilename );
                            return FALSE;
                        }

                        ListView_InsertItem( hwndFiles, &lvi );
                    }
                    else
                    {
                        ErrorMsg1Param( hDlg, IDS_ERR_DUPE_FILE,
                                        &achFilename[FileOffset] );
                    }
                }
            }
            
            LocalFree( achFilename );

            if ( ListView_GetSelectedCount( hwndFiles ) )
            {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, TRUE );
            } else  {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );
            }

            break;


        case IDC_BUT_REMOVE:

            nItem = ListView_GetNextItem( hwndFiles, -1,
                                          LVNI_ALL | LVNI_SELECTED );

            while ( nItem != -1 )
            {
                lvi.mask     = LVIF_PARAM;
                lvi.iItem    = nItem;
                lvi.iSubItem = 0;

                ListView_GetItem( hwndFiles, &lvi );

                RemoveItem( (PMYITEM) lvi.lParam );

                //GetSystemTime( &st );
                //SystemTimeToFileTime( &st, &g_CDF.ftFileListChange );

                ListView_DeleteItem( hwndFiles, nItem );

                nItem = ListView_GetNextItem( hwndFiles, -1,
                                              LVNI_ALL | LVNI_SELECTED );
            }

            EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );

            break;
    }

    return fResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FilesNotify                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when a notification message sent to this page.       *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL FilesNotify( HWND hDlg, WPARAM wParam, LPARAM lParam )
{
    switch ( ((LPNMHDR)lParam)->code )  {

        case LVN_GETDISPINFO:
        {
            LV_DISPINFO *pnmv = (LV_DISPINFO *) lParam;

            if ( pnmv->item.mask & LVIF_TEXT )
            {
                PMYITEM pMyItem = (PMYITEM) (pnmv->item.lParam);

                lstrcpy( pnmv->item.pszText,
                         GetItemSz( pMyItem, pnmv->item.iSubItem ) );
            }

            break;
        }


        case LVN_ITEMCHANGED:
        {
            if ( ListView_GetSelectedCount( GetDlgItem( hDlg,
                                            IDC_LV_CAB_FILES ) ) )
            {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, TRUE );
            } else  {
                EnableDlgItem( hDlg, IDC_BUT_REMOVE, FALSE );
            }

            break;
        }

/*
        case LVN_COLUMNCLICK :
        {
            NM_LISTVIEW FAR *pnmv = (NM_LISTVIEW FAR *) lParam;

            if ( pnmv->iSubItem == 1 )  {
                if ( g_CDF.wSortOrder & _SORT_FILENAME )  {
                    g_CDF.wSortOrder = g_CDF.wSortOrder ^ _SORT_ORDER;
                } else  {
                    g_CDF.wSortOrder = _SORT_FILENAME | _SORT_DESCENDING;
                }
            } else  {
                if ( g_CDF.wSortOrder & _SORT_PATH )  {
                    g_CDF.wSortOrder = g_CDF.wSortOrder ^ _SORT_ORDER;
                } else  {
                    g_CDF.wSortOrder = _SORT_PATH | _SORT_DESCENDING;
                }
            }

            ListView_SortItems( GetDlgItem( hDlg, IDC_LV_CAB_FILES ),
                                CompareFunc, g_CDF.wSortOrder );

            break;
        }
*/
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FilesOK                                                     *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL FilesOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
              BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    if ( fForward )
    {
        if ( ListView_GetItemCount( GetDlgItem( hDlg, IDC_LV_CAB_FILES ) )
             == 0 )
        {
            ErrorMsg( hDlg, IDS_ERR_NO_FILES );
            return FALSE;
        }

        if ( g_CDF.uPackPurpose == IDC_CMD_EXTRACT )
        {
            *puNextPage = ORD_PAGE_SHOWWINDOW;
        }
        else if ( g_CDF.uPackPurpose == IDC_CMD_CREATECAB )
        {
            *puNextPage = ORD_PAGE_TARGET_CAB;
        }
        else
            ;  // normal page order
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  PACKPURPOSE PAGE    ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       PackPurposeInit                                             *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL PackPurposeInit( HWND hDlg, BOOL fFirstInit )
{
    CHAR msg[MAX_STRING];
    UINT  idMsg;

    if ( CheckRadioButton( hDlg, IDC_CMD_RUNCMD, IDC_CMD_CREATECAB, g_CDF.uPackPurpose ) )
    {
        if ( g_CDF.uPackPurpose == IDC_CMD_RUNCMD )
            idMsg = IDS_CMD_RUNCMD;
        else if ( g_CDF.uPackPurpose == IDC_CMD_EXTRACT )
            idMsg = IDS_CMD_EXTRACT;
        else
            idMsg = IDS_CMD_CREATECAB;

        LoadSz( idMsg, msg, sizeof(msg) );
        SendMessage( GetDlgItem( hDlg, IDC_CMD_NOTES), WM_SETTEXT, 0, (LPARAM)msg );
    }
    else
        SysErrorMsg( hDlg );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       PackPurposeCmd                                              *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************

BOOL PackPurposeCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                     BOOL *pfKeepHistory )
{
    CHAR msg[MAX_STRING];
    int   idMsg;

    switch ( uCtrlID )
    {

        case IDC_CMD_RUNCMD:
            if ( IsDlgButtonChecked( hDlg, IDC_CMD_RUNCMD ) )
                idMsg = IDS_CMD_RUNCMD;
            break;

        case IDC_CMD_EXTRACT:
            if ( IsDlgButtonChecked( hDlg, IDC_CMD_EXTRACT ) )
                idMsg = IDS_CMD_EXTRACT;
            break;

        case IDC_CMD_CREATECAB:
            if ( IsDlgButtonChecked( hDlg, IDC_CMD_CREATECAB ) )
                idMsg = IDS_CMD_CREATECAB;
            break;

    }

    LoadSz( idMsg, msg, sizeof(msg) );
    SendMessage( GetDlgItem( hDlg, IDC_CMD_NOTES), WM_SETTEXT, 0, (LPARAM)msg );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       PackPurposeOK                                               *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL PackPurposeOK( HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );

    if ( IsDlgButtonChecked( hDlg, IDC_CMD_RUNCMD ) )
    {
        g_CDF.uPackPurpose = IDC_CMD_RUNCMD;
    }
    else if ( IsDlgButtonChecked( hDlg, IDC_CMD_EXTRACT ) )
    {
        g_CDF.uPackPurpose = IDC_CMD_EXTRACT;
        // leave long file name
        g_CDF.uExtractOpt |= EXTRACTOPT_LFN_YES;
    }
    else
    {
        g_CDF.uPackPurpose = IDC_CMD_CREATECAB;
        // load Default messagebox title name
        LoadSz( IDS_APPNAME, g_CDF.achTitle, sizeof(g_CDF.achTitle) );
    }

    if ( fForward )
    {
        if ( g_CDF.uPackPurpose == IDC_CMD_CREATECAB )
        {
            g_CDF.uExtractOpt |= CAB_RESVSP6K;
            *puNextPage = ORD_PAGE_FILES;
        }
    }
    else
    {
        if ( MsgBox( hDlg, IDS_LOSE_CHANGES, MB_ICONQUESTION, MB_YESNO ) == IDNO )
        {
            return FALSE;
        }
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  COMMAND PAGE        ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       CommandInit                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL CommandInit( HWND hDlg, BOOL fFirstInit )
{
    LRESULT nCurSel;
    PMYITEM pMyItem;
    LPSTR   szFile;
    CHAR   achExt[_MAX_EXT];

    SetFontForControl(hDlg, IDC_CB_INSTALLCMD);
    SetFontForControl(hDlg, IDC_CB_POSTCMD);
    if ( !fFirstInit )
    {
        // cleanup old settings
        SendDlgItemMessage( hDlg, IDC_CB_INSTALLCMD, CB_RESETCONTENT, 0, 0 );
        SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_RESETCONTENT, 0, 0 );

        g_CDF.uExtractOpt &= ~(EXTRACTOPT_ADVDLL);

        // ADD EXE, BAT, COM and INF FILES TO THE COMBBOXes
        pMyItem = GetFirstItem();

        while ( ! LastItem( pMyItem ) )
        {
            szFile = GetItemSz( pMyItem, 0 );
            _splitpath( szFile, NULL, NULL, NULL, achExt );

            if (    lstrcmpi( achExt, achExtEXE ) == 0
                 || lstrcmpi( achExt, achExtBAT ) == 0
                 || lstrcmpi( achExt, achExtCOM ) == 0
                 || lstrcmpi( achExt, achExtINF ) == 0 )
            {
                SendDlgItemMessage( hDlg, IDC_CB_INSTALLCMD, CB_ADDSTRING, 0, (LPARAM)szFile );
                SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_ADDSTRING, 0, (LPARAM)szFile );
            }
            pMyItem = GetNextItem( pMyItem );
        }
        SetCurrSelect( hDlg, IDC_CB_INSTALLCMD, g_CDF.achOrigiInstallCmd );

        SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_ADDSTRING, 0, (LPARAM)achResNone );

        if ( !SetCurrSelect( hDlg, IDC_CB_POSTCMD, g_CDF.achOrigiPostInstCmd ) )
        {
            nCurSel = SendDlgItemMessage( hDlg, IDC_CB_POSTCMD,
                                          CB_FINDSTRINGEXACT, (WPARAM) -1,
                                          (LPARAM)achResNone );

            SendDlgItemMessage( hDlg, IDC_CB_POSTCMD, CB_SETCURSEL, (WPARAM)nCurSel, 0 );
        }
    }
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CommandOK                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL CommandOK( HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory )
{

    ASSERT( puNextPage );

    SendMessage( GetDlgItem(hDlg, IDC_CB_INSTALLCMD), WM_GETTEXT,
                 (WPARAM)sizeof(g_CDF.achOrigiInstallCmd), (LPARAM)g_CDF.achOrigiInstallCmd );

    RemoveBlanks( g_CDF.achOrigiInstallCmd );

    if ( fForward && !lstrlen(g_CDF.achOrigiInstallCmd) )
    {
        ErrorMsg( hDlg, IDS_ERR_NO_SELECT );
        return FALSE;
    }

    // set EXTRACTOPT_ADVDLL if needed
    if ( !CheckAdvBit( g_CDF.achOrigiInstallCmd ) )
        return FALSE;

    SendMessage( GetDlgItem(hDlg, IDC_CB_POSTCMD), WM_GETTEXT,
                 (WPARAM)sizeof(g_CDF.achOrigiPostInstCmd), (LPARAM)g_CDF.achOrigiPostInstCmd );

    RemoveBlanks( g_CDF.achOrigiPostInstCmd );

    if ( lstrlen( g_CDF.achOrigiPostInstCmd ) && lstrcmpi(g_CDF.achOrigiPostInstCmd, achResNone) )
    {
        if ( !CheckAdvBit( g_CDF.achOrigiPostInstCmd ) )
            return FALSE;
    }
    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  SHOWWINDOW PAGE     ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       ShowWindowInit                                              *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL ShowWindowInit( HWND hDlg, BOOL fFirstInit )
{
    if ( g_CDF.uShowWindow == bResShowDefault )  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   TRUE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, FALSE );
    } else if ( g_CDF.uShowWindow == bResShowHidden )  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    TRUE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, FALSE );
    } else if ( g_CDF.uShowWindow == bResShowMin )  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, TRUE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, FALSE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_DEFAULT,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_HIDDEN,    FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MINIMIZED, FALSE );
        CheckDlgButton( hDlg, IDC_RAD_MAXIMIZED, TRUE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ShowWindowOK                                                *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL ShowWindowOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_DEFAULT ) )  {
        g_CDF.uShowWindow = bResShowDefault;
    } else if ( IsDlgButtonChecked( hDlg, IDC_RAD_HIDDEN ) )  {
        g_CDF.uShowWindow = bResShowHidden;
    } else if ( IsDlgButtonChecked( hDlg, IDC_RAD_MINIMIZED ) )  {
        g_CDF.uShowWindow = bResShowMin;
    } else {
        g_CDF.uShowWindow = bResShowMax;
    }

    return TRUE;
}




//###########################################################################
//#                      ####################################################
//#  FINISHMSG PAGE      ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMsgInit                                               *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL FinishMsgInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_FINISHMSG);
    SendDlgItemMessage( hDlg, IDC_EDIT_FINISHMSG, EM_LIMITTEXT, MAX_FINISHMSG-2, 0L );
    SetDlgItemText( hDlg, IDC_EDIT_FINISHMSG, g_CDF.achFinishMsg );

    if ( g_CDF.fFinishMsg )  {
        CheckDlgButton( hDlg, IDC_RAD_NO_FINISHMSG,  FALSE );
        CheckDlgButton( hDlg, IDC_RAD_YES_FINISHMSG, TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_NO_FINISHMSG,  TRUE );
        CheckDlgButton( hDlg, IDC_RAD_YES_FINISHMSG, FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMsgCmd                                                *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL FinishMsgCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage,
                   UINT *puNextPage, BOOL *pfKeepHistory )
{
    switch ( uCtrlID ) {
        case IDC_RAD_YES_FINISHMSG:
            EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, TRUE );
            break;


        case IDC_RAD_NO_FINISHMSG:
            EnableDlgItem( hDlg, IDC_EDIT_FINISHMSG, FALSE );
            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMsgOK                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL FinishMsgOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    GetDlgItemText( hDlg, IDC_EDIT_FINISHMSG, g_CDF.achFinishMsg,
                    sizeof(g_CDF.achFinishMsg) );

    if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_FINISHMSG ) )  {
        g_CDF.fFinishMsg = TRUE;
    } else  {
        g_CDF.fFinishMsg = FALSE;
    }

    if ( fForward )  {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_FINISHMSG ) )  {
            if ( lstrlen( g_CDF.achFinishMsg ) == 0 )  {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_FINISHMSG,
                                      IDS_ERR_NO_FINISHMSG );
                return FALSE;
            }
        }
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  TARGET PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       TargetInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL TargetInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_TARGET);
    SetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget );

    if ( !(g_CDF.uExtractOpt & EXTRACTOPT_UI_NO) )
        CheckDlgButton( hDlg, IDC_HIDEEXTRACTUI, FALSE );
    else
        CheckDlgButton( hDlg, IDC_HIDEEXTRACTUI, TRUE );

    if ( g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES )
        CheckDlgButton( hDlg, IDC_USE_LFN, TRUE );
    else
        CheckDlgButton( hDlg, IDC_USE_LFN, FALSE );


    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCmd                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL TargetCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID )
    {

        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_EXE,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_EXE_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_TARGET, achFilename );
            }
            break;

        case IDC_USE_LFN:
            if ( IsDlgButtonChecked( hDlg, IDC_USE_LFN ) && (g_CDF.uPackPurpose != IDC_CMD_EXTRACT) )
            {
                if ( MsgBox( hDlg, IDS_WARN_USELFN, MB_ICONQUESTION, MB_YESNO) == IDNO )
                {
                    CheckDlgButton( hDlg, IDC_USE_LFN, FALSE );
                }
            }
            break;

    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL TargetOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    LPSTR szTemp;
    LPSTR szExt;

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget,
                    sizeof(g_CDF.achTarget) );

    RemoveBlanks( g_CDF.achTarget );

    if ( fForward )
    {
        if ( lstrlen( g_CDF.achTarget ) == 0 )
        {
            DisplayFieldErrorMsg( hDlg, IDC_EDIT_TARGET, IDS_ERR_NO_TARGET );
            return FALSE;
        }

        if ( !GetFullPathName( g_CDF.achTarget, sizeof(g_CDF.achTarget),
                               g_CDF.achTarget, &szTemp ) )
        {
            SysErrorMsg( hDlg );
            return FALSE;
        }

        // make sure that the path exists
        if ( !MakeDirectory( hDlg, g_CDF.achTarget, TRUE ) )
            return FALSE;

        if ( !(szExt = ANSIStrRChr(g_CDF.achTarget, '.')) || lstrcmpi( szExt, achExtEXE ) )
        {
            lstrcat( g_CDF.achTarget, achExtEXE );
        }

        // if goal is extract files only, no need for reboot page
        if ( g_CDF.uPackPurpose == IDC_CMD_EXTRACT )
        {
            *puNextPage = ORD_PAGE_SAVE;
        }
        else
        {
            // if you are in TARGET page, you should always jump over TARGET_CAB page
            *puNextPage = ORD_PAGE_REBOOT;
        }

        g_CDF.uExtractOpt &= ~(EXTRACTOPT_UI_NO | EXTRACTOPT_LFN_YES);

        if ( IsDlgButtonChecked( hDlg, IDC_HIDEEXTRACTUI ) )
            g_CDF.uExtractOpt |= EXTRACTOPT_UI_NO;

        if ( IsDlgButtonChecked( hDlg, IDC_USE_LFN ) )
             g_CDF.uExtractOpt |= EXTRACTOPT_LFN_YES;

        MyProcessLFNCmd( g_CDF.achOrigiInstallCmd, g_CDF.achInstallCmd );
        MyProcessLFNCmd( g_CDF.achOrigiPostInstCmd, g_CDF.achPostInstCmd );
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  TARGET_CAB PAGE     ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCABInit                                               *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL TargetCABInit( HWND hDlg, BOOL fFirstInit )
{
    int i;
    LRESULT nCurSel;

    SetFontForControl(hDlg, IDC_EDIT_TARGET);
    SetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget );

    // init CB box
    if ( !fFirstInit )
    {
        // cleanup old settings
        SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_RESETCONTENT, 0, 0 );
        for ( i = 0; i<4; i++ )
        {
            nCurSel = SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_ADDSTRING, 0, (LPARAM)pResvSizes[i] );
            if ( (nCurSel == (LRESULT)CB_ERR) || (nCurSel == (LRESULT)CB_ERRSPACE) )
            {
                ErrorMsg( hDlg, IDS_ERR_NO_MEMORY );
                return FALSE;
            }
        }

        if ( g_CDF.uExtractOpt & CAB_RESVSP2K )
            i = 1;
        else if ( g_CDF.uExtractOpt & CAB_RESVSP4K )
            i = 2;
        else if ( g_CDF.uExtractOpt & CAB_RESVSP6K )
            i = 3;
        else
            i = 0;

        if ( SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_SETCURSEL, (WPARAM)i, (LPARAM)0 ) == (LRESULT)CB_ERR ) 
        {
            SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_SETCURSEL, (WPARAM)0,(LPARAM)0 );
        }
    }

    // init Check boxes
    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
        CheckDlgButton( hDlg, IDC_MULTIPLE_CAB, TRUE );
    else
        CheckDlgButton( hDlg, IDC_MULTIPLE_CAB, FALSE );

    if ( g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES )
        CheckDlgButton( hDlg, IDC_USE_LFN, TRUE );
    else
        CheckDlgButton( hDlg, IDC_USE_LFN, FALSE );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCABCmd                                                *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL TargetCABCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID )
    {

        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_CAB,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_CAB_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_TARGET, achFilename );
            }
            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TargetCABOK                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL TargetCABOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    LPSTR   szTemp;
    LPSTR   szExt;
    LRESULT nCurSel;

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_TARGET, g_CDF.achTarget,
                    sizeof(g_CDF.achTarget) );

    RemoveBlanks( g_CDF.achTarget );

    if ( fForward )
    {
        if ( lstrlen( g_CDF.achTarget ) == 0 )
        {
            DisplayFieldErrorMsg( hDlg, IDC_EDIT_TARGET, IDS_ERR_NO_TARGET );
            return FALSE;
        }
        
        // get the CAB format options
        //
        g_CDF.uExtractOpt &= ~(CAB_FIXEDSIZE | EXTRACTOPT_LFN_YES);
        g_CDF.uExtractOpt &= ~(CAB_RESVSP2K | CAB_RESVSP4K | CAB_RESVSP6K );

        nCurSel = SendDlgItemMessage( hDlg, IDC_CB_RESVCABSP, CB_GETCURSEL, (WPARAM)0,(LPARAM)0 );
        if ( nCurSel != (LRESULT)CB_ERR )
        {
            switch( nCurSel )
            {
                case 1:
                    g_CDF.uExtractOpt |= CAB_RESVSP2K;
                    break;
                case 2:
                    g_CDF.uExtractOpt |= CAB_RESVSP4K;
                    break;
                case 3:
                    g_CDF.uExtractOpt |= CAB_RESVSP6K;
                    break;
            }
        }

        if ( IsDlgButtonChecked( hDlg, IDC_MULTIPLE_CAB ) )
            g_CDF.uExtractOpt |= CAB_FIXEDSIZE;

        if ( IsDlgButtonChecked( hDlg, IDC_USE_LFN ) )
            g_CDF.uExtractOpt |= EXTRACTOPT_LFN_YES;

        // make sure CAB file name is 8.3 format
        //
        if ( !MakeCabName( hDlg, g_CDF.achTarget, g_CDF.achCABPath ) )
        {
            return FALSE;
        }

        if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
        {
            // only user choose to get layout inf name and cab label
            *puNextPage = ORD_PAGE_CABLABEL;
        }
        else
        {
            // only user choose to create CAB only get this page
            // therefore, for sure no reboot page needed!
            *puNextPage = ORD_PAGE_SAVE;
        }

    }

    return TRUE;
}
//###########################################################################
//#                      ####################################################
//#  CABLABEL PAGE       ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       CABLABEL                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL CabLabelInit( HWND hDlg, BOOL fFirstInit )
{
    SetFontForControl(hDlg, IDC_EDIT_LAYOUTINF);
    SetFontForControl(hDlg, IDC_EDIT_CABLABEL);
    SendDlgItemMessage( hDlg, IDC_EDIT_LAYOUTINF, EM_LIMITTEXT, MAX_PATH-1, 0 );
    SendDlgItemMessage( hDlg, IDC_EDIT_CABLABEL, EM_LIMITTEXT, MAX_PATH-1, 0 );
    SetDlgItemText( hDlg, IDC_EDIT_LAYOUTINF, g_CDF.achINF );
    SetDlgItemText( hDlg, IDC_EDIT_CABLABEL, g_CDF.szCabLabel );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CabLabelCmd                                                 *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL CabLabelCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                 BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;

    switch ( uCtrlID )
    {

        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_INF,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_INF_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_LAYOUTINF, achFilename );
            }
            break;
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CabLabelOK                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL CabLabelOK( HWND hDlg, BOOL fForward, UINT *puNextPage,BOOL *pfKeepHistory )
{
    LPSTR szTemp;
    LPSTR szExt;

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_LAYOUTINF, g_CDF.achINF,sizeof(g_CDF.achINF) );
    GetDlgItemText( hDlg, IDC_EDIT_CABLABEL, g_CDF.szCabLabel,sizeof(g_CDF.szCabLabel) );

    RemoveBlanks( g_CDF.achINF );

    if ( fForward )
    {
        if ( lstrlen( g_CDF.achINF ) == 0 )
        {
            // use the default one
            lstrcpy( g_CDF.achINF, CABPACK_INFFILE );
        }

        if ( !GetFullPathName( g_CDF.achINF, sizeof(g_CDF.achINF),
                               g_CDF.achINF, &szTemp ) )
        {
            SysErrorMsg( hDlg );
            return FALSE;
        }

        if ( !(szExt = strchr(szTemp, '.')) )
        {
            lstrcat( szTemp, achExtINF );
        }
        else if ( lstrcmpi( szExt, achExtINF) )
        {
            lstrcpy( szExt, achExtINF );
        }

        *puNextPage = ORD_PAGE_SAVE;
    }

    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  REBOOT PAGE         ####################################################
//#                      ####################################################
//###########################################################################

//***************************************************************************
//*                                                                         *
//* NAME:       Reboot                                                      *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************

BOOL RebootInit( HWND hDlg, BOOL fFirstInit )
{
    BOOL state;

    if ( !(g_CDF.dwReboot & REBOOT_YES) )
    {
        CheckDlgButton( hDlg, IDC_REBOOT_NO, TRUE );
        CheckDlgButton( hDlg, IDC_REBOOT_ALWAYS, FALSE );
        CheckDlgButton( hDlg, IDC_REBOOT_IFNEED, FALSE );
        state = FALSE;
    }
    else
    {
        CheckDlgButton( hDlg, IDC_REBOOT_NO,   FALSE );

        CheckDlgButton( hDlg, IDC_REBOOT_ALWAYS, (g_CDF.dwReboot & REBOOT_ALWAYS) );
        CheckDlgButton( hDlg, IDC_REBOOT_IFNEED, !(g_CDF.dwReboot & REBOOT_ALWAYS) );
        state = TRUE;
    }


    CheckDlgButton( hDlg, IDC_REBOOT_SILENT, (g_CDF.dwReboot & REBOOT_SILENT) );

    EnableWindow( GetDlgItem(hDlg, IDC_REBOOT_SILENT), state );
    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RebootCmd                                                   *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************

BOOL RebootCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
                BOOL *pfKeepHistory )
{
    BOOL state;

    state = IsDlgButtonChecked( hDlg, IDC_REBOOT_NO );
    EnableWindow( GetDlgItem(hDlg, IDC_REBOOT_SILENT), !state );

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RebootOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL RebootOK( HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );

    g_CDF.dwReboot = 0;

    if ( !IsDlgButtonChecked( hDlg, IDC_REBOOT_NO ) )
    {
        g_CDF.dwReboot |= REBOOT_YES;

        if ( IsDlgButtonChecked( hDlg, IDC_REBOOT_ALWAYS ) )
            g_CDF.dwReboot |= REBOOT_ALWAYS;
    }

    if ( IsDlgButtonChecked( hDlg, IDC_REBOOT_SILENT ) )
         g_CDF.dwReboot |= REBOOT_SILENT;

    return TRUE;
}


//###########################################################################
//#                      ####################################################
//#  SAVE PAGE           ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       SaveInit                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL SaveInit( HWND hDlg, BOOL fFirstInit )
{
    PSTR pszTmp;
    char szPath[MAX_PATH];

    SetFontForControl(hDlg, IDC_EDIT_SAVE_CDF);
    if ( g_CDF.achFilename[0] == 0 )
    {
        char ch;

        pszTmp = ANSIStrRChr( g_CDF.achTarget, '.' );
        if ( pszTmp )
        {
            ch = *pszTmp;
            *pszTmp = '\0';
            lstrcpy( szPath, g_CDF.achTarget );
            *pszTmp = ch;
            lstrcat( szPath, EXT_SED );
            pszTmp = szPath;
        }
        else
            pszTmp = g_CDF.achTarget;
    }
    else
    {
        pszTmp = ANSIStrRChr( g_CDF.achFilename, '.' );
        if ( pszTmp && !lstrcmpi( pszTmp, EXT_CDF ) )
            lstrcpy( pszTmp, EXT_SED );
        pszTmp = g_CDF.achFilename;
    }
    SetDlgItemText( hDlg, IDC_EDIT_SAVE_CDF, pszTmp );

    if ( g_CDF.fSave )  {
        CheckDlgButton( hDlg, IDC_RAD_YES_SAVE,   TRUE );
        CheckDlgButton( hDlg, IDC_RAD_NO_SAVE,    FALSE );
        EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, TRUE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
    } else  {
        CheckDlgButton( hDlg, IDC_RAD_YES_SAVE,   FALSE );
        CheckDlgButton( hDlg, IDC_RAD_NO_SAVE,    TRUE );
        EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, FALSE );
        EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       SaveCmd                                                     *
//*                                                                         *
//* SYNOPSIS:   Called when dialog control pressed on page.                 *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             uCtrlID:        Control ID of control that was touched      *
//*             pfGotoPage:     If TRUE, goto the page puNextPage           *
//*             puNextPage:     Proc can fill this with next page to go to  *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL SaveCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,
              BOOL *pfKeepHistory )
{
    CHAR        achFilename[MAX_PATH] = { '\0' };
    BOOL         fResult;


    switch ( uCtrlID ) {

        case IDC_RAD_YES_SAVE:
            EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, TRUE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, TRUE );
            break;


        case IDC_RAD_NO_SAVE:
            EnableDlgItem( hDlg, IDC_EDIT_SAVE_CDF, FALSE );
            EnableDlgItem( hDlg, IDC_BUT_BROWSE, FALSE );
            break;


        case IDC_BUT_BROWSE:
            fResult = MySave( hDlg, IDS_FILTER_CDF,
                              achFilename, sizeof(achFilename), 0,
                              NULL, NULL, EXT_SED_NODOT );

            if ( fResult )  {
                SetDlgItemText( hDlg, IDC_EDIT_SAVE_CDF, achFilename );
            }

            break;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       SaveOK                                                      *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL SaveOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
             BOOL *pfKeepHistory )
{
    LPSTR szTemp;
    LPSTR szExt;
    CHAR szCDF[MAX_PATH];

    ASSERT( puNextPage );

    GetDlgItemText( hDlg, IDC_EDIT_SAVE_CDF, szCDF, sizeof(szCDF) );

    if ( fForward )
    {
        if ( IsDlgButtonChecked( hDlg, IDC_RAD_YES_SAVE ) )
        {
            if ( lstrlen( szCDF ) == 0 )
            {
                DisplayFieldErrorMsg( hDlg, IDC_EDIT_SAVE_CDF,
                                      IDS_ERR_NO_SAVE_FILENAME );
                return FALSE;
            }

            szExt = ANSIStrRChr( szCDF, '.' );
            if ( !szExt || lstrcmpi( szExt, EXT_SED ) )           // not given extension
            {
                lstrcat( szCDF, EXT_SED );
            }

            if ( ! GetFullPathName( szCDF, sizeof(szCDF), szCDF, &szTemp ) )
            {
                SysErrorMsg( hDlg );
                return FALSE;
            }

            // if there is existing CDF and is different name, copy it to new CDF first
            if ( lstrlen(g_CDF.achFilename) && lstrcmpi( szCDF, g_CDF.achFilename) )
            {
                if ( FileExists(szCDF) && MsgBox1Param( NULL, IDS_WARN_OVERIDECDF, szCDF, MB_ICONQUESTION, MB_YESNO ) == IDNO )
                    return FALSE;

                CopyFile( g_CDF.achFilename, szCDF, FALSE );
            }

            lstrcpy( g_CDF.achFilename, szCDF );
            g_CDF.fSave = TRUE;

            // make sure that the path exists
            if ( !MakeDirectory( hDlg, g_CDF.achFilename, TRUE ) )
                return FALSE;
        }
        else
            g_CDF.fSave = FALSE;

    }
    else
    {
        // back, means that the filelist may change.  Clean flag to prepare for next CDF out
        CleanFileListWriteFlag();
    }
    return TRUE;
}

//###########################################################################
//#                      ####################################################
//#  CREATE PAGE         ####################################################
//#                      ####################################################
//###########################################################################


//***************************************************************************
//*                                                                         *
//* NAME:       CreateInit                                                  *
//*                                                                         *
//* SYNOPSIS:   Called when this page is displayed.                         *
//*                                                                         *
//* REQUIRES:   hDlg:       Dialog window                                   *
//*             fFirstInit: TRUE if this is the first time the dialog is    *
//*                         initialized, FALSE if this InitProc has been    *
//*                         called before (e.g. went past this page and     *
//*                         backed up).                                     *
//*                                                                         *
//* RETURNS:    BOOL:       Always TRUE                                     *
//*                                                                         *
//***************************************************************************
BOOL CreateInit( HWND hDlg, BOOL fFirstInit )
{
    PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
    SetFontForControl(hDlg, IDC_MEDIT_STATUS);
    SetDlgItemText( hDlg, IDC_MEDIT_STATUS, "" );

    if ( fFirstInit )  {
        MEditSubClassWnd( GetDlgItem( hDlg, IDC_MEDIT_STATUS ),
                          (FARPROC) MEditSubProc );
    }

    ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE1 ), SW_SHOW );
    ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE2 ), SW_HIDE );
    ShowWindow( GetDlgItem( hDlg, IDC_TEXT_STATUS ), SW_HIDE );
    ShowWindow( GetDlgItem( hDlg, IDC_MEDIT_STATUS ), SW_HIDE );

    g_fFinish = FALSE;

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CreateOK                                                    *
//*                                                                         *
//* SYNOPSIS:   Called when Next or Back btns pressed on this page.         *
//*                                                                         *
//* REQUIRES:   hDlg:           Dialog window                               *
//*             fForward:       TRUE if 'Next' was pressed, FALSE if 'Back' *
//*             puNextPage:     if 'Next' was pressed, proc can fill this   *
//*                             in with next page to go to. This parameter  *
//*                             is ingored if 'Back' was pressed.           *
//*             pfKeepHistory:  Page will not be kept in history if proc    *
//*                             fills this in with FALSE.                   *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE means turn to next page. FALSE to keep *
//*                             the current page.                           *
//*                                                                         *
//***************************************************************************
BOOL CreateOK( HWND hDlg, BOOL fForward, UINT *puNextPage,
               BOOL *pfKeepHistory )
{
    ASSERT( puNextPage );


    *pfKeepHistory = FALSE;

    // fForward in this case indicates a click on the Finish button

    if ( fForward )  {

        if ( g_fFinish )  {
            DeleteAllItems();
            return TRUE;
        }

        PropSheet_SetWizButtons( GetParent( hDlg ), 0 );
        EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
        SetDlgItemText( hDlg, IDC_MEDIT_STATUS, "" );
        ShowWindow( GetDlgItem( hDlg, IDC_TEXT_STATUS ), SW_SHOW );
        ShowWindow( GetDlgItem( hDlg, IDC_MEDIT_STATUS ), SW_SHOW );
        
        if ( ! MakePackage( hDlg ) )  {
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
            return FALSE;
        }
            
        EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
        if ( ! g_fFinish )  {
            g_fFinish = TRUE;
            ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE1 ), SW_HIDE );
            ShowWindow( GetDlgItem( hDlg, IDC_TEXT_CREATE2 ), SW_SHOW );
            PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
            return FALSE;
        }
    }

    return TRUE;
}


BOOL SetCurrSelect( HWND hDlg, UINT ctlId, LPSTR lpSelect )
{
    LRESULT nCurSel;
    BOOL    fRet = FALSE;

    if ( *lpSelect )
    {
        // Select the file that was last selected
        nCurSel = SendDlgItemMessage( hDlg, ctlId, CB_FINDSTRINGEXACT, (WPARAM) -1,
                                      (LPARAM) lpSelect );

        if ( nCurSel != (LRESULT)CB_ERR )
        {
            SendDlgItemMessage( hDlg, ctlId, CB_SETCURSEL, (WPARAM)nCurSel, 0 );
            fRet = TRUE;
        }
        else
        {
            fRet = SetDlgItemText( hDlg, ctlId, lpSelect );
        }

    }
    return fRet;
}

void RemoveBlanks( LPSTR lpData )
{
    CHAR   achBuf[MAX_PATH];
    int     i = 0;

    if ( !lpData || *lpData == 0)
    {
        return;
    }

    lstrcpy( achBuf, lpData );

    while ( achBuf[i] && achBuf[i] == ' ' )
        i++;

    lstrcpy( lpData, achBuf+i );
}

// returns start of next field (or null if null), sets start to begining of the first field,
// with fields separated by separaters and nulls first separater after the first field
CHAR* ExtractField( CHAR **pstart, CHAR * separaters)
{
    LPSTR start = *pstart;
    int x = 0;

    while(strchr(separaters, *start)) {
        if(*start == 0)
            return(NULL);
        start++;
        }

    *pstart = start;

    while(!strchr(separaters, start[x]) && (start[x] != 0))
        x++;

    if(start[x] == 0)
        return(start + x);

    start[x] = 0;

    return(start + x + 1);
}

BOOL GetFileFromList( LPSTR lpFile, LPSTR lpFullPath )
{
    PMYITEM pMyItem;

    pMyItem = GetFirstItem();
    while ( ! LastItem( pMyItem ) )
    {
        if ( !lstrcmpi( lpFile, GetItemSz( pMyItem, 0 ) ) )
        {
            lstrcpy( lpFullPath, GetItemSz( pMyItem, 1 ) );
            lstrcat( lpFullPath, GetItemSz( pMyItem, 0 ) );
            return TRUE;
        }
        pMyItem = GetNextItem( pMyItem );
    }
    return FALSE;
}

BOOL SetAdvDLLBit( LPSTR szInfFile  )
{
    CHAR szTempFile[MAX_PATH];
    CHAR szBuf[SMALL_BUF_LEN];

    szTempFile[0] = 0;

    // you are here, we expects the file is from the package
    if ( !GetFileFromList( szInfFile, szTempFile ) )
    {
        ErrorMsg( NULL, IDS_ERR_NO_CUSTOM );
        return FALSE;
    }

    // If the key "AdvancedInf" is defined, then we set the ADVDLL bit.
    // We don't care what the key is defined as -- we only care that it exists.
    if ( GetPrivateProfileString( SEC_VERSION, KEY_ADVINF, "", szBuf, sizeof(szBuf), szTempFile )
         > 0 )
    {
        g_CDF.uExtractOpt |= EXTRACTOPT_ADVDLL;
    }
    return TRUE;
}


BOOL SetCmdFromListWithCorrectForm( LPSTR szFile, LPSTR szOutCmd )
{
    CHAR   szTempFile[MAX_PATH];
    LPSTR  szShortFile;

    // you are here, we expects the file is from the package
    if ( GetFileFromList( szFile, szTempFile ) )
    {
        if ( !(g_CDF.uExtractOpt & EXTRACTOPT_LFN_YES) )
        {
            GetShortPathName( szTempFile, szTempFile, sizeof(szTempFile) );
            szShortFile = ANSIStrRChr( szTempFile, '\\' );
            lstrcpy( szOutCmd, szShortFile+1 );
        }
        else
        {           
            lstrcpy( szTempFile, "\"" );
            lstrcat( szTempFile, szFile );
            lstrcat( szTempFile, "\"" );
            lstrcpy( szOutCmd, szTempFile );
        }
        return TRUE;
    }
    return FALSE;
}


void MyProcessLFNCmd( LPSTR szOrigiCmd, LPSTR szOutCmd )
{
    LPSTR  szFirstField, szNextField;
    CHAR   szBuf[MAX_PATH];

    // store the original form first
    lstrcpy( szOutCmd, szOrigiCmd );

    // Three cases for LFN command or its params:
    // 1) Command has no params and is one of the files in the list;
    //      we make sure the command name is consistant with file in the CAB.
    // 2) Command has params and is one of the files in the list;
    //      user has to put "..." around the LFN to get processed correctly.
    // 3) Command is not one of the files in the list;
    //      user responsible to make sure the command in valid COMMAND-LINE format.
    //
    if ( SetCmdFromListWithCorrectForm( szOrigiCmd, szOutCmd ) )
    {
        // case 1)
        return;
    }

    lstrcpy( szBuf, szOrigiCmd );
    if ( szBuf[0] == '"' )
    {
        szFirstField = szBuf+1;
        szNextField = ExtractField( &szFirstField, "\"" );
        if ( szNextField && (*szNextField == '"') )
        {
            // special case for skipping the end of double quotes around the cmd
            szNextField = CharNext( szNextField );
        }
    }
    else
    {
        szFirstField = szBuf;
        szNextField = ExtractField( &szFirstField, " " );
    }

    if ( SetCmdFromListWithCorrectForm( szFirstField, szOutCmd  ) )
    {
        // case 2)
        if ( szNextField && *szNextField )
        {
            lstrcat( szOutCmd, " " );
            lstrcat( szOutCmd, szNextField );
        }
    }

    // case 3) command is outside the package, you are on your own.
    return;
}


BOOL CheckAdvBit( LPSTR szOrigiCommand )
{
    CHAR szTmp[MAX_PATH];
    LPSTR szNextField, szCurrField, szExt;

    lstrcpy( szTmp, szOrigiCommand );

    // check if the command is LFN name
    if ( szTmp[0] == '"' )
    {
        szCurrField = &szTmp[1];
        szNextField = ExtractField( &szCurrField, "\"" );
    }
    else
    {
        szCurrField = szTmp;
        szNextField = ExtractField( &szCurrField, " " );
    }

    // check if this is a INF file command
    if ( ((szExt = ANSIStrRChr( szCurrField, '.' )) != NULL) && !lstrcmpi( szExt, achExtINF ) )
    {
        if ( !SetAdvDLLBit( szCurrField ) )
            return FALSE;
    }
    return TRUE;
}


void SysErrorMsg( HWND hWnd )
{
    LPVOID  lpMsg;
    DWORD   dwErr;

    dwErr = GetLastError();

    if ( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL, dwErr,
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                        (LPSTR)&lpMsg, 0, NULL ) )
    {
        MessageBox( hWnd, (LPSTR)lpMsg, g_CDF.achTitle, MB_ICONERROR|MB_OK
                    |((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));

        LocalFree( lpMsg );
    }
    else
    {
        char szError[SMALL_BUF_LEN];

        // should never be here, if so, post the original Win32 error code
        ErrorMsg1Param( hWnd, IDS_ERR_SYSERROR, _itoa(dwErr, szError, 10) );
    }

    return;
}

void SetFontForControl(HWND hwnd, UINT uiID)
{
   if (g_hFont)
   {
      SendDlgItemMessage(hwnd, uiID, WM_SETFONT, (WPARAM)g_hFont ,0L);
   }
}

void CleanFileListWriteFlag()
{
    PMYITEM pMyItem;

    pMyItem = GetFirstItem();
    while (!LastItem( pMyItem ) )  
    {
        pMyItem->fWroteOut = FALSE;
        pMyItem = GetNextItem( pMyItem );
    }
}

BOOL MakeCabName( HWND hwnd, PSTR pszTarget, PSTR pszCab )
{
    PSTR szTemp, szTemp1, szExt;

    if ( !GetFullPathName( pszTarget, MAX_PATH, pszTarget, &szTemp1 ) )
    {
        SysErrorMsg( hwnd );
        return FALSE;
    }

    // make sure that the path exists
    if ( !MakeDirectory( hwnd, pszTarget, TRUE) ) 
        return FALSE;

    lstrcpy( pszCab, pszTarget );
    szTemp = pszCab + lstrlen(pszCab) - lstrlen(szTemp1);

    // make sure CAB file name is 8.3 format
    //
    szExt = strchr( szTemp, '.' );
    if ( szExt )
    {
        *szExt = '\0';
    }

    if ( g_CDF.uExtractOpt & CAB_FIXEDSIZE )
    {
        // possible multiple CABs, so only take first 5 characters
        //
        if ( lstrlen( szTemp ) > 8 )
        {
            *(szTemp+8) = '\0' ;
            if ( !strchr(szTemp, '*') )
                lstrcpy( (szTemp+5), "_*" );
        }
        else if ( !strchr(szTemp, '*') )
        {
            if ( lstrlen( szTemp) > 5 )
            {
                lstrcpy( (szTemp+5), "_*" );
            }
            else
                lstrcat( szTemp, "_*" );
        }
    }
    else if ( lstrlen( szTemp ) > 8 )
    {
        DisplayFieldErrorMsg( hwnd, IDC_EDIT_TARGET, IDS_ERR_CABNAME );
        return FALSE;
    }

    // add .CAB extension in
    //
    lstrcat( szTemp, ".CAB" );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\pagefcns.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* PAGEFCNS.H -                                                            *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************
#define IDD_BACK            0x3023      // From commctrl defines...
#define IDD_NEXT            0x3024      // From commctrl defines...

#define MAX_SECLEN          80
#define MAX_TITLE           128         // Max size of Title
#define MAX_PROMPT          512         // Max size of prompt
#define MAX_CUSTOM          512         // Max size of Custom command
#define MAX_FINISHMSG       512         // Max size of Finished message
#define MAX_VERINFO         2048        // max size of version info

//***************************************************************************
//* Defines                                                                 *
//***************************************************************************
#define achExtEXE   ".EXE"
#define achExtBAT   ".BAT"
#define achExtCOM   ".COM"
#define achExtINF   ".INF"
#define achQUANTUM  "QUANTUM"
#define achMSZIP    "MSZIP"
#define achLZX      "LZX"
#define achNONE     "NONE"

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************

// This structure holds the list of files that are in the List View
// Control.

typedef struct _MyItem {
    LPSTR  aszCols[2];     // Filename and Path
    BOOL   fWroteOut;
    struct _MyItem *Next;
} MYITEM, *PMYITEM;


// This structure (generally) holds all the information that will be
// saved in the CABPack Directive File.
typedef struct _CDF {
    BOOL     fSave;
    BOOL     fPrompt;
    BOOL     fLicense;
    BOOL     fFinishMsg;
    BOOL     fUseLFN;
    CHAR    achFilename[MAX_PATH];
    CHAR    achTitle[MAX_TITLE];
    CHAR    achPrompt[MAX_PROMPT];
    CHAR    achLicense[MAX_PATH];
    CHAR    achTarget[MAX_PATH];
    CHAR    achFinishMsg[MAX_FINISHMSG];
    CHAR    achTargetPath[MAX_PATH];
    CHAR    achTargetBase[MAX_PATH];
    CHAR    achDDF[MAX_PATH];
    CHAR    achCABPath[MAX_PATH];
    CHAR    achINF[MAX_PATH];
    CHAR    achRPT[MAX_PATH];
    CHAR    achPostInstCmd[MAX_CUSTOM];
    CHAR    achInstallCmd[MAX_PATH];
    CHAR    achOrigiPostInstCmd[MAX_CUSTOM];
    CHAR    achOrigiInstallCmd[MAX_PATH];
    CHAR    achStrings[MAX_SECLEN];
    CHAR    achLocale[MAX_SECLEN];
    CHAR    achSourceFile[MAX_SECLEN];
    CHAR    achVerInfo[MAX_SECLEN];
    CHAR    szCabLabel[MAX_PATH];
    CHAR    szAdmQCmd[MAX_PATH];    
    CHAR    szOrigiAdmQCmd[MAX_PATH];
    CHAR    szUsrQCmd[MAX_PATH];
    CHAR    szOrigiUsrQCmd[MAX_PATH];
    LPSTR   lpszCookie;
    LPCSTR  szCompressionType;
    UINT    uCompressionLevel;
    LPSTR   szCAB;
    UINT     uPackPurpose;
    UINT     uShowWindow;
    UINT     uExtractOpt;
    DWORD    dwPlatform;
    DWORD    dwReboot;
    DWORD    cbFileListNum;
    DWORD    cbPackInstSpace;
    PTARGETVERINFO  pVerInfo;
    PMYITEM  pTop;
} CDF, *PCDF;



//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL WelcomeInit( HWND, BOOL );
BOOL WelcomeCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL WelcomeOK( HWND, BOOL, UINT *, BOOL * );

BOOL ModifyInit( HWND, BOOL );
BOOL ModifyOK( HWND, BOOL, UINT *, BOOL * );

BOOL TitleInit( HWND, BOOL );
BOOL TitleOK( HWND, BOOL, UINT *, BOOL * );

BOOL PromptInit( HWND, BOOL );
BOOL PromptCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL PromptOK( HWND, BOOL, UINT *, BOOL * );

BOOL LicenseTxtInit( HWND, BOOL );
BOOL LicenseTxtCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL LicenseTxtOK( HWND, BOOL, UINT *, BOOL * );

BOOL FilesInit( HWND, BOOL );
BOOL FilesCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL FilesNotify( HWND, WPARAM, LPARAM );
BOOL FilesOK( HWND, BOOL, UINT *, BOOL * );

BOOL CommandInit( HWND, BOOL );
BOOL CommandCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL CommandOK( HWND, BOOL, UINT *, BOOL * );

BOOL ShowWindowInit( HWND, BOOL );
BOOL ShowWindowOK( HWND, BOOL, UINT *, BOOL * );

BOOL FinishMsgInit( HWND, BOOL );
BOOL FinishMsgCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL FinishMsgOK( HWND, BOOL, UINT *, BOOL * );

BOOL TargetInit( HWND, BOOL );
BOOL TargetCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL TargetOK( HWND, BOOL, UINT *, BOOL * );

BOOL TargetCABInit( HWND, BOOL );
BOOL TargetCABCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL TargetCABOK( HWND, BOOL, UINT *, BOOL * );

BOOL SaveInit( HWND, BOOL );
BOOL SaveCmd( HWND, UINT, BOOL *, UINT *, BOOL * );
BOOL SaveOK( HWND, BOOL, UINT *, BOOL * );

BOOL CreateInit( HWND, BOOL );
BOOL CreateOK( HWND, BOOL, UINT *, BOOL * );

BOOL PackPurposeInit( HWND, BOOL );
BOOL PackPurposeOK( HWND, BOOL, UINT *, BOOL * );
BOOL PackPurposeCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,BOOL *pfKeepHistory );

BOOL CabLabelInit( HWND, BOOL );
BOOL CabLabelOK( HWND, BOOL, UINT *, BOOL * );
BOOL CabLabelCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,BOOL *pfKeepHistory );

BOOL RebootInit( HWND, BOOL );
BOOL RebootOK( HWND, BOOL, UINT *, BOOL * );
BOOL RebootCmd( HWND hDlg, UINT uCtrlID, BOOL *pfGotoPage, UINT *puNextPage,BOOL *pfKeepHistory );

void RemoveBlanks( LPSTR lpData );
BOOL SetCurrSelect( HWND hDlg, UINT ctlId, LPSTR lpSelect );
BOOL CheckAdvBit( LPSTR szOrigiCommand );
void MyProcessLFNCmd( LPSTR szOrigiCmd, LPSTR szOutCmd );
void SysErrorMsg( HWND );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\common\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\updres.c ===
/*
 *
 * Resource Updating Functions
 */

#if WINNT  /* for UNICODE_STRING */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <malloc.h>
#include <stdlib.h>
#endif

#include <windows.h>
#include <imagehlp.h>
#pragma hdrstop
#include "cabpack.h"
#include "sdsutils.h"
#define DPrintf( a )
#define DPrintfn( a )
#define DPrintfu( a )

#define RtlAllocateHeap(a,b,c)    malloc( c )
#define RtlFreeHeap(a,b,c)        free( c )


/*
 * BUGBUG - OPTIMIZATION PROBLEM?
 * BUGBUG - The program mysteriously does not work correctly unless
 * BUGBUG   optimization is turned off in the early section of this file.
 * BUGBUG   I don't have time to debug this, if you do please tell me what
 * BUGBUG   is wrong
 */


#pragma optimize( "", off )



#define cbPadMax    16L
 char     *pchPad = "PADDINGXXPADDING";
 char     *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";


extern CDF  g_CDF;  //global struct
extern HINSTANCE    g_hInst; // Pointer to Instance

WCHAR *
MakeUnicodeCopy( LPCSTR psz )
{
    LPWSTR result;

    if (((ULONG_PTR) psz) & (ULONG_PTR)0xFFFF0000)  {
        result = (LPWSTR) malloc( (lstrlen(psz) + 1) * sizeof(WCHAR) );
            // BUGBUG ERROR CHECKING!!! Internal tool only
        mbstowcs( result, psz, lstrlen(psz) + 1);
        return( result );
    } else {
        return( (WCHAR *) psz );
    }
}




/****************************************************************************
**
** API entry points
**
****************************************************************************/


/*++
    Routine Description
        Begins an update of resources.  Save away the name
        and current resources in a list, using EnumResourceXxx
        api set.

        Parameters:

            lpFileName - Supplies the name of the executable file that the
                resource specified by lpType/lpName/language will be updated
                in.  This file must be able to be opened for writing (ie, not
                currently executing, etc.)  The file may be fully qualified,
                or if not, the current directory is assumed.  It must be a
                valid Windows executable file.

            bDeleteExistingResources - if TRUE, existing resources are
                deleted, and only new resources will appear in the result.
                Otherwise, all resources in the input file will be in the
                output file unless specifically deleted or replaced.

        Return Value:

        NULL - The file specified was not able to be opened for writing.
        Either it was not an executable image, the executable image is
        already loaded, or the filename did not exist.  More information may
        be available via GetLastError api.

        HANDLE - A handle to be passed to the UpdateResource and
        EndUpdateResources function.
--*/


HANDLE
LocalBeginUpdateResource( LPCSTR pwch, BOOL bDeleteExistingResources )
{
    HMODULE     hModule;
    PUPDATEDATA pUpdate;
    HANDLE      hUpdate;
    LPSTR       pFileName;
    DWORD       attr;

    SetLastError(NO_ERROR);


    DEBUGMSG("LocalBeginUpdateResource() - Start");

        // Pointer Sanity check
    if (pwch == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

        // Allocate Resource Editing State (contains lists of resources)
    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
    if (hUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

        // Set reasonable start condition
    pUpdate->Status = NO_ERROR;

        // Copy Filename into state table
    pUpdate->hFileName = GlobalAlloc(GHND, (lstrlen(pwch)+1) * sizeof(TCHAR) );
    if (pUpdate->hFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pFileName = (LPSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    lstrcpy(pFileName, pwch);
    GlobalUnlock(pUpdate->hFileName);


        // Make sure file is writable, not a directory, etc.
    attr = GetFileAttributes(pFileName);
    if (attr == 0xffffffff) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    } else if (attr & (FILE_ATTRIBUTE_READONLY |
                 FILE_ATTRIBUTE_SYSTEM |
                 FILE_ATTRIBUTE_HIDDEN |
                 FILE_ATTRIBUTE_DIRECTORY)) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_WRITE_PROTECT);
        return NULL;
    }


            // If not deleting all resources, load them all in
            // by enumerating all the resources
    if (! bDeleteExistingResources)  {
        hModule = LoadLibraryEx(pwch, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL) {
            GlobalUnlock(hUpdate);
            GlobalFree(hUpdate);
            if (GetLastError() == NO_ERROR)
                SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        } else {
                EnumResourceTypes(hModule, EnumTypesFunc, (LONG_PTR) pUpdate);
        }
        FreeLibrary(hModule);
   }

    if (pUpdate->Status != NO_ERROR) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    }

    GlobalUnlock(hUpdate);

    DEBUGMSG("LocalBeginUpdateResource() - Finish");
    return hUpdate;
}











/*++
    Routine Description
        This routine adds, deletes or modifies the input resource
        in the list initialized by BeginUpdateResource.  The modify
        case is simple, the add is easy, the delete is hard.
        The ASCII entry point converts inputs to UNICODE.

        Parameters:

            hUpdateFile - The handle returned by the BeginUpdateResources
                function.

            lpType - Points to a null-terminated character string that
                represents the type name of the resource to be updated or
                added.  May be an integer value passed to MAKEINTRESOURCE
                macro.  For predefined resource types, the lpType parameter
                should be one of the following values:

                  RT_ACCELERATOR - Accelerator table
                  RT_BITMAP - Bitmap resource
                  RT_DIALOG - Dialog box
                  RT_FONT - Font resource
                  RT_FONTDIR - Font directory resource
                  RT_MENU - Menu resource
                  RT_RCDATA - User-defined resource (raw data)
                  RT_VERSION - Version resource
                  RT_ICON - Icon resource
                  RT_CURSOR - Cursor resource



            lpName - Points to a null-terminated character string that
                represents the name of the resource to be updated or added.
                May be an integer value passed to MAKEINTRESOURCE macro.

            language - Is the word value that specifies the language of the
                resource to be updated.  A complete list of values is
                available in winnls.h.

            lpData - A pointer to the raw data to be inserted into the
                executable image's resource table and data.  If the data is
                one of the predefined types, it must be valid and properly
                aligned.  If lpData is NULL, the specified resource is to be
                deleted from the executable image.

            cb - count of bytes in the data.

        Return Value:

        TRUE - The resource specified was successfully replaced in, or added
        to, the specified executable image.

        FALSE/NULL - The resource specified was not successfully added to or
        updated in the executable image.  More information may be available
        via GetLastError api.
--*/


BOOL
LocalUpdateResource(
    HANDLE      hUpdate,
    LPCTSTR     lpType,
    LPCTSTR     lpName,
    WORD        language,
    LPVOID      lpData,
    ULONG       cb
    )
{
    PUPDATEDATA pUpdate;
    PSDATA      Type;
    PSDATA      Name;
    PVOID       lpCopy;
    LONG        fRet;

    LPWSTR      lpwType;
    LPWSTR      lpwName;


    DEBUGMSG("LocalUpdateResource() Start");

            // Reset Error
    SetLastError(0);

            // Get pointer to Resource Update Session
    pUpdate = (PUPDATEDATA) GlobalLock(hUpdate);


    lpwType = MakeUnicodeCopy( lpType );
    lpwName = MakeUnicodeCopy( lpName );
    if (lpwName == NULL || lpwType == NULL) {
        if (lpwType  && lpwType != (LPWSTR) lpType)
            free( lpwType );
        if (lpwName  && lpwName != (LPWSTR) lpName)
            free( lpwName );
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    Name = AddStringOrID(lpwName, pUpdate);
    if (Name == NULL) {
        if (lpwType != (LPWSTR) lpType)
            free( lpwType );
        if (lpwName != (LPWSTR) lpName)
            free( lpwName );
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    Type = AddStringOrID(lpwType, pUpdate);
    if (Type == NULL) {
        if (lpwType != (LPWSTR) lpType)
            free( lpwType );
        if (lpwName != (LPWSTR) lpName)
            free( lpwName );
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (lpwType != (LPWSTR) lpType)
        free( lpwType );
    if (lpwName != (LPWSTR) lpName)
        free( lpwName );

    if (cb == 0) {
        lpCopy = NULL;
    } else {
        // RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        lpCopy = malloc( cb );
        if (lpCopy == NULL) {
            pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
            GlobalUnlock(hUpdate);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        memcpy( lpCopy, lpData, cb);
    }

    fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    GlobalUnlock(hUpdate);
    DEBUGMSG("LocalUpdateResource(): End");
    if (fRet == NO_ERROR)  {
        return TRUE;
    } else {
        SetLastError(fRet);
        if (lpData != NULL)
            free( lpData );
        return FALSE;
    }
}




/*++
    Routine Description
        Finishes the UpdateResource action.  Copies the
        input file to a temporary, adds the resources left
        in the list (hUpdate) to the exe.

        Parameters:

            hUpdateFile - The handle returned by the BeginUpdateResources
                function.

            fDiscard - If TRUE, discards all the updates, frees all memory.

        Return Value:

        FALSE - The file specified was not able to be written.  More
        information may be available via GetLastError api.

        TRUE -  The accumulated resources specified by UpdateResource calls
        were written to the executable file specified by the hUpdateFile
        handle.
--*/




BOOL
LocalEndUpdateResource(
                    HANDLE  hUpdate,
                    BOOL    fDiscard
                 )
{
    LPTSTR      pFileName;
    PUPDATEDATA pUpdate;
    TCHAR       pTempFileName[MAX_PATH];
    INT         cch;
    LPTSTR      p;
    LONG        rc;

    SetLastError(0);

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);

    DEBUGMSG("LocalEndUpdateResource()");

    if (fDiscard) {
        rc = NO_ERROR;
    } else {
        pFileName = (LPTSTR)GlobalLock(pUpdate->hFileName);
        strcpy(pTempFileName, pFileName);
        cch = lstrlen(pTempFileName);
        p = pTempFileName + cch;
        while (*p != '\\' && p >= pTempFileName)
            p--;
        *(p+1) = 0;
        rc = GetTempFileName(pTempFileName, "RCX", 0, pTempFileName);
        if (rc == 0) {
            rc = GetTempPath(MAX_PATH, pTempFileName);
            if (rc == 0) {
                pTempFileName[0] = '.';
                pTempFileName[1] = '\\';
                pTempFileName[2] = 0;
            }
            rc = GetTempFileName(pTempFileName, "RCX", 0, pTempFileName);
            if (rc == 0) {
                rc = GetLastError();
            } else {
                rc =  WriteResFile(hUpdate, pTempFileName);
                if (rc == NO_ERROR) {
                    DeleteFile(pFileName);
                    MoveFile(pTempFileName, pFileName);
                } else {
                    SetLastError(rc);
                    DeleteFile(pTempFileName);
                }
            }
        } else {
            rc = WriteResFile(hUpdate, pTempFileName);
            if (rc == NO_ERROR) {
                DeleteFile(pFileName);
                MoveFile(pTempFileName, pFileName);
            } else {
                SetLastError(rc);
                DeleteFile(pTempFileName);
            }
        }
        GlobalUnlock(pUpdate->hFileName);
        GlobalFree(pUpdate->hFileName);
    }

    FreeData(pUpdate);
    GlobalUnlock(hUpdate);
    GlobalFree(hUpdate);
    DEBUGMSG("LocalEndUpdateResource(): End");
    return rc?FALSE:TRUE;
}



/**********************************************************************
**
**  End of API entry points.
**
**  Beginning of private entry points for worker routines to do the
**  real work.
**
***********************************************************************/


BOOL _stdcall
EnumTypesFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LONG_PTR lParam
    )
{

    EnumResourceNames(hModule, lpType, EnumNamesFunc, lParam);

    return TRUE;
}



BOOL _stdcall
EnumNamesFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    LONG_PTR lParam
    )
{

    EnumResourceLanguages(hModule, lpType, lpName, EnumLangsFunc, lParam);
    return TRUE;
}



BOOL _stdcall
EnumLangsFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD language,
    LONG_PTR lParam
    )
{
    HANDLE  hResInfo;
    LONG    fError;
    PSDATA  Type;
    PSDATA  Name;
    ULONG   cb;
    PVOID   lpData;
    HANDLE  hResource;
    PVOID   lpResource;

    LPWSTR  lpwType;
    LPWSTR  lpwName;


    hResInfo = FindResourceEx(hModule, lpType, lpName, language);
    if (hResInfo == NULL) {
        return FALSE;
    }

    lpwType = MakeUnicodeCopy( lpType );
    lpwName = MakeUnicodeCopy( lpName );
    if (lpwType == NULL || lpwName == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    Type = AddStringOrID(lpwType, (PUPDATEDATA)lParam);
    if (lpType != (LPSTR) lpwType)
        free( lpwType );
    if (Type == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }
    Name = AddStringOrID(lpwName, (PUPDATEDATA)lParam);
    if (lpName != (LPSTR) lpwName)
        free( lpwName );
    if (Name == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    cb = SizeofResource(hModule, hResInfo);
    if (cb == 0) {
        return FALSE;
    }
    lpData = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
    if (lpData == NULL) {
        return FALSE;
    }
    RtlZeroMemory(lpData, cb);

    hResource = LoadResource(hModule, hResInfo);
    if (hResource == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpData);
        return FALSE;
    }

    lpResource = (PVOID)LockResource(hResource);
    if (lpResource == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpData);
        return FALSE;
    }

    RtlCopyMemory(lpData, lpResource, cb);

    (VOID)UnlockResource(hResource);

    (VOID)FreeResource(hResource);

    fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam, lpData, cb);
    if (fError != NO_ERROR) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    return TRUE;
}





/*
 * BUGBUG  END OF OPTIMIZATION PROBLEM
 */

#pragma optimize( "", on )







VOID
FreeOne(
    PRESNAME pRes
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes);
}


VOID
FreeData(
    PUPDATEDATA pUpd
    )
{
    PRESTYPE    pType;
    PRESNAME    pRes;
    PSDATA      pstring, pStringTmp;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID) {
        pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) {
        pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

    }

    pstring = pUpd->StringHead;
    while (pstring != NULL) {
        pStringTmp = pstring->uu.ss.pnext;
    if (pstring->discriminant == IS_STRING)
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring->szStr);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
        pstring = pStringTmp;
    }

    return;
}


/*+++

    Routines to register strings

---*/

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    )
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if (((ULONG_PTR)lp & (ULONG_PTR)0xFFFF0000) == 0) {
        //
        // an ID
        //
        pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(SDATA));
    if (pstring == NULL)
        return NULL;
    RtlZeroMemory((PVOID)pstring, sizeof(SDATA));
    pstring->discriminant = IS_ID;

        pstring->uu.Ordinal = (WORD)((ULONG_PTR)lp & (ULONG_PTR)0x0000ffff);
    }
    else {
        //
        // a string
        //
        cb = wcslen(lp) + 1;
        ppstring = &pupd->StringHead;

        while ((pstring = *ppstring) != NULL) {
            if (!wcsncmp(pstring->szStr, lp, cb))
        break;
            ppstring = &(pstring->uu.ss.pnext);
        }

        if (!pstring) {

            //
            // allocate a new one
            //

            pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG( RES_TAG ) | HEAP_ZERO_MEMORY,
                                              sizeof(SDATA)
                                             );
        if (pstring == NULL)
            return NULL;
        RtlZeroMemory((PVOID)pstring, sizeof(SDATA));

            pstring->szStr = (WCHAR*)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                            cb*sizeof(WCHAR));
            if (pstring->szStr == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
                return NULL;
        }
        pstring->discriminant = IS_STRING;
            pstring->OffsetToString = pupd->cbStringTable;

            pstring->cbData = sizeof(pstring->cbsz) + cb * sizeof(WCHAR);
            pstring->cbsz = cb - 1; /* don't include zero terminator */
            RtlCopyMemory(pstring->szStr, lp, cb*sizeof(WCHAR));

            pupd->cbStringTable += pstring->cbData;

            pstring->uu.ss.pnext=NULL;
            *ppstring=pstring;
        }
    }

    return(pstring);
}
//
// add a resource into the resource directory hiearchy
//


LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG cb
    )
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;

    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //

    while ((pType=*ppType) != NULL) {
        if (pType->Type->uu.Ordinal == Type->uu.Ordinal) {
            ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
            break;
        }
        if (fTypeID) {
            if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
        break;
        }
    else {
            if (wcsncmp(Type->szStr, pType->Type->szStr, Type->cbsz) < 0)
        break;
        }
        ppType = &(pType->pnext);
    }

    //
    // Create a new type if needed
    //

    if (ppName == NULL) {
        pType = (PRESTYPE)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESTYPE));
    if (pType == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pType, sizeof(RESTYPE));
        pType->pnext = *ppType;
        *ppType = pType;
        pType->Type = Type;
        ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //

    while ( (pName = *ppName) != NULL) {
        if (fNameID) {
        if (Name->uu.Ordinal == pName->Name->uu.Ordinal) {
        fSame = TRUE;
        break;
        }
            if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
        break;
        }
    else {
            if (wcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) == 0) {
        fSame = TRUE;
        break;
        }
            if (wcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) < 0)
        break;
        }
        ppName = &(pName->pnext);
    }

    //
    // check for delete/modify
    //

    if (fSame) {                /* same name, new language */
        if (pName->NumberOfLanguages == 1) {    /* one language currently ? */
            if (Language == pName->LanguageId) {    /* REPLACE || DELETE */
                pName->DataSize = cb;
                if (lpData == NULL) {           /* DELETE */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
        RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                (PVOID)pName->OffsetToDataEntry = lpData;
                return NO_ERROR;
            }
        else {
                if (lpData == NULL) {           /* no data but new? */
                return ERROR_INVALID_PARAMETER; /* badness */
        }
        return InsertResourceIntoLangList(pupd, Type, Name, pType, pName, Language, fNameID, cb, lpData);
        }
        }
        else {                  /* many languages currently */
        pNameM = pName;         /* save head of lang list */
        while ( (pName = *ppName) != NULL) {/* find insertion point */
            if (pName->Name != pNameM->Name ||
            Language <= pName->LanguageId)  /* here? */
                break;              /* yes */
            ppName = &(pName->pnext);   /* traverse language list */
        }

        if (pName && Language == pName->LanguageId) { /* language found? */
        if (lpData == NULL) {           /* DELETE */
            return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
        }

                pName->DataSize = cb;           /* REPLACE */
        RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                (PVOID)pName->OffsetToDataEntry = lpData;
                return NO_ERROR;
        }
        else {                  /* add new language */
        return InsertResourceIntoLangList(pupd, Type, Name, pType, pNameM, Language, fNameID, cb, lpData);
        }
    }
    }
    else {                  /* unique name */
    if (lpData == NULL) {           /* can't delete new name */
        return ERROR_INVALID_PARAMETER;
    }
    }

    //
    // add new name/language
    //

    if (!fSame) {
        if (fNameID)
            pType->NumberOfNamesID++;
        else
            pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    RtlZeroMemory((PVOID)pName, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    (PVOID)pName->OffsetToDataEntry = lpData;

    return NO_ERROR;
}


BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT Language,
    INT fType,
    INT fName
    )
{
    PPRESTYPE   ppType;
    PPRESNAME   ppName;
    PRESNAME    pNameT;

    /* find previous type node */
    ppType = fType ? &pUpd->ResTypeHeadID : &pUpd->ResTypeHeadName;
    while (*ppType != pType) {
        ppType = &((*ppType)->pnext);
    }

    /* find previous type node */
    ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    pNameT = NULL;
    while (*ppName != pName) {
    if (pNameT == NULL) {       /* find first Name in lang list */
        if (fName) {
        if ((*ppName)->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
            pNameT = *ppName;
        }
        }
        else {
        if (wcsncmp((*ppName)->Name->szStr, pName->Name->szStr, (*ppName)->Name->cbsz) == 0) {
            pNameT = *ppName;
        }
        }
    }
        ppName = &((*ppName)->pnext);
    }

    if (pNameT == NULL) {   /* first of this name? */
    pNameT = pName->pnext;  /* then (possibly) make next head of lang */
    if (pNameT != NULL) {
        if (fName) {
        if (pNameT->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
            pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
        }
        }
        else {
        if (wcsncmp(pNameT->Name->szStr, pName->Name->szStr, pNameT->Name->cbsz) == 0) {
            pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
        }
        }
    }
    }
    else
    pNameT->NumberOfLanguages--;

    if (pNameT) {
    if (pNameT->NumberOfLanguages == 0) {
        if (fName)
        pType->NumberOfNamesID -= 1;
        else
        pType->NumberOfNamesName -= 1;
    }
    }

    *ppName = pName->pnext;     /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pName->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, pName);    /* and free */

    if (*ppName == NULL) {      /* type list completely empty? */
    *ppType = pType->pnext;         /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, pType);    /* and free */
    }

    return NO_ERROR;
}

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT Language,
    INT fName,
    INT cb,
    PVOID lpData
    )
{
    PRESNAME    pNameM;
    PRESNAME    pNameNew;
    PPRESNAME   ppName;

    pNameNew = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pNameNew == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pNameNew, sizeof(RESNAME));
    pNameNew->Name = Name;
    pNameNew->Type = Type;
    pNameNew->LanguageId = (WORD)Language;
    pNameNew->DataSize = cb;
    (PVOID)pNameNew->OffsetToDataEntry = lpData;

    if (Language < pName->LanguageId) {     /* have to add to the front */
    pNameNew->NumberOfLanguages = pName->NumberOfLanguages + 1;
    pName->NumberOfLanguages = 1;

        ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    /* don't have to look for NULL at end of list !!! */
    while (pName != *ppName) {      /* find insertion point */
        ppName = &((*ppName)->pnext);   /* traverse language list */
    }
    pNameNew->pnext = *ppName;      /* insert */
    *ppName = pNameNew;
    }
    else {
    pNameM = pName;
    pName->NumberOfLanguages += 1;
    while (pName != NULL) {         /* find insertion point */
        if (Language <= pName->LanguageId)  /* here? */
        break;              /* yes */
        pNameM = pName;
        pName = pName->pnext;       /* traverse language list */
    }
    pName = pNameM->pnext;
    pNameM->pnext = pNameNew;
    pNameNew->pnext = pName;
    }
    return NO_ERROR;
}


/*
 * Utility routines
 */


ULONG
FilePos(int fh)
{

    return _llseek(fh, 0L, SEEK_CUR);
}



ULONG
MuMoveFilePos( INT fh, ULONG pos )
{
    return _llseek( fh, pos, SEEK_SET );
}



ULONG
MuWrite( INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;
    LPVOID  lpMsg;
    TCHAR  szBuf[MAX_STRING];

    n1 = _lwrite(fh, p, n);
    if ( n1 == HFILE_ERROR )
    {
        ULONG   cb;
        PUCHAR  pb;
        ULONG   cbDone, nBytes;

        // try on small buffer again
        pb = p;
        nBytes = n;
        while ( nBytes )
        {
            if (nBytes <= BUFSIZE)
                cb = nBytes;
            else
                cb = BUFSIZE;

            cbDone =  _lwrite( fh, pb, cb);
            if ( cbDone != HFILE_ERROR )
            {
                nBytes -= cbDone;
                pb += cbDone;
            }
            else
            {
                if ( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    NULL, GetLastError(),
                                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                    (LPSTR)&lpMsg, 0, NULL ) )
                {
                     TCHAR szTmp[MAX_STRING];

                     LoadSz( IDS_ERR_WRITEFILE, szTmp, sizeof(szTmp) );
                     wsprintf( szBuf, szTmp, n, lpMsg );

                     MessageBox( NULL, szBuf, g_CDF.achTitle, MB_ICONERROR|MB_OK|
                                 ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));

                     LocalFree( lpMsg );
                }
                return cbDone;  // error return
            }
         }
         return 0;  //purely simulate the old normal return here.
    }
    else if ( n1 != n)
        return n1;
    else
        return 0;
}



ULONG
MuRead(INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;

    if ((n1 = _lread( fh, p, n )) != n) {
        return n1;
    }
    else
        return 0;
}



BOOL
MuCopy( INT srcfh, INT dstfh, ULONG nbytes )
{
    ULONG   n;
    ULONG   cb=0L;
    PUCHAR  pb;

    pb = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), BUFSIZE);
    if (pb == NULL)
        return 0;
    RtlZeroMemory((PVOID)pb, BUFSIZE);

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        if (!MuRead( srcfh, pb, n )) {
        cb += n;
            MuWrite( dstfh, pb, n );
    }
        else {
        RtlFreeHeap(RtlProcessHeap(), 0, pb);
        return cb;
    }
    }
    RtlFreeHeap(RtlProcessHeap(), 0, pb);
    return cb;
}



VOID
SetResdata(
    PIMAGE_RESOURCE_DATA_ENTRY  pResData,
    ULONG           offset,
    ULONG           size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


VOID
SetRestab(
    PIMAGE_RESOURCE_DIRECTORY   pRestab,
    LONG            time,
    WORD            cNamed,
    WORD            cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER
FindSection(
    PIMAGE_SECTION_HEADER   pObjBottom,
    PIMAGE_SECTION_HEADER   pObjTop,
    LPSTR pName
    )
{

    while (pObjBottom < pObjTop) {
    if (strcmp(pObjBottom->Name, pName) == 0)
        return pObjBottom;
    pObjBottom++;
    }

    return NULL;
}


ULONG
AssignResourceToSection(
    PRESNAME    *ppRes,     /* resource to assign */
    ULONG   ExtraSectionOffset, /* offset between .rsrc and .rsrc1 */
    ULONG   Offset,     /* next available offset in section */
    LONG    Size,       /* Maximum size of .rsrc */
    PLONG   pSizeRsrc1
    )
{
    ULONG   cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size) {
    *pSizeRsrc1 = Offset;
    Offset = ExtraSectionOffset;
    DPrintf((DebugBuf, "<<< Secondary resource section @%#08lx >>>\n", Offset));
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    DPrintf((DebugBuf, "    --> %#08lx bytes at %#08lx\n", cb, Offset));
    return Offset + cb;
}



/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr  Modified for new (NT) Linear Exe format
* 1/18/92   vich    Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*             a second .rsrc section.
\****************************************************************************/

/*  */
LONG
PEWriteResFile(
    INT     inpfh,
    INT     outfh,
    ULONG   cbOldexe,
    PUPDATEDATA pUpdate
    )
{
    IMAGE_NT_HEADERS Old;   /* original header              */
    IMAGE_NT_HEADERS New;   /* working header       */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG   clock = GetTickCount(); /* current time */
    ULONG   cbName=0;   /* count of bytes in name strings */
    ULONG   cbType=0;   /* count of bytes in type strings */
    ULONG   cTypeStr=0; /* count of strings */
    ULONG   cNameStr=0; /* count of strings */
    LONG    cb;     /* temp byte count and file index */
    ULONG   cTypes = 0L;    /* count of resource types      */
    ULONG   cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG   cRes = 0L;  /* count of resources      */
    ULONG   cbRestab;   /* count of resources      */
    LONG    cbNew = 0L; /* general count */
    ULONG   ibObjTab;
    ULONG   ibObjTabEnd;
    ULONG   ibSave;
    ULONG   adjust=0;
    PIMAGE_SECTION_HEADER   pObjtblOld,
        pObjtblNew,
        pObjDebug,
        pObjResourceOld,
        pObjResourceNew,
        pObjResourceOldX,
        pObjDebugDirOld,
        pObjDebugDirNew,
        pObjNew,
        pObjOld,
        pObjLast;
    PUCHAR  p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT pResStr;
    PUSHORT pResStrEnd;
    PSDATA  pPreviousName;
    LONG    nObjResource=-1;
    LONG    nObjResourceX=-1;
    ULONG   cbResource;
    ULONG   cbMustPad = 0;
    ULONG       ibMaxDbgOffsetOld;

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS));
    ibObjTab = cbOldexe + sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
                              Old.FileHeader.SizeOfOptionalHeader;
    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);

    if (*(PUSHORT)&Old.Signature != IMAGE_NT_SIGNATURE)
    return ERROR_INVALID_EXE_SIGNATURE;

    if ((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
    (Old.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
    return ERROR_EXE_MARKED_INVALID;
    }
    DPrintfn((DebugBuf, "\n"));

    /* New header is like old one.                  */
    RtlCopyMemory(&New, &Old, sizeof(IMAGE_NT_HEADERS));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
    Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblOld, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    DPrintf((DebugBuf, "Old section table: %#08lx bytes at %#08lx(mem)\n",
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
        pObjtblOld));
    MuMoveFilePos(inpfh, ibObjTab);
    MuRead(inpfh, (PUCHAR)pObjtblOld,
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld) {
            ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
        }
    }
    DPrintf((DebugBuf, "Maximum debug offset in old file: %08x\n", ibMaxDbgOffsetOld ));

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */
    DPrintf((DebugBuf, "Beginning loop to count resources\n"));

    /* first, count those in the named type list */
    cbResource = 0;
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        //DPrintf((DebugBuf, "Resource type "));
        //DPrintfu((pType->Type->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cTypes++;
        cTypeStr++;
        cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadName;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource "));
        //DPrintfu((pRes->Name->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cRes++;
                if (pPreviousName == NULL ||
                    wcsncmp(pPreviousName->szStr,
                            pRes->Name->szStr,
                            pRes->Name->cbsz) != 0) {
            cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
            cNameStr++;
                    cNames++;
        }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadID;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }
        }
        pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    //DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        //DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
        cTypes++;
            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadName;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource "));
        //DPrintfu((pRes->Name->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cRes++;
                if (pPreviousName == NULL ||
                    wcsncmp(pPreviousName->szStr,
                            pRes->Name->szStr,
                            pRes->Name->cbsz) != 0) {
                    cNames++;
            cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
            cNameStr++;
        }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadID;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }
    }
        pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) + /* root dir (types) */
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir2 (names) */
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir3 (langs) */
    cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    (cbName + cbType) +             /* name/type strings */
    cb +                        /* padding */
    cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY); /* data entries */

    cbResource += cbRestab;     /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    if (pObjResourceOld == NULL) {
    cb = 0x7fffffff;        /* can fill forever */
    }
    else if (pObjResourceOld + 1 == pObjResourceOldX) {
    nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
    DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
    DPrintf((DebugBuf,"Merging old Resource extra section #%lu\n", nObjResource+2));
    cb = 0x7fffffff;        /* merge resource sections */
    }
    else if ((pObjResourceOld + 1) >= pObjLast) {
        nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
        cb = 0x7fffffff;        /* can fill forever (.rsrc is the last entry) */
    }
    else {
    nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
    DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
    cb = (pObjResourceOld+1)->VirtualAddress -
            pObjResourceOld->VirtualAddress;
    if (cbRestab > (ULONG)cb) {
        DPrintf((DebugBuf, "Resource Table Too Large\n"));
        return ERROR_INVALID_DATA;
    }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb) {
        if (pObjOld == pObjResourceOld + 1) {
            DPrintf((DebugBuf, "Large resource section  pushes .reloc\n"));
            cb = 0x7fffffff;        /* can fill forever */
        }
        else if (pObjResourceOldX == NULL) {
            DPrintf((DebugBuf, "Too much resource data for old .rsrc section\n"));
            nObjResourceX = (LONG)(pObjOld - pObjtblOld);
            adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
        }
        else {      /* have already merged .rsrc & .rsrc1, if possible */
            DPrintf((DebugBuf, ".rsrc1 section not empty\n"));
            nObjResourceX = (LONG)(pObjResourceOldX - pObjtblOld);
            adjust = pObjResourceOldX->VirtualAddress -
                 pObjResourceOld ->VirtualAddress;
        }
    }

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */
    DPrintf((DebugBuf, "Beginning loop to assign resources to addresses\n"));

    /* first, those in the named type list */

    cbResource = cbRestab;  /* assign resource table to 1st rsrc section */
                /* adjust == offset to .rsrc1 */
                /* cb == size availble in .rsrc */
    cbNew = 0;          /* count of bytes in second .rsrc */
    DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        DPrintf((DebugBuf, "Resource type "));
        DPrintfu((pType->Type->szStr));
        DPrintfn((DebugBuf, "\n"));
        pRes = pType->NameHeadName;
        while (pRes) {
        DPrintf((DebugBuf, "Resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
        pRes = pType->NameHeadID;
        while (pRes) {
        DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
    }
        pType = pType->pnext;
    }

    /* then, count those in the ID type list */

    DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
        pRes = pType->NameHeadName;
        while (pRes) {
        DPrintf((DebugBuf, "Resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
        pRes = pType->NameHeadID;
        while (pRes) {
        DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
    }
        pType = pType->pnext;
    }
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
    if (cbNew == 0)
    cbNew = cbResource;

    /*
     * Discover where the Debug info is (if any)?
     */
    pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
    if (pObjDebug != NULL) {
    if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0) {
        DPrintf((DebugBuf, ".debug section but no debug directory\n"));
        return ERROR_INVALID_DATA;
    }
    if (pObjDebug != pObjLast-1) {
        DPrintf((DebugBuf, "debug section not last section in file\n"));
        return ERROR_INVALID_DATA;
    }
    DPrintf((DebugBuf, "Debug section: %#08lx bytes @%#08lx\n",
         pObjDebug->SizeOfRawData,
         pObjDebug->PointerToRawData));
    }
    pObjDebugDirOld = NULL;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
    if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= pObjOld->VirtualAddress &&
        Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < pObjOld->VirtualAddress+pObjOld->SizeOfRawData) {
        pObjDebugDirOld = pObjOld;
        break;
    }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (nObjResource == -1) {       /* no old resource section */
    if (pObjOld != NULL)
        nObjResource = (LONG)(pObjOld - pObjtblOld);
    else if (pObjDebug != NULL)
        nObjResource = (LONG)(pObjDebug - pObjtblOld);
    else
        nObjResource = New.FileHeader.NumberOfSections;
    New.FileHeader.NumberOfSections++;
    }

    DPrintf((DebugBuf, "Resources assigned to section #%lu\n", nObjResource+1));
    if (nObjResourceX != -1) {
    if (pObjResourceOldX != NULL) {
        nObjResourceX = (LONG)(pObjResourceOldX - pObjtblOld);
        New.FileHeader.NumberOfSections--;
    }
    else if (pObjOld != NULL)
        nObjResourceX = (LONG)(pObjOld - pObjtblOld);
    else if (pObjDebug != NULL)
        nObjResourceX = (LONG)(pObjDebug - pObjtblOld);
    else
        nObjResourceX = New.FileHeader.NumberOfSections;
    New.FileHeader.NumberOfSections++;
    DPrintf((DebugBuf, "Extra resources assigned to section #%lu\n",
        nObjResourceX+1));
    }
    else if (pObjResourceOldX != NULL) {    /* Was old .rsrc1 section? */
    DPrintf((DebugBuf, "Extra resource section deleted\n"));
    New.FileHeader.NumberOfSections--;  /* yes, delete it */
    }

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
    adjust = (New.FileHeader.NumberOfSections -
          Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
    cb = Old.OptionalHeader.SizeOfHeaders -
    (Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
     sizeof(IMAGE_NT_HEADERS) + cbOldexe );
    if (adjust > (ULONG)cb) {
    int i;

    adjust -= cb;
    DPrintf((DebugBuf, "Adjusting header RVAs by %#08lx\n", adjust));
    for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
        if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
        New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
             apszUnit[i],
             New.OptionalHeader.DataDirectory[i].VirtualAddress,
             New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
        New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
        }
    }
    New.OptionalHeader.SizeOfHeaders += adjust;
    }

    /* Allocate storage for new section table                */
    cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    pObjtblNew = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), (short)cb);
    if (pObjtblNew == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblNew, cb);
    DPrintf((DebugBuf, "New section table: %#08lx bytes at %#08lx\n", cb, pObjtblNew));
    pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
    adjust = 0;         /* adjustment to virtual address */
    for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++) {
    if (pObjOld == pObjResourceOldX) {
        if (nObjResourceX == -1) {
            // we have to move back all the other section.
            // the .rsrc1 is bigger than what we need
            // adjust must be a negative number
            if (pObjOld+1 < pObjLast) {
                adjust -= (pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress;
            }
        }
        continue;
    }
    else if (pObjNew == pObjResourceNew) {
        DPrintf((DebugBuf, "Resource Section %i\n", nObjResource+1));
        cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
        if (pObjResourceOld == NULL) {
        adjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
        RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
        strcpy(pObjNew->Name, ".rsrc");
        pObjNew->VirtualAddress = pObjOld->VirtualAddress;
        pObjNew->PointerToRawData = pObjOld->PointerToRawData;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        pObjNew->SizeOfRawData = cb;
        pObjNew->Misc.VirtualSize = ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
        }
        else {
        *pObjNew = *pObjOld;    /* copy obj table entry */
        pObjNew->SizeOfRawData = cb;
        pObjNew->Misc.VirtualSize = ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
        if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData) {
            adjust = 0;
        }
        else if (pObjNew->SizeOfRawData > pObjOld->SizeOfRawData) {
            adjust += ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
            if (pObjOld+1 < pObjLast) {
                // if there is more stuff after pObjOld, shift it as well
                adjust -= ((pObjOld+1)->VirtualAddress-pObjOld->VirtualAddress);
            }
        }
        else {      /* is smaller, but pad so will be valid */
            adjust = 0;
            pObjNew->SizeOfRawData = pObjResourceOld->SizeOfRawData;
            pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);
            /* don't need to set VirtualSize - will be the same */
            cbMustPad = pObjResourceOld->SizeOfRawData;
        }
        }
        pObjNew++;
        if (pObjResourceOld == NULL)
        goto rest_of_table;
    }
    else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {
        DPrintf((DebugBuf, "Additional Resource Section %i\n",
        nObjResourceX+1));
        RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
        strcpy(pObjNew->Name, ".rsrc1");
        /*
         * Before we copy the virtual address we have to move back the
         * .reloc * virtual address. Otherwise we will keep moving the
         * reloc VirtualAddress forward.
         * We will have to move back the address of .rsrc1
         */
        if (pObjResourceOldX == NULL) {
        // This is the first time we have a .rsrc1
        pObjNew->VirtualAddress = pObjOld->VirtualAddress;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress - pObjNew->VirtualAddress;
        DPrintf((DebugBuf, "Added .rsrc1. VirtualAddress %lu\t adjust: %lu\n", pObjNew->VirtualAddress, adjust ));
        }
        else {
        // we already have an .rsrc1 use the position of that and
        // calculate the new adjust
        pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;

        DPrintf((DebugBuf, ".rsrc1 Keep old position.\t\tVirtualAddress %lu\t", pObjNew->VirtualAddress ));
        // Check if we have enough room in the old .rsrc1
        // Include the full size of the section, data + roundup
        if (cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
            pObjOld->VirtualAddress - pObjNew->VirtualAddress ) {
            // we have to move back all the other section.
            // the .rsrc1 is bigger than what we need
            // adjust must be a negative number
            // calc new adjust size
            adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress -
            pObjOld->VirtualAddress;
            DPrintf((DebugBuf, "adjust: %ld\tsmall: New %lu\tOld %lu\n", adjust,
            cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
            pObjOld->VirtualAddress - pObjNew->VirtualAddress));
        }
        else {
            // we have to move the section again.
            // The .rsrc1 is too small

            adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress -
            pObjOld->VirtualAddress;
            DPrintf((DebugBuf, "adjust: %lu\tsmall: New %lu\tOld %lu\n", adjust,
            cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
            pObjOld->VirtualAddress - pObjNew->VirtualAddress));
        }
        }
        pObjNew++;
        goto rest_of_table;
    }
    else if (pObjNew < pObjResourceNew) {
        DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
             pObjOld - pObjtblOld + 1, pObjNew));
        *pObjNew++ = *pObjOld;      /* copy obj table entry */
    }
    else {
rest_of_table:
        DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
             pObjOld - pObjtblOld + 1, pObjNew));
        DPrintf((DebugBuf, "adjusting VirtualAddress by %#08lx\n", adjust));
        *pObjNew++ = *pObjOld;
        (pObjNew-1)->VirtualAddress += adjust;
    }
    }


    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
                    pObjNew->SizeOfRawData,
                                    New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
    pResTab = (PIMAGE_RESOURCE_DIRECTORY)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cbRestab);
    if (pResTab == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                          */

    RtlZeroMemory((PVOID)pResTab, cbRestab);
    DPrintf((DebugBuf, "resource directory tables: %#08lx bytes at %#08lx(mem)\n", cbRestab, pResTab));
    p = (PUCHAR)pResTab;
    pResTab->Characteristics = 0L;
    pResTab->TimeDateStamp = clock;
    pResTab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pResTab->MinorVersion = MINOR_RESOURCE_VERSION;
    pResTab->NumberOfNamedEntries = (USHORT)cTypeStr;
    pResTab->NumberOfIdEntries = (USHORT)(cTypes - cTypeStr);

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResStr  = (PUSHORT)(((PUCHAR)pResData) +
        cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */
    DPrintf((DebugBuf, "building resource directory\n"));

    // First, add all the entries in the Types: Alpha list.

    DPrintf((DebugBuf, "Walk the type: Alpha list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    DPrintf((DebugBuf, "resource type "));
    DPrintfu((pType->Type->szStr));
    DPrintfn((DebugBuf, "\n"));

    pResDirT->Name = (ULONG)((((PUCHAR)pResStr) - p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
    pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    pResDirT++;

    *pResStr = pType->Type->cbsz;
    wcsncpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz);
    pResStr += pType->Type->cbsz + 1;

    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    SetRestab(pResTabN, clock,
        (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

    pRes = pType->NameHeadName;
    while (pRes) {
        DPrintf((DebugBuf, "resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL ||
                wcsncmp(pPreviousName->szStr,
                           pRes->Name->szStr,
                           pRes->Name->cbsz) != 0) {
                // Setup a new name directory

            pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

            // Copy the alpha name to a string entry

            *pResStr = pRes->Name->cbsz;
            wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
            pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

        pPreviousName = NULL;

    pRes = pType->NameHeadID;
    while (pRes) {
        DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL ||
                pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

            pResDirN->Name = pRes->Name->uu.Ordinal;
            pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

    pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.

    DPrintf((DebugBuf, "Walk the type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));

    pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
    pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    pResDirT++;

    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    SetRestab(pResTabN, clock,
        (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

    pRes = pType->NameHeadName;
    while (pRes) {
        DPrintf((DebugBuf, "resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL ||
                wcsncmp(pPreviousName->szStr,
                           pRes->Name->szStr,
                           pRes->Name->cbsz) != 0) {
                // Setup a new name directory

            pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                        IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry.

            *pResStr = pRes->Name->cbsz;
            wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
            pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

        pPreviousName = NULL;

    pRes = pType->NameHeadID;
    while (pRes) {
        DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL ||
                pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

            pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                        IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry


        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

    pType = pType->pnext;
    }
    DPrintf((DebugBuf, "Zeroing %u bytes after strings at %#08lx(mem)\n",
         (pResStrEnd - pResStr) * sizeof(*pResStr), pResStr));
    while (pResStr < pResStrEnd) {
    *pResStr++ = 0;
    }

#if DBG
    {
    USHORT  j = 0;
    PUSHORT pus = (PUSHORT)pResTab;

    while (pus < (PUSHORT)pResData) {
        DPrintf((DebugBuf, "%04x\t%04x %04x %04x %04x %04x %04x %04x %04x\n",
             j,
             *pus,
             *(pus + 1),
             *(pus + 2),
             *(pus + 3),
             *(pus + 4),
             *(pus + 5),
             *(pus + 6),
             *(pus + 7)));
        pus += 8;
        j += 16;
    }
    }
#endif /* DBG */

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    DPrintf((DebugBuf, "copying through PE header: %#08lx bytes @0x0\n",
         cbOldexe + sizeof(IMAGE_NT_HEADERS)));
    MuMoveFilePos(inpfh, 0L);
    MuCopy(inpfh, outfh, cbOldexe + sizeof(IMAGE_NT_HEADERS));

    /*
     * Copy rest of file header
     */
    DPrintf((DebugBuf, "skipping section table: %#08lx bytes @%#08lx\n",
         New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
         FilePos(outfh)));
    DPrintf((DebugBuf, "copying hdr data: %#08lx bytes @%#08lx ==> @%#08lx\n",
         Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd,
         ibObjTabEnd,
         ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
            Old.OptionalHeader.SizeOfHeaders));

    MuMoveFilePos(outfh, ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
            Old.OptionalHeader.SizeOfHeaders);
    MuMoveFilePos(inpfh, ibObjTabEnd);
    MuCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */

    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;

    /* [Inateeg update next 3 lines] */

    // Zero out the Bound Import Descriptor slot (we don't care about it for now)
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

    cb = pObjtblOld->PointerToRawData - FilePos(outfh);

    DPrintf((DebugBuf, "padding header with %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
    while (cb >= cbPadMax) {
    MuWrite(outfh, pchZero, cbPadMax);
    cb -= cbPadMax;
    }
    MuWrite(outfh, pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MuMoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ;
        pObjOld < pObjLast ;
            pObjNew++) {
    if (pObjOld == pObjResourceOldX)
        pObjOld++;
    if (pObjNew == pObjResourceNew) {

        /* Write new resource section */
        DPrintf((DebugBuf, "Primary resource section %i to %#08lx\n",
            nObjResource+1, FilePos(outfh)));

        pObjNew->PointerToRawData = FilePos(outfh);
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
        ibSave = FilePos(outfh);
        DPrintf((DebugBuf,
            "writing resource header data: %#08lx bytes @%#08lx\n",
             cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);

        pResSave = WriteResSection(pUpdate, outfh,
                    New.OptionalHeader.FileAlignment,
                    pObjResourceNew->SizeOfRawData-cbRestab,
                    NULL);
        cb = FilePos(outfh);
        DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
            cb - ibSave - cbRestab, ibSave + cbRestab));
        if (cbMustPad != 0) {
        cbMustPad -= cb - ibSave;
        DPrintf((DebugBuf, "writing MUNGE pad: %#04lx bytes @%#08lx\n",
             cbMustPad, cb));
        /* assumes that cbMustPad % cbpadMax == 0 */
        while (cbMustPad > 0) {
            MuWrite(outfh, pchPad, cbPadMax);
            cbMustPad -= cbPadMax;
        }
        cb = FilePos(outfh);
        }
        if (nObjResourceX == -1) {
        MuMoveFilePos(outfh, ibSave);
        DPrintf((DebugBuf,
            "re-writing resource directory: %#08x bytes @%#08lx\n",
            cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
        MuMoveFilePos(outfh, cb);
        cb = FilePos(inpfh);
        MuMoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
        }
        New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
        if (pObjResourceOld == NULL) {
        pObjNew++;
        goto next_section;
        }
        else
        pObjOld++;
    }
    else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {

        /* Write new resource section */
        DPrintf((DebugBuf, "Secondary resource section %i @%#08lx\n",
            nObjResourceX+1, FilePos(outfh)));

        pObjNew->PointerToRawData = FilePos(outfh);
        (void)WriteResSection(pUpdate, outfh,
            New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
        cb = FilePos(outfh);
        pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
        pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);
        DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
             pObjNew->SizeOfRawData, pObjNew->PointerToRawData));
        MuMoveFilePos(outfh, ibSave);
        DPrintf((DebugBuf,
            "re-writing resource directory: %#08x bytes @%#08lx\n",
            cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
        MuMoveFilePos(outfh, cb);
        New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
        pObjNew++;
        goto next_section;
    }
    else {
        if (pObjNew < pObjResourceNew &&
             pObjOld->PointerToRawData != 0 &&
        pObjOld->PointerToRawData != FilePos(outfh)) {
        MuMoveFilePos(outfh, pObjOld->PointerToRawData);
        }
next_section:
        /* Nop this section, because the author doesn't know what he's doing
            if ((Old.OptionalHeader.BaseOfCode == 0x400) &&
                (Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R3000 ||
                 Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R4000
                ) &&
                (pObjOld->PointerToRawData != 0) &&
                (pObjOld->VirtualAddress != New.OptionalHeader.BaseOfCode) &&
                ((pObjOld->Characteristics&IMAGE_SCN_CNT_CODE) != 0)
               ) {
                cb = FilePos(outfh) & 0xFFF;
                if (cb != 0) {
                    cb = (cb ^ 0xFFF) + 1;
                    DPrintf((DebugBuf, "padding driver code section %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
                    while (cb >= cbPadMax) {
                        MuWrite(outfh, pchZero, cbPadMax);
                        cb -= cbPadMax;
                    }
                    MuWrite(outfh, pchZero, cb);
                }
            }
        End nop. */

        DPrintf((DebugBuf, "copying section %i @%#08lx\n",
            pObjNew-pObjtblNew+1, FilePos(outfh)));
        if (pObjOld->PointerToRawData != 0) {
        pObjNew->PointerToRawData = FilePos(outfh);
        MuMoveFilePos(inpfh, pObjOld->PointerToRawData);
        MuCopy(inpfh, outfh, pObjOld->SizeOfRawData);
        }
        if (pObjOld == pObjDebugDirOld) {
        pObjDebugDirNew = pObjNew;
        }
            if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
        New.OptionalHeader.SizeOfInitializedData +=
                pObjNew->SizeOfRawData;
        pObjOld++;
    }
    }
    if (pObjResourceOldX != NULL)
    New.OptionalHeader.SizeOfInitializedData -=
            pObjResourceOldX->SizeOfRawData;


    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew,
              pObjtblNew+New.FileHeader.NumberOfSections,
              ".reloc");
    if (pObjNew != NULL) {
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
    }

    /*
     * Write new section table out.
     */
    DPrintf((DebugBuf, "Writing new section table: %#08x bytes @%#08lx\n",
         New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
         ibObjTab));
    MuMoveFilePos(outfh, ibObjTab);
    MuWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /* Seek to end of output file and issue truncating write */
    adjust = _llseek(outfh, 0L, SEEK_END);
    MuWrite(outfh, NULL, 0);
    DPrintf((DebugBuf, "File size is: %#08lx\n", adjust));

    /* If a debug section, fix up the debug table */
    pObjNew = FindSection(pObjtblNew,
              pObjtblNew+New.FileHeader.NumberOfSections,
              ".debug");
    cb = PatchDebug(inpfh, outfh,
        pObjDebug, pObjNew,
        pObjDebugDirOld, pObjDebugDirNew,
                &Old, &New, ibMaxDbgOffsetOld, &adjust);

    if (cb == NO_ERROR) {
    if (pObjResourceOld == NULL) {
        cb = (LONG)pObjResourceNew->SizeOfRawData;
    }
    else {
        cb = (LONG)pObjResourceOld->SizeOfRawData -
         (LONG)pObjResourceNew->SizeOfRawData;
    }
    cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb,
        &New, Old.OptionalHeader.SizeOfHeaders);
    }

    /* copy NOTMAPPED debug info */
    if (pObjDebugDirOld != NULL && pObjDebug == NULL &&
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size
        != 0) {
    if (New.FileHeader.PointerToSymbolTable != 0)
        New.FileHeader.PointerToSymbolTable = adjust;   /* update symbol table ptr */
    ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
    _llseek(outfh, 0L, SEEK_END);       /* to EOF */
    MuMoveFilePos(inpfh, adjust);   /* returned by PatchDebug */
    DPrintf((DebugBuf, "Copying NOTMAPPED Debug Information, %#08lx bytes\n", ibSave-adjust));
    MuCopy(inpfh, outfh, ibSave-adjust);
    }

    /*
     * Write updated PE header
     */
    DPrintf((DebugBuf, "Writing updated file header: %#08x bytes @%#08lx\n",
         sizeof(IMAGE_NT_HEADERS),
         cbOldexe));
    MuMoveFilePos(outfh, (long)cbOldexe);
    MuWrite(outfh, (char*)&New, sizeof(IMAGE_NT_HEADERS));

    /* free up allocated memory */

    DPrintf((DebugBuf, "Freeing old section table: %#08lx(mem)\n", pObjtblOld));
    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblOld);
    DPrintf((DebugBuf, "Freeing resource directory: %#08lx(mem)\n", pResTab));
    RtlFreeHeap(RtlProcessHeap(), 0, pResTab);

AbortExit:
    DPrintf((DebugBuf, "Freeing new section table: %#08lx(mem)\n", pObjtblNew));
    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblNew);
    return cb;
}


/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME    pResSave
    )
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL    fName;
    PVOID   lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop1:
    for ( ; pRes ; pRes = pRes->pnext) {
        if (pResSave != NULL && pRes != pResSave)
        continue;
        pResSave = NULL;
#if DBG
        if (pType->Type->discriminant == IS_STRING) {
            DPrintf((DebugBuf, "    "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "."));
        }
        else {
            DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
        }
        if (pRes->Name->discriminant == IS_STRING) {
            DPrintfu((pRes->Name->szStr));
        }
        else {
            DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
        }
#endif
        lpData = (PVOID)pRes->OffsetToDataEntry;
        DPrintfn((DebugBuf, "\n"));

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
        DPrintf((DebugBuf,
            "Writing resource: %#04lx bytes @%#08lx\n",
            size, FilePos(outfh)));
        MuWrite(outfh, lpData, size);
        /* pad resource     */
        cbT = REMAINDER(size, CBLONG);
#ifdef DBG
        if (cbT != 0)
            DPrintf((DebugBuf,
                "Writing small pad: %#04lx bytes @%#08lx\n",
                cbT, FilePos(outfh)));
#endif
        MuWrite(outfh, pchPad, cbT);    /* dword    */
        cbB += size + cbT;
        cbLeft -= size + cbT;       /* less left    */
        continue;       /* next resource    */
        }
        else {          /* will fill up section    */
        DPrintf((DebugBuf, "Done with .rsrc section\n"));
        goto write_pad;
        }
    }
    if (fName) {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop1;
    }
    pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop2:
    for ( ; pRes ; pRes = pRes->pnext) {
        if (pResSave != NULL && pRes != pResSave)
        continue;
        pResSave = NULL;
#if DBG
        if (pType->Type->discriminant == IS_STRING) {
            DPrintf((DebugBuf, "    "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "."));
        }
        else {
            DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
        }
        if (pRes->Name->discriminant == IS_STRING) {
            DPrintfu((pRes->Name->szStr));
        }
        else {
            DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
        }
#endif
        lpData = (PVOID)pRes->OffsetToDataEntry;
        DPrintfn((DebugBuf, "\n"));

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
        DPrintf((DebugBuf,
            "Writing resource: %#04lx bytes @%#08lx\n",
            size, FilePos(outfh)));
        MuWrite(outfh, lpData, size);
        /* pad resource     */
        cbT = REMAINDER(size, CBLONG);
#ifdef DBG
        if (cbT != 0)
            DPrintf((DebugBuf,
                "Writing small pad: %#04lx bytes @%#08lx\n",
                cbT, FilePos(outfh)));
#endif
        MuWrite(outfh, pchPad, cbT);    /* dword    */
        cbB += size + cbT;
        cbLeft -= size + cbT;       /* less left    */
        continue;       /* next resource    */
        }
        else {          /* will fill up section    */
        DPrintf((DebugBuf, "Done with .rsrc section\n"));
        goto write_pad;
        }
    }
    if (fName) {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop2;
    }
    pType = pType->pnext;
    }
    pRes = NULL;

write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    DPrintf((DebugBuf, "Writing file sector pad: %#04lx bytes @%#08lx\n",
         cbLeft, FilePos(outfh)));
    if (cbLeft != 0) {
    while (cbLeft >= cbPadMax) {
        MuWrite(outfh, pchPad, cbPadMax);
        cbLeft -= cbPadMax;
    }
    MuWrite(outfh, pchPad, cbLeft);
    }
    return pRes;
}



#if DBG

void
wchprintf(WCHAR*wch)
{
    UNICODE_STRING ustring;
    STRING  string;
    char    buf[257];
    ustring.MaximumLength = ustring.Length = wcslen(wch) * sizeof(WCHAR);
    ustring.Buffer = wch;

    string.Length = 0;
    string.MaximumLength = 256;
    string.Buffer = buf;

    RtlUnicodeStringToAnsiString(&string, &ustring, FALSE);
    buf[string.Length] = '\000';
    DPrintfn((DebugBuf, "%s", buf));
}
#endif

//
// adjust debug directory table
//

/*  */
LONG
PatchDebug(int  inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER pDebugOld,
      PIMAGE_SECTION_HEADER pDebugNew,
      PIMAGE_SECTION_HEADER pDebugDirOld,
      PIMAGE_SECTION_HEADER pDebugDirNew,
      PIMAGE_NT_HEADERS pOld,
      PIMAGE_NT_HEADERS pNew,
          ULONG ibMaxDbgOffsetOld,
      PULONG pPointerToRawData)
{
    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG   ib;
    ULONG   adjust;
    ULONG   ibNew;

    if (pDebugDirOld == NULL ||
    pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size==0)
    return NO_ERROR;

    pDbgSave = pDbg = (PIMAGE_DEBUG_DIRECTORY)RtlAllocateHeap(
            RtlProcessHeap(), MAKE_TAG( RES_TAG ),
        pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    if (pDbg == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;

    if (pDebugOld) {
    DPrintf((DebugBuf, "Patching dbg directory: @%#08lx ==> @%#08lx\n",
         pDebugOld->PointerToRawData, pDebugNew->PointerToRawData));
    }
    else
        adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MuMoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MuRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL) {
    /* find 1st entry - use for offset */
        DPrintf((DebugBuf, "Adjust: %#08lx\n",adjust));
    for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld &&
                pDbg->PointerToRawData < ibNew
               )
                ibNew = pDbg->PointerToRawData;

    if (ibNew != 0xffffffff)
        *pPointerToRawData = ibNew;
    else
        *pPointerToRawData = _llseek(inpfh, 0L, SEEK_END);
    for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++) {
        DPrintf((DebugBuf, "Old debug file offset: %#08lx\n",
             pDbg->PointerToRawData));
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld)
                pDbg->PointerToRawData += adjust - ibNew;
        DPrintf((DebugBuf, "New debug file offset: %#08lx\n",
             pDbg->PointerToRawData));
    }
    }
    else {
    for ( ; pDbg<pDbgLast ; pDbg++) {
        DPrintf((DebugBuf, "Old debug addr: %#08lx, file offset: %#08lx\n",
             pDbg->AddressOfRawData,
             pDbg->PointerToRawData));
        pDbg->AddressOfRawData += pDebugNew->VirtualAddress -
                pDebugOld->VirtualAddress;
        pDbg->PointerToRawData += pDebugNew->PointerToRawData -
                pDebugOld->PointerToRawData;
        DPrintf((DebugBuf, "New debug addr: %#08lx, file offset: %#08lx\n",
             pDbg->AddressOfRawData,
             pDbg->PointerToRawData));
    }
    }

    MuMoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MuWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    RtlFreeHeap(RtlProcessHeap(), 0, pDbgSave);

    return NO_ERROR;
}

//
// This routine patches various RVAs in the file to compensate
// for extra section table entries.
//


LONG
PatchRVAs(int   inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER po32,
      ULONG pagedelta,
      PIMAGE_NT_HEADERS pNew,
      ULONG OldSize)
{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0) {
    return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //

    DPrintf((DebugBuf, "Export offset=%08lx, hdrsize=%08lx\n",
         pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
         pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
    {
    DPrintf((DebugBuf, "No exports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    DPrintf((DebugBuf, "No exports in header to patch\n"));
    }
    else
    {
    MuMoveFilePos(inpfh, offset - hdrdelta);
    MuRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
    Exp.Name += hdrdelta;
    (ULONG)Exp.AddressOfFunctions += hdrdelta;
    (ULONG)Exp.AddressOfNames += hdrdelta;
    (ULONG)Exp.AddressOfNameOrdinals += hdrdelta;
    MuMoveFilePos(outfh, offset);
    MuWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //

    DPrintf((DebugBuf, "Import offset=%08lx, hdrsize=%08lx\n",
         pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
         pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0)
    {
    DPrintf((DebugBuf, "No imports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    DPrintf((DebugBuf, "No imports in header to patch\n"));
    }
    else
    {
    for (cimp = cmod = 0; ; cmod++)
    {
        MuMoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
        MuRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
        if (Imp.FirstThunk == 0)
        {
        break;
        }
        Imp.Name += hdrdelta;
        MuMoveFilePos(outfh, offset + cmod * sizeof(Imp));
        MuWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));

        rvaiat = (ULONG)Imp.FirstThunk;
        DPrintf((DebugBuf, "RVAIAT = %#08lx\n", (ULONG)rvaiat));
        for (i = 0; i < pNew->FileHeader.NumberOfSections; i++) {
        if (rvaiat >= po32[i].VirtualAddress &&
            rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData) {

            offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
            goto found;
        }
        }
        DPrintf((DebugBuf, "IAT not found\n"));
        return ERROR_INVALID_DATA;
found:
        DPrintf((DebugBuf, "IAT offset: @%#08lx ==> @%#08lx\n",
             offiat - pagedelta,
             offiat));
        MuMoveFilePos(inpfh, offiat - pagedelta);
        MuMoveFilePos(outfh, offiat);
        for (;;) {
        MuRead(inpfh, (PUCHAR) &iat, sizeof(iat));
        if (iat == 0) {
            break;
        }
        if ((iat & IMAGE_ORDINAL_FLAG) == 0) {  // if import by name
            DPrintf((DebugBuf, "Patching IAT: %08lx + %04lx ==> %08lx\n",
                 iat,
                 hdrdelta,
                 iat + hdrdelta));
            iat += hdrdelta;
            cimp++;
        }
        MuWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
        }
    }
    DPrintf((DebugBuf, "%u import module name RVAs patched\n", cmod));
    DPrintf((DebugBuf, "%u IAT name RVAs patched\n", cimp));
    if (cmod == 0)
    {
        DPrintf((DebugBuf, "No import modules to patch\n"));
    }
    if (cimp == 0)
    {
        DPrintf((DebugBuf, "No import name RVAs to patch\n"));
    }
    }

    return NO_ERROR;

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  RecalcChecksum(CHAR *pszFile)                                            */
/*                                                                           */
/*  Generates a correct checksum for pszFile. Returns TRUE for success       */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL RecalcChecksum(CHAR *pszFile)
{
    BOOL fSuccess = FALSE;

    HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile)
    {
        BY_HANDLE_FILE_INFORMATION fi;

        // We only do this for files smaller than 2^32-1 bytes
        if (GetFileInformationByHandle(hFile, &fi) && (0 == fi.nFileSizeHigh))
        {
            HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
            if (hMapping)
            {
                LPVOID pvView = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);

                if (pvView)
                {
                    DWORD dwCheckCurrent;
                    DWORD dwCheckNew;
                    PIMAGE_NT_HEADERS pih = CheckSumMappedFile(pvView, fi.nFileSizeLow, &dwCheckCurrent, &dwCheckNew);

                    if (pih)
                    {
                        pih->OptionalHeader.CheckSum = dwCheckNew;
                        fSuccess = TRUE;
                    }

                    UnmapViewOfFile(pvView);
                }

                CloseHandle(hMapping);
            }
        }

        CloseHandle(hFile);
    }

    return fSuccess;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/


LONG
WriteResFile(
    HANDLE  hUpdate,
    CHAR    *pDstname)
{
    HANDLE  inh;
    HANDLE  outh;
    INT     inpfh;
    INT     outfh;
    ULONG   onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    INT     rc;
    CHAR    *pFilename;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    pFilename = (CHAR*)GlobalLock(pUpdate->hFileName);

    /* open the original exe file */
    inh = CreateFile(pFilename, GENERIC_READ, 0 /*exclusive access*/, NULL /* security attr */,  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    GlobalUnlock(pUpdate->hFileName);
    if ( inh == INVALID_HANDLE_VALUE )   {
        GlobalUnlock(hUpdate);
        return ERROR_OPEN_FAILED;
    }
    inpfh = (INT)HandleToLong(inh); 

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_BAD_EXE_FORMAT;
    }

    outh = CreateFile(pDstname, GENERIC_READ|GENERIC_WRITE, 0 /*exclusive access*/, NULL /* security attr */, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (outh != INVALID_HANDLE_VALUE ) {
        outfh = (INT)HandleToLong(outh);
        rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
        _lclose(outfh);
    }
    _lclose(inpfh);

    /* Fix up the checksum for the destination file */
    RecalcChecksum(pDstname);

    GlobalUnlock(hUpdate);
    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* IDS.H -                                                                 *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_APPNAME                 1000
#define IDS_MSSERIF                 1001
#define IDS_QUERYCANCEL             1002

#define IDS_LOSE_CHANGES            1050
#define IDS_DDF_HEADER              1052
#define IDS_STATUS_MAKE_CAB         1053
#define IDS_STATUS_MAKE_EXE         1054
#define IDS_STATUS_ERROR_CAB        1055
#define IDS_STATUS_ERROR_EXE        1056
#define IDS_STATUS_ERROR_CDF        1057
#define IDS_STATUS_DONE             1058
#define IDS_FILTER_CDF              1059
#define IDS_FILTER_TXT              1060
#define IDS_FILTER_ALL              1061
#define IDS_FILTER_EXE              1062
#define IDS_HEADER_FILENAME         1070
#define IDS_HEADER_PATH             1071
#define IDS_CMD_RUNCMD              1074
#define IDS_CMD_EXTRACT             1075
#define IDS_CMD_CREATECAB           1076
#define IDS_FILTER_CAB              1077
#define IDS_FILTER_INF              1078

#define IDS_ERR_NO_MEMORY           1100
#define IDS_ERR_CDF_DOESNT_EXIST    1101
#define IDS_ERR_NO_TITLE            1102
#define IDS_ERR_NO_PROMPT           1103
#define IDS_ERR_NO_LICENSE          1104
#define IDS_ERR_LICENSE_NOT_FOUND   1105
#define IDS_ERR_DUPE_FILE           1106
#define IDS_ERR_NO_FILES            1107
#define IDS_ERR_NO_SELECT           1108
#define IDS_ERR_NO_CUSTOM           1109
#define IDS_ERR_NO_FINISHMSG        1110
#define IDS_ERR_NO_TARGET           1111
#define IDS_ERR_NO_SAVE_FILENAME    1114
#define IDS_ERR_CREATE_TARGET       1115
#define IDS_ERR_INIT_RESOURCE       1116
#define IDS_ERR_UPDATE_RESOURCE     1117
#define IDS_ERR_CLOSE_RESOURCE      1118
#define IDS_ERR_OPEN_CDF            1119
#define IDS_ERR_READ_CDF            1121
#define IDS_ERR_OPEN_DDF            1122
#define IDS_ERR_WRITE_DDF           1123
#define IDS_ERR_OPEN_RPT            1126
#define IDS_ERR_READ_RPT            1127
#define IDS_ERR_OPEN_LICENSE        1128
#define IDS_ERR_READ_LICENSE        1129
#define IDS_ERR_OPEN_CAB            1130
#define IDS_ERR_READ_CAB            1131
#define IDS_ERR_START_DIAMOND       1132
#define IDS_ERR_FILE_NOT_FOUND      1133
#define IDS_ERR_FILE_NOT_FOUND2     1134
#define IDS_ERR_SHORT_PATH          1135
#define IDS_ERR_VERSION_INFO        1137
#define IDS_ERR_BADCMDLINE          1138
#define IDS_WARN_OVERIDECDF         1139
#define IDS_WARN_MISSSTRING         1140
#define IDS_ERR_CLASSNAME           1141
#define IDS_ERR_NOSOURCEFILE        1142
#define IDS_WARN_USELFN             1143
#define IDS_ERR_WRITEFILE           1144
#define IDS_ERR_SYSERROR            1145
#define IDS_ERR_CABNAME             1146
#define IDS_ERR_CANT_SETA_FILE      1147
#define IDS_ERR_INVALID_CDF         1148
#define IDS_ERR_CDFFORMAT           1149
#define IDS_ERR_COOKIE              1151
#define IDS_ERR_VCHKFLAG            1152
#define IDS_ERR_VCHKFILE            1153
#define IDS_ERR_BADSTRING           1154
#define IDS_CREATEDIR               1155
#define IDS_INVALIDPATH             1156

//***************************************************************************
//* DIALOG PAGE IDS                                                         *
//***************************************************************************
#define IDD_WELCOME                 2000
#define IDD_MODIFY                  2001
#define IDD_TITLE                   2002
#define IDD_PROMPT                  2003
#define IDD_LICENSETXT              2004
#define IDD_FILES                   2005
#define IDD_COMMAND                 2006
#define IDD_SHOWWINDOW              2007
#define IDD_FINISHMSG               2008
#define IDD_TARGET                  2009
#define IDD_SAVE                    2010
#define IDD_CREATE                  2011
#define IDD_PACKPURPOSE             2012
#define IDD_REBOOT                  2013
#define IDD_TARGET_CAB              2014
#define IDD_CABLABEL                2015

//***************************************************************************
//* DIALOG CONTROL IDS                                                      *
//***************************************************************************
#define IDC_UNUSED                  -1
#define IDC_BMPFRAME                2100
#define IDC_BIGTEXT                 2101
#define IDC_BUT_BROWSE              2102
#define IDC_RAD_CREATE_NEW          2103
#define IDC_RAD_OPEN_EXISTING       2104
#define IDC_EDIT_OPEN_CDF           2105
#define IDC_EDIT_TITLE              2106
#define IDC_RAD_NO_PROMPT           2107
#define IDC_RAD_YES_PROMPT          2108
#define IDC_EDIT_PROMPT             2109
#define IDC_RAD_NO_LICENSE          2110
#define IDC_RAD_YES_LICENSE         2111
#define IDC_EDIT_LICENSE            2112
#define IDC_LV_CAB_FILES            2113
#define IDC_BUT_ADD                 2114
#define IDC_BUT_REMOVE              2115

#define IDC_RAD_DEFAULT             2120
#define IDC_RAD_HIDDEN              2121
#define IDC_RAD_MINIMIZED           2122
#define IDC_RAD_MAXIMIZED           2123
#define IDC_RAD_NO_FINISHMSG        2124
#define IDC_RAD_YES_FINISHMSG       2125
#define IDC_EDIT_FINISHMSG          2126
#define IDC_EDIT_TARGET             2127
#define IDC_RAD_YES_SAVE            2128
#define IDC_RAD_NO_SAVE             2129
#define IDC_EDIT_SAVE_CDF           2130
#define IDC_TEXT_CREATE1            2131
#define IDC_TEXT_CREATE2            2132
#define IDC_TEXT_STATUS             2133
#define IDC_MEDIT_STATUS            2134
#define IDC_RAD_MODIFY              2135
#define IDC_RAD_CREATE              2136

#define IDC_REBOOT_NO               2139
#define IDC_REBOOT_ALWAYS           2140
#define IDC_REBOOT_IFNEED           2141
#define IDC_REBOOT_SILENT           2142
#define IDC_CMD_NOTES               2143
#define IDC_HIDEEXTRACTUI           2144
#define IDC_CB_INSTALLCMD           2145
#define IDC_CB_POSTCMD              2146
#define IDC_USE_LFN                 2147

#define IDC_CMD_RUNCMD              2148
#define IDC_CMD_EXTRACT             2149
#define IDC_CMD_CREATECAB           2150

#define IDC_CB_RESVCABSP            2151
#define IDC_MULTIPLE_CAB            2152

#define IDC_EDIT_LAYOUTINF          2153
#define IDC_EDIT_CABLABEL           2154

//***************************************************************************
//* BITMAP AND ICON IDS                                                     *
//***************************************************************************
#define IDB_BMP                     2200
#define IDI_ICON                    2201



// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        1157
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2155
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\exescan\chksect.h ===
/* selftest.h */

typedef enum
{
    SELFTEST_NO_ERROR = 0,
    SELFTEST_NO_MEMORY,
    SELFTEST_FILE_NOT_FOUND,
    SELFTEST_READ_ERROR,
    SELFTEST_WRITE_ERROR,
    SELFTEST_NOT_PE_FILE,
    SELFTEST_NO_SECTION,
    SELFTEST_FAILED,
    SELFTEST_ALREADY,
    SELFTEST_SIGNED,
    SELFTEST_DIRTY,
    SELFTEST_MAX_RESULT
} SELFTEST_RESULT;


extern SELFTEST_RESULT AddSection(char *pszEXEFileName,char *pszCABFileName);
extern SELFTEST_RESULT SelfTest(char *pszEXEFileName,
        unsigned long *poffCabinet,unsigned long *pcbCabinet);
extern SELFTEST_RESULT CheckSection(char *pszEXEFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\common\res.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RES.H - Resource strings shared by CABPack and WExtract                 *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************
#define achResTitle         "TITLE"
#define achResLicense       "LICENSE"
#define achResShowWindow    "SHOWWINDOW"
#define achResFinishMsg     "FINISHMSG"
#define achResRunProgram    "RUNPROGRAM"
#define achResPostRunCmd    "POSTRUNPROGRAM"
#define achResCabinet       "CABINET"
#define achResUPrompt       "UPROMPT"
#define achResNone          "<None>"
#define achResNumFiles      "NUMFILES"
#define achResSize          "FILESIZES"
#define achResReboot        "REBOOT"
#define achResExtractOpt    "EXTRACTOPT"
#define achResPackInstSpace "PACKINSTSPACE"
#define achResOneInstCheck  "INSTANCECHECK"
#define achResAdminQCmd     "ADMQCMD"
#define achResUserQCmd      "USRQCMD"
#define achResVerCheck      "VERCHECK"

#define bResShowDefault         0
#define bResShowHidden          1
#define bResShowMin             2
#define bResShowMax             3

// Bits flags for extract options
//
#define EXTRACTOPT_UI_NO             0x00000001
#define EXTRACTOPT_LFN_YES           0x00000002
#define EXTRACTOPT_ADVDLL            0x00000004
#define EXTRACTOPT_COMPRESSED        0x00000008
#define EXTRACTOPT_UPDHLPDLLS        0x00000010
#define EXTRACTOPT_PLATFORM_DIR      0x00000020
#define EXTRACTOPT_INSTCHKPROMPT     0x00000040
#define EXTRACTOPT_INSTCHKBLOCK      0x00000080
#define EXTRACTOPT_CHKADMRIGHT       0x00000100
#define EXTRACTOPT_PASSINSTRET       0x00000200
#define EXTRACTOPT_CMDSDEPENDED	     0x00000400	
#define EXTRACTOPT_PASSINSTRETALWAYS 0x00000800

//
// when the Wizard is used to create CAB only, the CDF.uExtractOpt
// is used to store the CAB file options.  Pick the upper word and try
// not miss used by Extract options
//
#define CAB_FIXEDSIZE           0x00010000
#define CAB_RESVSP2K            0x00020000
#define CAB_RESVSP4K            0x00040000
#define CAB_RESVSP6K            0x00080000


#define CLUSTER_BASESIZE        512
#define MAX_NUMCLUSTERS         8

// Install EXE return code
//
#define RC_WEXTRACT_AWARE       0xAA000000  // means cabpack aware func return code
#define REBOOT_YES              0x00000001  // this bit off means no reboot
#define REBOOT_ALWAYS           0x00000002  // if REBOOT_YES is on and this bit on means always reboot
                                            //                         this bit is off means reboot if need
#define REBOOT_SILENT           0x00000004  // if REBOOT_YES is on and this bit on means not prompt user before reboot

#define KEY_ADVINF              "AdvancedINF"
#define SEC_VERSION             "Version"

// define dwFlags between wextract and advpack.dll
// The lower word is reserved for passing Quiet mode info
// defined in advpub.h
//
#define ADVFLAGS_NGCONV         0x00010000      // don't run GroupConv
#define ADVFLAGS_COMPRESSED     0x00020000      // the file to be installed is compressed
#define ADVFLAGS_UPDHLPDLLS     0x00040000      // update advpack, w95inf32 ...DLLs
#define ADVFLAGS_DELAYREBOOT 	0x00080000	// if any reboot condition there from pre, delay action
#define ADVFLAGS_DELAYPOSTCMD 	0x00100000	// if any reboot condition there from pre, delay run post setup commands

typedef struct _ADVPACKARGS {
    HWND  hWnd;
    LPSTR lpszTitle;
    LPSTR lpszInfFilename;
    LPSTR lpszSourceDir;
    LPSTR lpszInstallSection;
    WORD  wOSVer;
    DWORD dwFlags;
    DWORD dwPackInstSize;
} ADVPACKARGS, *PADVPACKARGS;

typedef struct _VER {
    DWORD dwMV;
    DWORD dwLV;
    DWORD dwBd;
} VER;

typedef struct _VERRANGE {
    VER     frVer;
    VER     toVer;
} VERRANGE, *PVERRANGE;

typedef struct _VERCHECK {
    VERRANGE    vr[2];
    DWORD       dwFlag;
    DWORD       dwstrOffs;
    DWORD       dwNameOffs;
} VERCHECK, *PVERCHECK;

typedef struct _TARGETVERINFO {
    DWORD    dwSize;
    VERCHECK ntVerCheck;
    VERCHECK win9xVerCheck;
    DWORD    dwNumFiles;
    DWORD    dwFileOffs;
    char     szBuf[1];
} TARGETVERINFO, *PTARGETVERINFO;

// define the flag field
//
#define VERCHK_OK       0x00000000
#define VERCHK_YESNO    0x00000001
#define VERCHK_OKCANCEL 0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\exescan\chksect.c ===
#include <windows.h>

#include "crc32.h"

#include "chksect.h"

#define CHECK_SECTION

#ifndef offsetof
#define offsetof(s,m) (size_t)&(((s *)0)->m)
#endif

#define RoundUp(n,scale) (scale * ((n + scale - 1) / scale))

#define IsMemZero(pv,cb) (!(*((char *)pv) || memcmp(pv,((char *)pv)+1,cb-1)))

#pragma intrinsic(memcpy,memcmp)

enum
{
    EX_CHECKSUM,
    EX_SECURITY,
    EX_CRC32FILE,
    EX_EOF,
    MAX_EXCLUDE
};

#define MAX_BUFFER              (256*1024)      /* must be even */

typedef struct
{
    DWORD   signature;
    DWORD   crc32File;
    DWORD   cbCabFile;
} SELFTEST_SECTION;

#define SECTION_NAME            "Ext_Cab1"

#define SECTION_SIGNATURE       (0x4D584653)


#ifdef ADD_SECTION
SELFTEST_RESULT AddSection(char *pszEXEFileName,char *pszCABFileName)
#else
#ifdef CHECK_SECTION
SELFTEST_RESULT CheckSection(char *pszEXEFileName)
#else
SELFTEST_RESULT SelfTest(char *pszEXEFileName,
        unsigned long *poffCabinet,unsigned long *pcbCabinet)
#endif
#endif
{
    HANDLE hFile;                       // handle to the file we're updating
    enum SELFTEST_RESULT result;        // our return code
    union
    {
        IMAGE_DOS_HEADER dos;
        IMAGE_NT_HEADERS nt;
        IMAGE_SECTION_HEADER section;
    } header;                           // used to examine the file
    DWORD offNTHeader;                  // file offset to NT header
    int cSections;                      // number of sections in the file
    unsigned char *pBuffer;             // general-purpose buffer
    DWORD cbActual;                     // # of bytes actual read/written
#ifndef CHECK_SECTION
    unsigned long crc32;                // computed CRC-32
    struct
    {
        DWORD offExclude;
        DWORD cbExclude;
    } excludeList[MAX_EXCLUDE];         // list of ranges to exclude from CRC
    int iExclude;                       // exclude list index
    DWORD offSelfTestSection;           // file offset of our added section
    SELFTEST_SECTION SelfTestSection;   // added section header
    DWORD cbFile;                       // number of bytes in file/region
    DWORD cbChunk;                      // number of bytes in current chunk
    DWORD offFile;                      // current file offset
#endif
#ifdef ADD_SECTION
    DWORD offSectionHeader;             // file offset of section header
    DWORD offMaxVirtualAddress;         // lowest unused virtual address
    DWORD cbAlignVirtual;               // virtual address alignment increment
    DWORD cbAlignFile;                  // file address alignment increment
    HANDLE hCABFile;                       // cabinet file handle
    DWORD cbCABFile;                    // cabinet file size
    DWORD checksum;                     // generated checksum
    WORD *pBufferW;                     // used to generate checksum
#endif
#ifdef CHECK_SECTION
    DWORD offSectionHeaderEnd;          // first unused byte after section headers
    DWORD offFirstSection;              // first used byte after that
    DWORD offImportStart;               // where the import entries start
    DWORD cbImport;                     // size of import entry data
#endif

#ifndef CHECK_SECTION
    GenerateCRC32Table();
#endif

    pBuffer = (void *) GlobalAlloc(GMEM_FIXED,MAX_BUFFER);
    if (pBuffer == NULL)
    {
        result = SELFTEST_NO_MEMORY;
        goto done_no_buffer;
    }

#ifdef ADD_SECTION
    /* get size of cabinet */

    hCABFile = CreateFile(pszCABFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
            OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
    if (hCABFile == INVALID_HANDLE_VALUE)
    {
        result = SELFTEST_FILE_NOT_FOUND;
        goto done_no_cab;
    }

    cbCABFile = GetFileSize(hCABFile,NULL);
#endif


    /* open EXE image */

#ifdef ADD_SECTION
    hFile = CreateFile(pszEXEFileName,GENERIC_READ|GENERIC_WRITE,0,NULL,
            OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
#else
    hFile = CreateFile(pszEXEFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
            OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL);
#endif
    if (hFile == INVALID_HANDLE_VALUE)
    {
        result = SELFTEST_FILE_NOT_FOUND;
        goto done_no_exe;
    }


    /* read MS-DOS header */

    if ((ReadFile(hFile,&header.dos,sizeof(IMAGE_DOS_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_DOS_HEADER)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    if (header.dos.e_magic != IMAGE_DOS_SIGNATURE)
    {
        offNTHeader = 0;
    }
    else
    {
        offNTHeader = header.dos.e_lfanew;
    }


    /* read PE header */

    SetFilePointer(hFile,offNTHeader,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&header.nt,sizeof(IMAGE_NT_HEADERS),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_NT_HEADERS)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    if (header.nt.Signature != IMAGE_NT_SIGNATURE)
    {
        result = SELFTEST_NOT_PE_FILE;
        goto done;
    }

    cSections = header.nt.FileHeader.NumberOfSections;

#ifdef ADD_SECTION
    cbAlignVirtual = header.nt.OptionalHeader.SectionAlignment;
    cbAlignFile = header.nt.OptionalHeader.FileAlignment;
    offMaxVirtualAddress = 0;
#endif


#ifndef CHECK_SECTION
    /* determine current file size */

    cbFile = GetFileSize(hFile,NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }
#endif

#ifndef CHECK_SECTION
    /* see if we've been signed */

    if (header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress != 0)
    {
#ifdef ADD_SECTION
        result = SELFTEST_SIGNED;
        goto done;
#else
        /* make sure certificate is at the end of the file */

        if (cbFile !=
                (header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress
                + header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size))
        {
            result = SELFTEST_FAILED;
            goto done;
        }
        else
        {
            /* ignore anything starting at the certificate */

            cbFile = header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress;
        }
#endif
    }
#endif

#ifdef ADD_SECTION
    /* determine lowest un-used virtual address */
#else
    /* locate our added section */
#endif

#ifndef CHECK_SECTION
    offSelfTestSection = 0;
#endif

#ifdef ADD_SECTION
    offSectionHeader = offNTHeader +
            sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
            header.nt.FileHeader.SizeOfOptionalHeader +
            cSections * sizeof(IMAGE_SECTION_HEADER);
#endif

    SetFilePointer(hFile,(offNTHeader + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
            header.nt.FileHeader.SizeOfOptionalHeader),NULL,FILE_BEGIN);

#ifdef CHECK_SECTION
    offSectionHeaderEnd = offNTHeader +
            sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) +
            header.nt.FileHeader.SizeOfOptionalHeader +
            cSections * sizeof(IMAGE_SECTION_HEADER);

    offImportStart = header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
    cbImport = header.nt.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;

    if ((ReadFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    offFirstSection = header.section.PointerToRawData;

    if ((offFirstSection - offSectionHeaderEnd) > 0)
    {
        SetFilePointer(hFile,offSectionHeaderEnd,NULL,FILE_BEGIN);

        if ((ReadFile(hFile,pBuffer,(offFirstSection - offSectionHeaderEnd),&cbActual,NULL) != TRUE)
                || (cbActual != (DWORD) (offFirstSection - offSectionHeaderEnd)))
        {
            result = SELFTEST_READ_ERROR;
            goto done;
        }

        if ((offImportStart >= offSectionHeaderEnd) &&
            ((offImportStart + cbImport) <= offFirstSection))
        {
            memset(pBuffer + (offImportStart - offSectionHeaderEnd),0,cbImport);
        }

        if ((*pBuffer != '\0') ||
            (((offFirstSection - offSectionHeaderEnd) > 1) &&
            (memcmp(pBuffer,pBuffer + 1,(offFirstSection - offSectionHeaderEnd - 1)) != 0)))
        {
            result = SELFTEST_DIRTY;
        }
        else
        {
            result = SELFTEST_NO_ERROR;
        }
    }
    else
    {
        result = SELFTEST_NO_ERROR;
    }
#else
    while (cSections--)
    {
        if ((ReadFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
                || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
        {
            result = SELFTEST_READ_ERROR;
            goto done;
        }

        if (!memcmp(header.section.Name,SECTION_NAME,sizeof(header.section.Name)))
        {
            /* found our added section */

#ifdef ADD_SECTION
            result = SELFTEST_ALREADY;
            goto done;
#else
            offSelfTestSection = header.section.PointerToRawData;

            break;
#endif
        }

#ifdef ADD_SECTION
        if (offMaxVirtualAddress <
                (header.section.VirtualAddress + header.section.Misc.VirtualSize))
        {
            offMaxVirtualAddress =
                (header.section.VirtualAddress + header.section.Misc.VirtualSize);
        }
#endif
    }

#ifdef ADD_SECTION
    /* increase number of sections in the file; whack checksum */

    SetFilePointer(hFile,offNTHeader,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&header.nt,sizeof(IMAGE_NT_HEADERS),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_NT_HEADERS)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    header.nt.FileHeader.NumberOfSections++;
    header.nt.OptionalHeader.CheckSum = 0;
    header.nt.OptionalHeader.SizeOfImage =
            RoundUp(offMaxVirtualAddress,cbAlignVirtual) +
            RoundUp((sizeof(SELFTEST_SECTION) + cbCABFile),cbAlignVirtual);

    SetFilePointer(hFile,offNTHeader,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&header.nt,sizeof(IMAGE_NT_HEADERS),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_NT_HEADERS)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* make sure there's room for another section header */

    SetFilePointer(hFile,offSectionHeader,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }

    if (!IsMemZero(&header.section,sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_NO_SECTION;
        goto done;
    }


    /* create the new section header */

    memcpy(header.section.Name,SECTION_NAME,sizeof(header.section.Name));
    header.section.SizeOfRawData = 
            RoundUp((sizeof(SELFTEST_SECTION) + cbCABFile),cbAlignFile);
    header.section.PointerToRawData =
            RoundUp(cbFile,cbAlignFile);
    header.section.VirtualAddress =
            RoundUp(offMaxVirtualAddress,cbAlignVirtual);
    header.section.Misc.VirtualSize =
            RoundUp((sizeof(SELFTEST_SECTION) + cbCABFile),cbAlignVirtual);
    header.section.Characteristics = (IMAGE_SCN_CNT_INITIALIZED_DATA |
            IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_READ);


    /* write the new section header */

    SetFilePointer(hFile,offSectionHeader,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&header.section,sizeof(IMAGE_SECTION_HEADER),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(IMAGE_SECTION_HEADER)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* create the new section data */

    memset(&SelfTestSection,0,sizeof(SelfTestSection));
    SelfTestSection.signature = SECTION_SIGNATURE;
    SelfTestSection.cbCabFile = cbCABFile;

    offSelfTestSection = header.section.PointerToRawData;

    SetFilePointer(hFile,offSelfTestSection,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&SelfTestSection,sizeof(SelfTestSection),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(SelfTestSection)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* copy cabinet into section */

    SetFilePointer(hCABFile,0,NULL,FILE_BEGIN);

    cbFile = cbCABFile;

    while (cbFile)
    {
        if (cbFile > MAX_BUFFER)
        {
            cbChunk = MAX_BUFFER;
        }
        else
        {
            cbChunk = cbFile;
        }

        if ((ReadFile(hCABFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                || (cbActual != cbChunk))
        {
            result = SELFTEST_READ_ERROR;
            goto done;
        }

        if ((WriteFile(hFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                || (cbActual != cbChunk))
        {
            result = SELFTEST_WRITE_ERROR;
        }

        cbFile -= cbChunk;
    }


    /* pad added section as needed */

    cbChunk = header.section.SizeOfRawData - sizeof(SelfTestSection) - cbCABFile;

    if (cbChunk != 0)
    {
        memset(pBuffer,0,cbChunk);

        if ((WriteFile(hFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                || (cbActual != cbChunk))
        {
            result = SELFTEST_WRITE_ERROR;
        }
    }


    /* we've now increased total size of the file */

    cbFile = offSelfTestSection + header.section.SizeOfRawData;
#else

    /* make sure our added section was found */

    if (offSelfTestSection == 0)
    {
        result = SELFTEST_NO_SECTION;
        goto done;
    }
#endif

    /* If this EXE gets signed, the checksum will be changed.       */

    excludeList[EX_CHECKSUM].offExclude = offNTHeader + 
            offsetof(IMAGE_NT_HEADERS,OptionalHeader.CheckSum);
    excludeList[EX_CHECKSUM].cbExclude =
            sizeof(header.nt.OptionalHeader.CheckSum);


    /* If this EXE gets signed, the security entry will be changed. */

    excludeList[EX_SECURITY].offExclude = offNTHeader +
        offsetof(IMAGE_NT_HEADERS,
            OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]);
    excludeList[EX_SECURITY].cbExclude = sizeof(IMAGE_DATA_DIRECTORY);


    /* Can't CRC our own CRC field.                                 */

    excludeList[EX_CRC32FILE].offExclude = offSelfTestSection +
            offsetof(SELFTEST_SECTION,crc32File);
    excludeList[EX_CRC32FILE].cbExclude = sizeof(SelfTestSection.crc32File);


    /* Stop at end of known file.                                   */

    /* Note: current code assumes that the only thing which could   */
    /* be appended to the file after this is the certificate from   */
    /* codesigning, and that it will be pointed at by the security  */
    /* entry.  If anything else appends, or padding is added before */
    /* the certificate, we'll have to store this file size in the   */
    /* added section, and retrieve it before running the CRC.       */

    excludeList[EX_EOF].offExclude = cbFile;


    /*  Compute the CRC-32 of the file, skipping excluded extents.  */
    /*  This code assumes excludeList is sorted by offExclude.      */

    crc32 = CRC32_INITIAL_VALUE;
    offFile = 0;

#ifdef ADD_SECTION
    /*  Along the way, compute the correct checksum for this new    */
    /*  image.  We know that each of the sections on the exclude    */
    /*  list just happened to be zeroed right now, so they won't    */
    /*  affect our checksum.  But we will have to add our new CRC32 */
    /*  value to the checksum, because it will be in the file when  */
    /*  we're done.  It helps that we know that all the exclusions  */
    /*  on the list are WORD aligned and have even lengths.         */

    /*  The checksum in a PE file is a 16-bit sum of 16-bit words   */
    /*  in the file, with wrap-around carry, while the checksum     */
    /*  field is filled with zero.  The file's length is added,     */
    /*  yielding a 32-bit result.                                   */

    checksum = 0;
#endif

    for (iExclude = 0; iExclude < MAX_EXCLUDE; iExclude++)
    {
        SetFilePointer(hFile,offFile,NULL,FILE_BEGIN);

        cbFile = excludeList[iExclude].offExclude - offFile;

        while (cbFile)
        {
            if (cbFile > MAX_BUFFER)
            {
                cbChunk = MAX_BUFFER;
            }
            else
            {
                cbChunk = cbFile;
            }

            if ((ReadFile(hFile,pBuffer,cbChunk,&cbActual,NULL) != TRUE)
                    || (cbActual != cbChunk))
            {
                result = SELFTEST_READ_ERROR;
                goto done;
            }

            CRC32Update(&crc32,pBuffer,cbChunk);

            offFile += cbChunk;
            cbFile -= cbChunk;

#ifdef ADD_SECTION
            /* roll buffer into checksum */

            pBufferW = (WORD *) pBuffer;

            cbChunk >>= 1;

            while (cbChunk--)
            {
                checksum += *pBufferW++;

                if (checksum > 0x0000FFFF)
                {
                    checksum -= 0x0000FFFF;
                }
            }
#endif

            /*
             *  INSERT PROGRESS GAUGE HERE:
             *  %complete = (offFile * 100.0) / excludeList[EX_EOF].offExclude
             */
        }

        offFile += excludeList[iExclude].cbExclude;
    }


#ifdef ADD_SECTION
    /* account for CRC32 value in checksum */

    checksum += (WORD) crc32;
    checksum += (crc32 >> 16);

    while (checksum > 0x0000FFFF)
    {
        checksum -= 0x0000FFFF;
    }


    /* add file length to checksum */

    checksum += excludeList[EX_EOF].offExclude;


    /* update CRC-32 value in added section */

    SetFilePointer(hFile,excludeList[EX_CRC32FILE].offExclude,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&crc32,sizeof(crc32),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(crc32)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* update checksum value in header */

    SetFilePointer(hFile,excludeList[EX_CHECKSUM].offExclude,NULL,FILE_BEGIN);

    if ((WriteFile(hFile,&checksum,sizeof(checksum),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(checksum)))
    {
        result = SELFTEST_WRITE_ERROR;
        goto done;
    }


    /* done */

    if (CloseHandle(hFile) != TRUE)
    {
        result = SELFTEST_WRITE_ERROR;
    }
    else
    {
        result = SELFTEST_NO_ERROR;
    }

    goto done_no_exe;
#else
    /* read the header from the added section */

    SetFilePointer(hFile,offSelfTestSection,NULL,FILE_BEGIN);

    if ((ReadFile(hFile,&SelfTestSection,sizeof(SelfTestSection),&cbActual,NULL) != TRUE)
            || (cbActual != sizeof(SelfTestSection)))
    {
        result = SELFTEST_READ_ERROR;
        goto done;
    }


    /* verify CRC-32 value in added section */

    if ((SelfTestSection.signature != SECTION_SIGNATURE) ||
            (crc32 != SelfTestSection.crc32File))
    {
        result = SELFTEST_FAILED;
    }
    else
    {
        *poffCabinet = offSelfTestSection + sizeof(SelfTestSection);
        *pcbCabinet = SelfTestSection.cbCabFile;

        result = SELFTEST_NO_ERROR;
    }
#endif
#endif  // CHECK_SECTION

done:
    CloseHandle(hFile);

done_no_exe:

#ifdef ADD_SECTION
    CloseHandle(hCABFile);

done_no_cab:
#endif

    GlobalFree((HGLOBAL) pBuffer);

done_no_buffer:

#ifdef ADD_SECTION
    /* destroy failed attempt */

    if (result != SELFTEST_NO_ERROR)
    {
        DeleteFile(pszEXEFileName);
    }
#endif

    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\version.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1996. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* VERSION.C - Function to overwrite the versin information from           *
//*             wextract.exe                                                *
//*                                                                         *
//***************************************************************************
//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "cabpack.h"
#include <memory.h> 

extern CDF   g_CDF;
extern TCHAR g_szOverideCDF[MAX_PATH];
extern TCHAR g_szOverideSec[SMALL_BUF_LEN];

// Function prototypes
BOOL UpdateVersionInfo(LPBYTE lpOldVersionInfo, LPBYTE *lplpNewVersionInfo, WORD *pwSize);
BOOL FindVerValue( WCHAR *lpKey, WCHAR *lpszData, WORD *pwLen);
BOOL CALLBACK MyEnumLangsFunc(HANDLE hModule, LPSTR lpType, LPSTR lpName, WORD languages, LONG lParam);

// External function and variables
DWORD MyGetPrivateProfileString( LPCTSTR lpSec, LPCTSTR lpKey, LPCTSTR lpDefault,
                                LPTSTR lpBuf, UINT uSize, LPCTSTR lpOverSec );
void MyWritePrivateProfileString( LPCTSTR lpSec, LPCTSTR lpKey, LPTSTR lpBuf, UINT uSize );

//////////////////////////////////////////////////////////////////////////////
//// Version information overwrite functions and data types
#define KEY_FROMFILE        "FromFile"
#define COMPANYNAME         "CompanyName"
#define INTERNALNAME        "InternalName"
#define ORIGINALFILENAME    "OriginalFilename"
#define PRODUCTNAME         "ProductName"
#define PRODUCTVERSION      "ProductVersion"
#define FILEVERSION         "FileVersion"
#define FILEDESCRIPTION     "FileDescription"
#define LEGALCOPYRIGHT      "LegalCopyright"

#define MAX_VALUE   256

// What language is the version information in?
WORD    wVerLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
// Structure to save the keys and values for the Version info
typedef struct _VERINFO
{
    LPSTR   lpszName;
    CHAR    szValue[MAX_VALUE];
} VERINFO;

// Array of keys and values which can be changed.
VERINFO Verinfo_Array[] = { 
                    { COMPANYNAME, ""},
                    { INTERNALNAME, ""},
                    { ORIGINALFILENAME, ""},
                    { PRODUCTNAME, ""},
                    { PRODUCTVERSION, ""},
                    { FILEVERSION, ""},
                    { FILEDESCRIPTION, ""},
                    { LEGALCOPYRIGHT, ""}
                    };

#define ARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))

UINT    VerInfoElem = ARRAYSIZE(Verinfo_Array);

//... Decrement WORD at *pw by given amount w
#define DECWORDBY( pw,w) if (pw) { *(pw) = (*(pw) > (w)) ? *(pw) - (w) : 0;}

//... Increment WORD at *pw by given amount w
#define INCWORDBY( pw,w) if (pw) { *(pw) += (w);}

#define MEMSIZE( x ) ((x) * 2) 
                // was sizeof( TCHAR))

#define STRINGFILEINFOLEN  15
#define LANGSTRINGLEN  8    //... # WCHARs in string denoting language
                            //... and code page in a Version resource.
#define VERTYPESTRING  1    //... Version data value is a string

#pragma pack(1)
typedef struct VERBLOCK
{
    WORD  wLength;          // Length of this block
    WORD  wValueLength;     // Length of the valuedata
    WORD  wType;            // Type of data (1=string, 0=binary)
    WCHAR szKey[1];         // data
} VERBLOCK ;

typedef VERBLOCK * PVERBLOCK;

typedef struct VERHEAD
{
    WORD wTotLen;
    WORD wValLen;
    WORD wType;
    TCHAR szKey[( sizeof( TEXT("VS_VERSION_INFO" )) +3 )&~03];
    VS_FIXEDFILEINFO vsf;

} VERHEAD ;
#pragma pack()


// Do the version info update
//
// szFile is the file we want to update the version info from
// hUpdate is the handle to the resource info which will be used to update all resources
//
BOOL DoVersionInfo(HWND hDlg, LPSTR szFile, HANDLE hUpdate)
{
    HINSTANCE   hModule;
    HRSRC       hrsrc;
    HGLOBAL     hgbl;
    LPBYTE      lp;
    LPBYTE      lpCopy;
    WORD        wSize;

    if (GetVersionInfoFromFile())
    {
        // Get the current version info from the file
        hModule = LoadLibraryEx(szFile, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL)
            return FALSE;       // Should not happen, we loaded the module before

        // Determine the language of the version information
        EnumResourceLanguages(hModule, RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO), (ENUMRESLANGPROC)MyEnumLangsFunc, 0L);
        
        hrsrc = FindResourceEx (hModule, RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO), wVerLang);
        if (hrsrc == NULL)
        {
            FreeLibrary(hModule);
            return FALSE;       // Should we continue???
        }
        if ((hgbl = LoadResource(hModule, hrsrc)) == NULL)
        {
            FreeResource(hrsrc);
            FreeLibrary(hModule);
            return FALSE;       // Should we continue???
        }

        if ((lp = LockResource(hgbl)) == NULL)
        {
            FreeResource(hrsrc);
            FreeLibrary(hModule);
            return FALSE;       // Should we continue???
        }

        // UPdate the version information, If success, lpCopy has the pointer to the update info
        UpdateVersionInfo(lp, &lpCopy, &wSize);
        UnlockResource(hgbl);
        FreeResource(hrsrc);
        FreeLibrary(hModule);

        if (lpCopy != NULL)
        {
            // Now update the resource for the file
            if ( LocalUpdateResource( hUpdate, RT_VERSION,
                 MAKEINTRESOURCE(VS_VERSION_INFO), wVerLang, //MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                 lpCopy, wSize) == FALSE )
            {
                free (lpCopy);
                ErrorMsg( hDlg, IDS_ERR_UPDATE_RESOURCE );
                return FALSE;
            }
            free (lpCopy);
        }

        return TRUE;
    }
    return TRUE;
}

// Get the version information we use to overwrite from the CDF file
BOOL GetVersionInfoFromFile()
{
    char    szFilename[MAX_STRING];
    HLOCAL  hInfoBuffer;
    LPSTR   lpValueBuffer;
    char    szQuery[128];
    DWORD   dwBytes;
    DWORD   dwLangCharset;
    DWORD   dwInfoBuffer;
    DWORD   dwDummy;
    UINT    i;

    if ( MyGetPrivateProfileString(SEC_OPTIONS, KEY_VERSIONINFO, "", g_CDF.achVerInfo, sizeof(g_CDF.achVerInfo), g_szOverideSec ) > 0)
    {
        // We better zero the version info in our array.
        for (i = 0; i < VerInfoElem; i++)
        {
            Verinfo_Array[i].szValue[0] = '\0';
        }

        if ( MyGetPrivateProfileString( g_CDF.achVerInfo, KEY_FROMFILE, "", szFilename, sizeof(szFilename), g_CDF.achVerInfo) > 0)
        {
            // Fill the version info from the file version info

            // determine if the file contains version information
            // and get the size of the information if so
            dwInfoBuffer = GetFileVersionInfoSize(szFilename, &dwDummy);

            if (dwInfoBuffer != 0)
            {

                // allocate memory to hold the version information
                hInfoBuffer = LocalAlloc(LMEM_FIXED, dwInfoBuffer);

                if (hInfoBuffer != NULL)
                {

                    // read version information into our memory
                    if (GetFileVersionInfo(szFilename, 0, dwInfoBuffer, (LPVOID)hInfoBuffer) != 0)
                    {
                        // get language and character set information
                        if (VerQueryValue((LPVOID)hInfoBuffer, "\\VarFileInfo\\Translation",
                                &lpValueBuffer, &dwBytes))
                            dwLangCharset = *(LPDWORD)lpValueBuffer;
                        else
                            dwLangCharset = 0x04E40409;         // If we don't have any default to US. Should never happen

                        // Now get the version info from the file
                        for (i = 0; i < VerInfoElem; i++)
                        {
                            // get version information string
                            wsprintf(szQuery, "\\StringFileInfo\\%4.4X%4.4X\\%s",
                                    LOWORD(dwLangCharset), HIWORD(dwLangCharset), Verinfo_Array[i].lpszName);

                            if (VerQueryValue((LPVOID)hInfoBuffer, szQuery, (LPVOID)&lpValueBuffer, &dwBytes) != 0)
                                lstrcpyn(Verinfo_Array[i].szValue,lpValueBuffer, MAX_VALUE-1);        // Found one, take it
                        }
                    }
                    LocalFree(hInfoBuffer);
                }
            }
        } // Got version info from file

        // Now see if we have to overwrite some info from the batch file.
        for (i = 0; i < VerInfoElem; i++)
        {
            if (MyGetPrivateProfileString(g_CDF.achVerInfo, Verinfo_Array[i].lpszName, "", szFilename, MAX_VALUE, g_CDF.achVerInfo) > 0)
            {
                lstrcpyn(Verinfo_Array[i].szValue, szFilename, MAX_VALUE-1);
            }
        }
        return TRUE;
    }
    return FALSE;
}


// Update the lpOldVersionInfo with the overwritable data.
// lpOldVersionInfo: pointer to the old version info data block
// lplpNewVersionInfo: Will get the pointer to the updated version info data, 
//      the caller has to free the buffer if the pointer is not NULL,
// pwSize: pointer to a word which will return the size of the new version info block
//
// Note: This code assumes that there is only one language data block in the version info data.
//
BOOL UpdateVersionInfo(LPBYTE lpOldVersionInfo, LPBYTE *lplpNewVersionInfo, WORD *pwSize)
{
    WCHAR       szData[MAX_STRING]; // Will hold the data to put into the versin info
    WORD        wDataLen = 0;            //... Length of old resource data
    WORD        wVerHeadSize;            //... Sizeof of the VERHEAD struct
    int         nNewVerBlockSize = 0;   // Size of the new version info data block
    PVERBLOCK   pNewVerStamp = NULL;    // Pointer to the new version info data block
    PVERBLOCK   pNewBlk      = NULL;    // Pointer to the currently worked on data in new verblock
    VERHEAD     *pVerHdr = (VERHEAD*)lpOldVersionInfo;  // Pointer to old verinfo
    VERBLOCK    *pVerBlk;               // Pointer to the currently worked on data in old verblock
    LPBYTE      lp;                     // Pointer to the data area to copy (overwrite)
    WORD        wStringTableLen = 0;    // Bytes (left) in the language data block
    PVERBLOCK   pNewStringTblBlk;       // Pointer to the language part for the version info
    WORD        wStringInfoLen = 0;     //... # of bytes in StringFileInfo
    PVERBLOCK   pNewStringInfoBlk;      //... Start of this StringFileInfo blk
    WORD        wLen = 0;


    *lplpNewVersionInfo = NULL;
    *pwSize = 0;
    wVerHeadSize = (WORD)(3 * sizeof(WORD) + MEMSIZE(lstrlen("VS_FIXEDFILEINFO") + 1) + sizeof(VS_FIXEDFILEINFO));
    wVerHeadSize = ROUNDUP(wVerHeadSize, 4);

    // Total length of the version information
    wDataLen = pVerHdr->wTotLen;

    if ( wDataLen == 0 || wDataLen == (WORD)-1 )
    {
        return(FALSE);             //... No resource data
    }

    //... Allocate buffer to hold New Version
    //... Stamping Block (make the buffer large to
    //... account for expansion of strings 
    pVerBlk = (PVERBLOCK)((PBYTE)pVerHdr + wVerHeadSize);       // point into version block of the old info

    // we potentialy replace 8 (VerInfoElem=8) string in the version info
    // I alloc 9 * 2 * 256 + size of the current version info. This should give us plenty of space
    // I need to multiply by 2 because we work with unicode strings. One character = 2 bytes.
    nNewVerBlockSize = wDataLen + (2 * (VerInfoElem+1) * MAX_VALUE);
    pNewVerStamp = (PVERBLOCK)malloc( nNewVerBlockSize ); 
    //... Fill new memory block with zeros
    memset((void *)pNewVerStamp, 0, nNewVerBlockSize);

    //... Copy version info header into new version buffer
    memcpy((void *)pNewVerStamp, (void *)pVerHdr, wVerHeadSize);
    pNewVerStamp->wLength = wVerHeadSize;
    
    //... Move after version info header
    pNewBlk = (PVERBLOCK)((PBYTE)pNewVerStamp + wVerHeadSize);

    wDataLen -= wVerHeadSize;

    if (wDataLen > 0)
    {                           //... Start of a StringFileInfo block?
        pNewStringInfoBlk = pNewBlk;
        //... Get # of bytes in this StringFileInfo
        //... (Length of value is always 0 here)
        wStringInfoLen = pVerBlk->wLength;

        //... Move to start of first StringTable blk.
        //  -2 is for the starting WCHAR part of the VERBLOCK
        wLen = ROUNDUP(sizeof(VERBLOCK) - 2 + MEMSIZE( STRINGFILEINFOLEN),4);

        // Copy StringFileVersion header
        CopyMemory( pNewBlk, pVerBlk, wLen);
        pNewStringInfoBlk->wLength = 0;     // Set length, will be updated dynamicly

        // Go to the language ID block
        pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
        pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

        // Decrement byte counter
        DECWORDBY(&wDataLen,       wLen);
        DECWORDBY(&wStringInfoLen, wLen);

        // Update the size values
        INCWORDBY(&pNewVerStamp->wLength,      wLen);
        INCWORDBY(&pNewStringInfoBlk->wLength, wLen);

        // We should be now at the language codepage ID string
        if (wStringInfoLen > 0)
        {
            //... Get # of bytes in this StringTable
            wStringTableLen = pVerBlk->wLength;

            pNewStringTblBlk = pNewBlk;

            //... Move to start of first String.
            //  -2 is for the starting WCHAR part of the VERBLOCK
            wLen = ROUNDUP( sizeof(VERBLOCK) - 2 + MEMSIZE( LANGSTRINGLEN),4);
            // Copy language/codepage header
            CopyMemory( pNewBlk, pVerBlk, wLen);
            pNewStringTblBlk->wLength = 0;  // Set length, will be updated dynamicly

            // Go to the first data block
            pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
            pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

            DECWORDBY(&wDataLen,        wLen);
            DECWORDBY(&wStringInfoLen,  wLen);
            DECWORDBY(&wStringTableLen, wLen);

            // Update the size values
            INCWORDBY(&pNewVerStamp->wLength,      wLen);
            INCWORDBY(&pNewStringInfoBlk->wLength, wLen);
            INCWORDBY(&pNewStringTblBlk->wLength,  wLen);

            while ( wStringTableLen > 0 )
            {
                // Copy the old data
                CopyMemory( pNewBlk, pVerBlk, ROUNDUP(pVerBlk->wLength,4));

                wLen = pVerBlk->wLength;
                //... Is value a string?
                if (pVerBlk->wType == VERTYPESTRING)
                {
                    //... See if we need to replace the value for this data
                    wLen = sizeof(szData);
                    if (FindVerValue( pVerBlk->szKey, szData, &wLen)) 
                    {
                        // Update the length values
                        pNewBlk->wValueLength = wLen;
                        // Find the start of the data
                        lp = (LPBYTE) ((PBYTE)pNewBlk + ROUNDUP(pVerBlk->wLength,4) - ROUNDUP(MEMSIZE(pVerBlk->wValueLength),4));

                        // Get the size of the new data
                        wLen = ROUNDUP(MEMSIZE(pNewBlk->wValueLength),4);
                        // Overwrite the old data
                        CopyMemory(lp, szData, wLen);

                        // calculate the size of this data and set it.
                        wLen = MEMSIZE(pNewBlk->wValueLength);
                        pNewBlk->wLength += (wLen - MEMSIZE(pVerBlk->wValueLength));
                    }
                }

                // Update the size values
                wLen = ROUNDUP(pNewBlk->wLength,4);
                INCWORDBY(&pNewVerStamp->wLength, wLen);
                INCWORDBY(&pNewStringInfoBlk->wLength, wLen);
                INCWORDBY(&pNewStringTblBlk->wLength, wLen);

                // Go to the next data block in the old version info
                wLen = ROUNDUP(pVerBlk->wLength,4);
                pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);

                DECWORDBY(&wDataLen,        wLen);
                DECWORDBY(&wStringInfoLen,  wLen);
                DECWORDBY(&wStringTableLen, wLen);

                // Go to where the next data block in the new version info would be.
                pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + ROUNDUP(pNewBlk->wLength,4));

            }               //... END while wStringTableLen

            // Copy the rest of the VERBLOCK, this should be the VarFileInfo part.
            if (wDataLen > 0)
            {
                // Update the most outer length info.
                INCWORDBY(&pNewVerStamp->wLength, wDataLen);
                // Update length info
                CopyMemory(pNewBlk, pVerBlk, wDataLen);
            }
            // Set the values to return to the caller.
            *pwSize = pNewVerStamp->wLength;
            *lplpNewVersionInfo = (LPBYTE)pNewVerStamp;

        }   //... END if wStringInfoLen
    }

    // If some thing went wrong in finding the first language common part of the version info
    // we did not update the version info, therefore we have to free the buffer we allocated
    if (*pwSize == 0)
        free (pNewVerStamp);

    return(TRUE);
}

// Try to find the string in our array of version info we can overwrite
// lpKey:    is a pointer to the value string in the old versin info block (UNICODE)
// lpszData: will contain the data string (UNICODE) if we found the value
// pwLen:    pointer to a word which contains the size of the lpszData buffer on input
// if we found the value it contains the length the version info uses as ValueLength
// which is the size in single byte + zero termination
//
BOOL FindVerValue( WCHAR *lpKey, WCHAR *lpszData, WORD *pwLen)
{
    char szValue[MAX_STRING];
    UINT i = 0;

    // Make it a SB character string
    WideCharToMultiByte(CP_ACP, 0, lpKey, -1, szValue, sizeof(szValue), NULL, NULL);

    // Zero out the buffer, I use so that the caller can over write more memory then the
    // data in the string would take up. This is because the data is WORD aligned.
    memset(lpszData, 0, *pwLen);

    while (i < VerInfoElem) 
    {
        if (lstrcmpi(Verinfo_Array[i].lpszName, szValue) == 0)
        {
            if ((Verinfo_Array[i].szValue[0] != '\0') &&
                (*pwLen >= MEMSIZE(lstrlen(Verinfo_Array[i].szValue) + 1) ) )
            {
                // Convert the ANSI data string into UNICODE
                *pwLen  = (WORD)MultiByteToWideChar(CP_ACP, 0, Verinfo_Array[i].szValue, -1 ,
                                        lpszData, *pwLen);
            }
            i = VerInfoElem;    // Stop searching
        }
        i++;
    }
    // Return if we found the value and the array contained data.
    return (*lpszData != '\0');
}

BOOL CALLBACK MyEnumLangsFunc(HANDLE hModule, LPSTR lpType, LPSTR lpName, WORD languages, LONG lParam)
{
    // The first language we find is OK.
    wVerLang = languages;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\exescan\crc32.c ===
/*
 *  CRC32.C -- CRC32 computation
 */

#include "crc32.h"

long crc32Table[256];

/*
 *  GenerateCRC32Table - Construct CRC-32 constant table
 *
 *  We construct the table on-the-fly because the code needed
 *  to do build it is much smaller than the table it creates.
 */

void GenerateCRC32Table(void)
{
    int iIndex;
    int cBit;
    long shiftIn;
    long shiftOut;

    for (iIndex = 0; iIndex < 256; iIndex++)
    {
        shiftOut = iIndex;
        shiftIn = 0;

        for (cBit = 0; cBit < 8; cBit++)
        {
            shiftIn <<= 1;
            shiftIn |= (shiftOut & 1);
            shiftOut >>= 1;
        }

        shiftIn <<= 24;

        for (cBit = 0; cBit < 8; cBit++)
        {
            if (shiftIn & 0x80000000L)
            {
                shiftIn = (shiftIn << 1) ^ 0x04C11DB7L;
            }
            else
            {
                shiftIn <<= 1;
            }
        }

        for (cBit = 0; cBit < 32; cBit++)
        {
            shiftOut <<= 1;
            shiftOut |= (shiftIn & 1);
            shiftIn >>= 1;
        }

        crc32Table[iIndex] = shiftOut;
    }
}


/*
 *  update CRC32 accumulator from contents of a buffer
 */

void CRC32Update(unsigned long *pCRC32,void *p,unsigned long cb)
{
    unsigned char *pb = p;
    unsigned long crc32;

    crc32 = (-1L - *pCRC32);

    while (cb--)
    {
        crc32 = crc32Table[(unsigned char)crc32 ^ *pb++] ^
                ((crc32 >> 8) & 0x00FFFFFFL);
    }

    *pCRC32 = (-1L - crc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\cabpack\updres.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;



    /*
     * All TYPE and NAME's that are STRING's instead of ORDINAL values
     * are represented by one of these structures which links into the
     * table from the StringHead link of the UPDATEDATA structure
     */
   
typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz



    // Resource Name Information
typedef struct _RESNAME {
        struct _RESNAME *pnext;	    // The first three fields should be the
        PSDATA    Name;		        // same in both res structures
        ULONG     OffsetToData;

        PSDATA	  Type;
	    ULONG	  SectionNumber;
        ULONG	  DataSize;
        ULONG_PTR OffsetToDataEntry;
        USHORT    ResourceNumber;
        USHORT    NumberOfLanguages;
        WORD	  LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

    // Resource Type Information    
typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	    // The first three fields should be the
        PSDATA Type;		        // same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;



    // Main Header for the linked lists of resources??
typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL _stdcall
EnumTypesFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LONG_PTR lParam
    );

BOOL _stdcall
EnumNamesFunc(
    HANDLE hModule,
    LPCSTR lpName,
    LPCSTR lpType,
    LONG_PTR lParam
    );

BOOL _stdcall
EnumLangsFunc(
    HANDLE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD languages,
    LONG_PTR lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN TCHAR	*pDstname
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

LONG
PatchRVAs(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    PIMAGE_NT_HEADERS pNew,
    ULONG OldSize);

LONG
PatchDebug(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32DebugOld,
    PIMAGE_SECTION_HEADER po32DebugNew,
    PIMAGE_SECTION_HEADER po32DebugDirOld,
    PIMAGE_SECTION_HEADER po32DebugDirNew,
    PIMAGE_NT_HEADERS pOld,
    PIMAGE_NT_HEADERS pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData);

HANDLE
LocalBeginUpdateResource(
                            LPCSTR pwch,
                            BOOL bDeleteExistingResources
                        );

BOOL
LocalUpdateResource(
    HANDLE	    hUpdate,
    LPCTSTR     lpType,
    LPCTSTR     lpName,
    WORD	    language,
    LPVOID	    lpData,
    ULONG	    cb
    );

BOOL
LocalEndUpdateResource(
                    HANDLE	hUpdate,
                    BOOL	fDiscard
                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\exescan\crc32.h ===
/*
 *  CRC32.H -- CRC32 computation
 */

#define CRC32_INITIAL_VALUE 0L

/*
 *  GenerateCRC32Table - Construct CRC-32 constant table
 *
 *  We construct the table on-the-fly because the code needed
 *  to do build it is much smaller than the table it creates.
 *
 *  Entry:
 *      none
 *
 *  Exit:
 *      internal table constructed
 */

void GenerateCRC32Table(void);


/*
 *  CRC32Update - Update CRC32 value from a buffer
 *
 *  Entry:
 *      GenerateCRC32Table() has been called
 *      pCRC32  pointer to CRC32 accumulator
 *      p       pointer to buffer to compute CRC on
 *      cb      count of bytes in buffer
 *
 *  Exit:
 *      *pCRC32 updated
 */

void CRC32Update(unsigned long *pCRC32,void *p,unsigned long cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\exescan\exescan.c ===
#include <windows.h>
#include <stdio.h>

#include "chksect.h"


#define     SYMBOL(x)       #x

static char *pszResult[] =
{
    SYMBOL(SELFTEST_NO_ERROR),
    SYMBOL(SELFTEST_NO_MEMORY),
    SYMBOL(SELFTEST_FILE_NOT_FOUND),
    SYMBOL(SELFTEST_READ_ERROR),
    SYMBOL(SELFTEST_WRITE_ERROR),
    SYMBOL(SELFTEST_NOT_PE_FILE),
    SYMBOL(SELFTEST_NO_SECTION),
    SYMBOL(SELFTEST_FAILED),
    SYMBOL(SELFTEST_ALREADY),
    SYMBOL(SELFTEST_SIGNED),
    SYMBOL(SELFTEST_DIRTY)
};


int __cdecl main(int argc,char *argv[])
{
    enum SELFTEST_RESULT result;

    if ((sizeof(pszResult) / sizeof(pszResult[0])) != SELFTEST_MAX_RESULT)
    {
        fprintf(stderr,"pszResult[] is incomplete\n");
        return(1);
    }

    if (argc != 2)
    {
        fprintf(stderr,"\n"
                "Microsoft (R) Self-Extractor Scanning Tool - Version 1.0 (07/03/97 - msliger)\n"
                "Copyright (c) Microsoft Corp 1997. All rights reserved.\n"
                "\n"
                "MICROSOFT INTERNAL USE ONLY\n"
                "\n"
                "Usage:   EXESCAN {package.exe}\n");
        return(1);
    }

    result = CheckSection(argv[1]);

    if (result != SELFTEST_NO_ERROR)
    {
        if (result >= SELFTEST_MAX_RESULT)
        {
            printf("EXESCAN: Result=%d (undefined)\n",result);
        }
        else
        {
            printf("EXESCAN: Result=%s\n",pszResult[result]);
        }
    }

    printf("[errorlevel=%d]\n",result);

    return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\updfile\updfile.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* UPDFILE.H -                                                             *
//*                                                                         *
//***************************************************************************

#ifndef _UPDFILE_H_
#define _UPDFILE_H_

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************


//***************************************************************************
//* MACRO DEFINITIONS                                                       *
//***************************************************************************
#define MsgBox( nMsgID ) \
        MsgBox2Param( nMsgID, NULL, NULL )
#define MsgBox1Param( nMsgID, szParam ) \
        MsgBox2Param( nMsgID, szParam, NULL )

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************

//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************

//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL FileExists( PCSTR );
VOID MsgBox2Param( UINT, PCSTR, PCSTR );
PSTR LoadSz( UINT, PSTR, UINT );

#endif // _UPDFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\updfile\updres.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;



    /*
     * All TYPE and NAME's that are STRING's instead of ORDINAL values
     * are represented by one of these structures which links into the
     * table from the StringHead link of the UPDATEDATA structure
     */
   
typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz



    // Resource Name Information
typedef struct _RESNAME {
        struct _RESNAME *pnext;	    // The first three fields should be the
        PSDATA Name;		        // same in both res structures
        ULONG   OffsetToData;

        PSDATA	Type;
	    ULONG	SectionNumber;
        ULONG	DataSize;
        ULONG_PTR   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD	LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;


    // Resource Type Information    
typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	    // The first three fields should be the
        PSDATA Type;		        // same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;



    // Main Header for the linked lists of resources??
typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPSTR lpType,
    LONG_PTR lParam
    );

BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPSTR lpName,
    LPSTR lpType,
    LONG_PTR lParam
    );

BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPSTR lpType,
    LPSTR lpName,
    WORD languages,
    LONG_PTR lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN TCHAR	*pDstname
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

LONG
PatchRVAs(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    PIMAGE_NT_HEADERS pNew,
    ULONG OldSize);

LONG
PatchDebug(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32DebugOld,
    PIMAGE_SECTION_HEADER po32DebugNew,
    PIMAGE_SECTION_HEADER po32DebugDirOld,
    PIMAGE_SECTION_HEADER po32DebugDirNew,
    PIMAGE_NT_HEADERS pOld,
    PIMAGE_NT_HEADERS pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData);

HANDLE
LocalBeginUpdateResource(
                            LPCSTR pwch,
                            BOOL bDeleteExistingResources
                        );

BOOL
LocalUpdateResource(
    HANDLE	    hUpdate,
    LPCTSTR     lpType,
    LPCTSTR     lpName,
    WORD	    language,
    LPVOID	    lpData,
    ULONG	    cb
    );

BOOL
LocalEndUpdateResource(
                    HANDLE	hUpdate,
                    BOOL	fDiscard
                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\updfile\updres.c ===
/*
 *
 * Resource Updating Functions
 */

#if WINNT  /* for UNICODE_STRING */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <malloc.h>
#include <stdlib.h>
#endif
#include <windows.h>
#pragma hdrstop
#include "..\wextract\cpldebug.h"
#include "updres.h"

#define DPrintf( a )
#define DPrintfn( a )
#define DPrintfu( a )

#define RtlAllocateHeap(a,b,c)    malloc( c )
#define RtlFreeHeap(a,b,c)        free( c )


/*
 * BUGBUG - OPTIMIZATION PROBLEM?
 * BUGBUG - The program mysteriously does not work correctly unless
 * BUGBUG   optimization is turned off in the early section of this file.
 * BUGBUG   I don't have time to debug this, if you do please tell me what
 * BUGBUG   is wrong
 */


#pragma optimize( "", off )



#define cbPadMax    16L
 char     *pchPad = "PADDINGXXPADDING";
 char     *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";




WCHAR *
MakeUnicodeCopy( LPCSTR psz )
{
    LPWSTR result;

    if (((ULONG_PTR) psz) & (ULONG_PTR)0xFFFF0000)  {
        result = (LPWSTR) malloc( (strlen(psz) + 1) * sizeof(WCHAR) );
            // BUGBUG ERROR CHECKING!!! Internal tool only
        mbstowcs( result, psz, strlen(psz) + 1);
        return( result );
    } else {
        return( (WCHAR *) psz );
    }
}




/****************************************************************************
**
** API entry points
**
****************************************************************************/


/*++
    Routine Description
        Begins an update of resources.  Save away the name
        and current resources in a list, using EnumResourceXxx
        api set.

        Parameters:

            lpFileName - Supplies the name of the executable file that the
                resource specified by lpType/lpName/language will be updated
                in.  This file must be able to be opened for writing (ie, not
                currently executing, etc.)  The file may be fully qualified,
                or if not, the current directory is assumed.  It must be a
                valid Windows executable file.

            bDeleteExistingResources - if TRUE, existing resources are
                deleted, and only new resources will appear in the result.
                Otherwise, all resources in the input file will be in the
                output file unless specifically deleted or replaced.

        Return Value:

        NULL - The file specified was not able to be opened for writing.
        Either it was not an executable image, the executable image is
        already loaded, or the filename did not exist.  More information may
        be available via GetLastError api.

        HANDLE - A handle to be passed to the UpdateResource and
        EndUpdateResources function.
--*/


HANDLE
LocalBeginUpdateResource( LPCSTR pwch, BOOL bDeleteExistingResources )
{
    HMODULE     hModule;
    PUPDATEDATA pUpdate;
    HANDLE      hUpdate;
    LPSTR       pFileName;
    DWORD       attr;

    SetLastError(NO_ERROR);



        // Pointer Sanity check
    if (pwch == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

        // Allocate Resource Editing State (contains lists of resources)
    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
    if (hUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (pUpdate == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

        // Set reasonable start condition
    pUpdate->Status = NO_ERROR;

        // Copy Filename into state table
    pUpdate->hFileName = GlobalAlloc(GHND, (strlen(pwch)+1) * sizeof(TCHAR) );
    if (pUpdate->hFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    pFileName = (LPSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    lstrcpy(pFileName, pwch);
    GlobalUnlock(pUpdate->hFileName);


        // Make sure file is writable, not a directory, etc.
    attr = GetFileAttributes(pFileName);
    if (attr == 0xffffffff) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    } else if (attr & (FILE_ATTRIBUTE_READONLY |
                 FILE_ATTRIBUTE_SYSTEM |
                 FILE_ATTRIBUTE_HIDDEN |
                 FILE_ATTRIBUTE_DIRECTORY)) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        SetLastError(ERROR_WRITE_PROTECT);
        return NULL;
    }


            // If not deleting all resources, load them all in
            // by enumerating all the resources
    if (! bDeleteExistingResources)  {
        hModule = LoadLibraryEx(pwch, NULL,LOAD_LIBRARY_AS_DATAFILE| DONT_RESOLVE_DLL_REFERENCES);
        if (hModule == NULL) {
            GlobalUnlock(hUpdate);
            GlobalFree(hUpdate);
            if (GetLastError() == NO_ERROR)
                SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        } else {
                EnumResourceTypes(hModule, (ENUMRESTYPEPROC) EnumTypesFunc, (LONG_PTR) pUpdate);
        }
        FreeLibrary(hModule);
   }

    if (pUpdate->Status != NO_ERROR) {
        GlobalUnlock(hUpdate);
        GlobalFree(hUpdate);
        return NULL;
    }

    GlobalUnlock(hUpdate);

    return hUpdate;
}











/*++
    Routine Description
        This routine adds, deletes or modifies the input resource
        in the list initialized by BeginUpdateResource.  The modify
        case is simple, the add is easy, the delete is hard.
        The ASCII entry point converts inputs to UNICODE.

        Parameters:

            hUpdateFile - The handle returned by the BeginUpdateResources
                function.

            lpType - Points to a null-terminated character string that
                represents the type name of the resource to be updated or
                added.  May be an integer value passed to MAKEINTRESOURCE
                macro.  For predefined resource types, the lpType parameter
                should be one of the following values:

                  RT_ACCELERATOR - Accelerator table
                  RT_BITMAP - Bitmap resource
                  RT_DIALOG - Dialog box
                  RT_FONT - Font resource
                  RT_FONTDIR - Font directory resource
                  RT_MENU - Menu resource
                  RT_RCDATA - User-defined resource (raw data)
                  RT_VERSION - Version resource
                  RT_ICON - Icon resource
                  RT_CURSOR - Cursor resource



            lpName - Points to a null-terminated character string that
                represents the name of the resource to be updated or added.
                May be an integer value passed to MAKEINTRESOURCE macro.

            language - Is the word value that specifies the language of the
                resource to be updated.  A complete list of values is
                available in winnls.h.

            lpData - A pointer to the raw data to be inserted into the
                executable image's resource table and data.  If the data is
                one of the predefined types, it must be valid and properly
                aligned.  If lpData is NULL, the specified resource is to be
                deleted from the executable image.

            cb - count of bytes in the data.

        Return Value:

        TRUE - The resource specified was successfully replaced in, or added
        to, the specified executable image.

        FALSE/NULL - The resource specified was not successfully added to or
        updated in the executable image.  More information may be available
        via GetLastError api.
--*/


BOOL
LocalUpdateResource(
    HANDLE      hUpdate,
    LPCTSTR     lpType,
    LPCTSTR     lpName,
    WORD        language,
    LPVOID      lpData,
    ULONG       cb
    )
{
    PUPDATEDATA pUpdate;
    PSDATA      Type;
    PSDATA      Name;
    PVOID       lpCopy;
    LONG        fRet;

    LPWSTR      lpwType;
    LPWSTR      lpwName;



            // Reset Error
    SetLastError(0);

            // Get pointer to Resource Update Session
    pUpdate = (PUPDATEDATA) GlobalLock(hUpdate);


    lpwType = MakeUnicodeCopy( lpType );
    lpwName = MakeUnicodeCopy( lpName );

    Name = AddStringOrID(lpwName, pUpdate);
    if (Name == NULL) {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    Type = AddStringOrID(lpwType, pUpdate);
    if (Type == NULL) {
        pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
        GlobalUnlock(hUpdate);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (lpwType != (LPWSTR) lpType)
        free( lpwType );
    if (lpwName != (LPWSTR) lpName)
        free( lpwName );

    if (cb == 0) {
        lpCopy = NULL;
    } else {
        // RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
        lpCopy = malloc( cb );
        if (lpCopy == NULL) {
            pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
            GlobalUnlock(hUpdate);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        memcpy( lpCopy, lpData, cb);
    }

    fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    GlobalUnlock(hUpdate);
    if (fRet == NO_ERROR)  {
        return TRUE;
    } else {
        SetLastError(fRet);
        if (lpData != NULL)
            free( lpData );
        return FALSE;
    }
}




/*++
    Routine Description
        Finishes the UpdateResource action.  Copies the
        input file to a temporary, adds the resources left
        in the list (hUpdate) to the exe.

        Parameters:

            hUpdateFile - The handle returned by the BeginUpdateResources
                function.

            fDiscard - If TRUE, discards all the updates, frees all memory.

        Return Value:

        FALSE - The file specified was not able to be written.  More
        information may be available via GetLastError api.

        TRUE -  The accumulated resources specified by UpdateResource calls
        were written to the executable file specified by the hUpdateFile
        handle.
--*/




BOOL
LocalEndUpdateResource(
                    HANDLE  hUpdate,
                    BOOL    fDiscard
                 )
{
    LPTSTR      pFileName;
    PUPDATEDATA pUpdate;
    TCHAR       pTempFileName[MAX_PATH];
    INT         cch;
    LPTSTR      p;
    LONG        rc;

    SetLastError(0);

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);


    if (fDiscard) {
        rc = NO_ERROR;
    } else {
        pFileName = (LPTSTR)GlobalLock(pUpdate->hFileName);
        strcpy(pTempFileName, pFileName);
        cch = strlen(pTempFileName);
        p = pTempFileName + cch;
        while (*p != '\\' && p >= pTempFileName)
            p--;
        *(p+1) = 0;
        rc = GetTempFileName(pTempFileName, "RCX", 0, pTempFileName);
        if (rc == 0) {
            rc = GetTempPath(MAX_PATH, pTempFileName);
            if (rc == 0) {
                pTempFileName[0] = '.';
                pTempFileName[1] = '\\';
                pTempFileName[2] = 0;
            }
            rc = GetTempFileName(pTempFileName, "RCX", 0, pTempFileName);
            if (rc == 0) {
                rc = GetLastError();
            } else {
                rc =  WriteResFile(hUpdate, pTempFileName);
                if (rc == NO_ERROR) {
                    DeleteFile(pFileName);
                    MoveFile(pTempFileName, pFileName);
                } else {
                    SetLastError(rc);
                    DeleteFile(pTempFileName);
                }
            }
        } else {
            rc = WriteResFile(hUpdate, pTempFileName);
            if (rc == NO_ERROR) {
                DeleteFile(pFileName);
                MoveFile(pTempFileName, pFileName);
            } else {
                SetLastError(rc);
                DeleteFile(pTempFileName);
            }
        }
        GlobalUnlock(pUpdate->hFileName);
        GlobalFree(pUpdate->hFileName);
    }

    FreeData(pUpdate);
    GlobalUnlock(hUpdate);
    GlobalFree(hUpdate);
    return rc?FALSE:TRUE;
}



/**********************************************************************
**
**  End of API entry points.
**
**  Beginning of private entry points for worker routines to do the
**  real work.
**
***********************************************************************/


BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPSTR lpType,
    LONG_PTR lParam
    )
{

    EnumResourceNames(hModule, lpType, (ENUMRESNAMEPROC)EnumNamesFunc, lParam);

    return TRUE;
}



BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPSTR lpType,
    LPSTR lpName,
    LONG_PTR lParam
    )
{

    EnumResourceLanguages(hModule, lpType, lpName, (ENUMRESLANGPROC)EnumLangsFunc, lParam);
    return TRUE;
}



BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPSTR lpType,
    LPSTR lpName,
    WORD language,
    LONG_PTR lParam
    )
{
    HANDLE  hResInfo;
    LONG    fError;
    PSDATA  Type;
    PSDATA  Name;
    ULONG   cb;
    PVOID   lpData;
    HANDLE  hResource;
    PVOID   lpResource;

    LPWSTR  lpwType;
    LPWSTR  lpwName;


    hResInfo = FindResourceEx(hModule, lpType, lpName, language);
    if (hResInfo == NULL) {
        return FALSE;
    }





    lpwType = MakeUnicodeCopy( lpType );

    if(lpwType == NULL) {
        return FALSE;
    }

    lpwName = MakeUnicodeCopy( lpName );

    if(lpwName == NULL) {
        if (lpType != (LPSTR) lpwType)free(lpwType);
        return FALSE;
    }

    Type = AddStringOrID(lpwType, (PUPDATEDATA)lParam);
    if (Type == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }
    Name = AddStringOrID(lpwName, (PUPDATEDATA)lParam);
    if (Name == NULL) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    if (lpType != (LPSTR) lpwType)
        free( lpwType );
    if (lpName != (LPSTR) lpwName)
        free( lpwName );

    cb = SizeofResource(hModule, hResInfo);
    if (cb == 0) {
        return FALSE;
    }
    lpData = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cb);
    if (lpData == NULL) {
        return FALSE;
    }
    RtlZeroMemory(lpData, cb);

    hResource = LoadResource(hModule, hResInfo);
    if (hResource == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpData);
        return FALSE;
    }

    lpResource = (PVOID)LockResource(hResource);
    if (lpResource == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, lpData);
        return FALSE;
    }

    RtlCopyMemory(lpData, lpResource, cb);

    (VOID)UnlockResource(hResource);

    (VOID)FreeResource(hResource);

    fError = AddResource(Type, Name, language, (PUPDATEDATA)lParam, lpData, cb);
    if (fError != NO_ERROR) {
        ((PUPDATEDATA)lParam)->Status = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    return TRUE;
}





/*
 * BUGBUG  END OF OPTIMIZATION PROBLEM
 */

#pragma optimize( "", on )








VOID
FreeOne(
    PRESNAME pRes
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes);
}


VOID
FreeData(
    PUPDATEDATA pUpd
    )
{
    PRESTYPE    pType;
    PRESNAME    pRes;
    PSDATA      pstring, pStringTmp;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID) {
        pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) {
        pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

        for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
            pType->NameHeadID = pType->NameHeadID->pnext;
            FreeOne(pRes);
        }

        for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
            pType->NameHeadName = pType->NameHeadName->pnext;
            FreeOne(pRes);
        }

    }

    pstring = pUpd->StringHead;
    while (pstring != NULL) {
        pStringTmp = pstring->uu.ss.pnext;
    if (pstring->discriminant == IS_STRING)
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring->szStr);
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
        pstring = pStringTmp;
    }

    return;
}


/*+++

    Routines to register strings

---*/

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    )
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if (((ULONG_PTR)lp & (ULONG_PTR)0xFFFF0000) == 0) {
        //
        // an ID
        //
        pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(SDATA));
    if (pstring == NULL)
        return NULL;
    RtlZeroMemory((PVOID)pstring, sizeof(SDATA));
    pstring->discriminant = IS_ID;

        pstring->uu.Ordinal = (WORD)((ULONG_PTR)lp & (ULONG_PTR)0x0000ffff);
    }
    else {
        //
        // a string
        //
        cb = wcslen(lp) + 1;
        ppstring = &pupd->StringHead;

        while ((pstring = *ppstring) != NULL) {
            if (!wcsncmp(pstring->szStr, lp, cb))
        break;
            ppstring = &(pstring->uu.ss.pnext);
        }

        if (!pstring) {

            //
            // allocate a new one
            //

            pstring = (PSDATA)RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG( RES_TAG ) | HEAP_ZERO_MEMORY,
                                              sizeof(SDATA)
                                             );
        if (pstring == NULL)
            return NULL;
        RtlZeroMemory((PVOID)pstring, sizeof(SDATA));

            pstring->szStr = (WCHAR*)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
                            cb*sizeof(WCHAR));
            if (pstring->szStr == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pstring);
                return NULL;
        }
        pstring->discriminant = IS_STRING;
            pstring->OffsetToString = pupd->cbStringTable;

            pstring->cbData = sizeof(pstring->cbsz) + cb * sizeof(WCHAR);
            pstring->cbsz = cb - 1; /* don't include zero terminator */
            RtlCopyMemory(pstring->szStr, lp, cb*sizeof(WCHAR));

            pupd->cbStringTable += pstring->cbData;

            pstring->uu.ss.pnext=NULL;
            *ppstring=pstring;
        }
    }

    return(pstring);
}
//
// add a resource into the resource directory hiearchy
//


LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG cb
    )
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;

    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //

    while ((pType=*ppType) != NULL) {
        if (pType->Type->uu.Ordinal == Type->uu.Ordinal) {
            ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
            break;
        }
        if (fTypeID) {
            if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
        break;
        }
    else {
            if (wcsncmp(Type->szStr, pType->Type->szStr, Type->cbsz) < 0)
        break;
        }
        ppType = &(pType->pnext);
    }

    //
    // Create a new type if needed
    //

    if (ppName == NULL) {
        pType = (PRESTYPE)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESTYPE));
    if (pType == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pType, sizeof(RESTYPE));
        pType->pnext = *ppType;
        *ppType = pType;
        pType->Type = Type;
        ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //

    while ( (pName = *ppName) != NULL) {
        if (fNameID) {
        if (Name->uu.Ordinal == pName->Name->uu.Ordinal) {
        fSame = TRUE;
        break;
        }
            if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
        break;
        }
    else {
            if (wcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) == 0) {
        fSame = TRUE;
        break;
        }
            if (wcsncmp(Name->szStr, pName->Name->szStr, Name->cbsz) < 0)
        break;
        }
        ppName = &(pName->pnext);
    }

    //
    // check for delete/modify
    //

    if (fSame) {                /* same name, new language */
        if (pName->NumberOfLanguages == 1) {    /* one language currently ? */
            if (Language == pName->LanguageId) {    /* REPLACE || DELETE */
                pName->DataSize = cb;
                if (lpData == NULL) {           /* DELETE */
                    return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
                }
        RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                pName->OffsetToDataEntry = (ULONG_PTR)lpData;
                return NO_ERROR;
            }
        else {
                if (lpData == NULL) {           /* no data but new? */
                return ERROR_INVALID_PARAMETER; /* badness */
        }
        return InsertResourceIntoLangList(pupd, Type, Name, pType, pName, Language, fNameID, cb, lpData);
        }
        }
        else {                  /* many languages currently */
        pNameM = pName;         /* save head of lang list */
        while ( (pName = *ppName) != NULL) {/* find insertion point */
            if (pName->Name != pNameM->Name ||
            Language <= pName->LanguageId)  /* here? */
                break;              /* yes */
            ppName = &(pName->pnext);   /* traverse language list */
        }

        if (pName && Language == pName->LanguageId) { /* language found? */
        if (lpData == NULL) {           /* DELETE */
            return DeleteResourceFromList(pupd, pType, pName, Language, fTypeID, fNameID);
        }

                pName->DataSize = cb;           /* REPLACE */
        RtlFreeHeap(RtlProcessHeap(),0,(PVOID)pName->OffsetToDataEntry);
                pName->OffsetToDataEntry = (ULONG_PTR)lpData;
                return NO_ERROR;
        }
        else {                  /* add new language */
        return InsertResourceIntoLangList(pupd, Type, Name, pType, pNameM, Language, fNameID, cb, lpData);
        }
    }
    }
    else {                  /* unique name */
    if (lpData == NULL) {           /* can't delete new name */
        return ERROR_INVALID_PARAMETER;
    }
    }

    //
    // add new name/language
    //

    if (!fSame) {
        if (fNameID)
            pType->NumberOfNamesID++;
        else
            pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    RtlZeroMemory((PVOID)pName, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    pName->OffsetToDataEntry = (ULONG_PTR)lpData;

    return NO_ERROR;
}


BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT Language,
    INT fType,
    INT fName
    )
{
    PPRESTYPE   ppType;
    PPRESNAME   ppName;
    PRESNAME    pNameT;

    /* find previous type node */
    ppType = fType ? &pUpd->ResTypeHeadID : &pUpd->ResTypeHeadName;
    while (*ppType != pType) {
        ppType = &((*ppType)->pnext);
    }

    /* find previous type node */
    ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    pNameT = NULL;
    while (*ppName != pName) {
    if (pNameT == NULL) {       /* find first Name in lang list */
        if (fName) {
        if ((*ppName)->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
            pNameT = *ppName;
        }
        }
        else {
        if (wcsncmp((*ppName)->Name->szStr, pName->Name->szStr, (*ppName)->Name->cbsz) == 0) {
            pNameT = *ppName;
        }
        }
    }
        ppName = &((*ppName)->pnext);
    }

    if (pNameT == NULL) {   /* first of this name? */
    pNameT = pName->pnext;  /* then (possibly) make next head of lang */
    if (pNameT != NULL) {
        if (fName) {
        if (pNameT->Name->uu.Ordinal == pName->Name->uu.Ordinal) {
            pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
        }
        }
        else {
        if (wcsncmp(pNameT->Name->szStr, pName->Name->szStr, pNameT->Name->cbsz) == 0) {
            pNameT->NumberOfLanguages = pName->NumberOfLanguages - 1;
        }
        }
    }
    }
    else
    pNameT->NumberOfLanguages--;

    if (pNameT) {
    if (pNameT->NumberOfLanguages == 0) {
        if (fName)
        pType->NumberOfNamesID -= 1;
        else
        pType->NumberOfNamesName -= 1;
    }
    }

    *ppName = pName->pnext;     /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pName->OffsetToDataEntry);
    RtlFreeHeap(RtlProcessHeap(), 0, pName);    /* and free */

    if (*ppName == NULL) {      /* type list completely empty? */
    *ppType = pType->pnext;         /* link to next */
    RtlFreeHeap(RtlProcessHeap(), 0, pType);    /* and free */
    }

    return NO_ERROR;
}

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT Language,
    INT fName,
    INT cb,
    PVOID lpData
    )
{
    PRESNAME    pNameM;
    PRESNAME    pNameNew;
    PPRESNAME   ppName;

    pNameNew = (PRESNAME)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), sizeof(RESNAME));
    if (pNameNew == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;
    RtlZeroMemory((PVOID)pNameNew, sizeof(RESNAME));
    pNameNew->Name = Name;
    pNameNew->Type = Type;
    pNameNew->LanguageId = (WORD)Language;
    pNameNew->DataSize = cb;
    pNameNew->OffsetToDataEntry = (ULONG_PTR)lpData;

    if (Language < pName->LanguageId) {     /* have to add to the front */
    pNameNew->NumberOfLanguages = pName->NumberOfLanguages + 1;
    pName->NumberOfLanguages = 1;

        ppName = fName ? &pType->NameHeadID : &pType->NameHeadName;
    /* don't have to look for NULL at end of list !!! */
    while (pName != *ppName) {      /* find insertion point */
        ppName = &((*ppName)->pnext);   /* traverse language list */
    }
    pNameNew->pnext = *ppName;      /* insert */
    *ppName = pNameNew;
    }
    else {
    pNameM = pName;
    pName->NumberOfLanguages += 1;
    while (pName != NULL) {         /* find insertion point */
        if (Language <= pName->LanguageId)  /* here? */
        break;              /* yes */
        pNameM = pName;
        pName = pName->pnext;       /* traverse language list */
    }
    pName = pNameM->pnext;
    pNameM->pnext = pNameNew;
    pNameNew->pnext = pName;
    }
    return NO_ERROR;
}


/*
 * Utility routines
 */


ULONG
FilePos(int fh)
{

    return _llseek(fh, 0L, SEEK_CUR);
}



ULONG
MuMoveFilePos( INT fh, ULONG pos )
{
    return _llseek( fh, pos, SEEK_SET );
}



ULONG
MuWrite( INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;

    if ((n1 = _lwrite(fh, p, n)) != n) {
    return n1;
    }
    else
        return 0;
}



ULONG
MuRead(INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;

    if ((n1 = _lread( fh, p, n )) != n) {
        return n1;
    }
    else
        return 0;
}



BOOL
MuCopy( INT srcfh, INT dstfh, ULONG nbytes )
{
    ULONG   n;
    ULONG   cb=0L;
    PUCHAR  pb;

    pb = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), BUFSIZE);
    if (pb == NULL)
        return 0;
    RtlZeroMemory((PVOID)pb, BUFSIZE);

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        if (!MuRead( srcfh, pb, n )) {
        cb += n;
            MuWrite( dstfh, pb, n );
    }
        else {
        RtlFreeHeap(RtlProcessHeap(), 0, pb);
        return cb;
    }
    }
    RtlFreeHeap(RtlProcessHeap(), 0, pb);
    return cb;
}



VOID
SetResdata(
    PIMAGE_RESOURCE_DATA_ENTRY  pResData,
    ULONG           offset,
    ULONG           size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


VOID
SetRestab(
    PIMAGE_RESOURCE_DIRECTORY   pRestab,
    LONG            time,
    WORD            cNamed,
    WORD            cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER
FindSection(
    PIMAGE_SECTION_HEADER   pObjBottom,
    PIMAGE_SECTION_HEADER   pObjTop,
    LPSTR pName
    )
{

    while (pObjBottom < pObjTop) {
    if (strcmp(pObjBottom->Name, pName) == 0)
        return pObjBottom;
    pObjBottom++;
    }

    return NULL;
}


ULONG
AssignResourceToSection(
    PRESNAME    *ppRes,     /* resource to assign */
    ULONG   ExtraSectionOffset, /* offset between .rsrc and .rsrc1 */
    ULONG   Offset,     /* next available offset in section */
    LONG    Size,       /* Maximum size of .rsrc */
    PLONG   pSizeRsrc1
    )
{
    ULONG   cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size) {
    *pSizeRsrc1 = Offset;
    Offset = ExtraSectionOffset;
    DPrintf((DebugBuf, "<<< Secondary resource section @%#08lx >>>\n", Offset));
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    DPrintf((DebugBuf, "    --> %#08lx bytes at %#08lx\n", cb, Offset));
    return Offset + cb;
}



/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr  Modified for new (NT) Linear Exe format
* 1/18/92   vich    Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*             a second .rsrc section.
\****************************************************************************/

/*  */
LONG
PEWriteResFile(
    INT     inpfh,
    INT     outfh,
    ULONG   cbOldexe,
    PUPDATEDATA pUpdate
    )
{
    IMAGE_NT_HEADERS Old;   /* original header              */
    IMAGE_NT_HEADERS New;   /* working header       */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG   clock = GetTickCount(); /* current time */
    ULONG   cbName=0;   /* count of bytes in name strings */
    ULONG   cbType=0;   /* count of bytes in type strings */
    ULONG   cTypeStr=0; /* count of strings */
    ULONG   cNameStr=0; /* count of strings */
    LONG    cb;     /* temp byte count and file index */
    ULONG   cTypes = 0L;    /* count of resource types      */
    ULONG   cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG   cRes = 0L;  /* count of resources      */
    ULONG   cbRestab;   /* count of resources      */
    LONG    cbNew = 0L; /* general count */
    ULONG   ibObjTab;
    ULONG   ibObjTabEnd;
    ULONG   ibSave;
    ULONG   adjust=0;
    PIMAGE_SECTION_HEADER   pObjtblOld,
        pObjtblNew = NULL,
        pObjDebug,
        pObjResourceOld,
        pObjResourceNew,
        pObjResourceOldX,
        pObjDebugDirOld,
        pObjDebugDirNew,
        pObjNew,
        pObjOld,
        pObjLast;
    PUCHAR  p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT pResStr;
    PUSHORT pResStrEnd;
    PSDATA  pPreviousName;
    LONG    nObjResource=-1;
    LONG    nObjResourceX=-1;
    ULONG   cbResource;
    ULONG   cbMustPad = 0;
    ULONG       ibMaxDbgOffsetOld;

    MuMoveFilePos(inpfh, cbOldexe);
    MuRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS));
    ibObjTab = cbOldexe + sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
                              Old.FileHeader.SizeOfOptionalHeader;
    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);

    if (*(PUSHORT)&Old.Signature != IMAGE_NT_SIGNATURE)
    return ERROR_INVALID_EXE_SIGNATURE;

    if ((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
    (Old.FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
    return ERROR_EXE_MARKED_INVALID;
    }
    DPrintfn((DebugBuf, "\n"));

    /* New header is like old one.                  */
    RtlCopyMemory(&New, &Old, sizeof(IMAGE_NT_HEADERS));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ),
    Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblOld, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    DPrintf((DebugBuf, "Old section table: %#08lx bytes at %#08lx(mem)\n",
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
        pObjtblOld));
    MuMoveFilePos(inpfh, ibObjTab);
    MuRead(inpfh, (PUCHAR)pObjtblOld,
        Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
        if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld) {
            ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
        }
    }
    DPrintf((DebugBuf, "Maximum debug offset in old file: %08x\n", ibMaxDbgOffsetOld ));

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */
    DPrintf((DebugBuf, "Beginning loop to count resources\n"));

    /* first, count those in the named type list */
    cbResource = 0;
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        //DPrintf((DebugBuf, "Resource type "));
        //DPrintfu((pType->Type->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cTypes++;
        cTypeStr++;
        cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadName;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource "));
        //DPrintfu((pRes->Name->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cRes++;
                if (pPreviousName == NULL ||
                    wcsncmp(pPreviousName->szStr,
                            pRes->Name->szStr,
                            pRes->Name->cbsz) != 0) {
            cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
            cNameStr++;
                    cNames++;
        }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadID;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }
        }
        pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    //DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        //DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
        cTypes++;
            //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadName;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource "));
        //DPrintfu((pRes->Name->szStr));
        //DPrintfn((DebugBuf, "\n"));
        cRes++;
                if (pPreviousName == NULL ||
                    wcsncmp(pPreviousName->szStr,
                            pRes->Name->szStr,
                            pRes->Name->cbsz) != 0) {
                    cNames++;
            cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
            cNameStr++;
        }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }

            //DPrintf((DebugBuf, "Walk name: ID list\n"));
            pPreviousName = NULL;
        pRes = pType->NameHeadID;
        while (pRes) {
        //DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cRes++;
                if (pPreviousName == NULL ||
                    pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                    cNames++;
                }
        cbResource += ROUNDUP(pRes->DataSize, CBLONG);
                pPreviousName = pRes->Name;
        pRes = pRes->pnext;
        }
    }
        pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) + /* root dir (types) */
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir2 (names) */
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir3 (langs) */
    cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    (cbName + cbType) +             /* name/type strings */
    cb +                        /* padding */
    cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY); /* data entries */

    cbResource += cbRestab;     /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    if (pObjResourceOld == NULL) {
        cb = 0x7fffffff;        /* can fill forever */
    }
    else if (pObjResourceOld + 1 == pObjResourceOldX) {
        nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
        DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
        DPrintf((DebugBuf,"Merging old Resource extra section #%lu\n", nObjResource+2));
        cb = 0x7fffffff;        /* merge resource sections */
    }
    else {
        nObjResource = (LONG)(pObjResourceOld - pObjtblOld);
        DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
        cb = (pObjResourceOld+1)->VirtualAddress -
                pObjResourceOld->VirtualAddress;
        if (cbRestab > (ULONG)cb) {
            DPrintf((DebugBuf, "Resource Table Too Large\n"));
            return ERROR_INVALID_DATA;
        }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb) {
    if (pObjResourceOld != NULL && pObjOld == pObjResourceOld + 1) {
        DPrintf((DebugBuf, "Large resource section  pushes .reloc\n"));
        cb = 0x7fffffff;        /* can fill forever */
    }
    else if (pObjResourceOldX == NULL) {
        DPrintf((DebugBuf, "Too much resource data for old .rsrc section\n"));
        nObjResourceX = (LONG)(pObjOld - pObjtblOld);
        adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
    }
    else {      /* have already merged .rsrc & .rsrc1, if possible */
        DPrintf((DebugBuf, ".rsrc1 section not empty\n"));
        nObjResourceX = (LONG)(pObjResourceOldX - pObjtblOld);
        adjust = pObjResourceOldX->VirtualAddress -
             pObjResourceOld ->VirtualAddress;
    }
    }

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */
    DPrintf((DebugBuf, "Beginning loop to assign resources to addresses\n"));

    /* first, those in the named type list */

    cbResource = cbRestab;  /* assign resource table to 1st rsrc section */
                /* adjust == offset to .rsrc1 */
                /* cb == size availble in .rsrc */
    cbNew = 0;          /* count of bytes in second .rsrc */
    DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        DPrintf((DebugBuf, "Resource type "));
        DPrintfu((pType->Type->szStr));
        DPrintfn((DebugBuf, "\n"));
        pRes = pType->NameHeadName;
        while (pRes) {
        DPrintf((DebugBuf, "Resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
        pRes = pType->NameHeadID;
        while (pRes) {
        DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
    }
        pType = pType->pnext;
    }

    /* then, count those in the ID type list */

    DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
        DPrintf((DebugBuf, "Resource type %hu\n", pType->Type->uu.Ordinal));
        pRes = pType->NameHeadName;
        while (pRes) {
        DPrintf((DebugBuf, "Resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
        pRes = pType->NameHeadID;
        while (pRes) {
        DPrintf((DebugBuf, "Resource %hu\n", pRes->Name->uu.Ordinal));
        cbResource = AssignResourceToSection(&pRes,
            adjust, cbResource, cb, &cbNew);
        }
    }
        pType = pType->pnext;
    }
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
    if (cbNew == 0)
    cbNew = cbResource;

    /*
     * Discover where the Debug info is (if any)?
     */
    pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
    if (pObjDebug != NULL) {
    if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0) {
        DPrintf((DebugBuf, ".debug section but no debug directory\n"));
        return ERROR_INVALID_DATA;
    }
    if (pObjDebug != pObjLast-1) {
        DPrintf((DebugBuf, "debug section not last section in file\n"));
        return ERROR_INVALID_DATA;
    }
    DPrintf((DebugBuf, "Debug section: %#08lx bytes @%#08lx\n",
         pObjDebug->SizeOfRawData,
         pObjDebug->PointerToRawData));
    }
    pObjDebugDirOld = NULL;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
    if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= pObjOld->VirtualAddress &&
        Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < pObjOld->VirtualAddress+pObjOld->SizeOfRawData) {
        pObjDebugDirOld = pObjOld;
        break;
    }
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (nObjResource == -1) {       /* no old resource section */
    if (pObjOld != NULL)
        nObjResource = (LONG)(pObjOld - pObjtblOld);
    else if (pObjDebug != NULL)
        nObjResource = (LONG)(pObjDebug - pObjtblOld);
    else
        nObjResource = New.FileHeader.NumberOfSections;
    New.FileHeader.NumberOfSections++;
    }

    DPrintf((DebugBuf, "Resources assigned to section #%lu\n", nObjResource+1));
    if (nObjResourceX != -1) {
    if (pObjResourceOldX != NULL) {
        nObjResourceX = (LONG)(pObjResourceOldX - pObjtblOld);
        New.FileHeader.NumberOfSections--;
    }
    else if (pObjOld != NULL)
        nObjResourceX = (LONG)(pObjOld - pObjtblOld);
    else if (pObjDebug != NULL)
        nObjResourceX = (LONG)(pObjDebug - pObjtblOld);
    else
        nObjResourceX = New.FileHeader.NumberOfSections;
    New.FileHeader.NumberOfSections++;
    DPrintf((DebugBuf, "Extra resources assigned to section #%lu\n",
        nObjResourceX+1));
    }
    else if (pObjResourceOldX != NULL) {    /* Was old .rsrc1 section? */
    DPrintf((DebugBuf, "Extra resource section deleted\n"));
    New.FileHeader.NumberOfSections--;  /* yes, delete it */
    }

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
    adjust = (New.FileHeader.NumberOfSections -
          Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
    cb = Old.OptionalHeader.SizeOfHeaders -
    (Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
     sizeof(IMAGE_NT_HEADERS) + cbOldexe );
    if (adjust > (ULONG)cb) {
    int i;

    adjust -= cb;
    DPrintf((DebugBuf, "Adjusting header RVAs by %#08lx\n", adjust));
    for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
        if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
        New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders) {
        DPrintf((DebugBuf, "Adjusting unit[%s] RVA from %#08lx to %#08lx\n",
             apszUnit[i],
             New.OptionalHeader.DataDirectory[i].VirtualAddress,
             New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
        New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
        }
    }
    New.OptionalHeader.SizeOfHeaders += adjust;
    }

    /* Allocate storage for new section table                */
    cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    pObjtblNew = (PIMAGE_SECTION_HEADER)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), (short)cb);
    if (pObjtblNew == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }
    RtlZeroMemory((PVOID)pObjtblNew, cb);
    DPrintf((DebugBuf, "New section table: %#08lx bytes at %#08lx\n", cb, pObjtblNew));
    pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
    adjust = 0;         /* adjustment to virtual address */
    for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++) {
    if (pObjOld == pObjResourceOldX) {
        if (nObjResourceX == -1) {
        // we have to move back all the other section.
        // the .rsrc1 is bigger than what we need
        // adjust must be a negative number
        adjust -= (pObjOld+1)->VirtualAddress - pObjOld->VirtualAddress;
        }
        continue;
    }
    else if (pObjNew == pObjResourceNew) {
        DPrintf((DebugBuf, "Resource Section %i\n", nObjResource+1));
        cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
        if (pObjResourceOld == NULL) {
        adjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
        RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
        strcpy(pObjNew->Name, ".rsrc");
        pObjNew->VirtualAddress = pObjOld->VirtualAddress;
        pObjNew->PointerToRawData = pObjOld->PointerToRawData;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        pObjNew->SizeOfRawData = cb;
        pObjNew->Misc.VirtualSize = ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
        }
        else {
        *pObjNew = *pObjOld;    /* copy obj table entry */
        pObjNew->SizeOfRawData = cb;
        pObjNew->Misc.VirtualSize = ROUNDUP(cb, New.OptionalHeader.SectionAlignment);
        if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData) {
            adjust = 0;
        }
        else if (pObjNew->SizeOfRawData > pObjOld->SizeOfRawData) {
            adjust +=
            ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment) -
            ((pObjOld+1)->VirtualAddress-pObjOld->VirtualAddress);

        }
        else {      /* is smaller, but pad so will be valid */
            adjust = 0;
            pObjNew->SizeOfRawData = pObjResourceOld->SizeOfRawData;
            pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);
            /* don't need to set VirtualSize - will be the same */
            cbMustPad = pObjResourceOld->SizeOfRawData;
        }
        }
        pObjNew++;
        if (pObjResourceOld == NULL)
        goto rest_of_table;
    }
    else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {
        DPrintf((DebugBuf, "Additional Resource Section %i\n",
        nObjResourceX+1));
        RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
        strcpy(pObjNew->Name, ".rsrc1");
        /*
         * Before we copy the virtual address we have to move back the
         * .reloc * virtual address. Otherwise we will keep moving the
         * reloc VirtualAddress forward.
         * We will have to move back the address of .rsrc1
         */
        if (pObjResourceOldX == NULL) {
        // This is the first time we have a .rsrc1
        pObjNew->VirtualAddress = pObjOld->VirtualAddress;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress - pObjNew->VirtualAddress;
        DPrintf((DebugBuf, "Added .rsrc1. VirtualAddress %lu\t adjust: %lu\n", pObjNew->VirtualAddress, adjust ));
        }
        else {
        // we already have an .rsrc1 use the position of that and
        // calculate the new adjust
        pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
        pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
            IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
        
        DPrintf((DebugBuf, ".rsrc1 Keep old position.\t\tVirtualAddress %lu\t", pObjNew->VirtualAddress ));
        // Check if we have enough room in the old .rsrc1
        // Include the full size of the section, data + roundup
        if (cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
            pObjOld->VirtualAddress - pObjNew->VirtualAddress ) {
            // we have to move back all the other section.
            // the .rsrc1 is bigger than what we need
            // adjust must be a negative number
            // calc new adjust size
            adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress -
            pObjOld->VirtualAddress;
            DPrintf((DebugBuf, "adjust: %ld\tsmall: New %lu\tOld %lu\n", adjust,
            cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
            pObjOld->VirtualAddress - pObjNew->VirtualAddress));
        }
        else {
            // we have to move the section again.
            // The .rsrc1 is too small
        
            adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
            pObjResourceNew->VirtualAddress -
            pObjOld->VirtualAddress;
            DPrintf((DebugBuf, "adjust: %lu\tsmall: New %lu\tOld %lu\n", adjust,
            cbResource -
            (pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
            pObjOld->VirtualAddress - pObjNew->VirtualAddress));
        }
        }
        pObjNew++;
        goto rest_of_table;
    }
    else if (pObjNew < pObjResourceNew) {
        DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
             pObjOld - pObjtblOld + 1, pObjNew));
        *pObjNew++ = *pObjOld;      /* copy obj table entry */
    }
    else {
rest_of_table:
        DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
             pObjOld - pObjtblOld + 1, pObjNew));
        DPrintf((DebugBuf, "adjusting VirtualAddress by %#08lx\n", adjust));
        *pObjNew++ = *pObjOld;
        (pObjNew-1)->VirtualAddress += adjust;
    }
    }


    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
                    pObjNew->SizeOfRawData,
                                    New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
    pResTab = (PIMAGE_RESOURCE_DIRECTORY)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( RES_TAG ), cbRestab);
    if (pResTab == NULL) {
    cb = ERROR_NOT_ENOUGH_MEMORY;
    goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                          */

    RtlZeroMemory((PVOID)pResTab, cbRestab);
    DPrintf((DebugBuf, "resource directory tables: %#08lx bytes at %#08lx(mem)\n", cbRestab, pResTab));
    p = (PUCHAR)pResTab;
    pResTab->Characteristics = 0L;
    pResTab->TimeDateStamp = clock;
    pResTab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pResTab->MinorVersion = MINOR_RESOURCE_VERSION;
    pResTab->NumberOfNamedEntries = (USHORT)cTypeStr;
    pResTab->NumberOfIdEntries = (USHORT)(cTypes - cTypeStr);

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
        cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
        cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
        cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResStr  = (PUSHORT)(((PUCHAR)pResData) +
        cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */
    DPrintf((DebugBuf, "building resource directory\n"));

    // First, add all the entries in the Types: Alpha list.

    DPrintf((DebugBuf, "Walk the type: Alpha list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    DPrintf((DebugBuf, "resource type "));
    DPrintfu((pType->Type->szStr));
    DPrintfn((DebugBuf, "\n"));

    pResDirT->Name = (ULONG)((((PUCHAR)pResStr) - p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
    pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    pResDirT++;

    *pResStr = pType->Type->cbsz;
    wcsncpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz);
    pResStr += pType->Type->cbsz + 1;

    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    SetRestab(pResTabN, clock,
        (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

    pRes = pType->NameHeadName;
    while (pRes) {
        DPrintf((DebugBuf, "resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL ||
                wcsncmp(pPreviousName->szStr,
                           pRes->Name->szStr,
                           pRes->Name->cbsz) != 0) {
                // Setup a new name directory

            pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

            // Copy the alpha name to a string entry

            *pResStr = pRes->Name->cbsz;
            wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
            pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

        pPreviousName = NULL;

    pRes = pType->NameHeadID;
    while (pRes) {
        DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL ||
                pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

            pResDirN->Name = pRes->Name->uu.Ordinal;
            pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

    pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.

    DPrintf((DebugBuf, "Walk the type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));

    pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
    pResDirT->OffsetToData = (ULONG)((((PUCHAR)pResDirN) - p) |
            IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    pResDirT++;

    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    SetRestab(pResTabN, clock,
        (USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

        pPreviousName = NULL;

    pRes = pType->NameHeadName;
    while (pRes) {
        DPrintf((DebugBuf, "resource "));
        DPrintfu((pRes->Name->szStr));
        DPrintfn((DebugBuf, "\n"));

            if (pPreviousName == NULL ||
                wcsncmp(pPreviousName->szStr,
                           pRes->Name->szStr,
                           pRes->Name->cbsz) != 0) {
                // Setup a new name directory

            pResDirN->Name = (ULONG)((((PUCHAR)pResStr)-p) |
            IMAGE_RESOURCE_NAME_IS_STRING);
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                        IMAGE_RESOURCE_DATA_IS_DIRECTORY);
                pResDirN++;

                // Copy the alpha name to a string entry.

            *pResStr = pRes->Name->cbsz;
            wcsncpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz);
            pResStr += pRes->Name->cbsz + 1;

                pPreviousName = pRes->Name;

                // Setup the Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new Language directory

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry

        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

        pPreviousName = NULL;

    pRes = pType->NameHeadID;
    while (pRes) {
        DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

            if (pPreviousName == NULL ||
                pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
                // Setup the name directory to point to the next language
                // table

            pResDirN->Name = pRes->Name->uu.Ordinal;
                pResDirN->OffsetToData = (ULONG)((((PUCHAR)pResDirL)-p) |
                        IMAGE_RESOURCE_DATA_IS_DIRECTORY);
            pResDirN++;

                pPreviousName = pRes->Name;

                // Init a new Language table

                pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
        SetRestab(pResTabL, clock,
            (USHORT)0, (USHORT)pRes->NumberOfLanguages);
                pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
            }

            // Setup a new language directory entry to point to the next
            // resource

            pResDirL->Name = pRes->LanguageId;
            pResDirL->OffsetToData = (ULONG)(((PUCHAR)pResData) - p);
            pResDirL++;

            // Setup a new resource data entry


        SetResdata(pResData,
        pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
        pRes->DataSize);
        pResData++;

        pRes = pRes->pnext;
    }

    pType = pType->pnext;
    }
    DPrintf((DebugBuf, "Zeroing %u bytes after strings at %#08lx(mem)\n",
         (pResStrEnd - pResStr) * sizeof(*pResStr), pResStr));
    while (pResStr < pResStrEnd) {
    *pResStr++ = 0;
    }

#if DBG
    {
    USHORT  j = 0;
    PUSHORT pus = (PUSHORT)pResTab;

    while (pus < (PUSHORT)pResData) {
        DPrintf((DebugBuf, "%04x\t%04x %04x %04x %04x %04x %04x %04x %04x\n",
             j,
             *pus,
             *(pus + 1),
             *(pus + 2),
             *(pus + 3),
             *(pus + 4),
             *(pus + 5),
             *(pus + 6),
             *(pus + 7)));
        pus += 8;
        j += 16;
    }
    }
#endif /* DBG */

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    DPrintf((DebugBuf, "copying through PE header: %#08lx bytes @0x0\n",
         cbOldexe + sizeof(IMAGE_NT_HEADERS)));
    MuMoveFilePos(inpfh, 0L);
    MuCopy(inpfh, outfh, cbOldexe + sizeof(IMAGE_NT_HEADERS));

    /*
     * Copy rest of file header
     */
    DPrintf((DebugBuf, "skipping section table: %#08lx bytes @%#08lx\n",
         New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
         FilePos(outfh)));
    DPrintf((DebugBuf, "copying hdr data: %#08lx bytes @%#08lx ==> @%#08lx\n",
         Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd,
         ibObjTabEnd,
         ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
            Old.OptionalHeader.SizeOfHeaders));

    MuMoveFilePos(outfh, ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
            Old.OptionalHeader.SizeOfHeaders);
    MuMoveFilePos(inpfh, ibObjTabEnd);
    MuCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */
    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;
    DPrintf((DebugBuf, "padding header with %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
    while (cb >= cbPadMax) {
    MuWrite(outfh, pchZero, cbPadMax);
    cb -= cbPadMax;
    }
    MuWrite(outfh, pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MuMoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ;
        pObjOld < pObjLast ;
            pObjNew++) {
    if (pObjOld == pObjResourceOldX)
        pObjOld++;
    if (pObjNew == pObjResourceNew) {

        /* Write new resource section */
        DPrintf((DebugBuf, "Primary resource section %i to %#08lx\n",
            nObjResource+1, FilePos(outfh)));

        pObjNew->PointerToRawData = FilePos(outfh);
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
            New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
        ibSave = FilePos(outfh);
        DPrintf((DebugBuf,
            "writing resource header data: %#08lx bytes @%#08lx\n",
             cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);

        pResSave = WriteResSection(pUpdate, outfh,
                    New.OptionalHeader.FileAlignment,
                    pObjResourceNew->SizeOfRawData-cbRestab,
                    NULL);
        cb = FilePos(outfh);
        DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
            cb - ibSave - cbRestab, ibSave + cbRestab));
        if (cbMustPad != 0) {
        cbMustPad -= cb - ibSave;
        DPrintf((DebugBuf, "writing MUNGE pad: %#04lx bytes @%#08lx\n",
             cbMustPad, cb));
        /* assumes that cbMustPad % cbpadMax == 0 */
        while (cbMustPad > 0) {
            MuWrite(outfh, pchPad, cbPadMax);
            cbMustPad -= cbPadMax;
        }
        cb = FilePos(outfh);
        }
        if (nObjResourceX == -1) {
        MuMoveFilePos(outfh, ibSave);
        DPrintf((DebugBuf,
            "re-writing resource directory: %#08x bytes @%#08lx\n",
            cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
        MuMoveFilePos(outfh, cb);
        cb = FilePos(inpfh);
        MuMoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
        }
        New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
        if (pObjResourceOld == NULL) {
        pObjNew++;
        goto next_section;
        }
        else
        pObjOld++;
    }
    else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {

        /* Write new resource section */
        DPrintf((DebugBuf, "Secondary resource section %i @%#08lx\n",
            nObjResourceX+1, FilePos(outfh)));

        pObjNew->PointerToRawData = FilePos(outfh);
        (void)WriteResSection(pUpdate, outfh,
            New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
        cb = FilePos(outfh);
        pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
        pObjNew->Misc.VirtualSize = ROUNDUP(pObjNew->SizeOfRawData, New.OptionalHeader.SectionAlignment);
        DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
             pObjNew->SizeOfRawData, pObjNew->PointerToRawData));
        MuMoveFilePos(outfh, ibSave);
        DPrintf((DebugBuf,
            "re-writing resource directory: %#08x bytes @%#08lx\n",
            cbRestab, ibSave));
        MuWrite(outfh, (PUCHAR)pResTab, cbRestab);
        MuMoveFilePos(outfh, cb);
        New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
        pObjNew++;
        goto next_section;
    }
    else {
        if (pObjNew < pObjResourceNew &&
                pObjOld->PointerToRawData != 0 &&
        pObjOld->PointerToRawData != FilePos(outfh)) {
        MuMoveFilePos(outfh, pObjOld->PointerToRawData);
        }
next_section:
        /* Nop this section, because SteveWo doesn't know what he's doing
            if ((Old.OptionalHeader.BaseOfCode == 0x400) &&
                (Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R3000 ||
                 Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R4000
                ) &&
                (pObjOld->PointerToRawData != 0) &&
                (pObjOld->VirtualAddress != New.OptionalHeader.BaseOfCode) &&
                ((pObjOld->Characteristics&IMAGE_SCN_CNT_CODE) != 0)
               ) {
                cb = FilePos(outfh) & 0xFFF;
                if (cb != 0) {
                    cb = (cb ^ 0xFFF) + 1;
                    DPrintf((DebugBuf, "padding driver code section %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
                    while (cb >= cbPadMax) {
                        MuWrite(outfh, pchZero, cbPadMax);
                        cb -= cbPadMax;
                    }
                    MuWrite(outfh, pchZero, cb);
                }
            }
        End nop. */

        DPrintf((DebugBuf, "copying section %i @%#08lx\n",
            pObjNew-pObjtblNew+1, FilePos(outfh)));
        if (pObjOld->PointerToRawData != 0) {
        pObjNew->PointerToRawData = FilePos(outfh);
        MuMoveFilePos(inpfh, pObjOld->PointerToRawData);
        MuCopy(inpfh, outfh, pObjOld->SizeOfRawData);
        }
        if (pObjOld == pObjDebugDirOld) {
        pObjDebugDirNew = pObjNew;
        }
            if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
        New.OptionalHeader.SizeOfInitializedData +=
                pObjNew->SizeOfRawData;
        pObjOld++;
    }
    }
    if (pObjResourceOldX != NULL)
    New.OptionalHeader.SizeOfInitializedData -=
            pObjResourceOldX->SizeOfRawData;


    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew,
              pObjtblNew+New.FileHeader.NumberOfSections,
              ".reloc");
    if (pObjNew != NULL) {
    New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
    }

    /*
     * Write new section table out.
     */
    DPrintf((DebugBuf, "Writing new section table: %#08x bytes @%#08lx\n",
         New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
         ibObjTab));
    MuMoveFilePos(outfh, ibObjTab);
    MuWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /* Seek to end of output file and issue truncating write */
    adjust = _llseek(outfh, 0L, SEEK_END);
    MuWrite(outfh, NULL, 0);
    DPrintf((DebugBuf, "File size is: %#08lx\n", adjust));

    /* If a debug section, fix up the debug table */
    pObjNew = FindSection(pObjtblNew,
              pObjtblNew+New.FileHeader.NumberOfSections,
              ".debug");
    cb = PatchDebug(inpfh, outfh,
        pObjDebug, pObjNew,
        pObjDebugDirOld, pObjDebugDirNew,
                &Old, &New, ibMaxDbgOffsetOld, &adjust);

    if (cb == NO_ERROR) {
    if (pObjResourceOld == NULL) {
        cb = (LONG)pObjResourceNew->SizeOfRawData;
    }
    else {
        cb = (LONG)pObjResourceOld->SizeOfRawData -
         (LONG)pObjResourceNew->SizeOfRawData;
    }
    cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb,
        &New, Old.OptionalHeader.SizeOfHeaders);
    }

    /* copy NOTMAPPED debug info */
    if (pObjDebugDirOld != NULL && pObjDebug == NULL &&
        New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size
        != 0) {
    if (New.FileHeader.PointerToSymbolTable != 0)
        New.FileHeader.PointerToSymbolTable = adjust;   /* update symbol table ptr */
    ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
    _llseek(outfh, 0L, SEEK_END);       /* to EOF */
    MuMoveFilePos(inpfh, adjust);   /* returned by PatchDebug */
    DPrintf((DebugBuf, "Copying NOTMAPPED Debug Information, %#08lx bytes\n", ibSave-adjust));
    MuCopy(inpfh, outfh, ibSave-adjust);
    }

    /*
     * Write updated PE header
     */
    DPrintf((DebugBuf, "Writing updated file header: %#08x bytes @%#08lx\n",
         sizeof(IMAGE_NT_HEADERS),
         cbOldexe));
    MuMoveFilePos(outfh, (long)cbOldexe);
    MuWrite(outfh, (char*)&New, sizeof(IMAGE_NT_HEADERS));

    /* free up allocated memory */

    DPrintf((DebugBuf, "Freeing old section table: %#08lx(mem)\n", pObjtblOld));
    RtlFreeHeap(RtlProcessHeap(), 0, pObjtblOld);
    DPrintf((DebugBuf, "Freeing resource directory: %#08lx(mem)\n", pResTab));
    RtlFreeHeap(RtlProcessHeap(), 0, pResTab);

AbortExit:
    if (pObjtblNew)
    {
        DPrintf((DebugBuf, "Freeing new section table: %#08lx(mem)\n", pObjtblNew));
        RtlFreeHeap(RtlProcessHeap(), 0, pObjtblNew);
    }
    return cb;
}


/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME    pResSave
    )
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL    fName;
    PVOID   lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop1:
    for ( ; pRes ; pRes = pRes->pnext) {
        if (pResSave != NULL && pRes != pResSave)
        continue;
        pResSave = NULL;
#if DBG
        if (pType->Type->discriminant == IS_STRING) {
            DPrintf((DebugBuf, "    "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "."));
        }
        else {
            DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
        }
        if (pRes->Name->discriminant == IS_STRING) {
            DPrintfu((pRes->Name->szStr));
        }
        else {
            DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
        }
#endif
        lpData = (PVOID)pRes->OffsetToDataEntry;
        DPrintfn((DebugBuf, "\n"));

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
        DPrintf((DebugBuf,
            "Writing resource: %#04lx bytes @%#08lx\n",
            size, FilePos(outfh)));
        MuWrite(outfh, lpData, size);
        /* pad resource     */
        cbT = REMAINDER(size, CBLONG);
#ifdef DBG
        if (cbT != 0)
            DPrintf((DebugBuf,
                "Writing small pad: %#04lx bytes @%#08lx\n",
                cbT, FilePos(outfh)));
#endif
        MuWrite(outfh, pchPad, cbT);    /* dword    */
        cbB += size + cbT;
        cbLeft -= size + cbT;       /* less left    */
        continue;       /* next resource    */
        }
        else {          /* will fill up section    */
        DPrintf((DebugBuf, "Done with .rsrc section\n"));
        goto write_pad;
        }
    }
    if (fName) {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop1;
    }
    pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    pRes = pType->NameHeadName;
    fName = TRUE;
loop2:
    for ( ; pRes ; pRes = pRes->pnext) {
        if (pResSave != NULL && pRes != pResSave)
        continue;
        pResSave = NULL;
#if DBG
        if (pType->Type->discriminant == IS_STRING) {
            DPrintf((DebugBuf, "    "));
            DPrintfu((pType->Type->szStr));
            DPrintfn((DebugBuf, "."));
        }
        else {
            DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
        }
        if (pRes->Name->discriminant == IS_STRING) {
            DPrintfu((pRes->Name->szStr));
        }
        else {
            DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
        }
#endif
        lpData = (PVOID)pRes->OffsetToDataEntry;
        DPrintfn((DebugBuf, "\n"));

        /* if there is room in the current section, write it there */
        size = pRes->DataSize;
        if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
        DPrintf((DebugBuf,
            "Writing resource: %#04lx bytes @%#08lx\n",
            size, FilePos(outfh)));
        MuWrite(outfh, lpData, size);
        /* pad resource     */
        cbT = REMAINDER(size, CBLONG);
#ifdef DBG
        if (cbT != 0)
            DPrintf((DebugBuf,
                "Writing small pad: %#04lx bytes @%#08lx\n",
                cbT, FilePos(outfh)));
#endif
        MuWrite(outfh, pchPad, cbT);    /* dword    */
        cbB += size + cbT;
        cbLeft -= size + cbT;       /* less left    */
        continue;       /* next resource    */
        }
        else {          /* will fill up section    */
        DPrintf((DebugBuf, "Done with .rsrc section\n"));
        goto write_pad;
        }
    }
    if (fName) {
        fName = FALSE;
        pRes = pType->NameHeadID;
        goto loop2;
    }
    pType = pType->pnext;
    }
    pRes = NULL;

write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    DPrintf((DebugBuf, "Writing file sector pad: %#04lx bytes @%#08lx\n",
         cbLeft, FilePos(outfh)));
    if (cbLeft != 0) {
    while (cbLeft >= cbPadMax) {
        MuWrite(outfh, pchPad, cbPadMax);
        cbLeft -= cbPadMax;
    }
    MuWrite(outfh, pchPad, cbLeft);
    }
    return pRes;
}



#if DBG

void
wchprintf(WCHAR*wch)
{
    UNICODE_STRING ustring;
    STRING  string;
    char    buf[257];
    ustring.MaximumLength = ustring.Length = wcslen(wch) * sizeof(WCHAR);
    ustring.Buffer = wch;

    string.Length = 0;
    string.MaximumLength = 256;
    string.Buffer = buf;

    RtlUnicodeStringToAnsiString(&string, &ustring, FALSE);
    buf[string.Length] = '\000';
    DPrintfn((DebugBuf, "%s", buf));
}
#endif

//
// adjust debug directory table
//

/*  */
LONG
PatchDebug(int  inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER pDebugOld,
      PIMAGE_SECTION_HEADER pDebugNew,
      PIMAGE_SECTION_HEADER pDebugDirOld,
      PIMAGE_SECTION_HEADER pDebugDirNew,
      PIMAGE_NT_HEADERS pOld,
      PIMAGE_NT_HEADERS pNew,
          ULONG ibMaxDbgOffsetOld,
      PULONG pPointerToRawData)
{
    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG   ib;
    ULONG   adjust;
    ULONG   ibNew;

    if (pDebugDirOld == NULL ||
    pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size==0)
    return NO_ERROR;

    pDbgSave = pDbg = (PIMAGE_DEBUG_DIRECTORY)RtlAllocateHeap(
            RtlProcessHeap(), MAKE_TAG( RES_TAG ),
        pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    if (pDbg == NULL)
    return ERROR_NOT_ENOUGH_MEMORY;

    if (pDebugOld) {
    DPrintf((DebugBuf, "Patching dbg directory: @%#08lx ==> @%#08lx\n",
         pDebugOld->PointerToRawData, pDebugNew->PointerToRawData));
    }
    else
        adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MuMoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MuRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL) {
    /* find 1st entry - use for offset */
        DPrintf((DebugBuf, "Adjust: %#08lx\n",adjust));
    for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld &&
                pDbg->PointerToRawData < ibNew
               )
                ibNew = pDbg->PointerToRawData;
    
    if (ibNew != 0xffffffff)
        *pPointerToRawData = ibNew;
    else
        *pPointerToRawData = _llseek(inpfh, 0L, SEEK_END);
    for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++) {
        DPrintf((DebugBuf, "Old debug file offset: %#08lx\n",
             pDbg->PointerToRawData));
            if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld)
                pDbg->PointerToRawData += adjust - ibNew;
        DPrintf((DebugBuf, "New debug file offset: %#08lx\n",
             pDbg->PointerToRawData));
    }
    }
    else {
    for ( ; pDbg<pDbgLast ; pDbg++) {
        DPrintf((DebugBuf, "Old debug addr: %#08lx, file offset: %#08lx\n",
             pDbg->AddressOfRawData,
             pDbg->PointerToRawData));
        pDbg->AddressOfRawData += pDebugNew->VirtualAddress -
                pDebugOld->VirtualAddress;
        pDbg->PointerToRawData += pDebugNew->PointerToRawData -
                pDebugOld->PointerToRawData;
        DPrintf((DebugBuf, "New debug addr: %#08lx, file offset: %#08lx\n",
             pDbg->AddressOfRawData,
             pDbg->PointerToRawData));
    }
    }

    MuMoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MuWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    RtlFreeHeap(RtlProcessHeap(), 0, pDbgSave);

    return NO_ERROR;
}

//
// This routine patches various RVAs in the file to compensate
// for extra section table entries.
//


LONG
PatchRVAs(int   inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER po32,
      ULONG pagedelta,
      PIMAGE_NT_HEADERS pNew,
      ULONG OldSize)
{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0) {
    return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //

    DPrintf((DebugBuf, "Export offset=%08lx, hdrsize=%08lx\n",
         pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
         pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
    {
    DPrintf((DebugBuf, "No exports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    DPrintf((DebugBuf, "No exports in header to patch\n"));
    }
    else
    {
    MuMoveFilePos(inpfh, offset - hdrdelta);
    MuRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
    Exp.Name += hdrdelta;
    (ULONG)Exp.AddressOfFunctions += hdrdelta;
    (ULONG)Exp.AddressOfNames += hdrdelta;
    (ULONG)Exp.AddressOfNameOrdinals += hdrdelta;
    MuMoveFilePos(outfh, offset);
    MuWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //

    DPrintf((DebugBuf, "Import offset=%08lx, hdrsize=%08lx\n",
         pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
         pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0)
    {
    DPrintf((DebugBuf, "No imports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    DPrintf((DebugBuf, "No imports in header to patch\n"));
    }
    else
    {
    for (cimp = cmod = 0; ; cmod++)
    {
        MuMoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
        MuRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
        if (Imp.FirstThunk == 0)
        {
        break;
        }
        Imp.Name += hdrdelta;
        MuMoveFilePos(outfh, offset + cmod * sizeof(Imp));
        MuWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));

        rvaiat = (ULONG)Imp.FirstThunk;
        DPrintf((DebugBuf, "RVAIAT = %#08lx\n", (ULONG)rvaiat));
        for (i = 0; i < pNew->FileHeader.NumberOfSections; i++) {
        if (rvaiat >= po32[i].VirtualAddress &&
            rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData) {

            offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
            goto found;
        }
        }
        DPrintf((DebugBuf, "IAT not found\n"));
        return ERROR_INVALID_DATA;
found:
        DPrintf((DebugBuf, "IAT offset: @%#08lx ==> @%#08lx\n",
             offiat - pagedelta,
             offiat));
        MuMoveFilePos(inpfh, offiat - pagedelta);
        MuMoveFilePos(outfh, offiat);
        for (;;) {
        MuRead(inpfh, (PUCHAR) &iat, sizeof(iat));
        if (iat == 0) {
            break;
        }
        if ((iat & IMAGE_ORDINAL_FLAG) == 0) {  // if import by name
            DPrintf((DebugBuf, "Patching IAT: %08lx + %04lx ==> %08lx\n",
                 iat,
                 hdrdelta,
                 iat + hdrdelta));
            iat += hdrdelta;
            cimp++;
        }
        MuWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
        }
    }
    DPrintf((DebugBuf, "%u import module name RVAs patched\n", cmod));
    DPrintf((DebugBuf, "%u IAT name RVAs patched\n", cimp));
    if (cmod == 0)
    {
        DPrintf((DebugBuf, "No import modules to patch\n"));
    }
    if (cimp == 0)
    {
        DPrintf((DebugBuf, "No import name RVAs to patch\n"));
    }
    }

    return NO_ERROR;

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/


LONG
WriteResFile(
    HANDLE  hUpdate,
    CHAR    *pDstname)
{
    HANDLE  inh;
    HANDLE  outh;
    INT     inpfh;
    INT     outfh;
    ULONG   onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    INT     rc;
    CHAR    *pFilename;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    pFilename = (CHAR*)GlobalLock(pUpdate->hFileName);

    /* open the original exe file */
    inh = CreateFile(pFilename, GENERIC_READ, 0 /*exclusive access*/, NULL /* security attr */,  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    GlobalUnlock(pUpdate->hFileName);
    if ( inh == INVALID_HANDLE_VALUE )   {
        GlobalUnlock(hUpdate);
        return ERROR_OPEN_FAILED;
    }
    inpfh = (INT)HandleToLong(inh); 

    /* read the old format EXE header */
    rc = _lread(inpfh, (char*)&oldexe, sizeof(oldexe));
    if (rc != sizeof(oldexe)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_READ_FAULT;
    }

    /* make sure its really an EXE file */
    if (oldexe.e_magic != IMAGE_DOS_SIGNATURE) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_INVALID_EXE_SIGNATURE;
    }

    /* make sure theres a new EXE header floating around somewhere */
    if (!(onewexe = oldexe.e_lfanew)) {
        _lclose(inpfh);
        GlobalUnlock(hUpdate);
        return ERROR_BAD_EXE_FORMAT;
    }

    outh = CreateFile(pDstname, GENERIC_READ|GENERIC_WRITE, 0 /*exclusive access*/, NULL /* security attr */, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if ( outh != INVALID_HANDLE_VALUE )   {
        outfh = (INT)HandleToLong( outh );
        rc = PEWriteResFile(inpfh, outfh, onewexe, pUpdate);
        _lclose(outfh);
    }

    _lclose(inpfh);
    GlobalUnlock(hUpdate);
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf16\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286p
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

ifndef WEPSEG
    WEPSEG equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE
createSeg %WEPSEG, WepCodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;   external functions
;
        externFP    LocalInit           ; in KERNEL
        externFP    LibMain             ; C code to do DLL init

;-----------------------------------------------------------------------;
;
;
%out link me first!!
sBegin  Data
assumes DS,Data
	org 0			;Base of DATA segment.

	DD 0			;So null pointers get 0.
maxRsrvPtrs = 5
	DW maxRsrvPtrs
usedRsrvPtrs = 0
labelDP	<PUBLIC, rsrvptrs>

DefRsrvPtr	MACRO	name
globalW	name, 0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr	pLocalHeap	;Local heap pointer.
DefRsrvPtr	pAtomTable	;Atom table pointer.
DefRsrvPtr	pStackTop	;Top of stack.
DefRsrvPtr	pStackMin	;Minimum value of SP.
DefRsrvPtr	pStackBot	;Bottom of stack.

if maxRsrvPtrs - usedRsrvPtrs
	DW maxRsrvPtrs - usedRsrvPtrs DUP (0)
endif

public	__acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain
cEnd

sEnd    CodeSeg

;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;

sBegin  WepCodeSeg
        assumes cs,WepCodeSeg
        assumes ds,nothing
        assumes es,nothing

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
        ParmW  WhyIsThisParamBogusDave?
cBegin
cEnd

sEnd    WepCodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf16\wexthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf16\w95inf16.h ===
#include <windows.h>
#include <winerror.h>
#include <setupx.h>


typedef char    CHAR;




    /*
     * Resource String Names
     */
#define IDS_SETUPX_FILENAME     100
#define IDS_GENERIC_SETUPX_ERR  101




#define SMALL_BUF_LEN           48
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf16\w95inf16.c ===
/*
 * w95inf16.c
 *
 * Copyright (c) 1995 Microsoft Corporation
 *
 * 16bit portion of the INFINST program.   This DLL contains all the
 * stuff to drive GenInstall (a 16 bit DLL)
 *
 */
#include "w95inf16.h"
#include <regstr.h>
#include <cpldebug.h>
#include <memory.h>
#include <string.h>
//#include "..\core\infinst.h"

#pragma message("If you change W95INF16.DLL, you need to manually increase")
#pragma message("the version number in w95inf16.rcv. This is not done automatically.")
#define SHORTSTRING 256

    /*
     * GLOBALS
     */
HINSTANCE   hInstance;

CHAR    szDll16[] = "W95INF16.DLL";
CHAR    szDll32[] = "W95INF32.DLL";

static  char    g_szRunOnceExe[] = {"runonce"};

    /*
     * S T R I N G S
     */
char    *szSectVersion          = "version";
char    *szKeySignature         = "signature";
char    *szValSignature         = "$CHICAGO$";

    /*
     * Declarations
     */
BOOL FAR PASCAL w95thk_ThunkConnect16(LPSTR pszDLL16, LPSTR pszDll32, WORD hInst, DWORD dwReason);
VOID WINAPI GetSETUPXErrorText16(DWORD,LPSTR, DWORD);
WORD WINAPI CtlSetLddPath16(UINT, LPSTR);
WORD WINAPI GenInstall16(LPSTR, LPSTR, LPSTR, DWORD);
BOOL WINAPI GenFormStrWithoutPlaceHolders16(LPSTR, LPSTR, LPSTR);

    /*
     * Library Initialization
     *
     * Call by LibInit
     */
BOOL FAR PASCAL LibMain(HINSTANCE hInst, WORD wDataSeg, WORD wHeapSize, LPSTR lpszCmdLine)
{
    // Keep Copy of Instance
    hInstance = hInst;

    DEBUGMSG("W95INF16.DLL - LibMain()");

    return( TRUE );
}

    /*
     * Thunk Entry Point
     */
BOOL FAR PASCAL DllEntryPoint(DWORD dwReason, WORD hInst, WORD wDS, WORD wHeapSize, DWORD dwReserved1, WORD wReserved2)
{

    DEBUGMSG("W95INF16.DLL - DllEntryPoint()");
    if (! (w95thk_ThunkConnect16(szDll16, szDll32, hInst, dwReason)))  {
        DEBUGMSG("W95INF16.DLL - w95thk_ThunkConnect16() Failed");
        return( FALSE );
    }

    return( TRUE );
}


/*
 *  O P E N _ V A L I D A T E _ I N F
 *
 * Routine:     OpenValidateInf
 *
 * Purpose:     Open INF and validate internals
 *
 * Notes:       Stolen from setupx
 *
 * 
 */

RETERR OpenValidateInf(LPCSTR lpszInfFile, HINF FAR * phInf )
{
    RETERR  err;            
    HINF    hInfFile;
    char    szTmpBuf[SHORTSTRING];


	ASSERT(lpszInfFile);
	ASSERT(phInf);

    DEBUGMSG("OpenValidateInf([%s])", lpszInfFile );

    *phInf = NULL;
        /*
         * Open the INF
         */
    err = IpOpen( lpszInfFile, &hInfFile );
	if (err != OK) {
		DEBUGMSG("IpOpen(%s) returned %u",(LPSTR) lpszInfFile,err);
		return err;
	}

        /*
         * Get INF signature
         */
    err = IpGetProfileString( hInfFile, szSectVersion, szKeySignature, szTmpBuf, sizeof(szTmpBuf));
	if (err != OK) {
        DEBUGMSG("IpGetProfileString returned %u",err);
		return err;
	}

        /*
         * Check INF signature
         */
    if ( lstrcmpi(szTmpBuf,szValSignature) != 0 )   {
		DEBUGMSG("signature error in %s",(LPSTR) lpszInfFile);		
        IpClose(hInfFile);
		return ERR_IP_INVALID_INFFILE;
    }

        /*
         * Set Out Parameter phInf
         */
    *phInf = hInfFile;

    DEBUGMSG("OpenValidateInf([%s]) Complete", lpszInfFile );
    return OK;
}

//***************************************************************************
//*                                                                         *
//* NAME:       AddPath                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID AddPath(LPSTR szPath, LPCSTR szName )
{
    LPSTR szTmp;

        // Find end of the string
    szTmp = szPath + lstrlen(szPath);

        // If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';

        // Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpy( szTmp, szName );
}


//BUGBUG:  Ideally, we would like to use the HWND in here, but in 32-bit land,
//         HWND is 32-bits and in 16-bit land, HWND is 16-bits, so we have a
//         problem.

//WORD WINAPI GenInstall16(LPSTR lpszInf, LPSTR lpszSection, LPSTR lpszDirectory, DWORD dwQuietMode, DWORD hWnd )
WORD WINAPI GenInstall16(LPSTR lpszInf, LPSTR lpszSection, LPSTR lpszDirectory, DWORD dwQuietMode )
{
    VCPUIINFO   VcpUiInfo;
    RETERR      err;
	BYTE		fNeedBoot	= 1;
    char        szPrevSourcePath[MAX_PATH+1]    = "";
    BOOL        fNeedToRestorePrevSourcePath    = FALSE;
    HINF        hInf = NULL;

    ASSERT(lpszInf);
    ASSERT(lpszSection);

        /*
         * Open INF
         */
    err = OpenValidateInf(lpszInf, &hInf);
    if (err != OK) {
            DEBUGMSG("OpenValidateInf(%s) returned %u",lpszInf, err);
            goto done;
    }
    ASSERT(hInf);

        /*
         * Save source path for restoration
         *
         *      If we get a non-zero length string for the old
         *      source path then we will restore it when finished
         */
    err = CtlGetLddPath(LDID_SRCPATH,szPrevSourcePath);
    if ((err == OK) && (lstrlen(szPrevSourcePath)))  {
        DEBUGMSG("Saved Sourcpath [%s]", szPrevSourcePath );
        fNeedToRestorePrevSourcePath = TRUE;
    }


        /*
         * Set Source Path for GenInstall
         */                                                                   

    DEBUGMSG("Setting Source path to [%s]", lpszDirectory );
    CtlSetLddPath(LDID_SRCPATH, lpszDirectory );

        /*
         * Set Up GenInstall UI
         */
    _fmemset(&VcpUiInfo,0,sizeof(VcpUiInfo));
    if ( ! dwQuietMode ) {
        VcpUiInfo.flags = VCPUI_CREATEPROGRESS;
    } else {
        VcpUiInfo.flags = 0;
    }

    VcpUiInfo.hwndParent = 0;           // Our parent
    VcpUiInfo.hwndProgress = NULL;        // No progress DLG
    VcpUiInfo.idPGauge = 0;
    VcpUiInfo.lpfnStatCallback = NULL;    // No stat callback
    VcpUiInfo.lUserData = 0L;             // No client data.


        /*
         * Open VCP to batch copy requests
         */
    DEBUGMSG("Setting up VCP");
    err = VcpOpen((VIFPROC) vcpUICallbackProc, (LPARAM)(LPVCPUIINFO)&VcpUiInfo);
	if (err != OK) 
	{
		DEBUGMSG("VcpOpen returned %u",err);
		goto done;
	}
    DEBUGMSG("VCP Setup Complete");


        /*
         * Call GenInstall to Install Files
         */

        /*
         * GenInstall Go Do your thing
         */
    err = GenInstall(hInf,lpszSection, GENINSTALL_DO_FILES );

    // err = InstallFilesFromINF(0, lpszInf, lpszSection, GENINSTALL_DO_FILES);
    DEBUGMSG("GeInstall() DO_FILE Returned %d", err);
    if (err == OK) 
	{
        err = VcpClose(VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME, NULL);
        if (err != OK) 
		{
            DEBUGMSG("VcpClose returned %u", err);
            goto done;
        }
    }
	else
	{
        err = VcpClose(VCPFL_ABANDON, NULL);
        if (err != OK)
		{
            DEBUGMSG("VcpClose returned %u", err);
            goto done;
        }
    }


        /*
         * Now have GenInstall do rest of install
         */
    err = GenInstall(hInf, lpszSection, GENINSTALL_DO_ALL ^ GENINSTALL_DO_FILES );

    //DEBUGMSG("Installing everything else using InstallFilesFromINF()");
    //err = InstallFilesFromINF(0, lpszInf, lpszSection, GENINSTALL_DO_ALL ^ GENINSTALL_DO_FILES);
    if (err != OK)
	{
        DEBUGMSG("GenInstall() Non Files returned %d", err );
        goto done;
    }

done:
        /*
         * Restore Source LDID
         */
	if (fNeedToRestorePrevSourcePath) {
		DEBUGMSG("Restoring source path to: %s",(LPSTR) szPrevSourcePath);
		err=CtlSetLddPath(LDID_SRCPATH,szPrevSourcePath);
		ASSERT(err == OK);
	}

    if ( hInf )
        IpClose( hInf );

    return(err);
}



VOID WINAPI GetSETUPXErrorText16(DWORD dwError,LPSTR pszErrorDesc, DWORD cbErrorDesc)
{
	WORD wID;	// ID of string resource in SETUPX with error description	

	// get string ID with this error from setupx
    wID = suErrorToIds((WORD) dwError,E2I_SETUPX);

	if (wID) {
		CHAR szSetupxFilename[13];	// big enough for 8.3
		HMODULE hInstSetupx;

		// get setupx filename out of resource
		LoadString(hInstance,IDS_SETUPX_FILENAME,szSetupxFilename,
			sizeof(szSetupxFilename));

		// get the module handle for setupx
		hInstSetupx = GetModuleHandle(szSetupxFilename);
		ASSERT(hInstSetupx);	// pretty weird if this fails
		if (hInstSetupx) {

			// load the string from setupx
			if (LoadString(hInstSetupx,wID,pszErrorDesc,(int) cbErrorDesc)) {
				return;	// got it
			}																	   	
		}
	} 

	// we get here if couldn't map error to string ID, couldn't get
	// SETUPX module handle, or couldn't find string ID in setupx.  1st
	// case is relatively likely, other cases are pretty unlikely.
	{
		CHAR szFmt[SMALL_BUF_LEN+1];
		// load generic text and insert error number
		LoadString(hInstance,IDS_GENERIC_SETUPX_ERR,szFmt,sizeof(szFmt));
		wsprintf(pszErrorDesc,szFmt,wID);
	}
}



WORD WINAPI CtlSetLddPath16(UINT uiLDID, LPSTR lpszPath)
{
	return(CtlSetLddPath(uiLDID, lpszPath));
}

BOOL WINAPI GenFormStrWithoutPlaceHolders16( LPSTR lpszDst, LPSTR lpszSrc, LPSTR lpszInfFilename )
{
    RETERR  err = OK;
    HINF hInf;

    err = OpenValidateInf(lpszInfFilename, &hInf);
	if (err != OK) {
        DEBUGMSG("OpenValidateInf(%s) returned %u",lpszInfFilename, err);
        return FALSE;
	}

    GenFormStrWithoutPlaceHolders( lpszDst, (LPCSTR) lpszSrc, hInf );

    IpClose( hInf );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\updfile\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RESOURCE.H                                                              *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_SUCCESS             1000

#define IDS_ERR_INVALID_ARGS    1100
#define IDS_ERR_GET_FULL_PATH   1101
#define IDS_ERR_FILE_NOT_EXIST  1102
#define IDS_ERR_LOAD_EXE        1103
#define IDS_ERR_BEGIN_UPD_RES   1104
#define IDS_ERR_OPEN_INPUT_FILE 1105
#define IDS_ERR_NO_MEMORY       1106
#define IDS_ERR_READ_INPUT_FILE 1107
#define IDS_ERR_UPDATE_RES      1108
#define IDS_ERR_END_UPD_RES     1109
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf32\w95thk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf32\w95pub32.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* W95PUB16.H - Public interface to W95INF16.DLL.                          *
//*                                                                         *
//***************************************************************************

#ifndef _W95PUB16_H_
#define _W95PUB16_H_

static const TCHAR achCTLSETLDDPATH32[]                 = "CtlSetLddPath32@8";
static const TCHAR achGENINSTALL32[]                    = "GenInstall32@20";
static const TCHAR achGETSETUPXERRORTEXT32[]            = "GetSETUPXErrorText32@12";
static const TCHAR achGENFORMSTRWITHOUTPLACEHOLDERS32[] = "GenFormStrWithoutPlaceHolders32@12";

typedef VOID (WINAPI *GETSETUPXERRORTEXT32)( DWORD, LPSTR, DWORD);
typedef WORD (WINAPI *CTLSETLDDPATH32)(UINT, LPSTR);
typedef WORD (WINAPI *GENINSTALL32)(LPSTR, LPSTR, LPSTR, DWORD, DWORD);
typedef BOOL (WINAPI *GENFORMSTRWITHOUTPLACEHOLDERS32)(LPSTR, LPSTR, LPSTR);

#endif // _W95PUB16_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\updfile\updfile.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* UPDFILE.C                                                               *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <stdio.h>
//#include <stdlib.h>
#include <wtypes.h>
#include "resource.h"
#include "updfile.h"
#include "updres.h"


//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************



//***************************************************************************
//*                                                                         *
//* NAME:       main                                                        *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the program.                           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    int:            Always 0                                    *
//*                                                                         *
//***************************************************************************
INT _cdecl main( INT argc, CHAR *argv[] )
{
    // ARGV[1] == Name of package
    // ARGV[2] == Name of file to add to package
    HANDLE  hUpdateRes = NULL;
    HANDLE  hFile      = INVALID_HANDLE_VALUE;
    DWORD   dwFileSize = 0;
    PSTR    pszFileContents = NULL;
    DWORD   dwBytes;
    HMODULE hModule;
    TCHAR   szResName[20];
    DWORD   dwResNum;
    TCHAR   szFileToAdd[MAX_PATH];
    PSTR    pszFileToAddFilename = NULL;
    TCHAR   szPackage[MAX_PATH];
    PSTR    pszPackageFilename = NULL;
    DWORD   dwHeaderSize = 0;
    PSTR    pszTemp = NULL;
    DWORD   dwReturnCode = 0;
    PDWORD  pdwTemp = NULL;
    static const TCHAR c_szResNameTemplate[] = "UPDFILE%lu";

    if ( argc != 3 ) {
        MsgBox( IDS_ERR_INVALID_ARGS );
        dwReturnCode = 1;
        goto done;
    }

    dwFileSize = GetFullPathName( argv[1], sizeof(szPackage), szPackage, &pszPackageFilename );
    if ( (dwFileSize+1) > sizeof(szPackage) || dwFileSize == 0 ) {
        MsgBox1Param( IDS_ERR_GET_FULL_PATH, argv[1] );
        dwReturnCode = 1;
        goto done;
    }

    if ( ! FileExists( szPackage ) ) {
        MsgBox1Param( IDS_ERR_FILE_NOT_EXIST, argv[1] );
        dwReturnCode = 1;
        goto done;
    }

    dwFileSize = GetFullPathName( argv[2], sizeof(szFileToAdd), szFileToAdd, &pszFileToAddFilename );
    if ( (dwFileSize+1) > sizeof(szFileToAdd) || dwFileSize == 0 ) {
        MsgBox1Param( IDS_ERR_GET_FULL_PATH, argv[2] );
        dwReturnCode = 1;
        goto done;
    }

    if ( ! FileExists( szFileToAdd ) ) {
        MsgBox1Param( IDS_ERR_FILE_NOT_EXIST, argv[2] );
        dwReturnCode = 1;
        goto done;
    }

    // make sure the target file is not read-only file
    SetFileAttributes( szPackage, FILE_ATTRIBUTE_NORMAL );

    hModule = LoadLibraryEx( szPackage, NULL, LOAD_LIBRARY_AS_DATAFILE |
                             DONT_RESOLVE_DLL_REFERENCES );
    if ( hModule == NULL ) {
        MsgBox1Param( IDS_ERR_LOAD_EXE, argv[1] );
        dwReturnCode = 1;
        goto done;
    }

    for ( dwResNum = 0; ; dwResNum += 1 ) {
        wsprintf( szResName, c_szResNameTemplate, dwResNum );

        if ( FindResource( hModule, szResName, RT_RCDATA ) == NULL ) {
            break;
        }
    }

    FreeLibrary( hModule );

    hFile = CreateFile( szFileToAdd, GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, 0, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        MsgBox1Param( IDS_ERR_OPEN_INPUT_FILE, argv[2] );
        dwReturnCode = 1;
        goto done;
    }

    dwFileSize = GetFileSize( hFile, NULL );
    dwHeaderSize = sizeof(DWORD) + sizeof(DWORD) + lstrlen(pszFileToAddFilename) + 1;

    // File Size + reserved DWORD + Filename\0 + File Contents
    pszFileContents = (PSTR) LocalAlloc( LPTR, dwHeaderSize + dwFileSize );
    if ( ! pszFileContents )  {
        MsgBox( IDS_ERR_NO_MEMORY );
        dwReturnCode = 1;
        goto done;
    }

    pdwTemp = (PDWORD) pszFileContents;
    *pdwTemp = dwFileSize;
    pdwTemp = (PDWORD) (pszFileContents + sizeof(DWORD));
    *pdwTemp = MAXDWORD;
    pszTemp = pszFileContents + sizeof(DWORD) + sizeof(DWORD);
    lstrcpy( pszTemp, pszFileToAddFilename );
    pszTemp = pszFileContents + dwHeaderSize;
    

    if ( ! ReadFile( hFile, pszTemp, dwFileSize, &dwBytes, NULL ) )
    {
        MsgBox1Param( IDS_ERR_READ_INPUT_FILE, argv[2] );
        dwReturnCode = 1;
        goto done;
    }

    CloseHandle( hFile );
    hFile = INVALID_HANDLE_VALUE ;

    // Initialize the EXE file for resource editing
    hUpdateRes = LocalBeginUpdateResource( szPackage, FALSE );
    if ( hUpdateRes == NULL ) {
        MsgBox1Param( IDS_ERR_BEGIN_UPD_RES, argv[1] );
        dwReturnCode = 1;
        goto done;
    }
                  
    if ( LocalUpdateResource( hUpdateRes, RT_RCDATA,
         szResName, MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
         pszFileContents, dwHeaderSize + dwFileSize )
         == FALSE )
    {
        MsgBox1Param( IDS_ERR_UPDATE_RES, argv[1] );
        dwReturnCode = 1;
        goto done;
    }

  done:

    if ( hUpdateRes ) {
        // Write out modified EXE if success ((returncode = 0, means pass
        // in FALSE to update file (i.e., don't discard changes)
        if ( LocalEndUpdateResource( hUpdateRes, (dwReturnCode == 1) ) == FALSE ) {
                MsgBox1Param( IDS_ERR_END_UPD_RES, argv[1] );
                dwReturnCode = 1;
        }
    }

    if ( pszFileContents ) {
        LocalFree( pszFileContents );
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle( hFile ) ;
    }

    if (dwReturnCode == 0)
        MsgBox2Param( IDS_SUCCESS, argv[2], argv[1] );


    return dwReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FileExists                                                  *
//*                                                                         *
//* SYNOPSIS:   Checks if a file exists.                                    *
//*                                                                         *
//* REQUIRES:   pszFilename                                                 *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if it exists, FALSE otherwise              *
//*                                                                         *
//***************************************************************************
BOOL FileExists( PCSTR pszFilename )
{
    HANDLE hFile;

    hFile = CreateFile( pszFilename, GENERIC_READ, FILE_SHARE_READ |
                        FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    CloseHandle( hFile );

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgBox2Param                                                *
//*                                                                         *
//* SYNOPSIS:   Displays a message box with the specified string ID using   *
//*             2 string parameters.                                        *
//*                                                                         *
//* REQUIRES:   hWnd:           Parent window                               *
//*             nMsgID:         String resource ID                          *
//*             szParam1:       Parameter 1 (or NULL)                       *
//*             szParam2:       Parameter 2 (or NULL)                       *
//*             uIcon:          Icon to display (or 0)                      *
//*             uButtons:       Buttons to display                          *
//*                                                                         *
//* RETURNS:    INT:            ID of button pressed                        *
//*                                                                         *
//* NOTES:      Macros are provided for displaying 1 parameter or 0         *
//*             parameter message boxes.  Also see ErrorMsg() macros.       *
//*                                                                         *
//***************************************************************************
VOID MsgBox2Param( UINT nMsgID, PCSTR c_pszParam1, PCSTR c_pszParam2 )
{
    TCHAR szMsgBuf[512];
    PSTR  pszMessage = NULL;
    static const TCHAR c_szError[] = "Unexpected Error.  Could not load resource.";
    PSTR  apszParams[2];

    apszParams[0] = (PSTR) c_pszParam1;
    apszParams[1] = (PSTR) c_pszParam2;

    LoadSz( nMsgID, szMsgBuf, sizeof(szMsgBuf) );

    if ( (*szMsgBuf) == '\0' ) {
        lstrcpy( szMsgBuf, c_szError );
    }

    if ( FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY
                        | FORMAT_MESSAGE_ALLOCATE_BUFFER, szMsgBuf, 0, 0, (PSTR) (&pszMessage),
                        0, (va_list *)apszParams ) )
    {
        printf( "\n%s\n\n", pszMessage );
        LocalFree( pszMessage );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       LoadSz                                                      *
//*                                                                         *
//* SYNOPSIS:   Loads specified string resource into buffer.                *
//*                                                                         *
//* REQUIRES:   idString:                                                   *
//*             lpszBuf:                                                    *
//*             cbBuf:                                                      *
//*                                                                         *
//* RETURNS:    LPSTR:     Pointer to the passed-in buffer.                 *
//*                                                                         *
//* NOTES:      If this function fails (most likely due to low memory), the *
//*             returned buffer will have a leading NULL so it is generally *
//*             safe to use this without checking for failure.              *
//*                                                                         *
//***************************************************************************
PSTR LoadSz( UINT idString, PSTR pszBuf, UINT cbBuf )
{
    // Clear the buffer and load the string
    if ( pszBuf ) {
        *pszBuf = '\0';
        LoadString( NULL, idString, pszBuf, cbBuf );
    }

    return pszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\cpldebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME ""
#endif	// SZ_COMPNAME



static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
	_asm {int 3};
}

#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf16\w95thk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Wed Jan 29 18:57:28 1997

;Command Line: ..\..\..\..\dev\tools\binr\thunk.exe -NC _TEXT ..\w95thk.thk 

	TITLE	$..\w95thk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_w95thkTargetTable	;Flat address of target table in 16-bit module.

public FT_w95thkChecksum32
FT_w95thkChecksum32	dd	03469h


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public w95thk_ThunkData32	;This symbol must be exported.
w95thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	03469h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_w95thk - offset w95thk_ThunkData32
	dd	offset FT_Prolog_w95thk - offset w95thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public w95thk_ThunkConnect32@16
w95thk_ThunkConnect32@16:
	pop	edx
	push	offset w95thk_ThkData16
	push	offset w95thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
w95thk_ThkData16 label byte
	db	"w95thk_ThunkData16",0


		


pfnQT_Thunk_w95thk	dd offset QT_Thunk_w95thk
pfnFT_Prolog_w95thk	dd offset FT_Prolog_w95thk
	.data
QT_Thunk_w95thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_w95thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include w95thk.inc



;************************ START OF THUNK BODIES************************




;
public GetSETUPXErrorText16@12
GetSETUPXErrorText16@12:
	FAPILOG16	73
	mov	cl,3
; GetSETUPXErrorText16(16) = GetSETUPXErrorText16(32) {}
;
; dword ptr [ebp+8]:  dwError
; dword ptr [ebp+12]:  lpszErrorText
; dword ptr [ebp+16]:  cbErrorText
;
public IIGetSETUPXErrorText16@12
IIGetSETUPXErrorText16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwError: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbErrorText: dword->dword
	call	dword ptr [pfnQT_Thunk_w95thk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public CtlSetLddPath16@8
CtlSetLddPath16@8:
	FAPILOG16	53
	mov	cl,2
; CtlSetLddPath16(16) = CtlSetLddPath16(32) {}
;
; dword ptr [ebp+8]:  uiLDID
; dword ptr [ebp+12]:  lpszPath
;
public IICtlSetLddPath16@8
IICtlSetLddPath16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;uiLDID: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_w95thk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public GenInstall16@12
GenInstall16@12:
	FAPILOG16	36
	mov	cl,1
; GenInstall16(16) = GenInstall16(32) {}
;
; dword ptr [ebp+8]:  lpszInf
; dword ptr [ebp+12]:  lpszSection
; dword ptr [ebp+16]:  lpszDirectory
;
public IIGenInstall16@12
IIGenInstall16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_w95thk]
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public GenFormStrWithoutPlaceHolders16@12
GenFormStrWithoutPlaceHolders16@12:
	FAPILOG16	0
	mov	cl,0
; GenFormStrWithoutPlaceHolders16(16) = GenFormStrWithoutPlaceHolders16(32) {}
;
; dword ptr [ebp+8]:  lpszDst
; dword ptr [ebp+12]:  lpszSrc
; dword ptr [ebp+16]:  lpszInfFilename
;
public IIGenFormStrWithoutPlaceHolders16@12
IIGenFormStrWithoutPlaceHolders16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_w95thk]
	cwde
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] GenFormStrWithoutPlaceHolders16',0
	db	'[F] GenInstall16',0
	db	'[F] CtlSetLddPath16',0
	db	'[F] GetSETUPXErrorText16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef GenFormStrWithoutPlaceHolders16:far16
externDef GenInstall16:far16
externDef CtlSetLddPath16:far16
externDef GetSETUPXErrorText16:far16


FT_w95thkTargetTable label word
	dw	offset GenFormStrWithoutPlaceHolders16
	dw	   seg GenFormStrWithoutPlaceHolders16
	dw	offset GenInstall16
	dw	   seg GenInstall16
	dw	offset CtlSetLddPath16
	dw	   seg CtlSetLddPath16
	dw	offset GetSETUPXErrorText16
	dw	   seg GetSETUPXErrorText16




	.data

public w95thk_ThunkData16	;This symbol must be exported.
w95thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	03469h	;Checksum
	dw	offset FT_w95thkTargetTable
	dw	seg    FT_w95thkTargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public w95thk_ThunkConnect16
w95thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    w95thk_ThunkData16
	push	offset w95thk_ThunkData16
	push	seg    w95thk_ThkData32
	push	offset w95thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
w95thk_ThkData32 label byte
	db	"w95thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf32\w95inf32.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* W95INF32.H - Self-extracting/Self-installing stub.                      *
//*                                                                         *
//***************************************************************************


#ifndef _W95INF32_H_
#define _W95INF32_H_


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <windows.h>
//#include <shellapi.h>
//#include <winerror.h>
//#include <memory.h>
//#include <string.h>
//#include <cpldebug.h>
//#include <stdio.h>


//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
extern "C" {
    BOOL    WINAPI      w95thk_ThunkConnect32(LPSTR pszDll16, LPSTR pszDll32, HINSTANCE hInst, DWORD dwReason);
    BOOL    _stdcall    DllEntryPoint(HINSTANCE, DWORD, LPVOID );

    extern  VOID WINAPI GetSETUPXErrorText16( DWORD, LPSTR, DWORD );
    extern  WORD WINAPI CtlSetLddPath16(UINT, LPSTR);
    extern  WORD WINAPI GenInstall16(LPSTR, LPSTR, LPSTR, DWORD, DWORD);
//    extern  WORD WINAPI GenInstall16(LPSTR, LPSTR, LPSTR, DWORD);
    extern  BOOL WINAPI GenFormStrWithoutPlaceHolders16( LPSTR, LPSTR, LPSTR );

    VOID WINAPI         GetSETUPXErrorText32(DWORD, LPSTR, DWORD);
    WORD WINAPI         CtlSetLddPath32(UINT, LPSTR);
    WORD WINAPI         GenInstall32(LPSTR, LPSTR, LPSTR, DWORD, DWORD);
    BOOL WINAPI         GenFormStrWithoutPlaceHolders32( LPSTR, LPSTR, LPSTR );
}


#endif // _W95INF32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\global.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* WEXTRACT.H - Self-extracting/Self-installing stub.                      *
//*                                                                         *
//***************************************************************************

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

extern SESSION  g_Sess;                        // Session
extern BOOL     g_fMinimalUI;          // Minimal UI for NT3.5
extern HANDLE   g_hInst;
extern LPSTR    g_szLicense;
extern HWND     g_hwndExtractDlg;
extern DWORD    g_dwFileSizes[];
extern BOOL     g_fIsWin95;
extern FARPROC  g_lpfnOldMEditWndProc;
extern UINT     g_uInfRebootOn;
extern WORD     g_wOSVer;
extern DWORD    g_dwRebootCheck;
extern DWORD    g_dwExitCode;

extern CMDLINE_DATA g_CMD;
#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf32\w95thk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Tue Jan 28 11:38:37 1997

;Command Line: ..\..\..\..\dev\tools\binr\thunk.exe -NC _TEXT ..\w95thk.thk 

	TITLE	$..\w95thk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_w95thkTargetTable	;Flat address of target table in 16-bit module.

public FT_w95thkChecksum32
FT_w95thkChecksum32	dd	03469h


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public w95thk_ThunkData32	;This symbol must be exported.
w95thk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	03469h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_w95thk - offset w95thk_ThunkData32
	dd	offset FT_Prolog_w95thk - offset w95thk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public w95thk_ThunkConnect32@16
w95thk_ThunkConnect32@16:
	pop	edx
	push	offset w95thk_ThkData16
	push	offset w95thk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
w95thk_ThkData16 label byte
	db	"w95thk_ThunkData16",0


		


pfnQT_Thunk_w95thk	dd offset QT_Thunk_w95thk
pfnFT_Prolog_w95thk	dd offset FT_Prolog_w95thk
	.data
QT_Thunk_w95thk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_w95thk label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include w95thk.inc



;************************ START OF THUNK BODIES************************




;
public GetSETUPXErrorText16@12
GetSETUPXErrorText16@12:
	FAPILOG16	73
	mov	cl,3
; GetSETUPXErrorText16(16) = GetSETUPXErrorText16(32) {}
;
; dword ptr [ebp+8]:  dwError
; dword ptr [ebp+12]:  lpszErrorText
; dword ptr [ebp+16]:  cbErrorText
;
public IIGetSETUPXErrorText16@12
IIGetSETUPXErrorText16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwError: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbErrorText: dword->dword
	call	dword ptr [pfnQT_Thunk_w95thk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public CtlSetLddPath16@8
CtlSetLddPath16@8:
	FAPILOG16	53
	mov	cl,2
; CtlSetLddPath16(16) = CtlSetLddPath16(32) {}
;
; dword ptr [ebp+8]:  uiLDID
; dword ptr [ebp+12]:  lpszPath
;
public IICtlSetLddPath16@8
IICtlSetLddPath16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;uiLDID: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	dword ptr [pfnQT_Thunk_w95thk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	8





;
public GenInstall16@20
GenInstall16@20:
	FAPILOG16	36
	mov	cl,1
; GenInstall16(16) = GenInstall16(32) {}
;
; dword ptr [ebp+8]:  lpszInf
; dword ptr [ebp+12]:  lpszSection
; dword ptr [ebp+16]:  lpszDirectory
; dword ptr [ebp+20]:  dwQuietMode
; dword ptr [ebp+24]:  hwnd
;
public IIGenInstall16@20
IIGenInstall16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	push	dword ptr [ebp+20]	;dwQuietMode: dword->dword
	push	dword ptr [ebp+24]	;hwnd: dword->dword
	call	dword ptr [pfnQT_Thunk_w95thk]
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	20





;
public GenFormStrWithoutPlaceHolders16@12
GenFormStrWithoutPlaceHolders16@12:
	FAPILOG16	0
	mov	cl,0
; GenFormStrWithoutPlaceHolders16(16) = GenFormStrWithoutPlaceHolders16(32) {}
;
; dword ptr [ebp+8]:  lpszDst
; dword ptr [ebp+12]:  lpszSrc
; dword ptr [ebp+16]:  lpszInfFilename
;
public IIGenFormStrWithoutPlaceHolders16@12
IIGenFormStrWithoutPlaceHolders16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_w95thk]
	cwde
	call	SUnMapLS_IP_EBP_8
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] GenFormStrWithoutPlaceHolders16',0
	db	'[F] GenInstall16',0
	db	'[F] CtlSetLddPath16',0
	db	'[F] GetSETUPXErrorText16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef GenFormStrWithoutPlaceHolders16:far16
externDef GenInstall16:far16
externDef CtlSetLddPath16:far16
externDef GetSETUPXErrorText16:far16


FT_w95thkTargetTable label word
	dw	offset GenFormStrWithoutPlaceHolders16
	dw	   seg GenFormStrWithoutPlaceHolders16
	dw	offset GenInstall16
	dw	   seg GenInstall16
	dw	offset CtlSetLddPath16
	dw	   seg CtlSetLddPath16
	dw	offset GetSETUPXErrorText16
	dw	   seg GetSETUPXErrorText16




	.data

public w95thk_ThunkData16	;This symbol must be exported.
w95thk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	03469h	;Checksum
	dw	offset FT_w95thkTargetTable
	dw	seg    FT_w95thkTargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public w95thk_ThunkConnect16
w95thk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    w95thk_ThunkData16
	push	offset w95thk_ThunkData16
	push	seg    w95thk_ThkData32
	push	offset w95thk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
w95thk_ThkData32 label byte
	db	"w95thk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\w95inf32\w95inf32.c ===
//***************************************************************************
//*   Copyright (c) Microsoft Corporation 1995-1996. All rights reserved.   *
//***************************************************************************
//*                                                                         *
//* W95INF32.C - Win32 Based Cabinet File Self-extractor and installer.        *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "w95inf32.h"
#pragma hdrstop


//***************************************************************************
//*                                                                         *
//* NAME:       DllEntryPoint                                               *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the DLL.                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL _stdcall DllEntryPoint( HINSTANCE hInst, DWORD dwReason,
							 LPVOID dwReserved )
{
    if ( !( w95thk_ThunkConnect32( "W95INF16.DLL", "W95INF32.DLL", hInst, dwReason ) ) )
	{
        MessageBox( 0, "ThunkConnect32 Failure!!", "W95INF32.DLL", MB_OK );
        return( FALSE );
    }

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       CtlSetLDDPath                                               *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   lpszINFFilename: Filename containing DirIDs to define       *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
WORD WINAPI CtlSetLddPath32( UINT uiLDID, LPSTR lpszPath )
{
    return( CtlSetLddPath16( uiLDID, lpszPath ) );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GenInstall                                                  *
//*                                                                         *
//* SYNOPSIS:   This function will map the to main function	to do the       *
//*             installation.  This will thunk into 16 bit code to call     *
//*             GetInstall() in setupx.dll if running on Win95.  If running *
//*             on WinNT SUR, it will call a function to do all the         *
//*             setupapi.dll function calls needed to install IE.           *
//*                                                                         *
//* REQUIRES:   lpszInfFileName: String containing filename of INF file.    *
//*             lpszSection: String containing section of the INF to install*
//*             lpszDirectory: Directory of CABs (Temp Dir).                *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
WORD WINAPI GenInstall32( LPSTR lpszInfFilename, LPSTR lpszInstallSection, LPSTR lpszSourceDir, DWORD dwQuietMode, DWORD hWnd )
{
// BUGBUG: HWND is 32-bit, which is not good when partying in 16-bit land.
_asm { int 3 }
    return( GenInstall16( lpszInfFilename, lpszInstallSection, lpszSourceDir, dwQuietMode, NULL ) );
//    return( GenInstall16( lpszInfFilename, lpszInstallSection, lpszSourceDir, dwQuietMode ) );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetSetupXErrorText                                          *
//*                                                                         *
//* SYNOPSIS:   This function will map the to main function	to do the       *
//*             installation.  This will thunk into 16 bit code to call     *
//*             GetInstall() in setupx.dll if running on Win95.  If running *
//*             on WinNT SUR, it will call a function to do all the         *
//*             setupapi.dll function calls needed to install IE.           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
VOID WINAPI GetSETUPXErrorText32( DWORD dwError, LPSTR szErrorText, DWORD dwcbErrorText )
{
    GetSETUPXErrorText16( dwError, szErrorText, dwcbErrorText );
}


//***************************************************************************
//*                                                                         *
//* NAME:       GenFormStrWithoutPlaceHolders                               *
//*                                                                         *
//* SYNOPSIS:   This function will map the to main function	to do the       *
//*             installation.  This will thunk into 16 bit code to call     *
//*             GetInstall() in setupx.dll if running on Win95.  If running *
//*             on WinNT SUR, it will call a function to do all the         *
//*             setupapi.dll function calls needed to install IE.           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL: Error result, FALSE == ERROR                          *
//*                                                                         *
//***************************************************************************
BOOL WINAPI GenFormStrWithoutPlaceHolders32( LPSTR szDst, LPSTR szSrc, LPSTR szInfFilename )
{
    return( GenFormStrWithoutPlaceHolders16( szDst, szSrc, szInfFilename ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\pch.h ===
#include <windows.h>
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\resource.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* RESOURCE.H -                                                            *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* STRING RESOURCE IDS                                                     *
//***************************************************************************
#define IDS_SELECTDIR               1000
#define IDS_PROMPT                  1001

#define IDS_ERR_GET_DISKSPACE       1200
#define IDS_ERR_NO_RESOURCE         1201
#define IDS_ERR_USER_CANCEL         1202
#define IDS_ERR_OS_VERSION          1204
#define IDS_ERR_NO_MEMORY           1205
#define IDS_ERR_CREATE_THREAD       1208
#define IDS_ERR_INVALID_CABINET     1210
#define IDS_ERR_FILETABLE_FULL      1211
#define IDS_ERR_CHANGE_DIR          1212
#define IDS_ERR_NO_SPACE_BOTH       1213
#define IDS_ERR_INVALID_DIR         1214
#define IDS_ERR_EMPTY_DIR_FIELD     1215
#define IDS_ERR_UPDATE_DIR          1216
#define IDS_ERR_LOADFUNCS           1217
#define IDS_ERR_LOADDLL             1218
#define IDS_ERR_CREATE_PROCESS      1220
#define IDS_ERR_UNKNOWN_CLUSTER     1221
#define IDS_ERR_RESOURCEBAD         1222
#define IDS_ERR_NO_INF_INSTALLS     1223
#define IDS_ERR_LOAD_DLL            1224
#define IDS_ERR_GET_PROC_ADDR       1225
#define IDS_ERR_OS_UNSUPPORTED      1226
#define IDS_ERR_CREATE_DIR          1227
#define IDS_ERR_NO_SPACE_INST       1228
#define IDS_ERR_GET_WIN_DIR         1264
#define IDS_ERR_OPENPROCTK          1269
#define IDS_ERR_ADJTKPRIV           1270
#define IDS_ERR_EXITWINEX           1271
#define IDS_ERR_LOWSWAPSPACE        1272
#define IDS_ERR_GETVOLINFOR         1273
#define IDS_ERR_NO_SPACE_ERR        1274
#define IDS_ERR_DIALOGBOX           1275

// FDI Error Codes: Add WEX_FDI_BASE to the error returned by FDI to
// index into the table of strings for that error

#define IDS_ERR_FDI_BASE            1300
#define IDS_ERR_BADCMDLINE          1312
#define IDS_HELPMSG                 1313
#define IDS_RESTARTYESNO            1314
#define IDS_MULTIINST               1316
#define IDS_ERR_FILENOTEXIST        1317

#define IDS_NOTADMIN                1351
#define IDS_CREATE_DIR              1354
#define IDS_ERR_ALREADY_RUNNING     1355
#define IDS_ERR_TARGETOS            1356
#define IDS_ERR_FILEVER             1357

//***************************************************************************
//* DIALOG IDS                                                              *
//***************************************************************************
#define IDD_LICENSE                 2001
#define IDD_TEMPDIR                 2002
#define IDD_OVERWRITE               2003
#define IDD_EXTRACT                 2004
#define IDD_EXTRACT_MIN             2005
#define IDD_WARNING                 2006


//***************************************************************************
//* DIALOG CONTROL IDS                                                      *
//***************************************************************************
#define IDC_UNUSED                  -1
#define IDC_EDIT_LICENSE            2100
#define IDC_EDIT_TEMPDIR            2101
#define IDC_BUT_BROWSE              2102
#define IDC_FILENAME                2103
#define IDC_TEXT_FILENAME           2104
#define IDC_BUT_YESTOALL            2105
#define IDC_GENERIC1                2106
#define IDC_USER1                   2107
#define IDC_TEMPTEXT                2108
#define IDC_CONTINUE                2109
#define IDC_EXIT                    2110
#define IDC_WARN_TEXT               2111
#define IDC_EXTRACTINGFILE          2113
#define IDC_EXTRACT_WAIT            2114



//***************************************************************************
//* ICON/ANIMATION IDS                                                      *
//***************************************************************************
#define IDI_WEXICON                 3000
#define IDA_FILECOPY                3001


//***************************************************************************
//* USER-DEFINED MESSAGES                                                   *
//***************************************************************************
#define UM_EXTRACTDONE              4001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\addpath.c ===
#include <windows.h>

//***************************************************************************
//*                                                                         *
//* NAME:       AddPath                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
VOID AddPath(LPSTR szPath, LPCSTR szName )
{
    LPSTR szTmp;

	// Find end of the string
    szTmp = szPath + lstrlen(szPath);

	// If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
	*(szTmp++) = '\\';

	// Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpy( szTmp, szName );
}

// function will upated the given buffer to parent dir
//
BOOL GetParentDir( LPSTR szFolder )
{
    LPSTR lpTmp;
    BOOL  bRet = FALSE;

    // remove the trailing '\\'
    lpTmp = CharPrev( szFolder, (szFolder + lstrlen(szFolder)) );
    lpTmp = CharPrev( szFolder, lpTmp );

    while ( (lpTmp > szFolder) && (*lpTmp != '\\') )
    {
       lpTmp = CharPrev( szFolder, lpTmp );
    }

    if ( *lpTmp == '\\' )
    {
        if ( (lpTmp == szFolder) || (*CharPrev(szFolder, lpTmp)==':') )
            lpTmp = CharNext( lpTmp );
        *lpTmp = '\0';
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\wextract.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* WEXTRACT.C - Win32 Based Cabinet File Self-extractor and installer.     *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "wextract.h"
#include "sdsutils.h"
//***************************************************************************
//* GLOBAL VARIABLES                                                        *
//***************************************************************************
FAKEFILE g_FileTable[FILETABLESIZE];    // File Table
SESSION  g_Sess;                // Session
WORD     g_wOSVer;
BOOL     g_fOSSupportsFullUI = TRUE;    // Minimal UI for NT3.5
BOOL     g_fOSSupportsINFInstalls = TRUE; // TRUE if INF installs are allowed
                                          // on the target platform.
HANDLE   g_hInst;
LPSTR    g_szLicense;
HWND     g_hwndExtractDlg = NULL;
DWORD    g_dwFileSizes[MAX_NUMCLUSTERS+1];
FARPROC  g_lpfnOldMEditWndProc;
UINT     g_uInfRebootOn;
CMDLINE_DATA g_CMD;
DWORD    g_dwRebootCheck;
int      g_dwExitCode;
HANDLE   g_hCancelEvent = NULL;
HANDLE  g_hMutex = NULL;
char     g_szBrowsePath[MAX_PATH];

#define  CMD_REGSERV    "RegServer"
#define  COMPRESS_FACTOR    2
#define  SIZE_100MB     102400


int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();


    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

//***************************************************************************
//*                                                                         *
//* NAME:       WinMain                                                     *
//*                                                                         *
//* SYNOPSIS:   Main entry point for the program.                           *
//*                                                                         *
//* REQUIRES:   hInstance:                                                  *
//*             hPrevInstance:                                              *
//*             lpszCmdLine:                                                *
//*             nCmdShow:                                                   *
//*                                                                         *
//* RETURNS:    int:                                                        *
//*                                                                         *
//***************************************************************************
INT WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPTSTR lpszCmdLine, INT nCmdShow )
{
    
    BOOL fReturn = FALSE;
    
    // initailize to SUCCESS return
    // this value is updated inside DoMain() ..
    //
    g_dwExitCode = S_OK;
    if ( Init( hInstance, lpszCmdLine, nCmdShow ) )
    {
        fReturn = DoMain();
        CleanUp();
    }

    if ( fReturn )
    {
       // get reboot info
       if ( !(g_CMD.szRunonceDelDir[0]) && (g_Sess.dwReboot & REBOOT_YES)  )
       {
           MyRestartDialog( g_Sess.dwReboot );
       }
    }

    // BUGBUG: ParseCommandLine() seems to use exit() directly.
    // one other exit of this EXE will be at /? case in parsecmdline
    // so we do close there if not NULL.
    //
    if (g_hMutex)
        CloseHandle(g_hMutex);

    return g_dwExitCode;
}

//***************************************************************************
//*                                                                         *
//* NAME:       Init                                                        *
//*                                                                         *
//* SYNOPSIS:   Initialization for the program is done here.                *
//*                                                                         *
//* REQUIRES:   hInstance:                                                  *
//*             hPrevInstance:                                              *
//*             lpszCmdLine:                                                *
//*             nCmdShow:                                                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL Init( HINSTANCE hInstance, LPCTSTR lpszCmdLine, INT nCmdShow )
{
    DWORD   dwSize;
    PTARGETVERINFO pTargetVer = NULL;
    HRSRC   hRc;
    HGLOBAL hMemVer;

    g_hInst = hInstance;

    ZeroMemory( &g_Sess, sizeof(g_Sess) );
    ZeroMemory( &g_CMD, sizeof(g_CMD) );
    ZeroMemory( g_szBrowsePath, sizeof(g_szBrowsePath) );

    // Initialize the structure
    g_Sess.fAllCabinets = TRUE;

    // Get Application Title Name
    dwSize = GetResource( achResTitle, g_Sess.achTitle,
                          sizeof(g_Sess.achTitle) - 1 );

    if ( dwSize == 0 || dwSize > sizeof(g_Sess.achTitle) )  {
        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
        return FALSE;
    }

    g_hCancelEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    SetEvent( g_hCancelEvent );

    if ( !GetResource( achResExtractOpt, &(g_Sess.uExtractOpt), sizeof(g_Sess.uExtractOpt) ) )
    {
        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        return FALSE;
    }

    if ( ( g_Sess.uExtractOpt & EXTRACTOPT_INSTCHKPROMPT ) ||
         ( g_Sess.uExtractOpt & EXTRACTOPT_INSTCHKBLOCK ) )
    {
        char szCookie[MAX_PATH];

        if ( !GetResource( achResOneInstCheck, szCookie, sizeof(szCookie) ) )
        {
            ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
            return FALSE;
        }

        g_hMutex = CreateMutex(NULL, TRUE, szCookie );
        if ((g_hMutex != NULL) && (GetLastError() == ERROR_ALREADY_EXISTS))
        {
            if ( g_Sess.uExtractOpt & EXTRACTOPT_INSTCHKBLOCK )
            {
                ErrorMsg1Param( NULL, IDS_ERR_ALREADY_RUNNING, g_Sess.achTitle );
            }
            else if ( MsgBox1Param( NULL, IDS_MULTIINST, g_Sess.achTitle, MB_ICONQUESTION, MB_YESNO) == IDYES )
            {
                goto CONTINUE;
            }
            CloseHandle(g_hMutex);
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            return FALSE;
        }
    }

CONTINUE:
    g_uInfRebootOn = 0;

    if ( !ParseCmdLine(lpszCmdLine) )
    {
        ErrorMsg( NULL, IDS_ERR_BADCMDLINE );
        return FALSE;
    }

    // if this is runoncde called for cleanup only purpose, clenup and return
    if ( g_CMD.szRunonceDelDir[0] )
    {
        DeleteMyDir( g_CMD.szRunonceDelDir );
        return FALSE;
    }

    hRc = FindResource( hInstance, achResVerCheck, RT_RCDATA );

    if ( hRc )
    {
        hMemVer = LoadResource( hInstance, hRc );
        pTargetVer = (PTARGETVERINFO) hMemVer;
    }

    if ( g_fOSSupportsFullUI ) 
    {     
        // Allow Use of Progress Bar
        InitCommonControls();
    }

    // if user want to extract files only with /C command switch, no further check is needed!
    // If package is built for extract only, checks are needed!
    if ( g_CMD.fUserBlankCmd )
    {
        return TRUE;
    }

    if ( !CheckOSVersion( pTargetVer ) )  
    {
        return FALSE;
    }

    // Check for Administrator rights on NT
    // Don't do the check if this is quiet mode. This
    // will probably change when we add support in cabpack
    // to make this check or not

    if( ((g_wOSVer == _OSVER_WINNT3X) || (g_wOSVer == _OSVER_WINNT40) || (g_wOSVer == _OSVER_WINNT50)) &&
        ( g_Sess.uExtractOpt & EXTRACTOPT_CHKADMRIGHT ) && 
        !( g_CMD.wQuietMode & QUIETMODE_ALL ) )
    {
       if(!IsNTAdmin())
       {
          if(MyDialogBox(g_hInst, MAKEINTRESOURCE(IDD_WARNING),
                         NULL, WarningDlgProc, IDS_NOTADMIN, (INT_PTR)IDC_EXIT) != (INT_PTR)IDC_CONTINUE)
             return FALSE;
       }
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       DoMain                                                      *
//*                                                                         *
//* SYNOPSIS:   This is the main function that processes the package.       *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL DoMain( VOID )
{
    typedef BOOL (WINAPI *DECRYPTFILEAPTR)(LPCSTR, DWORD);
    HINSTANCE hAdvapi32;
    DECRYPTFILEAPTR DecryptFileAPtr = NULL;
    char szPath[MAX_PATH + 1];

    // If a prompt is defined, then pop it up in a message box
    // Display License file
    // if cmdline option: /Q or /Q:1 or /Q:A or /Q:U is used, batch mode is on.  No UI needed
    if ( !g_CMD.wQuietMode && !g_CMD.fUserBlankCmd )
    {
        if ( !GetUsersPermission() )
        {
            return FALSE;
        }

    }

    if ( !g_CMD.wQuietMode )
    {
        if ( !DisplayLicense() )
        {
            return FALSE;
        }

    }

    // get package extracting size and install size resource
    //
    if ( ! GetFileList() )  {
        return FALSE;
    }


    // Set Directory to Extract Into
    if ( ! GetTempDirectory() )  {
        //ErrorMsg( NULL, IDS_ERR_FIND_TEMP );
        return FALSE;
    }

    //
    // Try to turn off encryption on the directory (winseraid #23464.)
    //
    GetSystemDirectory(szPath, sizeof(szPath));
    AddPath(szPath, "advapi32.dll");
    hAdvapi32 = LoadLibrary(szPath);

    if ( hAdvapi32 ) {
        DecryptFileAPtr = (DECRYPTFILEAPTR)GetProcAddress( hAdvapi32, "DecryptFileA" );

        if ( DecryptFileAPtr )
            DecryptFileAPtr( g_Sess.achDestDir, 0 );
    }

    FreeLibrary(hAdvapi32);

    // check if windows dir has enough space for install,
    //
    if ( !g_CMD.fUserBlankCmd && !g_Sess.uExtractOnly && !CheckWinDir() )
    {
        return FALSE;
    }

    // Change to that directory

    if ( ! SetCurrentDirectory( g_Sess.achDestDir ) ) {
        ErrorMsg( NULL, IDS_ERR_CHANGE_DIR );
        g_dwExitCode = MyGetLastError();
        return FALSE;
    }

    // Extract the files
    if ( !g_CMD.fNoExtracting )
    {
        if ( ! ExtractFiles() )  {
            return FALSE;
        }
    }

    if ( (g_CMD.dwFlags & CMDL_DELAYREBOOT) ||
         (g_CMD.dwFlags & CMDL_DELAYPOSTCMD) )
        g_dwRebootCheck = 0;
    else
        g_dwRebootCheck = NeedRebootInit(g_wOSVer);
    
    // Install using the specified installation command
    // if not Command option, check if user op-out run command

    if ( !g_CMD.fUserBlankCmd && !g_Sess.uExtractOnly )
    {
        if ( ! RunInstallCommand() )  {
            return FALSE;
        }
    }

    // Popup a message that it has finished
    if ( !g_CMD.wQuietMode && !g_CMD.fUserBlankCmd  )
    {
        FinishMessage();
    }

    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CleanUp                                                     *
//*                                                                         *
//* SYNOPSIS:   Any last-minute application cleanup activities.             *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID CleanUp( VOID )
{
    // Delete extracted files - will do nothing if no files extracted
    DeleteExtractedFiles();
}


//***************************************************************************
//*                                                                         *
//* NAME:       MEditSubClassWnd                                            *
//*                                                                         *
//* SYNOPSIS:   Subclasses a multiline edit control so that a edit message  *
//*             to select the entire contents is ignored.                   *
//*                                                                         *
//* REQUIRES:   hWnd:           Handle of the edit window                   *
//*             fnNewProc:      New window handler proc                     *
//*             lpfnOldProc:    (returns) Old window handler proc           *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//* NOTE:       A selected edit message is not generated when the user      *
//*             selects text with the keyboard or mouse.                    *
//*                                                                         *
//***************************************************************************
VOID NEAR PASCAL MEditSubClassWnd( HWND hWnd, FARPROC fnNewProc )
{
    g_lpfnOldMEditWndProc = (FARPROC) GetWindowLongPtr( hWnd, GWLP_WNDPROC );

    SetWindowLongPtr( hWnd, GWLP_WNDPROC, (LONG_PTR) MakeProcInstance( fnNewProc,
                   (HINSTANCE) GetWindowWord( hWnd, GWW_HINSTANCE ) ) );
}


//***************************************************************************
//*                                                                         *
//* NAME:       MEditSubProc                                                *
//*                                                                         *
//* SYNOPSIS:   New multiline edit window procedure to ignore selection of  *
//*             all contents.                                               *
//*                                                                         *
//* REQUIRES:   hWnd:                                                       *
//*             msg:                                                        *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    LONG:                                                       *
//*                                                                         *
//* NOTE:       A selected edit message is not generated when the user      *
//*             selects text with the keyboard or mouse.                    *
//*                                                                         *
//***************************************************************************
LRESULT CALLBACK MEditSubProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    if ( msg == EM_SETSEL )  {
        if ( wParam == 0 && lParam == -2 ) {
            return 0;
        }
    }

    return CallWindowProc( (WNDPROC) g_lpfnOldMEditWndProc, hWnd, msg,
                           wParam, lParam );
}

//***************************************************************************
//*                                                                         *
//* NAME:       LicenseDlgProc                                              *
//*                                                                         *
//* SYNOPSIS:   Dialog Procedure for our license dialog window.             *
//*                                                                         *
//* REQUIRES:   hwndDlg:                                                    *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK LicenseDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam,
                                 LPARAM lParam )
{
    static LRESULT  RC;
    static BOOL  fSetSel = FALSE;
    static TCHAR achMessage[MSG_MAX];

    switch (uMsg)  {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************

            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetDlgItemText( hwndDlg, IDC_EDIT_LICENSE, g_szLicense );
            SetWindowText( hwndDlg, g_Sess.achTitle );
            SetForegroundWindow( hwndDlg );

            // Subclass the multiline edit control.

            MEditSubClassWnd( GetDlgItem( hwndDlg, IDC_EDIT_LICENSE ),
                              (FARPROC) MEditSubProc );

            return TRUE;


      //*********************************************************************
        case WM_PAINT:
      //*********************************************************************

            // For some reason, the EM_SETSEL message doesn't work when sent
            // from within WM_INITDIALOG.  That's why this hack of using a
            // flag and putting it in the WM_PAINT is used.

            if ( ! fSetSel ) {
                RC = SendDlgItemMessage( hwndDlg, IDC_EDIT_LICENSE, EM_SETSEL,
                                                 (WPARAM) -1, (LPARAM) 0 );
                fSetSel = TRUE;
            }

            return FALSE;


      //*********************************************************************
        case WM_CLOSE:
      //*********************************************************************

            EndDialog( hwndDlg, FALSE );
            return TRUE;


      //*********************************************************************
        case WM_COMMAND:
      //*********************************************************************

            if (wParam == IDYES)  {
                EndDialog( hwndDlg, TRUE );
            } else if (wParam == IDNO) {
                EndDialog( hwndDlg, FALSE );
            }

            return TRUE;
    }

    return FALSE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       IsFullPath                                                  *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
// return TRUE if given path is FULL pathname
//
BOOL IsFullPath( LPSTR pszPath )
{
    if ( (pszPath == NULL) || (lstrlen(pszPath) < 3) )
    {
        return FALSE;
    }

    if ( (pszPath[1] == ':') || ((pszPath[0] == '\\') && (pszPath[1]=='\\') ) )
        return TRUE;
    else
        return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       TempDirDlgProc                                              *
//*                                                                         *
//* SYNOPSIS:   Dialog Procedure for our temporary dir dialog window.       *
//*                                                                         *
//* REQUIRES:   hwndDlg:                                                    *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK TempDirDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam )
{
    static TCHAR  achDir[MAX_PATH];
    static TCHAR  achMsg[MSG_MAX];


    switch (uMsg)  {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************
        {

            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetWindowText( hwndDlg, g_Sess.achTitle );

            SendDlgItemMessage( hwndDlg, IDC_EDIT_TEMPDIR, EM_SETLIMITTEXT, (sizeof(g_Sess.achDestDir)-1), 0 );
//            if ( ( g_wOSVer == _OSVER_WINNT3X ) || ( g_wOSVer == _OSVER_WINNT40 ))
            if ( ( g_wOSVer == _OSVER_WINNT3X ) )
            {
                EnableWindow( GetDlgItem(  hwndDlg, IDC_BUT_BROWSE ), FALSE );
            }
            return TRUE;
        }

      //*********************************************************************
        case WM_CLOSE:
      //*********************************************************************

            EndDialog( hwndDlg, FALSE );
            return TRUE;

      //*********************************************************************
        case WM_COMMAND:
      //*********************************************************************

            switch ( wParam )  {

              //*************************************************************
                case IDOK:
              //*************************************************************
                {
                    DWORD dwAttribs = 0;
                    UINT  chkType;

                    if ( !GetDlgItemText( hwndDlg, IDC_EDIT_TEMPDIR, g_Sess.achDestDir,
                                sizeof(g_Sess.achDestDir)) || !IsFullPath(g_Sess.achDestDir) )
                    {
                        ErrorMsg( hwndDlg, IDS_ERR_EMPTY_DIR_FIELD );
                        return TRUE;
                    }

                    dwAttribs = GetFileAttributes( g_Sess.achDestDir );
                    if ( dwAttribs == 0xFFFFFFFF )
                    {
                        if ( MsgBox1Param( hwndDlg, IDS_CREATE_DIR, g_Sess.achDestDir, MB_ICONQUESTION, MB_YESNO )
                            == IDYES )
                        {
                            if ( ! CreateDirectory( g_Sess.achDestDir, NULL ) )
                            {
                                ErrorMsg1Param( hwndDlg, IDS_ERR_CREATE_DIR, g_Sess.achDestDir );
                                return TRUE;
                            }
                        }
                        else
                            return TRUE;
                    }
                    AddPath( g_Sess.achDestDir, "" );

                    if ( ! IsGoodTempDir( g_Sess.achDestDir ) )  {
                        ErrorMsg( hwndDlg, IDS_ERR_INVALID_DIR );
                        return TRUE;
                    }

                    if ( (g_Sess.achDestDir[0] == '\\') && (g_Sess.achDestDir[1] == '\\') )
                        chkType = CHK_REQDSK_NONE;
                    else
                        chkType = CHK_REQDSK_EXTRACT;

                    if ( ! IsEnoughSpace( g_Sess.achDestDir, chkType, MSG_REQDSK_ERROR ) )  {
                        return TRUE;
                    }

                    EndDialog( hwndDlg, TRUE );
                    return TRUE;
                }

              //*************************************************************
                case IDCANCEL:
              //*************************************************************

                    EndDialog( hwndDlg, FALSE );
                    g_dwExitCode = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    return TRUE;


              //*************************************************************
                case IDC_BUT_BROWSE:
              //*************************************************************

                    if ( LoadString( g_hInst, IDS_SELECTDIR, achMsg,
                                                      sizeof(achMsg) ) == 0 )
                    {
                        ErrorMsg( hwndDlg, IDS_ERR_NO_RESOURCE );
                        EndDialog( hwndDlg, FALSE );
                        return TRUE;
                    }

                    if ( ! BrowseForDir( hwndDlg, achMsg, achDir ) )  {
                        return TRUE;
                    }

                    if ( ! SetDlgItemText( hwndDlg, IDC_EDIT_TEMPDIR, achDir ) )
                    {
                        ErrorMsg( hwndDlg, IDS_ERR_UPDATE_DIR );
                        EndDialog( hwndDlg, FALSE );
                        return TRUE;
                    }

                    return TRUE;
            }

            return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       OverwriteDlgProc                                            *
//*                                                                         *
//* SYNOPSIS:   Dialog Procedure for asking if file should be overwritten.  *
//*                                                                         *
//* REQUIRES:   hwndDlg:                                                    *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK OverwriteDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam )
{
    switch (uMsg)  {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************

            CenterWindow( hwndDlg, GetDesktopWindow() );
            SetWindowText( hwndDlg, g_Sess.achTitle );
            SetDlgItemText( hwndDlg, IDC_TEXT_FILENAME,g_Sess.cszOverwriteFile );
            SetForegroundWindow( hwndDlg );
            return TRUE;


      //*********************************************************************
        case WM_CLOSE:
      //*********************************************************************

            EndDialog( hwndDlg, IDCANCEL );
            return TRUE;

      //*********************************************************************
        case WM_COMMAND:
      //*********************************************************************

            switch ( wParam )  {

              //*************************************************************
                case IDC_BUT_YESTOALL:
              //*************************************************************
                    g_Sess.fOverwrite = TRUE;

              //*************************************************************
                case IDYES:
                case IDNO:
              //*************************************************************

                    EndDialog( hwndDlg, wParam );
                    return TRUE;
            }
            return TRUE;
    }
    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ExtractDlgProc                                              *
//*                                                                         *
//* SYNOPSIS:   Dialog Procedure for our main dialog window.                *
//*                                                                         *
//* REQUIRES:   hwndDlg:                                                    *
//*             uMsg:                                                       *
//*             wParam:                                                     *
//*             lParam:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
INT_PTR CALLBACK ExtractDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam,
                                 LPARAM lParam )
{
    static DWORD  dwThreadID;
    static HANDLE hExtractThread;
    static TCHAR  achMessage[MSG_MAX];


    switch (uMsg)  {

      //*********************************************************************
        case WM_INITDIALOG:
      //*********************************************************************

            g_hwndExtractDlg = hwndDlg;

            CenterWindow( hwndDlg, GetDesktopWindow() );

            if ( g_fOSSupportsFullUI )  {
                Animate_Open( GetDlgItem( hwndDlg, IDC_USER1 ), IDA_FILECOPY );
                Animate_Play( GetDlgItem( hwndDlg, IDC_USER1 ), 0, -1, -1 );
            }

            SetWindowText( hwndDlg, g_Sess.achTitle );

            // Launch Extraction Thread
            hExtractThread = CreateThread( NULL, 0,
                                      (LPTHREAD_START_ROUTINE) ExtractThread,
                                      NULL, 0, &dwThreadID );

            if ( !hExtractThread )  {
                ErrorMsg( hwndDlg, IDS_ERR_CREATE_THREAD );
                EndDialog( hwndDlg, FALSE );
            }

            return TRUE;


      //*********************************************************************
        case UM_EXTRACTDONE:
      //*********************************************************************
            TerminateThread( hExtractThread, 0 );
            EndDialog( hwndDlg, (BOOL) wParam );
            return TRUE;


      //*********************************************************************
        case WM_CLOSE:
      //*********************************************************************

            g_Sess.fCanceled = TRUE;
            EndDialog( hwndDlg, FALSE );
            return TRUE;


      //*********************************************************************
        case WM_CHAR:
      //*********************************************************************
            if ( wParam == VK_ESCAPE )  {
                g_Sess.fCanceled = TRUE;
                EndDialog( hwndDlg, FALSE );
            }

            return TRUE;


      //*********************************************************************
        case WM_COMMAND:
      //*********************************************************************
            if ( wParam == IDCANCEL )  {
                int iMsgRet ;

                ResetEvent( g_hCancelEvent );

                iMsgRet = MsgBox1Param( g_hwndExtractDlg, IDS_ERR_USER_CANCEL, "",
                                        MB_ICONQUESTION, MB_YESNO ) ;

                // We will get back IDOK if we are in /q:1 mode.
                //
                if ( (iMsgRet == IDYES) || (iMsgRet == IDOK) )
                {
                    g_Sess.fCanceled = TRUE;
                    SetEvent( g_hCancelEvent );
                    WaitForObject( hExtractThread );
                    EndDialog( hwndDlg, FALSE );
                    return TRUE;
                }

                SetEvent( g_hCancelEvent );
            }
            return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       WaitForObject                                               *
//*                                                                         *
//* SYNOPSIS:   Waits for an object while still dispatching messages.       *
//*                                                                         *
//* REQUIRES:   Handle to the object.                                       *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID WaitForObject( HANDLE hObject )
{
    BOOL  fDone = FALSE;
    DWORD dwRet = 0;

    while ( ! fDone ) {
        dwRet = MsgWaitForMultipleObjects( 1, &hObject, FALSE, INFINITE, QS_ALLINPUT );

        if ( dwRet == WAIT_OBJECT_0 ) {
            fDone = TRUE;
        }
        else
        {
            MSG msg;

            // read all of the messages in this next loop
            // removing each message as we read it
            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) ) {
                // if it's a quit message we're out of here
                if ( msg.message == WM_QUIT ) {
                    fDone = TRUE;
                } else {
                    // otherwise dispatch it
                    DispatchMessage( &msg );
                } // end of PeekMessage while loop
            }
        }
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       CheckOSVersion                                              *
//*                                                                         *
//* SYNOPSIS:   Checks the OS version and sets some global variables.       *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
BOOL CheckOSVersion( PTARGETVERINFO ptargetVers )
{
    OSVERSIONINFO verinfo;        // Version Check
    UINT          uErrid = 0;
    PVERCHECK     pVerCheck;
    WORD          CurrBld;
    int           ifrAnswer[2], itoAnswer[2], i;
    char          szPath[MAX_PATH];

    // Operating System Version Check: For NT versions below 3.50 set flag to
    // prevent use of common controls (progress bar and AVI) not available.

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx( &verinfo ) == FALSE )
    {
        uErrid = IDS_ERR_OS_VERSION;
        goto EXIT;
    }

    switch( verinfo.dwPlatformId )
    {
        case VER_PLATFORM_WIN32_WINDOWS: // Win95
            // Accept for INF installs and Accept for animations
            g_wOSVer = _OSVER_WIN9X;
            g_fOSSupportsFullUI      = TRUE;
            g_fOSSupportsINFInstalls = TRUE;
            break;

        case VER_PLATFORM_WIN32_NT: // Win NT

            g_fOSSupportsFullUI      = TRUE;
            g_fOSSupportsINFInstalls = TRUE;
            g_wOSVer = _OSVER_WINNT40;

            if ( verinfo.dwMajorVersion <= 3 )
            {
                g_wOSVer = _OSVER_WINNT3X;
                if ( (verinfo.dwMajorVersion < 3) ||
                     ((verinfo.dwMajorVersion == 3) && (verinfo.dwMinorVersion < 51 )) )
                {
                    // Reject for INF installs and Reject for animations
                    g_fOSSupportsFullUI      = FALSE;
                    g_fOSSupportsINFInstalls = FALSE;
                }
            }
            else if ( verinfo.dwMajorVersion >= 5 )
                g_wOSVer = _OSVER_WINNT50;
            break;

        default:
            uErrid = IDS_ERR_OS_UNSUPPORTED;
            goto EXIT;
    }

    // check if the current OS/File versions
    //
    if ( !g_CMD.fNoVersionCheck && ptargetVers )
    {
        if ( g_wOSVer  == _OSVER_WIN9X )
            pVerCheck = &(ptargetVers->win9xVerCheck);
        else
            pVerCheck = &(ptargetVers->ntVerCheck);

        CurrBld = LOWORD( verinfo.dwBuildNumber );
        for ( i=0; i<2; i++ )
        {
            ifrAnswer[i] = CompareVersion( verinfo.dwMajorVersion, verinfo.dwMinorVersion, 
                                           pVerCheck->vr[i].frVer.dwMV, pVerCheck->vr[i].frVer.dwLV );
            itoAnswer[i] = CompareVersion( verinfo.dwMajorVersion, verinfo.dwMinorVersion, 
                                           pVerCheck->vr[i].toVer.dwMV, pVerCheck->vr[i].toVer.dwLV );
            if ( ifrAnswer[i] >= 0 && itoAnswer[i] <=0 )
            {
                if ( (ifrAnswer[i] == 0) && (itoAnswer[i] == 0) )
                {
                    if ( CurrBld < pVerCheck->vr[i].frVer.dwBd || CurrBld > pVerCheck->vr[i].toVer.dwBd )
                        goto RE_TRY;
                }
                else if ( ifrAnswer[i] == 0 )
                {
                    if ( CurrBld < pVerCheck->vr[i].frVer.dwBd )
                        goto RE_TRY;
                }
                else if ( itoAnswer[i] == 0 )
                {
                    if ( CurrBld > pVerCheck->vr[i].toVer.dwBd )
                        goto RE_TRY;
                }
                
                // if you are here, meaning you are fine with this Version range, no more check is needed
                break;

RE_TRY:
                if ( i == 0 )
                    continue;

                uErrid = IDS_ERR_TARGETOS;
                break;
            }
            else if ( i == 1 ) // not in any of the ranges
            {
                uErrid = IDS_ERR_TARGETOS;
                break;
            }
        }

        // if passed OS check, go on file check
        if ( uErrid == 0 )
        {
            if ( ptargetVers->dwNumFiles && !CheckFileVersion( ptargetVers, szPath, sizeof(szPath), &i ) )
                uErrid = IDS_ERR_FILEVER;
        }
    }

EXIT:
    if ( (uErrid == IDS_ERR_FILEVER) || (uErrid == IDS_ERR_TARGETOS) )
    {
        LPSTR pParam2 = NULL, pMsg;
        UINT  uButton, id;

        if ( uErrid == IDS_ERR_FILEVER )
        {
            pVerCheck = (PVERCHECK) (ptargetVers->szBuf + ptargetVers->dwFileOffs + i*sizeof(VERCHECK) );
            pParam2 = szPath;
        }

        pMsg = ptargetVers->szBuf + pVerCheck->dwstrOffs;
        uButton = GetMsgboxFlag( pVerCheck->dwFlag );

        if ( !(g_CMD.wQuietMode & QUIETMODE_ALL) && *pMsg )
        {                     
            MessageBeep( MB_OK );
            id = MessageBox( NULL, pMsg, g_Sess.achTitle, MB_ICONEXCLAMATION | uButton | 
                             ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));
            if ( uButton & MB_YESNO )
            {
                if ( id == IDYES )
                    uErrid = 0;
            }
            else if (uButton & MB_OKCANCEL )
            {
                if ( id == IDOK )
                    uErrid = 0;
            }                                        
        }
        else
        {
            MsgBox2Param( NULL, uErrid, g_Sess.achTitle, pParam2, MB_ICONEXCLAMATION, MB_OK);
        }
    }
    else if ( uErrid )
        ErrorMsg( NULL, uErrid );

    return ( uErrid? FALSE : TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       DisplayLicense                                              *
//*                                                                         *
//* SYNOPSIS:   Displays a license file and asks if user accepts it.        *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if user accepts, FALSE if an error     *
//*                             occurs or user rejects.                     *
//*                                                                         *
//***************************************************************************
BOOL DisplayLicense( VOID )
{
    DWORD    dwSize;
    INT_PTR  iDlgRC;


    dwSize = GetResource( achResLicense, NULL, 0 );

    g_szLicense = (LPSTR) LocalAlloc( LPTR, dwSize + 1 );
    if ( ! g_szLicense )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        g_dwExitCode = MyGetLastError();
        return FALSE;
    }

    if ( ! GetResource( achResLicense, g_szLicense, dwSize ) )  {
        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
        LocalFree( g_szLicense );
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        return FALSE;
    }

    if ( lstrcmp( g_szLicense, achResNone ) != 0 ) {
        iDlgRC = MyDialogBox( g_hInst,
                                   MAKEINTRESOURCE(IDD_LICENSE),
                                   NULL, LicenseDlgProc, (LPARAM)0, 0 );
        LocalFree( g_szLicense );

        if ( iDlgRC == 0 ) {
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            return FALSE;
        }
    } else {
        LocalFree( g_szLicense );
    }

    g_dwExitCode = S_OK;
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ExtractFiles                                                *
//*                                                                         *
//* SYNOPSIS:   Starts extraction of the files.                             *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if extraction OK, FALSE on error       *
//*                                                                         *
//***************************************************************************
BOOL ExtractFiles( VOID )
{
    UINT     wIndex;
    INT_PTR  iDlgRC;
    BOOL     extCodeThread = 0;

    // FDI does all its file I/O as callbacks up to functions provided by
    // this program.  Each file is identified by a "handle" similar to a
    // file handle.  In order to support the file that is actually a
    // resource in memory we implement our own file table.  The offsets
    // into this table are the handles that FDI uses.  The table itself
    // stores either a real file handle in the case of disk files or
    // information (pointer to memory block, current offset) for a memory
    // file.  The following initializes the table.

    for ( wIndex = 0; wIndex < FILETABLESIZE; wIndex++ ) {
        g_FileTable[wIndex].avail = TRUE;
    }

    if ( (g_CMD.wQuietMode & QUIETMODE_ALL) || (g_Sess.uExtractOpt & EXTRACTOPT_UI_NO) )
    {
        extCodeThread = ExtractThread();

        if ( extCodeThread == 0 )
        {
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_PROCESS_ABORTED);
            return FALSE;
        }
    }
    else
    {


        iDlgRC = MyDialogBox( g_hInst, ( g_fOSSupportsFullUI ) ?
                                   MAKEINTRESOURCE(IDD_EXTRACT) :
                                   MAKEINTRESOURCE(IDD_EXTRACT_MIN),
                                   NULL, ExtractDlgProc,
                                   (LPARAM)0, 0 );

        if ( iDlgRC == 0 )
        {
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_PROCESS_ABORTED);
            return FALSE;
        }
    }

    // Extract EXTRA files tagged on with updfile.exe
    if ( ! TravelUpdatedFiles( ProcessUpdatedFile_Write ) ) {
        // g_dwExitCode is set in TravelUpdatedFiles()
        return FALSE;
    }

    g_dwExitCode = S_OK;
    return TRUE;
}

//***************************************************************************
//*                                                                         *
//* NAME:       RunInstallCommand                                           *
//*                                                                         *
//* SYNOPSIS:   Executes the installation command or INF file.              *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if installation OK, FALSE on error     *
//*                                                                         *
//***************************************************************************
BOOL RunInstallCommand( VOID )
{
    //DWORD  dwExitCode;                  // Return Status from Setup Process
    UINT   bShowWindow;
    LPTSTR szCommand;
    TCHAR  szResCommand[MAX_PATH];
    DWORD  dwSize;
    STARTUPINFO         sti;
    BOOL   fInfCmd = FALSE;
    DOINFINSTALL  pfDoInfInstall = NULL;
    HANDLE        hSetupLibrary;
    ADVPACKARGS   AdvPackArgs;
    UINT   i = 0;
    BOOL   bFoundQCmd = FALSE, bRunOnceAdded = FALSE;

    g_dwExitCode = S_OK;

    // get reboot info
    if ( !g_CMD.fUserReboot )
    {
        // no command line, get from resource
        dwSize = GetResource( achResReboot, &g_Sess.dwReboot,sizeof(g_Sess.dwReboot) );
        if ( dwSize == 0 || dwSize > sizeof(g_Sess.dwReboot) )
        {
            ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
            return FALSE;
        }
    }

    for ( i = 0; i < 2; i += 1 )
    {
        fInfCmd = FALSE;        // Default to FALSE;

        memset( &sti, 0, sizeof(sti) );
        sti.cb = sizeof(STARTUPINFO);

        if ( !g_CMD.szUserCmd[0] )
        {
            dwSize = GetResource( achResShowWindow, &bShowWindow,
                                  sizeof(bShowWindow) );

            if ( dwSize == 0 || dwSize > sizeof(bShowWindow) )  {
                ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
                g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
                return FALSE;
            }

            if ( bShowWindow == bResShowHidden ) {
                sti.dwFlags     = STARTF_USESHOWWINDOW;
                sti.wShowWindow = SW_HIDE;
            } else if ( bShowWindow == bResShowMin ) {
                sti.dwFlags     = STARTF_USESHOWWINDOW;
                sti.wShowWindow = SW_MINIMIZE;
            } else if ( bShowWindow == bResShowMax ) {
                sti.dwFlags     = STARTF_USESHOWWINDOW;
                sti.wShowWindow = SW_MAXIMIZE;
            }

            if ( i == 0 )
            {
                // if user specify the quiet mode command, use it.  Otherwise, assume
                // quiet mode or not, they run the same command.
                //
                if ( g_CMD.wQuietMode )
                {
                    LPCSTR pResName;
        
                    if ( g_CMD.wQuietMode & QUIETMODE_ALL )
                        pResName = achResAdminQCmd;
                    else if ( g_CMD.wQuietMode & QUIETMODE_USER )
                        pResName = achResUserQCmd;
        
                    if ( !GetResource( pResName, szResCommand, sizeof(szResCommand) ) )
                    {
                        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
                        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
                        return FALSE;
                    }
        
                    if ( lstrcmpi(szResCommand, achResNone) )
                    {
                        bFoundQCmd = TRUE;
                    }
                }
                
                if ( !bFoundQCmd && !GetResource( achResRunProgram, szResCommand, sizeof(szResCommand) ) )
                {
                    ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
                    g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
                    return FALSE;
                }
            }
        }
        else
        {
            lstrcpy( szResCommand, g_CMD.szUserCmd );
        }

        if ( i == 1 )
        {
            // if there is PostInstallCommand to be run
            if ( ! GetResource( achResPostRunCmd, szResCommand, sizeof(szResCommand) ) )  {
                ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
                g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
                return FALSE;
            }

            if ( g_CMD.szUserCmd[0] || !lstrcmpi( szResCommand, achResNone ) )
            {
                break;
            }
        }

        if ( !AnalyzeCmd( szResCommand, &szCommand, &fInfCmd ) )
        {
            return FALSE;
        }

        // before we run the app, add runonce entry, if it return, we delete this entry
        if ( !bRunOnceAdded && (g_wOSVer != _OSVER_WINNT3X) && g_CMD.fCreateTemp && !fInfCmd ) {
            bRunOnceAdded = TRUE;
            AddRegRunOnce();
        }

        if ( fInfCmd && ! g_fOSSupportsINFInstalls ) {
            ErrorMsg( NULL, IDS_ERR_NO_INF_INSTALLS );
            LocalFree( szCommand );
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_PROCESS_ABORTED);
            return FALSE;
        }

        if ( fInfCmd && g_Sess.uExtractOpt & EXTRACTOPT_ADVDLL )
        {

            hSetupLibrary = MyLoadLibrary( ADVPACKDLL );

            if ( hSetupLibrary == NULL ) {
                ErrorMsg1Param( NULL, IDS_ERR_LOAD_DLL, ADVPACKDLL );
                LocalFree( szCommand );
                g_dwExitCode = MyGetLastError();
                return FALSE;
            }

            pfDoInfInstall = (DOINFINSTALL) GetProcAddress( hSetupLibrary, szDOINFINSTALL );

            if ( pfDoInfInstall == NULL ) {
                ErrorMsg1Param( NULL, IDS_ERR_GET_PROC_ADDR, szDOINFINSTALL );
                FreeLibrary( hSetupLibrary );
                LocalFree( szCommand );
                g_dwExitCode = MyGetLastError();
                return FALSE;
            }

            AdvPackArgs.hWnd = NULL;
            AdvPackArgs.lpszTitle = g_Sess.achTitle;
            AdvPackArgs.lpszInfFilename = szCommand;
            AdvPackArgs.lpszSourceDir = g_Sess.achDestDir;
            AdvPackArgs.lpszInstallSection = szResCommand;
            AdvPackArgs.wOSVer = g_wOSVer;
            AdvPackArgs.dwFlags = g_CMD.wQuietMode;
            if ( g_CMD.fNoGrpConv )
            {
                AdvPackArgs.dwFlags |= ADVFLAGS_NGCONV;
            }

            if ( g_Sess.uExtractOpt & EXTRACTOPT_COMPRESSED )
            {
                AdvPackArgs.dwFlags |= ADVFLAGS_COMPRESSED;
            }

            if ( g_Sess.uExtractOpt & EXTRACTOPT_UPDHLPDLLS )
            {
                AdvPackArgs.dwFlags |= ADVFLAGS_UPDHLPDLLS;
            }

            if ( g_CMD.dwFlags & CMDL_DELAYREBOOT )
            {
                AdvPackArgs.dwFlags |= ADVFLAGS_DELAYREBOOT;
            }

            if ( g_CMD.dwFlags & CMDL_DELAYPOSTCMD )
            {
                AdvPackArgs.dwFlags |= ADVFLAGS_DELAYPOSTCMD;
            }

            AdvPackArgs.dwPackInstSize = g_Sess.cbPackInstSize;

            if ( FAILED(g_dwExitCode = pfDoInfInstall(&AdvPackArgs)) ) {
                FreeLibrary( hSetupLibrary );
                LocalFree( szCommand );
                return FALSE;
            }

            FreeLibrary( hSetupLibrary );
        }
        else
        {
            if ( !RunApps( szCommand, &sti ) )
            {
                LocalFree( szCommand );
                return FALSE;
            }
        }

        LocalFree( szCommand );
    } // end for

    // convert the RunOnce entry added by AddRegRunOnce to use ADVPACK instead
    // of wextract if g_bConvertRunOnce is TRUE
    if (g_bConvertRunOnce)
        ConvertRegRunOnce();

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       RunApps                                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL RunApps( LPSTR lpCommand, STARTUPINFO *lpsti )
{
    DWORD dwExitCode;
    PROCESS_INFORMATION pi;             // Setup Process Launch
    BOOL  bRet = TRUE;
    TCHAR  achMessage[MAX_STRING];
    
    if ( !lpCommand )
    {
        return FALSE;
    }

    memset( &pi, 0, sizeof(pi) );
    if ( CreateProcess( NULL, lpCommand, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, lpsti, &pi ) )
    {
        WaitForSingleObject( pi.hProcess, INFINITE );
        GetExitCodeProcess( pi.hProcess, &dwExitCode );

        // check if this return code is cabpack aware
        // if so, use it as reboot code
        if ( !g_CMD.fUserReboot && (g_Sess.dwReboot & REBOOT_YES) &&
             !(g_Sess.dwReboot & REBOOT_ALWAYS) && ((dwExitCode & 0xFF000000) == RC_WEXTRACT_AWARE) )
        {
            g_Sess.dwReboot = dwExitCode;
        }

        // store app return code to system standard return code if necessary
        // g_dwExitCode is set in this function, make sure it is not re-set afterward
        //
        savAppExitCode( dwExitCode );

        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );

        if ( g_Sess.uExtractOpt & EXTRACTOPT_CMDSDEPENDED )
        {
            if ( FAILED( dwExitCode ) )
                bRet = FALSE;
        }
    }
    else
    {
        g_dwExitCode = MyGetLastError();        
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                       achMessage, sizeof(achMessage), NULL );
        ErrorMsg2Param( NULL, IDS_ERR_CREATE_PROCESS, lpCommand, achMessage );
        bRet = FALSE;
    }

    return bRet;
}

// convert app return code to sys return code
//
void savAppExitCode( DWORD dwAppRet )
{
    if ( g_Sess.uExtractOpt & EXTRACTOPT_PASSINSTRETALWAYS )
    {
        g_dwExitCode = dwAppRet;
    }
    else
    {
        // called from AdvINFInstall
        if ( (CheckReboot() == EWX_REBOOT) || 
             ( ((dwAppRet & 0xFF000000) == RC_WEXTRACT_AWARE) && (dwAppRet & REBOOT_YES)) )
        {
            g_dwExitCode = ERROR_SUCCESS_REBOOT_REQUIRED;
        }
        else if ( g_Sess.uExtractOpt & EXTRACTOPT_PASSINSTRET )
        {
            // if author specified, relay back whatever EXE returns
            //
            g_dwExitCode = dwAppRet;
        }
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       FinishMessage                                               *
//*                                                                         *
//* SYNOPSIS:   Displays the final message to the user when everything      *
//*             was successfull.                                            *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID FinishMessage( VOID )
{
    LPSTR    szFinishMsg;
    DWORD    dwSize;


    dwSize = GetResource( achResFinishMsg, NULL, 0 );

    szFinishMsg = (LPSTR) LocalAlloc( LPTR, dwSize + 1 );
    if ( ! szFinishMsg )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        return;
    }

    if ( ! GetResource( achResFinishMsg, szFinishMsg, dwSize ) )
    {
        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
        LocalFree( szFinishMsg );
        return;
    }

    if ( lstrcmp( szFinishMsg, achResNone ) != 0 )  {
        MsgBox1Param( NULL, IDS_PROMPT, szFinishMsg,
                      MB_ICONINFORMATION, MB_OK );
    }

    LocalFree( szFinishMsg );
}

int CALLBACK BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch(uMsg) {
    case BFFM_INITIALIZED:
        // lpData is the path string
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
        break;
    }
    return 0;
}

//***************************************************************************
//*                                                                         *
//* NAME:       BrowseForDir                                                *
//*                                                                         *
//* SYNOPSIS:   Let user browse for a directory on their system or network. *
//*                                                                         *
//* REQUIRES:   hwndParent:                                                 *
//*             szTitle:                                                    *
//*             szResult:                                                   *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//* NOTES:      It would be really cool to set the status line of the       *
//*             browse window to display "Yes, there's enough space", or    *
//*             "no there is not".                                          *
//*                                                                         *
//***************************************************************************
BOOL BrowseForDir( HWND hwndParent, LPCTSTR szTitle, LPTSTR szResult )
{
    BROWSEINFO   bi;
    LPITEMIDLIST pidl;
    HINSTANCE    hShell32Lib;
    SHFREE       pfSHFree;
    SHGETPATHFROMIDLIST        pfSHGetPathFromIDList;
    SHBROWSEFORFOLDER          pfSHBrowseForFolder;
    LPSTR        lpTmp;


    ASSERT( szResult );

    // Load the Shell 32 Library to get the SHBrowseForFolder() features

    if ( ( hShell32Lib = LoadLibrary( achShell32Lib ) ) != NULL )  {

    if ( ( !( pfSHBrowseForFolder = (SHBROWSEFORFOLDER)
                      GetProcAddress( hShell32Lib, achSHBrowseForFolder ) ) )
             || ( ! ( pfSHFree = (SHFREE) GetProcAddress( hShell32Lib,
                      MAKEINTRESOURCE(SHFREE_ORDINAL) ) ) )
             || ( ! ( pfSHGetPathFromIDList = (SHGETPATHFROMIDLIST)
                      GetProcAddress( hShell32Lib, achSHGetPathFromIDList ) ) ) )
        {
            FreeLibrary( hShell32Lib );
            ErrorMsg( hwndParent, IDS_ERR_LOADFUNCS );
            return FALSE;
        }
    } else  {
        ErrorMsg( hwndParent, IDS_ERR_LOADDLL );
        return FALSE;
    }

    if ( !g_szBrowsePath[0] )
    {
        GetTempPath( sizeof(g_szBrowsePath), g_szBrowsePath );
        // The following api does not like to have trailing '\\'
        lpTmp = CharPrev( g_szBrowsePath, g_szBrowsePath + lstrlen(g_szBrowsePath) );
        if ( (*lpTmp == '\\') && ( *CharPrev( g_szBrowsePath, lpTmp ) != ':' ) )
            *lpTmp = '\0';
    }

    szResult[0]       = 0;
    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = szTitle;
    bi.ulFlags        = BIF_RETURNONLYFSDIRS;
    bi.lpfn           = BrowseCallback;
    bi.lParam         = (LPARAM)g_szBrowsePath;

    pidl              = pfSHBrowseForFolder( &bi );


    if ( pidl )  {
        pfSHGetPathFromIDList( pidl, g_szBrowsePath );
        if ( g_szBrowsePath[0] )  {
            lstrcpy( szResult, g_szBrowsePath );
        }
        pfSHFree( pidl );
    }

    FreeLibrary( hShell32Lib );

    if ( szResult[0] != 0 ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       CenterWindow                                                *
//*                                                                         *
//* SYNOPSIS:   Center one window within another.                           *
//*                                                                         *
//* REQUIRES:   hwndChild:                                                  *
//*             hWndParent:                                                 *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE otherwise         *
//*                                                                         *
//***************************************************************************
BOOL CenterWindow( HWND hwndChild, HWND hwndParent )
{
    RECT rChild;
    RECT rParent;
    int  wChild;
    int  hChild;
    int  wParent;
    int  hParent;
    int  wScreen;
    int  hScreen;
    int  xNew;
    int  yNew;
    HDC  hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return( SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER));
}


//***************************************************************************
//*                                                                         *
//* NAME:       MsgBox2Param                                                *
//*                                                                         *
//* SYNOPSIS:   Displays a message box with the specified string ID using   *
//*             2 string parameters.                                        *
//*                                                                         *
//* REQUIRES:   hWnd:           Parent window                               *
//*             nMsgID:         String resource ID                          *
//*             szParam1:       Parameter 1 (or NULL)                       *
//*             szParam2:       Parameter 2 (or NULL)                       *
//*             uIcon:          Icon to display (or 0)                      *
//*             uButtons:       Buttons to display                          *
//*                                                                         *
//* RETURNS:    INT:            ID of button pressed                        *
//*                                                                         *
//* NOTES:      Macros are provided for displaying 1 parameter or 0         *
//*             parameter message boxes.  Also see ErrorMsg() macros.       *
//*                                                                         *
//***************************************************************************
INT CALLBACK MsgBox2Param( HWND hWnd, UINT nMsgID, LPCSTR szParam1, LPCSTR szParam2,
                  UINT uIcon, UINT uButtons )
{
    TCHAR achMsgBuf[STRING_BUF_LEN];
    LPSTR szMessage;
    INT   nReturn;
    CHAR  achErr[] = "LoadString() Error.  Could not load string resource.";

    // BUGBUG:  the correct quiet mode return code should be a caller's param since the caller
    // knows what expected its own case.
    //
    if ( !(g_CMD.wQuietMode & QUIETMODE_ALL) )
    {
        // BUGBUG:  This section could be replaced by using FormatMessage
        //
        LoadSz( nMsgID, achMsgBuf, sizeof(achMsgBuf) );

        if ( achMsgBuf[0] == 0 )
        {
            MessageBox( hWnd, achErr, g_Sess.achTitle, MB_ICONSTOP |
                        MB_OK | MB_SETFOREGROUND | 
                        ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));
            return -1;
        }

        if ( szParam2 != NULL )  
        {
            szMessage = (LPSTR) LocalAlloc( LPTR,   lstrlen( achMsgBuf )
                                                  + lstrlen( szParam1 )
                                                  + lstrlen( szParam2 ) + 100 );
            if ( ! szMessage )  
            {
                return -1;
            }

            wsprintf( szMessage, achMsgBuf, szParam1, szParam2 );
        } 
        else if ( szParam1 != NULL )  
        {
            szMessage = (LPSTR) LocalAlloc( LPTR,   lstrlen( achMsgBuf )
                                                  + lstrlen( szParam1 ) + 100 );
            if ( ! szMessage )  {
                return -1;
            }

            wsprintf( szMessage, achMsgBuf, szParam1 );
        } 
        else  
        {
            szMessage = (LPSTR) LocalAlloc( LPTR, lstrlen( achMsgBuf ) + 1 );
            if ( ! szMessage )  
                return -1;            

            lstrcpy( szMessage, achMsgBuf );
        }

        MessageBeep( uIcon );

        nReturn = MessageBox( hWnd, szMessage, g_Sess.achTitle, uIcon |
                              uButtons | MB_APPLMODAL | MB_SETFOREGROUND  | 
                              ((RunningOnWin95BiDiLoc() && IsBiDiLocalizedBinary(g_hInst,RT_VERSION, MAKEINTRESOURCE(VS_VERSION_INFO))) ? (MB_RIGHT | MB_RTLREADING) : 0));

        LocalFree( szMessage );

        return nReturn;
    }
    else
        return IDOK;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetResource                                                 *
//*                                                                         *
//* SYNOPSIS:   Loads a specified resource into a buffer.                   *
//*                                                                         *
//* REQUIRES:   szRes:          Name of resource to load                    *
//*             lpBuffer:       Buffer to put the resource in               *
//*             dwMaxSize:      Size of buffer (not including terminating   *
//*                             NULL char, if it's needed.                  *
//*                                                                         *
//* RETURNS:    DWORD:          0 if it fails, otherwise size of resource   *
//*                                                                         *
//* NOTES:      If the value returned is greater than dwMaxSize, then       *
//*             it means the buffer wasn't big enough and the calling       *
//*             function should allocate memory the size of the return val. *
//*                                                                         *
//***************************************************************************

DWORD GetResource( LPCSTR szRes, VOID *lpBuffer, DWORD dwMaxSize )
{
    HANDLE hRes;
    DWORD  dwSize;

    // BUGBUG: called should not depend on this size being exact resource size.
    // Resources could be padded!
    //
    dwSize = SizeofResource( NULL, FindResource( NULL, szRes, RT_RCDATA ) );

    if ( dwSize > dwMaxSize || lpBuffer == NULL )  {
        return dwSize;
    }

    if ( dwSize == 0 )  {
        return 0;
    }

    hRes = LockResource( LoadResource( NULL,
                         FindResource( NULL, szRes, RT_RCDATA ) ) );

    if ( hRes == NULL )  {
        return 0;
    }

    memcpy( lpBuffer, hRes, dwSize );

    FreeResource( hRes );

    return ( dwSize );
}


//***************************************************************************
//*                                                                         *
//* NAME:       LoadSz                                                      *
//*                                                                         *
//* SYNOPSIS:   Loads specified string resource into buffer.                *
//*                                                                         *
//* REQUIRES:   idString:                                                   *
//*             lpszBuf:                                                    *
//*             cbBuf:                                                      *
//*                                                                         *
//* RETURNS:    LPSTR:      Pointer to the passed-in buffer.                *
//*                                                                         *
//* NOTES:      If this function fails (most likely due to low memory), the *
//*             returned buffer will have a leading NULL so it is generally *
//*             safe to use this without checking for failure.              *
//*                                                                         *
//***************************************************************************
LPSTR LoadSz( UINT idString, LPSTR lpszBuf, UINT cbBuf )
{
    ASSERT( lpszBuf );

    // Clear the buffer and load the string
    if ( lpszBuf ) {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }

    return lpszBuf;
}


//***************************************************************************
//*                                                                         *
//* NAME:       CatDirAndFile                                               *
//*                                                                         *
//* SYNOPSIS:   Concatenate a directory with a filename.                    *
//*                                                                         *
//* REQUIRES:   pszResult:                                                  *
//*             wSize:                                                      *
//*             pszDir:                                                     *
//*             pszFile:                                                    *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL CatDirAndFile( LPTSTR pszResult, int wSize, LPCTSTR pszDir,
                    LPCTSTR pszFile )
{
    ASSERT( lstrlen(pszDir) );
    ASSERT( lstrlen(pszFile) );

    if ( lstrlen(pszDir) + lstrlen(pszFile) + 1 >= wSize ) {
        return FALSE;
    }

    lstrcpy( pszResult, pszDir );
    if (    pszResult[lstrlen(pszResult)-1] != '\\'
         && pszResult[lstrlen(pszResult)-1] != '/' )
    {
        pszResult[lstrlen(pszResult)] = '\\';
        pszResult[lstrlen(pszResult)+1] = '\0';
    }

    lstrcat( pszResult, pszFile );

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       FileExists                                                  *
//*                                                                         *
//* SYNOPSIS:   Checks if a file exists.                                    *
//*                                                                         *
//* REQUIRES:   pszFilename                                                 *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if it exists, FALSE otherwise              *
//*                                                                         *
//***************************************************************************
#if 0
BOOL FileExists( LPCTSTR pszFilename )
{
    HANDLE hFile;

    ASSERT( pszFilename );

    hFile = CreateFile( pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL, NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }

    CloseHandle( hFile );

    return( TRUE );
}
#endif

//***************************************************************************
//*                                                                         *
//* NAME:       CheckOverwrite                                              *
//*                                                                         *
//* SYNOPSIS:   Check for file existence and do overwrite processing.       *
//*                                                                         *
//* REQUIRES:   pszFile:        File to check                               *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if file can be overwritten.            *
//*                             FALSE if it can not be overwritten.         *
//*                                                                         *
//* NOTE:       Should ask Yes/No/Yes-To-All instead of current Yes/No      *
//*                                                                         *
//***************************************************************************
BOOL CheckOverwrite( LPCTSTR cpszFile )
{
    BOOL fRc = TRUE;

    ASSERT( cpszFile );

    // If File doesn't already exist no overwrite handling
    if ( ! FileExists( cpszFile )  )  {
        return TRUE;
    }

    // Prompt if we're supposed to
    if ( !g_Sess.fOverwrite && !(g_CMD.wQuietMode & QUIETMODE_ALL)  )
    {

        g_Sess.cszOverwriteFile = cpszFile;

        switch ( MyDialogBox( g_hInst, MAKEINTRESOURCE(IDD_OVERWRITE),
                            g_hwndExtractDlg, OverwriteDlgProc, (LPARAM)0, (INT_PTR)IDYES ) )
        {
            case (INT_PTR)IDYES:
                fRc = TRUE;
                break;

            case (INT_PTR)IDC_BUT_YESTOALL:
                g_Sess.fOverwrite = TRUE;
                fRc = TRUE;
                break;

            case (INT_PTR)IDNO:
                fRc = FALSE;
                break;
        }
   }

   if ( fRc )
        SetFileAttributes( cpszFile, FILE_ATTRIBUTE_NORMAL );

    return fRc;
}


//***************************************************************************
//*                                                                         *
//* NAME:       AddFile                                                     *
//*                                                                         *
//* SYNOPSIS:   Add a file to the list of files we have extracted.          *
//*                                                                         *
//* REQUIRES:   pszName:        Filename to add                             *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//* NOTE:       Singly linked list - items added at front                   *
//*                                                                         *
//***************************************************************************
BOOL AddFile( LPCTSTR pszName )
{
    PFNAME NewName;

    ASSERT( pszName );

    // Allocate Node
    NewName = (PFNAME) LocalAlloc( LPTR, sizeof(FNAME) );
    if ( ! NewName )  {
        ErrorMsg( g_hwndExtractDlg, IDS_ERR_NO_MEMORY );
        return( FALSE );
    }

    // Allocate String Space
    NewName->pszFilename = (LPTSTR) LocalAlloc( LPTR, lstrlen(pszName) + 1 );
    if ( ! NewName->pszFilename )  {
        ErrorMsg( g_hwndExtractDlg, IDS_ERR_NO_MEMORY );
        LocalFree( NewName );
        return( FALSE );
    }

    // Copy Filename
    lstrcpy( NewName->pszFilename, pszName );

    // Link into list
    NewName->pNextName = g_Sess.pExtractedFiles;
    g_Sess.pExtractedFiles = NewName;

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       Win32Open                                                   *
//*                                                                         *
//* SYNOPSIS:   Translate a C-Runtime _open() call into appropriate Win32   *
//*             CreateFile()                                                *
//*                                                                         *
//* REQUIRES:   pszName:        Filename to add                             *
//*                                                                         *
//* RETURNS:    HANDLE:         Handle to file on success.                  *
//*                             INVALID_HANDLE_VALUE on error.              *
//*                                                                         *
//* NOTE:       BUGBUG: Doesn't fully implement C-Runtime _open()           *
//*             BUGBUG: capability but it currently supports all callbacks  *
//*             BUGBUG: that FDI will give us                               *
//*                                                                         *
//***************************************************************************
HANDLE Win32Open( LPCTSTR pszFile, int oflag, int pmode )
{
    HANDLE  FileHandle;
    BOOL    fExists     = FALSE;
    DWORD   fAccess;
    DWORD   fCreate;


    ASSERT( pszFile );

    // BUGBUG: No Append Mode Support
    if (oflag & _O_APPEND)
        return( INVALID_HANDLE_VALUE );

    // Set Read-Write Access
    if ((oflag & _O_RDWR) || (oflag & _O_WRONLY))
        fAccess = GENERIC_WRITE;
    else
        fAccess = GENERIC_READ;

     // Set Create Flags
    if (oflag & _O_CREAT)  {
        if (oflag & _O_EXCL)
            fCreate = CREATE_NEW;
        else if (oflag & _O_TRUNC)
            fCreate = CREATE_ALWAYS;
        else
            fCreate = OPEN_ALWAYS;
    } else {
        if (oflag & _O_TRUNC)
            fCreate = TRUNCATE_EXISTING;
        else
            fCreate = OPEN_EXISTING;
    }

    FileHandle = CreateFile( pszFile, fAccess, 0, NULL, fCreate,
                            FILE_ATTRIBUTE_NORMAL, NULL );

    if ((FileHandle == INVALID_HANDLE_VALUE) && (fCreate != OPEN_EXISTING)) {
        MakeDirectory( pszFile );
        FileHandle = CreateFile( pszFile, fAccess, 0, NULL, fCreate,
                                FILE_ATTRIBUTE_NORMAL, NULL );
    }
    return( FileHandle );
}

//***************************************************************************
//*                                                                         *
//* NAME:       MakeDirectory                                               *
//*                                                                         *
//* SYNOPSIS:   Make sure the directories along the given pathname exist.   *
//*                                                                         *
//* REQUIRES:   pszFile:        Name of the file being created.             *
//*                                                                         *
//* RETURNS:    nothing                                                     *
//*                                                                         *
//***************************************************************************

VOID MakeDirectory( LPCTSTR pszPath )
{
    LPTSTR pchChopper;
    int cExempt;

    if (pszPath[0] != '\0')
    {
        cExempt = 0;

        if ((pszPath[1] == ':') && (pszPath[2] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 3);   /* skip past "C:\" */
        }
        else if ((pszPath[0] == '\\') && (pszPath[1] == '\\'))
        {
            pchChopper = (LPTSTR) (pszPath + 2);   /* skip past "\\" */

            cExempt = 2;                /* machine & share names exempt */
        }
        else
        {
            pchChopper = (LPTSTR) (pszPath + 1);   /* skip past potential "\" */
        }

        while (*pchChopper != '\0')
        {
            if ((*pchChopper == '\\') && (*(pchChopper - 1) != ':'))
            {
                if (cExempt != 0)
                {
                    cExempt--;
                }
                else
                {
                    *pchChopper = '\0';

                    CreateDirectory(pszPath,NULL);

                    *pchChopper = '\\';
                }
            }

            pchChopper = CharNext(pchChopper);
        }
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       openfunc                                                    *
//*                                                                         *
//* SYNOPSIS:   Open File Callback from FDI                                 *
//*                                                                         *
//* REQUIRES:   pszFile:                                                    *
//*             oflag:                                                      *
//*             pmode:                                                      *
//*                                                                         *
//* RETURNS:    int:            Filehandle (index into file table)          *
//*                             -1 on failure                               *
//*                                                                         *
//***************************************************************************

//
// Sundown - 11/02/98 - if we are defining ourself as DIAMONDAPI, we need to respect 
//                      the API types - polymorphic or not...

INT_PTR FAR DIAMONDAPI openfunc( char FAR *pszFile, int oflag, int pmode )
{
    INT_PTR rc;
    int     i;

    ASSERT( pszFile );

    // Find Available File Handle in Fake File Table
    for ( i = 0; i < FILETABLESIZE; i++ ) {
        if ( g_FileTable[i].avail == TRUE ) {
            break;
        }
    }

    // Running out of file handles should never happen

    if ( i == FILETABLESIZE )  {
        ErrorMsg( g_hwndExtractDlg, IDS_ERR_FILETABLE_FULL );
        return( -1 );
    }

    // BUGBUG Spill File Support for Quantum?

    if ((*pszFile == '*') && (*(pszFile+1) != 'M'))  {
        // Spill File Support for Quantum Not Supported
        ASSERT( TRUE );
    }

    // If Opening the Cabinet set up memory fake file

    if ( ( lstrcmp( pszFile, achMemCab ) ) == 0 )  {
        if (    ( oflag & _O_CREAT  )
             || ( oflag & _O_APPEND )
             || ( oflag & _O_WRONLY )
             || ( oflag & _O_RDWR   ) )
        {
            return(-1);
        }
        g_FileTable[i].avail         = FALSE;
        g_FileTable[i].ftype         = MEMORY_FILE;
        g_FileTable[i].mfile.start   = (void *) g_Sess.lpCabinet;
        g_FileTable[i].mfile.length  = g_Sess.cbCabSize;
        g_FileTable[i].mfile.current = 0;
        rc = i;
    } else  {            // Else its a normal file - Open it
        g_FileTable[i].hf = Win32Open(pszFile, oflag, pmode );
        if ( g_FileTable[i].hf != INVALID_HANDLE_VALUE )  {
            g_FileTable[i].avail = FALSE;
            g_FileTable[i].ftype = NORMAL_FILE;
            rc = i;
        } else {
            rc = -1;
        }
    }

    return( rc );
}


//***************************************************************************
//*                                                                         *
//* NAME:       readfunc                                                    *
//*                                                                         *
//* SYNOPSIS:   FDI read() callback                                         *
//*                                                                         *
//* REQUIRES:   hf:                                                         *
//*             pv:                                                         *
//*             cb:                                                         *
//*                                                                         *
//* RETURNS:    UINT:                                                       *
//*                                                                         *
//***************************************************************************
UINT FAR DIAMONDAPI readfunc( INT_PTR hf, void FAR *pv, UINT cb )
{
    int     rc;
    int     cbRead;


    ASSERT( hf < (INT_PTR)FILETABLESIZE );
    ASSERT( g_FileTable[hf].avail == FALSE );
    ASSERT( pv );

    // Normal File:  Call Read
    // Memory File:  Compute read amount so as to not read
    //               past eof.  Copy into requesters buffer
    switch ( g_FileTable[hf].ftype )  {

        case NORMAL_FILE:
            if ( ! ReadFile( g_FileTable[hf].hf, pv, cb, (DWORD *) &cb, NULL ) )
            {
                rc = -1;
            } else  {
                rc = cb;
            }
            break;


        case MEMORY_FILE:
            // XXX BAD CAST - SIGN PROBLEM FIX THIS!
            cbRead = __min( cb, (UINT) g_FileTable[hf].mfile.length
                                           - g_FileTable[hf].mfile.current );

            ASSERT( cbRead >= 0 );

            CopyMemory( pv, (const void *) ((char *) g_FileTable[hf].mfile.start + g_FileTable[hf].mfile.current),
                    cbRead );

            g_FileTable[hf].mfile.current += cbRead;
            rc = cbRead;
            break;
    }

    return( rc );
}


//***************************************************************************
//*                                                                         *
//* NAME:       writefunc                                                   *
//*                                                                         *
//* SYNOPSIS:   FDI write() callback                                        *
//*                                                                         *
//* REQUIRES:   hf:                                                         *
//*             pv:                                                         *
//*             cb:                                                         *
//*                                                                         *
//* RETURNS:    UINT:                                                       *
//*                                                                         *
//***************************************************************************
UINT FAR DIAMONDAPI writefunc( INT_PTR hf, void FAR *pv, UINT cb )
{
    int rc;

    ASSERT( hf < (INT_PTR)FILETABLESIZE );
    ASSERT( g_FileTable[hf].avail == FALSE );
    ASSERT( pv );
    ASSERT( g_FileTable[hf].ftype != MEMORY_FILE );

    WaitForObject( g_hCancelEvent );

    // If Cancel has been pressed, let's fake a write error so that diamond
    // will immediately send us a close for the file currently being written
    // to so that we can kill our process.
    //
    if ( g_Sess.fCanceled ) {
        return (UINT) -1 ;
    }

    if ( ! WriteFile( g_FileTable[hf].hf, pv, cb, (DWORD *) &cb, NULL ) )  {
        rc = -1;
    } else  {
        rc = cb;
    }

    // Progress Bar: Keep count of bytes written and adjust progbar

    if ( rc != -1 )  {
        // Update count of bytes written
        g_Sess.cbWritten += rc;

        // Update the Progress Bar
        if ( g_fOSSupportsFullUI && g_hwndExtractDlg  )  {
            SendDlgItemMessage( g_hwndExtractDlg, IDC_GENERIC1, PBM_SETPOS,
                                (WPARAM) g_Sess.cbWritten * 100 /
                                g_Sess.cbTotal, (LPARAM) 0 );
        }
    }

    return( rc );
}


//***************************************************************************
//*                                                                         *
//* NAME:       closefunc                                                   *
//*                                                                         *
//* SYNOPSIS:   FDI close file callback                                     *
//*                                                                         *
//* REQUIRES:   hf:                                                         *
//*                                                                         *
//* RETURNS:    int:                                                        *
//*                                                                         *
//***************************************************************************
int FAR DIAMONDAPI closefunc( INT_PTR hf )
{
    int rc;

    ASSERT(hf < (INT_PTR)FILETABLESIZE);
    ASSERT(g_FileTable[hf].avail == FALSE);

    // If memory file reset values else close the file

    if ( g_FileTable[hf].ftype == MEMORY_FILE )  {
        g_FileTable[hf].avail           = TRUE;
        g_FileTable[hf].mfile.start   = 0;
        g_FileTable[hf].mfile.length  = 0;
        g_FileTable[hf].mfile.current = 0;
        rc = 0;
    } else  {
        if ( CloseHandle( g_FileTable[hf].hf ) )  {
            rc = 0;
            g_FileTable[hf].avail = TRUE;
        } else  {
            rc = -1;
        }
    }

    return( rc );
}


//***************************************************************************
//*                                                                         *
//* NAME:       seekfunc                                                    *
//*                                                                         *
//* SYNOPSIS:   FDI Seek callback                                           *
//*                                                                         *
//* REQUIRES:   hf:                                                         *
//*             dist:                                                       *
//*             seektype:                                                   *
//*                                                                         *
//* RETURNS:    long:                                                       *
//*                                                                         *
//***************************************************************************
long FAR DIAMONDAPI seekfunc( INT_PTR hf, long dist, int seektype )
{
    long    rc;
    DWORD   W32seektype;

    ASSERT(hf < (INT_PTR)FILETABLESIZE);
    ASSERT(g_FileTable[hf].avail == FALSE);

    // If memory file just change indexes else call SetFilePointer()

    if (g_FileTable[hf].ftype == MEMORY_FILE)  {
        switch (seektype)  {
            case SEEK_SET:
                g_FileTable[hf].mfile.current = dist;
                break;
            case SEEK_CUR:
                g_FileTable[hf].mfile.current += dist;
                break;
            case SEEK_END:
                g_FileTable[hf].mfile.current = g_FileTable[hf].mfile.length + dist; // XXX is a -1 necessary
                break;
            default:
                return(-1);
        }
        rc = g_FileTable[hf].mfile.current;
    } else {
        // Must be Win32 File so translate to Win32 Seek type and seek
        switch (seektype) {
            case SEEK_SET:
                W32seektype = FILE_BEGIN;
                break;
            case SEEK_CUR:
                W32seektype = FILE_CURRENT;
                break;
            case SEEK_END:
                W32seektype = FILE_END;
                break;
        }
        rc = SetFilePointer(g_FileTable[hf].hf, dist, NULL, W32seektype);
        if (rc == 0xffffffff)
            rc = -1;
    }

    return( rc );
}


//***************************************************************************
//*                                                                         *
//* NAME:       AdjustFileTime                                              *
//*                                                                         *
//* SYNOPSIS:   Change the time info for a file                             *
//*                                                                         *
//* REQUIRES:   hf:                                                         *
//*             date:                                                       *
//*             time:                                                       *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL AdjustFileTime( INT_PTR hf, USHORT date, USHORT time )
{
    FILETIME    ft;
    FILETIME    ftUTC;


    ASSERT( hf < (INT_PTR)FILETABLESIZE );
    ASSERT( g_FileTable[hf].avail == FALSE );
    ASSERT( g_FileTable[hf].ftype != MEMORY_FILE );

    // THIS IS A DUPLICATE OF THE ASSERTION!!!!!!
    // Memory File?  -- Bogus
    if ( g_FileTable[hf].ftype == MEMORY_FILE ) {
        return( FALSE );
    }

    if ( ! DosDateTimeToFileTime( date, time, &ft ) ) {
        return( FALSE );
    }

    if ( ! LocalFileTimeToFileTime( &ft, &ftUTC ) ) {
        return( FALSE );
    }

    if ( ! SetFileTime( g_FileTable[hf].hf, &ftUTC, &ftUTC, &ftUTC ) ) {
        return( FALSE );
    }

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       Attr32FromAttrFAT                                           *
//*                                                                         *
//* SYNOPSIS:   Translate FAT attributes to Win32 Attributes                *
//*                                                                         *
//* REQUIRES:   attrMSDOS:                                                  *
//*                                                                         *
//* RETURNS:    DWORD:                                                      *
//*                                                                         *
//***************************************************************************
DWORD Attr32FromAttrFAT( WORD attrMSDOS )
{
    //** Quick out for normal file special case
    if (attrMSDOS == _A_NORMAL) {
        return FILE_ATTRIBUTE_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!

    return attrMSDOS & (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}


//***************************************************************************
//*                                                                         *
//* NAME:       allocfunc                                                   *
//*                                                                         *
//* SYNOPSIS:   FDI Memory Allocation Callback                              *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
FNALLOC( allocfunc )
{
    void *pv;

    pv = (void *) GlobalAlloc( GMEM_FIXED, cb );
    return( pv );
}


//***************************************************************************
//*                                                                         *
//* NAME:       freefunc                                                    *
//*                                                                         *
//* SYNOPSIS:   FDI Memory Deallocation Callback                            *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
FNFREE( freefunc )
{
    ASSERT(pv);

    GlobalFree( pv );
}


//***************************************************************************
//*                                                                         *
//* NAME:       doGetNextCab                                                *
//*                                                                         *
//* SYNOPSIS:   Get Next Cabinet in chain                                   *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    -1                                                          *
//*                                                                         *
//* NOTES:      BUGBUG: CLEANUP: STUB THIS OUT                              *
//*             BUGBUG: STUBBED OUT IN WEXTRACT - CHAINED CABINETS NOT      *
//*             BUGBUG:   SUPPORTED                                         *
//*                                                                         *
//***************************************************************************
FNFDINOTIFY( doGetNextCab )
{
    return( -1 );
}


//***************************************************************************
//*                                                                         *
//* NAME:       fdiNotifyExtract                                            *
//*                                                                         *
//* SYNOPSIS:   Principle FDI Callback in file extraction                   *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
FNFDINOTIFY( fdiNotifyExtract )
{
    INT_PTR  fh;
    TCHAR    achFile[MAX_PATH];        // Current File

    // User Hit Cancel Button?  Cleanup.
    if ( g_Sess.fCanceled ) {

       if ( fdint == fdintCLOSE_FILE_INFO )  {
           // close the file (as below)
           closefunc( pfdin->hf );
        }

        return( -1 );
    }

    switch ( fdint )  {

        //*******************************************************************
        case fdintCABINET_INFO:
            return UpdateCabinetInfo( pfdin );


        //*******************************************************************
        case fdintCOPY_FILE:
            if ( g_hwndExtractDlg )
                SetDlgItemText( g_hwndExtractDlg, IDC_FILENAME, pfdin->psz1 );

            if ( ! CatDirAndFile( achFile, sizeof( achFile ),
                                  g_Sess.achDestDir, pfdin->psz1 ) )
            {
                return -1;                  // Abort with error
            }

            if ( ! CheckOverwrite( achFile ) )  {
                return (INT_PTR)NULL;
            }

            fh = openfunc( achFile, _O_BINARY | _O_TRUNC | _O_RDWR |
                           _O_CREAT, _S_IREAD | _S_IWRITE );

            if ( fh == -1 ) {
                return( -1 );
            }

            if ( ! AddFile( achFile ) ) {
                return( -1 );
            }

            g_Sess.cFiles++;

            return(fh);


        //*******************************************************************
        case fdintCLOSE_FILE_INFO:
            if ( ! CatDirAndFile( achFile, sizeof(achFile),
                                  g_Sess.achDestDir, pfdin->psz1 ) )
            {
                return -1;                  // Abort with error;
            }

            if ( ! AdjustFileTime( pfdin->hf, pfdin->date, pfdin->time ) )  {
                return( -1 );
            }

            closefunc( pfdin->hf );

            if ( ! SetFileAttributes( achFile,
                                      Attr32FromAttrFAT( pfdin->attribs ) ) )
            {
                return( -1 );
            }

            return(TRUE);


        //*******************************************************************
        case fdintPARTIAL_FILE:
            return( 0 );


        //*******************************************************************
        case fdintNEXT_CABINET:
            return doGetNextCab( fdint, pfdin );


        //*******************************************************************
        default:
            break;
    }
    return( 0 );
}


//***************************************************************************
//*                                                                         *
//* NAME:       UpdateCabinetInfo                                           *
//*                                                                         *
//* SYNOPSIS:   update history of cabinets seen                             *
//*                                                                         *
//* REQUIRES:   pfdin:          FDI info structure                          *
//*                                                                         *
//* RETURNS:    0                                                           *
//*                                                                         *
//***************************************************************************
int UpdateCabinetInfo( PFDINOTIFICATION pfdin )
{
    //** Save older cabinet info
    g_Sess.acab[0] = g_Sess.acab[1];

    //** Save new cabinet info
    lstrcpy( g_Sess.acab[1].achCabPath    , pfdin->psz3 );
    lstrcpy( g_Sess.acab[1].achCabFilename, pfdin->psz1 );
    lstrcpy( g_Sess.acab[1].achDiskName   , pfdin->psz2 );
    g_Sess.acab[1].setID    = pfdin->setID;
    g_Sess.acab[1].iCabinet = pfdin->iCabinet;

    return 0;
}


//***************************************************************************
//*                                                                         *
//* NAME:       VerifyCabinet                                               *
//*                                                                         *
//* SYNOPSIS:   Check that cabinet is properly formed                       *
//*                                                                         *
//* REQUIRES:   HGLOBAL:                                                    *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if Cabinet OK, FALSE if Cabinet invalid*
//*                                                                         *
//***************************************************************************
BOOL VerifyCabinet( VOID *lpCabinet )
{
    HFDI            hfdi;
    ERF             erf;
    FDICABINETINFO  cabinfo;
    INT_PTR         fh;

    /* zero structure before use. FDIIsCabinet not fill in hasnext/hasprev on NT */
    memset( &cabinfo, 0, sizeof(cabinfo) );

    hfdi = FDICreate(allocfunc,freefunc,openfunc,readfunc,writefunc,closefunc,seekfunc,cpu80386,&erf);
    if ( hfdi == NULL )  {
        // BUGBUG Error Handling?
        return( FALSE );
    }

    fh = openfunc( achMemCab, _O_BINARY | _O_RDONLY, _S_IREAD | _S_IWRITE );
    if (fh == -1)  {
        return( FALSE );
    }

    if (FDIIsCabinet(hfdi, fh, &cabinfo ) == FALSE)  {
        return( FALSE );
    }

    if (cabinfo.cbCabinet != (long) g_Sess.cbCabSize)  {
        return( FALSE );
    }

    if (cabinfo.hasprev || cabinfo.hasnext)  {
        return( FALSE );
    }

    if (closefunc( fh ) == -1)   {
        return( FALSE );
    }

    if (FDIDestroy(hfdi) == FALSE)  {
        return( FALSE );
    }

    return( TRUE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       ExtractThread                                               *
//*                                                                         *
//* SYNOPSIS:   Main Body of Extract Thread                                 *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:                                                       *
//*                                                                         *
//***************************************************************************
BOOL ExtractThread( VOID )
{
    HFDI        hfdi;
    BOOL        fExtractResult = TRUE;

    if ( ! GetCabinet() )  {
        return FALSE;
    }

    if ( g_hwndExtractDlg )
    {
        ShowWindow( GetDlgItem( g_hwndExtractDlg, IDC_EXTRACT_WAIT ), SW_HIDE ) ;
        ShowWindow( GetDlgItem( g_hwndExtractDlg, IDC_EXTRACTINGFILE ), SW_SHOW ) ;
    }

    if ( ! VerifyCabinet( g_Sess.lpCabinet ) )  {
        ErrorMsg( g_hwndExtractDlg, IDS_ERR_INVALID_CABINET );
        fExtractResult = FALSE;
        goto done;
    }

    // Extract the files

    hfdi = FDICreate( allocfunc, freefunc, openfunc, readfunc, writefunc,
                      closefunc, seekfunc, cpu80386, &(g_Sess.erf) );

    if ( hfdi == NULL )  {
        ErrorMsg( g_hwndExtractDlg, g_Sess.erf.erfOper + IDS_ERR_FDI_BASE );
        fExtractResult = FALSE;
        goto done;
    }

    fExtractResult = FDICopy( hfdi, achMemCab, "", 0, fdiNotifyExtract,
                              NULL, (void *) &g_Sess );


    if ( fExtractResult == FALSE )  {
        goto done;
    }

    if ( FDIDestroy( hfdi ) == FALSE )  {
        ErrorMsg( g_hwndExtractDlg, g_Sess.erf.erfOper + IDS_ERR_FDI_BASE );
        fExtractResult = FALSE;
        goto done;
    }

  done:
    if ( g_Sess.lpCabinet )
    {
        FreeResource( g_Sess.lpCabinet );
        g_Sess.lpCabinet = NULL;
    }

    if ( (fExtractResult == FALSE) && !g_Sess.fCanceled )
    {
        ErrorMsg( NULL, IDS_ERR_LOWSWAPSPACE );
    }

    if ( !(g_CMD.wQuietMode & QUIETMODE_ALL) && !(g_Sess.uExtractOpt & EXTRACTOPT_UI_NO)  )
    {
        SendMessage( g_hwndExtractDlg, UM_EXTRACTDONE, (WPARAM) fExtractResult, (LPARAM) 0 );

    }
    return fExtractResult;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetCabinet                                                  *
//*                                                                         *
//* SYNOPSIS:   Gets the cabinet from a resource.                           *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if successfull, FALSE otherwise            *
//*                                                                         *
//***************************************************************************
BOOL GetCabinet( VOID )
{
    g_Sess.cbCabSize = GetResource( achResCabinet, NULL, 0 );

    //g_Sess.lpCabinet = (VOID *) LocalAlloc( LPTR, g_Sess.cbCabSize + 1 );
    //if ( ! g_Sess.lpCabinet )  {
    //    ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
    //    return FALSE;
    //}

    g_Sess.lpCabinet = LockResource( LoadResource( NULL,
                         FindResource( NULL, achResCabinet, RT_RCDATA ) ) );

    if ( g_Sess.lpCabinet == NULL )  {
        return 0;
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetFileList                                                 *
//*                                                                         *
//* SYNOPSIS:   Gets the file list from resources.                          *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if successfull, FALSE otherwise            *
//*                                                                         *
//***************************************************************************
BOOL GetFileList( VOID )
{
    DWORD  dwSize;

    dwSize = GetResource( achResSize, g_dwFileSizes, sizeof(g_dwFileSizes) );

    if ( dwSize != sizeof(g_dwFileSizes) ) {
         ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
         g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
         return FALSE;
    }

    // total files sizes not considering the cluster size
    g_Sess.cbTotal = g_dwFileSizes[MAX_NUMCLUSTERS];

    if ( g_Sess.cbTotal == 0 )
    {
        ErrorMsg( NULL, IDS_ERR_RESOURCEBAD );
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        return FALSE;
    }

    // get install disk space requirement
    // if there is no such resource, the value shoud be remain 0 as default
    GetResource( achResPackInstSpace, &(g_Sess.cbPackInstSize), sizeof(g_Sess.cbPackInstSize) );

    // Get disk space required for Extra files (files tagged onto package with Updfile.exe)
    if ( ! TravelUpdatedFiles( ProcessUpdatedFile_Size ) ) {
        ErrorMsg( NULL, IDS_ERR_RESOURCEBAD );
        // g_dwExitCode is set in TravelUpdatedFiles()
        return FALSE;
    }

    return TRUE;

}


//***************************************************************************
//*                                                                         *
//* NAME:       GetUsersPermission                                          *
//*                                                                         *
//* SYNOPSIS:   Ask user if (s)he wants to perform this extraction before   *
//*             proceeding.   If no IDS_UD_PROMPT string resource exists    *
//*             then we skip the prompting and just extract.                *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE to proceed with extraction             *
//*                             FALSE to abort extraction                   *
//*                                                                         *
//***************************************************************************
BOOL GetUsersPermission( VOID )
{
    int   ret;
    LPSTR szPrompt;
    DWORD dwSize;


    // Get Prompt String
    dwSize = GetResource( achResUPrompt, NULL, 0 );

    szPrompt = (LPSTR) LocalAlloc( LPTR, dwSize + 1 );
    if ( ! szPrompt )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        g_dwExitCode = MyGetLastError();
        return FALSE;
    }

    if ( ! GetResource( achResUPrompt, szPrompt, dwSize ) )  {
        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
        LocalFree( szPrompt );
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        return FALSE;
    }

    if ( lstrcmp( szPrompt, achResNone ) == 0 )  {
        LocalFree( szPrompt );
        return( TRUE );
    }

    ret = MsgBox1Param( NULL, IDS_PROMPT, szPrompt,
                        MB_ICONQUESTION, MB_YESNO );

    LocalFree( szPrompt );

    if ( ret == IDYES )  {
        g_dwExitCode = S_OK;
        return( TRUE );
    } else  {
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        return( FALSE );
    }
}


//***************************************************************************
//*                                                                         *
//* NAME:       DeleteExtractedFiles                                        *
//*                                                                         *
//* SYNOPSIS:   Delete the files that were extracted into the temporary     *
//*             directory.                                                  *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    Nothing                                                     *
//*                                                                         *
//***************************************************************************
VOID DeleteExtractedFiles( VOID )
{
    PFNAME rover;
    PFNAME temp;


    rover = g_Sess.pExtractedFiles;
    temp = rover;

    while ( rover != NULL )  {
        if ( !g_CMD.fUserBlankCmd && !g_Sess.uExtractOnly )
        {
            SetFileAttributes( rover->pszFilename, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( rover->pszFilename );
        }
        rover = rover->pNextName;

        LocalFree( temp->pszFilename );
        LocalFree( temp );

        temp = rover;
    }

    if ( g_CMD.fCreateTemp && (!g_CMD.fUserBlankCmd) && (!g_Sess.uExtractOnly) )
    {
        char szFolder[MAX_PATH];

        lstrcpy( szFolder, g_Sess.achDestDir );
        if (g_Sess.uExtractOpt & EXTRACTOPT_PLATFORM_DIR)
        {
            // potential we have create 2 level temp dir temp\platform
            // if they are empty clean up
            GetParentDir( szFolder );
        }

        SetCurrentDirectory( ".." );
        DeleteMyDir( szFolder );
    }

    // delete the runonce reg entry if it is there since we do the cleanup ourself
    if ( (g_wOSVer != _OSVER_WINNT3X) && (g_CMD.fCreateTemp) )
        CleanRegRunOnce();

    g_CMD.fCreateTemp = FALSE;
}

BOOL GetNewTempDir( LPCSTR lpParent, LPSTR lpFullPath )
{
    int     index = 0;
    char    szPath[MAX_PATH];
    BOOL    bFound = FALSE;

    while ( index < 400 )
    {
        wsprintf(szPath, TEMP_TEMPLATE, index++);
        lstrcpy( lpFullPath, lpParent );
        AddPath( lpFullPath, szPath );

        // if there is an empty dir, remove it first
        RemoveDirectory( lpFullPath );

        if ( GetFileAttributes( lpFullPath ) == -1 )
        {
            if ( CreateDirectory( lpFullPath , NULL ) )
            {
                g_CMD.fCreateTemp = TRUE;
                bFound = TRUE;
            }
            else
                bFound = FALSE;
            break;
        }
    }

    if ( !bFound && GetTempFileName( lpParent, TEMPPREFIX, 0, lpFullPath )  )
    {
        bFound = TRUE;
        DeleteFile( lpFullPath );  // if file doesn't exist, fail it.  who cares.
        CreateDirectory( lpFullPath, NULL );
    }
    return bFound;
}

//***************************************************************************
//*                                                                         *
//* NAME:       CreateAndValidateSubdir                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
BOOL CreateAndValidateSubdir( LPCTSTR lpPath, BOOL bCreateUnique, UINT chkType )
{
    TCHAR szTemp[MAX_PATH];

    if ( bCreateUnique )
    {
        if ( GetNewTempDir( lpPath, szTemp ) )
        {
            lstrcpy( g_Sess.achDestDir, szTemp );
            if (g_Sess.uExtractOpt & EXTRACTOPT_PLATFORM_DIR) {
                SYSTEM_INFO SystemInfo;
                GetSystemInfo( &SystemInfo );
                switch (SystemInfo.wProcessorArchitecture) {
                    case PROCESSOR_ARCHITECTURE_INTEL:
                        AddPath( g_Sess.achDestDir, "i386" );
                        break;

                    case PROCESSOR_ARCHITECTURE_MIPS:
                        AddPath( g_Sess.achDestDir, "mips" );
                        break;

                    case PROCESSOR_ARCHITECTURE_ALPHA:
                        AddPath( g_Sess.achDestDir, "alpha" );
                        break;

                    case PROCESSOR_ARCHITECTURE_PPC:
                        AddPath( g_Sess.achDestDir, "ppc" );
                        break;
                }
            }
            AddPath( g_Sess.achDestDir, "" );
        }
        else
            return FALSE;
    }
    else
        lstrcpy( g_Sess.achDestDir, lpPath );

    // if not there, create dir
    if ( !IsGoodTempDir( g_Sess.achDestDir ) )
    {
        if ( CreateDirectory( g_Sess.achDestDir, NULL ) )
        {
            g_CMD.fCreateTemp = TRUE;
        }
        else
        {
            g_dwExitCode = MyGetLastError();
            return FALSE;
        }
    }

    if ( IsEnoughSpace(g_Sess.achDestDir, chkType, MSG_REQDSK_NONE ) )
    {
        g_dwExitCode = S_OK;
        return TRUE;
    }

    if ( g_CMD.fCreateTemp )
    {
        g_CMD.fCreateTemp = FALSE;
        RemoveDirectory(g_Sess.achDestDir);
    }

    return FALSE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       GetTempDirectory                                            *
//*                                                                         *
//* SYNOPSIS:   Get a temporary Directory for extraction that is on a drive *
//*             with enough disk space available.                           *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if successful, FALSE on error          *
//*                                                                         *
//***************************************************************************
BOOL GetTempDirectory( VOID )
{
    INT_PTR  iDlgRC;
    int   len;
    DWORD dwSize;
    LPTSTR szCommand;
    char  szRoot[MAX_PATH];

    // Try system TEMP path first, if that isn't any good then
    // we'll try the EXE directory.   If both fail, ask user
    // to pick a temp dir.

    // check if user has empty command
    dwSize = GetResource( achResRunProgram, NULL, 0 );

    szCommand = (LPSTR) LocalAlloc( LPTR, dwSize + 1 );
    if ( ! szCommand )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        g_dwExitCode = MyGetLastError();
        return FALSE;
    }

    if ( ! GetResource( achResRunProgram, szCommand, dwSize ) )
    {
        ErrorMsg( NULL, IDS_ERR_NO_RESOURCE );
        LocalFree( szCommand );
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
        return FALSE;
    }

    if ( !lstrcmp( szCommand, achResNone ) )
    {
        // only extract files, no run command
        g_Sess.uExtractOnly = 1;
    }

    LocalFree( szCommand );

    // if user use /T: option, we wont try any others
    if ( g_CMD.szUserTempDir[0] )
    {
        UINT chkType;

        if ( (g_CMD.szUserTempDir[0] == '\\') && (g_CMD.szUserTempDir[1] == '\\') )
            chkType = CHK_REQDSK_NONE;
        else
            chkType = CHK_REQDSK_EXTRACT;

        if ( CreateAndValidateSubdir( g_CMD.szUserTempDir, FALSE, chkType ) )
            return TRUE;
        else
        {
            ErrorMsg( NULL, IDS_ERR_INVALID_DIR );
            return FALSE;
        }
    }
    else
    {
        if ( g_CMD.fUserBlankCmd || g_Sess.uExtractOnly )
        {
            // ask user where files are stored
            iDlgRC = MyDialogBox( g_hInst, MAKEINTRESOURCE(IDD_TEMPDIR),
                                  NULL, TempDirDlgProc, (LPARAM)0, 0  );
            //fDlgRC = UserDirPrompt( NULL, IDS_TEMP_EXTRACT, "", g_Sess.achDestDir, sizeof(g_Sess.achDestDir) );
            return ( iDlgRC != 0 ) ;
        }

        // First - try TMP, TEMP, and current
        if ( GetTempPath( sizeof(g_Sess.achDestDir), g_Sess.achDestDir ) )
        {
            if ( CreateAndValidateSubdir( g_Sess.achDestDir, TRUE, (CHK_REQDSK_EXTRACT | CHK_REQDSK_INST) ) )
                return TRUE;

            if ( !IsWindowsDrive( g_Sess.achDestDir ) && CreateAndValidateSubdir( g_Sess.achDestDir, TRUE, CHK_REQDSK_EXTRACT ) )
                return TRUE;
        }

        // temp dir failed, try EXE dir
        // Second - try running EXE Directory
        // Too much grief, lets take this thing out
#if 0
        if ( GetModuleFileName( g_hInst, g_Sess.achDestDir, (DWORD)sizeof(g_Sess.achDestDir) ) && (g_Sess.achDestDir[1] != '\\') )
        {
            len = lstrlen( g_Sess.achDestDir )-1;
            while ( g_Sess.achDestDir[len] != '\\' )
                len--;
            g_Sess.achDestDir[len+1] = '\0';

            if ( CreateAndValidateSubdir ( g_Sess.achDestDir, TRUE, (CHK_REQDSK_EXTRACT | CHK_REQDSK_INST) ) )
                return TRUE;

           if ( !IsWindowsDrive( g_Sess.achDestDir ) && CreateAndValidateSubdir( g_Sess.achDestDir, TRUE, CHK_REQDSK_EXTRACT ) )
                return TRUE;
        }
#endif
        // you are here--means that tmp dir and exe dir are both failed EITHER because of not enough space for
        // both install and extracting and they reside the same dir as Windows OR it is non-windir but not enough space
        // even for extracting itself.
        // we are going to search through users's machine drive A to Z and pick up the drive(FIXED&NON-CD) meet the following conditions:
        // 1) big enough for both install and extract space;
        // 2) 1st Non-Windows drive which has enough space for extracting
        //

        do
        {
            lstrcpy( szRoot, "A:\\" );
            while ( szRoot[0] <= 'Z' )
            {
                UINT uType;
                DWORD dwFreeBytes = 0;

                uType = GetDriveType(szRoot);

                // even the drive type is OK, verify the drive has valid connection
                //
                if ( ( ( uType != DRIVE_RAMDISK) && (uType != DRIVE_FIXED) ) ||
                     ( GetFileAttributes( szRoot ) == -1) )
                {
                    if ( (uType != DRIVE_REMOVABLE ) || (szRoot[0] == 'A') || ( szRoot[0] == 'B') ||
                         !(dwFreeBytes = GetSpace(szRoot)))
                    {
                        szRoot[0]++;
                        continue;
                    }

                    if ( dwFreeBytes < SIZE_100MB )
                    {
                        szRoot[0]++;
                        continue;
                    }
                }

                // fixed drive:
                if ( !IsEnoughSpace( szRoot, CHK_REQDSK_EXTRACT | CHK_REQDSK_INST, MSG_REQDSK_NONE ) )
                {
                    if ( IsWindowsDrive(szRoot) || !IsEnoughSpace( szRoot, CHK_REQDSK_EXTRACT, MSG_REQDSK_NONE ) )
                    {
                        szRoot[0]++;
                        continue;
                    }
                }

                // find the suitable drive
                // create \msdownld.tmp dir as place for extracting location
                //
                if ( IsWindowsDrive(szRoot) )
                {
                    GetWindowsDirectory( szRoot, sizeof(szRoot) );
                }
                AddPath( szRoot, DIR_MSDOWNLD );
                if ( !IfNotExistCreateDir( szRoot ) )
                {
                    szRoot[0]++;
                    szRoot[3] = '\0';
                    continue;
                }
                SetFileAttributes( szRoot, FILE_ATTRIBUTE_HIDDEN );

                lstrcpy( g_Sess.achDestDir, szRoot );
                if ( CreateAndValidateSubdir ( g_Sess.achDestDir, TRUE, CHK_REQDSK_NONE ) )
                    return TRUE;

            }

            GetWindowsDirectory( szRoot, MAX_PATH);
            // just post message; use Windows Drive clustor size as rough estimate
            //
        } while ( IsEnoughSpace( szRoot, CHK_REQDSK_EXTRACT | CHK_REQDSK_INST, MSG_REQDSK_RETRYCANCEL ) );
    }

    return( FALSE );
}

//***************************************************************************
//*                                                                         *
//* NAME:       IsGoodTempDir                                               *
//*                                                                         *
//* SYNOPSIS:   Find out if it's a good temporary directory or not.         *
//*                                                                         *
//* REQUIRES:   szPath:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if good, FALSE if nogood               *
//*                                                                         *
//***************************************************************************
BOOL IsGoodTempDir( LPCTSTR szPath )
{
    DWORD  dwAttribs;
    HANDLE hFile;
    LPSTR  szTestFile;


    ASSERT( szPath );

    szTestFile = (LPSTR) LocalAlloc( LPTR, lstrlen( szPath ) + 20 );
    if ( ! szTestFile )  {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        g_dwExitCode = MyGetLastError();
        return( FALSE );
    }

    lstrcpy( szTestFile, szPath );
    AddPath( szTestFile, "TMP4351$.TMP" );
    hFile = CreateFile( szTestFile, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                        NULL );

    LocalFree( szTestFile );

    if ( hFile == INVALID_HANDLE_VALUE )  {
        g_dwExitCode = MyGetLastError();
        return( FALSE );
    }

    CloseHandle( hFile );

    dwAttribs = GetFileAttributes( szPath );

    if (    ( dwAttribs != 0xFFFFFFFF )
         && ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        g_dwExitCode = S_OK;
        return( TRUE );
    }

    g_dwExitCode = MyGetLastError();
    return( FALSE );
}


//***************************************************************************
//*                                                                         *
//* NAME:       IsEnoughSpace                                               *
//*                                                                         *
//* SYNOPSIS:   Check to make sure that enough space is available in the    *
//*             directory specified.                                        *
//*                                                                         *
//* REQUIRES:   szPath:                                                     *
//*                                                                         *
//* RETURNS:    BOOL:           TRUE if enough space is available           *
//*                             FALSE if not enough space                   *
//*                                                                         *
//***************************************************************************
BOOL IsEnoughSpace( LPCTSTR szPath, UINT chkType, UINT msgType )
{
    DWORD   dwClusterSize     = 0;
    DWORD   dwFreeBytes       = 0;
    ULONG   ulBytesNeeded;
    ULONG   ulInstallNeeded;
    TCHAR   achOldPath[MAX_PATH];
    WORD    idxSize;
    DWORD   idxdwClusterSize = 0;
    TCHAR   szDrv[6];
    DWORD   dwMaxCompLen;
    DWORD   dwVolFlags;


    ASSERT( szPath );

    if ( chkType == CHK_REQDSK_NONE )
        return TRUE;

    GetCurrentDirectory( sizeof(achOldPath), achOldPath );
    if ( ! SetCurrentDirectory( szPath ) )  {
        ErrorMsg( NULL, IDS_ERR_CHANGE_DIR );
        g_dwExitCode = MyGetLastError();
        return FALSE;
    }
 
    if ((dwFreeBytes=GetDrvFreeSpaceAndClusterSize(NULL, &dwClusterSize)) == 0)
    {
        TCHAR szMsg[MAX_STRING]={0};

        g_dwExitCode = MyGetLastError();
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                       szMsg, sizeof(szMsg), NULL );
        ErrorMsg2Param( NULL, IDS_ERR_GET_DISKSPACE, szPath, szMsg );
        SetCurrentDirectory( achOldPath );
        return( FALSE );
    }

    // find out if the drive is compressed
    if ( !GetVolumeInformation( NULL, NULL, 0, NULL,
                    &dwMaxCompLen, &dwVolFlags, NULL, 0 ) )
    {
        TCHAR szMsg[MAX_STRING]={0};

        g_dwExitCode = MyGetLastError();
        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0,
                       szMsg, sizeof(szMsg), NULL );
        ErrorMsg2Param( NULL, IDS_ERR_GETVOLINFOR, szPath, szMsg );
        SetCurrentDirectory( achOldPath );
        return( FALSE );

    }

    SetCurrentDirectory( achOldPath );
    lstrcpyn( szDrv, szPath, 3 );

    ulBytesNeeded = 0;
    idxdwClusterSize = CLUSTER_BASESIZE;

    for ( idxSize=0; idxSize<MAX_NUMCLUSTERS; idxSize++ )
    {
        if ( dwClusterSize == idxdwClusterSize )
        {
            break;
        }
        idxdwClusterSize = idxdwClusterSize<<1;
    }

    if ( idxSize == MAX_NUMCLUSTERS )
    {
        ErrorMsg( NULL, IDS_ERR_UNKNOWN_CLUSTER );
        return( FALSE );
    }

    if ( (g_Sess.uExtractOpt & EXTRACTOPT_COMPRESSED) &&
         ( dwVolFlags & FS_VOL_IS_COMPRESSED ) )
    {
        ulBytesNeeded = (ULONG)(g_dwFileSizes[idxSize]*COMPRESS_FACTOR);
        ulInstallNeeded = (ULONG)(g_Sess.cbPackInstSize + g_Sess.cbPackInstSize/4);
    }
    else
    {
        ulBytesNeeded = (ULONG)g_dwFileSizes[idxSize];
        ulInstallNeeded = (ULONG)g_Sess.cbPackInstSize;
    }

    if ( (chkType & CHK_REQDSK_EXTRACT) && (chkType & CHK_REQDSK_INST) )
    {
        if ( (ulBytesNeeded + ulInstallNeeded) > (ULONG) dwFreeBytes )
        {
            return ( DiskSpaceErrMsg( msgType, ulBytesNeeded, ulInstallNeeded, szDrv ) );
        }
    }
    else if ( chkType & CHK_REQDSK_EXTRACT )
    {
        if ( ulBytesNeeded > (ULONG) dwFreeBytes )
        {
            return ( DiskSpaceErrMsg( msgType, ulBytesNeeded, ulInstallNeeded, szDrv ) );
        }

    }
    else
    {
        if ( ulInstallNeeded > (ULONG)dwFreeBytes )
        {
            return ( DiskSpaceErrMsg( msgType, ulBytesNeeded, ulInstallNeeded, szDrv ) );
        }

    }

    // PATH GOOD AND SPACE AVAILABLE!
    g_dwExitCode = S_OK;
    return TRUE;
}

BOOL RemoveLeadTailBlanks( LPSTR szBuf, int *startIdx )
{
    int i=0, j=0;

    while ( (szBuf[i] != 0) && IsSpace(szBuf[i]) )
      i++;

    if ( szBuf[i] == 0 )
    {
        return FALSE;
    }

    j = lstrlen(&szBuf[i]) - 1;
    while ( j>=0 && IsSpace( szBuf[j+i] ) )
      j--;

    szBuf[j+i+1] = '\0';

    *startIdx = i;
    return TRUE;
}


//***************************************************************************
//*                                                                         *
//*  ParseCmdLine()                                                         *
//*                                                                         *
//*  Purpose:    Parses the command line looking for switches               *
//*                                                                         *
//*  Parameters: LPSTR lpszCmdLineOrg - Original command line               *
//*                                                                         *
//*                                                                         *
//*  Return:     (BOOL) TRUE if successful                                  *
//*                     FALSE if an error occurs                            *
//*                                                                         *
//***************************************************************************

BOOL ParseCmdLine( LPCTSTR lpszCmdLineOrg )
{
    LPCTSTR pLine, pArg;
    char  szTmpBuf[MAX_PATH];
    int   i,j;
    LPTSTR lpTmp;
    BOOL  bRet = TRUE;
    BOOL  bLeftQ, bRightQ;

    // If we have no command line, then return.   It is
    // OK to have no command line.  CFGTMP is created
    // with standard files
    if( (!lpszCmdLineOrg) || (lpszCmdLineOrg[0] == 0) )
       return TRUE;

    // Loop through command line
    pLine = lpszCmdLineOrg;
    while ( (*pLine != EOL) && bRet )
    {
       // Move to first non-white char.
       pArg = pLine;
       while ( IsSpace( (int) *pArg ) )
          pArg = CharNext (pArg);

       if( *pArg == EOL )
          break;

       // Move to next white char.
       pLine = pArg;
       i = 0;
       bLeftQ = FALSE;
       bRightQ = FALSE;
       while ( (*pLine != EOL) && ( (!bLeftQ && (!IsSpace(*pLine))) || (bLeftQ && (!bRightQ) )) )
       {
           if ( *pLine == '"')
           {
               switch ( *(pLine + 1) )
               {
                   case '"':
                        if(i + 1 < sizeof(szTmpBuf) / sizeof(szTmpBuf[0]))
                        {
                            szTmpBuf[i++] = *pLine++;
                            pLine++;
                        }
                        else
                        {
                            return FALSE;
                        }

                        break;

                   default:
                        if ( !bLeftQ )
                            bLeftQ = TRUE;
                        else
                            bRightQ = TRUE;
                        pLine++;
                        break;
               }
           }
           else
           {
               if(i + 1 < sizeof(szTmpBuf) / sizeof(szTmpBuf[0]))
               {
                   szTmpBuf[i++] = *pLine++;
               }
               else
               {
                   return FALSE;
               }
           }
       }

       szTmpBuf[i] = '\0';

       // make sure the " " are in paires
       if ( (bLeftQ && bRightQ) || (!bLeftQ) && (!bRightQ) )
           ;
       else
       {
           bRet = FALSE;
           break;
       }

       if( szTmpBuf[0] != CMD_CHAR1 && szTmpBuf[0] != CMD_CHAR2 )
       {
            // cmdline comand starting with either '/' or '-'
            return FALSE;
       }

       // Look for other switches
       switch( (CHAR)CharUpper((PSTR)szTmpBuf[1]) )
       {
           case 'Q':
               if (szTmpBuf[2] == 0 )
                    g_CMD.wQuietMode = QUIETMODE_USER;
                    //g_CMD.wQuietMode = QUIETMODE_ALL;
               else if ( szTmpBuf[2] == ':')
               {
                   switch ( (CHAR)CharUpper((PSTR)szTmpBuf[3]) )
                   {                        
                        case 'U':
                        case '1':
                            g_CMD.wQuietMode = QUIETMODE_USER;
                            break;

                        case 'A':
                            g_CMD.wQuietMode = QUIETMODE_ALL;
                            break;

                        default:
                            bRet = FALSE;
                            break;
                    }
               }
               else
                   bRet = FALSE;
               break;

           case 'T':
           case 'D':
              if ( szTmpBuf[2] == ':' )
              {
                  PSTR pszPath;

                  if ( szTmpBuf[3] == '"' )
                      i = 4;
                  else
                      i = 3;

                  if ( !lstrlen(&szTmpBuf[i]) )
                  {
                      bRet = FALSE;
                      break;
                  }
                  else
                  {
                      j = i;
                      if (!RemoveLeadTailBlanks( &szTmpBuf[i], &j ) )
                      {
                          bRet = FALSE;
                          break;
                      }
                      if ( (CHAR)CharUpper((PSTR)szTmpBuf[1]) == 'T' )
                      {
                        lstrcpy( g_CMD.szUserTempDir, &szTmpBuf[i+j] );
                        AddPath( g_CMD.szUserTempDir, "" );
                        pszPath = g_CMD.szUserTempDir;
                      }
                      else
                      {
                        lstrcpy( g_CMD.szRunonceDelDir, &szTmpBuf[i+j] );
                        AddPath( g_CMD.szRunonceDelDir, "" );
                        pszPath = g_CMD.szRunonceDelDir;
                      }

                      // make sure it is full path
                      if ( !IsFullPath(pszPath) )
                            return FALSE;

                  }
              }
              else
                  bRet = FALSE;
              break;

           case 'C':
              if ( szTmpBuf[2] == 0 )
              {
                   g_CMD.fUserBlankCmd = TRUE;
              }
              else if ( szTmpBuf[2] == ':' )
              {
                  if ( szTmpBuf[3] == '"' )
                      i = 4;
                  else
                      i = 3;

                  if ( !lstrlen(&szTmpBuf[i]) )
                  {
                      bRet = FALSE;
                      break;
                  }
                  else
                  {
                      // just make sure [] paires right
                      //
                      if ( ANSIStrChr( &szTmpBuf[i], '[' ) && (!ANSIStrChr( &szTmpBuf[i], ']' )) ||
                           ANSIStrChr( &szTmpBuf[i], ']' ) && (!ANSIStrChr( &szTmpBuf[i], '[' )) )
                      {
                          bRet = FALSE;
                          break;
                      }
                      j = i;
                      if (!RemoveLeadTailBlanks( &szTmpBuf[i], &j ) )
                      {
                          bRet = FALSE;
                          break;
                      }
                      lstrcpy( g_CMD.szUserCmd, &szTmpBuf[i+j] );
                  }
              }
              else
                  bRet = FALSE;
              break;

           case 'R':
               if (szTmpBuf[2] == 0 )
               {
                   g_Sess.dwReboot = REBOOT_YES | REBOOT_ALWAYS;
                   g_CMD.fUserReboot = TRUE;
               }
               else if ( szTmpBuf[2] == ':')
               {
                   g_Sess.dwReboot = REBOOT_YES;

                   i = 3;
                   while ( szTmpBuf[i] != 0 )
                   {
                        switch ( (CHAR)CharUpper((PSTR)szTmpBuf[i++]) )
                        {
                            case 'N':
                                g_Sess.dwReboot &= ~(REBOOT_YES);
                                g_CMD.fUserReboot = TRUE;
                                break;
                            case 'I':
                                g_Sess.dwReboot &= ~(REBOOT_ALWAYS);
                                g_CMD.fUserReboot = TRUE;
                                break;
                            case 'A':
                                g_Sess.dwReboot |= REBOOT_ALWAYS;
                                g_CMD.fUserReboot = TRUE;
                                break;
                            case 'S':
                                g_Sess.dwReboot |= REBOOT_SILENT;
                                g_CMD.fUserReboot = TRUE;
                                break;
                            case 'D':
                                g_CMD.dwFlags |= CMDL_DELAYREBOOT;
                                break;
                            case 'P':
                                g_CMD.dwFlags |= CMDL_DELAYPOSTCMD;
                                break;

                            default:
                                bRet = FALSE;
                                break;
                        }
                   }
               }
               else if ( !lstrcmpi( CMD_REGSERV, &szTmpBuf[1] )  )
               {
                    break;  //ignore
               }
               else
               {
                    bRet = FALSE;
                    break;
               }
               
               break;

           case 'N':
               if (szTmpBuf[2] == 0 )
                   g_CMD.fNoExtracting = TRUE;
               else if ( szTmpBuf[2] == ':')
               {
                   i = 3;
                   while ( szTmpBuf[i] != 0 )
                   {
                        switch ( (CHAR)CharUpper((PSTR)szTmpBuf[i++]) )
                        {
                            case 'G':
                                g_CMD.fNoGrpConv = TRUE;
                                break;

                            case 'E':
                                g_CMD.fNoExtracting = TRUE;
                                break;

                            case 'V':
                                g_CMD.fNoVersionCheck = TRUE;
                                break;

                            default:
                                bRet = FALSE;
                                break;
                        }
                   }

               }
               else
                   bRet = FALSE;
               break;

           case '?':        // Help
              DisplayHelp();
              if (g_hMutex)
                CloseHandle(g_hMutex);
                ExitProcess(0);              

           default:
              bRet = FALSE;
              break;
       }
    }

    if ( g_CMD.fNoExtracting && (g_CMD.szUserTempDir[0]==0) )
    {
        if ( GetModuleFileName( g_hInst, g_CMD.szUserTempDir, (DWORD)sizeof(g_CMD.szUserTempDir) ) )
        {
            lpTmp= ANSIStrRChr(g_CMD.szUserTempDir, '\\') ;
            *(lpTmp+1) = '\0' ;
        }
        else
            bRet = FALSE ;
    }
    return bRet;
}

// check windows drive disk space
//
BOOL CheckWinDir()
{
    TCHAR szWinDrv[MAX_PATH];

    if ( !GetWindowsDirectory( szWinDrv, MAX_PATH ) )
    {
        ErrorMsg( NULL, IDS_ERR_GET_WIN_DIR );
        g_dwExitCode = MyGetLastError();
        return FALSE;
    }
    return ( IsEnoughSpace( szWinDrv, CHK_REQDSK_INST, MSG_REQDSK_WARN ) );
}

// get the last error and map it to HRESULT
//
DWORD MyGetLastError()
{
    return HRESULT_FROM_WIN32( GetLastError() );
}


//***************************************************************************
//*                                                                         *
//* NAME:       TravelUpdatedFiles                                          *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if successfull, FALSE otherwise            *
//*                                                                         *
//***************************************************************************
BOOL TravelUpdatedFiles( pfuncPROCESS_UPDATED_FILE pProcessUpdatedFile )
{
    DWORD  dwFileSize      = 0;
    DWORD  dwReserved      = 0;
    PSTR   pszFilename     = NULL;
    PSTR   pszFileContents = NULL;
    TCHAR  szResName[20];
    DWORD  dwResNum        = 0;
    HANDLE hRes            = NULL;
    HRSRC  hRsrc           = NULL;
    BOOL   fReturnCode     = TRUE;
    static const TCHAR c_szResNameTemplate[] = "UPDFILE%lu";

    for ( dwResNum = 0; ; dwResNum += 1 ) {
        wsprintf( szResName, c_szResNameTemplate, dwResNum );

        hRsrc = FindResource( NULL, szResName, RT_RCDATA );
        if ( hRsrc == NULL ) {
            break;
        }

        hRes = LockResource( LoadResource( NULL, hRsrc ) );
        if ( hRes == NULL ) {
            g_dwExitCode = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
            fReturnCode = FALSE;
            goto done;
        }

        dwFileSize      = *((PDWORD)hRes);
        dwReserved      = *((PDWORD)(((PDWORD)hRes)+1));
        pszFilename     = (PSTR) (((PSTR)hRes)+(2*sizeof(DWORD)));
        pszFileContents = (PSTR) (pszFilename + lstrlen(pszFilename) + 1);

        if ( !pProcessUpdatedFile( dwFileSize, dwReserved, pszFilename, pszFileContents ) )
        {
            // g_dwExitCode is set in pProcessUpdatedFile()
            fReturnCode = FALSE;
            FreeResource( hRes );
            goto done;
        }

        FreeResource( hRes );
    }

  done:

    return fReturnCode;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ProcessUpdatedFile_Size                                     *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if successfull, FALSE otherwise            *
//*                                                                         *
//***************************************************************************
BOOL ProcessUpdatedFile_Size( DWORD dwFileSize, DWORD dwReserved,
                              PCSTR c_pszFilename, PCSTR c_pszFileContents )
{
    DWORD  clusterCurrSize = 0;
    DWORD  i               = 0;

#if 0
    if (g_Sess.cbPackInstSize != 0 ) {
        g_Sess.cbPackInstSize += dwFileSize;
    }
#endif

    // calculate the file size in different cluster sizes
    clusterCurrSize = CLUSTER_BASESIZE;
    for ( i = 0; i < MAX_NUMCLUSTERS; i += 1 ) {
        g_dwFileSizes[i] += ((dwFileSize/clusterCurrSize)*clusterCurrSize +
                             (dwFileSize%clusterCurrSize?clusterCurrSize : 0));
        clusterCurrSize = (clusterCurrSize<<1);
    }

    return TRUE;
}


//***************************************************************************
//*                                                                         *
//* NAME:       ProcessUpdatedFile_Write                                    *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:   Nothing                                                     *
//*                                                                         *
//* RETURNS:    BOOL:       TRUE if successfull, FALSE otherwise            *
//*                                                                         *
//***************************************************************************
BOOL ProcessUpdatedFile_Write( DWORD dwFileSize, DWORD dwReserved,
                               PCSTR c_pszFilename, PCSTR c_pszFileContents )
{
    HANDLE hFile          = INVALID_HANDLE_VALUE;
    BOOL   fSuccess       = TRUE;
    DWORD  dwBytesWritten = 0;
    TCHAR  szFullFilename[MAX_PATH];

    lstrcpy( szFullFilename, g_Sess.achDestDir );
    AddPath( szFullFilename, c_pszFilename );

    hFile = CreateFile( szFullFilename, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
        fSuccess = FALSE;
        goto done;
    }

    if (    ! WriteFile( hFile, c_pszFileContents, dwFileSize, &dwBytesWritten, NULL )
         || dwFileSize != dwBytesWritten )
    {
        g_dwExitCode = HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
        fSuccess = FALSE;
        goto done;
    }

  done:

    if ( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hFile );
    }

    return fSuccess;
}


HINSTANCE MyLoadLibrary( LPTSTR lpFile )
{
    TCHAR szPath[MAX_PATH];
    DWORD dwAttr;
    HINSTANCE hFile;

    lstrcpy( szPath, g_Sess.achDestDir );
    AddPath( szPath, lpFile );

    if ( ((dwAttr=GetFileAttributes( szPath )) != -1) &&
          !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
    {
        hFile = LoadLibraryEx( szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    }
    else
    {
        hFile = LoadLibrary( lpFile );
    }

    return hFile;

}

INT_PTR MyDialogBox( HANDLE hInst, LPCTSTR pTemplate, HWND hWnd, DLGPROC lpProc, LPARAM lpParam, INT_PTR idefRet )
{
    INT_PTR iDlgRc = -1;
    HRSRC hDlgRc;
    HGLOBAL hMemDlg;

    hDlgRc = FindResource( hInst, pTemplate, RT_DIALOG );

    if ( hDlgRc )
    {
        hMemDlg = LoadResource( hInst, hDlgRc );
        if ( hMemDlg )
        {
            if ( !lpParam )
                iDlgRc = DialogBoxIndirect( hInst, hMemDlg, hWnd, lpProc );
            else
                iDlgRc = DialogBoxIndirectParam( hInst, hMemDlg, hWnd, lpProc, lpParam );

            FreeResource( hMemDlg );
        }
    }

    if ( iDlgRc == (INT_PTR)-1 )
    {
        ErrorMsg( NULL, IDS_ERR_DIALOGBOX );
        iDlgRc = idefRet;
    }

    return iDlgRc;
}

/* these are here to avoid linking QDI */

void * __cdecl QDICreateDecompression(void)
{
    return(NULL);
}

void __cdecl QDIDecompress(void)
{
}

void __cdecl QDIResetDecompression(void)
{
}

void __cdecl QDIDestroyDecompression(void)
{
}


/* these are here to avoid linking MDI */

void* __cdecl MDICreateDecompression(void)
{
    return(NULL);
}

void __cdecl MDIDecompress(void)
{
}

void __cdecl MDIResetDecompression(void)
{
}

void __cdecl MDIDestroyDecompression(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\atol.c ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      string.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "sdsutils.h"

//=================================================================================================
//
// copied from msdev\crt\src\atox.c
//
// long AtoL(char *nptr) - Convert string to long
//
// Purpose:
//       Converts ASCII string pointed to by nptr to binary.
//       Overflow is not detected.
//
// Entry:
//       nptr = ptr to string to convert
//
// Exit:
//       return long int value of the string
//
// Exceptions:
//       None - overflow is not detected.
//
//=================================================================================================

long AtoL(const char *nptr)
{
    int c;                  /* current char */
    long total;             /* current total */
    int sign;               /* if '-', then negative, otherwise positive */

    // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
    // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
    // DBCS Trailing bytes -- pritvi

    /* skip whitespace */
    while ( IsSpace((int)(unsigned char)*nptr) )
        ++nptr;

    c = (int)(unsigned char)*nptr++;
    sign = c;               /* save sign indication */
    if (c == '-' || c == '+')
        c = (int)(unsigned char)*nptr++;        /* skip sign */

    total = 0;

    while (IsDigit(c)) {
        total = 10 * total + (c - '0');         /* accumulate digit */
        c = (int)(unsigned char)*nptr++;        /* get next char */
    }

    if (sign == '-')
        return -total;
    else
        return total;   /* return result, negated if necessary */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\checks.c ===
#include <windows.h>


BOOL RunningOnMillennium()
{
    OSVERSIONINFO VersionInfo;
    static BOOL bRet = -2;

    if (bRet == -2)
    {
        bRet = FALSE;
        VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&VersionInfo))
        {
            if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            {
                bRet = ((VersionInfo.dwMajorVersion == 4) && (VersionInfo.dwMinorVersion == 90));
            }
        }
    }
    return bRet;
}

BOOL ConvertHexStringToIntA( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}

typedef struct  {
    WORD wLang;
    BOOL fFoundLang;
    LPCTSTR lpszType;
} ENUMLANGDATA;

BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;
    BOOL fContinue = TRUE;


    if (lpszType == pel->lpszType)
    {
        if (pel->wLang == PRIMARYLANGID(wIdLang))
        {
            pel->wLang = wIdLang;
            pel->fFoundLang = TRUE;
            fContinue = FALSE; 
        }
    }
    return fContinue;   // continue until we get langs...
}


BOOL GetResourceLanguage(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wLang)
{
        ENUMLANGDATA el;

    el.wLang = wLang;
    el.fFoundLang = FALSE;
    el.lpszType = lpszType;

    EnumResourceLanguages(hinst, lpszType, lpszName, EnumResLangProc, (LPARAM)&el);

    return el.fFoundLang;
}

BOOL IsBiDiLocalizedBinary(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName)
{
        static BOOL bRet = -2;

    if(bRet == -2)
    {
        bRet = FALSE;
        if(GetResourceLanguage(hinst,lpszType, lpszName, LANG_ARABIC)
            || GetResourceLanguage(hinst, lpszType, lpszName, LANG_HEBREW))
            {
                bRet = TRUE;
            }
    }
    return bRet;    
}

BOOL RunningOnWin95BiDiLoc()
{
        OSVERSIONINFO VersionInfo;
        static BOOL bRet = -2;
        HKEY  hKey;
        DWORD dwType;
        CHAR  szResourceLocale[12];
        DWORD dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
        LONG lRes;
        int   iLCID=0L;
       

    if (bRet == -2)
    {
        bRet = FALSE;
        VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&VersionInfo))
        {
            if ((VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) 
                && (VersionInfo.dwMajorVersion == 4) 
                && (VersionInfo.dwMinorVersion < 10)
                && (GetSystemMetrics(SM_MIDEASTENABLED))) // Anything before Win98.
            {
                if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                                   "Control Panel\\Desktop\\ResourceLocale" , 
                                   0, 
                                   KEY_READ, &hKey) == ERROR_SUCCESS) 
                {
                    lRes = RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE) szResourceLocale , &dwSize );

                    RegCloseKey(hKey);
                    if(ERROR_SUCCESS != lRes)
                    {
                        return bRet;
                    }

                    if( ConvertHexStringToIntA( szResourceLocale , &iLCID ) )
                    {
                        iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                        if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                        {
                            bRet = TRUE;
                        }
                    }
                }
            }
        }
    }
    return bRet;
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\wextract.h ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* WEXTRACT.H - Self-extracting/Self-installing stub.                      *
//*                                                                         *
//***************************************************************************

#ifndef _WEXTRACT_H_
#define _WEXTRACT_H_

//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include <shlobj.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include <sys\stat.h>
#include "fdi.h"
#include "resource.h"
#include <cpldebug.h>
#include <res.h>
#include <sdsutils.h>


//***************************************************************************
//* DEFINES                                                                 *
//***************************************************************************
#define SMALL_BUF_LEN     80
#define STRING_BUF_LEN    512
#define MAX_STRING        STRING_BUF_LEN
#define MSG_MAX           STRING_BUF_LEN
#define FILETABLESIZE     40
#define SHFREE_ORDINAL    195           // Required for BrowseForDir
#define _OSVER_WIN9X      0
#define _OSVER_WINNT3X    1
#define _OSVER_WINNT40    2
#define _OSVER_WINNT50    3

// If the following #define is turned on, the directory where the app.
// (wextract app.) is running from is passed as command line to the
// exe that it will then launch after decompression (self extracting).
// This is useful, say, if we are trying to use modified runonce app. that
// Mark was working on. Else, if we are trying to run a custom app. say
// or even an INF (using rundll32, this code does not work). For now,
// I am disabling this so that our Service Pack code can use this.
//
// #define ISVINSTALL                      // If defined, WExtract will pass
                                        // the directory it was run from
                                        // to the installation program.  This
                                        // is to support the ISV Installer
                                        // which requires this path to find
                                        // the CABs.

#define CMD_CHAR1   '/'
#define CMD_CHAR2   '-'
#define EOL         '\0'

#define TEMPPREFIX  "IXP"
#define TEMP_TEMPLATE "IXP%03d.TMP"

// define quiet modes
#define QUIETMODE_ALL       0x0001
#define QUIETMODE_USER      0x0002

// disk checking methods
#define CHK_REQDSK_NONE     0x0000
#define CHK_REQDSK_EXTRACT  0x0001
#define CHK_REQDSK_INST     0x0002

// Disk check Message type
#define MSG_REQDSK_NONE         0x0000
#define MSG_REQDSK_ERROR        0x0001
#define MSG_REQDSK_WARN         0x0002
#define MSG_REQDSK_RETRYCANCEL  0x0004

// alternative download & extract dir name
#define DIR_MSDOWNLD    "msdownld.tmp"

#define KBYTES          1000

#define ADVPACKDLL      "advpack.dll"

//***************************************************************************
//* TYPE DEFINITIONS                                                        *
//***************************************************************************
// Filename List: We keep track of all files that we have created by keeping
// their names in a list and when the program is complete we use this list
// to delete files if necessary
typedef struct _FNAME {
    LPTSTR         pszFilename;
    struct _FNAME *pNextName;
} FNAME, *PFNAME;

// Current Cabinet Information
typedef struct _CABINET {
    TCHAR  achCabPath[MAX_PATH];        // Cabinet file path
    TCHAR  achCabFilename[MAX_PATH];    // Cabinet file name.ext
    TCHAR  achDiskName[MAX_PATH];       // User readable disk label
    USHORT setID;
    USHORT iCabinet;
} CABINET, *PCABINET;

// Master State Information for File Extraction
typedef struct _SESSION {
    VOID   *lpCabinet;                  // Pointer to cabinet in mem
    UINT    cbCabSize;
    ERF     erf;
    TCHAR   achTitle[128];
    UINT    wCluster;
    BOOL    fCanceled;                  // User hit Cancel button
    BOOL    fOverwrite;                 // Overwrite Files
    PFNAME  pExtractedFiles;            // List of Files Extracted
    TCHAR   achDestDir[MAX_PATH];       // Dest Dir
    TCHAR   achCabPath[MAX_PATH];       // Current Path to cabs
    BOOL    fAllCabinets;
    BOOL    fContinuationCabinet;
    UINT    cFiles;
    UINT    cbTotal;
    UINT    cbAdjustedTotal;
    UINT    cbWritten;
    LPCSTR  cszOverwriteFile;
    //** fNextCabCalled allows us to figure out which of the acab[] entries
    //   to use if we are processing all file in a cabinet set (i.e., if
    //   fAllCabinet is TRUE).  If fdintNEXT_CABINET has never been called,
    //   then acab[1] has the information for the next cabinet.  But if
    //   it has been called, then fdintCABINET_INFO will have been called
    //   at least twice (once for the first cabinet, and once at least for
    //   a continuation cabinet), and so acab[0] is the cabinet we need to
    //   pass to a subsequent FDICopy() call.
    BOOL    fNextCabCalled;             // TRUE => GetNextCabinet called
    CABINET acab[2];                    // Last two fdintCABINET_INFO data sets
    DWORD   dwReboot;
    UINT    uExtractOnly;
    UINT    uExtractOpt;
    DWORD   cbPackInstSize;
} SESSION, *PSESSION;

// Memory File: We have to imitate a file with the cabinet attached to
// this executable by using the following MEMFILE structure.
typedef struct _MEMFILE {
    void *start;
    long  current;
    long  length;
} MEMFILE, *PMEMFILE;

// File Table: In order to support both Win32 File Handles and Memory Files
// (see above) we maintain our own file table.  So FDI file handles are
// indexes into a table of these structures.
typedef enum { NORMAL_FILE, MEMORY_FILE } FILETYPE;

typedef struct _FAKEFILE {
    BOOL        avail;
    FILETYPE    ftype;
    MEMFILE     mfile;              // State for memory file
    HANDLE      hf;                 // Handle for disk  file
} FAKEFILE, *PFAKEFILE;

// Required for BrowseForDir()

typedef WINSHELLAPI HRESULT (WINAPI *SHGETSPECIALFOLDERLOCATION)(HWND, int, LPITEMIDLIST *);
typedef WINSHELLAPI LPITEMIDLIST (WINAPI *SHBROWSEFORFOLDER)(LPBROWSEINFO);
typedef WINSHELLAPI void (WINAPI *SHFREE)(LPVOID);
typedef WINSHELLAPI BOOL (WINAPI *SHGETPATHFROMIDLIST)( LPCITEMIDLIST, LPTSTR );

typedef struct _MyFile {
    LPSTR szFilename;
    ULONG ulSize;
    struct _MyFile *Next;
} MYFILE, *PMYFILE;


// define the cmdline flags
#define     CMDL_CREATETEMP     0x00000001
#define     CMDL_USERBLANKCMD   0x00000002
#define     CMDL_USERREBOOT     0x00000004
#define     CMDL_NOEXTRACT      0x00000008
#define     CMDL_NOGRPCONV      0x00000010
#define     CMDL_NOVERCHECK     0x00000020
#define     CMDL_DELAYREBOOT    0x00000040
#define     CMDL_DELAYPOSTCMD 0x00000080

typedef struct _CMDLINE {
    BOOL     fCreateTemp;
    BOOL     fUserBlankCmd;
    BOOL     fUserReboot;
    BOOL     fNoExtracting;
    BOOL     fNoGrpConv;
    BOOL     fNoVersionCheck;
    WORD     wQuietMode;
    TCHAR    szRunonceDelDir[MAX_PATH];
    TCHAR    szUserTempDir[MAX_PATH];
    TCHAR    szUserCmd[MAX_PATH];
    DWORD    dwFlags;
} CMDLINE_DATA, *PCMDLINE_DATA;


typedef HRESULT (WINAPI *DOINFINSTALL)( ADVPACKARGS * );

typedef BOOL (*pfuncPROCESS_UPDATED_FILE)( DWORD, DWORD, PCSTR, PCSTR );


//***************************************************************************
//* MACRO DEFINITIONS                                                       *
//***************************************************************************
#define MsgBox( hWnd, nMsgID, uIcon, uButtons ) \
        MsgBox2Param( hWnd, nMsgID, NULL, NULL, uIcon, uButtons )
#define MsgBox1Param( hWnd, nMsgID, szParam, uIcon, uButtons ) \
        MsgBox2Param( hWnd, nMsgID, szParam, NULL, uIcon, uButtons )
#define ErrorMsg( hWnd, nMsgID ) \
        MsgBox2Param( hWnd, nMsgID, NULL, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg1Param( hWnd, nMsgID, szParam ) \
        MsgBox2Param( hWnd, nMsgID, szParam, NULL, MB_ICONERROR, MB_OK )
#define ErrorMsg2Param( hWnd, nMsgID, szParam1, szParam2 ) \
        MsgBox2Param( hWnd, nMsgID, szParam1, szParam2, MB_ICONERROR, MB_OK )


//***************************************************************************
//* GLOBAL CONSTANTS                                                        *
//***************************************************************************
static TCHAR achWndClass[]       = "WEXTRACT";    // Window Class Name
static TCHAR achMemCab[]         = "*MEMCAB";

static TCHAR achSETUPDLL[]         = "rundll32.exe %s,InstallHinfSection %s 128 %s";
static TCHAR achShell32Lib[]                 = "SHELL32.DLL";
static TCHAR achSHGetSpecialFolderLocation[] = "SHGetSpecialFolderLocation";
static TCHAR achSHBrowseForFolder[]          = "SHBrowseForFolder";
static TCHAR achSHGetPathFromIDList[]        = "SHGetPathFromIDList";

// BUGBUG: mg: These should eventually become customizable from CABPACK.
static char szSectionName[] = "DefaultInstall";

// default INF install section name
static TCHAR achDefaultSection[] = "DefaultInstall";
static char szDOINFINSTALL[] = "DoInfInstall";

extern BOOL g_bConvertRunOnce;

//***************************************************************************
//* FUNCTION PROTOTYPES                                                     *
//***************************************************************************
BOOL                Init( HINSTANCE, LPCTSTR, INT );
BOOL                DoMain( );
VOID                CleanUp( VOID );
VOID NEAR PASCAL    MEditSubClassWnd( HWND, FARPROC );
LRESULT CALLBACK       MEditSubProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK    WaitDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK    LicenseDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK    TempDirDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK    OverwriteDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR CALLBACK    ExtractDlgProc( HWND, UINT, WPARAM, LPARAM );
VOID                WaitForObject( HANDLE );
BOOL                CheckOSVersion( PTARGETVERINFO );
BOOL                DisplayLicense( VOID );
BOOL                ExtractFiles( VOID );
BOOL                RunInstallCommand( VOID );
VOID                FinishMessage( VOID );
BOOL                BrowseForDir( HWND, LPCTSTR, LPTSTR );
BOOL                CenterWindow( HWND, HWND );
INT CALLBACK        MsgBox2Param( HWND, UINT, LPCSTR, LPCSTR, UINT, UINT );
DWORD               GetResource( LPCSTR, VOID *, DWORD );
LPSTR               LoadSz( UINT, LPSTR, UINT );
BOOL                CatDirAndFile( LPTSTR, int, LPCTSTR, LPCTSTR );
BOOL                FileExists( LPCTSTR );
BOOL                CheckOverwrite( LPCTSTR );
BOOL                AddFile( LPCTSTR );
HANDLE              Win32Open( LPCTSTR, int, int );
INT_PTR FAR DIAMONDAPI  openfunc( char FAR *, int, int );
UINT FAR DIAMONDAPI readfunc( INT_PTR, void FAR *, UINT );
UINT FAR DIAMONDAPI writefunc( INT_PTR, void FAR *, UINT );
int FAR DIAMONDAPI  closefunc( INT_PTR );
long FAR DIAMONDAPI seekfunc( INT_PTR, long, int );
BOOL                AdjustFileTime( INT_PTR, USHORT, USHORT );
DWORD               Attr32FromAttrFAT( WORD );
                    FNALLOC( allocfunc );
                    FNFREE( freefunc );
                    FNFDINOTIFY( doGetNextCab );
                    FNFDINOTIFY( fdiNotifyExtract );
int                 UpdateCabinetInfo( PFDINOTIFICATION );
BOOL                VerifyCabinet( HGLOBAL );
BOOL                ExtractThread( VOID );
BOOL                GetCabinet( VOID );
BOOL                GetFileList( VOID );
BOOL                GetUsersPermission( VOID );
VOID                DeleteExtractedFiles( VOID );
BOOL                GetTempDirectory( VOID );
BOOL                IsGoodTempDir( LPCTSTR );
BOOL                IsEnoughSpace( LPCTSTR, UINT, UINT );
BOOL                RunApps( LPSTR lpCommand, STARTUPINFO *lpsti );
BOOL                ParseCmdLine( LPCTSTR lpszCmdLineOrg );
BOOL                AnalyzeCmd( LPTSTR szOrigiCommand, LPTSTR *lplpCommand, BOOL *pfInfCmd );
void                DisplayHelp();
void                CleanRegRunOnce();
void                AddRegRunOnce();
void                ConvertRegRunOnce();
void                MyRestartDialog( DWORD dwRebootMode );
void                DeleteMyDir( LPSTR lpDir );
void                AddPath(LPSTR szPath, LPCSTR szName );
BOOL                IsRootPath(LPCSTR pPath);
INT_PTR CALLBACK    WarningDlgProc(HWND hwnd, UINT msg,WPARAM wParam, LPARAM lParam);
BOOL                IsNTAdmin();
DWORD               NeedRebootInit(WORD wOSVer);
BOOL                NeedReboot(DWORD dwRebootCheck, WORD wOSVer);
BOOL                IfNotExistCreateDir( LPTSTR szDir );
BOOL                IsWindowsDrive( LPTSTR szPath );
BOOL                DiskSpaceErrMsg( UINT msgType, ULONG ulExtractNeeded, DWORD dwInstNeeded, LPTSTR lpDrv );
BOOL                CheckWinDir();
DWORD               MyGetLastError();
void                savAppExitCode( DWORD dwAppRet );
DWORD               CheckReboot( VOID );
BOOL                TravelUpdatedFiles( pfuncPROCESS_UPDATED_FILE );
BOOL                ProcessUpdatedFile_Size( DWORD, DWORD, PCSTR, PCSTR );
BOOL                ProcessUpdatedFile_Write( DWORD, DWORD, PCSTR, PCSTR );
VOID                MakeDirectory ( LPCTSTR );
INT_PTR             MyDialogBox( HANDLE, LPCTSTR, HWND, DLGPROC, LPARAM, INT_PTR );
BOOL                CheckFileVersion( PTARGETVERINFO ptargetVers, LPSTR, int, int* );
BOOL                GetFileTobeChecked( LPSTR szPath, int iSize, LPCSTR szNameStr );
UINT                GetMsgboxFlag( DWORD dwFlag );
int                 CompareVersion( DWORD, DWORD, DWORD, DWORD );
void                ExpandCmdParams( PCSTR pszInParam, PSTR pszOutParam );
HINSTANCE           MyLoadLibrary( LPTSTR lpFile );

#endif // _WEXTRACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\crypto.c ===
#include <windows.h>
#include <regstr.h>
#include "sdsutils.h"

const char c_szUNINSTALLDAT[]="ie6bak.dat";
const char c_szUNINSTALLINI[] = "ie6bak.ini";
const char c_szIE4SECTIONNAME[] = "backup";
const char c_szIE4_OPTIONS[] = "Software\\Microsoft\\IE Setup\\Options";
const char c_szIE4_UNINSTALLDIR[] = "UninstallDir";

// the following functions are stolen from ie4.dll
BOOL FileVerGreaterOrEqual(LPSTR lpszFileName, DWORD dwReqMSVer, DWORD dwReqLSVer)
{
    DWORD dwMSVer, dwLSVer;

    MyGetVersionFromFile(lpszFileName, &dwMSVer, &dwLSVer, TRUE);

    return ((dwMSVer > dwReqMSVer)  ||  ((dwMSVer == dwReqMSVer) && (dwLSVer >= dwReqLSVer)));
}

void BuildPath( char *szPath, const char *szDirPath, const char *szFileName )
{
    lstrcpy( szPath, szDirPath );
    AddPath( szPath, szFileName );
}

ULONG FileSize( LPSTR lpFile )
{
    ULONG ulFileSize = (ULONG) -1;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile;

    if ( lpFile == NULL  ||  *lpFile == 0 )
        return ulFileSize;

    if ((hFile = FindFirstFile( lpFile, &FindFileData )) != INVALID_HANDLE_VALUE)
    {
        ulFileSize = (FindFileData.nFileSizeHigh * MAXDWORD) + FindFileData.nFileSizeLow;
        FindClose( hFile );
    }

    return ulFileSize;
}

BOOL ValidateUninstallFiles(LPSTR lpszPath)
{
   HKEY  hKey;
   DWORD dwType;
   DWORD dwValue;
   DWORD dwSize;
   char szTmp[MAX_PATH];
   BOOL  bValidFiles = FALSE;

   if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIE4_OPTIONS, 0, KEY_READ, &hKey))
   {
      dwSize = sizeof(dwValue);
      if ( RegQueryValueEx(hKey, c_szUNINSTALLDAT, NULL, &dwType, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS )
      {
         BuildPath(szTmp, lpszPath, c_szUNINSTALLDAT);
         if (dwType == REG_DWORD)
            bValidFiles = (dwValue == FileSize(szTmp));

      }
      if (bValidFiles)
      {
         dwSize = sizeof(dwValue);
         if ( RegQueryValueEx(hKey, c_szUNINSTALLINI, NULL, &dwType, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS )
         {
            BuildPath(szTmp, lpszPath, c_szUNINSTALLINI);
            if (dwType == REG_DWORD)
               bValidFiles = (dwValue == FileSize(szTmp));
         }
      }
      RegCloseKey(hKey);
   }
   return bValidFiles;
}

BOOL GetUninstallDirFromReg(LPSTR lpszUninstallDir)
{
   HKEY    hKey;
   DWORD   dwType;
   char    szValue[MAX_PATH];
   DWORD   dwSize = MAX_PATH;

   *szValue = '\0';
   if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIE4_OPTIONS, 0, KEY_READ, &hKey))
   {
      if ( RegQueryValueEx(hKey, c_szIE4_UNINSTALLDIR, NULL, &dwType, (LPBYTE) szValue, &dwSize) == ERROR_SUCCESS )
      {
         if (lpszUninstallDir)
            lstrcpy (lpszUninstallDir, szValue);
      }
      RegCloseKey(hKey);
   }

   return (*szValue != '\0');
}

BOOL FileBackupEntryExists(LPCSTR lpcszFileName)
{
    BOOL bRet = FALSE;
    char szPath[MAX_PATH];

    if (GetUninstallDirFromReg(szPath) && ValidateUninstallFiles(szPath))
    {
        char szPath[MAX_PATH];

        // Get backup directory from registry
        if (GetUninstallDirFromReg(szPath))
        {
            DWORD dwSaveAttribs;
            char szLine[MAX_PATH];

            AddPath(szPath, c_szUNINSTALLINI);

            // c_szUNINSTALLINI has HR attribs set; GetPrivateProfileString might fail because of HR attribs.
            // set the attribs to normal and restore the original attribs at the end
            dwSaveAttribs = GetFileAttributes(szPath);
            SetFileAttributes(szPath, FILE_ATTRIBUTE_NORMAL);

            bRet = (GetPrivateProfileString(c_szIE4SECTIONNAME, lpcszFileName, "", szLine, sizeof(szLine), szPath) != 0);

            if (dwSaveAttribs != (DWORD) -1)
                SetFileAttributes(szPath, dwSaveAttribs);
        }
    }

    return bRet;
}

#define REGSTR_CCS_CONTROL_WINDOWS  REGSTR_PATH_CURRENT_CONTROL_SET "\\WINDOWS"
#define CSDVERSION      "CSDVersion"
#define NTSP6_VERSION   0x0600
// version updated to SP6!

BOOL CheckForNT4_SP6()
{
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;
    static BOOL    bNTSP6 = -1;

    if ( bNTSP6 == -1)
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            // assign the default
            bNTSP6 = FALSE;
            dwSize = sizeof(dwCSDVersion);
            if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (unsigned char*)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
            {
                bNTSP6 = (LOWORD(dwCSDVersion) >= NTSP6_VERSION);
            }
            RegCloseKey(hKey);
        }
    }
    return bNTSP6;
}

#define SP4_CRYPT32_DLL_MAJOR_VER   0x00050083  // 5.131
#define SP4_CRYPT32_DLL_MINOR_VER   0x07550005  // 1877.5 = SP6 level

BOOL FSP4LevelCryptoInstalled()
{
    static BOOL bSP4LevelCryptoInstalled = 2;

    if (bSP4LevelCryptoInstalled == 2)
    {
        OSVERSIONINFO VerInfo;

        bSP4LevelCryptoInstalled = FALSE;

        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&VerInfo);

        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            char szCrypt32DLL[MAX_PATH];

            GetSystemDirectory(szCrypt32DLL, sizeof(szCrypt32DLL));
            AddPath(szCrypt32DLL, "crypt32.dll");

            // we have to distinguish the case when a user is upgrading or reinstalling IE5; in this case,
            // backup entry for crypt32.dll would exist in ie5bak.ini and bSP4LevelCryptoInstalled should be set to FALSE
            if (VerInfo.dwMajorVersion >= 5 || CheckForNT4_SP6() || 
		(FileVerGreaterOrEqual(szCrypt32DLL, SP4_CRYPT32_DLL_MAJOR_VER, SP4_CRYPT32_DLL_MINOR_VER)  &&
                !FileBackupEntryExists(szCrypt32DLL)))
                bSP4LevelCryptoInstalled = TRUE;
        }
    }

    return bSP4LevelCryptoInstalled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\iexpress\wextract\utils.c ===
//***************************************************************************
//*     Copyright (c) Microsoft Corporation 1995. All rights reserved.      *
//***************************************************************************
//*                                                                         *
//* UTILS.C - Win32 Based Cabinet File Self-extractor and installer utils.  *
//*                                                                         *
//***************************************************************************
//*                                                                         *
//* Originally written by Jeff Webber.                                      *
//*                                                                         *
//***************************************************************************


//***************************************************************************
//* INCLUDE FILES                                                           *
//***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "wextract.h"
#include "regstr.h"
#include "global.h"
#include <commctrl.h>

static TCHAR szRegRunOnceKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce";
static TCHAR szNT4XDelayUntilReboot[] = "System\\CurrentControlSet\\Control\\Session Manager";
static TCHAR szNT4XPendingValue[] = "PendingFileRenameOperations";
static TCHAR szNT3XDelayUntilReboot[] = "System\\CurrentControlSet\\Control\\Session Manager\\FileRenameOperations";
static TCHAR szRegValNameTemplate[] = "wextract_cleanup%d";
static TCHAR szRegValTemplate[] = "%s /D:%s";
static TCHAR szRegValAdvpackTemplate[] = "rundll32.exe %sadvpack.dll,DelNodeRunDLL32 \"%s\"";
static TCHAR szBATCommand[] = "Command.com /c %s";

// store the RunOnce Clean-up reg keyname for this instance
//
TCHAR g_szRegValName[SMALL_BUF_LEN] = { 0 };
BOOL g_bConvertRunOnce = FALSE;

//***************************************************************************
//* Functions                                                               *
//***************************************************************************
typedef HRESULT (*CHECKTOKENMEMBERSHIP)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

BOOL CheckToken(BOOL *pfIsAdmin)
{
    BOOL bNewNT5check = FALSE;
    HINSTANCE hAdvapi32 = NULL;
    CHECKTOKENMEMBERSHIP pf;
    PSID AdministratorsGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    hAdvapi32 = LoadLibrary("advapi32.dll");
    if (hAdvapi32)
    {
        pf = (CHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
        if (pf)
        {
            bNewNT5check = TRUE;
            *pfIsAdmin = FALSE;
            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                pf(NULL, AdministratorsGroup, pfIsAdmin);
                FreeSid(AdministratorsGroup);
            }
        }
        FreeLibrary(hAdvapi32);
    }
    return bNewNT5check;
}

// IsNTAdmin();
// Returns true if our process has admin priviliges.
// Returns false otherwise.
BOOL IsNTAdmin()
{
      static int    fIsAdmin = 2;
      HANDLE        hAccessToken;
      PTOKEN_GROUPS ptgGroups;
      DWORD         dwReqSize;
      UINT          i;
      SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
      PSID AdministratorsGroup;
      BOOL bRet;

      //
      // If we have cached a value, return the cached value. Note I never
      // set the cached value to false as I want to retry each time in
      // case a previous failure was just a temp. problem (ie net access down)
      //

      bRet = FALSE;
      ptgGroups = NULL;

      if( fIsAdmin != 2 )
         return (BOOL)fIsAdmin;

      if (!CheckToken(&bRet))
      {
          if(!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hAccessToken ) )
             return FALSE;

          // See how big of a buffer we need for the token information
          if(!GetTokenInformation( hAccessToken, TokenGroups, NULL, 0, &dwReqSize))
          {
              // GetTokenInfo should the buffer size we need - Alloc a buffer
              if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                  ptgGroups = (PTOKEN_GROUPS) LocalAlloc(LMEM_FIXED, dwReqSize);
              
          }
          
          // ptgGroups could be NULL for a coupla reasons here:
          // 1. The alloc above failed
          // 2. GetTokenInformation actually managed to succeed the first time (possible?)
          // 3. GetTokenInfo failed for a reason other than insufficient buffer
          // Any of these seem justification for bailing.
          
          // So, make sure it isn't null, then get the token info
          if(ptgGroups && GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, dwReqSize, &dwReqSize))
          {
              if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
              {
                  
                  // Search thru all the groups this process belongs to looking for the
                  // Admistrators Group.
                  
                  for( i=0; i < ptgGroups->GroupCount; i++ )
                  {
                      if( EqualSid(ptgGroups->Groups[i].Sid, AdministratorsGroup) )
                      {
                          // Yea! This guy looks like an admin
                          fIsAdmin = TRUE;
                          bRet = TRUE;
                          break;
                      }
                  }
                  FreeSid(AdministratorsGroup);
              }
          }
          if(ptgGroups)
              LocalFree(ptgGroups);

          // BUGBUG: Close handle here? doc's aren't clear whether this is needed.
          CloseHandle(hAccessToken);
      }
      else if (bRet)
          fIsAdmin = TRUE;

      return bRet;
}


//**************************************************************************
//
// WarningDlgProc()
//
// Dialog proc for handling a continue/Exit dialog.
//
//**************************************************************************

INT_PTR CALLBACK WarningDlgProc( HWND hwnd, UINT msg,WPARAM wParam, LPARAM lParam)
{
   char szMsg[MAX_STRING];

   switch( msg )
   {
     case WM_INITDIALOG:
        CenterWindow( hwnd, GetDesktopWindow() );
        *szMsg = 0;
        LoadString(g_hInst, (UINT)lParam, szMsg, sizeof(szMsg));
        SetDlgItemText(hwnd, IDC_WARN_TEXT, szMsg);
        MessageBeep((UINT)-1);
        return( TRUE );     // Let default control be chosen.

     case WM_COMMAND:
        switch( wParam )
        {
           case IDC_EXIT:
           case IDC_CONTINUE:
              EndDialog( hwnd, wParam );
              break;

           default:
              return FALSE;
        }
        return TRUE;

     default:
        break;
    }
    return( FALSE );            // Let default dialog processing do all.
}

// returns start of next field (or null if null), sets start to begining of the first field,
// with fields separated by separaters and nulls first separater after the first field
TCHAR* ExtractField( TCHAR **pstart, TCHAR * separaters)
{
    LPTSTR start = *pstart;
    int x = 0;

    while(ANSIStrChr(separaters, *start)) {
        if(*start == 0)
            return(NULL);
        start++;
        }

    *pstart = start;

    while(!ANSIStrChr(separaters, start[x]) && (start[x] != 0))
        x++;

    if(start[x] == 0)
        return(start + x);

    start[x] = 0;
    return(start + x + 1);
}


BOOL AnalyzeCmd( LPTSTR szOrigiCommand, LPTSTR *lplpCommand, BOOL *pfInfCmd )
{
    TCHAR szTmp[MAX_PATH];
    TCHAR szINFFile[MAX_PATH];
    LPTSTR szNextField, szCurrField, szExt;
    UINT   secLength;
    LPTSTR lpTempCmd, pszINFEngine;

    lstrcpy( szTmp, szOrigiCommand );

    // check if the command is LFN name
    if ( szTmp[0] == '"' )
    {
        szCurrField = &szTmp[1];
        szNextField = ExtractField( &szCurrField, "\"" );
    }
    else
    {
        szCurrField = szTmp;
        szNextField = ExtractField( &szCurrField, " " );
    }

    if ( !IsRootPath( szCurrField ) )
    {
        // BUGBUG: when IsRootPath Failed, we did not check if the givn
        // szCurrField is valid name or not.  If it is not valid, the result
        // of the AddPath will produce invalid file path.  The error will come out at
        // either SETUP engine or CreateProcess
        //
        lstrcpy( szINFFile, g_Sess.achDestDir );
        AddPath( szINFFile, szCurrField );
    }
    else
        lstrcpy( szINFFile, szCurrField );

    // check if this is a INF file command
    if ( ((szExt = ANSIStrRChr( szCurrField, '.' )) != NULL) && !lstrcmpi( szExt, ".INF" ) )
    {
	// check to see if this valid command
	if ( !FileExists( szINFFile ) )
        {
            ErrorMsg1Param( NULL, IDS_ERR_FILENOTEXIST, szINFFile );
	    return FALSE;
        }	        

        // check if there is INF section install, and get the sec start point
        szCurrField = szNextField;
        szNextField = ExtractField( &szCurrField, "[" );  // skip things between .INF and [ section beginning

        secLength = lstrlen( achDefaultSection );

        if ( szNextField )
        {
            // in the case of: .INF<single-blank>[abc]
            // the szNextField is "" while in the case of: .INF<multiple-blanks>[abc]
            // szNextField points to "abc]".  Therefore, the conditional pointer switch added here
            //
            if ( *szNextField )
            {
                szCurrField = szNextField;
            }

            szNextField = ExtractField( &szCurrField, "]" );  // get INF InstallSection name

            if ( *szCurrField )
            {
                secLength = lstrlen( szCurrField );
            }
        }

        lpTempCmd = (LPSTR) LocalAlloc( LPTR, 512);

        if ( ! lpTempCmd )
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            return FALSE;
        }

        // store INF name for reboot checking use
        g_uInfRebootOn = GetPrivateProfileInt( *szCurrField ? szCurrField : achDefaultSection, "Reboot", 0, szINFFile );
        *pfInfCmd = TRUE;  // no RunOnce entry needed

        // check if we need use Advanced INF dll handling
        if ( GetPrivateProfileString( SEC_VERSION, KEY_ADVINF, "", lpTempCmd, 8, szINFFile )
             > 0 )
        {
            g_Sess.uExtractOpt |= EXTRACTOPT_ADVDLL;

            // re-use the buf here
            lstrcpy( szOrigiCommand, *szCurrField ? szCurrField : achDefaultSection );
            lstrcpy( lpTempCmd, szINFFile );
        }
        else
        {
            g_Sess.uExtractOpt &= ~(EXTRACTOPT_ADVDLL);

            if (g_wOSVer == _OSVER_WIN9X)
            {
                pszINFEngine = "setupx.dll";
                GetShortPathName( szINFFile, szINFFile, sizeof(szINFFile) );
            }
            else
                pszINFEngine = "setupapi.dll";

            wsprintf( lpTempCmd, achSETUPDLL, pszINFEngine,
                      *szCurrField ? szCurrField : achDefaultSection, szINFFile );
        }
    }
    else if ( ((szExt = ANSIStrRChr( szCurrField, '.' )) != NULL) && !lstrcmpi( szExt, ".BAT" ) )
    {
        lpTempCmd = (LPSTR) LocalAlloc( LPTR, lstrlen( szBATCommand ) + lstrlen( szINFFile ) + 8 );
        if ( ! lpTempCmd )
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            return FALSE;
        }

        wsprintf( lpTempCmd, szBATCommand, szINFFile );
    }
    else
    {
        // assume EXE command
        // you are here, the szINFFile contains the command with fully qualified pathname enterred either
        // by User or appended by wextract.exe to Temp extracting file location.

        DWORD dwAttr;
        CHAR  szCmd[2*MAX_STRING]; 
        
        lpTempCmd = (LPSTR) LocalAlloc( LPTR, 2*MAX_STRING );   // 1K buf
        if ( ! lpTempCmd )
        {
            ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
            return FALSE;
        }

        dwAttr = GetFileAttributes( szINFFile );
        if ( (dwAttr == -1) || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
        {
            // file is not found as it IS.  Run it as it WAS!
            // IS and WAS may be the same if user enterred fully qaulified name.  CreateProcess will buff it.
            lstrcpy( szCmd, szOrigiCommand );
        }
        else
        {
            // found it.  Run it as it IS.  Need to append switches if there is any.
            lstrcpy( szCmd, szINFFile );
            if ( szNextField && *szNextField )
            {         
                lstrcat( szCmd, " " );
                lstrcat( szCmd, szNextField );
            }
        }
        // replace the #D with the directory this module is loaded or  
        // #E with the fullpath of the running EXE
        ExpandCmdParams( szCmd, lpTempCmd );

    }

    *lplpCommand = lpTempCmd;

    return TRUE;
}

void DisplayHelp()
{
    MsgBox1Param( NULL, IDS_HELPMSG, "", MB_ICONINFORMATION, MB_OK  );
}


DWORD CheckReboot( VOID )
{
    DWORD dwReturn = 0xFFFFFFFF;

    if ( !g_uInfRebootOn )
    {
        if (NeedReboot(g_dwRebootCheck, g_wOSVer))
            dwReturn = EWX_REBOOT;

    }
    else
        dwReturn = EWX_REBOOT;    // reboot = 1 in inf file

    return dwReturn;

}

// NT reboot
//
BOOL MyNTReboot()
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;

    // get a token from this process
    if ( !OpenProcessToken( GetCurrentProcess(),
                            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
    {
         ErrorMsg( NULL, IDS_ERR_OPENPROCTK );
         return FALSE;
    }

    // get the LUID for the shutdown privilege
    LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //get the shutdown privilege for this proces
    if ( !AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 ) )
    {
        ErrorMsg( NULL, IDS_ERR_ADJTKPRIV );
        return FALSE;
    }

    // shutdown the system and force all applications to close
    if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
    {
        ErrorMsg( NULL, IDS_ERR_EXITWINEX );
        return FALSE;
    }

    return TRUE;
}


// Display a dialog asking the user to restart Windows, with a button that
// will do it for them if possible.
//
void MyRestartDialog( DWORD dwRebootMode )
{
    UINT    id = IDCANCEL;
    DWORD   dwReturn;

    // only if you checked and REBOOT_YES is true, you are here
    if (  dwRebootMode & REBOOT_ALWAYS )
    {
           dwReturn = EWX_REBOOT;
    }
    else
    {
        dwReturn = CheckReboot();
    }

    if ( dwReturn == EWX_REBOOT )
    {
        if ( dwRebootMode & REBOOT_SILENT )
            id = IDYES;
        else
        {
            id = MsgBox1Param( NULL, IDS_RESTARTYESNO, "", MB_ICONINFORMATION, MB_YESNO );
        }

        if ( id == IDYES )
        {
            if ( dwReturn == EWX_REBOOT )
            {
                if ( g_wOSVer == _OSVER_WIN9X )
                {
                    // By default (all platforms), we assume powerdown is possible
                    id = ExitWindowsEx( EWX_REBOOT, 0 );
                }
                else
                {
                    MyNTReboot();
                }
            }

        }
    }
    return;
}


// CleanRegRunOnce()
//
void CleanRegRunOnce()
{
    HKEY hKey;

    if ( g_szRegValName[0] == 0 )
    {
        return;
    }

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegRunOnceKey, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS )
    {
        RegDeleteValue( hKey, g_szRegValName );
        RegCloseKey( hKey );
    }
    return;
}


void AddRegRunOnce()
{
    HKEY hKey;
    DWORD dwDisposition;
    LPSTR szRegEntry;
    TCHAR szBuf[MAX_PATH] = "";
    TCHAR szAdvpack[MAX_PATH] = "";
    int   i;
    DWORD dwTmp;
    HANDLE hSetupLibrary;
    BOOL fUseAdvpack = FALSE;

    // prepare backup registry
    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegRunOnceKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
    {
        // reg problem, but not block the process
        return;
    }

    // Check if key already exists -- if so, go with next number.
    //
    for (i=0; i<200; i++)
    {
        wsprintf( g_szRegValName, szRegValNameTemplate, i );

        if ( RegQueryValueEx( hKey, g_szRegValName, 0, NULL, NULL, &dwTmp ) != ERROR_SUCCESS )
        {
            // g_szRegValName now has the key name we need for this instance
            break;
        }
    }

    if ( i == 200 )
    {
        // something is wrong, there are at lease 200 RunOnce enteries in the Registry
        // bail out, don't add any more
        RegCloseKey( hKey );
        g_szRegValName[0] = 0;
        return;
    }

    // check if ADVPACK in the system dir exports DelNodeRunDLL32;
    // if so, use szRegValAdvpackTemplate, otherwise, use szRegValTemplate
    GetSystemDirectory(szAdvpack, sizeof(szAdvpack));
    AddPath(szAdvpack, ADVPACKDLL);
    if ((hSetupLibrary = LoadLibrary(szAdvpack)) != NULL)
    {
        fUseAdvpack = GetProcAddress(hSetupLibrary, "DelNodeRunDLL32") != NULL;
        FreeLibrary(hSetupLibrary);
    }

    if (fUseAdvpack)
    {
        if (GetSystemDirectory(szBuf, sizeof(szBuf)))
            AddPath(szBuf, "");
    }
    else
    {
        // get current EXE filename
        //
        if ( !GetModuleFileName( g_hInst, szBuf, (DWORD)sizeof(szBuf) ) )
        {
             RegCloseKey( hKey );
             return;
        }
    }

    // alloc mem for store reg entry values
    //
    szRegEntry = (LPSTR) LocalAlloc( LPTR, lstrlen(szBuf) + lstrlen(g_Sess.achDestDir) + SMALL_BUF_LEN );

    if ( !szRegEntry )
    {
        ErrorMsg( NULL, IDS_ERR_NO_MEMORY );
        RegCloseKey( hKey );
        return;
    }

    g_bConvertRunOnce = !fUseAdvpack;

    wsprintf(szRegEntry, fUseAdvpack ? szRegValAdvpackTemplate : szRegValTemplate, szBuf, g_Sess.achDestDir);

    RegSetValueEx( hKey, g_szRegValName, 0, REG_SZ, (CONST BYTE*)szRegEntry, lstrlen(szRegEntry)+1);

    RegCloseKey(hKey);
    LocalFree( szRegEntry );
    return;
}

// Change the RunOnce entry that cleans up extracted files to use ADVPACK instead of wextract
void ConvertRegRunOnce()
{
    if (*g_szRegValName)
    {
        HKEY hKey;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegRunOnceKey, 0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            TCHAR szRegEntry[2 * MAX_PATH + sizeof(szRegValAdvpackTemplate)];
            DWORD dwSize = sizeof(szRegEntry);

            // read the old value data that uses wextract and get the extracted files dir
            if (RegQueryValueEx(hKey, g_szRegValName, NULL, NULL, (LPBYTE) szRegEntry, &dwSize) == ERROR_SUCCESS)
            {
                TCHAR szSysDir[MAX_PATH] = "";

                if (GetSystemDirectory(szSysDir, sizeof(szSysDir)))
                    AddPath(szSysDir, "");

                wsprintf(szRegEntry, szRegValAdvpackTemplate, szSysDir, g_Sess.achDestDir);
                RegSetValueEx(hKey, g_szRegValName, 0, REG_SZ, (CONST BYTE *) szRegEntry, lstrlen(szRegEntry) + 1);
            }

            RegCloseKey(hKey);
        }
    }

    return;
}

void DeleteMyDir( LPSTR lpDir )
{
    char szFile[MAX_PATH];
    WIN32_FIND_DATA fileData;
    HANDLE hFindFile;

    if ( lpDir == NULL  ||  *lpDir == '\0' )
        return;

    lstrcpy( szFile, lpDir );
    lstrcat( szFile, "*" );
    hFindFile = FindFirstFile( szFile, &fileData );
    if ( hFindFile == INVALID_HANDLE_VALUE )
        return;

    do
    {
        lstrcpy( szFile, lpDir );

        if ( fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( fileData.cFileName, "." ) == 0  ||
                 lstrcmp( fileData.cFileName, ".." ) == 0 )
                continue;

            // delete the sub-dir
            lstrcat( szFile, fileData.cFileName );
            AddPath( szFile, "");
            DeleteMyDir( szFile );
        }
        else
        {
            // delete the file
            lstrcat( szFile, fileData.cFileName );
            SetFileAttributes( szFile, FILE_ATTRIBUTE_NORMAL );
            DeleteFile( szFile );
        }
    } while ( FindNextFile( hFindFile, &fileData ) );

    FindClose( hFindFile  );
    RemoveDirectory( lpDir );
}



#if 0
//==================================================================
// AddPath()
//
void AddPath(LPSTR szPath, LPCSTR szName )
{
    LPSTR szTmp;

        // Find end of the string
    szTmp = szPath + lstrlen(szPath);

        // If no trailing backslash then add one
    if ( szTmp > szPath && *(AnsiPrev( szPath, szTmp )) != '\\' )
        *(szTmp++) = '\\';

        // Add new name to existing path string
    while ( *szName == ' ' ) szName++;
    lstrcpy( szTmp, szName );
}

#endif

//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// check if a path is a root path
//
// returns:
//  TRUE for "X:\..." "\\foo\asdf\..."
//  FALSE for others

BOOL IsRootPath(LPCSTR pPath)
{
    if ( !pPath || (lstrlen(pPath) < 3) )
    {
        return FALSE;
    }

    // BUGBUG: this just smell like UNC, possible invalid UNC. If so,
    // user will get error when later create process

    if ( ( (*(pPath+1) == ':') && (*(pPath+2) == '\\') ) ||         // "X:\" case
         ( (*pPath == '\\') && (*(pPath + 1) == '\\' ) ) )          // UNC \\.... case
        return TRUE;
    else
        return FALSE;
}

// BUGBUG:BUGBUG:BUGBUG:BUGBUG
// The code below is duplicated in advpack.dll. If you do changed/fixes to this code
// make sure to also change the code in advpack.dll


// Returns the size of wininit.ini in the windows directory.
// 0 if not found
DWORD GetWininitSize()
{
    TCHAR   szPath[MAX_PATH];
    HFILE   hFile;
    DWORD   dwSize = (DWORD)0;
    if ( GetWindowsDirectory( szPath, MAX_PATH ) )
    {
        AddPath( szPath, "wininit.ini" );

        // Make sure all changes have been saved to disk for accurate size reading
        WritePrivateProfileString(NULL, NULL, NULL, szPath);

        if ((hFile = _lopen(szPath, OF_READ|OF_SHARE_DENY_NONE)) != HFILE_ERROR)
        {
            dwSize = _llseek(hFile, 0L, FILE_END);
            _lclose(hFile);
        }
    }
    return dwSize;
}

// Returns the size of the value lpcszValue under lpcszRegKey
// 0 if the registry key or the value were not found
DWORD GetRegValueSize(LPCSTR lpcszRegKey, LPCSTR lpcszValue)
{
    HKEY        hKey;
    DWORD       dwValueSize = (DWORD)0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpcszRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, lpcszValue, NULL, NULL, NULL,&dwValueSize) != ERROR_SUCCESS)
            dwValueSize = (DWORD)0;
        RegCloseKey(hKey);
    }
    return dwValueSize;
}

// Returns the number of Values in the key
// 0 if the registry key was not found or RegQueryInfoKey failed
DWORD GetNumberOfValues(LPCSTR lpcszRegKey)
{
    HKEY        hKey;
    DWORD       dwValueSize = (DWORD)0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpcszRegKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryInfoKey(hKey,
                            NULL, NULL, NULL, NULL, NULL, NULL,
                            &dwValueSize,
                            NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            dwValueSize = (DWORD)0;
        RegCloseKey(hKey);
    }
    return dwValueSize;
}

// Returns the rebootcheck value depending on the OS we get passed in.
DWORD NeedRebootInit(WORD wOSVer)
{
    DWORD   dwReturn = (DWORD)0;

    switch (wOSVer)
    {
        case _OSVER_WIN9X:
            dwReturn = GetWininitSize();
            break;

        case _OSVER_WINNT40:
        case _OSVER_WINNT50:
            dwReturn = GetRegValueSize(szNT4XDelayUntilReboot, szNT4XPendingValue);
            break;

        case _OSVER_WINNT3X:
            dwReturn = GetNumberOfValues(szNT3XDelayUntilReboot);
            break;

    }
    return dwReturn;
}

// Checks the passed in reboot check value against the current value.
// If they are different, we need to reboot.
// The reboot check value is dependend on the OS
BOOL NeedReboot(DWORD dwRebootCheck, WORD wOSVer)
{
    return (dwRebootCheck != NeedRebootInit(wOSVer));
}

// check if Dir does not exist, create one.
//
BOOL IfNotExistCreateDir( LPTSTR lpDir )
{
    DWORD attr;

    if ( (attr = GetFileAttributes( lpDir )) == -1  )
    {
        return ( CreateDirectory( lpDir, NULL ) );
    }

    return (attr & FILE_ATTRIBUTE_DIRECTORY);
}

// check if the given dir is on Windows Drive
//
BOOL IsWindowsDrive( LPTSTR szPath )
{
    TCHAR szWin[MAX_PATH];

    if ( !GetWindowsDirectory( szWin, MAX_PATH ) )
    {
        ErrorMsg( NULL, IDS_ERR_GET_WIN_DIR );
        ASSERT( FALSE );
    }

    return ( *szPath == szWin[0] );
}

PSTR MyULtoA( ULONG ulParam, PSTR pszOut )
{
    wsprintf( pszOut, "%lu", ulParam );
    return pszOut;
}

// display diskspace checking Error message
// it always return FALSE except that User answer YES on msgbox
//
BOOL DiskSpaceErrMsg( UINT msgType, ULONG ulExtractNeeded, DWORD dwInstNeeded, LPTSTR lpDrv )
{
    TCHAR szSize[10];
    BOOL  bRet = FALSE;

    // all the cases except one are returning FALSE, so we set Error code here
    g_dwExitCode = ERROR_DISK_FULL;

    if ( msgType == MSG_REQDSK_ERROR )
    {
        ErrorMsg1Param( NULL, IDS_ERR_NO_SPACE_ERR, MyULtoA((ulExtractNeeded+dwInstNeeded), szSize) );
    }
    else if ( msgType == MSG_REQDSK_RETRYCANCEL )
    {
        if ( MsgBox1Param( NULL, IDS_ERR_NO_SPACE_BOTH, MyULtoA( (ulExtractNeeded+dwInstNeeded), szSize),
                      MB_ICONQUESTION, MB_RETRYCANCEL|MB_DEFBUTTON1 ) == IDRETRY )
            bRet = TRUE;
        else
            bRet = FALSE;
    }
    else if ( msgType == MSG_REQDSK_WARN )
    {
        // in /Q mode: MsgBox2Param return MB_OK which is not IDYES, so we fail the process.
        //
        if ( MsgBox2Param( NULL, IDS_ERR_NO_SPACE_INST, MyULtoA(dwInstNeeded, szSize), lpDrv,
                           MB_ICONINFORMATION, MB_YESNO | MB_DEFBUTTON2 ) == IDYES )
        {
            bRet = TRUE;
            g_dwExitCode = S_OK;
        }
    }
    //else ( msgType == MSG_REQDSK_NONE ) do nothing

    return bRet;
}

BOOL GetFileTobeChecked( LPSTR szPath, int iSize, LPCSTR szNameStr )
{
    char ch;
    BOOL bComplete = FALSE;    
    
    szPath[0] = 0;
    if ( *szNameStr == '#' )
    {
        ch = (CHAR)CharUpper((PSTR)*(++szNameStr));
        szNameStr = CharNext( CharNext( szNameStr ) );

        switch ( ch )
        {
            case 'S':
                GetSystemDirectory( szPath, iSize );
                break;

            case 'W':
                GetWindowsDirectory( szPath, iSize );
                break;

            case 'A':
            default:
                {
                    // look into reg AppPath
                    char szSubKey[MAX_PATH];
                    DWORD dwSize = sizeof( szSubKey );
                    HKEY  hKey;
					DWORD dwType;
                
                    lstrcpy( szSubKey, REGSTR_PATH_APPPATHS );
                    AddPath( szSubKey, szNameStr );
                
                    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &hKey ) == ERROR_SUCCESS )
                    {                        
                        if ( RegQueryValueEx(hKey, "", NULL, &dwType, (LPBYTE)szPath, &dwSize) == ERROR_SUCCESS )                    
						{                            
							if ((dwType == REG_EXPAND_SZ) &&
								(ExpandEnvironmentStrings(szPath, szSubKey, sizeof(szSubKey))))
							{
								lstrcpy(szPath, szSubKey);
								bComplete = TRUE;
							}
							else if (dwType == REG_SZ)
								bComplete = TRUE;
						}

                        RegCloseKey( hKey );
                    }
                }
                break;

        }
    }
    else
        GetSystemDirectory( szPath, iSize );

    if ( !bComplete )
        AddPath( szPath, szNameStr );

    return TRUE;
}


BOOL CheckFileVersion( PTARGETVERINFO ptargetVers, LPSTR szPath, int isize, int *pidx )
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR    *lpBuffer;
    HGLOBAL     hgbl = NULL;
    BOOL        bRet = FALSE;
    int         ifrAnswer[2], itoAnswer[2], i, j;
    PVERCHECK   pfileV;

    for ( i=0; i< (int)(ptargetVers->dwNumFiles); i++ )
    {    
        pfileV = (PVERCHECK)( ptargetVers->szBuf + ptargetVers->dwFileOffs + i*sizeof(VERCHECK) ); 
        if ( !GetFileTobeChecked( szPath, isize, (ptargetVers->szBuf + pfileV->dwNameOffs) ) )
            goto EXIT;

        dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwHandle);
        if (dwVerInfoSize)
        {
            // Alloc the memory for the version stamping
            hgbl = GlobalAlloc(GHND, dwVerInfoSize);
            if (hgbl == NULL)
                goto EXIT;

            lpBuffer = GlobalLock(hgbl);
            if (lpBuffer == NULL)
                goto EXIT;
            // Read version stamping info
            if (GetFileVersionInfo(szPath, dwHandle, dwVerInfoSize, lpBuffer))
            {
                // Get the value for Translation
                if ( VerQueryValue(lpBuffer, "\\", (void FAR*FAR*)&lpVSFixedFileInfo, &uiSize) && (uiSize) )
                {
                    for ( j=0; j<2; j++ )
                    {
                        ifrAnswer[j] = CompareVersion( lpVSFixedFileInfo->dwFileVersionMS, lpVSFixedFileInfo->dwFileVersionLS,
                                                    pfileV->vr[j].frVer.dwMV, pfileV->vr[j].frVer.dwLV );
                        itoAnswer[j] = CompareVersion( lpVSFixedFileInfo->dwFileVersionMS, lpVSFixedFileInfo->dwFileVersionLS,
                                                    pfileV->vr[j].toVer.dwMV, pfileV->vr[j].toVer.dwLV );
                
                    }

                    if ( (ifrAnswer[0] >= 0 && itoAnswer[0] <= 0) || (ifrAnswer[1] >= 0 && itoAnswer[1] <= 0) ) 
                        ;
                    else
                    {
                        GlobalUnlock(hgbl);
                        goto EXIT;
                    }

                }
            }
            GlobalUnlock(hgbl);
        }
        else
        {
            // file not exist case, if author specify install 1st ranges from version 0 to 0.  Then do it!
            if ( pfileV->vr[0].frVer.dwMV || pfileV->vr[0].frVer.dwLV )
            {
                goto EXIT;
            }
        }
    }
    
    bRet = TRUE;

EXIT:
    *pidx = i;
    if ( hgbl )
        GlobalFree( hgbl );

    return bRet;
}

UINT GetMsgboxFlag( DWORD dwFlag )
{
    UINT uButton;

    if ( dwFlag & VERCHK_YESNO )
        uButton = MB_YESNO | MB_DEFBUTTON2;
    else if ( dwFlag & VERCHK_OKCANCEL )
        uButton = MB_OKCANCEL | MB_DEFBUTTON2;
    else
        uButton = MB_OK;

    return uButton;
}

int CompareVersion(DWORD dwMS1, DWORD dwLS1, DWORD dwMS2, DWORD dwLS2)
{
    if (dwMS1 < dwMS2)
        return -1 ;

    if (dwMS1 > dwMS2)
        return 1 ;

    if (dwLS1 < dwLS2)
        return -1 ;

    if (dwLS1 > dwLS2)
        return 1 ;

    return 0 ;
}

void ExpandCmdParams( PCSTR pszInParam, PSTR pszOutParam )
{
    CHAR szModulePath[MAX_PATH];
    LPSTR pszTmp;	

    *pszOutParam = '\0';

    if ( !pszInParam || !*pszInParam )
        return;

    // get Module path
    GetModuleFileName( g_hInst, szModulePath, (DWORD)sizeof(szModulePath) );
                                               
    while ( *pszInParam != '\0'  )
    {
	if (IsDBCSLeadByte(*pszInParam))
	{
	    *pszOutParam = *pszInParam;
	    *(pszOutParam+1) = *(pszInParam+1);
	}
	else
            *pszOutParam = *pszInParam;

        if ( *pszInParam == '#' )
        {
            pszInParam = CharNext(pszInParam);    
            if ( (CHAR)CharUpper((PSTR)*pszInParam) == 'D' )
            {
                GetParentDir( szModulePath );     
		pszTmp = CharPrev(szModulePath, &szModulePath[lstrlen(szModulePath)]);
                if (pszTmp && (*pszTmp  == '\\'))
                    *pszTmp = '\0';
                lstrcpy( pszOutParam, szModulePath );
                pszOutParam += lstrlen( szModulePath );
            }
            else if ( (CHAR)CharUpper((PSTR)*pszInParam) == 'E' )
            {
                lstrcpy( pszOutParam, szModulePath );
                pszOutParam += lstrlen( szModulePath );
            }
            else if ( *pszInParam == '#' )
                pszOutParam = CharNext( pszOutParam );
        }
        else
            pszOutParam = CharNext( pszOutParam );

        pszInParam = CharNext(pszInParam);
    }

    *pszOutParam = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\fileexst.c ===
#include <windows.h>
//=========================================================================================
//  FileExists
//		pszFilename  file to be checked		
//
//	Return
//		TRUE	file exists.
//		FALSE	file does not exist.
//
//=========================================================================================

BOOL FileExists( PCSTR pszFilename )
{
   DWORD attr;
   
   // No null filename
   attr = GetFileAttributes(pszFilename);
   if( attr == 0xFFFFFFFF )
      return FALSE;

   return !(attr & FILE_ATTRIBUTE_DIRECTORY);
}

//***************************************************************************
//*                                                                         *
//* NAME:       FileSize                                                    *
//*                                                                         *
//* SYNOPSIS:                                                               *
//*                                                                         *
//* REQUIRES:                                                               *
//*                                                                         *
//* RETURNS:                                                                *
//*                                                                         *
//***************************************************************************
/*
DWORD FileSize( PCSTR pszFile )
{
    HFILE hFile;
    OFSTRUCT ofStru;
    DWORD dwSize = 0;

    if ( *pszFile == 0 )
        return 0;

    hFile = OpenFile( pszFile, &ofStru, OF_READ );
    if ( hFile != HFILE_ERROR )
    {
        dwSize = GetFileSize( (HANDLE)hFile, NULL );
        _lclose( hFile );
    }

    return dwSize;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\nexttok.c ===
#include <windows.h>
#include <sdsutils.h>

// If the next token in *pszData is delimited by the DeLim char, replace DeLim
//   in *pszData by chEos, set *pszData to point to the char after the chEos and return
//   ptr to the beginning of the token; otherwise, return NULL

PSTR GetNextToken( PSTR *pszData, char DeLim)
{
    PSTR szPos;

    if ( (pszData == NULL)  ||  (*pszData == NULL)  ||  (**pszData == '\0') )
	    return NULL;

    if ((szPos = ANSIStrChr( *pszData, DeLim ) ) != NULL)
    {
    	PSTR szT = *pszData;
	
	// replace DeLim with the chEos char
	*szPos = '\0';                 
    	*pszData = szPos + 1;
    	szPos = szT;
    }
    else                                
    {
	// DeLim not found; set *pszData to point to
        // to the end of szData; the next invocation
        // of this function would return NULL

 	szPos = *pszData;
    	*pszData = szPos + lstrlen(szPos);
    }

    return szPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\regdel.c ===
#include <windows.h>

LONG RegDeleteKeyRecursively(HKEY hkRootKey, PCSTR pcszSubKey)
{
    LONG lErr;

    if ((lErr = RegDeleteKey(hkRootKey, pcszSubKey)) != ERROR_SUCCESS)
    {
        HKEY hkSubKey;

        // delete the key recursively

        if ((lErr = RegOpenKeyEx(hkRootKey, pcszSubKey, 0, KEY_READ | KEY_WRITE, &hkSubKey)) == ERROR_SUCCESS)
        {
            CHAR szSubKeyName[MAX_PATH + 1];
            DWORD dwIndex;

            if ((lErr = RegQueryInfoKey(hkSubKey, NULL, NULL, NULL, &dwIndex, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
                while (RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, sizeof(szSubKeyName)) == ERROR_SUCCESS)
                    RegDeleteKeyRecursively(hkSubKey, szSubKeyName);

            RegCloseKey(hkSubKey);

            lErr = RegDeleteKey(hkRootKey, pcszSubKey);
        }
    }

    return lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\grpconv.c ===
#include <windows.h>
#include <regstr.h>
#include "sdsutils.h"

#define SETUP_INI   "setup.ini"
#define RENAMEFILES "RenameFiles"
#define DELETEFILES "DeleteFiles"
#define RECONVRENAMEFILES "PreConvRenameFiles"
// REGSTR_PATH_SETUP = Software\Microsoft\Windows\CurrentVersion



BOOL CheckGrpconvRegkey(LPSTR lpSubKey)
{
    BOOL bRunGrpConv = FALSE;
    char szKey[MAX_PATH];
    char szFile[MAX_PATH];
    char szName[MAX_PATH];
    char szData[MAX_PATH];
    char *pTemp;
    char *pSep;
    HKEY hKey;
    HKEY hSubKey;
    DWORD dwKeyIndex = 0;
    DWORD dwFileIndex = 0;
    DWORD dwSize;
    DWORD dwNameSize;
    DWORD dwDataSize;
    DWORD dwAttrib;

    lstrcpy(szKey, REGSTR_PATH_SETUP);
    AddPath(szKey, lpSubKey);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        while (!bRunGrpConv && 
               (RegEnumKey(hKey, dwKeyIndex, szKey, sizeof(szKey)) == ERROR_SUCCESS))
        {
            dwSize = sizeof(szFile);
            if ((RegOpenKeyEx(hKey, szKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS) &&
                (ERROR_SUCCESS == RegQueryValueEx(hSubKey, NULL, NULL, NULL, (LPBYTE) szFile, &dwSize)))
            {
                // szFile contains now the path.
                pTemp = szFile + lstrlen(szFile);
                dwFileIndex = 0;
                dwNameSize = sizeof(szName);
                dwDataSize = sizeof(szData);
                while (!bRunGrpConv && 
                       (RegEnumValue(hSubKey, dwFileIndex, szName, &dwNameSize, NULL, NULL,
                                    szData, &dwDataSize) == ERROR_SUCCESS) )
                {
                    if (dwNameSize)
                    {
                        *pTemp = '\0';
                        AddPath(szFile, szName);
                        dwAttrib = GetFileAttributes(szFile);
                        if (dwAttrib != (DWORD)-1)
                        {
                            // we have to check the data to see if this entry was processed
                            pSep = ANSIStrChr(szData, ',');
                            if (pSep)
                            {
                                *pSep = '\0';
                                pSep++;
                                bRunGrpConv = !(dwAttrib & (DWORD)AtoL(pSep));
                            }
                            else
                                bRunGrpConv = TRUE;

                        }
                    }
                    dwNameSize = sizeof(szName);
                    dwDataSize = sizeof(szData);
                    dwFileIndex++;
                }
                RegCloseKey(hSubKey);
            }
            dwKeyIndex++;
        }

        RegCloseKey(hKey);
    }
    return bRunGrpConv;
}

#if 0
BOOL IsNT5orHigher()
{
    OSVERSIONINFO verinfo;        
    BOOL bRet = FALSE;

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&verinfo))
    {
        if ((verinfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (verinfo.dwMajorVersion >= 5))
        {
            bRet = TRUE;
        }
    }
    return bRet;
}
#endif

BOOL NeedToRunGrpconv()
{
    BOOL bRunGrpConv = FALSE;
    char szTemp[MAX_PATH];
    // check if grpconv -o needs to be run.
    // a) setup.ini in the windows directory exists
    // b) HKLM\Software\Microsoft\Windows\CurrentVersion\RenameFiles exist
    // c) HKLM\Software\Microsoft\Windows\CurrentVersion\DeleteFiles exist

    GetWindowsDirectory(szTemp, sizeof(szTemp));
    AddPath(szTemp, SETUP_INI);
    bRunGrpConv = (GetFileAttributes(szTemp) != (DWORD)-1);
    if (!bRunGrpConv)
    {
        // need check user profile directory
        if (ExpandEnvironmentStrings("%USERPROFILE%", szTemp, sizeof(szTemp)))
        {                    
            AddPath(szTemp, SETUP_INI);
            bRunGrpConv = (GetFileAttributes(szTemp) != (DWORD)-1);                
        }
    }

    if (!bRunGrpConv)
    {
        bRunGrpConv = CheckGrpconvRegkey(RENAMEFILES);
    }
    if (!bRunGrpConv)
    {
        bRunGrpConv = CheckGrpconvRegkey(DELETEFILES);
    }
    if (!bRunGrpConv)
    {
        bRunGrpConv = CheckGrpconvRegkey(RECONVRENAMEFILES);
    }
    return bRunGrpConv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\sdsutils.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Libinc.h
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _SDSUTILS_H_
#define _SDSUTILS_H_



#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define IsSpace(c)  ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
#define IsAlpha(c)  ( ((c) >= 'A'  &&  (c) <= 'Z') || ((c) >= 'a'  &&  (c) <= 'z'))

// flags for import proxy function
#define IMPTPROXY_CALLAFTIE4	0x00000001
#define NS_NAVI4        	0x00040000
#define NS_NAVI3ORLESS  	0x00030000

// define constance used by multiple setup binaries
extern const char c_gszPre_DEFAULTBROWSER[];
extern const char c_gszNavigator3[];
extern const char c_gszNavigator4[];
extern const char c_gszInternetExplorer[];
 
BOOL ChrCmpA_inline(WORD w1, WORD wMatch);
LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch);
LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch);
LPSTR FAR ANSIStrChrI(LPCSTR lpStart, WORD wMatch);

long AtoL(const char *nptr);
PSTR ULtoA( unsigned long val, char *buf, int radix );

//DWORD FileSize( PCSTR pszFile );
BOOL FileExists( PCSTR pszFilename );
VOID AddPath(LPSTR szPath, LPCSTR szName );
unsigned long StrToUL (const char *nptr, char **endptr,int ibase);
LPSTR GetNextToken( PSTR *ppstr, char Delim );
BOOL GetParentDir( LPSTR szFolder );

PSTR ANSIStrStr(LPCSTR lpFirst, LPCSTR lpSrch);
PSTR ANSIStrStrI(LPCSTR lpFirst, LPCSTR lpSrch);

void DoPatchLoadBalancingForNetware(BOOL fRunningOnWin9X);
void MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
void ImportNetscapeProxySettings(DWORD);
BOOL IsIEDefaultBrowser();
DWORD GetNetScapeVersion();

LONG RegDeleteKeyRecursively(HKEY hkRootKey, PCSTR pcszSubKey);
void ConvertVersionString(LPCSTR pszVer, WORD rwVer[], CHAR ch);
DWORD GetSpace( LPTSTR szPath );
DWORD GetDriveSize( LPTSTR szPath );
DWORD GetDrvFreeSpaceAndClusterSize( LPSTR szPath, LPDWORD lpdwClustSize );
BOOL NeedToRunGrpconv();

extern const char c_szUNINSTALLDAT[];       // "ie5bak.dat"
extern const char c_szUNINSTALLINI[];       // "ie5bak.ini"
extern const char c_szIE4SECTIONNAME[];     // "backup"
extern const char c_szIE4_OPTIONS[];        // "Software\\Microsoft\\IE Setup\\Options"
extern const char c_szIE4_UNINSTALLDIR[];   // "UninstallDir"

BOOL FileVerGreaterOrEqual(LPSTR lpszFileName, DWORD dwReqMSVer, DWORD dwReqLSVer);
void BuildPath( char *szPath, const char *szDirPath, const char *szFileName );
ULONG FileSize( LPSTR lpFile );
BOOL ValidateUninstallFiles(LPSTR lpszPath);
BOOL GetUninstallDirFromReg(LPSTR lpszUninstallDir);
BOOL FileBackupEntryExists(LPCSTR lpcszFileName);
BOOL FSP4LevelCryptoInstalled();
void MakeLFNPath(LPSTR lpszSFNPath, LPSTR lpszLFNPath, BOOL fNoExist);
BOOL MyPathIsUNC(LPCSTR pszPath);

BOOL RunningOnMillennium();
BOOL RunningOnWin95BiDiLoc();
BOOL IsBiDiLocalizedBinary(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName);
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif //  _SDSUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\ie4func.c ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      strstr.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg got from shlwapi
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "sdsutils.h"
	
//=================================================================================================
//
//=================================================================================================

#define NETWAREPATH             "System\\CurrentControlSet\\Services\\Class\\NetClient\\"
#define NETWARESUBKEY           "Ndi"
#define NETWAREVALUE            "DeviceID"
#define DNSLOADBALANCINGPATH    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define DNSLOADBALANCINGVALUE   "DontUseDNSLoadBalancing"

void DoPatchLoadBalancingForNetware( BOOL fRunningOnWin9X )
{
    HKEY    hNetWareSectionKey              = NULL;
    HKEY    hCurrentSubKey                  = NULL;
    HKEY    hDNS_LoadBalancingKey           = NULL;
    char    szCurrSubKeyName[MAX_PATH]      = { 0 };
    char    szCurrentBuf[MAX_PATH]          = { 0 };
    DWORD   dwSize                          = sizeof(szCurrSubKeyName);
    DWORD   dwDNSLoadBalancingData          = 1;
    DWORD   dwCurrentSection                = 0;
    DWORD   dwType                          = REG_SZ;
    LPSTR   pNetWareName                    = "NOVELL";

    if ( fRunningOnWin9X )
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, NETWAREPATH, 0, KEY_READ, &hNetWareSectionKey) )
        {
            while (ERROR_SUCCESS == RegEnumKeyEx(hNetWareSectionKey, dwCurrentSection, szCurrSubKeyName, &dwSize, NULL, NULL, NULL, NULL))
            {
                lstrcpy(szCurrentBuf, NETWAREPATH);
                AddPath(szCurrentBuf, szCurrSubKeyName);
                AddPath(szCurrentBuf, NETWARESUBKEY);
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCSTR)szCurrentBuf, 0, KEY_QUERY_VALUE, &hCurrentSubKey))
                {
                    dwSize = sizeof(szCurrentBuf);
                    if (ERROR_SUCCESS == RegQueryValueEx(hCurrentSubKey, NETWAREVALUE, NULL, &dwType, (LPBYTE) szCurrentBuf, &dwSize))
                    {
                        if ((REG_SZ == dwType) && (0 == _strnicmp(pNetWareName, szCurrentBuf, lstrlen(pNetWareName))))
                        {
                            // The user has Novell's version of NetWare so we need to turn off DNS Load Balancing.
                            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, DNSLOADBALANCINGPATH, 0, TEXT(""), 0,
                                            KEY_WRITE, NULL, &hDNS_LoadBalancingKey, NULL))
                            {
                                dwType = REG_DWORD;
                                RegSetValueEx(hDNS_LoadBalancingKey, DNSLOADBALANCINGVALUE, 0, dwType, (CONST BYTE *) (&dwDNSLoadBalancingData), sizeof(dwDNSLoadBalancingData));
                                RegCloseKey(hDNS_LoadBalancingKey);
                                hDNS_LoadBalancingKey = NULL;
                                RegCloseKey(hCurrentSubKey);
                                break;
                            }
                        }
                    }
                    RegCloseKey(hCurrentSubKey);
                    hCurrentSubKey = NULL;
                }
                dwCurrentSection++;
                dwSize = sizeof(szCurrSubKeyName);
            }
            RegCloseKey(hNetWareSectionKey);
            hNetWareSectionKey = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\lfnpath.c ===
#include <windows.h>
#include "sdsutils.h"

LPSTR PathBuildRoot(LPSTR szRoot, char cDrive)
{
    szRoot[0] = cDrive;
    szRoot[1] = ':';
    szRoot[2] = '\\';
    szRoot[3] = 0;

    return szRoot;
}

static LPSTR StrSlash(LPSTR psz)
{
    for (; *psz && *psz != '\\'; psz = CharNext(psz));
    
    return psz;
}
//--------------------------------------------------------------------------
// Return a pointer to the end of the next path componenent in the string.
// ie return a pointer to the next backslash or terminating NULL.
static LPSTR GetPCEnd(LPSTR lpszStart)
{
    LPSTR lpszEnd;
    
    lpszEnd = StrSlash(lpszStart);
    if (!lpszEnd)
    {
        lpszEnd = lpszStart + lstrlen(lpszStart);
    }
    
    return lpszEnd;
}

//---------------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
// Cond:    Note that SHELL32 implements its own copy of this
//          function.

BOOL MyPathIsUNC(LPCSTR pszPath)
{
    return (pszPath[0] == '\\' && pszPath[1] == '\\');
}

void MakeLFNPath(LPSTR lpszSFNPath, LPSTR lpszLFNPath, BOOL fNoExist)
{
   char     cTmp;
   HANDLE   hFind;
   LPSTR    pTmp = lpszSFNPath;
   WIN32_FIND_DATA Find_Data;

   *lpszLFNPath = '\0';

   if (*lpszSFNPath == '\0')
      return;

   if (MyPathIsUNC(lpszSFNPath))
   {
      lstrcpy(lpszLFNPath, lpszSFNPath);
      return;
   }

   PathBuildRoot(lpszLFNPath, *lpszSFNPath);

   // Skip past the root backslash
   pTmp = GetPCEnd(pTmp);
   if (*pTmp == '\0')
      return;
   pTmp = CharNext(pTmp);

   while (*pTmp)
   {
      // Get the next Backslash
      pTmp = GetPCEnd(pTmp);
      cTmp = *pTmp;
      *pTmp = '\0';
      hFind = FindFirstFile(lpszSFNPath, &Find_Data);
      if (hFind != INVALID_HANDLE_VALUE)
      {
         // Add the LFN to the path
         AddPath(lpszLFNPath, Find_Data.cFileName);
         FindClose(hFind);
      }
      else
      {
          if (fNoExist)
          {
              LPSTR pBack = ANSIStrRChr(lpszSFNPath, '\\');

              AddPath(lpszLFNPath, ++pBack);
          }
          else
          {
              *pTmp = cTmp;
              break;
          }
      }

      *pTmp = cTmp;
      
      if (*pTmp)
         pTmp = CharNext(pTmp);
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\proxy.c ===
#include <windows.h>
#include "regstr.h"
#include "sdsutils.h"

//----------------------------------------------------------------
// defines used to form the ProxyServer values
//----------------------------------------------------------------
#define TYPE_HTTP   1
#define TYPE_FTP    2
#define TYPE_GOPHER 3
#define TYPE_HTTPS  4
#define TYPE_SOCKS  5

#define MANUAL_PROXY    1
#define AUTO_PROXY      2
#define NO_PROXY        3

#define MAX_STRING      1024


// define keynames
const char NS_HTTP_KeyName[] = "HTTP_Proxy";
const char NS_HTTP_PortKeyName[] = "Http_ProxyPort";
const char NS_FTP_KeyName[] = "FTP_Proxy";
const char NS_FTP_PortKeyName[] = "Ftp_ProxyPort";
const char NS_Gopher_KeyName[] = "Gopher_Proxy";
const char NS_Gopher_PortKeyName[] = "Gopher_ProxyPort";
const char NS_HTTPS_KeyName[] = "HTTPS_Proxy";
const char NS_HTTPS_PortKeyName[] = "HTTPS_ProxyPort";
const char NS_SOCKS_KeyName[] = "SOCKS_Server";
const char NS_SOCKS_PortKeyName[] = "SOCKS_ServerPort";

// the string below have to match the strings in the prefs.js file netscape is using for
// it's settings. The parsing code needs them.
const char c_gszNetworkProxyType[]          = "network.proxy.type";
const char c_gszNetworkProxyHttp[]          = "network.proxy.http";
const char c_gszNetworkProxyHttpPort[]      = "network.proxy.http_port";
const char c_gszNetworkProxyFtp[]           = "network.proxy.ftp";
const char c_gszNetworkProxyFtpPort[]       = "network.proxy.ftp_port";
const char c_gszNetworkProxyGopher[]        = "network.proxy.gopher";
const char c_gszNetworkProxyGopherPort[]    = "network.proxy.gopher_port";
const char c_gszNetworkProxySsl[]           = "network.proxy.ssl";
const char c_gszNetworkProxySslPort[]       = "network.proxy.ssl_port";
const char c_gszNetworkProxyNoProxyOn[]     = "network.proxy.no_proxies_on";
const char c_gszNetworkAutoProxy[]          = "network.proxy.autoconfig_url";
const char c_gszNSAutoConfigUrl[]           = "Auto Config URL";

// This are the string we append the proxy settings to for IE
const char c_gszHTTP[]                      = "http=";
const char c_gszFTP[]                       = "ftp=";
const char c_gszGopher[]                    = "gopher=";
const char c_gszHTTPS[]                     = "https=";
const char c_gszSOCKS[]                     = "socks=";

// This are the registry key/valuenames for IE
const char c_gszIERegPath[]                 = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
const char c_gszIEProxyKeyName[]            = "ProxyServer";
const char c_gszIEOverrideKeyName[]         = "ProxyOverride";
const char c_gszIEWEnableKeyName[]          = "ProxyEnable";
const char c_gszIEAutoConfigUrl[]           = "AutoConfigURL";

const char c_gszIE4Setup[]                  = "Software\\Microsoft\\IE Setup\\Setup";

const char c_gszPre_DEFAULTBROWSER[] = "PreDefaultBrowser";
const char c_gszNavigator3[] = "Navigator30";
const char c_gszNavigator4[] = "Navigator40";
const char c_gszInternetExplorer[] = "Internet Explorer";

//-------------------------------------------------------------------------
// function prototype
//-------------------------------------------------------------------------

BOOL GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);
BOOL RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL IsIEDefaultBrowser();
void MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
BOOL ImportNetscapeProxy(void);
void ImportNetscape4Proxy();
BOOL GetNav4UserDir(LPSTR lpszDir);
void ImportNav4Settings(LPSTR lpData, DWORD dwBytes);
void AppendOneNav4Setting(LPSTR lpData, DWORD dwBytes, LPSTR lpProxyName, LPSTR lpProxyPort, LPSTR lpProxyType, LPSTR lpProxyValue);
void AppendOneNav4Setting(LPSTR lpData, DWORD dwBytes, LPSTR lpProxyName, LPSTR lpProxyPort, LPSTR lpProxyType, LPSTR lpProxyValue);
BOOL GetValueFormNav4(LPSTR lpData, DWORD dwBytes, LPSTR lpName, DWORD dwSize, LPSTR lpValue);
void CheckPreDefBrowser( DWORD *pdwVerMS );
LPSTR ConvertNetscapeProxyList(LPSTR pszBypassList);

//-------------------------------------------------------------------------
// functions
//-------------------------------------------------------------------------

void ImportNetscapeProxySettings( DWORD dwFlags )
{
    DWORD dwVerMS = 0;

    if ( dwFlags & IMPTPROXY_CALLAFTIE4 )
    {
          CheckPreDefBrowser( &dwVerMS );
    }
    else if (!IsIEDefaultBrowser())
    {
        dwVerMS = GetNetScapeVersion();
    }

    // Only if we go a version number see what netscape we should migrate.
    // It could still be that neither netscape nor IE is the default browser
    if (dwVerMS != 0)
    {
        // If Netscape 4 is install over netscape 3 and then uninstalled
        // the apppath for netscape is empty, but netscape 3 is still working.
        if (dwVerMS < NS_NAVI4)
            ImportNetscapeProxy();
        else
            ImportNetscape4Proxy();
    }
}

void CheckPreDefBrowser( DWORD *pdwVerMS )
{
    HKEY hKey;
    DWORD dwSize;
    char szBuf[MAX_PATH];

    if ( !pdwVerMS )
        return;

    *pdwVerMS = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_gszIE4Setup, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szBuf);
        if ( RegQueryValueEx(hKey, c_gszPre_DEFAULTBROWSER, 0, NULL, (LPBYTE)szBuf, &dwSize) == ERROR_SUCCESS )
        {
            if ( !lstrcmpi( szBuf, c_gszNavigator4 ) )
                *pdwVerMS = NS_NAVI4;
            else if ( !lstrcmpi( szBuf, c_gszNavigator3 ) )
                *pdwVerMS = NS_NAVI3ORLESS;
        }
        RegCloseKey( hKey );
    }
}


DWORD GetNetScapeVersion()
{
    // Determine which of the import code we should call
    char  c_gszRegstrPathNetscape[] = REGSTR_PATH_APPPATHS "\\netscape.exe";
    HKEY  hKey;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVerMS = 0;
    DWORD dwVerLS = 0;
    char  szTmp[MAX_PATH];
    char  *pTmp;
    char  *pBrowser;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_gszRegstrPathNetscape, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szTmp);
        if ((RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)szTmp, &dwSize) == ERROR_SUCCESS) &&
            (dwType == REG_SZ))
        {
            if (GetFileAttributes(szTmp) != 0xFFFFFFFF)
            {
                // File exists
                // Check the version
                MyGetVersionFromFile(szTmp, &dwVerMS, &dwVerLS, TRUE);
            }
        }
        RegCloseKey(hKey);
    }
    if (dwVerMS == 0)
    {
        // Assume the registry entry above does not exist or the file it pointed to does not exist.
        // GetVersionFromFile will retrun 0 if the file does not exist.

        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, ".htm", 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szTmp);
            if (RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)szTmp, &dwSize) != ERROR_SUCCESS)
                *szTmp = '\0';
            RegCloseKey(hKey);

            if (*szTmp != '\0')
            {
                AddPath(szTmp,"shell\\open\\command");
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szTmp);
                    if (RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)szTmp, &dwSize) == ERROR_SUCCESS)
                    {
                        // We have now the command line for the browser.
                        pTmp = szTmp;
                        if (*pTmp == '\"')
                        {
                            pTmp = CharNext(pTmp);
                            pBrowser = pTmp;
                            while ((*pTmp) && (*pTmp != '\"'))
                                pTmp = CharNext(pTmp);
                        }
                        else
                        {
                            pBrowser = pTmp;
                            while ((*pTmp) && (*pTmp != ' '))
                                pTmp = CharNext(pTmp);
                        }
                        *pTmp = '\0';
                        MyGetVersionFromFile(pBrowser, &dwVerMS, &dwVerLS, TRUE);
                    }

                    RegCloseKey(hKey);
                }
            }
        }

    }
    return dwVerMS;
}

/****************************************************\
    FUNCTION: ImportNetscapeProxy

    PARAMETERS:
        BOOL return - Error result. FALSE == ERROR

    DESCRIPTION:
        This function will check to see if IE's proxy
    value is set.  If it is not set, and Netscape's
    proxy value is set, we will copy their value over
    to ours.  We will also do this for the Proxy Override.
\***************************************************/

BOOL ImportNetscapeProxy(void)
{
    DWORD   dwRegType               = 0;
    HKEY    hIEKey                  = NULL;
    HKEY    hNSKey                  = NULL;
    // NS keys
    //
    char    *szNSRegPath            = "Software\\Netscape\\Netscape Navigator\\Proxy Information";
    char    *szNSRegPath2           = "Software\\Netscape\\Netscape Navigator\\Services";
    char    *szNSOverrideKeyName    = "No_Proxy";
    char    *szNSEnableKeyName      = "Proxy Type";
    char    *pszNewOverride         = NULL;

    char    szCurrentProxy[1024];
    char    szCurrentProxyOverride[1024];

    DWORD   dwDataSize              = sizeof(szCurrentProxy);
    DWORD   dwProxyEnabled          = 0;

    szCurrentProxy[0] = '\0';
    szCurrentProxyOverride[0] = '\0';


       // If Netscape does not have their proxy set to "Manual", then we will not
    // bother picking up their settings.
    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szNSRegPath, 0, KEY_QUERY_VALUE, &hNSKey)) &&
        (NULL != hNSKey))
    {
        dwDataSize = sizeof(dwProxyEnabled);
        RegQueryValueEx(hNSKey, szNSEnableKeyName, NULL, &dwRegType, (LPBYTE)&dwProxyEnabled, &dwDataSize);
        RegCloseKey(hNSKey);
        hNSKey = NULL;
    }

    switch (dwProxyEnabled)
    {
        case MANUAL_PROXY:
            // We only want to create an IE proxy server value if an IE value does not exist and
            // a Netscape value does.
            if (//(TRUE == RegStrValueEmpty(HKEY_CURRENT_USER, (LPSTR)c_gszIERegPath, (LPSTR)c_gszIEProxyKeyName)) &&
                ((FALSE == RegStrValueEmpty(HKEY_CURRENT_USER, szNSRegPath, (LPSTR)NS_HTTP_KeyName))   ||
                 (FALSE == RegStrValueEmpty(HKEY_CURRENT_USER, szNSRegPath, (LPSTR)NS_FTP_KeyName))    ||
                 (FALSE == RegStrValueEmpty(HKEY_CURRENT_USER, szNSRegPath, (LPSTR)NS_Gopher_KeyName)) ||
                 (FALSE == RegStrValueEmpty(HKEY_CURRENT_USER, szNSRegPath, (LPSTR)NS_HTTPS_KeyName))  ||
                 (FALSE == RegStrValueEmpty(HKEY_CURRENT_USER, szNSRegPath2,(LPSTR)NS_SOCKS_KeyName)) ) )
            {

                dwDataSize = sizeof(szCurrentProxy);
                if (TRUE == GetNSProxyValue(szCurrentProxy, &dwDataSize))
                {

                    // ASSERTSZ(NULL != szCurrentProxy, "GetNSProxyValue() was called and failed.");
                    if ((NULL != szCurrentProxy) &&
                        (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_gszIERegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                        KEY_SET_VALUE, NULL, &hIEKey, NULL)) &&
                        (NULL != hIEKey))
                    {

                        // At this point, the NS value exists, the IE value does not, so we will import the NS value.
                        RegSetValueEx(hIEKey, c_gszIEProxyKeyName, 0, REG_SZ, (unsigned char*)szCurrentProxy, lstrlen(szCurrentProxy)+1);
                        // We also need to turn on the Proxy
                        dwProxyEnabled = 1;

                        RegSetValueEx(hIEKey, c_gszIEWEnableKeyName, 0, REG_BINARY, (unsigned char*)&dwProxyEnabled, sizeof(dwProxyEnabled));
                        RegCloseKey(hIEKey);
                        hIEKey = NULL;
                    }
                }
            }

            // At this point, we want to import the Proxy Override value if it does
            // not exist for IE but does for NS.
            if (//(TRUE == RegStrValueEmpty(HKEY_CURRENT_USER, (LPSTR)c_gszIERegPath, (LPSTR)c_gszIEOverrideKeyName)) &&
                (FALSE == RegStrValueEmpty(HKEY_CURRENT_USER, szNSRegPath, szNSOverrideKeyName)))
            {
                if ((ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_gszIERegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                        KEY_SET_VALUE, NULL, &hIEKey, NULL)) &&
                    (NULL != hIEKey))
                {
                    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szNSRegPath, 0, KEY_QUERY_VALUE, &hNSKey)) &&
                        (NULL != hNSKey))
                    {
                        dwDataSize = sizeof(szCurrentProxyOverride);
                        if (ERROR_SUCCESS == RegQueryValueEx(hNSKey, szNSOverrideKeyName, NULL, &dwRegType, (LPBYTE)szCurrentProxyOverride, &dwDataSize))
                        {
                            if ((NULL != szCurrentProxyOverride) &&
                                (REG_SZ == dwRegType) &&
                                (0 != szCurrentProxyOverride[0]))
                            {

                                // At this point, the value exists, and it's invalid, so we need to change it.
                                pszNewOverride = ConvertNetscapeProxyList(szCurrentProxyOverride);
                                // Use the override list iff we successfully inserted '*' characters as appropriate.
                                if (pszNewOverride)
                                {
                                    RegSetValueEx(hIEKey, c_gszIEOverrideKeyName, 0, REG_SZ, (unsigned char*)pszNewOverride, lstrlen(pszNewOverride)+1);
                                    LocalFree(pszNewOverride);  // This is the caller's responsibility.
                                }
                                else
                                {
                                    RegSetValueEx(hIEKey, c_gszIEOverrideKeyName, 0, REG_SZ, (unsigned char*)szCurrentProxyOverride, lstrlen(szCurrentProxyOverride)+1);
                                }
                            }
                        }
                        RegCloseKey(hNSKey);
                        hNSKey = NULL;
                    }
                    RegCloseKey(hIEKey);
                    hIEKey = NULL;
                }
            }
        break;

        case AUTO_PROXY:
            if (RegOpenKeyEx(HKEY_CURRENT_USER, szNSRegPath, 0, KEY_QUERY_VALUE, &hNSKey) == ERROR_SUCCESS)
            {
                dwDataSize = sizeof(szCurrentProxy);
                if (RegQueryValueEx(hNSKey, c_gszNSAutoConfigUrl, NULL, NULL, (LPBYTE)szCurrentProxy, &dwDataSize) == ERROR_SUCCESS)
                {
                    if ((*szCurrentProxy != '\0') &&
                        (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszIERegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                                    KEY_SET_VALUE, NULL, &hIEKey, NULL) == ERROR_SUCCESS))
                    {
                        // At this point, the value exists, and it's invalid, so we need to change it.
                        RegSetValueEx(hIEKey, c_gszIEAutoConfigUrl, 0, REG_SZ, (LPBYTE)szCurrentProxy, lstrlen(szCurrentProxy)+1);
                        RegCloseKey(hIEKey);
                    }
                }
                RegCloseKey(hNSKey);
            }
            break;

        case NO_PROXY:
            // Nothing to do!?
            break;
    }
    return(TRUE);
}

// form proxy value for all protocals
//
BOOL GetOneProxyValue( char *szProxyValue, HKEY hKey, UINT type )
{
    BOOL    fExistPortNum           = FALSE;
    DWORD   dwRegType   = 0;
    long    lPortNum                = 0;
    DWORD   dwDataSize              = sizeof(lPortNum);
    char    szValue[MAX_PATH]       = {0};
    DWORD   dwSize                  = sizeof( szValue );
    LPSTR   pszValueName;
    LPSTR   pszPortName;
    LPSTR   pszType;
    BOOL    fValid                  = FALSE;

    if ( !szProxyValue || !hKey )
    {
        return FALSE;
    }

    switch( type )
    {
        case TYPE_HTTP:
            pszValueName = (LPSTR)NS_HTTP_KeyName;
            pszPortName = (LPSTR)NS_HTTP_PortKeyName;
            pszType = (LPSTR)c_gszHTTP;
            break;

        case TYPE_FTP:
            pszValueName = (LPSTR)NS_FTP_KeyName;
            pszPortName = (LPSTR)NS_FTP_PortKeyName;
            pszType = (LPSTR)c_gszFTP;
            break;

        case TYPE_GOPHER:
            pszValueName = (LPSTR)NS_Gopher_KeyName;
            pszPortName = (LPSTR)NS_Gopher_PortKeyName;
            pszType = (LPSTR)c_gszGopher;
            break;

        case TYPE_HTTPS:
            pszValueName = (LPSTR)NS_HTTPS_KeyName;
            pszPortName = (LPSTR)NS_HTTPS_PortKeyName;
            pszType = (LPSTR)c_gszHTTPS;
            break;

        case TYPE_SOCKS:
            pszValueName = (LPSTR)NS_SOCKS_KeyName;
            pszPortName = (LPSTR)NS_SOCKS_PortKeyName;
            pszType = (LPSTR)c_gszSOCKS;
            break;

        default:
            return FALSE;
    }

    if (ERROR_SUCCESS == RegQueryValueEx(hKey, pszPortName, NULL, &dwRegType, (LPBYTE)&lPortNum, &dwDataSize))
    {
        if (REG_DWORD == dwRegType)
        {
            fExistPortNum = TRUE;
        }
    }

    if (ERROR_SUCCESS == RegQueryValueEx(hKey, pszValueName, NULL, &dwRegType, (LPBYTE)szValue, &dwSize))
    {
        if ((0 != szValue[0] ) && (REG_SZ == dwRegType))
        {
            // Append the Port number if it was found above.
            if (TRUE == fExistPortNum)
            {
                char  szPortNumStr[10];

                lstrcat(szValue, ":");
                wsprintf(szPortNumStr, "%lu", lPortNum);
                lstrcat(szValue, szPortNumStr);
            }
            fValid = TRUE;
        }
    }

    if ( fValid )
    {
        if ( lstrlen(szProxyValue) > 0)
            lstrcat( szProxyValue, ";" );

        lstrcat( szProxyValue, pszType );
        lstrcat( szProxyValue, szValue );
    }

    return fValid;
}


/****************************************************\
    FUNCTION: GetNSProxyValue

    PARAMETERS:
        BOOL return - Error result. FALSE == ERROR

    DESCRIPTION:
        This function will create the Server Proxy
    value used in an IE format.  Netscape stores the
    name of the server and the port number separately.
    IE contains a string that has the server name,
    a ":" and followed by a port number.  This
    function will convert the NS version to the IE
    version.  Note that the port number is optional.
\***************************************************/
BOOL GetNSProxyValue(char * szProxyValue, DWORD * pdwSize)
{
    HKEY    hkey                    = NULL;
    char    *szNSRegPath            = "Software\\Netscape\\Netscape Navigator\\Proxy Information";
    char    *szNSRegPath2           = "Software\\Netscape\\Netscape Navigator\\Services";

    //ASSERTSZ(NULL != szProxyValue, "Don't pass NULL");
    //ASSERTSZ(NULL != pdwSize, "Don't pass NULL (pdwSize)");

    // Get the port number if it exists...
    if ((NULL != szProxyValue) &&
        (NULL != pdwSize) &&
        (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szNSRegPath, 0, KEY_QUERY_VALUE, &hkey)) &&
        (NULL != hkey))
    {
        GetOneProxyValue( szProxyValue, hkey, TYPE_HTTP );
        GetOneProxyValue( szProxyValue, hkey, TYPE_FTP );
        GetOneProxyValue( szProxyValue, hkey, TYPE_GOPHER );
        GetOneProxyValue( szProxyValue, hkey, TYPE_HTTPS );

        RegCloseKey(hkey);
        hkey = NULL;

        if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szNSRegPath2, 0, KEY_QUERY_VALUE, &hkey) )
        {
            GetOneProxyValue( szProxyValue, hkey, TYPE_SOCKS );

            RegCloseKey(hkey);
            hkey = NULL;
        }

    }
    return(TRUE);
}

/****************************************************\
    FUNCTION: RegStrValueEmpty

    PARAMETERS:
        BOOL return - Error result. FALSE == ERROR

    DESCRIPTION:
        This function will check to see if the reg
    key passed in as a parameter is an empty str and return
    TRUE if it is empty and FALSE if it's not empty.
    If the reg key does not exist, we return TRUE.
\***************************************************/
BOOL RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey)
{
    char    szCurrentValue[1024];
    HKEY    hkey                    = NULL;
    DWORD   dwRegType               = 0;
    DWORD   dwDataSize              = sizeof(szCurrentValue);
    BOOL    fSuccess                = TRUE;

    szCurrentValue[0] = '\0';
    //ASSERTSZ(NULL != szPath,"Don't pass me NULL. (szPath)");
    //ASSERTSZ(NULL != szKey,"Don't pass me NULL. (szKey)");

    if ((NULL != szPath) &&
        (NULL != szKey) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hTheKey, szPath, 0, KEY_QUERY_VALUE, &hkey)) &&
        (NULL != hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, szKey, NULL, &dwRegType, (LPBYTE)szCurrentValue, &dwDataSize))
        {
            if (REG_SZ == dwRegType)
            {
                if (0 != szCurrentValue[0])
                {
                    // The value exists, but it's not equal to "".
                    fSuccess = FALSE;
                }
            }
        }
        RegCloseKey(hkey);
        hkey = NULL;
    }
    return(fSuccess);
}


///////////////////////////////////////////////////////////////////////////////////////
// Netscape 4.0 proxy migration code
///////////////////////////////////////////////////////////////////////////////////////
void ImportNetscape4Proxy()
{
    char szProxyFile[MAX_PATH];
    DWORD   dwFileSize;
    DWORD   dwBytesRead;
    WIN32_FIND_DATA FindData;
    HANDLE  hf;
    LPSTR   lpData;

    // Only if we don't have proxy settings for IE
//    if (RegStrValueEmpty(HKEY_CURRENT_USER, (LPSTR)c_gszIERegPath, (LPSTR)c_gszIEProxyKeyName))
    {

        if (GetNav4UserDir(szProxyFile))
        {
            AddPath(szProxyFile, "prefs.js");   // Add the preferences file name
            // Get the data from the file
            hf = FindFirstFile(szProxyFile, &FindData);
            if (hf != INVALID_HANDLE_VALUE)
            {
                FindClose(hf);
                dwFileSize = FindData.nFileSizeLow;
                lpData = (LPSTR)LocalAlloc(LPTR, dwFileSize);
                if (lpData)
                {
                    hf = CreateFile(szProxyFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hf != INVALID_HANDLE_VALUE)
                    {
                        if (ReadFile(hf, lpData, dwFileSize, &dwBytesRead, NULL))
                        {
                            // Parse the data.
                            ImportNav4Settings(lpData, dwBytesRead);
                        }
                        CloseHandle(hf);
                    }
                    LocalFree(lpData);
                }
            }
        }
    }
}

BOOL GetNav4UserDir(LPSTR lpszDir)
{
    char    szDir[MAX_PATH];
    HKEY    hKey;
    HKEY    hKeyUser;
    char    szUser[MAX_PATH];
    DWORD   dwSize;
    BOOL    bDirFound = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Netscape\\Netscape Navigator\\Users", 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szUser);
        if (RegQueryValueEx(hKey, "CurrentUser", NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
        {
            if (RegOpenKeyEx(hKey, szUser, 0, KEY_QUERY_VALUE, &hKeyUser) == ERROR_SUCCESS)
            {
                dwSize = sizeof(szDir);
                if (RegQueryValueEx(hKeyUser, "DirRoot", NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                {

                    // Found the directory for the current user.
                    lstrcpy(lpszDir, szDir);
                    bDirFound = TRUE;
                }
                RegCloseKey(hKeyUser);
            }
        }
        RegCloseKey(hKey);
    }
    if (!bDirFound)
    {
        *szUser = '\0';
        // NAV 4.5 is not writing the above keys. there is a different way of finding the user dir.
        if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Netscape\\Netscape Navigator\\biff", 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(szUser);
            if (RegQueryValueEx(hKey, "CurrentUser", NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
            {
                // Have the current user name. Now get the root folder where the user folder are.
                if (RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Netscape\\Netscape Navigator\\Main", 0, KEY_QUERY_VALUE, &hKeyUser) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szDir);
                    if (RegQueryValueEx(hKeyUser, "Install Directory", NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                    {
                        // Got the install folder.
                        // Need to the the parent folder and then append users\%s , %s gets replaced with
                        // the CurrentUser name.
                        if (GetParentDir(szDir))
                        {
                            AddPath(szDir, "Users");
                            AddPath(szDir, szUser);
                            bDirFound = TRUE;
                            lstrcpy(lpszDir, szDir);
                        }

                    }
                    RegCloseKey(hKeyUser);
                }

            }
            RegCloseKey(hKey);
        }
    }
    return bDirFound;
}

void ImportNav4Settings(LPSTR lpData, DWORD dwBytes)
{
    char    szValue[MAX_PATH];
    char    szProxyValue[MAX_STRING];
    UINT    uiType;
    HKEY    hIEKey;
    DWORD   dwProxyEnabled          = 0;
    char    *pszNewOverride = NULL;

    if (GetValueFormNav4(lpData, dwBytes, (LPSTR)c_gszNetworkProxyType, lstrlen(c_gszNetworkProxyType), szValue))
    {
        uiType = (INT) AtoL(szValue);
        switch (uiType)
        {
            case MANUAL_PROXY:
                *szProxyValue = '\0';
                AppendOneNav4Setting(lpData, dwBytes, (LPSTR)c_gszNetworkProxyHttp, (LPSTR)c_gszNetworkProxyHttpPort, (LPSTR)c_gszHTTP, szProxyValue);
                AppendOneNav4Setting(lpData, dwBytes, (LPSTR)c_gszNetworkProxyFtp, (LPSTR)c_gszNetworkProxyFtpPort, (LPSTR)c_gszFTP, szProxyValue);
                AppendOneNav4Setting(lpData, dwBytes, (LPSTR)c_gszNetworkProxyGopher, (LPSTR)c_gszNetworkProxyGopherPort, (LPSTR)c_gszGopher, szProxyValue);
                AppendOneNav4Setting(lpData, dwBytes, (LPSTR)c_gszNetworkProxySsl, (LPSTR)c_gszNetworkProxySslPort, (LPSTR)c_gszHTTPS, szProxyValue);
                // Need to set the IE4 value(s)
                if (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszIERegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                                    KEY_SET_VALUE, NULL, &hIEKey, NULL) == ERROR_SUCCESS)
                {

                    // At this point, the NS value exists, so we will import the NS value.
                    RegSetValueEx(hIEKey, c_gszIEProxyKeyName, 0, REG_SZ, (LPBYTE)szProxyValue, lstrlen(szProxyValue)+1);
                    // We also need to turn on the Proxy
                    dwProxyEnabled = 1;

                    RegSetValueEx(hIEKey, c_gszIEWEnableKeyName, 0, REG_BINARY, (LPBYTE)&dwProxyEnabled, sizeof(dwProxyEnabled));
                    RegCloseKey(hIEKey);
                }

                // need to do the proxyoverride.
                // if (RegStrValueEmpty(HKEY_CURRENT_USER, (LPSTR)c_gszIERegPath, (LPSTR)c_gszIEOverrideKeyName))
                {

                    if (GetValueFormNav4(lpData, dwBytes, (LPSTR)c_gszNetworkProxyNoProxyOn, lstrlen(c_gszNetworkProxyNoProxyOn), szValue))
                    {
                        if ((*szValue != '\0') &&
                            (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszIERegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                                        KEY_SET_VALUE, NULL, &hIEKey, NULL) == ERROR_SUCCESS))
                        {

                            // At this point, the value exists, and it's invalid, so we need to change it.
                            pszNewOverride = ConvertNetscapeProxyList(szValue);
                            // Use the override list iff we successfully inserted '*' characters as appropriate.
                            if (pszNewOverride)
                            {
                                RegSetValueEx(hIEKey, c_gszIEOverrideKeyName, 0, REG_SZ, (unsigned char*)pszNewOverride, lstrlen(pszNewOverride)+1);
                                LocalFree(pszNewOverride);  // This is the caller's responsibility.
                            }
                            else
                            {
                                RegSetValueEx(hIEKey, c_gszIEOverrideKeyName, 0, REG_SZ, (LPBYTE)szValue, lstrlen(szValue)+1);
                            }
                            RegCloseKey(hIEKey);
                        }
                    }
                }
                break;

            case AUTO_PROXY:
                if (GetValueFormNav4(lpData, dwBytes, (LPSTR)c_gszNetworkAutoProxy, lstrlen(c_gszNetworkAutoProxy), szValue))
                {
                    if ((*szValue != '\0') &&
                        (RegCreateKeyEx(HKEY_CURRENT_USER, c_gszIERegPath, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                                    KEY_SET_VALUE, NULL, &hIEKey, NULL) == ERROR_SUCCESS))
                    {

                        // At this point, the value exists, and it's invalid, so we need to change it.
                        RegSetValueEx(hIEKey, c_gszIEAutoConfigUrl, 0, REG_SZ, (LPBYTE)szValue, lstrlen(szValue)+1);
                        RegCloseKey(hIEKey);
                    }
                }
                break;

            case NO_PROXY:
                // Nothing to do!?
                break;
        }
    }
}


// QFE 3046:  This is a low risk helper function when importing Netscape
//            proxy bypass lists.  They don't prefix non-server specific
//            addresses with a '*'.
//            For example, "*.netscape.com" would be ".netscape.com" in Nav.
//            This function allocates a new string and inserts '*' when
//            an address is found and it contains more than just whitespace
//            (and isn't already prefixed with a '*').
//            For example, "netscape.com, *.microsoft.com ,   ,domain.com"
//            would become "*netscape.com, *.microsoft.com ,   ,*domain.com".
LPSTR ConvertNetscapeProxyList(LPSTR pszBypassList)
{
    LPSTR pszNewBypassList = NULL;
    LPSTR pszOffset1 = NULL;
    LPSTR pszOffset2 = NULL;

    if (pszBypassList)
    {
        // No one should ever have a list that's very big,
        // so we'll make life easy here and alloc a string
        // guaranteed to be >= the converted string.
        pszNewBypassList = (LPSTR) LocalAlloc(LPTR, 2*lstrlen(pszBypassList) + 1);
        if (pszNewBypassList)
        {
            *pszNewBypassList = '\0';
            pszOffset1 = pszBypassList;

            while (*pszOffset1)
            {
                pszOffset2 = pszOffset1;

                // Copy and ignore any leading whitespace
                while (*pszOffset2 && IsSpace(*pszOffset2))
                {
                    pszOffset2 = CharNext(pszOffset2);
                }
                if (pszOffset1 != pszOffset2)
                {
                    lstrcpyn(pszNewBypassList + lstrlen(pszNewBypassList), pszOffset1, (size_t)(pszOffset2-pszOffset1+1));
                    pszOffset1 = pszOffset2;
                }

//                while (*pszOffset2 && IsSpace(*pszOffset2) && *pszOffset2 != ',')
//                {
//                    pszOffset2 = CharNext(pszOffset2);
//                }

                // Only insert a '*' if the item contains more than just whitespace.
                // Inserting a '*' gets the IE setting equivalent to the behavior in Nav.
                if (*pszOffset2 && *pszOffset2 != ',' && *pszOffset2 != '*')
                {
                    lstrcat(pszNewBypassList, "*");
                }

                // Look for the next server/domain item
                // by finding the separator.
                pszOffset2 = ANSIStrChr(pszOffset2, ',');
                if (pszOffset2)
                {
                    // Found a separator.  Append everything up to the
                    // next character after the separator.
                    lstrcpyn(pszNewBypassList + lstrlen(pszNewBypassList), pszOffset1, (size_t)(pszOffset2-pszOffset1+2));
                    pszOffset1 = pszOffset2+1;
                }
                else
                {
                    // This is the last item.  Append it and get ready to exit.
                    lstrcat(pszNewBypassList, pszOffset1);
                    pszOffset1 += lstrlen(pszOffset1);
                }
            }
        }
    }
    return pszNewBypassList;
}


BOOL GetValueFormNav4(LPSTR lpData, DWORD dwBytes, LPSTR lpName, DWORD dwSize, LPSTR lpValue)
{
    LPSTR lp;
    LPSTR lpEnd;
    BYTE   c;
    BOOL   bFound = FALSE;

    // determine the tpe of proxy settings
    lp  = ANSIStrStrI(lpData, lpName);
    if (lp)
    {
        lp += dwSize;   // lp should point now to the closing "
        if (*lp == '\"')
        {
            lp = CharNext((LPCSTR)lp);
            while ( *lp && (*lp == ' '))
                lp = CharNext((LPCSTR)lp);
            if (*lp == ',')
            {
                lp = CharNext((LPCSTR)lp);
                while ( *lp && (*lp == ' '))
                    lp = CharNext((LPCSTR)lp);
                // lp is now the start of the value.
                if (*lp == '\"')
                {
                    lp = CharNext((LPCSTR)lp);
                    lpEnd = lp;
                    while ((*lpEnd) && (*lpEnd != '\"'))
                        lpEnd = CharNext((LPCSTR)lpEnd);
                }
                else
                {
                    lpEnd = lp;
                    while ( *lpEnd && (*lpEnd != ')') && !IsSpace( (int) *lpEnd ))
                        lpEnd = CharNext((LPCSTR)lpEnd);
                }
                c = *lpEnd;
                *lpEnd = '\0';
                lstrcpy(lpValue, (LPCSTR)lp);
                *lpEnd = c;
                bFound = TRUE;
            }
        }
    }
    return bFound;
}

void AppendOneNav4Setting(LPSTR lpData, DWORD dwBytes, LPSTR lpProxyName, LPSTR lpProxyPort, LPSTR lpProxyType, LPSTR lpProxyValue)
{
    char szValue[MAX_PATH];

    if (GetValueFormNav4(lpData, dwBytes, lpProxyName, lstrlen(lpProxyName), szValue))
    {

        // Append the proxy name
        if ( lstrlen(lpProxyValue) > 0)
            lstrcat( lpProxyValue, ";" );

        lstrcat(lpProxyValue, lpProxyType);
        lstrcat(lpProxyValue, szValue );

        // If the proxy has a port value, append it.
        if (GetValueFormNav4(lpData, dwBytes, lpProxyPort, lstrlen(lpProxyPort), szValue))
        {
            lstrcat(lpProxyValue, ":");
            lstrcat(lpProxyValue, szValue );
        }
    }
}


void MyGetVersionFromFile(LPSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion)
{
    unsigned    uiSize;
    DWORD       dwVerInfoSize;
    DWORD       dwHandle;
    VS_FIXEDFILEINFO * lpVSFixedFileInfo;
    void FAR   *lpBuffer;
    LPVOID      lpVerBuffer;

    *pdwMSVer = *pdwLSVer = 0L;

    dwVerInfoSize = GetFileVersionInfoSize(lpszFilename, &dwHandle);
    if (dwVerInfoSize)
    {
        // Alloc the memory for the version stamping
        lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
        if (lpBuffer)
        {
            // Read version stamping info
            if (GetFileVersionInfo(lpszFilename, dwHandle, dwVerInfoSize, lpBuffer))
            {
                if (bVersion)
                {
                    // Get the value for Translation
                    if (VerQueryValue(lpBuffer, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) &&
                        (uiSize))

                    {
                        *pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                        *pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
                    }
                }
                else
                {
                    if (VerQueryValue(lpBuffer, "\\VarFileInfo\\Translation", &lpVerBuffer, &uiSize) &&
                        (uiSize))
                    {
                        *pdwMSVer = LOWORD(*((DWORD *) lpVerBuffer));   // Language ID
                        *pdwLSVer = HIWORD(*((DWORD *) lpVerBuffer));   // Codepage ID
                    }
                }
            }
            LocalFree(lpBuffer);
        }
    }
    return ;
}

BOOL IsIEDefaultBrowser()
{
    HKEY  hKey;
    DWORD dwSize;
    DWORD dwType;
    char  szTmp[MAX_PATH];
    BOOL  bIEDefaultBrowser = FALSE;

    // Check where the default value for this is pointing
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, "http\\shell\\open\\command", 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szTmp);
        if ( RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)szTmp, &dwSize) == ERROR_SUCCESS )
        {
            CharLower(szTmp);   // lowercase the string for the strstr call.
            bIEDefaultBrowser = (ANSIStrStrI(szTmp, "iexplore.exe") != NULL);
        }
        RegCloseKey(hKey);
    }
    return bIEDefaultBrowser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\space.c ===
#include <windows.h>

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//
// Checks the install destination dir free disk space
//
DWORD GetSpace( LPSTR szPath )
{
    DWORD   dwSecsPerCluster  = 0;
    DWORD   dwBytesPerSector  = 0;
    DWORD   dwFreeClusters    = 0;
    DWORD   dwTotalClusters   = 0;
    DWORD   dwClusterSize     = 0;
    DWORD   dwFreeBytes       = 0;
    DWORD   dwVolFlags        = 0;

    if( szPath[0] == 0)
       return 0;

    if ( ! GetDiskFreeSpace( szPath, &dwSecsPerCluster, &dwBytesPerSector,
                             &dwFreeClusters, &dwTotalClusters ) )
    {
        return( 0 );
    }

    dwClusterSize = dwBytesPerSector * dwSecsPerCluster;
    dwFreeBytes = MulDiv(dwClusterSize, dwFreeClusters, 1024);
    return dwFreeBytes;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//
// Checks the install destination dir free disk space
//
DWORD GetDriveSize( LPSTR szPath )
{
    DWORD   dwSecsPerCluster  = 0;
    DWORD   dwBytesPerSector  = 0;
    DWORD   dwFreeClusters    = 0;
    DWORD   dwTotalClusters   = 0;
    DWORD   dwClusterSize     = 0;
    DWORD   dwFreeBytes       = 0;
    DWORD   dwVolFlags        = 0;

    if( szPath[0] == 0)
       return 0;

    if ( ! GetDiskFreeSpace( szPath, &dwSecsPerCluster, &dwBytesPerSector,
                             &dwFreeClusters, &dwTotalClusters ) )
    {
        return( 0 );
    }

    dwClusterSize = dwBytesPerSector * dwSecsPerCluster;
    dwFreeBytes = MulDiv(dwClusterSize, dwTotalClusters, 1024);
    return dwFreeBytes;
}

//=--------------------------------------------------------------------------=
// Function name here
//=--------------------------------------------------------------------------=
// Function description
//
// Parameters:
//   
// Returns:
//
// Notes:
//
// Checks the given path drive free space and the current cluster size
//
DWORD GetDrvFreeSpaceAndClusterSize( LPSTR szPath, LPDWORD lpdwClustSize )
{
    DWORD   dwSecsPerCluster  = 0;
    DWORD   dwBytesPerSector  = 0;
    DWORD   dwFreeClusters    = 0;
    DWORD   dwTotalClusters   = 0;
    DWORD   dwClusterSize     = 0;
    DWORD   dwFreeBytes       = 0;
    DWORD   dwVolFlags        = 0;

    // if szPath is NULL, the current directory root will be used by the API	
    if ( ! GetDiskFreeSpace( szPath, &dwSecsPerCluster, &dwBytesPerSector,
                             &dwFreeClusters, &dwTotalClusters ) )
    {
        return( 0 );
    }

    dwClusterSize = dwBytesPerSector * dwSecsPerCluster;
    dwFreeBytes = MulDiv(dwClusterSize, dwFreeClusters, 1024);
	
    if (lpdwClustSize)
        *lpdwClustSize = dwClusterSize;

    return dwFreeBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\strstr.c ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      strstr.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg got from shlwapi
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "sdsutils.h"
	
//=================================================================================================
//
//=================================================================================================


/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 */
int 
StrCmpNA(
    LPCSTR lpStr1, 
    LPCSTR lpStr2, 
    int    nChar)
{
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
        w2 = (*lpStr2) ? *(UNALIGNED WORD *)lpStr2 : 0;

        // (ChrCmpA returns FALSE if the characters match)

        // Do the characters match?
        if (ChrCmpA_inline(w1, w2)) 
        {
            // No; determine the lexical value of the comparison
            // (since ChrCmp just returns true/false).
            char sz1[4];
            char sz2[4];

            // Since the character may be a DBCS character; we
            // copy two bytes into each temporary buffer 
            // (in preparation for the lstrcmp call).

            (*(WORD *)sz1) = w1;
            (*(WORD *)sz2) = w2;

            // Add null terminators to temp buffers
            *AnsiNext(sz1) = 0;
            *AnsiNext(sz2) = 0;
            return lstrcmpA(sz1, sz2);
        }
    }

    return 0;
}


/*
 * ANSIStrStr      - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
PSTR ANSIStrStr(LPCSTR lpFirst, LPCSTR lpSrch)
{
    UINT uLen;
    WORD wMatch;

    uLen = (UINT)lstrlen(lpSrch);
    wMatch = *(UNALIGNED WORD FAR *)lpSrch;

    for ( ; (lpFirst=ANSIStrChr(lpFirst, wMatch))!=0 && StrCmpNA(lpFirst, lpSrch, uLen);
         lpFirst=AnsiNext(lpFirst))
        continue; /* continue until we hit the end of the string or get a match */

    return((LPSTR)lpFirst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\strchr.c ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      string.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "sdsutils.h"
//=================================================================================================
//
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
//
// ChrCmp -  Case sensitive character comparison for DBCS
// Assumes   w1, wMatch are characters to be compared
// Return    FALSE if they match, TRUE if no match
//
//=================================================================================================

BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

//=================================================================================================
//      
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
//
// StrChr - Find first occurrence of character in string
// Assumes   lpStart points to start of null terminated string
//           wMatch  is the character to match
// returns ptr to the first occurrence of ch in str, NULL if not found.
//
//=================================================================================================

LPSTR FAR ANSIStrChr(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\strstri.c ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      strstr.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg got from shlwapi
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "sdsutils.h"
	
//=================================================================================================
//
//=================================================================================================

/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
    }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpiA(sz1, sz2);
}

/*
 * ANSIStrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL ANSIStrChrI(LPCSTR lpStart, WORD wMatch)
{
    wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

    for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
        if (!ChrCmpIA(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            return((LPSTR)lpStart);
    }
    return (NULL);
}


/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */
int FAR PASCAL StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD w1;
        WORD w2;

        // If either pointer is at the null terminator already,
        // we want to copy just one byte to make sure we don't read 
        // past the buffer (might be at a page boundary).

        w1 = (*lpStr1) ? *(UNALIGNED WORD *)lpStr1 : 0;
        w2 = (UINT)(IsDBCSLeadByte(*lpStr2)) ? *(UNALIGNED WORD *)lpStr2 : (WORD)(BYTE)(*lpStr2);

        i = ChrCmpIA(w1, w2);
        if (i)
            return i;
    }
    return 0;
}

/*
 * ANSiStrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR FAR PASCAL ANSIStrStrI(LPCSTR lpFirst, LPCSTR lpSrch)
{
    UINT uLen;
    WORD wMatch;

    uLen = (UINT)lstrlenA(lpSrch);
    wMatch = *(UNALIGNED WORD FAR *)lpSrch;

    for ( ; (lpFirst = ANSIStrChrI(lpFirst, wMatch)) != 0 && StrCmpNIA(lpFirst, lpSrch, uLen);
         lpFirst=AnsiNext(lpFirst))
        continue; /* continue until we hit the end of the string or get a match */

    return((LPSTR)lpFirst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\strrchr.c ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      string.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "sdsutils.h"

//=================================================================================================
//
// copied from \\trango\slmadd\src\shell\shlwapi\strings.c
//
// StrRChr - Find last occurrence of character in string
// Assumes   lpStart points to start of null terminated string
//           wMatch  is the character to match
// returns ptr to the last occurrence of ch in str, NULL if not found.
//
//=================================================================================================

LPSTR FAR ANSIStrRChr(LPCSTR lpStart, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    for ( ; *lpStart; lpStart = CharNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(*(UNALIGNED WORD FAR *)lpStart, wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\ultoa.c ===
#include <windows.h>

/* helper routine that does the main job. */

static void xtoa (
        unsigned long val,
        char *buf,
        unsigned radix,
        int is_neg
        )
{
        char *p;                /* pointer to traverse string */
        char *firstdig;         /* pointer to first digit */
        char temp;              /* temp char */
        unsigned digval;        /* value of digit */

        p = buf;

        if (is_neg) {
            /* negative, so output '-' and negate */
            *p++ = '-';
            val = (unsigned long)(-(long)val);
        }

        firstdig = p;           /* save pointer to first digit */

        do {
            digval = (unsigned) (val % radix);
            val /= radix;       /* get next digit */

            /* convert to ascii and store */
            if (digval > 9)
                *p++ = (char) (digval - 10 + 'a');  /* a letter */
            else
                *p++ = (char) (digval + '0');       /* a digit */
        } while (val > 0);

        /* We now have the digit of the number in the buffer, but in reverse
           order.  Thus we reverse them now. */

        *p-- = '\0';            /* terminate string; p points to last digit */

        do {
            temp = *p;
            *p = *firstdig;
            *firstdig = temp;   /* swap *p and *firstdig */
            --p;
            ++firstdig;         /* advance to next two digits */
        } while (firstdig < p); /* repeat until halfway */
}

/* Actual functions just call conversion helper with neg flag set correctly,
   and return pointer to buffer. */

PSTR ULtoA( unsigned long val, char *buf, int radix )
{
        xtoa(val, buf, radix, 0);
        return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\version.c ===
#include <windows.h>
#include "sdsutils.h"

void ConvertVersionString(LPCSTR pszVersion, WORD rwVer[], CHAR ch)
{
   LPSTR pszEnd;
   LPSTR pszTemp;
   LPSTR pszBegin;
   char  szVer[24];
   int i; 

   for(i = 0; i < 4; i++)
      rwVer[i] = 0;

   lstrcpy( szVer, pszVersion );

   pszEnd = szVer + lstrlen(szVer);
   pszTemp = szVer;
   for(i = 0; i < 4 && pszTemp < pszEnd; i++)
   {
      pszBegin = pszTemp;
      while(pszTemp < pszEnd && *pszTemp != ch)
         pszTemp++;

      *pszTemp = 0;
      rwVer[i] = (WORD) AtoL(pszBegin);
      pszTemp++;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\setup\sdslib\strtoul.c ===
#include <windows.h>
#include <sdsutils.h>

#define LONG_MAX 2147483647
#define LONG_MIN -2147483647-1
#define ULONG_MAX 0xFFFFFFFF


static unsigned long StrToXL (const char *nptr, const char **endptr, int ibase, int flags);

/***
*strtol, strtoul(nptr,endptr,ibase) - Convert ascii string to long un/signed
*       int.
*
*Purpose:
*       Convert an ascii string to a long 32-bit value.  The base
*       used for the caculations is supplied by the caller.  The base
*       must be in the range 0, 2-36.  If a base of 0 is supplied, the
*       ascii string must be examined to determine the base of the
*       number:
*               (a) First char = '0', second char = 'x' or 'X',
*                   use base 16.
*               (b) First char = '0', use base 8
*               (c) First char in range '1' - '9', use base 10.
*
*       If the 'endptr' value is non-NULL, then strtol/strtoul places
*       a pointer to the terminating character in this value.
*       See ANSI standard for details
*
*Entry:
*       nptr == NEAR/FAR pointer to the start of string.
*       endptr == NEAR/FAR pointer to the end of the string.
*       ibase == integer base to use for the calculations.
*
*       string format: [whitespace] [sign] [0] [x] [digits/letters]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               strtol -- LONG_MAX or LONG_MIN
*               strtoul -- ULONG_MAX
*               strtol/strtoul -- errno == ERANGE
*
*       No digits or bad base return:
*               0
*               endptr = nptr*
*
*Exceptions:
*       None.
*******************************************************************************/

/* flag values */
#define FL_UNSIGNED   1       /* strtoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */


static unsigned long StrToXL (const char *nptr, const char **endptr, int ibase, int flags)
{
        const char *p;
        char c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while ( IsSpace((int)(unsigned char)c) )
                c = *p++;               /* skip whitespace */

        if (c == '-') {
                flags |= FL_NEG;        /* remember minus sign */
                c = *p++;
        }
        else if (c == '+')
                c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) {
                /* bad base! */
                if (endptr)
                        /* store beginning of string in endptr */
                        *endptr = nptr;
                return 0L;              /* return 0 */
        }
        else if (ibase == 0) {
                /* determine base free-lance, based on first two chars of
                   string */
                if (c != '0')
                        ibase = 10;
                else if (*p == 'x' || *p == 'X')
                        ibase = 16;
                else
                        ibase = 8;
        }

        if (ibase == 16) {
                /* we might have 0x in front of number; remove if there */
                if (c == '0' && (*p == 'x' || *p == 'X')) {
                        ++p;
                        c = *p++;       /* advance past prefix */
                }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) {      /* exit in middle of loop */
                /* convert c to value */
                if ( IsDigit((int)(unsigned char)c) )
                        digval = c - '0';
                else if ( IsAlpha((int)(unsigned char)c) )
                        digval = (char)CharUpper((LPSTR)c) - 'A' + 10;
                else
                        break;
                if (digval >= (unsigned)ibase)
                        break;          /* exit loop if bad digit found */

                /* record the fact we have read one digit */
                flags |= FL_READDIGIT;

                /* we now need to compute number = number * base + digval,
                   but we need to know if overflow occured.  This requires
                   a tricky pre-check. */

                if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) {
                        /* we won't overflow, go ahead and multiply */
                        number = number * ibase + digval;
                }
                else {
                        /* we would have overflowed -- set the overflow flag */
                        flags |= FL_OVERFLOW;
                }

                c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) {
                /* no number there; return 0 and point to beginning of
                   string */
                if (endptr)
                        /* store beginning of string in endptr later on */
                        p = nptr;
                number = 0L;            /* return 0 */
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
                /* overflow or signed overflow occurred */
                if ( flags & FL_UNSIGNED )
                        number = ULONG_MAX;
                else if ( flags & FL_NEG )
                        number = (unsigned long)(-LONG_MIN);
                else
                        number = LONG_MAX;
        }

        if (endptr != NULL)
                /* store pointer to char that stopped the scan */
                *endptr = p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        return number;                  /* done. */
}

unsigned long StrToUL (const char *nptr, char **endptr,int ibase)
{
        return StrToXL(nptr, (const char**)endptr, ibase, FL_UNSIGNED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)   \
              -DFLAT         \
              -DWIN32=100    \
              -D_NT1X_=100   \
              -DINC_OLE2     \
              -DNOEXCEPTIONS \
	      -DNASHVILLE    \
              -DMLUI_SUPPORT \
              $(TRACELOG)

!IF "$(FREEBUILD)" == "0"
C_DEFINES=    \
              $(C_DEFINES)          \
              -DDBGASSERT=1
!ENDIF

#
# Set debugging level
#

!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG -DINET_DEBUG=1

#
# remove maximal diagnostics for customer debug version based on environment
# variable
#

!IF "$(FULL_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_DEBUG_MEMORY
!ELSE
C_DEFINES=$(C_DEFINES) -DRETAIL_LOGGING
!IF "$(BUILD_PRODUCT)" != "IE"
C_DEFINES=$(C_DEFINES) -DDISABLE_ASSERTS
!ENDIF
!ENDIF

!ELSE IF "$(ALMOSTRETAIL)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG
!ENDIF


!IFDEF USE_PERFTAGS
!IF $(FREEBUILD)
C_DEFINES = $(C_DEFINES) -DPERFTAGS
!ENDIF
!ENDIF

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#
WIN32_WINNT_VERSION=0x0500
WIN32_WIN95_VERSION=0x0400


# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_MSVCRT=1
# USE_NOLIBS= 1
USE_NOLIBS= 1

# Use the stripped down version for the crt
USE_LIBCMT=1

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

MSC_WARNING_LEVEL=/W3 /WX

GPCH_BUILD=..\..\mon\daytona

DELAYLOAD=WININET.DLL;SHELL32.DLL;MPR.DLL
DLOAD_ERROR_HANDLER = shlwapi.dll
DLOAD_FORCE_ERROR_CHECK = 1

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\agent\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\agent.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\agent.pch
PRECOMPILED_OPTION=/Yuagent.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\agent.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\agent.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\agent\stdafx.cxx ===
// stdafx.cpp : source file that includes just the standard includes
//      foo.pch will be the pre-compiled header
//      stdafx.obj will contain the pre-compiled type information

#include <agent.h>

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\agent\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\astghead.cxx ===
#include <windows.h>
#include <ole2.h>
#include <debnot.h>
#include <error.hxx>
#include "astg.hxx"
#include "asyncerr.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\agent\agent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       agent.CXX
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-21-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <agent.h>

//+---------------------------------------------------------------------------
//
//  Method:     COInetAgent::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAgent::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_SESSION, "%p _IN COInetAgent::QueryInterface\n", this));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetSession) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetAgent::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetAgent::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetAgent::AddRef(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetAgent::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_SESSION, "%p OUT COInetAgent::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetAgent::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetAgent::Release(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetAgent::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        // this is global
        //delete this;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetAgent::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

STDMETHODIMP COInetAgent::StartListen(
    const LPCWSTR  szProtocol,
    IOInetItemFilter   *pWChkItemFilter,
    DWORD          grfFilterMode,
    CLSID        *pclsidProtocol,
    DWORD          dwReserved
    )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAgent::StartListen\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetAgent::StartListen (hr:%lx)\n",this, hr));
    return hr;
}

// will release the sink passed in at StartListen
STDMETHODIMP COInetAgent::StopListen(CLSID *pclsidProtocol)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAgent::StopListen\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetAgent::StopListen (hr:%lx)\n",this, hr));
    return hr;
}

// add item to the spooler
STDMETHODIMP COInetAgent::ScheduleItem(
    IOInetItem          *pWChkItem,
    IOInetDestination   *pWChkDest,
    SCHEDULEDATA       *pschdata,
    DWORD               dwMode,
    DWORD     *pdwCookie
    )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAgent::ScheduleItem\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetAgent::ScheduleItem (hr:%lx)\n",this, hr));
    return hr;
}


STDMETHODIMP COInetAgent::RevokeItem(DWORD dwCookie)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAgent::RevokeItem\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetAgent::RevokeItem (hr:%lx)\n",this, hr));
    return hr;
}


#if 0
//+---------------------------------------------------------------------------
//
//  Method:     COInetItem::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetItem::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_SESSION, "%p _IN COInetItem::QueryInterface\n", this));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetSession) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetItem::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetItem::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetItem::AddRef(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetItem::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_SESSION, "%p OUT COInetItem::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetItem::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetItem::Release(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetItem::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        //delete this;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetItem::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

STDMETHODIMP COInetItem::GetURL(LPOLESTR *ppwzUrl)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItem::GetURL\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItem::GetURL (hr:%lx)\n",this, hr));
    return hr;
}


STDMETHODIMP COInetItem::GetInfo(
        DWORD     dwOptions,
        LPOLESTR *ppwzItemMime,
        LPCLSID  *pclsidItem,
        LPOLESTR *ppwzProtocol,
        LPCLSID  *pclsidProtocol,
        DWORD    *pdwOut
        )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItem::GetInfo\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItem::GetInfo (hr:%lx)\n",this, hr));
    return hr;
}


STDMETHODIMP COInetItem::GetItemData(DWORD *grfITEMF,ITEMDATA * pitemdata)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItem::GetItemData\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItem::GetItemData (hr:%lx)\n",this, hr));
    return hr;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\agent\advisor.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       agent.CXX
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-21-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <agent.h>

COInetAdvisor *g_pCOInetAdvisor = 0;

//+---------------------------------------------------------------------------
//
//  Function:   GetOInetAdvisor
//
//  Synopsis:
//
//  Arguments:  [dwMode] --
//              [ppOInetAdvisor] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetOInetAdvisor(DWORD dwMode, IOInetAdvisor **ppOInetAdvisor, DWORD dwReserved)
{

    HRESULT hr = NOERROR;
    TransDebugOut((DEB_SESSION, "API _IN GetOInetAdvisor\n"));

    TransAssert(( (ppOInetAdvisor != NULL) && (dwMode == 0) && (dwReserved == 0) && "Invalid argument"));

    if (ppOInetAdvisor && !dwMode && !dwReserved)
    {
        /*
        if (g_pCOInetAdvisor == 0)
        {
            g_pCOInetAdvisor = new COInetAdvisor();
        }

        if (g_pCOInetAdvisor)
        {
            g_pCOInetAdvisor->AddRef();
            *ppOInetAdvisor = g_pCOInetAdvisor;
        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }
        */
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TransDebugOut((DEB_SESSION, "API OUT GetOInetAdvisor (hr:%lx) \n", hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetItem::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetItem::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_SESSION, "%p _IN COInetItem::QueryInterface\n", this));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetAdvisor) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetItem::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetItem::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetItem::AddRef(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetItem::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_SESSION, "%p OUT COInetItem::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetItem::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetItem::Release(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetItem::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        //delete this;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetItem::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetItem::GetURL
//
//  Synopsis:
//
//  Arguments:  [ppwzUrl] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetItem::GetURL(LPOLESTR *ppwzUrl)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItem::GetURL\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItem::GetURL (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetItem::GetInfo
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//              [ppwzItemMime] --
//              [pclsidItem] --
//              [ppwzProtocol] --
//              [pclsidProtocol] --
//              [pdwOut] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetItem::GetInfo(
        DWORD     dwOptions,
        LPOLESTR *ppwzItemMime,
        LPCLSID  *pclsidItem,
        LPOLESTR *ppwzProtocol,
        LPCLSID  *pclsidProtocol,
        DWORD    *pdwOut
        )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItem::GetInfo\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItem::GetInfo (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetItem::GetItemData
//
//  Synopsis:
//
//  Arguments:  [ITEMDATA] --
//              [pitemdata] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetItem::GetItemData(DWORD *grfITEMF,ITEMDATA * pitemdata)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItem::GetItemData\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItem::GetItemData (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetItemSink::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetItemSink::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_SESSION, "%p _IN COInetItemSink::QueryInterface\n", this));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetAdvisor) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetItemSink::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetItemSink::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetItemSink::AddRef(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetItemSink::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_SESSION, "%p OUT COInetItemSink::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetItemSink::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetItemSink::Release(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetItemSink::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        //delete this;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetItemSink::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

STDMETHODIMP COInetItemSink::OnItem(
    ITEMTYPE   itemtype,
    IOInetItem *pWChkItem,
    DWORD      dwReserved
    )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetItemSink::OnItem\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetItemSink::OnItem (hr:%lx)\n",this, hr));
    return hr;
}

////////////////////////////////////////////////////////
//+---------------------------------------------------------------------------
//
//  Method:     COInetAdvisor::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAdvisor::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_SESSION, "%p _IN COInetAdvisor::QueryInterface\n", this));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetAdvisor) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetAdvisor::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetAdvisor::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetAdvisor::AddRef(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetAdvisor::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_SESSION, "%p OUT COInetAdvisor::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetAdvisor::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetAdvisor::Release(void)
{
    TransDebugOut((DEB_SESSION, "%p _IN COInetAdvisor::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        // this is global
        //delete this;
    }

    TransDebugOut((DEB_SESSION, "%p OUT COInetAdvisor::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetAdvisor::StartListen
//
//  Synopsis:
//
//  Arguments:  [szProtocol] --
//              [pWChkItemSink] --
//              [grfFilterMode] --
//              [pclsidProtocol] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAdvisor::StartListen(
    const LPCWSTR  szProtocol,
    IOInetItemFilter   *pWChkItemFilter,
    DWORD          grfFilterMode,
    CLSID        *pclsidProtocol,
    DWORD          dwReserved
    )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAdvisor::StartListen\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetAdvisor::StartListen (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetAdvisor::StopListen
//
//  Synopsis:   will release the sink passed in at StartListen
//
//  Arguments:  [pclsidProtocol] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAdvisor::StopListen(CLSID *pclsidProtocol)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAdvisor::StopListen\n", this));
    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT COInetAdvisor::StopListen (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetAdvisor::Advise
//
//  Synopsis:
//
//  Arguments:  [pWChkItemSink] --
//              [grfMode] --
//              [cMimes] --
//              [ppwzItemMimes] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAdvisor::Advise(IOInetItemSink *pWChkItemSink, DWORD grfMode, ULONG cMimes, const LPCWSTR *ppwzItemMimes, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAdvisor::Advise\n", this));
    HRESULT hr = NOERROR;

    for (ULONG i = 0; i < cMimes; i++)
    {
        LPCWSTR  pwzStr = *(ppwzItemMimes+i);
        _AdvSinks.AddVal(pWChkItemSink, pwzStr);
    }

    TransDebugOut((DEB_PROT, "%p OUT COInetAdvisor::Advise (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetAdvisor::Unadvise
//
//  Synopsis:
//
//  Arguments:  [pWChkItemSink] --
//              [cMimes] --
//              [ppwzItemMimes] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAdvisor::Unadvise(IOInetItemSink *pWChkItemSink, ULONG cMimes, const LPCWSTR *ppwzItemMimes)
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAdvisor::Unadvise\n", this));
    HRESULT hr = NOERROR;

    for (ULONG i = 0; i < cMimes; i++)
    {
        LPCWSTR  pwzStr = *(ppwzItemMimes+i);
        _AdvSinks.RemoveVal(pWChkItemSink, pwzStr);
    }

    TransDebugOut((DEB_PROT, "%p OUT COInetAdvisor::Unadvise (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetAdvisor::SendAdvise
//
//  Synopsis:
//
//  Arguments:  [itemtype] --
//              [pWChkItem] --
//              [grfMode] --
//              [pwzItemMimes] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetAdvisor::SendAdvise(
    ITEMTYPE        itemtype,
    IOInetItem     * pWChkItem,
    DWORD           grfMode,
    LPCWSTR         pwzItemMimes,
    DWORD           dwReserved
    )
{
    TransDebugOut((DEB_PROT, "%p _IN COInetAdvisor::SendAdvise\n", this));
    HRESULT hr;
    HRESULT hr1 = E_FAIL;

    IOInetItemSink   *pWChkItemSink = 0;

    hr = _AdvSinks.FindFirst(pwzItemMimes, (IUnknown **)&pWChkItemSink);

    if (hr == NOERROR)
    {

        do
        {
            hr1 = pWChkItemSink->OnItem(itemtype, pWChkItem, 0);
            pWChkItemSink->Release();
            pWChkItemSink = 0;

            hr = _AdvSinks.FindNext(pwzItemMimes, (IUnknown **)&pWChkItemSink);

        } while (hr == NOERROR);

    }

    TransDebugOut((DEB_PROT, "%p OUT COInetAdvisor::SendAdvise (hr:%lx)\n",this, hr1));
    return hr1;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMapStrToXVal::AddVal
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [ULONG] --
//              [cNames] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMapStrToXVal::AddVal(IUnknown *pUnk, LPCWSTR pwzName)
{
    TransDebugOut((DEB_PROT, "%p _IN CMapStrToXVal::AddVal\n", this));
    HRESULT hr = NOERROR;

    TransAssert((pUnk && pwzName));
    CLock lck(_mxs);

    CXUnknown cunk = pUnk;

    if (pUnk && pwzName)
    {
        CProtNode *pNode;
        CKey ckey = pwzName;

        if (_Map.Lookup(ckey, (CObject *&)pNode) )
        {
            pNode->Add(pUnk);
        }
        else
        {
           pNode = new CProtNode(pUnk);
           if (pNode)
           {
               _Map.SetAt(ckey, pNode);
               _cElements++;
           }
           else
           {
               hr = E_OUTOFMEMORY;
           }
        }

    }
    else
    {
        hr = E_INVALIDARG;
    }

    TransDebugOut((DEB_PROT, "%p OUT CMapStrToXVal::AddVal (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMapStrToXVal::RemoveVal
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMapStrToXVal::RemoveVal(IUnknown *pUnk,LPCWSTR pwzName)
{
    TransDebugOut((DEB_PROT, "%p _IN CMapStrToXVal::RemoveVal\n", this));
    HRESULT hr = NOERROR;

    CLock lck(_mxs);

    if (pUnk && pwzName)
    {
        CProtNode *pNode;
        CKey ckey = pwzName;

        if (_Map.Lookup(ckey, (CObject *&)pNode) )
        {
            pNode->Remove(pUnk);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TransDebugOut((DEB_PROT, "%p OUT CMapStrToXVal::RemoveVal (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMapStrToXVal::FindFirst
//
//  Synopsis:
//
//  Arguments:  [pwzName] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMapStrToXVal::FindFirst(LPCWSTR pwzName, IUnknown **ppUnk)
{
    TransDebugOut((DEB_PROT, "%p _IN CMapStrToXVal::FindFirst\n", this));
    HRESULT hr = E_FAIL;

    CLock lck(_mxs);
    TransAssert(( pwzName && ppUnk));

    if (_cElements)
    {
        CProtNode *pNode;
        CKey ckey = pwzName;

        if (   (_Map.Lookup(ckey, (CObject *&)pNode) )
            && (pNode->FindFirst(*ppUnk)) )
        {
            hr = NOERROR;
        }
    }

    TransDebugOut((DEB_PROT, "%p OUT CMapStrToXVal::FindFirst (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMapStrToXVal::FindNext
//
//  Synopsis:
//
//  Arguments:  [pwzName] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMapStrToXVal::FindNext(LPCWSTR pwzName, IUnknown **ppUnk)
{
    TransDebugOut((DEB_PROT, "%p _IN CMapStrToXVal::FindNext\n", this));
    HRESULT hr = E_FAIL;

    CLock lck(_mxs);
    TransAssert(( pwzName && ppUnk));

    if (_cElements)
    {
        CProtNode *pNode;
        CKey ckey = pwzName;

        if (   (_Map.Lookup(ckey, (CObject *&)pNode) )
            && (pNode->FindNext(*ppUnk)) )
        {
            hr = NOERROR;
        }
    }

    TransDebugOut((DEB_PROT, "%p OUT CMapStrToXVal::FindNext (hr:%lx)\n",this, hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\asyncver.h ===
#ifdef RC_INVOKED

#include <winver.h>

#define VER_FILEVERSION_STR      "0.0\0"
#define VER_FILEVERSION          0,000,0000,0000

#define VER_PRODUCTNAME_STR      "Microsoft Asynchronous Storage for OLE\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1995\0"
#define VER_PRODUCTVERSION_STR   "0.0\0"
#define VER_PRODUCTVERSION       0,0000,0000,0000
#define VER_COMMENT_STR          "Microsoft Asynchronous Storage for OLE\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_NT_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "Microsoft Asynchronous Storage for OLE\0"

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\asyncapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	asyncapi.cxx
//
//  Contents:	APIs for async docfiles
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "asyncapi.hxx"
#include "filllkb.hxx"
#include "filelkb.hxx"
#include "stgwrap.hxx"

#if DBG == 1
DECLARE_INFOLEVEL(astg);
#endif

HRESULT StgOpenAsyncDocfileOnIFillLockBytes( IFillLockBytes *pflb,
                                             DWORD grfMode,
                                             DWORD asyncFlags,
                                             IStorage **ppstgOpen)
{
    HRESULT hr;
    ILockBytes *pilb;
    IStorage *pstg;

    hr = pflb->QueryInterface(IID_ILockBytes, (void **)&pilb);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = StgOpenStorageOnILockBytes(pilb,
                                    NULL,
                                    grfMode,
                                    NULL,
                                    0,
                                    &pstg);

    pilb->Release();
    if (FAILED(hr))
    {
        return hr;
    }

    *ppstgOpen = new CAsyncRootStorage(pstg,(CFillLockBytes *) pflb);
    if (*ppstgOpen == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }
    
    return NOERROR;
}

HRESULT StgGetIFillLockBytesOnILockBytes( ILockBytes *pilb,
                                         IFillLockBytes **ppflb)
{
    SCODE sc = S_OK;
    CFillLockBytes *pflb = NULL;
    pflb = new CFillLockBytes(pilb);
    if (pflb == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }
    sc = pflb->Init();
    if (FAILED(sc))
    {
        *ppflb = NULL;
        return sc;
    }
    
    *ppflb = pflb;
    return NOERROR;
}


HRESULT StgGetIFillLockBytesOnFile(OLECHAR const *pwcsName,
                                  IFillLockBytes **ppflb)
{
    SCODE sc;
    CFileLockBytes *pflb = NULL;
    pflb = new CFileLockBytes;
    if (pflb == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }
    sc = pflb->Init(pwcsName);
    if (SUCCEEDED(sc))
    {
        sc = StgGetIFillLockBytesOnILockBytes(pflb, ppflb);
    }
    return sc;
}



#if DBG == 1
HRESULT StgGetDebugFileLockBytes(OLECHAR const *pwcsName, ILockBytes **ppilb)
{
    SCODE sc;
    CFileLockBytes *pflb;
    
    *ppilb = NULL;
    
    pflb = new CFileLockBytes;
    if (pflb == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    sc = pflb->Init(pwcsName);
    if (FAILED(sc))
    {
        delete pflb;
        pflb = NULL;
    }
    
    *ppilb = pflb;
    
    return sc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\filllkb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	filllkb.cxx
//
//  Contents:	IFillLockBytes and ILockBytes wrapper for async docfiles
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "filllkb.hxx"
#include <valid.h>
#include "filelkb.hxx"

#define ULIGetLow(x) x.LowPart

#define UNTERMINATED 0
#define TERMINATED_NORMAL 1
#define TERMINATED_ABNORMAL 2


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::CFillLockBytes, public
//
//  Synopsis:	Default constructor
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFillLockBytes::CFillLockBytes(ILockBytes *pilb)
{
    _pilb = pilb;
    _ulHighWater = 0;
    _ulFailurePoint = 0;
    _dwTerminate = UNTERMINATED;
    _hNotifyEvent = INVALID_HANDLE_VALUE;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::~CFillLockBytes, public
//
//  Synopsis:	Destructor
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFillLockBytes::~CFillLockBytes()
{
    astgAssert(_pilb == NULL);
    if (_hNotifyEvent != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hNotifyEvent);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Init, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CFillLockBytes::Init(void)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Init:%p()\n", this));
    _hNotifyEvent = CreateEvent(NULL,
                                TRUE,
                                FALSE,
                                NULL);
    if (_hNotifyEvent == NULL)
    {
        return Win32ErrorToScode(GetLastError());
    }
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CFillLockBytes::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------
//BUGBUG:  Delegate to wrapped ILockBytes?  Probably not.
STDMETHODIMP CFillLockBytes::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::QueryInterface(?, %p)\n",
                ppvObj));
    
    astgChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;

    sc = S_OK;
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (ILockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_ILockBytes))
    {
        *ppvObj = (ILockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
        CFillLockBytes::AddRef();
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::QueryInterface => %p\n",
                ppvObj));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CFillLockBytes::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CFillLockBytes::AddRef(void)
{
    return _pilb->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Release, public
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFillLockBytes::Release(void)
{
    LONG lRet;
    lRet = _pilb->Release();
    if (lRet == 0)
    {
        _pilb = NULL;
        delete this;
    }
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::ReadAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::ReadAt(ULARGE_INTEGER ulOffset,
                                    VOID HUGEP *pv,
                                    ULONG cb,
                                    ULONG *pcbRead)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::ReadAt:%p()\n", this));

    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((_dwTerminate == TERMINATED_NORMAL) ||
        (ULIGetLow(ulOffset) + cb <= _ulHighWater))
    {
        sc = _pilb->ReadAt(ulOffset, pv, cb, pcbRead);
    }
    else
    {
        *pcbRead = 0;
        _ulFailurePoint = cb + ULIGetLow(ulOffset);
        sc = STG_E_PENDING;
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::ReadAt\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::WriteAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::WriteAt(ULARGE_INTEGER ulOffset,
                                     VOID const HUGEP *pv,
                                     ULONG cb,
                                     ULONG *pcbWritten)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::WriteAt:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((_dwTerminate == TERMINATED_NORMAL) ||
        (ULIGetLow(ulOffset) + cb <= _ulHighWater))
    {
        sc = _pilb->WriteAt(ulOffset, pv, cb, pcbWritten);
    }
    else
    {
        *pcbWritten = 0;
        _ulFailurePoint = cb + ULIGetLow(ulOffset);
        sc = STG_E_PENDING;
    }
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::WriteAt\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Flush, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Flush(void)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Flush:%p()\n", this));
    sc = _pilb->Flush();
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Flush\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::SetSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::SetSize(ULARGE_INTEGER cb)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetSize:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else if ((_dwTerminate == TERMINATED_NORMAL) ||
             (ULIGetLow(cb) <= _ulHighWater))
    {
        sc = _pilb->SetSize(cb);
    }
    else
    {
        _ulFailurePoint = ULIGetLow(cb);
        sc = STG_E_PENDING;
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetSize\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::LockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::LockRegion:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->LockRegion(libOffset, cb, dwLockType);
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::LockRegion\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::UnlockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::UnlockRegion:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->UnlockRegion(libOffset, cb, dwLockType);
    }
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::UnlockRegion\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Stat, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Stat:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->Stat(pstatstg, grfStatFlag);
        //BUGBUG:  Do we need any post-processing here?
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Stat\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::FillAppend, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::FillAppend(void const *pv,
                                        ULONG cb,
                                        ULONG *pcbWritten)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::FillAppend:%p()\n", this));
    if (_dwTerminate != UNTERMINATED)
    {
        sc = STG_E_TERMINATED;
    }
    else
    {
        ULONG cbWritten;
        ULARGE_INTEGER uli;
        uli.QuadPart = _ulHighWater;
        sc = _pilb->WriteAt(uli, pv, cb, &cbWritten);
        _ulHighWater += cbWritten;
        if (pcbWritten != NULL)
        {
            *pcbWritten = cbWritten;
        }
        if (!PulseEvent(_hNotifyEvent))
        {
            sc = Win32ErrorToScode(GetLastError());
        }
    }

    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::FillAppend\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::FillAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::FillAt(ULARGE_INTEGER ulOffset,
                                    void const *pv,
                                    ULONG cb,
                                    ULONG *pcbWritten)
{
    //BUGBUG:  Implement
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::FillAt:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::FillAt\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::SetFillSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::SetFillSize(ULARGE_INTEGER ulSize)
{
    SCODE sc;
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::SetFillSize:%p()\n", this));
    if (_dwTerminate == TERMINATED_ABNORMAL)
    {
        sc = STG_E_INCOMPLETE;
    }
    else
    {
        sc = _pilb->SetSize(ulSize);
    }
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::SetFillSize\n"));
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::Terminate, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFillLockBytes::Terminate(BOOL bCanceled)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::Terminate:%p()\n", this));
    _dwTerminate = (bCanceled) ? TERMINATED_ABNORMAL : TERMINATED_NORMAL;
    if (!SetEvent(_hNotifyEvent))
    {
        return Win32ErrorToScode(GetLastError());
    }
    
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::Terminate\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetFailureInfo, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CFillLockBytes::GetFailureInfo(ULONG *pulWaterMark,
                                     ULONG *pulFailurePoint)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::GetFailureInfo:%p()\n", this));
    *pulWaterMark = _ulHighWater;
    *pulFailurePoint = _ulFailurePoint;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetFailureInfo\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetNotificationEvent, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

HANDLE CFillLockBytes::GetNotificationEvent(void)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::GetNotificationEvent:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetNotificationEvent\n"));
    return _hNotifyEvent;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFillLockBytes::GetTerminationStatus, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	11-Jan-96	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CFillLockBytes::GetTerminationStatus(DWORD *pdwFlags)
{
    astgDebugOut((DEB_ITRACE, "In  CFillLockBytes::GetTerminationStatus:%p()\n", this));
    *pdwFlags = _dwTerminate;
    astgDebugOut((DEB_ITRACE, "Out CFillLockBytes::GetTerminationStatus\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\filelkb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	filelkb.cxx
//
//  Contents:	File ILockBytes implementation for async storage
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "filelkb.hxx"
#include <valid.h>

#define WIN32_SCODE(err) HRESULT_FROM_WIN32(err)
#define LAST_STG_SCODE Win32ErrorToScode(GetLastError())

#define boolChk(e) \
    if (!(e)) astgErr(Err, LAST_STG_SCODE) else 1
#define boolChkTo(l, e) \
    if (!(e)) astgErr(l, LAST_STG_SCODE) else 1
#define negChk(e) \
    if ((e) == 0xffffffff) astgErr(Err, LAST_STG_SCODE) else 1
#define negChkTo(l, e) \
    if ((e) == 0xffffffff) astgErr(l, LAST_STG_SCODE) else 1


class CSafeCriticalSection
{
public:
    inline CSafeCriticalSection(CRITICAL_SECTION *pcs);
    inline ~CSafeCriticalSection();
private:
    CRITICAL_SECTION *_pcs;
};

inline CSafeCriticalSection::CSafeCriticalSection(CRITICAL_SECTION *pcs)
{
    _pcs = pcs;
    EnterCriticalSection(_pcs);
}

inline CSafeCriticalSection::~CSafeCriticalSection()
{
    LeaveCriticalSection(_pcs);
#if DBG == 1
    _pcs = NULL;
#endif
}

#define TAKE_CS CSafeCriticalSection scs(&_cs);

    
//+---------------------------------------------------------------------------
//
//  Function:	Win32ErrorToScode, public
//
//  Synopsis:	Map a Win32 error into a corresponding scode, remapping
//              into Facility_Storage if appropriate.
//
//  Arguments:	[dwErr] -- Win32 error to map
//
//  Returns:	Appropriate scode
//
//  History:	22-Sep-93	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE Win32ErrorToScode(DWORD dwErr)
{
    astgAssert((dwErr != NO_ERROR) &&
             "Win32ErrorToScode called on NO_ERROR");

    SCODE sc = STG_E_UNKNOWN;

    switch (dwErr)
    {
    case ERROR_INVALID_FUNCTION:
        sc = STG_E_INVALIDFUNCTION;
        break;
    case ERROR_FILE_NOT_FOUND:
        sc = STG_E_FILENOTFOUND;
        break;
    case ERROR_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;
    case ERROR_TOO_MANY_OPEN_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;
    case ERROR_ACCESS_DENIED:
    case ERROR_NETWORK_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;
    case ERROR_INVALID_HANDLE:
        sc = STG_E_INVALIDHANDLE;
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;
    case ERROR_NO_MORE_FILES:
        sc = STG_E_NOMOREFILES;
        break;
    case ERROR_WRITE_PROTECT:
        sc = STG_E_DISKISWRITEPROTECTED;
        break;
    case ERROR_SEEK:
        sc = STG_E_SEEKERROR;
        break;
    case ERROR_WRITE_FAULT:
        sc = STG_E_WRITEFAULT;
        break;
    case ERROR_READ_FAULT:
        sc = STG_E_READFAULT;
        break;
    case ERROR_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;
    case ERROR_LOCK_VIOLATION:
        sc = STG_E_LOCKVIOLATION;
        break;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;
    case ERROR_FILE_EXISTS:
    case ERROR_ALREADY_EXISTS:
        sc = STG_E_FILEALREADYEXISTS;
        break;
    case ERROR_INVALID_PARAMETER:
        sc = STG_E_INVALIDPARAMETER;
        break;
    case ERROR_INVALID_NAME:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILENAME_EXCED_RANGE:
        sc = STG_E_INVALIDNAME;
        break;
    case ERROR_INVALID_FLAGS:
        sc = STG_E_INVALIDFLAG;
        break;
    default:
        sc = WIN32_SCODE(dwErr);
        break;
    }
        
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::CFileLockBytes, public
//
//  Synopsis:	Default constructor
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

CFileLockBytes::CFileLockBytes(void)
{
    _cReferences = 1;
    _h = INVALID_HANDLE_VALUE;
    InitializeCriticalSection(&_cs);
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::~CFileLockBytes, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

CFileLockBytes::~CFileLockBytes()
{
    if (_h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_h);
    }
    DeleteCriticalSection(&_cs);
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::Init, public
//
//  Synopsis:	Initialization function
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CFileLockBytes::Init(OLECHAR const *pwcsName)
{
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::Init:%p()\n", this));

#ifndef UNICODE
    TCHAR atcPath[_MAX_PATH + 1];
    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;
    
    if (!WideCharToMultiByte(
        uCodePage,
        0,
        pwcsName,
        -1,
        atcPath,
        _MAX_PATH + 1,
        NULL,
        NULL))
    {
        return STG_E_INVALIDNAME;
    }

    _h = CreateFileA(atcPath,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    CREATE_NEW,                   //Create if necessary
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);
#else    
    _h = CreateFile(pwcsName,
                    GENERIC_READ | GENERIC_WRITE, //Read-write
                    0,                            // No sharing
                    NULL,
                    CREATE_NEW,                   //Create if necessary
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,
                    NULL);
#endif    
    if (_h == INVALID_HANDLE_VALUE)
    {
        return LAST_STG_SCODE;
    }
    wcscpy(_acName, pwcsName);
    
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::Init\n"));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CFileLockBytes::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    26-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP CFileLockBytes::QueryInterface(REFIID iid, void **ppvObj)
{
    TAKE_CS;
    
    SCODE sc;

    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::QueryInterface(?, %p)\n",
                ppvObj));
    
    astgChk(ValidateOutPtrBuffer(ppvObj));
    *ppvObj = NULL;

    sc = S_OK;
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IUnknown *)this;
        CFileLockBytes::AddRef();
    }
    else if (IsEqualIID(iid, IID_ILockBytes))
    {
        *ppvObj = (ILockBytes *)this;
        CFileLockBytes::AddRef();
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::QueryInterface => %p\n",
                ppvObj));

Err:
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CFileLockBytes::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    16-Mar-92       DrewB   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CFileLockBytes::AddRef(void)
{
    ULONG ulRet;

    astgDebugOut((DEB_TRACE, "In  CFileLockBytes::AddRef()\n"));

    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;

    astgDebugOut((DEB_TRACE, "Out CFileLockBytes::AddRef\n"));
    return ulRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::Release, public
//
//  History:	28-Dec-95	PhilipLa	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CFileLockBytes::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
    {
        lRet = 0;
    }
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::Release\n"));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::ReadAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileLockBytes::ReadAt(ULARGE_INTEGER ulOffset,
                                    VOID HUGEP *pv,
                                    ULONG cb,
                                    ULONG *pcbRead)
{
    TAKE_CS;
    
    SCODE sc = S_OK;
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::ReadAt:%p()\n", this));
    ULONG ulLow = ulOffset.LowPart;
    LONG lHigh = (LONG)ulOffset.HighPart;
    negChk(SetFilePointer(_h,
                          ulLow,
                          &lHigh,
                          FILE_BEGIN));
    boolChk(ReadFile(_h, pv, cb, pcbRead, NULL));
    
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::ReadAt\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::WriteAt, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileLockBytes::WriteAt(ULARGE_INTEGER ulOffset,
                                     VOID const HUGEP *pv,
                                     ULONG cb,
                                     ULONG *pcbWritten)
{
    TAKE_CS;
    
    SCODE sc = S_OK;
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::WriteAt:%p()\n", this));

    ULONG ulLow = ulOffset.LowPart;
    LONG lHigh = (LONG)ulOffset.HighPart;
    negChk(SetFilePointer(_h,
                          ulLow,
                          &lHigh,
                          FILE_BEGIN));
    boolChk(WriteFile(_h, pv, cb, pcbWritten, NULL));
    
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::WriteAt\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::Flush, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------
//BUGBUG:  Implement something here?
STDMETHODIMP CFileLockBytes::Flush(void)
{
    TAKE_CS;
    
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::Flush:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::Flush\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::SetSize, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileLockBytes::SetSize(ULARGE_INTEGER cb)
{
    TAKE_CS;
    
    SCODE sc = S_OK;
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::SetSize:%p()\n", this));
    LONG lHigh = (LONG)cb.HighPart;
    ULONG ulLow = cb.LowPart;

    negChk(SetFilePointer(_h, ulLow, &lHigh, FILE_BEGIN));
    boolChk(SetEndOfFile(_h));
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::SetSize\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::LockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileLockBytes::LockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    TAKE_CS;
    
    SCODE sc = S_OK;
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::LockRegion:%p()\n", this));
    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    boolChk(LockFile(_h,
                     libOffset.LowPart,
                     libOffset.HighPart,
                     cb.LowPart,
                     cb.HighPart));
            
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::LockRegion\n"));
Err:    
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFileLockBytes::UnlockRegion, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileLockBytes::UnlockRegion(ULARGE_INTEGER libOffset,
                                          ULARGE_INTEGER cb,
                                          DWORD dwLockType)
{
    TAKE_CS;
    
    SCODE sc = S_OK;
    astgDebugOut((DEB_ITRACE, "In  CFileLockBytes::UnlockRegion:%p()\n", this));
    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        return STG_E_INVALIDFUNCTION;
    }
    
    boolChk(UnlockFile(_h,
                     libOffset.LowPart,
                     libOffset.HighPart,
                     cb.LowPart,
                     cb.HighPart));
            
    astgDebugOut((DEB_ITRACE, "Out CFileLockBytes::UnlockRegion\n"));
Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CFIleLockBytes::Stat, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	28-Dec-95	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CFileLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    TAKE_CS;
    
    SCODE sc;

    astgDebugOut((DEB_ITRACE, "In  CFIleLockBytes::Stat:%p()\n", this));

    negChk(pstatstg->cbSize.LowPart =
           GetFileSize(_h, &pstatstg->cbSize.HighPart));
    boolChk(GetFileTime(_h, &pstatstg->ctime, &pstatstg->atime,
                        &pstatstg->mtime));
    pstatstg->grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;
    
    pstatstg->type = STGTY_LOCKBYTES;
    //BUGBUG:  Set grfMode
    //pstatstg->grfMode = DFlagsToMode(_pgfst->GetDFlags());
    pstatstg->pwcsName = NULL;
    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        pstatstg->pwcsName = (OLECHAR *)CoTaskMemAlloc(
            (wcslen(_acName) + 1) * sizeof(OLECHAR));
        if (pstatstg->pwcsName == NULL)
            return STG_E_INSUFFICIENTMEMORY;
        wcscpy(pstatstg->pwcsName, _acName);
    }
    sc = S_OK;

    astgDebugOut((DEB_ITRACE, "Out CFIleLockBytes::Stat\n"));
    return NOERROR;

Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\stgwrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:	stgwrap.cxx
//
//  Contents:	IStorage/IStream wrappers for async docfile
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "stgwrap.hxx"
#include "asyncerr.hxx"
#define UNTERMINATED 0
#define TERMINATED_NORMAL 1
#define TERMINATED_ABNORMAL 2

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
SCODE CAsyncStorage::Notify(void)
{
    SCODE sc = S_OK;
	ULONG ulWaterMark;
    ULONG ulFailurePoint;

	HANDLE hNotifyEvent;
	CSinkList *pslTemp;
	
	_pflb->GetFailureInfo(&ulWaterMark,
                          &ulFailurePoint);
	
	pslTemp =_cpoint.GetHead();
	
	while ((pslTemp == NULL) || 
		   (sc = pslTemp->GetProgressNotify()->OnProgress(ulWaterMark, ulFailurePoint,  FALSE)) ==S_OK)
	{	
		DWORD dwFlags;

		// wait for an event to signal
		hNotifyEvent = _pflb->GetNotificationEvent();
		WaitForSingleObject(hNotifyEvent, INFINITE);
			
		_pflb->GetTerminationStatus(&dwFlags);
		// client terminated call?
		if (dwFlags ==	TERMINATED_ABNORMAL)
				return STG_E_TERMINATED;

		// download is complete
		else if (dwFlags ==	TERMINATED_NORMAL)
				break;

		else
		{	_pflb->GetFailureInfo(&ulWaterMark,
					              &ulFailurePoint);

			// all the data is available now
			if (ulWaterMark >= ulFailurePoint)
				break;
		}
				
	}
	if (sc == S_FALSE)
		return S_OK;
	else return sc;


}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
SCODE CAsyncStream::Notify(void)
{
    SCODE sc = S_OK;
	ULONG ulWaterMark;
    ULONG ulFailurePoint;
	CSinkList *pslTemp;
	HANDLE hNotifyEvent;

	_pflb->GetFailureInfo(&ulWaterMark,
                          &ulFailurePoint);
    
	pslTemp =_cpoint.GetHead();
	
	while ((pslTemp == NULL) || 
		   (sc = pslTemp->GetProgressNotify()->OnProgress(ulWaterMark, ulFailurePoint,  FALSE)) ==S_OK)
	{	
		DWORD dwFlags;

		// wait for an event to signal
		hNotifyEvent = _pflb->GetNotificationEvent();
		WaitForSingleObject(hNotifyEvent, INFINITE);
			
		_pflb->GetTerminationStatus(&dwFlags);
		// client terminated call?
		if (dwFlags ==	TERMINATED_ABNORMAL)
				return STG_E_TERMINATED;

		// download is complete
		else if (dwFlags ==	TERMINATED_NORMAL)
				break;

		else
		{	_pflb->GetFailureInfo(&ulWaterMark,
					              &ulFailurePoint);

			// all the data is available now
			if (ulWaterMark >= ulFailurePoint)
				break;
		}
				
	}
	if (sc == S_FALSE)
		return S_OK;
	else return sc;


}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::Notify,  public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	14-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
SCODE CAsyncEnum::Notify(void)
{
    SCODE sc = S_OK;
	ULONG ulWaterMark;
    ULONG ulFailurePoint;
	CSinkList *pslTemp;
	HANDLE hNotifyEvent;

	_pflb->GetFailureInfo(&ulWaterMark,
                          &ulFailurePoint);
	
	pslTemp =_cpoint.GetHead();
	
	while ((pslTemp == NULL) || 
		   (sc = pslTemp->GetProgressNotify()->OnProgress(ulWaterMark, ulFailurePoint,  FALSE)) ==S_OK)
	{	
		DWORD dwFlags;

		// wait for an event to signal
		hNotifyEvent = _pflb->GetNotificationEvent();
		WaitForSingleObject(hNotifyEvent, INFINITE);
			
		_pflb->GetTerminationStatus(&dwFlags);
		// client terminated call?
		if (dwFlags ==	TERMINATED_ABNORMAL)
				return STG_E_TERMINATED;

		// download is complete
		else if (dwFlags ==	TERMINATED_NORMAL)
				break;

		else
		{	_pflb->GetFailureInfo(&ulWaterMark,
					              &ulFailurePoint);

			// all the data is available now
			if (ulWaterMark >= ulFailurePoint)
				break;
		}
				
	}
	if (sc == S_FALSE)
		return S_OK;
	else return sc;


}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::QueryInterface, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    *ppvObj = NULL;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::QueryInterface:%p()\n", this));    
 
    if (IsEqualIID(iid, IID_IUnknown)) 
     
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IStorage))
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IConnectionPointContainer))
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
    {
        AddRef();
    }
    astgDebugOut((DEB_ITRACE, "Out  CAsyncStorage::QueryInterface:%p()\n", this));    
    return sc;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::AddRef, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncStorage::AddRef(void)
{	
    ULONG ulRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::AddRef:%p()\n", this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    _pRealStg->AddRef();
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::AddRef\n"));
    return ulRet;
	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::Release, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAsyncStorage::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    _pRealStg->Release();
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::Release\n"));
    return (ULONG)lRet;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::CreateStream, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::CreateStream(OLECHAR const *pwcsName,
                                         DWORD grfMode,
                                         DWORD reserved1,
                                         DWORD reserved2,
                                         IStream **ppstm)
{
   
    SCODE sc = S_OK,
		  sc2 = S_OK;
   
    CAsyncStream *pwstm;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::CreateStream:%p()\n", this));
    
	do
	{	
		sc = _pRealStg->CreateStream(pwcsName,
                                 grfMode,
                                 reserved1,
                                 reserved2,
                                 ppstm);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

		
	} while (sc == STG_E_PENDING );
	
    if (SUCCEEDED(sc))
    {
        CAsyncStream *pwstm = new CAsyncStream(*ppstm, _pflb);
        *ppstm = (IStream *)pwstm;
	
    }
    astgDebugOut((DEB_ITRACE, "Out  CAsyncStorage::CreateStream:%p()\n", this));
    return ResultFromScode(sc);   		

}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::OpenStream, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::OpenStream(OLECHAR const *pwcsName,
                                       void *reserved1,
                                       DWORD grfMode,
                                       DWORD reserved2,
                                       IStream **ppstm)
{
    CAsyncStream *pwstm;
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
   

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::OpenStream:%p()\n", this));
    
    do
	{	
		sc = _pRealStg->OpenStream(pwcsName,
                               reserved1,
                               grfMode,
                               reserved2,
                               ppstm);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

		
	} while (sc == STG_E_PENDING );

	if (SUCCEEDED(sc))
    {
        CAsyncStream *pwstm = new CAsyncStream(*ppstm, _pflb);
        *ppstm = (IStream *)pwstm;
    }

    astgDebugOut((DEB_ITRACE, "Out  CAsyncStorage::OpenStream:%p()\n", this));
    return ResultFromScode(sc);   		

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::CreateStorage, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::CreateStorage(OLECHAR const *pwcsName,
                                          DWORD grfMode,
                                          DWORD reserved1,
                                          LPSTGSECURITY reserved2,
                                          IStorage **ppstg)
{
  
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;	
   
    
   
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::CreateStorage:%p()\n", this));
  
	do
	{	sc = _pRealStg->CreateStorage( pwcsName,
                                   grfMode,
                                   reserved1,
                                   reserved2,
                                   ppstg);
		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	
	}   while (sc == STG_E_PENDING );

	if (SUCCEEDED(sc))
    {
        CAsyncStorage *pwstg = new CAsyncStorage(*ppstg, _pflb);
        *ppstg = (IStorage *) pwstg;
	
    }


    astgDebugOut((DEB_ITRACE, "Out  CAsyncStorage::CreateStorage:%p()\n", this));
    return ResultFromScode(sc);   		
 

}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::OpenStorage, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::OpenStorage(OLECHAR const *pwcsName,
                                        IStorage *pstgPriority,
                                        DWORD grfMode,
                                        SNB snbExclude,
                                        DWORD reserved,
                                        IStorage **ppstg)
{
   
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::OpenStorage:%p()\n", this));
    
	
	do
	{	sc = _pRealStg->OpenStorage( pwcsName,
                                 pstgPriority,
                                 grfMode,
                                 snbExclude,
                                 reserved,
                                 ppstg);
		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	
	}   while (sc == STG_E_PENDING );

	if (SUCCEEDED(sc))
    {
        CAsyncStorage *pwstg = new CAsyncStorage(*ppstg, _pflb);
        *ppstg = (IStorage *) pwstg;
    }

    astgDebugOut((DEB_ITRACE, "Out  CAsyncStorage::OpenStorage:%p()\n", this));
    return ResultFromScode(sc);   		
  
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::CopyTo, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::CopyTo(DWORD ciidExclude,
                                   IID const *rgiidExclude,
                                   SNB snbExclude,
                                   IStorage *pstgDest)
{
   
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
    
   
 
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::CopyTo%p()\n", this));
   

    do
	{	
		sc = _pRealStg->CopyTo( ciidExclude,
                              rgiidExclude,
                              snbExclude,
                              pstgDest);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	
	} while (sc == STG_E_PENDING );

    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::CopyTo\n"));	
	return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::MoveElementTo, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::MoveElementTo(OLECHAR const *lpszName,
                                          IStorage *pstgDest,
                                          OLECHAR const *lpszNewName,
                                          DWORD grfFlags)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::MoveElementTo%p()\n", this));
   

	do
	{

		sc = _pRealStg->MoveElementTo(lpszName,
                                    pstgDest,
                                    lpszNewName,
                                    grfFlags) ;

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
	}
	while (sc == STG_E_PENDING );
    
	astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::MoveElementTo\n"));	
    return ResultFromScode(sc); 		
	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::Commit, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::Commit(DWORD grfCommitFlags)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::Commit%p()\n", this));
   

	do
	{				
		sc = _pRealStg->Commit(grfCommitFlags);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
		
	}  while (sc == STG_E_PENDING );
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::Commit\n"));	
    return ResultFromScode(sc); 		
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::Revert, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::Revert(void)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::Revert%p()\n", this));
   

    do
	{
		sc = _pRealStg->Revert();
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}  while (sc == STG_E_PENDING );
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::Revert\n"));	
    return ResultFromScode(sc); 	

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::EnumElements, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::EnumElements(DWORD reserved1,
                                         void *reserved2,
                                         DWORD reserved3,
                                         IEnumSTATSTG **ppenm)
{
   
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
   
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::EnumElements%p()\n", this));
   
	do
	{		
		sc = _pRealStg->EnumElements(reserved1,
                                   reserved2,
                                   reserved3,
                                   ppenm);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 


	}   while (sc == STG_E_PENDING );

	if (SUCCEEDED(sc))
    {
        CAsyncEnum *pwenum = new CAsyncEnum(*ppenm, _pflb);
        *ppenm = (IEnumSTATSTG *)pwenum;
	
    }
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::EnumElements\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::DestroyElement, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::DestroyElement(OLECHAR const *pwcsName)
{
   
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	ULONG ulWaterMark;
    ULONG ulFailurePoint;

	HANDLE hNotifyEvent;
	CSinkList *pslTemp;
	
	
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::DestroyElement%p()\n", this));
   
	pslTemp =_cpoint.GetHead();
	
	while (1)
	{	
		DWORD dwFlags;

		_pflb->GetTerminationStatus(&dwFlags);
		// client terminated call?
		if (dwFlags ==	TERMINATED_ABNORMAL)
				return STG_E_TERMINATED;

		// download is complete
		else if (dwFlags ==	TERMINATED_NORMAL)
				break;
		// wait for an event to signal
		hNotifyEvent = _pflb->GetNotificationEvent();
		WaitForSingleObject(hNotifyEvent, INFINITE);
	
		if (pslTemp != NULL)
		{
			_pflb->GetFailureInfo(&ulWaterMark,
                          &ulFailurePoint);
			pslTemp->GetProgressNotify()->OnProgress(ulWaterMark, (ULONG) -1 ,  FALSE);

		}

	} 
	
	sc = _pRealStg->DestroyElement(pwcsName);
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::DestroyElement\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::RenameElement, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::RenameElement(OLECHAR const *pwcsOldName,
                                          OLECHAR const *pwcsNewName)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::RenameElement%p()\n", this));
   
	do
	{	

		sc = _pRealStg->RenameElement(pwcsOldName,
                                    pwcsNewName);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2);

	}   while (sc == STG_E_PENDING );
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::RenameElement\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::SetElementTimes, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::SetElementTimes(const OLECHAR *lpszName,
                                            FILETIME const *pctime,
                                            FILETIME const *patime,
                                            FILETIME const *pmtime)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
 
    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::SetElementTimes%p()\n", this));
   

	do
	{	
		sc = _pRealStg->SetElementTimes(lpszName,
                                      pctime,
                                      patime,
                                      pmtime);
		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2);

	}   while (sc == STG_E_PENDING );
   
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::SetElementTimes\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::SetClass, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::SetClass(REFCLSID clsid)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::SetClass%p()\n", this));
   

    do
	{
		sc = _pRealStg->SetClass(clsid);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	
	} while (sc == STG_E_PENDING );
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::SetClass\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::SetStateBits, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::SetStateBits%p()\n", this));
   

    do
	{	sc = _pRealStg->SetStateBits(grfStateBits, grfMask);
		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

		
	} while (sc == STG_E_PENDING );  
    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::SetStateBits\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::Stat, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::Stat%p()\n", this));
   

	do
	{	sc = _pRealStg->Stat( pstatstg,  grfStatFlag);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}   while (sc == STG_E_PENDING );

    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::Stat\n"));	
    return ResultFromScode(sc); 	
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::EnumConnectionPoints, public
//
//  Synopsis:	Return enumerator on connection points
//
//  Arguments:	[ppEnum] -- Return pointer of enumerator
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CAsyncStorage::EnumConnectionPoints:%p()\n",
                  this));
    astgDebugOut((DEB_ITRACE,
                  "Out CAsyncStorage::EnumConnectionPoints\n"));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStorage::FindConnectionPoint, public
//
//  Synopsis:	Return a connection point given an IID
//
//  Arguments:	[iid] -- IID to return connection point for
//              [ppCP] -- Return location for pointer
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStorage::FindConnectionPoint(
    REFIID iid,
    IConnectionPoint **ppCP)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CAsyncStorage::FindConnectionPoint:%p()\n",
                  this));

    CConnectionPoint *pcp;
    
    if (IsEqualIID(iid, IID_IProgressNotify))
    {
        pcp = &_cpoint;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    pcp->AddRef();
    *ppCP = pcp;
    
    astgDebugOut((DEB_ITRACE,
                  "Out CAsyncStorage::FindConnectionPoint\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncRootStorage::QueryInterface, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncRootStorage::QueryInterface(REFIID iid, void **ppvObj)
{
	
    SCODE sc = S_OK;
    *ppvObj = NULL;

    astgDebugOut((DEB_ITRACE, "In  CAsyncRootStorage::QueryInterface:%p()\n", this));    
    if (IsEqualIID(iid, IID_IUnknown)) 
     
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IStorage))
    {
        *ppvObj = (IStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IRootStorage))
    {
        *ppvObj = (IRootStorage *)this;
    }
    else if (IsEqualIID(iid, IID_IConnectionPointContainer))
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
    {
        AddRef();
    }
    astgDebugOut((DEB_ITRACE, "Out  CAsyncRootStorage::QueryInterface:%p()\n", this));    
    return sc;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncRootStorage::AddRef, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncRootStorage::AddRef(void)
{	
    ULONG ulRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncRootStorage::AddRef:%p()\n", this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    _pRealStg->AddRef();
    astgDebugOut((DEB_ITRACE, "Out CAsyncRootStorage::AddRef\n"));
    return ulRet;
	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncRootStorage::Release, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAsyncRootStorage::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncRootStorage::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    _pRealStg->Release();
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;
    astgDebugOut((DEB_ITRACE, "Out CAsyncRootStorage::Release\n"));
    return (ULONG)lRet;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncRootStorage::SwitchToFile, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncRootStorage::SwitchToFile(OLECHAR *ptcsFile)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	IRootStorage *prstg;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStorage::%p()\n", this));
   

	if (!SUCCEEDED( _pRealStg->QueryInterface(IID_IRootStorage, (void **) &prstg)))
        return E_NOINTERFACE;
	
    do
	{
		sc = prstg->SwitchToFile(ptcsFile);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
	
	} while (sc == STG_E_PENDING );   

    astgDebugOut((DEB_ITRACE, "Out CAsyncStorage::\n"));	
    return ResultFromScode(sc); 	
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::QueryInterface, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CAsyncStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    *ppvObj = NULL;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::QueryInterface:%p()\n", this));    
    if (IsEqualIID(iid, IID_IUnknown)) 
     
    {
        *ppvObj = (IStream *)this;
    }
    else if (IsEqualIID(iid, IID_IStream))
    {
        *ppvObj = (IStream *)this;
    }
    else if (IsEqualIID(iid, IID_IConnectionPointContainer))
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
    {
        AddRef();
        _pRealStm->AddRef();
    }
    astgDebugOut((DEB_ITRACE, "Out  CAsyncStream::QueryInterface:%p()\n", this));    
    return sc;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::AddRef, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncStream::AddRef(void)
{	
    ULONG ulRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::AddRef:%p()\n", this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    _pRealStm->AddRef();
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::AddRef\n"));
    return ulRet;
	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Release, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncStream::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    _pRealStm->Release();
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Release\n"));
    return (ULONG)lRet;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Read, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStream::Read(VOID HUGEP *pv,
                                ULONG cb,
                                ULONG *pcbRead)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
   
  
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Read:%p()\n", this));
   
	do
	{
		sc = _pRealStm->Read(pv,cb,pcbRead);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	} while (sc == STG_E_PENDING );   

    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Read\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Write, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStream::Write(VOID const HUGEP *pv,
                                 ULONG cb,
                                 ULONG *pcbWritten)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;


    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Write:%p()\n", this));
   

    do
	{	sc = _pRealStm->Write(pv,cb,pcbWritten);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
	}  while (sc == STG_E_PENDING );   

    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Write\n"));	
    return ResultFromScode(sc); 	

}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Seek, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStream::Seek(LARGE_INTEGER dlibMove,
                                DWORD dwOrigin,
                                ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
   
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Seek:%p()\n", this));
   

    do
	{   
		sc = _pRealStm->Seek(dlibMove, dwOrigin,plibNewPosition);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}  while (sc == STG_E_PENDING );   

	astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Seek\n"));	
    return ResultFromScode(sc); 	

}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::CopyTo, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::CopyTo(IStream *pstm,
                                  ULARGE_INTEGER cb,
                                  ULARGE_INTEGER *pcbRead,
                                  ULARGE_INTEGER *pcbWritten)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::CopyTo:%p()\n", this));
   
    do
	{	sc = _pRealStm->CopyTo(pstm, cb,pcbRead, pcbWritten);

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}   while (sc == STG_E_PENDING );   

    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::CopyTo\n"));	
    return ResultFromScode(sc); 	

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::SetSize, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::SetSize(ULARGE_INTEGER cb)
{
	
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;


    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::SetSize%p()\n", this));
   

    do
	{	sc = _pRealStm->SetSize(cb);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
	
	} while (sc == STG_E_PENDING );   
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::SetSize\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Commit, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::Commit(DWORD grfCommitFlags)
{

	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
   
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Commit%p()\n", this));
   
    do
	{    
		sc = _pRealStm->Commit(grfCommitFlags);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}  while (sc == STG_E_PENDING );   
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Commit\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Revert, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::Revert(void)
{
    
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
  
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Revert%p()\n", this));
   
    do
	{
		sc = _pRealStm->Revert();
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	} while (sc == STG_E_PENDING );   
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Revert\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::LockRegion, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::LockRegion(ULARGE_INTEGER libOffset,
                                      ULARGE_INTEGER cb,
                                      DWORD dwLockType)
{
   
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::LockRegion%p()\n", this));
   

   do
   {	sc = _pRealStm->LockRegion(libOffset,
                                 cb,
                                 dwLockType);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 


	} while (sc == STG_E_PENDING );   
   
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::LockRegion\n"));	
    return ResultFromScode(sc); 	
}						  
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::UnlockRegion, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                        ULARGE_INTEGER cb,
                                        DWORD dwLockType)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::UnlockRegion%p()\n", this));
   
    do
	{
		sc = _pRealStm->UnlockRegion(libOffset,
                                   cb,
                                   dwLockType);		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}  while (sc == STG_E_PENDING );   
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::UnlockRegion\n"));	
    return ResultFromScode(sc); 	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Stat, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;


    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Stat%p()\n", this));
   

    do
	{	sc = _pRealStm->Stat(pstatstg, grfStatFlag);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}  while (sc == STG_E_PENDING );   
	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Stat\n"));	
    return ResultFromScode(sc); 	
}



//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::Clone, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStream::Clone(IStream **ppstm)
{
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	
    astgDebugOut((DEB_ITRACE, "In  CAsyncStream::Clone:%p()\n", this));
    do
    {
		sc = _pRealStm->Clone(ppstm);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
	
	}  while (sc == STG_E_PENDING );   
	
	
	
	if (SUCCEEDED(sc))
    {
        CAsyncStream *pwstm = new CAsyncStream(*ppstm, _pflb);
        *ppstm = (IStream *) pwstm;
		
    }	
    astgDebugOut((DEB_ITRACE, "Out CAsyncStream::Clone\n"));	
    return ResultFromScode(sc);   		
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::EnumConnectionPoints, public
//
//  Synopsis:	Return enumerator on connection points
//
//  Arguments:	[ppEnum] -- Return pointer of enumerator
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStream::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CAsyncStream::EnumConnectionPoints:%p()\n",
                  this));
    astgDebugOut((DEB_ITRACE,
                  "Out CAsyncStream::EnumConnectionPoints\n"));
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncStream::FindConnectionPoint, public
//
//  Synopsis:	Return a connection point given an IID
//
//  Arguments:	[iid] -- IID to return connection point for
//              [ppCP] -- Return location for pointer
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncStream::FindConnectionPoint(
    REFIID iid,
    IConnectionPoint **ppCP)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CAsyncStream::FindConnectionPoint:%p()\n",
                  this));

    CConnectionPoint *pcp;
    
    if (IsEqualIID(iid, IID_IProgressNotify))
    {
        pcp = &_cpoint;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    pcp->AddRef();
    *ppCP = pcp;
    
    astgDebugOut((DEB_ITRACE,
                  "Out CAsyncStream::FindConnectionPoint\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::QueryInterface, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------


STDMETHODIMP CAsyncEnum::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    *ppvObj = NULL;

    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::QueryInterface:%p()\n", this));    
    if (IsEqualIID(iid, IID_IUnknown)) 
     
    {
        *ppvObj = (IEnumSTATSTG *)this;
    }
    else if (IsEqualIID(iid, IID_IEnumSTATSTG))
    {
        *ppvObj = (IEnumSTATSTG *)this;
    }
    else if (IsEqualIID(iid, IID_IConnectionPointContainer))
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else
    {
        sc = E_NOINTERFACE;
    }

    if (SUCCEEDED(sc))
    {
        AddRef();
        _pRealEnum->AddRef();
    }
    astgDebugOut((DEB_ITRACE, "Out  CAsyncEnum::QueryInterface:%p()\n", this));    
    return sc;

}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::AddRef, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncEnum::AddRef(void)
{	
    ULONG ulRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::AddRef:%p()\n", this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    _pRealEnum->AddRef();
    astgDebugOut((DEB_ITRACE, "Out CAsyncEnum::AddRef\n"));
    return ulRet;
	
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::Release, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsyncEnum::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::Release:%p()\n", this));

    lRet = InterlockedDecrement(&_cReferences);
    _pRealEnum->Release();
    if (lRet == 0)
    {
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;
    astgDebugOut((DEB_ITRACE, "Out CAsyncEnum::Release\n"));
    return (ULONG)lRet;

}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::EnumConnectionPoints, public
//
//  Synopsis:	Return enumerator on connection points
//
//  Arguments:	[ppEnum] -- Return pointer of enumerator
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncEnum::EnumConnectionPoints(
    IEnumConnectionPoints **ppEnum)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CAsyncEnum::EnumConnectionPoints:%p()\n",
                  this));
    astgDebugOut((DEB_ITRACE,
                  "Out CAsyncEnum::EnumConnectionPoints\n"));
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::FindConnectionPoint, public
//
//  Synopsis:	Return a connection point given an IID
//
//  Arguments:	[iid] -- IID to return connection point for
//              [ppCP] -- Return location for pointer
//
//  Returns:	Appropriate status code
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CAsyncEnum::FindConnectionPoint(
    REFIID iid,
    IConnectionPoint **ppCP)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CAsyncEnum::FindConnectionPoint:%p()\n",
                  this));

    CConnectionPoint *pcp;
    
    if (IsEqualIID(iid, IID_IProgressNotify))
    {
        pcp = &_cpoint;
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    pcp->AddRef();
    *ppCP = pcp;
    
    astgDebugOut((DEB_ITRACE,
                  "Out CAsyncEnum::FindConnectionPoint\n"));
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::Next, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncEnum::Next(ULONG celt, STATSTG FAR *rgelt, ULONG *pceltFetched)
{
	
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
    

    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::Next:%p()\n", this));
    do
	{	sc = _pRealEnum->Next(celt, rgelt, pceltFetched);
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 
	} while (sc == STG_E_PENDING );      

    astgDebugOut((DEB_ITRACE, "Out CAsyncEnum::Next\n"));	
    return ResultFromScode(sc);  
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::Skip, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncEnum::Skip(ULONG celt)
{
	
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;
	

    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::Skip:%p()\n", this));
    sc = _pRealEnum->Skip(celt);
   
    do
	{
		sc = _pRealEnum->Reset();
		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	} while (sc == STG_E_PENDING );      

    astgDebugOut((DEB_ITRACE, "Out CAsyncEnum::Skip\n"));	
    return ResultFromScode(sc);  
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::Reset, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncEnum::Reset(void)
{
	
	SCODE sc = S_OK;
	SCODE sc2 = S_OK;

    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::Reset:%p()\n", this));
   
	do
	{	
		sc = _pRealEnum->Reset();

		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	} while (sc == STG_E_PENDING );      

    astgDebugOut((DEB_ITRACE, "Out CAsyncEnum::Reset\n"));	
    return ResultFromScode(sc);  
}
//+---------------------------------------------------------------------------
//
//  Member:	CAsyncEnum::Clone, public
//
//  Synopsis:	
//
//  Returns:	Appropriate status code
//
//  History:	01-Jan-96	SusiA	Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CAsyncEnum::Clone(IEnumSTATSTG **ppenm)
{
	
    SCODE sc = S_OK;
	SCODE sc2 = S_OK;
 
    astgDebugOut((DEB_ITRACE, "In  CAsyncEnum::Clone:%p()\n", this));
    
	do
	{

		sc = _pRealEnum->Clone(ppenm);
		
		if (( STG_E_PENDING==sc) && ((sc2 = Notify())!= S_OK))
			return ResultFromScode(sc2); 

	}  while (sc == STG_E_PENDING );      
	
	
	if (SUCCEEDED(sc))
    {
        CAsyncEnum *pwenum = new CAsyncEnum(*ppenm, _pflb);
        *ppenm = (IEnumSTATSTG *) pwenum;
		
    }	
    astgDebugOut((DEB_ITRACE, "Out CAsyncEnum::Clone\n"));	
    return ResultFromScode(sc);   	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\common.h ===
/*
 * common.h
 *
 * Definitions common to inflate and deflate
 */
#include "types.h"

#define NUM_CHARS				256
#define MIN_MATCH				3
#define MAX_MATCH				258

// window size
#define WINDOW_SIZE				32768
#define WINDOW_MASK				32767

// ZIP block types
#define BLOCKTYPE_UNCOMPRESSED	0
#define BLOCKTYPE_FIXED			1
#define BLOCKTYPE_DYNAMIC		2

// it's 288 and not 286 because we of the two extra codes which can appear
// in a static block; same for 32 vs 30 for distances
#define MAX_LITERAL_TREE_ELEMENTS	288
#define MAX_DIST_TREE_ELEMENTS		32
	
#define END_OF_BLOCK_CODE		256
#define	NUM_PRETREE_ELEMENTS	19
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\astg\stgconn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:	stgconn.cxx
//
//  Contents:	Connection points for Async Storage/Stream Wrappers
//
//  Classes:	
//
//  Functions:	
//
//  History:	19-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

#include "astghead.cxx"
#pragma hdrstop

#include "stgwrap.hxx"

//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::CConnectionPoint, public
//
//  Synopsis:	Constructor
//
//  Arguments:
//
//  History:	28-Dec-95	SusiA	Created
//
//----------------------------------------------------------------------------

CConnectionPoint::CConnectionPoint()
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::CConnectionPoint:%p()\n", this));
    _cReferences = 1;
    _dwCookie = 0;
    _pSinkHead = NULL;
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::CConnectionPoint\n"));
}


void CConnectionPoint::Init(IConnectionPointContainer *pCPC)
{
    _pCPC = pCPC;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::QueryInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	01-Jan-96	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc = S_OK;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::QueryInterface:%p()\n",
                  this));

    *ppvObj = NULL;

    if ((IsEqualIID(iid, IID_IUnknown)) ||
	(IsEqualIID(iid, IID_IConnectionPoint)))
    {
        *ppvObj = (IConnectionPoint *)this;
        CConnectionPoint::AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::QueryInterface\n"));
    return ResultFromScode(sc);
}



//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::AddRef, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void)
{
    ULONG ulRet;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::AddRef:%p()\n",
                  this));
    InterlockedIncrement(&_cReferences);
    ulRet = _cReferences;
    
    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::AddRef\n"));
    return ulRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Release, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CConnectionPoint::Release(void)
{
    LONG lRet;
    astgDebugOut((DEB_TRACE,
                  "In  CConnectionPoint::Release:%p()\n",
                  this));

    astgAssert(_cReferences > 0);
    lRet = InterlockedDecrement(&_cReferences);
    if (lRet == 0)
    {
        astgAssert((lRet > 0) && "Connection point released too many times.");
    }
    else if (lRet < 0)
        lRet = 0;
    
    astgDebugOut((DEB_TRACE, "Out CConnectionPoint::Release\n"));
    return (ULONG)lRet;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::GetConnectionInterface, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CConnectionPoint::GetConnectionInterface:%p()\n",
                  this));

    
    *pIID = IID_IProgressNotify;
          
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::GetConnectionInterface\n"));
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::GetConnectionPointContainer, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(
    IConnectionPointContainer ** ppCPC)
{
    astgDebugOut((DEB_ITRACE,
                  "In  CConnectionPoint::GetConnectionPointContainer:%p()\n",
                  this));

    *ppCPC = _pCPC;
    _pCPC->AddRef();
    
    astgDebugOut((DEB_ITRACE,
                  "Out CConnectionPoint::GetConnectionPointContainer\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Advise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	29-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnkSink,
                                      DWORD *pdwCookie)
{
    SCODE sc;
    CSinkList *pslTemp = NULL;
    CSinkList **ppslHead = NULL;
    void *pv = NULL;
    
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::Advise:%p()\n", this));
    
    IProgressNotify *ppn;
	
    // for the sweeper release, only one Advise sink per storage/Stream will be allowed 
    if (_pSinkHead != NULL)
        return  E_UNEXPECTED;

    //BUGBUG:  Multithread access
    astgMem(pslTemp = new CSinkList);

    //Note:  The QueryInterface will give us a reference to hold on to.
    astgChk(pUnkSink->QueryInterface(IID_IProgressNotify, &pv));
    pslTemp->SetProgressNotify((IProgressNotify *)pv);
    
    pslTemp->SetNext(_pSinkHead);

    *pdwCookie = ++_dwCookie;
    pslTemp->SetCookie(*pdwCookie);
    
    _pSinkHead = pslTemp;

    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::Advise\n"));
    return sc;
Err:
    delete pslTemp;
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::Unadvise, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
{
    CSinkList *pslTemp;
    CSinkList *pslPrev;
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::Unadvise:%p()\n", this));

    pslTemp = _pSinkHead;
    pslPrev = NULL;
    
    while ((pslTemp != NULL) && (pslTemp->GetCookie() != dwCookie))
    {
        pslPrev = pslTemp;
        pslTemp = pslTemp->GetNext();
    }

    if (pslTemp != NULL)
    {
        //Found the sink.  Delete it from the list.
        if (pslPrev != NULL)
        {
            pslPrev->SetNext(pslTemp->GetNext());
        }
        else
        {
            _pSinkHead = pslTemp->GetNext();
        }
        pslTemp->GetProgressNotify()->Release();
        
        delete pslTemp;
    }
    else
        //Client passed in unknown cookie.
        return E_UNEXPECTED;
        
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::Unadvise\n"));
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	CConnectionPoint::EnumConnections, public
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	30-Dec-95	SusiA	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

STDMETHODIMP CConnectionPoint::EnumConnections(
    IEnumConnections **ppEnum)
{
    astgDebugOut((DEB_ITRACE, "In  CConnectionPoint::EnumConnections:%p()\n", this));
    astgDebugOut((DEB_ITRACE, "Out CConnectionPoint::EnumConnections\n"));
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\api.c ===
/*
 * api.c
 *
 * Externally declared APIs
 */
#include <stdio.h>
#include <crtdbg.h>

#define DECLARE_DATA
#include "inflate.h"
#include "deflate.h"
#include "api_int.h"
#include "infgzip.h"
#include "fasttbl.h"
#include "crc32.h"


//
// Initialise global compression 
//
HRESULT WINAPI InitCompression(VOID)
{
	inflateInit();
	return S_OK;
}


//
// Initialise global decompression 
//
HRESULT WINAPI InitDecompression(VOID)
{
	deflateInit();
	return S_OK;
}


//
// De-init global compression
//
VOID WINAPI DeInitCompression(VOID)
{
}


//
// De-init global decompression
//
VOID WINAPI DeInitDecompression(VOID)
{
}


//
// Create a compression context
//
HRESULT WINAPI CreateCompression(PVOID *context, ULONG flags)
{
	t_encoder_context *ec;

    *context = (PVOID) LocalAlloc(LMEM_FIXED, sizeof(t_encoder_context));

    if (*context == NULL)
        return E_OUTOFMEMORY;

    ec = (t_encoder_context *) (*context);

    // no encoders initialised yet
	ec->std_encoder     = NULL;
    ec->optimal_encoder = NULL;
    ec->fast_encoder    = NULL;

    if (flags & COMPRESSION_FLAG_DO_GZIP)
        ec->using_gzip      = TRUE;
    else
        ec->using_gzip      = FALSE;

    InternalResetCompression(ec);

	return S_OK;
}


//
// Destroy a compression context
//
VOID WINAPI DestroyCompression(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    _ASSERT(void_context != NULL);

    if (context->std_encoder != NULL)
        LocalFree((PVOID) context->std_encoder);

    if (context->optimal_encoder != NULL)
        LocalFree((PVOID) context->optimal_encoder);

    if (context->fast_encoder != NULL)
        LocalFree((PVOID) context->fast_encoder);

	LocalFree(void_context);
}


//
// Create a decompression context
//
HRESULT WINAPI CreateDecompression(PVOID *context, ULONG flags)
{
	*context = (PVOID) LocalAlloc(LMEM_FIXED, sizeof(t_decoder_context));

    if (*context == NULL)
        return E_OUTOFMEMORY;

    if (flags & DECOMPRESSION_FLAG_DO_GZIP)
        ((t_decoder_context *) (*context))->using_gzip = TRUE;
    else
        ((t_decoder_context *) (*context))->using_gzip = FALSE;

	return ResetDecompression(*context);
}


//
// Destroy decompression context
//
VOID WINAPI DestroyDecompression(PVOID void_context)
{
    LocalFree(void_context);
}


//
// Reset compression context
//
HRESULT WINAPI ResetCompression(PVOID void_context)
{
	t_encoder_context *context = (t_encoder_context *) void_context;

    InternalResetCompression(context);

    // BUGBUG This forces a realloc of the particular compressor we are using
    // each time we reset, but if we don't do this then we are stuck with one
    // compressor (fast,std,optimal) forever until we destroy the context.
    // Should create a workaround for this problem.  Luckily, IIS creates a
    // new context all the time, and doesn't call reset (so says davidtr).
    DestroyIndividualCompressors(context);

	return S_OK;
}


//
// Reset decompression context
//
HRESULT WINAPI ResetDecompression(PVOID void_context)
{
	t_decoder_context *context = (t_decoder_context *) void_context;

    if (context->using_gzip)
    {
    	context->state	= STATE_READING_GZIP_HEADER;
        context->gzip_header_substate = 0;
        DecoderInitGzipVariables(context);
    }
    else
    {
	    context->state	= STATE_READING_BFINAL_NEED_TO_INIT_BITBUF;
    }

    context->bufpos = 0;
	context->bitcount = -16;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\api_int.h ===
/*
 * api_int.h
 *
 * Internal API function prototypes and flags
 *
 * The api.h which is given to decompression clients is hand-created from this file.
 */
// flags for CreateCompression() and CreateDeCompression()
#define COMPRESSION_FLAG_DEFLATE    0 
#define COMPRESSION_FLAG_GZIP       1 

#define COMPRESSION_FLAG_DO_GZIP      COMPRESSION_FLAG_GZIP
#define DECOMPRESSION_FLAG_DO_GZIP    COMPRESSION_FLAG_GZIP

// Initialise global DLL compression data
HRESULT	WINAPI InitCompression(VOID);

// Initialise global DLL decompression data
HRESULT	WINAPI InitDecompression(VOID);

// Free global compression data
VOID    WINAPI DeInitCompression(VOID);

// Free global decompression data
VOID    WINAPI DeInitDecompression(VOID);

// Create a new compression context
HRESULT	WINAPI CreateCompression(PVOID *context, ULONG flags);

// Compress data
HRESULT WINAPI Compress(
	PVOID				context,            // compression context
	CONST BYTE *		input_buffer,       // input buffer
	LONG				input_buffer_size,  // size of input buffer
	PBYTE				output_buffer,      // output buffer
	LONG				output_buffer_size, // size of output buffer
	PLONG				input_used,         // amount of input buffer used
	PLONG				output_used,        // amount of output buffer used
	INT					compression_level   // compression level (1...10)
);

// Reset compression state (for compressing new file)
HRESULT	WINAPI ResetCompression(PVOID context);

// Destroy compression context
VOID	WINAPI DestroyCompression(PVOID context);

// Create a decompression context
HRESULT WINAPI CreateDecompression(PVOID *context, ULONG flags);

// Decompress data
HRESULT WINAPI Decompress(
	PVOID				void_context,
	CONST BYTE *		input, 
	LONG				input_size,
	BYTE *				output, 
	LONG				output_size,
	PLONG				input_used,
	PLONG				output_used
);

HRESULT	WINAPI ResetDecompression(PVOID void_context);

VOID	WINAPI DestroyDecompression(PVOID void_context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\comninit.c ===
//
// comninit.c
//
// Initialisation code common to inflate and deflate
//
#include <stdio.h>
#include <crtdbg.h>
#include "inflate.h"
#include "deflate.h"


// Called by InitCompression() and InitDecompression() (functions to init global DLL data)
//
// Initialises the tree lengths of static type blocks
//
void InitStaticBlock(void)
{
    int i;

    // No real thread synchronisation problems with doing this
    if (g_InitialisedStaticBlock == FALSE)
    {
        g_InitialisedStaticBlock = TRUE;

        for (i = 0; i <= 143; i++)
        	g_StaticLiteralTreeLength[i] = 8;

        for (i = 144; i <= 255; i++)
	        g_StaticLiteralTreeLength[i] = 9;

        for (i = 256; i <= 279; i++)
	        g_StaticLiteralTreeLength[i] = 7;

        for (i = 280; i <= 287; i++)
	        g_StaticLiteralTreeLength[i] = 8;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\crc32.h ===
//
// crc32.h
//
// CRC32 table
//
#ifdef DECLARE_DATA
const ULONG g_CrcTable[256] = {
  0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
  0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
  0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
  0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
  0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
  0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
  0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
  0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
  0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
  0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
  0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
  0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
  0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
  0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
  0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
  0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
  0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
  0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
  0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
  0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
  0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
  0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
  0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
  0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
  0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
  0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
  0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
  0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
  0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
  0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
  0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
  0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
  0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
  0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
  0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
  0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
  0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
  0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
  0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
  0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
  0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
  0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
  0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
  0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
  0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
  0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
  0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
  0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
  0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
  0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
  0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
  0x2d02ef8dL
};
#else /* !DECLARE_DATA */
extern const ULONG g_CrcTable[256];
#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\comndata.h ===
//
// comndata.h
//
// Common to inflate and deflate
//
#ifndef _COMNDATA_H
#define _COMNDATA_H

#ifdef DECLARE_DATA

const BYTE g_CodeOrder[] = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
const BYTE g_ExtraLengthBits[] = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
const BYTE g_ExtraDistanceBits[] = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0};
const ULONG g_LengthBase[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};
const ULONG g_DistanceBasePosition[] = {1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};
const ULONG g_BitMask[] = {0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767};

BYTE    g_LengthLookup[256];
BYTE    g_DistLookup[512];

BYTE    g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
USHORT  g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];

// note: g_StaticDistanceTreeLength == 5 for all distances, which is why we don't have a
// table for that
USHORT  g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

BOOL    g_InitialisedStaticBlock = FALSE;

#else /* !DECLARE_DATA */

extern const BYTE g_CodeOrder[19];
extern const BYTE g_ExtraLengthBits[];
extern const BYTE g_ExtraDistanceBits[];
extern const ULONG g_LengthBase[];
extern const ULONG g_DistanceBasePosition[];
extern const ULONG g_BitMask[];

extern BYTE     g_LengthLookup[256];
extern BYTE     g_DistLookup[512];

extern BYTE     g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

extern BOOL     g_InitialisedStaticBlock;

#endif /* !DECLARE_DATA */

#endif /* _COMNDATA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\defctxt.h ===
/*
 * defctxt.h
 *
 * Deflate context
 */
typedef unsigned short	t_search_node;
typedef unsigned int	t_match_pos;


typedef enum
{
	STATE_NORMAL,
	STATE_OUTPUTTING_TREE_STRUCTURE,
	STATE_OUTPUTTING_BLOCK
} t_encoder_state;



struct fast_encoder;
struct optimal_encoder;
struct std_encoder;


//
// Context info common to all encoders
//
typedef struct
{
	t_encoder_state			state;

	unsigned long			outputting_block_bitbuf;
	int						outputting_block_bitcount;
	byte *					outputting_block_bufptr;
	unsigned int			outputting_block_current_literal;
	unsigned int			outputting_block_num_literals;

	long					bufpos;
	long					bufpos_end;

    // output buffer
	BYTE *					output_curpos;
	BYTE *					output_endpos;
	BYTE *					output_near_end_threshold;

	// bit buffer variables for outputting data
	unsigned long			bitbuf;
	int						bitcount;

    // varies; std/optimal encoders use the normal 32K window, while the fast
    // encoder uses a smaller window
    long                    window_size;

	struct std_encoder *	std_encoder;
	struct optimal_encoder *optimal_encoder;
    struct fast_encoder *   fast_encoder;

	BOOL					no_more_input;
	
	// have we output "bfinal=1"?
	BOOL					marked_final_block;

    // do we need to call ResetCompression() before we start compressing?
    BOOL                    fNeedToResetCompression;

    // if GZIP, have we output the GZIP header?
    BOOL                    using_gzip;
    BOOL                    gzip_fOutputGzipHeader;
    ULONG                   gzip_crc32;
    ULONG                   gzip_input_stream_size;
} t_encoder_context;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\defgzip.h ===
//
// defgzip.h
//
// Gzip additions to deflate
//

// compressing
void WriteGzipHeader(t_encoder_context *context, int compression_level);
void WriteGzipFooter(t_encoder_context *context);
void GzipCRCmemcpy(t_encoder_context *context, BYTE *dest, const BYTE *src, ULONG count);
void EncoderInitGzipVariables(t_encoder_context *context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\defdata.h ===
//
// defdata.h
//
// Data specific to deflate
//
// BUGBUG Some of these USHORTs could be made into ULONGs for speed-of-access.  The disadvantage would
//        be greater memory/cache usage.  g_StaticDistanceTreeCode[] could be made into a BYTE array,
//        since the codes are 5 bits.  Changes of this nature will require various code changes elsewhere.
//
#ifdef DECLARE_DATA

// lookup tables for finding the slot number of a match length or distance
BYTE    g_LengthLookup[256];
BYTE    g_DistLookup[512];

// literal codes for static blocks
BYTE    g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
USHORT  g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];

// distance codes for static blocks
// note: g_StaticDistanceTreeLength == 5 for all distances, which is why we don't have a table for that
USHORT  g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

// cached tree structure output for fast encoder
BYTE    g_FastEncoderTreeStructureData[MAX_TREE_DATA_SIZE];
int     g_FastEncoderTreeLength; // # bytes in g_FastEncoderTreeStructureData
ULONG   g_FastEncoderPostTreeBitbuf; // final value of bitbuf
int     g_FastEncoderPostTreeBitcount; // final value of bitcount

#else /* !DECLARE_DATA */

extern BYTE     g_LengthLookup[256];
extern BYTE     g_DistLookup[512];

extern BYTE     g_StaticLiteralTreeLength[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticLiteralTreeCode[MAX_LITERAL_TREE_ELEMENTS];
extern USHORT   g_StaticDistanceTreeCode[MAX_DIST_TREE_ELEMENTS];

extern BYTE     g_FastEncoderTreeStructureData[MAX_TREE_DATA_SIZE];
extern int      g_FastEncoderTreeLength;
extern ULONG    g_FastEncoderPostTreeBitbuf;
extern int      g_FastEncoderPostTreeBitcount;

#endif /* !DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\definit.c ===
//
// definit.c
//
// Initialisation code for deflate (compression stage)
//
// Includes both some one-time init routines, as well as a per context/reset init routine
//
#include "types.h"
#include "deflate.h"
#include "inflate.h"
#include "defproto.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// This function is called by the standard and optimal encoders, and creates the initial tree
// used to record literals for the first block.  After the first block we use the last block's
// trees to record data.
//
// This function does not change global data, and is called one a per context creation/reset.
//
VOID DeflateInitRecordingTables(
    BYTE *  recording_literal_len,
    USHORT *recording_literal_code,
    BYTE *  recording_dist_len,
    USHORT *recording_dist_code
)
{
    // BUGBUG These frequencies were taken from running on some text file, better stats could
    // be obtained from using an html page.  This barely affects compression though; bad estimates
    // will just make the recording buffer fill up a little bit sooner, making us output a block
    // a little sooner, which isn't always a bad thing anyway.
	USHORT	recording_dist_tree_freq[MAX_DIST_TREE_ELEMENTS*2] = 
	{
		2,2,3,4,3,7,16,22,42,60,100,80,149,158,223,200,380,324,537,
		477,831,752,1231,999,1369,1100,2034,1667,2599,2216,0,0
	};

	USHORT	recording_literal_tree_freq[MAX_LITERAL_TREE_ELEMENTS*2];

    int i;

	makeTree(
		MAX_DIST_TREE_ELEMENTS, 
		RECORDING_DIST_MAX_CODE_LEN, 
		recording_dist_tree_freq, 
		recording_dist_code, 
		recording_dist_len
	);

    // BUGBUG Put a better estimation in here!  This assumes all literals (chars and matches)
    // are equally likely, which they aren't (although all chars might be fairly equal for a
    // binary file).
	for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)
		recording_literal_tree_freq[i] = 1;

	makeTree(
		MAX_LITERAL_TREE_ELEMENTS, 
		RECORDING_LIT_MAX_CODE_LEN, 
		recording_literal_tree_freq, 
		recording_literal_code, 
		recording_literal_len
	);
}


//
// One-time init
//
// Generate the global slot tables which allow us to convert a distance
// (0..32K) to a distance slot (0..29), and a length (3..258) to
// a length slot (0...28)
//
static void GenerateSlotTables(void)
{
	int code, length, dist, n;

        /* Initialize the mapping length (0..255) -> length code (0..28) */
	length = 0;
	
	for (code = 0; code < NUM_LENGTH_BASE_CODES-1; code++)
	{
		for (n = 0; n < (1 << g_ExtraLengthBits[code]); n++) 
			g_LengthLookup[length++] = (byte) code;
	}

	g_LengthLookup[length-1] = (byte) code;

        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	dist = 0;
    
	for (code = 0 ; code < 16; code++)
	{
		for (n = 0; n < (1 << g_ExtraDistanceBits[code]); n++)
			g_DistLookup[dist++] = (byte) code;
	}

	dist >>= 7; /* from now on, all distances are divided by 128 */
    
	for ( ; code < NUM_DIST_BASE_CODES; code++) 
	{
		for (n = 0; n < (1 << (g_ExtraDistanceBits[code]-7)); n++) 
			g_DistLookup[256 + dist++] = (byte) code;
	}

    // ensure we didn't overflow the array
    _ASSERT(256 + dist <= sizeof(g_DistLookup)/sizeof(g_DistLookup[0]));
}


//
// One-time init
//
// Generate tables for encoding static blocks
//
static void GenerateStaticEncodingTables(void)
{
    int     i;
    int     len_cnt[17];
    BYTE    StaticDistanceTreeLength[MAX_DIST_TREE_ELEMENTS];

    // ensure we have already created the StaticLiteralTreeLength array
    // if we haven't, then this value would be zero
    _ASSERT(g_StaticLiteralTreeLength[0] != 0);

    //
    // Make literal tree
    //
    for (i = 0; i < 17; i++)
        len_cnt[i] = 0;

    // length count (how many length 8's, 9's, etc. there are) - needed to call makeCode()
    len_cnt[8] = 144;
    len_cnt[9] = 255-144+1;
    len_cnt[7] = 279-256+1;
    len_cnt[8] += (287-280)+1;

    makeCode(
        MAX_LITERAL_TREE_ELEMENTS, 
        len_cnt, 
        g_StaticLiteralTreeLength,
        g_StaticLiteralTreeCode
    );

    //
    // Make distance tree; there are 32 5-bit codes
    //
    for (i = 0; i < 17; i++)
        len_cnt[i] = 0;

    len_cnt[5] = 32;

    // We don't store StaticDistanceTreeLength[] globally, since it's 5 for everything,
    // but we need it to call makeCode()
    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
        StaticDistanceTreeLength[i] = 5;

    makeCode(
        MAX_DIST_TREE_ELEMENTS, 
        len_cnt, 
        StaticDistanceTreeLength,
        g_StaticDistanceTreeCode
    );
}


//
// Initialise global deflate data in the DLL
//
VOID deflateInit(VOID)
{
    GenerateSlotTables();
    InitStaticBlock();
    GenerateStaticEncodingTables();

    // For the fast encoder, take the hard-coded global tree we're using (which is NOT the same as
    // a static block's tree), generate the bitwise output for outputting the structure of that
    // tree, and record that globally, so that we can do a simple memcpy() to output the tree for
    // the fast encoder, instead of calling the tree output routine all the time.  This is a nifty
    // performance optimisation.
    FastEncoderGenerateDynamicTreeEncoding();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\deflate.h ===
//
// deflate.h
//

// common to inflate and deflate
#include "common.h"


// ZIP constants
#define NUM_LENGTH_BASE_CODES		29
#define NUM_DIST_BASE_CODES			30

#define NUM_PRETREE_ELEMENTS		19


//
// For std and optimal encoders, recording buffer encoding max bit lengths and
// decoding table sizes
//
#define REC_LITERALS_DECODING_TABLE_BITS 12
#define REC_DISTANCES_DECODING_TABLE_BITS 8

#define REC_LITERALS_DECODING_TABLE_SIZE (1 << REC_LITERALS_DECODING_TABLE_BITS)
#define REC_LITERALS_DECODING_TABLE_MASK (REC_LITERALS_DECODING_TABLE_SIZE-1)

#define REC_DISTANCES_DECODING_TABLE_SIZE (1 << REC_DISTANCES_DECODING_TABLE_BITS)
#define REC_DISTANCES_DECODING_TABLE_MASK (REC_DISTANCES_DECODING_TABLE_SIZE-1)

//
// The maximum code lengths to allow for recording (we don't want really large
// 15 bit codes, just in case uncommon chars suddenly become common due to a change
// in the data).
//
#define RECORDING_DIST_MAX_CODE_LEN	9
#define RECORDING_LIT_MAX_CODE_LEN	13


//
// Max size of tree output (in bytes)
//
// We require that the output buffer have at least this much data available, so that we can
// output the tree in one chunk
//
#define MAX_TREE_DATA_SIZE			512


//
// Return the position slot (0...29) of a match offset (0...32767)
//
#define POS_SLOT(pos) g_DistLookup[((pos) < 256) ? (pos) : (256 + ((pos) >> 7))]


// context structure
#include "defctxt.h"

// encoders
#include "stdenc.h"
#include "optenc.h"
#include "fastenc.h"

// prototypes
#include "defproto.h"

// variables
#include "defdata.h"
#include "comndata.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\defmisc.c ===
//
// defmisc.c
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// Fix the frequency data of the provided literal and distance trees such that no
// element has a zero frequency.  We must never allow the cumulative frequency of
// either tree to be >= 65536, so we divide all of the frequencies by two to make
// sure.
//
void NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq)
{
	int i;

	// don't allow any zero frequency items to exist
	// also make sure we don't overflow 65535 cumulative frequency
	for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
	{
		// avoid overflow
		dist_tree_freq[i] >>= 1;

		if (dist_tree_freq[i] == 0)
			dist_tree_freq[i] = 1;
	}

	for (i = 0; i < MAX_LITERAL_TREE_ELEMENTS; i++)
	{
		// avoid overflow
		literal_tree_freq[i] >>= 1;

		if (literal_tree_freq[i] == 0)
			literal_tree_freq[i] = 1;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\deflate.c ===
/*
 * deflate.c
 *
 * Main compression entrypoint for all three encoders
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "fasttbl.h"
#include "defgzip.h"


typedef struct config_s
{
   int good_length; /* reduce lazy search above this match length */
   int max_lazy;    /* do not perform lazy search above this match length */
   int nice_length; /* quit search above this match length */
   int max_chain;
} compression_config;


static const compression_config configuration_table[11] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0 },  /* store only */
/* 1 */ {4,    4,  8,    4 }, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8 },
/* 3 */ {4,    6, 32,   32 },

/* 4 */ {4,    4, 16,   16 },  /* lazy matches */
/* 5 */ {8,   16, 32,   32 },
/* 6 */ {8,   16, 128, 128 },
/* 7 */ {8,   32, 128, 256 },
/* 8 */ {32, 128, 258, 1024 },
/* 9 */ {32, 258, 258, 4096 }, 
/* 10 */ {32, 258, 258, 4096 } /* maximum compression */
};


//
// Destroy the std encoder, optimal encoder, and fast encoder, but leave the 
// compressor context around
//
VOID DestroyIndividualCompressors(PVOID void_context)
{
    t_encoder_context *context = (t_encoder_context *) void_context;

    if (context->std_encoder != NULL)
    {
        LocalFree((PVOID) context->std_encoder);
        context->std_encoder = NULL;
    }

    if (context->optimal_encoder != NULL)
    {
        LocalFree((PVOID) context->optimal_encoder);
        context->optimal_encoder = NULL;
    }

    if (context->fast_encoder != NULL)
    {
        LocalFree((PVOID) context->fast_encoder);
        context->fast_encoder = NULL;
    }
}


//
// Mark the final block in the compressed data
// 
// There must be one final block with bfinal=1 indicating that it is the last one.  In the case of
// the fast encoder we just need to output the end of block code, since the fast encoder just outputs
// one very long block.
//
// In the case of the standard and optimal encoders we have already finished outputting blocks,
// so we output a new block (a static/fixed block) with bfinal=1, consisting merely of the
// end of block code.
//
static void markFinalBlock(t_encoder_context *context)
{
    if (context->fast_encoder != NULL)
    {
        // The fast encoder outputs one long block, so it just needs to terminate this block
        outputBits(
            context, 
            g_FastEncoderLiteralTreeLength[END_OF_BLOCK_CODE], 
            g_FastEncoderLiteralTreeCode[END_OF_BLOCK_CODE]
        );
    }
    else
    {
        // To finish, output a static block consisting of a single end of block code

        // Combined these three outputBits() calls (commented out) into one call
        // The total number of bits output in one shot must be <= 16, but we're ok
        // since the the length of END_OF_BLOCK_CODE is 7 for a static (fixed) block
#if 0
    	outputBits(context, 1, 1); // bfinal = 1
        outputBits(context, 2, BLOCKTYPE_FIXED);
        outputBits(context, g_StaticLiteralTreeLength[END_OF_BLOCK_CODE], g_StaticLiteralTreeCode[END_OF_BLOCK_CODE]);
#endif

        // note: g_StaticLiteralTreeCode[END_OF_BLOCK_CODE] == 0x0000
        outputBits(
            context,
            (7 + 3), // StaticLiteralTreeLength[END_OF_BLOCK_CODE]=7, + 1 bfinal bit + 2 blocktype bits
            ((0x0000) << 3) | (BLOCKTYPE_FIXED << 1) | 1
        );
    }

    // flush bits from bit buffer to output buffer
    flushOutputBitBuffer(context);

    if (context->using_gzip)
        WriteGzipFooter(context);
}


//
// Returns a pointer to the start of the window of the currently active compressor
//
// Used for memcpy'ing window data when we reach the end of the window
//
static BYTE *GetEncoderWindow(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL || context->fast_encoder != NULL);

    if (context->std_encoder != NULL)
        return context->std_encoder->window;
    else if (context->optimal_encoder != NULL)
        return context->optimal_encoder->window;
    else
        return context->fast_encoder->window;
}


//
// This function does the actual work of resetting the compression state.
// However, it does not free the std/fast/optimal encoder memory (something
// that the external ResetCompression() API currently does).
//
void InternalResetCompression(t_encoder_context *context)
{
	context->no_more_input      = FALSE;
	context->marked_final_block = FALSE;
	context->state              = STATE_NORMAL;
	context->outputting_block_num_literals = 0;

    if (context->using_gzip)
        EncoderInitGzipVariables(context);

	InitBitBuffer(context);
}


//
// The compress API
//
HRESULT WINAPI Compress(
	PVOID				void_context,
	CONST BYTE *		input_buffer,
	LONG				input_buffer_size,
	PBYTE				output_buffer,
	LONG				output_buffer_size,
	PLONG				input_used,
	PLONG				output_used,
	INT					compression_level
)
{
	int				    lazy_match_threshold;
    int                 search_depth;
    int                 good_length;
    int                 nice_length;
	t_encoder_context * context = (t_encoder_context *) void_context;
    t_std_encoder *     std_encoder;
    t_optimal_encoder * optimal_encoder;
    t_fast_encoder *    fast_encoder;
    HRESULT             result = S_OK; // default to success

    *input_used = 0;
    *output_used = 0;

    // validate compression level
	if (compression_level < 0 || compression_level > 10)
    {
        result = E_INVALIDARG;
        goto exit;
    }

	context->output_curpos				= output_buffer;
	context->output_endpos				= output_buffer + output_buffer_size;
	context->output_near_end_threshold	= output_buffer + output_buffer_size - 16;

    //
    // Have we allocated the particular compressor we want yet?
    //
    if (context->std_encoder == NULL && context->optimal_encoder == NULL && context->fast_encoder == NULL)
    {
        // No
        if (compression_level <= 3) // fast encoder
        {
    		if (FastEncoderInit(context) == FALSE)
            {
	    		result = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else if (compression_level == 10) // optimal encoder
        {
    		if (OptimalEncoderInit(context) == FALSE)
            {
	    		result = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
        {
	    	if (StdEncoderInit(context) == FALSE)
            {
	    		result = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

    std_encoder     = context->std_encoder;
    optimal_encoder = context->optimal_encoder;
    fast_encoder    = context->fast_encoder;

	_ASSERT(std_encoder != NULL || optimal_encoder != NULL || fast_encoder != NULL);

	// set search depth
    if (fast_encoder != NULL)
    {
    	search_depth = configuration_table[compression_level].max_chain;
    	good_length = configuration_table[compression_level].good_length; 
    	nice_length = configuration_table[compression_level].nice_length; 
    	lazy_match_threshold = configuration_table[compression_level].max_lazy;
    }
    else if (std_encoder != NULL)
    {
    	search_depth = configuration_table[compression_level].max_chain;
    	good_length = configuration_table[compression_level].good_length; 
    	nice_length = configuration_table[compression_level].nice_length; 
    	lazy_match_threshold = configuration_table[compression_level].max_lazy;
    }

	// the output buffer must be large enough to contain an entire tree
	if (output_buffer_size < MAX_TREE_DATA_SIZE)
	{
        result = E_INVALIDARG;
        goto exit;
	}

    if (context->using_gzip && context->gzip_fOutputGzipHeader == FALSE)
    {
        // Write the GZIP header
        WriteGzipHeader(context, compression_level);
        context->gzip_fOutputGzipHeader = TRUE;
    }

	//
	// Check if previously we were in the middle of outputting a block
	//
	if (context->state != STATE_NORMAL)
	{
        // The fast encoder is a special case; it doesn't use OutputBlock()
        if (fast_encoder != NULL)
            goto start_encoding;

        // yes we were, so continue outputting it
        OutputBlock(context);

		//
		// Check if we're still outputting a block (it may be a long block that
		// has filled up the output buffer again)
		//
        // If we're coming close to the end of the buffer, and may not have enough space to
        // output a full tree structure, stop now.
        //
		if (context->state != STATE_NORMAL || 
            context->output_endpos - context->output_curpos < MAX_TREE_DATA_SIZE)
		{
			*output_used = (long) (context->output_curpos - output_buffer);
            goto set_output_used_then_exit; // success
		}

		//
		// We finished outputting the previous block, so time to compress some more input 
		//
	}

#ifdef _DEBUG
    // Fast encoder doesn't use outputBlock, so it doesn't have the tree limitation
    if (fast_encoder == NULL)
        _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);
#endif

	//
	// input_buffer_size == 0 means "this is the final block"
	//
	// Of course, the client may still need to call Compress() many more times if the output 
	// buffer is small and there is a big block waiting to be sent.
	//
	// We may even have some pending input data in our buffer waiting to be compressed.
	//
	if ((input_buffer_size == 0 || context->no_more_input) && context->bufpos >= context->bufpos_end)
	{
		// if we're ever passed zero bytes of input, it means that there will never be any
		// more input
		context->no_more_input = TRUE;

		// output existing block
        // this never happens for the fast encoder, since we don't record blocks
   		if (context->outputting_block_num_literals != 0)
        {
            FlushRecordingBuffer(context);
            OutputBlock(context);

	    	//
    		// Still outputting a block?
   			//
	    	if (context->state != STATE_NORMAL)
                goto set_output_used_then_exit; // success
        }

        // for the fast encoder only, we won't have output our fast encoder preamble if the
        // file size == 0, so output it now if we haven't already.
        if (fast_encoder != NULL)
        {
            if (fast_encoder->fOutputBlockHeader == FALSE)
            {
                fast_encoder->fOutputBlockHeader = TRUE;
                FastEncoderOutputPreamble(context);
            }
        }

		// if we've already marked the final block, don't do it again
		if (context->marked_final_block)
		{
            result = S_FALSE;
            goto set_output_used_then_exit; // should be zero output used
		}

		// ensure there is enough space to output the final block (max 8 bytes)
		if (context->output_curpos + 8 >= context->output_endpos)
            goto set_output_used_then_exit; // not enough space - do it next time

		// output the final block (of length zero - we just want the bfinal=1 marker)
		markFinalBlock(context);
		context->marked_final_block = TRUE;

        result = S_FALSE;
        goto set_output_used_then_exit;
	}

	// while there is more input data (passed in as parameters) or existing data in
	// the window to compress
start_encoding:
	while ((input_buffer_size > 0) || (context->bufpos < context->bufpos_end))
	{
		long amount_to_compress;
		long window_space_available;

		_ASSERT(context->bufpos >= context->window_size && context->bufpos < (2*context->window_size));

#ifdef _DEBUG
        // Fast encoder doesn't use outputBlock, so it doesn't have the tree limitation
        if (fast_encoder == NULL)
            _ASSERTE(context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE);
#endif

		// read more input data into the window if there is space available
		window_space_available = (2*context->window_size) - context->bufpos_end;

		amount_to_compress = (input_buffer_size < window_space_available) ? input_buffer_size : window_space_available;

		if (amount_to_compress > 0)
		{
			*input_used += amount_to_compress;

			// copy data into history window
            if (context->using_gzip)
            {
                // In addition to copying data into the history window, GZIP wants a crc32 of the input data.
                // We will do both of these things at the same time for the purposes of data locality,
                // performance etc.
                GzipCRCmemcpy(context, GetEncoderWindow(context) + context->bufpos_end, input_buffer, amount_to_compress);
            }
            else
            {
                // Copy data into history window
    		    memcpy(GetEncoderWindow(context) + context->bufpos_end, input_buffer, amount_to_compress);
            }

			input_buffer		+= amount_to_compress;
			input_buffer_size	-= amount_to_compress;

			// last input location
			context->bufpos_end += amount_to_compress;
		}

		if (optimal_encoder != NULL)
			OptimalEncoderDeflate(context);
		else if (std_encoder != NULL)
			StdEncoderDeflate(context, search_depth, lazy_match_threshold, good_length, nice_length);
        else if (fast_encoder != NULL)
			FastEncoderDeflate(context, search_depth, lazy_match_threshold, good_length, nice_length);

		// either we reached the end of the buffer, or we had to output a block and ran out
		// of output space midway
		_ASSERT(context->bufpos == context->bufpos_end || context->state != STATE_NORMAL);

		// if we ran out of output space, break now
		if (context->state != STATE_NORMAL)
			break;

        // another check for running out of output space
        if (fast_encoder == NULL && context->output_endpos - context->output_curpos >= MAX_TREE_DATA_SIZE)
            break;

	} /* end ... while (input_buffer_size > 0) */

set_output_used_then_exit:
	*output_used = (long) (context->output_curpos - output_buffer);

exit:
    _ASSERT(*output_used < output_buffer_size); // make sure we didn't overflow the output buffer
	_ASSERT(context->bufpos >= context->window_size && context->bufpos <= 2*context->window_size); // make sure bufpos is sane

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\defproto.h ===
//
// defproto.h
//
// Function prototypes

// comninit.c
void InitStaticBlock(void);

// definit.c
VOID deflateInit(VOID);

VOID DeflateInitRecordingTables(
    BYTE *  recording_literal_len,
    USHORT *recording_literal_code,
    BYTE *  recording_dist_len,
    USHORT *recording_dist_code
);

// output.c
void outputBits(t_encoder_context *context, int n, int x);
void flushOutputBitBuffer(t_encoder_context *context);
void InitBitBuffer(t_encoder_context *context);
void FlushRecordingBuffer(t_encoder_context *context);
void outputTreeStructure(t_encoder_context *context, const BYTE *literal_tree_len, const BYTE *dist_tree_len);
void OutputBlock(t_encoder_context *context);

// deftree.c
void makeTree(
	int					num_elements,
	int					max_code_length,
	unsigned short *	freq,
	unsigned short *	code,
	byte *				len
);

void makeCode(int num_elements, const int *len_cnt, const BYTE *len, USHORT *code);

// optfmtch.c
int optimal_find_match(t_encoder_context *context, long BufPos);
void optimal_insert(t_encoder_context *context, long BufPos, long end_pos);
void optimal_remove_node(t_encoder_context *context, long BufPos, ULONG end_pos);
void removeNodes(t_encoder_context *context);
void reinsertRemovedNodes(t_encoder_context *context);

// optenc.c
void OptimalEncoderDeflate(t_encoder_context *context);
void OptimalEncoderReset(t_encoder_context *context);
BOOL OptimalEncoderInit(t_encoder_context *context);
void OptimalEncoderZeroFrequencyCounts(t_optimal_encoder *encoder);

// stdenc.c
void StdEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
);

void StdEncoderReset(t_encoder_context *context);
BOOL StdEncoderInit(t_encoder_context *context);
void StdEncoderZeroFrequencyCounts(t_std_encoder *encoder);

// stdblock.c
BOOL StdEncoderOutputBlock(t_encoder_context *context);

// fastenc.c
BOOL FastEncoderInit(t_encoder_context *context);

void FastEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
);

VOID FastEncoderCreateStaticTrees(VOID);
void FastEncoderGenerateDynamicTreeEncoding(void);
void FastEncoderOutputPreamble(t_encoder_context *context);

// deflate.c
VOID DestroyIndividualCompressors(PVOID void_context);
void InternalResetCompression(t_encoder_context *context);

HRESULT WINAPI Compress(
	PVOID				void_context,
	CONST BYTE *		input_buffer,
	LONG				input_buffer_size,
	PBYTE				output_buffer,
	LONG				output_buffer_size,
	PLONG				input_used,
	PLONG				output_used,
	INT					compression_level
);

// defmisc.c
void NormaliseFrequencies(USHORT *literal_tree_freq, USHORT *dist_tree_freq);

// optblock.c
BOOL OptimalEncoderOutputBlock(t_encoder_context *context);

// stddebug.c
#ifdef _DEBUG
void StdEncoderVerifyHashes(t_encoder_context *context, long bufpos);
void StdEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number);
#endif

// optdebug.c
#ifdef _DEBUG
void OptimalEncoderVerifyHashes(t_encoder_context *context, long bufpos);
#endif

// fstdebug.c
#ifdef _DEBUG
void FastEncoderVerifyHashes(t_encoder_context *context, long bufpos);
void FastEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\fasttbl.h ===
#ifdef DECLARE_DATA
const BYTE g_FastEncoderLiteralTreeLength[] = {
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0c,0x06,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0d,0x0e,
0x06,0x0e,0x0a,0x0c,0x0e,0x0e,0x0d,0x0a,0x08,0x09,0x0b,0x0a,0x07,0x08,0x07,0x09,
0x08,0x08,0x08,0x09,0x08,0x09,0x0a,0x09,0x08,0x09,0x09,0x08,0x09,0x0a,0x08,0x0e,
0x0e,0x08,0x09,0x08,0x09,0x08,0x09,0x0a,0x0b,0x08,0x0b,0x0e,0x09,0x0a,0x09,0x0a,
0x09,0x0c,0x09,0x09,0x09,0x0a,0x0c,0x0b,0x0e,0x0e,0x0c,0x0b,0x0e,0x0b,0x0e,0x0e,
0x0e,0x06,0x07,0x07,0x07,0x06,0x08,0x08,0x07,0x06,0x0c,0x09,0x06,0x07,0x07,0x06,
0x07,0x0d,0x06,0x06,0x06,0x07,0x08,0x08,0x09,0x08,0x0b,0x0d,0x0c,0x0d,0x0d,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,
0x0e,0x0e,0x0e,0x0d,0x0d,0x0d,0x0e,0x0d,0x0e,0x0d,0x0e,0x0d,0x0e,0x0e,0x0e,0x0e,
0x0e,0x04,0x03,0x04,0x04,0x04,0x05,0x05,0x05,0x05,0x05,0x06,0x06,0x05,0x06,0x07,
0x08,0x08,0x09,0x0a,0x09,0x0a,0x0c,0x0b,0x0c,0x0e,0x0e,0x0e,0x0c,0x0b,
};
const USHORT g_FastEncoderLiteralTreeCode[] = {
0x06bf,0x26bf,0x16bf,0x36bf,0x0ebf,0x2ebf,0x1ebf,0x3ebf,
0x01bf,0x063f,0x0009,0x21bf,0x11bf,0x31bf,0x09bf,0x29bf,
0x19bf,0x39bf,0x05bf,0x25bf,0x15bf,0x35bf,0x0dbf,0x2dbf,
0x1dbf,0x3dbf,0x03bf,0x23bf,0x13bf,0x33bf,0x00bf,0x0bbf,
0x0029,0x2bbf,0x011f,0x0e3f,0x1bbf,0x3bbf,0x10bf,0x031f,
0x005b,0x0077,0x02df,0x009f,0x0023,0x00db,0x0063,0x0177,
0x003b,0x00bb,0x007b,0x00f7,0x00fb,0x01f7,0x029f,0x000f,
0x0007,0x010f,0x008f,0x0087,0x018f,0x019f,0x0047,0x07bf,
0x27bf,0x00c7,0x004f,0x0027,0x014f,0x00a7,0x00cf,0x039f,
0x06df,0x0067,0x01df,0x17bf,0x01cf,0x005f,0x002f,0x025f,
0x012f,0x013f,0x00af,0x01af,0x006f,0x015f,0x093f,0x05df,
0x37bf,0x0fbf,0x053f,0x03df,0x2fbf,0x07df,0x1fbf,0x3fbf,
0x007f,0x0019,0x0013,0x0053,0x0033,0x0039,0x00e7,0x0017,
0x0073,0x0005,0x0d3f,0x016f,0x0025,0x000b,0x004b,0x0015,
0x002b,0x08bf,0x0035,0x000d,0x002d,0x006b,0x0097,0x0057,
0x00ef,0x00d7,0x003f,0x18bf,0x033f,0x04bf,0x14bf,0x207f,
0x107f,0x307f,0x087f,0x287f,0x187f,0x387f,0x047f,0x247f,
0x147f,0x347f,0x0c7f,0x2c7f,0x1c7f,0x3c7f,0x027f,0x227f,
0x127f,0x327f,0x0a7f,0x2a7f,0x1a7f,0x3a7f,0x067f,0x267f,
0x167f,0x367f,0x0e7f,0x2e7f,0x1e7f,0x3e7f,0x017f,0x217f,
0x117f,0x317f,0x097f,0x297f,0x197f,0x397f,0x057f,0x257f,
0x157f,0x357f,0x0d7f,0x2d7f,0x1d7f,0x3d7f,0x037f,0x237f,
0x137f,0x337f,0x0b7f,0x2b7f,0x1b7f,0x3b7f,0x077f,0x277f,
0x177f,0x377f,0x0f7f,0x2f7f,0x1f7f,0x3f7f,0x00ff,0x20ff,
0x10ff,0x30ff,0x08ff,0x28ff,0x18ff,0x38ff,0x04ff,0x24ff,
0x14ff,0x34ff,0x0cff,0x2cff,0x1cff,0x3cff,0x02ff,0x22ff,
0x12ff,0x32ff,0x0aff,0x2aff,0x1aff,0x3aff,0x06ff,0x26ff,
0x16ff,0x36ff,0x0eff,0x2eff,0x1eff,0x3eff,0x01ff,0x21ff,
0x11ff,0x31ff,0x09ff,0x29ff,0x19ff,0x39ff,0x05ff,0x25ff,
0x15ff,0x35ff,0x0dff,0x2dff,0x1dff,0x3dff,0x03ff,0x23ff,
0x13ff,0x33ff,0x0bff,0x0cbf,0x1cbf,0x02bf,0x2bff,0x12bf,
0x1bff,0x0abf,0x3bff,0x1abf,0x07ff,0x27ff,0x17ff,0x37ff,
0x0fff,0x0004,0x0000,0x000c,0x0002,0x000a,0x0006,0x0016,
0x000e,0x001e,0x0001,0x001d,0x003d,0x0011,0x0003,0x001b,
0x0037,0x00b7,0x01ef,0x035f,0x001f,0x00df,0x0b3f,0x043f,
0x073f,0x2fff,0x1fff,0x3fff,0x0f3f,0x023f,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderLiteralTreeLength[];
extern const USHORT g_FastEncoderLiteralTreeCode[];
#endif /* DECLARE_DATA */
#ifdef DECLARE_DATA
const BYTE g_FastEncoderDistanceTreeLength[] = {
0x06,0x0a,0x0b,0x0b,0x09,0x08,0x08,0x08,0x07,0x07,0x05,0x06,0x04,0x05,0x04,0x05,
0x04,0x05,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x04,0x05,0x05,0x05,0x00,0x00,
};
const USHORT g_FastEncoderDistanceTreeCode[] = {
0x000f,0x01ff,0x03ff,0x07ff,0x00ff,0x003f,0x00bf,0x007f,
0x001f,0x005f,0x000d,0x002f,0x0000,0x001d,0x0008,0x0003,
0x0004,0x0013,0x000c,0x0002,0x000a,0x0006,0x000e,0x0001,
0x0009,0x000b,0x0005,0x001b,0x0007,0x0017,0x0000,0x0001,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderDistanceTreeLength[];
extern const USHORT g_FastEncoderDistanceTreeCode[];
#endif /* DECLARE_DATA */



#ifdef DECLARE_DATA
const ULONG g_FastEncoderLiteralCodeInfo[] = {

0x0000d7ee,0x0004d7ee,0x0002d7ee,0x0006d7ee,0x0001d7ee,0x0005d7ee,0x0003d7ee,
0x0007d7ee,0x000037ee,0x0000c7ec,0x00000126,0x000437ee,0x000237ee,0x000637ee,
0x000137ee,0x000537ee,0x000337ee,0x000737ee,0x0000b7ee,0x0004b7ee,0x0002b7ee,
0x0006b7ee,0x0001b7ee,0x0005b7ee,0x0003b7ee,0x0007b7ee,0x000077ee,0x000477ee,
0x000277ee,0x000677ee,0x000017ed,0x000177ee,0x00000526,0x000577ee,0x000023ea,
0x0001c7ec,0x000377ee,0x000777ee,0x000217ed,0x000063ea,0x00000b68,0x00000ee9,
0x00005beb,0x000013ea,0x00000467,0x00001b68,0x00000c67,0x00002ee9,0x00000768,
0x00001768,0x00000f68,0x00001ee9,0x00001f68,0x00003ee9,0x000053ea,0x000001e9,
0x000000e8,0x000021e9,0x000011e9,0x000010e8,0x000031e9,0x000033ea,0x000008e8,
0x0000f7ee,0x0004f7ee,0x000018e8,0x000009e9,0x000004e8,0x000029e9,0x000014e8,
0x000019e9,0x000073ea,0x0000dbeb,0x00000ce8,0x00003beb,0x0002f7ee,0x000039e9,
0x00000bea,0x000005e9,0x00004bea,0x000025e9,0x000027ec,0x000015e9,0x000035e9,
0x00000de9,0x00002bea,0x000127ec,0x0000bbeb,0x0006f7ee,0x0001f7ee,0x0000a7ec,
0x00007beb,0x0005f7ee,0x0000fbeb,0x0003f7ee,0x0007f7ee,0x00000fee,0x00000326,
0x00000267,0x00000a67,0x00000667,0x00000726,0x00001ce8,0x000002e8,0x00000e67,
0x000000a6,0x0001a7ec,0x00002de9,0x000004a6,0x00000167,0x00000967,0x000002a6,
0x00000567,0x000117ed,0x000006a6,0x000001a6,0x000005a6,0x00000d67,0x000012e8,
0x00000ae8,0x00001de9,0x00001ae8,0x000007eb,0x000317ed,0x000067ec,0x000097ed,
0x000297ed,0x00040fee,0x00020fee,0x00060fee,0x00010fee,0x00050fee,0x00030fee,
0x00070fee,0x00008fee,0x00048fee,0x00028fee,0x00068fee,0x00018fee,0x00058fee,
0x00038fee,0x00078fee,0x00004fee,0x00044fee,0x00024fee,0x00064fee,0x00014fee,
0x00054fee,0x00034fee,0x00074fee,0x0000cfee,0x0004cfee,0x0002cfee,0x0006cfee,
0x0001cfee,0x0005cfee,0x0003cfee,0x0007cfee,0x00002fee,0x00042fee,0x00022fee,
0x00062fee,0x00012fee,0x00052fee,0x00032fee,0x00072fee,0x0000afee,0x0004afee,
0x0002afee,0x0006afee,0x0001afee,0x0005afee,0x0003afee,0x0007afee,0x00006fee,
0x00046fee,0x00026fee,0x00066fee,0x00016fee,0x00056fee,0x00036fee,0x00076fee,
0x0000efee,0x0004efee,0x0002efee,0x0006efee,0x0001efee,0x0005efee,0x0003efee,
0x0007efee,0x00001fee,0x00041fee,0x00021fee,0x00061fee,0x00011fee,0x00051fee,
0x00031fee,0x00071fee,0x00009fee,0x00049fee,0x00029fee,0x00069fee,0x00019fee,
0x00059fee,0x00039fee,0x00079fee,0x00005fee,0x00045fee,0x00025fee,0x00065fee,
0x00015fee,0x00055fee,0x00035fee,0x00075fee,0x0000dfee,0x0004dfee,0x0002dfee,
0x0006dfee,0x0001dfee,0x0005dfee,0x0003dfee,0x0007dfee,0x00003fee,0x00043fee,
0x00023fee,0x00063fee,0x00013fee,0x00053fee,0x00033fee,0x00073fee,0x0000bfee,
0x0004bfee,0x0002bfee,0x0006bfee,0x0001bfee,0x0005bfee,0x0003bfee,0x0007bfee,
0x00007fee,0x00047fee,0x00027fee,0x00067fee,0x00017fee,0x000197ed,0x000397ed,
0x000057ed,0x00057fee,0x000257ed,0x00037fee,0x000157ed,0x00077fee,0x000357ed,
0x0000ffee,0x0004ffee,0x0002ffee,0x0006ffee,0x0001ffee,0x00000084,0x00000003,
0x00000184,0x00000044,0x00000144,0x000000c5,0x000002c5,0x000001c5,0x000003c6,
0x000007c6,0x00000026,0x00000426,0x000003a7,0x00000ba7,0x000007a7,0x00000fa7,
0x00000227,0x00000627,0x00000a27,0x00000e27,0x00000068,0x00000868,0x00001068,
0x00001868,0x00000369,0x00001369,0x00002369,0x00003369,0x000006ea,0x000026ea,
0x000046ea,0x000066ea,0x000016eb,0x000036eb,0x000056eb,0x000076eb,0x000096eb,
0x0000b6eb,0x0000d6eb,0x0000f6eb,0x00003dec,0x00007dec,0x0000bdec,0x0000fdec,
0x00013dec,0x00017dec,0x0001bdec,0x0001fdec,0x00006bed,0x0000ebed,0x00016bed,
0x0001ebed,0x00026bed,0x0002ebed,0x00036bed,0x0003ebed,0x000003ec,0x000043ec,
0x000083ec,0x0000c3ec,0x000103ec,0x000143ec,0x000183ec,0x0001c3ec,0x00001bee,
0x00009bee,0x00011bee,0x00019bee,0x00021bee,0x00029bee,0x00031bee,0x00039bee,
0x00041bee,0x00049bee,0x00051bee,0x00059bee,0x00061bee,0x00069bee,0x00071bee,
0x00079bee,0x000167f0,0x000367f0,0x000567f0,0x000767f0,0x000967f0,0x000b67f0,
0x000d67f0,0x000f67f0,0x001167f0,0x001367f0,0x001567f0,0x001767f0,0x001967f0,
0x001b67f0,0x001d67f0,0x001f67f0,0x000087ef,0x000187ef,0x000287ef,0x000387ef,
0x000487ef,0x000587ef,0x000687ef,0x000787ef,0x000887ef,0x000987ef,0x000a87ef,
0x000b87ef,0x000c87ef,0x000d87ef,0x000e87ef,0x000f87ef,0x0000e7f0,0x0002e7f0,
0x0004e7f0,0x0006e7f0,0x0008e7f0,0x000ae7f0,0x000ce7f0,0x000ee7f0,0x0010e7f0,
0x0012e7f0,0x0014e7f0,0x0016e7f0,0x0018e7f0,0x001ae7f0,0x001ce7f0,0x001ee7f0,
0x0005fff3,0x000dfff3,0x0015fff3,0x001dfff3,0x0025fff3,0x002dfff3,0x0035fff3,
0x003dfff3,0x0045fff3,0x004dfff3,0x0055fff3,0x005dfff3,0x0065fff3,0x006dfff3,
0x0075fff3,0x007dfff3,0x0085fff3,0x008dfff3,0x0095fff3,0x009dfff3,0x00a5fff3,
0x00adfff3,0x00b5fff3,0x00bdfff3,0x00c5fff3,0x00cdfff3,0x00d5fff3,0x00ddfff3,
0x00e5fff3,0x00edfff3,0x00f5fff3,0x00fdfff3,0x0003fff3,0x000bfff3,0x0013fff3,
0x001bfff3,0x0023fff3,0x002bfff3,0x0033fff3,0x003bfff3,0x0043fff3,0x004bfff3,
0x0053fff3,0x005bfff3,0x0063fff3,0x006bfff3,0x0073fff3,0x007bfff3,0x0083fff3,
0x008bfff3,0x0093fff3,0x009bfff3,0x00a3fff3,0x00abfff3,0x00b3fff3,0x00bbfff3,
0x00c3fff3,0x00cbfff3,0x00d3fff3,0x00dbfff3,0x00e3fff3,0x00ebfff3,0x00f3fff3,
0x00fbfff3,0x0007fff3,0x000ffff3,0x0017fff3,0x001ffff3,0x0027fff3,0x002ffff3,
0x0037fff3,0x003ffff3,0x0047fff3,0x004ffff3,0x0057fff3,0x005ffff3,0x0067fff3,
0x006ffff3,0x0077fff3,0x007ffff3,0x0087fff3,0x008ffff3,0x0097fff3,0x009ffff3,
0x00a7fff3,0x00affff3,0x00b7fff3,0x00bffff3,0x00c7fff3,0x00cffff3,0x00d7fff3,
0x00dffff3,0x00e7fff3,0x00effff3,0x00f7fff3,0x00fffff3,0x0001e7f1,0x0003e7f1,
0x0005e7f1,0x0007e7f1,0x0009e7f1,0x000be7f1,0x000de7f1,0x000fe7f1,0x0011e7f1,
0x0013e7f1,0x0015e7f1,0x0017e7f1,0x0019e7f1,0x001be7f1,0x001de7f1,0x001fe7f1,
0x0021e7f1,0x0023e7f1,0x0025e7f1,0x0027e7f1,0x0029e7f1,0x002be7f1,0x002de7f1,
0x002fe7f1,0x0031e7f1,0x0033e7f1,0x0035e7f1,0x0037e7f1,0x0039e7f1,0x003be7f1,
0x003de7f1,0x000047eb,
};
#else /* !DECLARE_DATA */
extern const ULONG g_FastEncoderLiteralCodeInfo[];
#endif /* DECLARE_DATA */
#ifdef DECLARE_DATA
const ULONG g_FastEncoderDistanceCodeInfo[] = {

0x00000f06,0x0001ff0a,0x0003ff0b,0x0007ff0b,0x0000ff19,0x00003f18,0x0000bf28,
0x00007f28,0x00001f37,0x00005f37,0x00000d45,0x00002f46,0x00000054,0x00001d55,
0x00000864,0x00000365,0x00000474,0x00001375,0x00000c84,0x00000284,0x00000a94,
0x00000694,0x00000ea4,0x000001a4,0x000009b4,0x00000bb5,0x000005c4,0x00001bc5,
0x000007d5,0x000017d5,0x00000000,0x00000100,
};
#else /* !DECLARE_DATA */
extern const ULONG g_FastEncoderDistanceCodeInfo[];
#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\deftree.c ===
//
// deftree.c
//
// Tree creation for the compressor
//
#include "deflate.h"
#include <string.h>
#include <crtdbg.h>


//
// MAX_LITERAL_TREE elements is the largest number of elements that will ever be passed
// in to this routine
//
typedef struct 
{
    // Made left_right a single long array for performance reasons.  We always access them
    // one after the other, so there is no disadvantage.
    // left[] in lower 16 bits, right[] in upper 16 bits
//	short           left[2*MAX_LITERAL_TREE_ELEMENTS];
//	short           right[2*MAX_LITERAL_TREE_ELEMENTS];
    unsigned long   left_right[2*MAX_LITERAL_TREE_ELEMENTS];

	int             heap[MAX_LITERAL_TREE_ELEMENTS+1];

	int				num_elements;

	// Maximum allowable code length (7 for pre-tree, 15 for other trees)
	int				max_code_length;

	unsigned short *freq; // passed in as parameter
	unsigned short *code; // passed in as parameter
	
	short *			sortptr;
	int				depth;
	int				heapsize;
	int             len_cnt[17];
} t_tree_context;



static void countLen(t_tree_context *context, int i)  /* call with i = root */
{
	if (i < context->num_elements)
	{
		// check for max code length allowed
		context->len_cnt[(context->depth < context->max_code_length) ? context->depth : context->max_code_length]++;
	}
	else
	{
        unsigned long lr_value = context->left_right[i];

		context->depth++;
		countLen(context, lr_value & 65535); // formerly left[i]
		countLen(context, lr_value >> 16); // formerly right[i]
		context->depth--;
	}
}


static void makeLen(t_tree_context *context, int root, BYTE *len)
{
	int		k;
	int		cum;
	int		i;

	for (i = 0; i <= 16; i++)
		context->len_cnt[i] = 0;

	countLen(context, root);

	cum = 0;

	for (i = context->max_code_length; i > 0; i--)
		cum += (context->len_cnt[i] << (context->max_code_length - i));

	while (cum != (1 << context->max_code_length))
	{
		context->len_cnt[context->max_code_length]--;

		for (i = context->max_code_length-1; i > 0; i--)
		{
			if (context->len_cnt[i] != 0)
			{
				context->len_cnt[i]--;
				context->len_cnt[i+1] += 2;
				break;
			}
		}

		cum--;
	}

	for (i = 16; i > 0; i--)
	{
		k = context->len_cnt[i];

		while (--k >= 0)
			len[ *context->sortptr++ ] = (byte) i;
	}
}


/* priority queue; send i-th entry down heap */
static void downHeap(t_tree_context *context, int i)
{
	int j, k;

	k = context->heap[i];

	while ((j = (i<<1)) <= context->heapsize)
	{
		if (j < context->heapsize && 
			context->freq[context->heap[j]] > context->freq[context->heap[j + 1]])
	 		j++;

		if (context->freq[k] <= context->freq[context->heap[j]])
			break;

		context->heap[i] = context->heap[j];
		i = j;
	}

	context->heap[i] = k;
}


//
// Reverse the bits, len > 0
//
static unsigned int bitReverse(unsigned int code, int len)
{
	unsigned int new_code = 0;

	do
	{
		new_code |= (code & 1);
		new_code <<= 1;
		code >>= 1;

	} while (--len > 0);

	return new_code >> 1;
}


void makeCode(int num_elements, const int *len_cnt, const BYTE *len, USHORT *code)
{
	int start[18];
	int i;
	
	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = (start[i] + len_cnt[i]) << 1;

	for (i = 0; i < num_elements; i++)
	{
		unsigned int unreversed_code;
		
		unreversed_code = start[len[i]]++;
		code[i] = (USHORT) bitReverse(unreversed_code, len[i]);
	}
}


void makeTree(
	int					num_elements,
	int					max_code_length,
	unsigned short *	freq,
	unsigned short *	code,
	byte *				len
)
{
	t_tree_context	tree;
	int				k;
	int				avail;
	int				i;

    _ASSERT(num_elements <= MAX_LITERAL_TREE_ELEMENTS);

	// init tree context
	tree.depth	= 0;
	tree.freq	= freq;
	tree.code	= code;
	tree.num_elements = num_elements;
	tree.max_code_length = max_code_length;

	avail				= num_elements;
	tree.heapsize		= 0;
	tree.heap[1]		= 0;

	for (i = 0; i < tree.num_elements; i++)
	{
		len[i] = 0;

		if (tree.freq[i] != 0)
			tree.heap[++tree.heapsize] = i;
	}

	//
	// Less than 2 elements in the tree?
	//
	if (tree.heapsize < 2)
	{
		if (tree.heapsize == 0)
		{
			//
			// No elements in the tree?
			//
			// Then insert two fake elements and retry.
			//
			tree.freq[0] = 1;
			tree.freq[1] = 1;
		}	
		else
		{
			//
			// One element in the tree, so add a fake code
			//
			// If our only element is element #0 (heap[1] == 0), then
			// make element #1 have a frequency of 1.
			//
			// Else make element #0 have a frequency of 1.
			//
			if (tree.heap[1] == 0)
				tree.freq[1] = 1;
			else
				tree.freq[0] = 1;
		}

		//
		// Retry with these new frequencies
		//
		makeTree(num_elements, max_code_length, freq, code, len);
		return;
	}

	for (i = tree.heapsize >> 1; i >= 1; i--)
		downHeap(&tree, i);  /* make priority queue */

	tree.sortptr = tree.code;

	do
	{
		int i, j;

		/* while queue has at least two entries */
		i = tree.heap[1];  /* take out least-freq entry */

		if (i < tree.num_elements)
			*tree.sortptr++ = (short) i; 

		tree.heap[1] = tree.heap[tree.heapsize--];
		downHeap(&tree, 1);

		j = tree.heap[1];  /* next least-freq entry */

		if (j < tree.num_elements)
			*tree.sortptr++ = (short) j; 

		k = avail++;  /* generate new node */

		tree.freq[k] = tree.freq[i] + tree.freq[j];
		tree.heap[1] = k;
		downHeap(&tree, 1);  /* put into queue */

//		tree.left[k] = (short) i;
//		tree.right[k] = (short) j;
		tree.left_right[k] = (j << 16) | i;

	} while (tree.heapsize > 1);

	tree.sortptr = tree.code;

	makeLen(&tree, k, len);
	makeCode(num_elements, tree.len_cnt, len, code);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\gentable.c ===
//
// gentable.c
//
// Generates static Huffman tables to be included in the DLL
//
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//#define GENERATE_C_CODE_TABLES

#ifdef GENERATE_C_CODE_TABLES
//
// Generates outputting tables for the fast encoder.
// 
// The other encoders do things differently; they have separate arrays for
// code[], len[], and they then have to check extra_bits[] afterwards to see
// how many (if any) low order bits to output.
//
// The fast encoder, on the other hand, is lean and mean.
//
// For a set of literal codes and lengths, generate a set of DWORDs with 
// these properties:
//
// [ code ] [ code_length ] 
//  27 bits     5 bits       
//
// Where "len" is the # bits in the code, and "code" is the FULL code to output,
// including ALL necessary g_LengthExtraBits[].
//
// The bitwise outputter cannot handle codes more than 16 bits in length, so
// if this happens (quite rare) whoever is using this table must output
// the code in two instalments.  
//
void MakeFastEncoderLiteralTable(BYTE *len, USHORT *code)
{
    ULONG outcode[(NUM_CHARS+1+(MAX_MATCH-MIN_MATCH+1))];
    int elements_to_output;
    int i;
    int match_length;

    elements_to_output = (NUM_CHARS+1+(MAX_MATCH-MIN_MATCH+1));

    // literals and end of block code are output without much fanfare
    for (i = 0; i <= NUM_CHARS; i++)
    {
        outcode[i] = len[i] | (code[i] << 5);
    }

    // match lengths are more interesting
    for (match_length = 0; match_length <= (MAX_MATCH-MIN_MATCH); match_length++)
    {
        int length_slot = g_LengthLookup[match_length];
        int extra_bits = g_ExtraLengthBits[length_slot];
        ULONG orig_code;
        int orig_len;
        ULONG tbl_code;
        int tbl_len;

        orig_code = (ULONG) code[(NUM_CHARS+1)+length_slot];
        orig_len = len[(NUM_CHARS+1)+length_slot];

        if (extra_bits == 0)
        {
            // if no extra bits, it's quite simple
            tbl_code = orig_code;
            tbl_len = orig_len;
        }
        else
        {
            // get extra bits data
            int extra_bits_data = match_length & g_BitMask[extra_bits];

            // stick it in the code and increase the code length appropriately
            tbl_code = orig_code | (extra_bits_data << orig_len);
            tbl_len = orig_len + extra_bits;
        }

        _ASSERT(tbl_len <= 27);
        outcode[(NUM_CHARS+1)+match_length] = tbl_len | (tbl_code << 5);
    }

    printf("#ifdef DECLARE_DATA\n");

    printf("const ULONG g_FastEncoderLiteralCodeInfo[] = {\n");

    for (i = 0; i < elements_to_output; i++)
    {
        if ((i % 7) == 0)
            printf("\n");

        printf("0x%08x,", outcode[i]);
    }

    printf("\n};\n");

    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const ULONG g_FastEncoderLiteralCodeInfo[];\n");
    printf("#endif /* DECLARE_DATA */\n");

}


//
// The distance table is slightly different; obviously we cannot have an element
// for all 8192 possible distances.  Instead we merge the code[] and len[] arrays,
// and store extra_bits[] in there.
//
// [ code ]  [ # extra_bits ] [ len ]
//  24 bits      4 bits       4 bits
//
// The code part is always < 16 bits, since we aren't merging the actual extra 
// bits with it, unlike for the literals.
//
void MakeFastEncoderDistanceTable(BYTE *len, USHORT *code)
{
    ULONG outcode[MAX_DIST_TREE_ELEMENTS];
    int i;
    int pos_slot;

    for (pos_slot = 0; pos_slot < MAX_DIST_TREE_ELEMENTS; pos_slot++)
    {
        int extra_bits = g_ExtraDistanceBits[pos_slot];
        ULONG orig_code;
        int orig_len;

        orig_code = (ULONG) code[pos_slot];
        orig_len = len[pos_slot];

        outcode[pos_slot] = orig_len | (extra_bits << 4) | (orig_code << 8);
    }

    printf("#ifdef DECLARE_DATA\n");

    printf("const ULONG g_FastEncoderDistanceCodeInfo[] = {\n");

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
    {
        if ((i % 7) == 0)
            printf("\n");

        printf("0x%08x,", outcode[i]);
    }

    printf("\n};\n");

    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const ULONG g_FastEncoderDistanceCodeInfo[];\n");
    printf("#endif /* DECLARE_DATA */\n");

}


void GenerateTable(char *table_name, int elements, BYTE *len, USHORT *code)
{
    int i;

    printf("#ifdef DECLARE_DATA\n");
    printf("const BYTE %sLength[] = {", table_name);

    for (i = 0; i < elements; i++)
    {
        if ((i % 16) == 0)
            printf("\n");

        printf("0x%02x,", len[i]);
    }

    printf("\n};\n");

    printf("const USHORT %sCode[] = {", table_name);

    for (i = 0; i < elements; i++)
    {
        if ((i % 8) == 0)
            printf("\n");

        printf("0x%04x,", code[i]);
    }

    printf("\n};\n");
    printf("#else /* !DECLARE_DATA */\n");
    printf("extern const BYTE %sLength[];\n", table_name);
    printf("extern const USHORT %sCode[];\n", table_name);
    printf("#endif /* DECLARE_DATA */\n");

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\fstdebug.c ===
/*
 * fstdebug.c
 *
 * Debugging stubs for fast encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef FULL_DEBUG
void FastEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
	int i;
	const t_search_node *lookup = context->fast_encoder->lookup;
	const t_search_node *prev = context->fast_encoder->prev;
	const BYTE *window = context->fast_encoder->window;

	for (i = 0; i < FAST_ENCODER_HASH_TABLE_SIZE; i++)
	{
		t_search_node where = lookup[i];
		t_search_node next_where;

		while (where != 0 && bufpos - where < FAST_ENCODER_WINDOW_SIZE)
		{
			int hash = FAST_ENCODER_RECALCULATE_HASH(where);

			_ASSERT(hash == i);

			next_where = prev[where & FAST_ENCODER_WINDOW_MASK];

			if (bufpos - next_where >= FAST_ENCODER_WINDOW_SIZE)
				break;

			_ASSERT(next_where < where);

			where = next_where;
		} 
	}
}


void FastEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number)
{
	const t_search_node *lookup = context->fast_encoder->lookup;
	const t_search_node *prev = context->fast_encoder->prev;
	BYTE *window = context->fast_encoder->window;
	t_search_node where;
	t_search_node next_where;
	int print = 0;

top:
	where = lookup[chain_number];

	if (print)
		printf("Verify chain %d\n", chain_number);

	while (where != 0 && bufpos - where < FAST_ENCODER_WINDOW_SIZE)
	{
		int hash = FAST_ENCODER_RECALCULATE_HASH(where);
        BYTE *window = context->fast_encoder->window;

		if (print)
			printf("   loc %d: char = %3d %3d %3d\n", where, window[where], window[where+1], window[where+2]);

		if (hash != chain_number && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(hash == chain_number);

		next_where = prev[where & FAST_ENCODER_WINDOW_MASK];

		if (bufpos - next_where >= FAST_ENCODER_WINDOW_SIZE)
			break;

		if (next_where >= where && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(next_where < where);

		where = next_where;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\gzip.c ===
//
// gzip.c
//
// All of the gzip-related additions to deflate (both encoder and decoder) are in this file
//

#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "inflate.h"
#include "infmacro.h"
#include "defgzip.h"
#include "infgzip.h"
#include "crc32.h"


#define GZIP_FLG_FTEXT      1
#define GZIP_FLG_CRC        2
#define GZIP_FLG_FEXTRA     4
#define GZIP_FLG_FNAME      8
#define GZIP_FLG_FCOMMENT   16


typedef enum
{
    // GZIP header
    GZIP_HDR_STATE_READING_ID1,
    GZIP_HDR_STATE_READING_ID2,
    GZIP_HDR_STATE_READING_CM,
    GZIP_HDR_STATE_READING_FLG,
    GZIP_HDR_STATE_READING_MMTIME, // iterates 4 times
    GZIP_HDR_STATE_READING_XFL,
    GZIP_HDR_STATE_READING_OS,
    GZIP_HDR_STATE_READING_XLEN1,
    GZIP_HDR_STATE_READING_XLEN2,
    GZIP_HDR_STATE_READING_XLEN_DATA,
    GZIP_HDR_STATE_READING_FILENAME,
    GZIP_HDR_STATE_READING_COMMENT,
    GZIP_HDR_STATE_READING_CRC16_PART1,
    GZIP_HDR_STATE_READING_CRC16_PART2,
    GZIP_HDR_STATE_DONE, // done reading GZIP header

    // GZIP footer
    GZIP_FTR_STATE_READING_CRC, // iterates 4 times
    GZIP_FTR_STATE_READING_FILE_SIZE // iterates 4 times
} t_gzip_state;


void EncoderInitGzipVariables(t_encoder_context *context)
{
    context->gzip_crc32 = 0;
    context->gzip_input_stream_size = 0;
    context->gzip_fOutputGzipHeader = FALSE;
}


void DecoderInitGzipVariables(t_decoder_context *context)
{
    context->gzip_crc32 = 0;
    context->gzip_output_stream_size = 0;
}


void WriteGzipHeader(t_encoder_context *context, int compression_level)
{
    BYTE *output_curpos = context->output_curpos;

    // only need 11 bytes
    _ASSERT(context->output_curpos + 16 <  context->output_endpos);

#ifndef TESTING
    // the proper code path
    *output_curpos++ = 0x1F; // ID1
    *output_curpos++ = 0x8B; // ID2
    *output_curpos++ = 8; // CM = deflate
    *output_curpos++ = 0; // FLG, no text, no crc, no extra, no name, no comment

    *output_curpos++ = 0; // MTIME (Modification Time) - no time available
    *output_curpos++ = 0;
    *output_curpos++ = 0;
    *output_curpos++ = 0;

    // XFL
    // 2 = compressor used max compression, slowest algorithm
    // 4 = compressor used fastest algorithm
    if (compression_level == 10)
        *output_curpos++ = 2; 
    else
        *output_curpos++ = 4; 

    *output_curpos++ = 0; // OS: 0 = FAT filesystem (MS-DOS, OS/2, NT/Win32)
#else /* TESTING */
    // this code is for code path testing only
    // it uses all of the headers to ensure that the decoder can handle them correctly
    *output_curpos++ = 0x1F; // ID1
    *output_curpos++ = 0x8B; // ID2
    *output_curpos++ = 8; // CM = deflate
    *output_curpos++ = (GZIP_FLG_CRC|GZIP_FLG_FEXTRA|GZIP_FLG_FNAME|GZIP_FLG_FCOMMENT); // FLG

    *output_curpos++ = 0; // MTIME (Modification Time) - no time available
    *output_curpos++ = 0;
    *output_curpos++ = 0;
    *output_curpos++ = 0;

    *output_curpos++ = 2; // XFL
    *output_curpos++ = 0; // OS: 0 = FAT filesystem (MS-DOS, OS/2, NT/Win32)
    
    // FEXTRA
    *output_curpos++ = 3; // LSB
    *output_curpos++ = 0; // MSB
    output_curpos += 3; // 3 bytes of data

    // FNAME, null terminated filename
    output_curpos += strlen(strcpy(output_curpos, "my filename"))+1;

    // FCOMMENT, null terminated comment
    output_curpos += strlen(strcpy(output_curpos, "my comment"))+1;

    // CRC16
    *output_curpos++ = 0x12;
    *output_curpos++ = 0x34;
#endif

	context->output_curpos = output_curpos;
}


void WriteGzipFooter(t_encoder_context *context)
{
    BYTE *output_curpos = context->output_curpos;

    *output_curpos++ = (BYTE) (context->gzip_crc32 & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 8) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 16) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_crc32 >> 24) & 255);

    *output_curpos++ = (BYTE) (context->gzip_input_stream_size & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 8) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 16) & 255);
    *output_curpos++ = (BYTE) ((context->gzip_input_stream_size >> 24) & 255);

	context->output_curpos = output_curpos;
}


BOOL ReadGzipFooter(t_decoder_context *context)
{
	if (context->state == STATE_START_READING_GZIP_FOOTER)
    {
        context->state = STATE_READING_GZIP_FOOTER;
        context->gzip_footer_substate = GZIP_FTR_STATE_READING_CRC;
        context->gzip_footer_loop_counter = 0;
    }

    _ASSERT(context->state == STATE_READING_GZIP_FOOTER);

	if (INPUT_EOF())
		return TRUE;

    if (context->gzip_footer_substate == GZIP_FTR_STATE_READING_CRC)
    {
        if (context->gzip_footer_loop_counter == 0)
            context->gzip_footer_crc32 = 0;

        while (context->gzip_footer_loop_counter < 4)
        {
            context->gzip_footer_crc32 |= ((*context->input_curpos++) << (8*context->gzip_footer_loop_counter));
            context->gzip_footer_loop_counter++;

            if (INPUT_EOF())
			    break;
        }

        if (context->gzip_footer_loop_counter >= 4)
        {
            context->gzip_footer_substate = GZIP_FTR_STATE_READING_FILE_SIZE;
            context->gzip_footer_loop_counter = 0;
        }

        if (INPUT_EOF())
	        return TRUE;
    }

    if (context->gzip_footer_substate == GZIP_FTR_STATE_READING_FILE_SIZE)
    {
        if (context->gzip_footer_loop_counter == 0)
            context->gzip_footer_output_stream_size = 0;

        while (context->gzip_footer_loop_counter < 4)
        {
            context->gzip_footer_output_stream_size |= ((*context->input_curpos++) << (8*context->gzip_footer_loop_counter));
            context->gzip_footer_loop_counter++;

            if (INPUT_EOF())
                break;
        }

        if (context->gzip_footer_loop_counter >= 4)
            context->state = STATE_VERIFYING_GZIP_FOOTER;
    }

    return TRUE;
}


BOOL ReadGzipHeader(t_decoder_context *context)
{
	if (context->state != STATE_READING_GZIP_HEADER)
    {
        context->state = STATE_READING_GZIP_HEADER;
        context->gzip_header_substate = GZIP_HDR_STATE_READING_ID1;
    }

	if (INPUT_EOF())
		return TRUE;

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_ID1)
    {
        if (*context->input_curpos++ != 0x1F)
            return FALSE;

        context->gzip_header_substate = GZIP_HDR_STATE_READING_ID2;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_ID2)
    {
        if (*context->input_curpos++ != 0x8B)
            return FALSE;

        context->gzip_header_substate = GZIP_HDR_STATE_READING_CM;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_CM)
    {
        // compression mode must be 8 (deflate)
        if (*context->input_curpos++ != 8)
            return FALSE;

        context->gzip_header_substate = GZIP_HDR_STATE_READING_FLG;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_FLG)
    {
        context->gzip_header_flag = *context->input_curpos++;
        context->gzip_header_substate = GZIP_HDR_STATE_READING_MMTIME;
        context->gzip_header_loop_counter = 0; // 4 MMTIME bytes

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_MMTIME)
    {
        // MTIME
        while (context->gzip_header_loop_counter < 4)
        {
            context->input_curpos++;
            context->gzip_header_loop_counter++;

            if (INPUT_EOF())
			    return TRUE;
        }

        context->gzip_header_substate = GZIP_HDR_STATE_READING_XFL;
        context->gzip_header_loop_counter = 0;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XFL)
    {
        context->input_curpos++; // ignore XFL
        context->gzip_header_substate = GZIP_HDR_STATE_READING_OS;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_OS)
    {
        context->input_curpos++; // ignore OS
        context->gzip_header_substate = GZIP_HDR_STATE_READING_XLEN1;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XLEN1)
    {
        // skip over some states if there's no "extra" data
        if ((context->gzip_header_flag & GZIP_FLG_FEXTRA) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_READING_FILENAME;
            goto gzip_state_reading_fname;
        }

        context->gzip_header_xlen1_byte = *context->input_curpos++; 
        context->gzip_header_substate = GZIP_HDR_STATE_READING_XLEN2;

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XLEN2)
    {
        BYTE xlen2 = *context->input_curpos++; 
        context->gzip_header_xlen = context->gzip_header_xlen1_byte | (xlen2 << 8);
        context->gzip_header_substate = GZIP_HDR_STATE_READING_XLEN_DATA;
        context->gzip_header_loop_counter = 0; // 0 bytes of XLEN data read so far

		if (INPUT_EOF())
			return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_XLEN_DATA)
    {
        while (context->gzip_header_loop_counter < context->gzip_header_xlen)
        {
            context->input_curpos++;
            context->gzip_header_loop_counter++;

            if (INPUT_EOF())
                break;
        }

        if (context->gzip_header_loop_counter >= context->gzip_header_xlen)
            context->gzip_header_substate = GZIP_HDR_STATE_READING_FILENAME;

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_reading_fname:

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_FILENAME)
    {
        // skip over this state if there's no filename
        if ((context->gzip_header_flag & GZIP_FLG_FNAME) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_READING_COMMENT;
            goto gzip_state_reading_comment;
        }

        do
        {
            if (*context->input_curpos++ == 0)
            {
                // filename null terminator found
                context->gzip_header_substate = GZIP_HDR_STATE_READING_COMMENT;
                break;
            }
        } while (!INPUT_EOF());

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_reading_comment:

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_COMMENT)
    {
        // skip over this state if there's no filename
        if ((context->gzip_header_flag & GZIP_FLG_FCOMMENT) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_READING_CRC16_PART1;
            goto gzip_state_reading_crc16;
        }

        do
        {
            if (*context->input_curpos++ == 0)
            {
                // filename null terminator found
                context->gzip_header_substate = GZIP_HDR_STATE_READING_CRC16_PART1;
                break;
            }
        } while (!INPUT_EOF());

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_reading_crc16:

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_CRC16_PART1)
    {
        // skip over these states if there's no crc16
        if ((context->gzip_header_flag & GZIP_FLG_CRC) == 0)
        {
            context->gzip_header_substate = GZIP_HDR_STATE_DONE;
            goto gzip_state_done;
        }

        context->input_curpos++; // ignore crc
        context->gzip_header_substate = GZIP_HDR_STATE_READING_CRC16_PART2;

        if (INPUT_EOF())
            return TRUE;
    }

    if (context->gzip_header_substate == GZIP_HDR_STATE_READING_CRC16_PART2)
    {
        context->input_curpos++; // ignore crc
        context->gzip_header_substate = GZIP_HDR_STATE_DONE;

        if (INPUT_EOF())
            return TRUE;
    }

gzip_state_done:

    if (context->gzip_header_substate == GZIP_HDR_STATE_DONE)
        context->state = STATE_READING_BFINAL_NEED_TO_INIT_BITBUF;

    return TRUE;
}


#define DO1(buf) crc = g_CrcTable[((ULONG)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

ULONG GzipCRC32(ULONG crc, const BYTE *buf, ULONG len)
{
    crc = crc ^ 0xffffffffUL;

    while (len >= 8)
    {
        DO8(buf);
        len -= 8;
    }

    if (len)
    {
        do
        {
          DO1(buf);
        } while (--len);
    }

    return crc ^ 0xffffffffUL;
}


//
// Works just like memcpy() except that we update context->crc32 and context->input_stream_size
// at the same time.
//
// BUGBUG Could possibly improve the perf by copying 4 or 8 bytes at a time as above
//
void GzipCRCmemcpy(t_encoder_context *context, BYTE *dest, const BYTE *src, ULONG count)
{
    ULONG crc = context->gzip_crc32 ^ 0xffffffffUL;

    context->gzip_input_stream_size += count;

    while (count-- > 0)
    {
        *dest++ = *src;
        DO1(src); // increments src
    }

    context->gzip_crc32 = crc ^ 0xffffffffUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\fastenc.h ===
/*
 * fastenc.h
 *
 * Defines for the fast encoder
 */

//
// Size of hash table for std encoder
//
#define FAST_ENCODER_HASH_TABLE_SIZE			2048
#define FAST_ENCODER_HASH_MASK					(FAST_ENCODER_HASH_TABLE_SIZE-1)
#define FAST_ENCODER_HASH_SHIFT					4

#define FAST_ENCODER_RECALCULATE_HASH(loc) \
	(((window[loc] << (2*FAST_ENCODER_HASH_SHIFT)) ^ \
	(window[loc+1] << FAST_ENCODER_HASH_SHIFT) ^ \
	(window[loc+2])) & FAST_ENCODER_HASH_MASK)


// 
// Be very careful about increasing the window size; the code tables will have to
// be updated, since they assume that extra_distance_bits is never larger than a
// certain size.
//
#define FAST_ENCODER_WINDOW_SIZE            8192
#define FAST_ENCODER_WINDOW_MASK            (FAST_ENCODER_WINDOW_SIZE - 1)


//
// Don't take a match 3 further away than this
//
#define FAST_ENCODER_MATCH3_DIST_THRESHOLD 16384


typedef struct fast_encoder
{
	// history window
	BYTE 					window[2*FAST_ENCODER_WINDOW_SIZE + MAX_MATCH + 4];

	// next most recent occurance of chars with same hash value
    t_search_node			prev[FAST_ENCODER_WINDOW_SIZE + MAX_MATCH];

	// hash table to find most recent occurance of chars with same hash value
	t_search_node			lookup[FAST_ENCODER_HASH_TABLE_SIZE];

    // have we output our block header (the whole data file will be one big dynamic block)?
    BOOL                    fOutputBlockHeader;

} t_fast_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infdata.h ===
//
// infdata.h
//
#ifdef DECLARE_DATA
SHORT           g_StaticDistanceTreeTable[STATIC_BLOCK_DISTANCE_TABLE_SIZE];
SHORT           g_StaticLiteralTreeTable[STATIC_BLOCK_LITERAL_TABLE_SIZE];
#else
extern SHORT    g_StaticDistanceTreeTable[STATIC_BLOCK_DISTANCE_TABLE_SIZE];
extern SHORT    g_StaticLiteralTreeTable[STATIC_BLOCK_LITERAL_TABLE_SIZE];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\fstenc.c ===
/*
 * fstenc.c
 *
 * Fast encoder
 *
 * This is a one pass encoder which uses predefined trees.  However, since these are not the same
 * trees defined for a fixed block (we use better trees than that), we output a dynamic block header.
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"
#include "fasttbl.h"


//
// For debugging purposes:
//
// Verifies that all of the hash pointers in the hash table are correct, and that everything
// in the same hash chain has the same hash value
//
#ifdef FULL_DEBUG
#define VERIFY_HASHES(bufpos) FastEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif


//
// Update hash variable "h" with character c
//
#define UPDATE_HASH(h,c) \
	h = ((h) << FAST_ENCODER_HASH_SHIFT) ^ (c);


//
// Insert a string into the hash chain at location bufpos
//
#define INSERT_STRING(search,bufpos) \
{ \
	UPDATE_HASH(hash, window[bufpos+2]); \
\
	_ASSERT((unsigned int) FAST_ENCODER_RECALCULATE_HASH(bufpos) == (unsigned int) (hash & FAST_ENCODER_HASH_MASK)); \
\
    search = lookup[hash & FAST_ENCODER_HASH_MASK]; \
	lookup[hash & FAST_ENCODER_HASH_MASK] = (t_search_node) (bufpos); \
	prev[bufpos & FAST_ENCODER_WINDOW_MASK] = (t_search_node) (search); \
}


//
// Output bits function which uses local variables for the bit buffer
//
#define LOCAL_OUTPUT_BITS(n, x) \
{ \
	bitbuf |= ((x) << bitcount); \
	bitcount += (n); \
	if (bitcount >= 16) \
    { \
		*output_curpos++ = (BYTE) bitbuf; \
		*output_curpos++ = (BYTE) (bitbuf >> 8); \
		bitcount -= 16; \
		bitbuf >>= 16; \
	} \
}


//
// Output unmatched symbol c
//
#define OUTPUT_CHAR(c) \
    LOCAL_OUTPUT_BITS(g_FastEncoderLiteralCodeInfo[c] & 31, g_FastEncoderLiteralCodeInfo[c] >> 5);


//
// Output a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
// Optimisation: unlike the other encoders, here we have an array of codes for each match
// length (not just each match length slot), complete with all the extra bits filled in, in
// a single array element.  
//
// There are many advantages to doing this:
//
// 1. A single array lookup on g_FastEncoderLiteralCodeInfo, instead of separate array lookups
//    on g_LengthLookup (to get the length slot), g_FastEncoderLiteralTreeLength, 
//    g_FastEncoderLiteralTreeCode, g_ExtraLengthBits, and g_BitMask
//
// 2. The array is an array of ULONGs, so no access penalty, unlike for accessing those USHORT
//    code arrays in the other encoders (although they could be made into ULONGs with some
//    modifications to the source).
//
// Note, if we could guarantee that code_len <= 16 always, then we could skip an if statement here.
//
// A completely different optimisation is used for the distance codes since, obviously, a table for 
// all 8192 distances combining their extra bits is not feasible.  The distance codeinfo table is 
// made up of code[], len[] and # extra_bits for this code.
//
// The advantages are similar to the above; a ULONG array instead of a USHORT and BYTE array, better
// cache locality, fewer memory operations.
//
#define OUTPUT_MATCH(match_len, match_pos) \
{ \
    int extra_bits; \
    int code_len; \
    ULONG code_info; \
\
	_ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
\
    code_info = g_FastEncoderLiteralCodeInfo[(NUM_CHARS+1-MIN_MATCH)+match_len]; \
    code_len = code_info & 31; \
    _ASSERT(code_len != 0); \
    if (code_len <= 16) \
    { \
        LOCAL_OUTPUT_BITS(code_len, code_info >> 5); \
    } \
    else \
    { \
        LOCAL_OUTPUT_BITS(16, (code_info >> 5) & 65535); \
        LOCAL_OUTPUT_BITS(code_len-16, code_info >> (5+16)); \
    } \
    code_info = g_FastEncoderDistanceCodeInfo[POS_SLOT(match_pos)]; \
    LOCAL_OUTPUT_BITS(code_info & 15, code_info >> 8); \
    extra_bits = (code_info >> 4) & 15; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_pos) & g_BitMask[extra_bits]); \
}


//
// This commented out code is the old way of doing things, which is what the other encoders use
//
#if 0
#define OUTPUT_MATCH(match_len, match_pos) \
{ \
	int pos_slot = POS_SLOT(match_pos); \
	int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
    int extra_bits; \
\
	_ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
    _ASSERT(g_FastEncoderLiteralTreeLength[(NUM_CHARS+1)+len_slot] != 0); \
    _ASSERT(g_FastEncoderDistanceTreeLength[pos_slot] != 0); \
\
    LOCAL_OUTPUT_BITS(g_FastEncoderLiteralTreeLength[(NUM_CHARS+1)+len_slot], g_FastEncoderLiteralTreeCode[(NUM_CHARS+1)+len_slot]); \
    extra_bits = g_ExtraLengthBits[len_slot]; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_len-MIN_MATCH) & g_BitMask[extra_bits]); \
\
    LOCAL_OUTPUT_BITS(g_FastEncoderDistanceTreeLength[pos_slot], g_FastEncoderDistanceTreeCode[pos_slot]); \
    extra_bits = g_ExtraDistanceBits[pos_slot]; \
    if (extra_bits != 0) LOCAL_OUTPUT_BITS(extra_bits, (match_pos) & g_BitMask[extra_bits]); \
}
#endif


//
// Local function prototypes
//
static void FastEncoderMoveWindows(t_encoder_context *context);

static int FastEncoderFindMatch(
    const BYTE *    window,
    const USHORT *  prev,
    long            bufpos, 
    long            search, 
    t_match_pos *   match_pos, 
    int             cutoff,
    int             nice_length
);


//
// Output the block type and tree structure for our hard-coded trees.
//
// Functionally equivalent to:
//
// outputBits(context, 1, 1); // "final" block flag
// outputBits(context, 2, BLOCKTYPE_DYNAMIC);
// outputTreeStructure(context, g_FastEncoderLiteralTreeLength, g_FastEncoderDistanceTreeLength);
//
// However, all of the above has smartly been cached in global data, so we just memcpy().
//
void FastEncoderOutputPreamble(t_encoder_context *context)
{
#if 0
    // slow way:
    outputBits(context, 1+2, 1 | (BLOCKTYPE_DYNAMIC << 1));
    outputTreeStructure(context, g_FastEncoderLiteralTreeLength, g_FastEncoderDistanceTreeLength);
#endif

    // make sure tree has been init
    _ASSERT(g_FastEncoderTreeLength > 0);

    // make sure we have enough space to output tree
    _ASSERT(context->output_curpos + g_FastEncoderTreeLength < context->output_endpos);

    // fast way:
    memcpy(context->output_curpos, g_FastEncoderTreeStructureData, g_FastEncoderTreeLength);
    context->output_curpos += g_FastEncoderTreeLength;

    // need to get final states of bitbuf and bitcount after outputting all that stuff
    context->bitbuf = g_FastEncoderPostTreeBitbuf;
    context->bitcount = g_FastEncoderPostTreeBitcount;
}


//
// Fast encoder deflate function
//
void FastEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth, // # hash links to traverse
	int					lazy_match_threshold, // don't search @ X+1 if match length @ X is > lazy
    int                 good_length, // divide traversal depth by 4 if match length > good
    int                 nice_length // in match finder, if we find >= nice_length match, quit immediately
)
{
	long			bufpos;
	unsigned int	hash;
    unsigned long   bitbuf;
    int             bitcount;
    BYTE *          output_curpos;
    t_fast_encoder *encoder = context->fast_encoder;
	byte *			window = encoder->window; // make local copies of context variables
	t_search_node *	prev = encoder->prev;
	t_search_node *	lookup = encoder->lookup;

    //
    // If this is the first time in here (since last reset) then we need to output our dynamic
    // block header
    //
    if (encoder->fOutputBlockHeader == FALSE)
    {
        encoder->fOutputBlockHeader = TRUE;

        //
        // Watch out!  Calls to outputBits() and outputTreeStructure() use the bit buffer 
        // variables stored in the context, not our local cached variables.
        //
        FastEncoderOutputPreamble(context);
    }

    //
    // Copy bitbuf vars into local variables since we're now using OUTPUT_BITS macro.
    // Do not call anything that uses the context structure's bit buffer variables!
    //
    output_curpos   = context->output_curpos;
    bitbuf          = context->bitbuf;
    bitcount        = context->bitcount;

    // copy bufpos into local variable
    bufpos = context->bufpos;

	VERIFY_HASHES(bufpos); // debug mode: verify that the hash table is correct

    // initialise the value of the hash
    // no problem if locations bufpos, bufpos+1 are invalid (not enough data), since we will 
    // never insert using that hash value
	hash = 0;
	UPDATE_HASH(hash, window[bufpos]);
	UPDATE_HASH(hash, window[bufpos+1]);

    // while we haven't come to the end of the input, and we still aren't close to the end
    // of the output
	while (bufpos < context->bufpos_end && output_curpos < context->output_near_end_threshold)
	{
		int				match_len;
		t_match_pos		match_pos;
		t_match_pos		search;

    	VERIFY_HASHES(bufpos); // debugger: verify that hash table is correct

		if (context->bufpos_end - bufpos <= 3)
		{
			// The hash value becomes corrupt when we get within 3 characters of the end of the
            // input buffer, since the hash value is based on 3 characters.  We just stop
            // inserting into the hash table at this point, and allow no matches.
			match_len = 0;
		}
		else
		{
            // insert string into hash table and return most recent location of same hash value
			INSERT_STRING(search,bufpos);

            // did we find a recent location of this hash value?
			if (search != 0)
			{
    			// yes, now find a match at what we'll call position X
				match_len = FastEncoderFindMatch(window, prev, bufpos, search, &match_pos, search_depth, nice_length);

				// truncate match if we're too close to the end of the input buffer
				if (bufpos + match_len > context->bufpos_end)
					match_len = context->bufpos_end - bufpos;
			}
			else
			{
                // no most recent location found
				match_len = 0;
			}
		}

		if (match_len < MIN_MATCH)
		{
            // didn't find a match, so output unmatched char
			OUTPUT_CHAR(window[bufpos]);
    		bufpos++;
		}
		else
		{
	    	// bufpos now points to X+1
    		bufpos++;

			// is this match so good (long) that we should take it automatically without
			// checking X+1 ?
			if (match_len <= lazy_match_threshold)
			{
				int				next_match_len;
				t_match_pos		next_match_pos;

				// sets search
				INSERT_STRING(search,bufpos);

				// no, so check for a better match at X+1
				if (search != 0)
				{
					next_match_len = FastEncoderFindMatch(
						window,
                        prev,
						bufpos, 
						search,
						&next_match_pos,
						match_len < good_length ? search_depth : (search_depth >> 2),
                        nice_length
					);
				
					// truncate match if we're too close to the end of the buffer
					// note: next_match_len could now be < MIN_MATCH
					if (bufpos + next_match_len > context->bufpos_end)
						next_match_len = context->bufpos_end - bufpos;
				}
				else
				{
					next_match_len = 0;
				}

				// right now X and X+1 are both inserted into the search tree
				if (next_match_len > match_len)
				{
					// since next_match_len > match_len, it can't be < MIN_MATCH here

					// match at X+1 is better, so output unmatched char at X
					OUTPUT_CHAR(window[bufpos-1]);

					// now output match at location X+1
					OUTPUT_MATCH(next_match_len, next_match_pos);

					// insert remainder of second match into search tree
					// 
					// example: (*=inserted already)
					//
					// X      X+1               X+2      X+3     X+4
					// *      *
					//        nextmatchlen=3
					//        bufpos
					//
					// If next_match_len == 3, we want to perform 2
					// insertions (at X+2 and X+3).  However, first we must 
					// inc bufpos.
					//
					bufpos++; // now points to X+2
					match_len = next_match_len;
					goto insert;
				}
				else
				{
					// match at X is better, so take it
					OUTPUT_MATCH(match_len, match_pos);

					//
					// Insert remainder of first match into search tree, minus the first
					// two locations, which were inserted by the FindMatch() calls.
					// 
					// For example, if match_len == 3, then we've inserted at X and X+1
					// already (and bufpos is now pointing at X+1), and now we need to insert 
					// only at X+2.
					//
					match_len--;
					bufpos++; // now bufpos points to X+2
					goto insert;
				}
			}
			else /* match_length >= good_match */
			{
				// in assertion: bufpos points to X+1, location X inserted already
					
				// first match is so good that we're not even going to check at X+1
				OUTPUT_MATCH(match_len, match_pos);

				// insert remainder of match at X into search tree
insert:
				if (context->bufpos_end - bufpos <= match_len)
				{
					bufpos += (match_len-1);
				}
				else
				{
   					while (--match_len > 0)
    				{
	    				t_match_pos ignore;

		    			INSERT_STRING(ignore,bufpos);
			    		bufpos++;
				    }
				}
			}
		}
	} /* end ... while (bufpos < bufpos_end) */

    // store local variables back in context
	context->bufpos = bufpos;
    context->bitbuf = bitbuf;
    context->bitcount = bitcount;
    context->output_curpos = output_curpos;

	VERIFY_HASHES(bufpos); // debugger: verify that hash table is correct

    if (bufpos == context->bufpos_end)
        context->state = STATE_NORMAL;
    else
        context->state = STATE_OUTPUTTING_BLOCK;

    // slide the window if bufpos has reached 2*window size
    if (context->bufpos == 2*FAST_ENCODER_WINDOW_SIZE)
        FastEncoderMoveWindows(context);
}


static void FastEncoderMoveWindows(t_encoder_context *context)
{
	t_search_node *lookup = context->fast_encoder->lookup;
	t_search_node *prev = context->fast_encoder->prev;
	BYTE *window = context->fast_encoder->window;
	int i;

    _ASSERT(context->bufpos == 2*FAST_ENCODER_WINDOW_SIZE);

    // verify that the hash table is correct
	VERIFY_HASHES(2*FAST_ENCODER_WINDOW_SIZE);

	memcpy(&window[0], &window[context->bufpos - FAST_ENCODER_WINDOW_SIZE], FAST_ENCODER_WINDOW_SIZE);

    // move all the hash pointers back
    // BUGBUG We are incurring a performance penalty since lookup[] is a USHORT array.  Would be
    // nice to subtract from two locations at a time.
	for (i = 0; i < FAST_ENCODER_HASH_TABLE_SIZE; i++)
	{
		long val = ((long) lookup[i]) - FAST_ENCODER_WINDOW_SIZE;

		if (val <= 0) // too far away now? then set to zero
			lookup[i] = (t_search_node) 0;
		else
			lookup[i] = (t_search_node) val;
	}

    // prev[]'s are absolute pointers, not relative pointers, so we have to move them back too
    // making prev[]'s into relative pointers poses problems of its own
	for (i = 0; i < FAST_ENCODER_WINDOW_SIZE; i++)
	{
		long val = ((long) prev[i]) - FAST_ENCODER_WINDOW_SIZE;

		if (val <= 0)
			prev[i] = (t_search_node) 0;
		else
			prev[i] = (t_search_node) val;
	}

#ifdef FULL_DEBUG
    // For debugging, wipe the window clean, so that if there is a bug in our hashing,
    // the hash pointers will now point to locations which are not valid for the hash value
    // (and will be caught by our ASSERTs).
	memset(&window[FAST_ENCODER_WINDOW_SIZE], 0, FAST_ENCODER_WINDOW_SIZE);
#endif

	VERIFY_HASHES(2*FAST_ENCODER_WINDOW_SIZE); // debug: verify hash table is correct

	context->bufpos = FAST_ENCODER_WINDOW_SIZE;
	context->bufpos_end = context->bufpos;
}


//
// Find match
//
// Returns match length found.  A match length < MIN_MATCH means no match was found.
//
static int FastEncoderFindMatch(
    const BYTE *    window, // window array
    const USHORT *  prev,   // prev ptr array
    long            bufpos, // current buffer position
    long            search, // where to start searching
    t_match_pos *   match_pos, // return match position here
    int             cutoff, // # links to traverse
    int             nice_length // stop immediately if we find a match >= nice_length
)
{
    // make local copies of context variables
	long			earliest;
	int				best_match = 0; // best match length found so far
	t_match_pos		l_match_pos = 0; // absolute match position of best match found
    BYTE            want_char;

	_ASSERT(bufpos >= 0 && bufpos < 2*FAST_ENCODER_WINDOW_SIZE);
	_ASSERT(search < bufpos);
	_ASSERT(FAST_ENCODER_RECALCULATE_HASH(search) == FAST_ENCODER_RECALCULATE_HASH(bufpos));

    // the earliest we can look
	earliest = bufpos - FAST_ENCODER_WINDOW_SIZE;
    _ASSERT(earliest >= 0);

    // store window[bufpos + best_match]
    want_char = window[bufpos];

	while (search > earliest)
	{
        // make sure all our hash links are valid
		_ASSERT(FAST_ENCODER_RECALCULATE_HASH(search) == FAST_ENCODER_RECALCULATE_HASH(bufpos));

        // Start by checking the character that would allow us to increase the match
        // length by one.  This improves performance quite a bit.
		if (window[search + best_match] == want_char)
		{
			int j;

            // Now make sure that all the other characters are correct
			for (j = 0; j < MAX_MATCH; j++)
			{
				if (window[bufpos+j] != window[search+j])
					break;
			}
	
			if (j > best_match)
			{
				best_match	= j;
				l_match_pos	= search; // absolute position

				if (j > nice_length)
					break;

                want_char = window[bufpos+j];
			}
		}

		if (--cutoff == 0)
			break;

        // make sure we're always going backwards
        _ASSERT(prev[search & FAST_ENCODER_WINDOW_MASK] < search);

		search = (long) prev[search & FAST_ENCODER_WINDOW_MASK];
	}

    // doesn't necessarily mean we found a match; best_match could be > 0 and < MIN_MATCH
	*match_pos = bufpos - l_match_pos - 1; // convert absolute to relative position

    // don't allow match length 3's which are too far away to be worthwhile
	if (best_match == 3 && *match_pos >= FAST_ENCODER_MATCH3_DIST_THRESHOLD)
		return 0;

	_ASSERT(best_match < MIN_MATCH || *match_pos < FAST_ENCODER_WINDOW_SIZE);

	return best_match;
}


void FastEncoderReset(t_encoder_context *context)
{
	_ASSERT(context->fast_encoder != NULL);

    // zero hash table
	memset(context->fast_encoder->lookup, 0, sizeof(context->fast_encoder->lookup));

    context->window_size = FAST_ENCODER_WINDOW_SIZE;
	context->bufpos = FAST_ENCODER_WINDOW_SIZE;
    context->bufpos_end = context->bufpos;
    context->fast_encoder->fOutputBlockHeader = FALSE;
}


BOOL FastEncoderInit(t_encoder_context *context)
{
	context->fast_encoder = (t_fast_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_fast_encoder));

    if (context->fast_encoder == NULL)
        return FALSE;

	FastEncoderReset(context);
	return TRUE;
}


//
// Pregenerate the structure of the dynamic tree header which is output for
// the fast encoder.  Also record the final states of bitcount and bitbuf
// after outputting.
//
void FastEncoderGenerateDynamicTreeEncoding(void)
{
    t_encoder_context context;

    // Create a fake context with output pointers into our global data
    memset(&context, 0, sizeof(context));
    context.output_curpos = g_FastEncoderTreeStructureData;
    context.output_endpos = g_FastEncoderTreeStructureData + sizeof(g_FastEncoderTreeStructureData);
    context.output_near_end_threshold = context.output_endpos - 16;
    InitBitBuffer(&context);

    outputBits(&context, 1, 1); // "final" block flag
    outputBits(&context, 2, BLOCKTYPE_DYNAMIC);
   
    outputTreeStructure(
        &context,
	    g_FastEncoderLiteralTreeLength, 
	    g_FastEncoderDistanceTreeLength
    );

    g_FastEncoderTreeLength = (int) (context.output_curpos - (BYTE *) g_FastEncoderTreeStructureData);
    g_FastEncoderPostTreeBitbuf = context.bitbuf;
    g_FastEncoderPostTreeBitcount = context.bitcount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infgzip.h ===
//
// infgzip.h
//
// Gzip additions to inflate
//

// decompressing
BOOL ReadGzipHeader(t_decoder_context *context);
BOOL ReadGzipFooter(t_decoder_context *context);
void DecoderInitGzipVariables(t_decoder_context *context);
ULONG GzipCRC32(ULONG crc, const BYTE *buf, ULONG len);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infinit.c ===
//
// infinit.c
//
// Inflate initialisation
//
#include <stdio.h>
#include <crtdbg.h>
#include "inflate.h"
#include "maketbl.h"


//
// Generate global tables for decoding static blocks
//
static VOID CreateStaticDecodingTables(VOID)
{
    SHORT StaticDistanceTreeLeft[MAX_DIST_TREE_ELEMENTS*2]; // temporary: not exported
    SHORT StaticDistanceTreeRight[MAX_DIST_TREE_ELEMENTS*2]; // temporary: not exported

    SHORT StaticLiteralTreeLeft[MAX_LITERAL_TREE_ELEMENTS*2]; // temporary: not exported
    SHORT StaticLiteralTreeRight[MAX_LITERAL_TREE_ELEMENTS*2]; // temporary: not exported
    
    SHORT TempStaticDistanceTreeTable[STATIC_BLOCK_DISTANCE_TABLE_SIZE];
    BYTE  TempStaticDistanceTreeLength[MAX_DIST_TREE_ELEMENTS];

    int i;

    _ASSERT(STATIC_BLOCK_LITERAL_TABLE_BITS == 9);
    _ASSERT(STATIC_BLOCK_DISTANCE_TABLE_BITS == 5);

    // The Table[] and Left/Right arrays are for the decoder only
    // We don't output Left/Right because they are not used; everything
    // fits in the lookup table, since max code length is 9, and tablebits
    // > 9.
    makeTable(
		MAX_LITERAL_TREE_ELEMENTS,
		STATIC_BLOCK_LITERAL_TABLE_BITS,
		g_StaticLiteralTreeLength,
		g_StaticLiteralTreeTable,
		StaticLiteralTreeLeft,
		StaticLiteralTreeRight);

    for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
        TempStaticDistanceTreeLength[i] = 5;

    makeTable(
		MAX_DIST_TREE_ELEMENTS,
		STATIC_BLOCK_DISTANCE_TABLE_BITS,
		TempStaticDistanceTreeLength,
		TempStaticDistanceTreeTable,
		StaticDistanceTreeLeft,
		StaticDistanceTreeRight);
    
    // Since all values are < 256, use a BYTE array
    for (i = 0; i < STATIC_BLOCK_DISTANCE_TABLE_SIZE; i++)
        g_StaticDistanceTreeTable[i] = TempStaticDistanceTreeTable[i];
}


VOID inflateInit(VOID)
{
    InitStaticBlock();
    CreateStaticDecodingTables();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infmacro.h ===
//
// infmacro.h
//

#define INPUT_EOF()	(context->input_curpos >= context->end_input_buffer)


// dump n bits from the bit buffer (n can be up to 16)
// in assertion: there must be at least n valid bits in the buffer
#define DUMPBITS(n) \
	bitbuf >>= n; \
	bitcount -= n; 


// return the next n bits in the bit buffer (n <= 16), then dump these bits
// in assertion: there must be at least n valid bits in the buffer
#define GETBITS(result, n) \
	bitcount -= n; \
	result = (bitbuf & g_BitMask[n]); \
	bitbuf >>= n; \


//
// Load bit buffer variables from context into local variables
//
#define LOAD_BITBUF_VARS() \
	bitbuf = context->bitbuf; \
	bitcount = context->bitcount; \
	input_ptr = context->input_curpos;


//
// Save bit buffer variables from local variables into context
//
#define SAVE_BITBUF_VARS() \
	context->bitbuf = bitbuf; \
	context->bitcount = bitcount; \
	context->input_curpos = input_ptr;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infdyna.c ===
//
// infdyna.c
//
// Decompress a dynamically compressed block
//
#include <stdio.h>
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"
#include "maketbl.h"


#define OUTPUT_EOF() (output_curpos >= context->end_output_buffer)

//
// This is the slow version, which worries about the input running out or the output
// running out.  The trick here is to not read any more bytes than we need to; theoretically
// the "end of block" code could be 1 bit, so we cannot always assume that it is ok to fill
// the bit buffer with 16 bits right before a table decode.
//
BOOL DecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;
    t_decoder_state old_state;
    BYTE            fCanTryFastEncoder = TRUE;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
top:
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(bitcount >= -16);

    old_state = context->state;
    context->state = STATE_DECODE_TOP; // reset state

	switch (old_state)
	{
		case STATE_DECODE_TOP:
			break;

		case STATE_HAVE_INITIAL_LENGTH:
			length = context->length;
			goto reenter_state_have_initial_length;

		case STATE_HAVE_FULL_LENGTH:
			length = context->length;
			goto reenter_state_have_full_length;

		case STATE_HAVE_DIST_CODE:
			length = context->length;
			dist_code = context->dist_code;
			goto reenter_state_have_dist_code;

		case STATE_INTERRUPTED_MATCH:
			length = context->length;
			offset = context->offset;
			goto reenter_state_interrupted_match;

        default:
            _ASSERT(0); // error, invalid state!
	}

	do
	{
        //
        // The first time we're at the top of this loop, check whether we can use the
        // fast encoder; we will do this if the input and output buffers are nowhere
        // near the end, which allows the fast encoder to be a little more relaxed
        // about checking for these conditions
        //
        // If we cannot enter the fast encoder when we first check, then we will not
        // be able to enter it again while we're in this function (the amount of
        // input/output available is not going to get any larger), so don't check
        // again.
        //
        if (fCanTryFastEncoder)
        {
    		if (context->output_curpos + MAX_MATCH < context->end_output_buffer &&
	    		context->input_curpos + 12 < context->end_input_buffer)
    		{
	    		SAVE_BITBUF_VARS();
		    	context->output_curpos = output_curpos;
    			context->bufpos = bufpos;

    			if (FastDecodeDynamicBlock(context, end_of_block_code_seen) == FALSE)
	    			return FALSE;

    			if (*end_of_block_code_seen)
	    			return TRUE;

    			goto top;
	    	}
            else
            {
                // don't check again
                fCanTryFastEncoder = FALSE;
            }
        }

		//
		// decode an element from the main tree
		//

		// we must have at least 1 bit available
		_ASSERT(bitcount >= -16);

		if (bitcount == -16)
		{
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
		}

retry_decode_literal:

		// assert that at least 1 bit is present
		_ASSERT(bitcount > -16);

		// decode an element from the literal tree
		length = context->literal_table[bitbuf & LITERAL_TABLE_MASK]; 
		
		while (length < 0) 
		{ 
			unsigned long mask = 1 << LITERAL_TABLE_BITS; 
			do 
			{ 
				length = -length; 
				if ((bitbuf & mask) == 0) 
					length = context->literal_left[length]; 
				else 
					length = context->literal_right[length]; 
				mask <<= 1; 
			} while (length < 0); 
		}

		//
		// If this code is longer than the # bits we had in the bit buffer (i.e.
		// we read only part of the code - but enough to know that it's too long),
		// read more bits and retry
		//
		if (context->literal_tree_code_length[length] > (bitcount+16))
		{
			// if we run out of bits, break
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
			goto retry_decode_literal;		
		}

		DUMPBITS(context->literal_tree_code_length[length]);
		_ASSERT(bitcount >= -16);

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

reenter_state_have_initial_length:

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					// make sure we have this many bits in the bit buffer
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_INITIAL_LENGTH;
							context->length = length;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
						
						// extra_length_bits will be no more than 5, so we need to read at
						// most one byte of input to satisfy this request
					}

					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);
					_ASSERT(bitcount >= -16);
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
reenter_state_have_full_length:

			// we must have at least 1 bit available
			if (bitcount == -16)
			{
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 
			}


retry_decode_distance:

			// assert that at least 1 bit is present
			_ASSERT(bitcount > -16);

			dist_code = context->distance_table[bitbuf & DISTANCE_TABLE_MASK]; 
			
			while (dist_code < 0) 
			{ 
				unsigned long mask = 1 << DISTANCE_TABLE_BITS; 
			
				do 
				{ 
					dist_code = -dist_code; 
				
					if ((bitbuf & mask) == 0) 
						dist_code = context->distance_left[dist_code]; 
					else 
						dist_code = context->distance_right[dist_code]; 
					
					mask <<= 1; 
				} while (dist_code < 0); 
			}

			//
			// If this code is longer than the # bits we had in the bit buffer (i.e.
			// we read only part of the code - but enough to know that it's too long),
			// read more bits and retry
			//
			if (context->distance_tree_code_length[dist_code] > (bitcount+16))
			{
				// if we run out of bits, break
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 

				_ASSERT(bitcount >= -16);
				goto retry_decode_distance;		
			}


			DUMPBITS(context->distance_tree_code_length[dist_code]);

			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);

reenter_state_have_dist_code:

			_ASSERT(bitcount >= -16);

			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				// make sure we have this many bits in the bit buffer
				if (extra_bits > bitcount + 16)
				{
					// if we run out of bits, break
					if (input_ptr >= end_input_buffer)
					{
						context->state = STATE_HAVE_DIST_CODE;
						context->length = length;
						context->dist_code = dist_code;
						break;
					}

					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;
						
					// extra_length_bits can be > 8, so check again
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_DIST_CODE;
							context->length = length;
							context->dist_code = dist_code;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}

				offset = g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]); 

				DUMPBITS(extra_bits);
				_ASSERT(bitcount >= -16);
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
reenter_state_interrupted_match:

			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;

				if (--length == 0)
					break;

			} while (output_curpos < context->end_output_buffer);

			if (length > 0)
			{
				context->state = STATE_INTERRUPTED_MATCH;
				context->length = length;
				context->offset = offset;
				break;
			}
		}

		// it's "<=" because we end when we received the end-of-block code,
		// not when we fill up the output, however, this will catch cases
		// of corrupted data where there is no end-of-output code
	} while (output_curpos < context->end_output_buffer);

	_ASSERT(bitcount >= -16);

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}


//
// This is the fast version, which assumes that, at the top of the loop:
//
// 1. There are at least 12 bytes of input available at the top of the loop (so that we don't
// have to check input EOF several times in the middle of the loop)
//
// and
//
// 2. There are at least MAX_MATCH bytes of output available (so that we don't have to check
// for output EOF while we're copying matches)
//
// The state must also be STATE_DECODE_TOP on entering and exiting this function
//
BOOL FastDecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(context->state == STATE_DECODE_TOP);
	_ASSERT(input_ptr + 12 < end_input_buffer);
	_ASSERT(output_curpos + MAX_MATCH < context->end_output_buffer);

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	do
	{
		//
		// decode an element from the main tree
		//

		// decode an element from the literal tree
		length = context->literal_table[bitbuf & LITERAL_TABLE_MASK]; 
		
		while (length < 0) 
		{ 
			unsigned long mask = 1 << LITERAL_TABLE_BITS; 
			do 
			{ 
				length = -length; 
				if ((bitbuf & mask) == 0) 
					length = context->literal_left[length]; 
				else 
					length = context->literal_right[length]; 
				mask <<= 1; 
			} while (length < 0); 
		}

		DUMPBITS(context->literal_tree_code_length[length]);

		if (bitcount <= 0)
		{
			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8;

			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;
			}
		}

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;

						if (bitcount <= 0)
						{
							bitbuf |= ((*input_ptr++) << (bitcount+16)); 
							bitcount += 8;
						}
					}
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
			dist_code = context->distance_table[bitbuf & DISTANCE_TABLE_MASK]; 
			
			while (dist_code < 0) 
			{ 
				unsigned long mask = 1 << DISTANCE_TABLE_BITS; 
			
				do 
				{ 
					dist_code = -dist_code; 
				
					if ((bitbuf & mask) == 0) 
						dist_code = context->distance_left[dist_code]; 
					else 
						dist_code = context->distance_right[dist_code]; 
					
					mask <<= 1; 
				} while (dist_code < 0); 
			}

			DUMPBITS(context->distance_tree_code_length[dist_code]);

			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;

				if (bitcount <= 0)
				{
					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;
				}
			}


			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);
			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				offset	= g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]);
                
				DUMPBITS(extra_bits);

				if (bitcount <= 0)
				{
					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;
			} while (--length != 0);
		}
	} while ((input_ptr + 12 < end_input_buffer) && (output_curpos + MAX_MATCH < context->end_output_buffer));

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infinput.c ===
//
// infinput.c
//
// Bitwise inputting for inflate (decompressor)
//
#include <stdio.h>
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"


void dumpBits(t_decoder_context *context, int n)
{
	context->bitbuf >>= n; 
	context->bitcount -= n; 
}


// retrieve n bits from the bit buffer, and dump them when done
// n can be up to 16
int getBits(t_decoder_context *context, int n)
{
	int result;

	context->bitcount -= n; 
	result = (context->bitbuf & g_BitMask[n]);
	context->bitbuf >>= n; 

	return result;
}


//
// Ensure that <num_bits> bits are in the bit buffer
//
// Returns FALSE if there are not and there was insufficient input to make this true
//
BOOL ensureBitsContext(t_decoder_context *context, int num_bits)
{
	if (context->bitcount + 16 < num_bits) 
	{ 
		if (INPUT_EOF())
			return FALSE;

		context->bitbuf |= ((*context->input_curpos++) << (context->bitcount+16)); 
		context->bitcount += 8; 
		
		if (context->bitcount + 16 < num_bits)
		{
			if (INPUT_EOF())
				return FALSE;

			context->bitbuf |= ((*context->input_curpos++) << (context->bitcount+16)); 
			context->bitcount += 8; 
		} 
	} 

	return TRUE;
}


// initialise the bit buffer
BOOL initBitBuffer(t_decoder_context *context) 
{
	if (context->input_curpos < context->end_input_buffer)
	{
		context->bitbuf = *context->input_curpos++;
		context->bitcount = -8;
		context->state = STATE_READING_BFINAL;
		return TRUE;
	}
	else
	{
		context->bitcount = -16;
		context->bitbuf = 0;
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\inflate.h ===
#include "common.h"
#include "api_int.h"


// decoding tables for dynamic blocks
#define LITERAL_TABLE_BITS		9
#define LITERAL_TABLE_MASK		((1 << LITERAL_TABLE_BITS)-1)

#define DISTANCE_TABLE_BITS		7
#define DISTANCE_TABLE_MASK		((1 << DISTANCE_TABLE_BITS)-1)

#define PRETREE_TABLE_BITS		7
#define PRETREE_TABLE_MASK		((1 << PRETREE_TABLE_BITS)-1)


// decoding tables for static blocks
#define STATIC_BLOCK_LITERAL_TABLE_BITS		9
#define STATIC_BLOCK_LITERAL_TABLE_MASK		((1 << STATIC_BLOCK_LITERAL_TABLE_BITS)-1)
#define STATIC_BLOCK_LITERAL_TABLE_SIZE		(1 << STATIC_BLOCK_LITERAL_TABLE_BITS)

#define STATIC_BLOCK_DISTANCE_TABLE_BITS    5
#define STATIC_BLOCK_DISTANCE_TABLE_MASK	((1 << STATIC_BLOCK_DISTANCE_TABLE_BITS)-1)
#define STATIC_BLOCK_DISTANCE_TABLE_SIZE	(1 << STATIC_BLOCK_DISTANCE_TABLE_BITS)


//
// Various possible states
//
typedef enum
{
    STATE_READING_GZIP_HEADER, // Only applies to GZIP
	STATE_READING_BFINAL_NEED_TO_INIT_BITBUF, // Start of block, need to init bit buffer
	STATE_READING_BFINAL,				// About to read bfinal bit
	STATE_READING_BTYPE,				// About to read btype bits
	STATE_READING_NUM_LIT_CODES,		// About to read # literal codes
	STATE_READING_NUM_DIST_CODES,		// About to read # dist codes
	STATE_READING_NUM_CODE_LENGTH_CODES,// About to read # code length codes
	STATE_READING_CODE_LENGTH_CODES,	// In the middle of reading the code length codes
	STATE_READING_TREE_CODES_BEFORE,	// In the middle of reading tree codes (loop top)
	STATE_READING_TREE_CODES_AFTER,		// In the middle of reading tree codes (extension; code > 15)
	STATE_DECODE_TOP,					// About to decode a literal (char/match) in a compressed block
	STATE_HAVE_INITIAL_LENGTH,			// Decoding a match, have the literal code (base length)
	STATE_HAVE_FULL_LENGTH,				// Ditto, now have the full match length (incl. extra length bits)
	STATE_HAVE_DIST_CODE,				// Ditto, now have the distance code also, need extra dist bits
	STATE_INTERRUPTED_MATCH,			// In the middle of a match, but output buffer filled up

	/* uncompressed blocks */
	STATE_UNCOMPRESSED_ALIGNING,
	STATE_UNCOMPRESSED_1,
	STATE_UNCOMPRESSED_2,
	STATE_UNCOMPRESSED_3,
	STATE_UNCOMPRESSED_4,
	STATE_DECODING_UNCOMPRESSED,

    // These three apply only to GZIP
    STATE_START_READING_GZIP_FOOTER, // (Initialisation for reading footer)
    STATE_READING_GZIP_FOOTER, 
    STATE_VERIFYING_GZIP_FOOTER,

    STATE_DONE // Finished

} t_decoder_state;


typedef struct
{
	byte				window[WINDOW_SIZE];

	// output buffer
	byte *				output_curpos;		// current output pos
	byte *				end_output_buffer;	// ptr to end of output buffer
	byte *				output_buffer;		// ptr to start of output buffer

	// input buffer
	const byte *		input_curpos;		// current input pos
	const byte *		end_input_buffer;	// ptr to end of input buffer

	int					num_literal_codes;
	int					num_dist_codes;
	int					num_code_length_codes;
	int					temp_code_array_size;
	byte				temp_code_list[MAX_LITERAL_TREE_ELEMENTS + MAX_DIST_TREE_ELEMENTS];

	// is this the last block?
	int					bfinal;

	// type of current block
	int					btype;

	// state information
	t_decoder_state		state;
	long				state_loop_counter;
	byte				state_code;
    BOOL                using_gzip;

    // gzip-specific stuff
    byte                gzip_header_substate;
    byte                gzip_header_flag;
    byte                gzip_header_xlen1_byte; // first byte of XLEN
    unsigned int        gzip_header_xlen; // xlen (0...65535)
    unsigned int        gzip_header_loop_counter;

    byte                gzip_footer_substate;
    unsigned int        gzip_footer_loop_counter;
    unsigned long       gzip_footer_crc32; // what we're supposed to end up with
    unsigned long       gzip_footer_output_stream_size; // what we're supposed to end up with

    unsigned long       gzip_crc32; // running counter
    unsigned long       gzip_output_stream_size; // running counter
    // end of gzip-specific stuff

	int					length;
	int					dist_code;
	long				offset;

	// bit buffer and # bits available in buffer
	unsigned long		bitbuf;
	int					bitcount;

	// position in the window
	long				bufpos;

	// for decoding the uncompressed block header
	byte				unc_buffer[4];

	// bit lengths of tree codes
	byte				literal_tree_code_length[MAX_LITERAL_TREE_ELEMENTS];
	byte				distance_tree_code_length[MAX_DIST_TREE_ELEMENTS];
	byte				pretree_code_length[NUM_PRETREE_ELEMENTS];

	// tree decoding tables
	short				distance_table[1 << DISTANCE_TABLE_BITS];
	short				literal_table[1 << LITERAL_TABLE_BITS];

	short 				literal_left[MAX_LITERAL_TREE_ELEMENTS*2];
	short 				literal_right[MAX_LITERAL_TREE_ELEMENTS*2];

	short 				distance_left[MAX_DIST_TREE_ELEMENTS*2];
	short 				distance_right[MAX_DIST_TREE_ELEMENTS*2];

	short				pretree_table[1 << PRETREE_TABLE_BITS];
	short				pretree_left[NUM_PRETREE_ELEMENTS*2];
	short				pretree_right[NUM_PRETREE_ELEMENTS*2];

} t_decoder_context;


#include "infproto.h"

#include "infdata.h"
#include "comndata.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\inflate.c ===
//
// inflate.c
//
// Decompressor
//
#include <crtdbg.h>
#include <stdio.h>
#include "inflate.h"
#include "infmacro.h"
#include "infgzip.h"
#include "maketbl.h"


//
// Local function prototypes
//
static BOOL	decodeBlock(t_decoder_context *context);
static BOOL makeTables(t_decoder_context *context);


HRESULT WINAPI Decompress(
	PVOID				void_context,
	CONST BYTE *		input, 
	LONG				input_size,
	BYTE *				output, 
	LONG				output_size,
	PLONG				input_used,
	PLONG				output_used
)
{
	t_decoder_context *context = (t_decoder_context *) void_context;

	context->input_curpos		= input;
	context->end_input_buffer	= input + input_size;
	context->output_curpos		= output;
	context->end_output_buffer	= output + output_size;
	context->output_buffer		= output;

	//
	// Keep decoding blocks until the output fills up, we read all the input, or we enter
    // the "done" state
	//
    // Note that INPUT_EOF() is not a sufficient check for determining that all the input
    // has been used; there could be an additional block stored entirely in the bit buffer.
    // For this reason, if we're in the READING_BFINAL state (start of new block) after
    // calling decodeBlock(), don't quit the loop unless there is truly no input left in
    // the bit buffer.
    //
	while ( (context->output_curpos < context->end_output_buffer) && 
            (!INPUT_EOF()) && 
            (context->state != STATE_DONE && context->state != STATE_VERIFYING_GZIP_FOOTER)
          )
	{
retry:
		if (decodeBlock(context) == FALSE)
		{
			*input_used = 0;
			*output_used = 0;
			return E_FAIL;
		}

        // No more input bytes, but am starting a new block and there's at least one bit
        // in the bit buffer
        if (context->state == STATE_READING_BFINAL && INPUT_EOF() && context->bitcount > -16)
            goto retry;
	}

	*input_used  = (long) (context->input_curpos - input);
	*output_used = (long) (context->output_curpos - output);

    if (context->using_gzip)
    {
        // Calculate the crc32 of everything we just decompressed, and then, if our state
        // is STATE_DONE, verify the crc
        if (*output_used > 0)
        {
            context->gzip_crc32 = GzipCRC32(context->gzip_crc32, output, *output_used);
            context->gzip_output_stream_size += (*output_used);
        }

        if (context->state == STATE_VERIFYING_GZIP_FOOTER)
        {
            context->state = STATE_DONE;

            // Now do our crc/input size check
            if (context->gzip_crc32 != context->gzip_footer_crc32 ||
                context->gzip_output_stream_size != context->gzip_footer_output_stream_size)
            {
               	*input_used = 0;
	            *output_used = 0;
        		return E_FAIL;
            }
        }
    }

	if (*input_used == 0 && *output_used == 0)
    {
        if (context->state == STATE_DONE)
		    return S_FALSE; // End of compressed data
        else
            return E_FAIL; // Avoid infinite loops
    }
	else
    {
		return S_OK;
    }
}


//
// Returns TRUE for success, FALSE for an error of some kind (invalid data)
//
static BOOL decodeBlock(t_decoder_context *context)
{
	BOOL eob, result;

    if (context->state == STATE_DONE || context->state == STATE_VERIFYING_GZIP_FOOTER)
        return TRUE;

    if (context->using_gzip)
    {
        if (context->state == STATE_READING_GZIP_HEADER)
        {
            if (ReadGzipHeader(context) == FALSE)
                return FALSE;

            // If we're still reading the GZIP header it means we ran out of input
            if (context->state == STATE_READING_GZIP_HEADER)
                return TRUE;
        }

        if (context->state == STATE_START_READING_GZIP_FOOTER || context->state == STATE_READING_GZIP_FOOTER)
        {
            if (ReadGzipFooter(context) == FALSE)
                return FALSE;

            // Whether we ran out of input or not, return
            return TRUE;
        }
    }

	//
	// Do we need to fill our bit buffer?
	//
	// This will happen the very first time we call Decompress(), as well as after decoding
	// an uncompressed block
	//
	if (context->state == STATE_READING_BFINAL_NEED_TO_INIT_BITBUF)
	{
		//
		// If we didn't have enough bits to init, return
		//
		if (initBitBuffer(context) == FALSE)
			return TRUE;
	}

	//
	// Need to read bfinal bit
	//
	if (context->state == STATE_READING_BFINAL)
	{
		// Need 1 bit
		if (ensureBitsContext(context, 1) == FALSE)
			return TRUE;

		context->bfinal	= getBits(context, 1);
		context->state = STATE_READING_BTYPE;
	}

	if (context->state == STATE_READING_BTYPE)
	{
		// Need 2 bits
		if (ensureBitsContext(context, 2) == FALSE)
			return TRUE;

		context->btype = getBits(context, 2);

		if (context->btype == BLOCKTYPE_DYNAMIC)
		{
			context->state = STATE_READING_NUM_LIT_CODES;
		}
		else if (context->btype == BLOCKTYPE_FIXED)
		{
			context->state = STATE_DECODE_TOP;
		}
		else if (context->btype == BLOCKTYPE_UNCOMPRESSED)
		{
			context->state = STATE_UNCOMPRESSED_ALIGNING;
		}
		else
		{
            // unsupported compression mode
			return FALSE;
		}
	}

	if (context->btype == BLOCKTYPE_DYNAMIC)
	{
		if (context->state < STATE_DECODE_TOP)
		{
			if (readDynamicBlockHeader(context) == FALSE)
				return FALSE;

			if (context->state == STATE_DECODE_TOP)
			{
				if (makeTables(context) == FALSE)
					return FALSE; // bad tables
			}
            else
            {
                return TRUE; // not enough input
            }
		}

		result = DecodeDynamicBlock(context, &eob);

		if (eob)
			context->state = STATE_READING_BFINAL;
	}
	else if (context->btype == BLOCKTYPE_FIXED)
	{
		result = DecodeStaticBlock(context, &eob);

		if (eob)
			context->state = STATE_READING_BFINAL;
	}
	else if (context->btype == BLOCKTYPE_UNCOMPRESSED)
	{
		result = decodeUncompressedBlock(context, &eob);
	}
	else
	{
		//
		// Invalid block type
		//
		return FALSE;
	}

    //
    // If we reached the end of the block and the block we were decoding had
    // bfinal=1 (final block)
    //
	if (eob && context->bfinal)
    {
        if (context->using_gzip)
    		context->state = STATE_START_READING_GZIP_FOOTER;
        else
            context->state = STATE_DONE;
    }

	return result;
}


//
// Will throw an exception if a corrupt table is detected
//
static BOOL makeTables(t_decoder_context *context) 
{
	if (makeTable(
		MAX_LITERAL_TREE_ELEMENTS,
		LITERAL_TABLE_BITS,
		context->literal_tree_code_length,
		context->literal_table,
		context->literal_left,
		context->literal_right) == FALSE)
		return FALSE;

	return makeTable(
		MAX_DIST_TREE_ELEMENTS,
		DISTANCE_TABLE_BITS,
		context->distance_tree_code_length,
		context->distance_table,
		context->distance_left,
		context->distance_right
	);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infproto.h ===
//
// infproto.h
//

// comninit.c
void InitStaticBlock(void);

// infinit.c
VOID inflateInit(VOID);

// inflate.c
BOOL ensureBitsContext(t_decoder_context *context, int num_bits);
int	 getBits(t_decoder_context *context, int n);
void dumpBits(t_decoder_context *context, int n);

// infuncmp.c
BOOL decodeUncompressedBlock(t_decoder_context *context, BOOL *end_of_block);

// inftree.c
BOOL readDynamicBlockHeader(t_decoder_context *context);

// infinput.c
void dumpBits(t_decoder_context *context, int n);
int getBits(t_decoder_context *context, int n);
BOOL ensureBitsContext(t_decoder_context *context, int num_bits);
BOOL initBitBuffer(t_decoder_context *context);

// infdyna.c
BOOL DecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen); 
BOOL FastDecodeDynamicBlock(t_decoder_context *context, BOOL *end_of_block_code_seen);

// infstatic.c
BOOL DecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen);
BOOL FastDecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infuncmp.c ===
//
// infuncmp.c
//
// Decodes uncompressed blocks
//
#include "inflate.h"
#include "infmacro.h"


//
// Returns whether there are >= n valid bits in the bit buffer
//
#define ASSERT_BITS_IN_BIT_BUFFER(n) (context->bitcount + 16 >= (n))


static int twoBytesToInt(byte a, byte b)
{
	return (((int) a) & 255) | ((((int) b) & 255) << 8);
}


static void dumpBits(t_decoder_context *context, int n)
{
	context->bitbuf >>= n; 
	context->bitcount -= n; 
}


// retrieve n bits from the bit buffer, and dump them when done
// n can be up to 16
static int getBits(t_decoder_context *context, int n)
{
	int result;

	context->bitcount -= n; 
	result = (context->bitbuf & g_BitMask[n]);
	context->bitbuf >>= n; 

	return result;
}


BOOL decodeUncompressedBlock(t_decoder_context *context, BOOL *end_of_block)
{
	unsigned int unc_len, complement;

	*end_of_block = FALSE;

	if (context->state == STATE_DECODING_UNCOMPRESSED)
	{
		unc_len = context->state_loop_counter;
	}
	else
	{
		int i;

		if (context->state == STATE_UNCOMPRESSED_ALIGNING)
		{
			// 
			// Right now we have between 0 and 32 bits in bitbuf
			//
			// However, we must flush to a byte boundary
			//
			if ((context->bitcount & 7) != 0)
			{
				int result;

				result = getBits(context, (context->bitcount & 7));

				//
				// Since this is supposed to be padding, we should read all zeroes,
				// however, it's not really specified in the spec that they have to
				// be zeroes, so don't count this as an error
				//
			}

			//
			// Now we have exactly 0, 8, 16, 24, or 32 bits in the bit buffer
			//
			context->state = STATE_UNCOMPRESSED_1;
		}

		//
		// Now we need to read 4 bytes from the input - however, some of these bytes may
		// be inside our bit buffer, so take them from there first
		//
		for (i = 0; i < 4; i++)
		{
			if (context->state == STATE_UNCOMPRESSED_1 + i)
			{
				if (ASSERT_BITS_IN_BIT_BUFFER(8))
				{
					context->unc_buffer[i] = (byte) ((context->bitbuf) & 255);
					context->bitbuf >>= 8;
					context->bitcount -= 8;
				}
				else
				{
					if (INPUT_EOF())
						return TRUE;

					context->unc_buffer[i] = *context->input_curpos++;
				}

				context->state++;
			}
		}

		unc_len = twoBytesToInt(
			context->unc_buffer[0], context->unc_buffer[1]
		);

		complement = twoBytesToInt(
			context->unc_buffer[2], context->unc_buffer[3]
		);

		// make sure complement matches
		if ((unsigned short) unc_len != (unsigned short) (~complement))
			return FALSE; // error!
	}

	// BUGBUG Make this into a memory copy loop for speed!
	while (unc_len > 0 && context->input_curpos < context->end_input_buffer && context->output_curpos < context->end_output_buffer)
	{
		unc_len--;
		*context->output_curpos++ = context->window[context->bufpos++] = *context->input_curpos++;
		context->bufpos &= WINDOW_MASK;
	}

	//
	// More bytes left to compress in this block?
	//
	if (unc_len != 0)
	{
		context->state = STATE_DECODING_UNCOMPRESSED;
		context->state_loop_counter = unc_len;
	}
	else
	{
		//
		// Done with this block, need to re-init bit buffer for next block
		//
		context->state = STATE_READING_BFINAL_NEED_TO_INIT_BITBUF;
		*end_of_block = TRUE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\maketbl.h ===
//
// maketbl.h
//
BOOL makeTable(
	int		num_elements, 
	int		table_bits, 
	const byte *code_length, 
	short *	table, 
	short *	left, 
	short *	right
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\maketbl.c ===
//
// maketbl.c
//
// Creates Huffman decoding tables
//
#include <windows.h>
#include <crtdbg.h>
#include "common.h"
#include "maketbl.h"


//
// Reverse the bits, len > 0
//
static unsigned int bitReverse(unsigned int code, int len)
{
	unsigned int new_code = 0;

    _ASSERT(len > 0);

	do
	{
		new_code |= (code & 1);
		new_code <<= 1;
		code >>= 1;
	} while (--len > 0);

	return new_code >> 1;
}


BOOL makeTable(
	int				num_elements, 
	int				table_bits, 
	const byte *	code_length, 
	short *			table, 
	short *			left, 
	short *			right
)
{
	int				bl_count[17];
	unsigned int	next_code[17];
	unsigned int	code[MAX_LITERAL_TREE_ELEMENTS];
	int				temp_code;
	int				avail;
	int				i, bits, ch;
	int				table_size, table_mask;

	table_size = 1 << table_bits;
	table_mask = table_size - 1;

	for (i = 0; i <= 16; i++)
		bl_count[i] = 0;

	for (i = 0; i < num_elements; i++)
		bl_count[ code_length[i] ]++;

	//
	// If there are any codes larger than table_bits in length, then
	// we will have to clear the table for our left/right spillover
    // code to work correctly.
	//
	// If there aren't any codes that large, then all table entries
	// will be written over without being read, so we don't need to
	// initialise them
	//
	for (i = table_bits; i <= 16; i++)
	{
		if (bl_count[i] > 0)
		{
			int j;

			// found a code larger than table_bits
			for (j = 0; j < table_size; j++)
				table[j] = 0;

			break;
		}
	}

	temp_code	= 0;
	bl_count[0] = 0;

	for (bits = 1; bits <= 16; bits++)
	{
		temp_code = (temp_code + bl_count[bits-1]) << 1;
		next_code[bits] = temp_code;
	}

	for (i = 0; i < num_elements; i++)
	{
		int len = code_length[i];

		if (len > 0)
		{
			code[i] = bitReverse(next_code[len], len);
			next_code[len]++;
		}
	}

	avail = num_elements;

	for (ch = 0; ch < num_elements; ch++)
	{
		int	start_at, len;

		// length of this code
		len = code_length[ch];

		// start value (bit reversed)
		start_at = code[ch];

		if (len > 0)
		{
			if (len <= table_bits)
			{
				int locs = 1 << (table_bits - len);
				int increment = 1 << len;
				int j;

				// 
				// Make sure that in the loop below, start_at is always
				// less than table_size.
				//
				// On last iteration we store at array index:
				//    initial_start_at + (locs-1)*increment
				//  = initial_start_at + locs*increment - increment
				//  = initial_start_at + (1 << table_bits) - increment
				//  = initial_start_at + table_size - increment
				//
				// Therefore we must ensure:
				//     initial_start_at + table_size - increment < table_size
				// or: initial_start_at < increment
				//
				if (start_at >= increment)
					return FALSE; // invalid table!

				for (j = 0; j < locs; j++)
				{
					table[start_at] = (short) ch;
					start_at += increment;
				}
			}
			else
			{
				int		overflow_bits;
				int		code_bit_mask;
				short *	p;

				overflow_bits = len - table_bits;
				code_bit_mask = 1 << table_bits;

				p = &table[start_at & table_mask];

				do
				{
					short value;

					value = *p;

					if (value == 0)
					{
						left[avail]		= 0;
						right[avail]	= 0;

						*p = -avail;

						value = -avail;
						avail++;
					}

					if ((start_at & code_bit_mask) == 0)
						p = &left[-value];
					else
						p = &right[-value];

					code_bit_mask <<= 1;
					overflow_bits--;
				} while (overflow_bits != 0);

				*p = (short) ch;
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\infstatic.c ===
//
// infstatic.c
//
// Decompress a static (fixed) compressed block
//
// This code was cloned from infdyna.c with the following changes:
// 1. Use global pre-initialised static tables
// 2. All distance prefixes are 5 bits, so don't look this up in a table
// 3. g_StaticDistanceTreeTable is a BYTE[] not a USHORT[]
// 4. Table lookup size for literals is 9 bits, for distances it is 5 bits
// 5. Due to #3 there is no table overflow, so there are no left/right arrays
// 6. When dumping 5 distance bits, no need to check for bitcount overflow twice
//
#include <stdio.h>
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"
#include "maketbl.h"


//
// Decoding table sizes; do not change!
//
// 9 is the largest code length for literals
// 5 is the largest code length for distances
//
// Therefore we don't need an overflow left/right table
//
#define STATIC_BLOCK_LITERAL_TABLE_BITS		9
#define STATIC_BLOCK_LITERAL_TABLE_MASK		((1 << STATIC_BLOCK_LITERAL_TABLE_BITS)-1)

#define STATIC_BLOCK_DISTANCE_TABLE_BITS	5
#define STATIC_BLOCK_DISTANCE_TABLE_MASK	((1 << STATIC_BLOCK_DISTANCE_TABLE_BITS)-1)


#define OUTPUT_EOF() (output_curpos >= context->end_output_buffer)

//
// This is the slow version, which worries about the input running out or the output
// running out.  The trick here is to not read any more bytes than we need to; theoretically
// the "end of block" code could be 1 bit, so we cannot always assume that it is ok to fill
// the bit buffer with 16 bits right before a table decode.
//
BOOL DecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
top:
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(bitcount >= -16);

	//
	// Set the state to DECODE_TOP here
	//
	switch (context->state)
	{
		case STATE_DECODE_TOP:
			break;

		case STATE_HAVE_INITIAL_LENGTH:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			goto reenter_state_have_initial_length;

		case STATE_HAVE_FULL_LENGTH:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			goto reenter_state_have_full_length;

		case STATE_HAVE_DIST_CODE:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			dist_code = context->dist_code;
			goto reenter_state_have_dist_code;

		case STATE_INTERRUPTED_MATCH:
			context->state = STATE_DECODE_TOP;
			length = context->length;
			offset = context->offset;
			goto reenter_state_interrupted_match;
	}

	do
	{
		if (context->output_curpos + MAX_MATCH < context->end_output_buffer &&
			context->input_curpos + 12 < context->end_input_buffer)
		{
			SAVE_BITBUF_VARS();
			context->output_curpos = output_curpos;
			context->bufpos = bufpos;

			if (FastDecodeStaticBlock(context, end_of_block_code_seen) == FALSE)
				return FALSE;

			if (*end_of_block_code_seen)
				return TRUE;

			goto top;
		}

		//
		// decode an element from the main tree
		//

		// we must have at least 1 bit available
		_ASSERT(bitcount >= -16);

		if (bitcount == -16)
		{
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
		}

retry_decode_literal:

		// assert that at least 1 bit is present
		_ASSERT(bitcount > -16);

		// decode an element from the literal tree
		length = g_StaticLiteralTreeTable[bitbuf & STATIC_BLOCK_LITERAL_TABLE_MASK]; 
		
		//
		// If this code is longer than the # bits we had in the bit buffer (i.e.
		// we read only part of the code - but enough to know that it's too long),
		// read more bits and retry
		//
		if (g_StaticLiteralTreeLength[length] > (bitcount+16))
		{
			// if we run out of bits, break
			if (input_ptr >= end_input_buffer)
				break;

			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8; 
			goto retry_decode_literal;		
		}

		DUMPBITS(g_StaticLiteralTreeLength[length]);
		_ASSERT(bitcount >= -16);

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

reenter_state_have_initial_length:

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					// make sure we have this many bits in the bit buffer
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_INITIAL_LENGTH;
							context->length = length;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
						
						// extra_length_bits will be no more than 5, so we need to read at
						// most one byte of input to satisfy this request
					}

					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);
					_ASSERT(bitcount >= -16);
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
reenter_state_have_full_length:

			// we must have at least 1 bit available
			if (bitcount == -16)
			{
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 
			}


retry_decode_distance:

			// assert that at least 1 bit is present
			_ASSERT(bitcount > -16);

			dist_code = g_StaticDistanceTreeTable[bitbuf & STATIC_BLOCK_DISTANCE_TABLE_MASK]; 
			
			//
			// If this code is longer than the # bits we had in the bit buffer (i.e.
			// we read only part of the code - but enough to know that it's too long),
			// read more bits and retry
			//
            // g_StaticTreeDistanceLength[dist_code] == 5
            //
			if (5 > (bitcount+16))
			{
				// if we run out of bits, break
				if (input_ptr >= end_input_buffer)
				{
					context->state = STATE_HAVE_FULL_LENGTH;
					context->length = length;
					break;
				}

				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8; 

				_ASSERT(bitcount >= -16);
				goto retry_decode_distance;		
			}


			DUMPBITS(5);

			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);

reenter_state_have_dist_code:

			_ASSERT(bitcount >= -16);

			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				// make sure we have this many bits in the bit buffer
				if (extra_bits > bitcount + 16)
				{
					// if we run out of bits, break
					if (input_ptr >= end_input_buffer)
					{
						context->state = STATE_HAVE_DIST_CODE;
						context->length = length;
						context->dist_code = dist_code;
						break;
					}

					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;
						
					// extra_length_bits can be > 8, so check again
					if (extra_bits > bitcount + 16)
					{
						// if we run out of bits, break
						if (input_ptr >= end_input_buffer)
						{
							context->state = STATE_HAVE_DIST_CODE;
							context->length = length;
							context->dist_code = dist_code;
							break;
						}

						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}

				offset = g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]); 

				DUMPBITS(extra_bits);
				_ASSERT(bitcount >= -16);
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
reenter_state_interrupted_match:

			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;

				if (--length == 0)
					break;

			} while (output_curpos < context->end_output_buffer);

			if (length > 0)
			{
				context->state = STATE_INTERRUPTED_MATCH;
				context->length = length;
				context->offset = offset;
				break;
			}
		}

		// it's "<=" because we end when we received the end-of-block code,
		// not when we fill up the output, however, this will catch cases
		// of corrupted data where there is no end-of-output code
	} while (output_curpos < context->end_output_buffer);

	_ASSERT(bitcount >= -16);

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}


//
// This is the fast version, which assumes that, at the top of the loop:
//
// 1. There are at least 12 bytes of input available at the top of the loop (so that we don't
// have to check input EOF several times in the middle of the loop)
//
// and
//
// 2. There are at least MAX_MATCH bytes of output available (so that we don't have to check
// for output EOF while we're copying matches)
//
// The state must also be STATE_DECODE_TOP on entering and exiting this function
//
BOOL FastDecodeStaticBlock(t_decoder_context *context, BOOL *end_of_block_code_seen) 
{
	const byte *	input_ptr;
	const byte *	end_input_buffer;
	byte *			output_curpos;
	byte *			window;
	unsigned long	bufpos;
	unsigned long	bitbuf;
	int				bitcount;
	int				length;
	long			dist_code;
	unsigned long	offset;

	*end_of_block_code_seen = FALSE;

	//
	// Store these variables locally for speed
	//
	output_curpos	= context->output_curpos;

	window = context->window;
	bufpos = context->bufpos;

	end_input_buffer = context->end_input_buffer;

	LOAD_BITBUF_VARS();

	_ASSERT(context->state == STATE_DECODE_TOP);
	_ASSERT(input_ptr + 12 < end_input_buffer);
	_ASSERT(output_curpos + MAX_MATCH < context->end_output_buffer);

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	do
	{
		//
		// decode an element from the main tree
		//

		// decode an element from the literal tree
		length = g_StaticLiteralTreeTable[bitbuf & STATIC_BLOCK_LITERAL_TABLE_MASK]; 
		
		DUMPBITS(g_StaticLiteralTreeLength[length]);

		if (bitcount <= 0)
		{
			bitbuf |= ((*input_ptr++) << (bitcount+16)); 
			bitcount += 8;

			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;
			}
		}

		//
		// Is it a character or a match?
		//
		if (length < 256)
		{
			// it's an unmatched symbol
			window[bufpos] = *output_curpos++ = (byte) length;
			bufpos = (bufpos + 1) & WINDOW_MASK;
		}
		else
		{
			// it's a match
			int extra_bits;

			length -= 257;

			// if value was 256, that was the end-of-block code
			if (length < 0)
			{
				*end_of_block_code_seen = TRUE;
				break;
			}


			//
			// Get match length
			//

			//
			// These matches are by far the most common case.
			//
			if (length < 8)
			{
				// no extra bits

				// match length = 3,4,5,6,7,8,9,10
				length += 3;
			}
			else
			{
				int extra_bits;

				extra_bits = g_ExtraLengthBits[length];

				if (extra_bits > 0)
				{
					length = g_LengthBase[length] + (bitbuf & g_BitMask[extra_bits]);

					DUMPBITS(extra_bits);

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;

						if (bitcount <= 0)
						{
							bitbuf |= ((*input_ptr++) << (bitcount+16)); 
							bitcount += 8;
						}
					}
				}
				else
				{
					/*
					 * we know length > 8 and extra_bits == 0, there the length must be 258
					 */
					length = 258; /* g_LengthBase[length]; */
				}
			}

			//
			// Get match distance
			//

			// decode distance code
			dist_code = g_StaticDistanceTreeTable[bitbuf & STATIC_BLOCK_DISTANCE_TABLE_MASK]; 
			DUMPBITS(5);

            // unlike dynamic block, don't need to do this twice
			if (bitcount <= 0)
			{
				bitbuf |= ((*input_ptr++) << (bitcount+16)); 
				bitcount += 8;
			}


			// To avoid a table lookup we note that for dist_code >= 2,
			// extra_bits = (dist_code-2) >> 1
			//
			// Old (intuitive) way of doing this:
			//    offset = distance_base_position[dist_code] + 
			//	   		   getBits(extra_distance_bits[dist_code]);
			extra_bits = (dist_code-2) >> 1;

			if (extra_bits > 0)
			{
				offset	= g_DistanceBasePosition[dist_code] + (bitbuf & g_BitMask[extra_bits]);
                
				DUMPBITS(extra_bits);

				if (bitcount <= 0)
				{
					bitbuf |= ((*input_ptr++) << (bitcount+16)); 
					bitcount += 8;

					if (bitcount <= 0)
					{
						bitbuf |= ((*input_ptr++) << (bitcount+16)); 
						bitcount += 8;
					}
				}
			}
			else
			{
				offset = dist_code + 1;
			}

			// copy remaining byte(s) of match
			do
			{
				window[bufpos] = *output_curpos++ = window[(bufpos - offset) & WINDOW_MASK];
				bufpos = (bufpos + 1) & WINDOW_MASK;
			} while (--length != 0);
		}
	} while ((input_ptr + 12 < end_input_buffer) && (output_curpos + MAX_MATCH < context->end_output_buffer));

	// make sure there are at least 16 bits in the bit buffer
	while (bitcount <= 0)
	{
		bitbuf |= ((*input_ptr++) << (bitcount+16)); 
		bitcount += 8;
	}

	SAVE_BITBUF_VARS();

	context->output_curpos = output_curpos;
	context->bufpos = bufpos;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\inftree.c ===
//
// inftree.c
//
// Reads the tree for a dynamic block
//
#include <crtdbg.h>
#include "inflate.h"
#include "infmacro.h"
#include "maketbl.h"


//
// Decode an element from the pre-tree
//
static int decodePretreeElement(t_decoder_context *context)
{
	int element;

retry:
	element = context->pretree_table[context->bitbuf & PRETREE_TABLE_MASK];

	while (element < 0)
	{
		unsigned long mask = 1 << PRETREE_TABLE_BITS;

		do
		{
			element = -element;

			if ((context->bitbuf & mask) == 0)
				element = context->pretree_left[element];
			else
				element = context->pretree_right[element];

			mask <<= 1;
		} while (element < 0);
	}

	//
	// If this code is longer than the # bits we had in the bit buffer (i.e.
	// we read only part of the code - but enough to know that it's too long),
	// return -1.
	//
	if (context->pretree_code_length[element] > (context->bitcount+16))
	{
		// if we run out of bits, return -1
		if (context->input_curpos >= context->end_input_buffer)
			return -1;

		context->bitbuf |= ((*context->input_curpos++) << (context->bitcount+16)); 
		context->bitcount += 8; 
		goto retry;
	}

	dumpBits(context, context->pretree_code_length[element]);

	return element;
}



//
// Dilemma: 
// 
// This code runs slowly because bitcount and bitbuf are accessed through the context,
// not as local variables.  However, if they were made into local variables, the code
// size would be massively increased.  Luckily the speed of this code isn't so important
// compared to that of decodeCompressedBlock().
//          
BOOL readDynamicBlockHeader(t_decoder_context *context)
{
	int		i;
	int     code;

#define NUM_CODE_LENGTH_ORDER_CODES (sizeof(g_CodeOrder)/sizeof(g_CodeOrder[0]))
    // make sure extern g_CodeOrder[] declared with array size!

	switch (context->state)
	{
		case STATE_READING_NUM_LIT_CODES:
			goto reenter_state_reading_num_lit_codes;

		case STATE_READING_NUM_DIST_CODES:
			goto reenter_state_reading_num_dist_codes;

		case STATE_READING_NUM_CODE_LENGTH_CODES:
			goto reenter_state_reading_num_code_length_codes;

		case STATE_READING_CODE_LENGTH_CODES:
		{
			i = context->state_loop_counter;
			goto reenter_state_reading_code_length_codes;
		}

		case STATE_READING_TREE_CODES_BEFORE:
		{
			i = context->state_loop_counter;
			goto reenter_state_reading_tree_codes_before;
		}

		case STATE_READING_TREE_CODES_AFTER:
		{
			i = context->state_loop_counter;
			code = context->state_code;
			goto reenter_state_reading_tree_codes_after;
		}

		default:
			return TRUE;
	}


reenter_state_reading_num_lit_codes:

	if (ensureBitsContext(context, 5) == FALSE)
	{
		context->state = STATE_READING_NUM_LIT_CODES;
		return TRUE;
	}

	context->num_literal_codes		= getBits(context, 5) + 257;



reenter_state_reading_num_dist_codes:

	if (ensureBitsContext(context, 5) == FALSE)
	{
		context->state = STATE_READING_NUM_DIST_CODES;
		return TRUE;
	}

	context->num_dist_codes			= getBits(context, 5) + 1;



reenter_state_reading_num_code_length_codes:

	if (ensureBitsContext(context, 4) == FALSE)
	{
		context->state = STATE_READING_NUM_CODE_LENGTH_CODES;
		return TRUE;
	}

	context->num_code_length_codes	= getBits(context, 4) + 4;



	for (i = 0; i < context->num_code_length_codes; i++)
	{

reenter_state_reading_code_length_codes:

		if (ensureBitsContext(context, 3) == FALSE)
		{
			context->state = STATE_READING_CODE_LENGTH_CODES;
			context->state_loop_counter = i;
			return TRUE;
		}

		context->pretree_code_length[ g_CodeOrder[i] ] = (byte) getBits(context, 3);
	}

	for (i = context->num_code_length_codes; i < NUM_CODE_LENGTH_ORDER_CODES; i++)
		context->pretree_code_length[ g_CodeOrder[i] ] = 0;

	if (makeTable(
		NUM_PRETREE_ELEMENTS,
		PRETREE_TABLE_BITS,
		context->pretree_code_length,
		context->pretree_table,
		context->pretree_left,
		context->pretree_right
	) == FALSE)
	{
		return FALSE;
	}

	context->temp_code_array_size = context->num_literal_codes + context->num_dist_codes;


	for (i = 0; i < context->temp_code_array_size; )
	{

reenter_state_reading_tree_codes_before:

		_ASSERT(context->bitcount >= -16);

		if (context->bitcount == -16)
		{
			if (context->input_curpos >= context->end_input_buffer)
            {
    			context->state = STATE_READING_TREE_CODES_BEFORE;
	    		context->state_loop_counter = i;
                return TRUE;
            }

			context->bitbuf |= ((*context->input_curpos++) << (context->bitcount+16)); 
			context->bitcount += 8; 
		}

		code = decodePretreeElement(context);

        if (code < 0)
        {
			context->state = STATE_READING_TREE_CODES_BEFORE;
			context->state_loop_counter = i;
			return TRUE;
        }

reenter_state_reading_tree_codes_after:

		if (code <= 15)
		{
			context->temp_code_list[i++] = (unsigned char) code;
		}
		else
		{
			int		repeat_count, j;

			//
			// If the code is > 15 it means there is a repeat count of 2, 3, or 7 bits
			//
			if (ensureBitsContext(context, 7) == FALSE)
			{
				context->state = STATE_READING_TREE_CODES_AFTER;
				context->state_code = (unsigned char) code;
				context->state_loop_counter = i;
				return TRUE;
			}

			if (code == 16)
			{
				byte prev_code;

				// can't have "prev code" on first code
				if (i == 0)
					return FALSE;

				prev_code = context->temp_code_list[i-1];

				repeat_count = getBits(context, 2) + 3;

				if (i + repeat_count > context->temp_code_array_size)
					return FALSE;

				for (j = 0; j < repeat_count; j++)
					context->temp_code_list[i++] = prev_code;
			}
			else if (code == 17)
			{
				repeat_count = getBits(context, 3) + 3;

				if (i + repeat_count > context->temp_code_array_size)
					return FALSE;

				for (j = 0; j < repeat_count; j++)
					context->temp_code_list[i++] = 0;
			}
			else // code == 18
			{
				repeat_count = getBits(context, 7) + 11;

				if (i + repeat_count > context->temp_code_array_size)
					return FALSE;

				for (j = 0; j < repeat_count; j++)
					context->temp_code_list[i++] = 0;
			}
		}
	}

	//
	// Create literal and distance tables
	//
	memcpy(context->literal_tree_code_length, context->temp_code_list, context->num_literal_codes);

	for (i = context->num_literal_codes; i < MAX_LITERAL_TREE_ELEMENTS; i++)
		context->literal_tree_code_length[i] = 0;

	for (i = 0; i < context->num_dist_codes; i++)
		context->distance_tree_code_length[i] = context->temp_code_list[i + context->num_literal_codes];

	for (i = context->num_dist_codes; i < MAX_DIST_TREE_ELEMENTS; i++)
		context->distance_tree_code_length[i] = 0;

	//
	// Make sure there is an end-of-block code, otherwise how could we ever end?
	//
	if (context->literal_tree_code_length[END_OF_BLOCK_CODE] == 0)
		return FALSE;

	context->state = STATE_DECODE_TOP;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\optdebug.c ===
/*
 * optdebug.c
 *
 * Optimal encoder debugging stubs
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef _DEBUG
static void OptimalEncoderVerifyTreeStructure(t_encoder_context *context, byte val1, byte val2, long where)
{
	long left, right;

	if (where == 0)
		return;

	_ASSERT(context->optimal_encoder->window[where] == val1);
	_ASSERT(context->optimal_encoder->window[where+1] == val2);

	left = context->optimal_encoder->search_left[where];
	right = context->optimal_encoder->search_right[where];

	OptimalEncoderVerifyTreeStructure(context, val1, val2, left);
	OptimalEncoderVerifyTreeStructure(context, val1, val2, right);
}


void OptimalEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
	long i;

	for (i = 0; i < NUM_DIRECT_LOOKUP_TABLE_ELEMENTS; i++)
	{
		long	where = context->optimal_encoder->search_tree_root[i];
		USHORT	tree_to_use;

		if (where == 0)
			continue;

		tree_to_use = *((USHORT UNALIGNED *) &context->optimal_encoder->window[where]);

		_ASSERT(where < bufpos);
		_ASSERT(tree_to_use == i);

		OptimalEncoderVerifyTreeStructure(context, context->optimal_encoder->window[where], context->optimal_encoder->window[where+1], where);
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\optblock.c ===
//
// optblock.c
//
// Outputting blocks
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "maketbl.h"


//
// Decode a recorded literal
//
#define DECODE_LITERAL(slot) \
	slot = encoder->recording_literal_tree_table[read_bitbuf & REC_LITERALS_DECODING_TABLE_MASK]; \
	while (slot < 0) \
	{  \
		unsigned long mask = 1 << REC_LITERALS_DECODING_TABLE_BITS; \
		do \
		{ \
			slot = -slot; \
			if ((read_bitbuf & mask) == 0) \
				slot = encoder->recording_literal_tree_left[slot]; \
			else \
				slot = encoder->recording_literal_tree_right[slot]; \
			mask <<= 1; \
		} while (slot < 0); \
	}


//
// Decode a recorded distance slot
//
#define DECODE_POS_SLOT(slot) \
	slot = encoder->recording_dist_tree_table[read_bitbuf & REC_DISTANCES_DECODING_TABLE_MASK]; \
	while (slot < 0) \
	{  \
		unsigned long mask = 1 << REC_DISTANCES_DECODING_TABLE_BITS; \
		do \
		{ \
			slot = -slot; \
			if ((read_bitbuf & mask) == 0) \
				slot = encoder->recording_dist_tree_left[slot]; \
			else \
				slot = encoder->recording_dist_tree_right[slot]; \
			mask <<= 1; \
		} while (slot < 0); \
	}


//
// Remove count bits from the bit buffer
//
#define DUMP_READBUF_BITS(count) \
	read_bitbuf >>= count; \
	read_bitcount -= count;


//
// Read more bits into the read buffer if our bit buffer if we need to
//
#define CHECK_MORE_READBUF() \
	if (read_bitcount <= 0) \
	{ \
		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
		read_bitcount += 8; \
		if (read_bitcount <= 0) \
		{ \
			read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
			read_bitcount += 8; \
		} \
	}


// output an element from the literal tree
#define OUTPUT_LITERAL(element) \
{ \
	_ASSERT(encoder->literal_tree_len[element] != 0); \
	outputBits(context, encoder->literal_tree_len[element], encoder->literal_tree_code[element]); \
}


// output an element from the distance tree
#define OUTPUT_DIST_SLOT(element) \
{ \
	_ASSERT(encoder->dist_tree_len[element] != 0); \
	outputBits(context, encoder->dist_tree_len[element], encoder->dist_tree_code[element]); \
}



//
// Output a dynamic block
//
static BOOL OptimalEncoderOutputDynamicBlock(t_encoder_context *context)
{
	unsigned long	read_bitbuf;
	int				read_bitcount;
	byte *			read_bufptr;
    t_optimal_encoder *encoder = context->optimal_encoder;

	if (context->state == STATE_NORMAL)
	{
		//
		// If we haven't started to output a block yet
		//
        read_bufptr     = encoder->lit_dist_buffer;
		read_bitbuf		= 0;
		read_bitcount	= -16;

		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
		read_bitcount += 8;

		read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
		read_bitcount += 8;

		context->outputting_block_bitbuf		= read_bitbuf;
		context->outputting_block_bitcount		= read_bitcount;
		context->outputting_block_bufptr		= read_bufptr;

		outputBits(context, 1, 0); // "final" block flag
		outputBits(context, 2, BLOCKTYPE_DYNAMIC); 

		context->state = STATE_OUTPUTTING_TREE_STRUCTURE;
	}

	if (context->state == STATE_OUTPUTTING_TREE_STRUCTURE)
	{
		//
		// Make sure there is enough room to output the entire tree structure at once
		//
		if (context->output_curpos > context->output_endpos - MAX_TREE_DATA_SIZE)
		{
            _ASSERT(0); // not enough room to output tree structure, fatal error!
			return FALSE;
		}

		outputTreeStructure(context, encoder->literal_tree_len, encoder->dist_tree_len);

		context->state = STATE_OUTPUTTING_BLOCK;
	}

	_ASSERT(context->state == STATE_OUTPUTTING_BLOCK);

	// load state into local variables
	read_bufptr		= context->outputting_block_bufptr;
	read_bitbuf		= context->outputting_block_bitbuf;
	read_bitcount	= context->outputting_block_bitcount;

	// output literals
	while (context->outputting_block_current_literal < context->outputting_block_num_literals)
	{
		int literal;

		// break when we get near the end of our output buffer
		if (context->output_curpos >= context->output_near_end_threshold)
			break;

		DECODE_LITERAL(literal);
		DUMP_READBUF_BITS(encoder->recording_literal_tree_len[literal]);
		CHECK_MORE_READBUF();

		if (literal < NUM_CHARS)
		{
			// it's a char
			OUTPUT_LITERAL(literal);
		}
		else
		{
			// it's a match
			int len_slot, pos_slot, extra_pos_bits;

			// literal == len_slot + (NUM_CHARS+1)
			_ASSERT(literal != END_OF_BLOCK_CODE);

			OUTPUT_LITERAL(literal);

			len_slot = literal - (NUM_CHARS+1);

			//
			// extra_length_bits[len_slot] > 0 when len_slot >= 8
			// (except when length is MAX_MATCH).
			//
			if (len_slot >= 8)
			{
				int extra_bits = g_ExtraLengthBits[len_slot];

				if (extra_bits > 0)
				{
					unsigned int extra_data = read_bitbuf & ((1 << extra_bits)-1);

					outputBits(context, extra_bits, extra_data);
					
					DUMP_READBUF_BITS(extra_bits);
					CHECK_MORE_READBUF();
				}
			}

			DECODE_POS_SLOT(pos_slot);
			DUMP_READBUF_BITS(encoder->recording_dist_tree_len[pos_slot]);
			CHECK_MORE_READBUF();

			_ASSERT(pos_slot < 30);

			OUTPUT_DIST_SLOT(pos_slot);

			extra_pos_bits = g_ExtraDistanceBits[pos_slot];

			if (extra_pos_bits > 0)
			{
				unsigned int extra_data = read_bitbuf & ((1 << extra_pos_bits)-1);

				outputBits(context, extra_pos_bits, extra_data);

				DUMP_READBUF_BITS(extra_pos_bits);
				CHECK_MORE_READBUF();
			}
		}

		context->outputting_block_current_literal++;
	}

	// did we output all of our literals without running out of output space?
	if (context->outputting_block_current_literal >= context->outputting_block_num_literals)
	{
		// output the code signifying end-of-block
		OUTPUT_LITERAL(END_OF_BLOCK_CODE);

		// reset state
		context->state = STATE_NORMAL;
	}
	else
	{
		context->outputting_block_bitbuf	= read_bitbuf;
		context->outputting_block_bitcount	= read_bitcount;
		context->outputting_block_bufptr	= read_bufptr;
		context->state					    = STATE_OUTPUTTING_BLOCK;
	}

    return TRUE;
}



//
// Output a block.  This routine will resume outputting a block that was already being
// output if state != STATE_NORMAL.
//
BOOL OptimalEncoderOutputBlock(t_encoder_context *context)
{
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);

	//
	// The tree creation routines cannot >= 65536 literals.
	//
	_ASSERT(context->outputting_block_num_literals < 65536);

	if (context->state == STATE_NORMAL)
	{
        //
		// Start outputting literals and distances from the beginning
		//
		context->outputting_block_current_literal = 0;
	
		//
		// Nothing to output?  Then return
		//
		if (context->outputting_block_num_literals == 0)
			return TRUE;

		// make decoding table so that we can decode recorded items
		makeTable(
			MAX_LITERAL_TREE_ELEMENTS,
			REC_LITERALS_DECODING_TABLE_BITS,
			encoder->recording_literal_tree_len,
			encoder->recording_literal_tree_table,
			encoder->recording_literal_tree_left,
			encoder->recording_literal_tree_right
		);

		makeTable(
			MAX_DIST_TREE_ELEMENTS,
			REC_DISTANCES_DECODING_TABLE_BITS,
			encoder->recording_dist_tree_len,
			encoder->recording_dist_tree_table,
			encoder->recording_dist_tree_left,
			encoder->recording_dist_tree_right
		);

		// now make the trees used for encoding
	    makeTree(
    		MAX_LITERAL_TREE_ELEMENTS, 
	    	15, 
    		encoder->literal_tree_freq, 
	    	encoder->literal_tree_code,
    		encoder->literal_tree_len
    	);

	    makeTree(
    		MAX_DIST_TREE_ELEMENTS, 
	    	15, 
    		encoder->dist_tree_freq, 
	    	encoder->dist_tree_code,
    		encoder->dist_tree_len
    	);
	}

	//
	// Try outputting as a dynamic block
	//
	if (OptimalEncoderOutputDynamicBlock(context) == FALSE)
    {
        return FALSE;
    }

    if (context->state == STATE_NORMAL)
    {
   	    encoder->recording_bufptr           = context->optimal_encoder->lit_dist_buffer;
        encoder->recording_bitbuf           = 0;
        encoder->recording_bitcount         = 0;

		context->outputting_block_num_literals = 0;

		// make sure there are no zero frequency items
		NormaliseFrequencies(encoder->literal_tree_freq, encoder->dist_tree_freq);

		// make tree for recording new items
		makeTree(
			MAX_DIST_TREE_ELEMENTS, 
			RECORDING_DIST_MAX_CODE_LEN,
			encoder->dist_tree_freq, 
			encoder->recording_dist_tree_code, 
			encoder->recording_dist_tree_len
		);

		makeTree(
			MAX_LITERAL_TREE_ELEMENTS, 
			RECORDING_LIT_MAX_CODE_LEN,
			encoder->literal_tree_freq, 
			encoder->recording_literal_tree_code, 
			encoder->recording_literal_tree_len
		);

		OptimalEncoderZeroFrequencyCounts(encoder);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\optenc.c ===
/*
 * optenc.c
 *
 * Optimal encoder
 *
 * BUGBUG  Can improve compression by using the "redo" method of LZX; after the first 32K bytes,
 * reset the compressor but keep the tables, and start over.
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//
// If we get a match this good, take it automatically
//
// Note: FAST_DECISION_THRESHOLD can be set to anything; it's been set to BREAK_LENGTH
//       arbitrarily
//
#define FAST_DECISION_THRESHOLD BREAK_LENGTH


//
// After we have this many literals, create a tree to get updated statistical estimates
//
#define FIRST_TREE_UPDATE 1024


//
// Verifies that all of the hash pointers in the hash table are correct, and that
// the tree structure is valid.
//
#define DISABLE_VERIFY_HASHES

#ifdef _DEBUG
#ifndef DISABLE_VERIFY_HASHES
#define VERIFY_HASHES(bufpos) verifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif
#else
#define VERIFY_HASHES(bufpos) ;
#endif


#define CHECK_FLUSH_RECORDING_BUFFER() \
	if (recording_bitcount >= 16) \
	{ \
		*recording_bufptr++ = (BYTE) recording_bitbuf; \
		*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); \
		recording_bitbuf >>= 16; \
		recording_bitcount -= 16; \
	}


#define OUTPUT_RECORDING_DATA(count,data) \
	recording_bitbuf |= ((data) << recording_bitcount); \
	recording_bitcount += (count);


//
// Record unmatched symbol c
//
#define RECORD_CHAR(c) \
    context->outputting_block_num_literals++; \
    encoder->literal_tree_freq[c]++; \
	_ASSERT(encoder->recording_literal_tree_len[c] != 0); \
	OUTPUT_RECORDING_DATA(encoder->recording_literal_tree_len[c], encoder->recording_literal_tree_code[c]); \
	CHECK_FLUSH_RECORDING_BUFFER();


//
// Record a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
#define RECORD_MATCH(match_len, match_pos) \
{ \
	int pos_slot = POS_SLOT(match_pos); \
	int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
	int item = (NUM_CHARS+1) + len_slot; \
	int extra_dist_bits = g_ExtraDistanceBits[pos_slot]; \
	int extra_len_bits = g_ExtraLengthBits[len_slot]; \
	_ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
	_ASSERT(context->outputting_block_num_literals >= 0 && context->outputting_block_num_literals < OPT_ENCODER_MAX_ITEMS); \
	_ASSERT(encoder->recording_literal_tree_len[item] != 0); \
	_ASSERT(encoder->recording_dist_tree_len[pos_slot] != 0); \
    context->outputting_block_num_literals++; \
    encoder->literal_tree_freq[(NUM_CHARS + 1) + len_slot]++; \
    encoder->dist_tree_freq[pos_slot]++; \
	OUTPUT_RECORDING_DATA(encoder->recording_literal_tree_len[item], encoder->recording_literal_tree_code[item]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_len_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_len_bits, (match_len-MIN_MATCH) & ((1 << extra_len_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
	OUTPUT_RECORDING_DATA(encoder->recording_dist_tree_len[pos_slot], encoder->recording_dist_tree_code[pos_slot]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_dist_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_dist_bits, match_pos & ((1 << extra_dist_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
}


#define FLUSH_RECORDING_BITBUF() \
    *recording_bufptr++ = (BYTE) recording_bitbuf; \
	*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); 


static void calculateUpdatedEstimates(t_encoder_context *context);
static void OptimalEncoderMoveWindows(t_encoder_context *context);


static int match_est(t_optimal_encoder *encoder, int match_length, unsigned int match_pos)
{
	int dist_slot;
	int len_slot;

	// output match position
	len_slot = g_LengthLookup[match_length-MIN_MATCH];
	dist_slot = POS_SLOT(match_pos);

	return	encoder->literal_tree_len[NUM_CHARS + 1 + len_slot] +
			g_ExtraLengthBits[len_slot] +
			encoder->dist_tree_len[dist_slot] + 
			g_ExtraDistanceBits[dist_slot];
}


//
// Create initial estimations to output each element
//
static void initOptimalEstimates(t_encoder_context *context)
{
	int i, p;
    t_optimal_encoder *encoder = context->optimal_encoder;

	for (i = 0; i < NUM_CHARS; i++)
		encoder->literal_tree_len[i] = 8;

	p = NUM_CHARS+1;
	encoder->literal_tree_len[p] = 3;
	encoder->literal_tree_len[p+1] = 4;
	encoder->literal_tree_len[p+2] = 5;

	for (; p < MAX_LITERAL_TREE_ELEMENTS; p++)
		encoder->literal_tree_len[p] = 6;

	for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
		encoder->dist_tree_len[i] = (i/2)+1;
}


//
// Fix optimal estimates; if bitlen == 0 it doesn't mean that the element takes 0
// bits to output, it means that the element didn't occur, so come up with some estimate.
//
static void fixOptimalEstimates(t_encoder_context *context)
{
	int i;
    t_optimal_encoder *encoder = context->optimal_encoder;

	for (i = 0; i < NUM_CHARS; i++)
	{
		if (encoder->literal_tree_len[i] == 0)
			encoder->literal_tree_len[i] = 13;
	}

	for (i = NUM_CHARS+1; i < MAX_LITERAL_TREE_ELEMENTS; i++)
	{
		if (encoder->literal_tree_len[i] == 0)
			encoder->literal_tree_len[i] = 12;
	}

	for (i = 0; i < MAX_DIST_TREE_ELEMENTS; i++)
	{
		if (encoder->dist_tree_len[i] == 0)
			encoder->dist_tree_len[i] = 10;
	}
}


/*
 * Returns an estimation of how many bits it would take to output
 * a given character
 */
#define CHAR_EST(c) (numbits_t) (encoder->literal_tree_len[(c)])


/*
 * Returns an estimation of how many bits it would take to output
 * a given match.
 */
#define MATCH_EST(ml,mp,result) result = match_est(encoder, ml,mp);


//
// Returns whether the literal buffers are just about full
//
// Since we could output a large number of matches/chars in between these checks, we
// have to be careful.
//
// BUGBUG should check after each item output, so we don't have to be so careful; this
//        means we will utilise more of the recording buffer
//
#define LITERAL_BUFFERS_FULL() \
    (context->outputting_block_num_literals >= OPT_ENCODER_MAX_ITEMS-4-LOOK-MAX_MATCH || \
            recording_bufptr + 3*(MAX_MATCH + LOOK) >= end_recording_bufptr)


void OptimalEncoderDeflate(t_encoder_context *context)
{
	unsigned long	bufpos_end;
	unsigned long	MatchPos;
	unsigned long	i;
	int				EncMatchLength; /* must be a signed number */
	unsigned long	bufpos;
	unsigned long	recording_bitbuf;
	int				recording_bitcount;
	byte *			recording_bufptr;
    byte *          end_recording_bufptr;
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);
	_ASSERT(context->state == STATE_NORMAL);

	// reinsert the up to BREAK_LENGTH nodes we removed the last time we exit this function
	VERIFY_HASHES(context->bufpos);
	reinsertRemovedNodes(context);
	VERIFY_HASHES(context->bufpos);

	// restore literal/match bitmap variables
    end_recording_bufptr = &encoder->lit_dist_buffer[OPT_ENCODER_LIT_DIST_BUFFER_SIZE-8];
	recording_bufptr = encoder->recording_bufptr;
    recording_bitbuf = encoder->recording_bitbuf;
    recording_bitcount = encoder->recording_bitcount;

    bufpos			= context->bufpos;
	bufpos_end		= context->bufpos_end;

	/*
	 * While we haven't reached the end of the data
	 */
after_output_block:

	while (bufpos < bufpos_end)
	{
		// time to update our stats?
		if (context->outputting_block_num_literals >= encoder->next_tree_update)
		{
			encoder->next_tree_update += 1024;

            calculateUpdatedEstimates(context);
			fixOptimalEstimates(context);
		}

		// literal buffer or distance buffer filled up (or close to filling up)?
		if (LITERAL_BUFFERS_FULL())
			break;

		/*
		 * Search for matches of all different possible lengths, at bufpos
		 */
		EncMatchLength = optimal_find_match(context, bufpos); 

		if (EncMatchLength < MIN_MATCH)
		{

output_literal:
			/*
			 * No match longer than 1 character exists in the history 
			 * window, so output the character at bufpos as a symbol.
			 */
			RECORD_CHAR(encoder->window[bufpos]);
			bufpos++;
			continue;
		}

		/*
		 * Found a match.
		 *
		 * Make sure it cannot exceed the end of the buffer.
		 */
		if ((unsigned long) EncMatchLength + bufpos > bufpos_end)
		{
			EncMatchLength = bufpos_end - bufpos;    

			/*
			 * Oops, not enough for even a small match, so we 
			 * have to output a literal
			 */
			if (EncMatchLength < MIN_MATCH)
				goto output_literal;
		}

		if (EncMatchLength < FAST_DECISION_THRESHOLD)
		{
			/*
			 *  A match has been found that is between MIN_MATCH and 
			 *  FAST_DECISION_THRESHOLD bytes in length.  The following 
			 *  algorithm is the optimal encoder that will determine the 
			 *  most efficient order of matches and unmatched characters 
			 *  over a span area defined by LOOK.  
			 *
			 *  The code is essentially a shortest path determination 
			 *  algorithm.  A stream of data can be encoded in a vast number 
			 *  of different ways depending on the match lengths and offsets
			 *  chosen.  The key to good compression ratios is to chose the 
			 *  least expensive path.
			 */
			unsigned long	span;
			unsigned long	epos, bpos, NextPrevPos, MatchPos;
			t_decision_node *decision_node_ptr;
			t_decision_node *context_decision_node = encoder->decision_node;
			t_match_pos *matchpos_table = encoder->matchpos_table;
			long		iterations;

			/*
			 * Points to the end of the area covered by this match; the span
			 * will continually be extended whenever we find more matches
			 * later on.  It will stop being extended when we reach a spot
			 * where there are no matches, which is when we decide which
			 * path to take to output the matches.
			 */
			span = bufpos + EncMatchLength;

			/*
			 * The furthest position into which we will do our lookahead parsing 
			 */
			epos = bufpos + LOOK;

			/*
			 * Temporary bufpos variable
			 */
			bpos = bufpos;

			/* 
			 * Calculate the path to the next character if we output
			 * an unmatched symbol.
			 */

			/* bits required to get here */
			context_decision_node[1].numbits = CHAR_EST(encoder->window[bufpos]);
				
			/* where we came from */
			context_decision_node[1].path    = bufpos;

			/* bits required to get here */
			context_decision_node[2].numbits = CHAR_EST(encoder->window[bufpos+1]) + context_decision_node[1].numbits;
				
			/* where we came from */
			context_decision_node[2].path    = bufpos+1;

			/*
			 * For the match found, estimate the cost of encoding the match
			 * for each possible match length, shortest offset combination.
			 *
			 * The cost, path and offset is stored at bufpos + Length.  
			 */
			for (i = MIN_MATCH; i <= (unsigned long) EncMatchLength; i++)
			{
				/*
				 * Get estimation of match cost given match length = i,
				 * match position = matchpos_table[i], and store
				 * the result in numbits[i]
				 */
				MATCH_EST(i, matchpos_table[i], context_decision_node[i].numbits);

				/*
				 * Where we came from 
				 */
				context_decision_node[i].path = bufpos;

				/*
				 * Associated match position with this path
				 */
				context_decision_node[i].link = matchpos_table[i];
			}

			/*
			 * Set bit counter to zero at the start 
			 */
			context_decision_node[0].numbits = 0;

			decision_node_ptr = &context_decision_node[-(long) bpos];

			while (1)
			{
				numbits_t est, cum_numbits;

				bufpos++;
	
				/* 
				 *  Set the proper repeated offset locations depending on the
				 *  shortest path to the location prior to searching for a 
				 *  match.
				 */

				/*
				 * The following is one of the two possible break points from
				 * the inner encoding loop.  This break will exit the loop if 
				 * a point is reached that no match can incorporate; i.e. a
				 * character that does not match back to anything is a point 
				 * where all possible paths will converge and the longest one
				 * can be chosen.
				 */
				if (span == bufpos)
					break;
					
				/*
				 * Search for matches at bufpos 
				 */
				EncMatchLength = optimal_find_match(context, bufpos); 

				/* 
				 * Make sure that the match does not exceed the stop point
				 */
				if ((unsigned long) EncMatchLength + bufpos > bufpos_end)
				{
					EncMatchLength = bufpos_end - bufpos; 
					
					if (EncMatchLength < MIN_MATCH)
						EncMatchLength = 0;
				}

				/*
				 * If the match is very long or it exceeds epos (either 
				 * surpassing the LOOK area, or exceeding past the end of the
				 * input buffer), then break the loop and output the path.
				 */
				if (EncMatchLength > FAST_DECISION_THRESHOLD || 
					bufpos + (unsigned long) EncMatchLength >= epos)
				{
					MatchPos = matchpos_table[EncMatchLength];

					decision_node_ptr[bufpos+EncMatchLength].link = MatchPos;
					decision_node_ptr[bufpos+EncMatchLength].path = bufpos;

					/*
					 * Quickly insert data into the search tree without
					 * returning match positions/lengths
					 */
#ifndef INSERT_NEAR_LONG_MATCHES
					if (MatchPos == 3 && EncMatchLength > 16)
					{
						/*
						 * If we found a match 1 character away and it's
						 * length 16 or more, it's probably a string of
						 * zeroes, so don't insert that into the search
						 * engine, since doing so can slow things down
						 * significantly!
						 */
						optimal_insert(
							context,
                               bufpos + 1,
                               bufpos - WINDOW_SIZE + 2
                           );
					}
					else
#endif
					{
						for (i = 1; i < (unsigned long) EncMatchLength; i++)
							optimal_insert(
								context,
                                   bufpos + i,
                                   bufpos + i - WINDOW_SIZE + 4
                                );
					}

					bufpos += EncMatchLength;
					break;
				}


				/*
				 * The following code will extend the area spanned by the 
				 * set of matches if the current match surpasses the end of
				 * the span.  A match of length two that is far is not 
				 * accepted, since it would normally be encoded as characters,
				 * thus allowing the paths to converge.
				 */
				if (EncMatchLength >= 3)
				{
					if (span < (unsigned long) (bufpos + EncMatchLength))
					{
						long end;
						long i;

						end = min(bufpos+EncMatchLength-bpos, LOOK-1);

						/*
						 * These new positions are undefined for now, since we haven't
						 * gone there yet, so put in the costliest value
						 */
						for (i = span-bpos+1; i <= end; i++)
							context_decision_node[i].numbits = (numbits_t) -1;

						span = bufpos + EncMatchLength;
					}
				}

				/*
				 *  The following code will iterate through all combinations
				 *  of match lengths for the current match.  It will estimate
				 *  the cost of the path from the beginning of LOOK to 
				 *  bufpos and to every locations spanned by the current 
				 *  match.  If the path through bufpos with the found matches
				 *  is estimated to take fewer number of bits to encode than
				 *  the previously found match, then the path to the location
				 *  is altered.
				 *
				 *  The code relies on accurate estimation of the cost of 
				 *  encoding a character or a match.  Furthermore, it requires
				 *  a search engine that will store the smallest match offset
				 *  of each possible match length.
				 *
				 *  A match of length one is simply treated as an unmatched 
				 *  character.
				 */

				/* 
				 *  Get the estimated number of bits required to encode the 
				 *  path leading up to bufpos.
				 */
				cum_numbits = decision_node_ptr[bufpos].numbits;

				/*
				 *  Calculate the estimated cost of outputting the path through
				 *  bufpos and outputting the next character as an unmatched byte
				 */
				est = cum_numbits + CHAR_EST(encoder->window[bufpos]);

				/*
				 *  Check if it is more efficient to encode the next character
				 *  as an unmatched character rather than the previously found 
				 *  match.  If so, then update the cheapest path to bufpos + 1.
				 *
				 *  What happens if est == numbits[bufpos-bpos+1]; i.e. it
				 *  works out as well to output a character as to output a
				 *  match?  It's a tough call; however, we will push the
				 *  encoder to use matches where possible.
				 */
				if (est < decision_node_ptr[bufpos+1].numbits)
				{
					decision_node_ptr[bufpos+1].numbits = est;
					decision_node_ptr[bufpos+1].path    = bufpos;
				}

				/*
				 *	Now, iterate through the remaining match lengths and 
				 *  compare the new path to the existing.  Change the path
				 *  if it is found to be more cost effective to go through
				 *  bufpos.
				 */
				for (i = MIN_MATCH; i <= (unsigned long) EncMatchLength; i++)
				{
					MATCH_EST(i, matchpos_table[i], est);
					est += cum_numbits;

					/*
					 * If est == numbits[bufpos+i] we want to leave things
					 * alone, since this will tend to force the matches
					 * to be smaller in size, which is beneficial for most
					 * data.
					 */
					if (est < decision_node_ptr[bufpos+i].numbits)
					{
						decision_node_ptr[bufpos+i].numbits	= est;
						decision_node_ptr[bufpos+i].path	= bufpos;
						decision_node_ptr[bufpos+i].link	= matchpos_table[i];
					}
				}
			} /* continue to loop through span of matches */

			/*
			 *  Here bufpos == span, ie. a non-matchable character found.  The
			 *  following code will output the path properly.
			 */

			/*
			 *  Unfortunately the path is stored in reverse; how to get from
			 *  where we are now, to get back to where it all started.
			 *
			 *  Traverse the path back to the original starting position
			 *  of the LOOK span.  Invert the path pointers in order to be
			 *  able to traverse back to the current position from the start.
			 */

			/*
			 * Count the number of iterations we did, so when we go forwards
			 * we'll do the same amount
			 */
			iterations = 0;

			NextPrevPos = decision_node_ptr[bufpos].path;

   			do
			{
				unsigned long	PrevPos;

      			PrevPos = NextPrevPos;

   				NextPrevPos = decision_node_ptr[PrevPos].path;
   				decision_node_ptr[PrevPos].path = bufpos;

   				bufpos = PrevPos;
   				iterations++;
			} while (bufpos != bpos);

			/*
			 * Traverse from the beginning of the LOOK span to the end of 
			 * the span along the stored path, outputting matches and 
			 * characters appropriately.
			 */
			do
			{
   				if (decision_node_ptr[bufpos].path > bufpos+1)
   				{
					/*
					 * Path skips over more than 1 character; therefore it's a match
					 */
					RECORD_MATCH(
						decision_node_ptr[bufpos].path - bufpos,
						decision_node_ptr[ decision_node_ptr[bufpos].path ].link
					);

					bufpos = decision_node_ptr[bufpos].path;
				}
   				else
   				{
					/*
					 * Path goes to the next character; therefore it's a symbol
					 */
					RECORD_CHAR(encoder->window[bufpos]);
					bufpos++;
				}
			} while (--iterations != 0);
		}
		else  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
		{
			/*
			 *  This code reflects a speed optimization that will always take
			 *  a match of length >= FAST_DECISION_THRESHOLD characters.
			 */

			/*
			 * The position associated with the match we found
			 */
			MatchPos = encoder->matchpos_table[EncMatchLength];

			/*
			 * Quickly insert match substrings into search tree
			 * (don't look for new matches; just insert the strings)
			 */
#ifndef INSERT_NEAR_LONG_MATCHES
			if (MatchPos == 3 && EncMatchLength > 16)
			{
				optimal_insert(
					context,
                       bufpos + 1,
                       bufpos - WINDOW_SIZE + 2 
                   );
			}
			else
#endif
			{
				for (i = 1; i < (unsigned long) EncMatchLength; i++)
					optimal_insert(
						context,
                           bufpos + i,
                           bufpos + i - WINDOW_SIZE + 1
                        );
			}

			/*
			 * Advance our position in the window
			 */
			bufpos += EncMatchLength;

			/*
			 * Output the match
			 */
			RECORD_MATCH(EncMatchLength, MatchPos);

		}  /* EncMatchLength >= FAST_DECISION_THRESHOLD */
	} /* end while ... bufpos <= bufpos_end */

	if (LITERAL_BUFFERS_FULL())
	{
		_ASSERT(context->outputting_block_num_literals <= OPT_ENCODER_MAX_ITEMS);

		// flush our recording matches bit buffer
        FLUSH_RECORDING_BITBUF();

        // BUGBUG Should check for failure result.  Luckily the only failure condition is
        // that the tree didn't fit into 500 bytes, which is basically impossible anyway.
		(void) OptimalEncoderOutputBlock(context);

		// fix estimates for optimal parser
		fixOptimalEstimates(context);

		encoder->next_tree_update = FIRST_TREE_UPDATE;

		// did we output the whole block?
		if (context->state == STATE_NORMAL)
		{
			// reset literal recording
        	recording_bufptr = encoder->recording_bufptr;
            recording_bitbuf = encoder->recording_bitbuf;
            recording_bitcount = encoder->recording_bitcount;
			goto after_output_block;
		}
	}

	// save recording state
	encoder->recording_bufptr = recording_bufptr;
    encoder->recording_bitbuf = recording_bitbuf;
    encoder->recording_bitcount = recording_bitcount;

    context->bufpos	= bufpos;

	VERIFY_HASHES(bufpos);
	removeNodes(context);
	VERIFY_HASHES(bufpos);

    if (context->bufpos == 2*WINDOW_SIZE)
        OptimalEncoderMoveWindows(context);
}


//
// Move the search windows when bufpos reaches 2*WINDOW_SIZE
//
static void OptimalEncoderMoveWindows(t_encoder_context *context)
{
	long	delta;
	int		i;
    t_optimal_encoder *encoder = context->optimal_encoder;
	t_search_node *search_tree_root = encoder->search_tree_root;
	t_search_node *left = encoder->search_left;
	t_search_node *right = encoder->search_right;

   	_ASSERT(context->bufpos == 2*WINDOW_SIZE);
 
	VERIFY_HASHES(context->bufpos);

	delta = context->bufpos - WINDOW_SIZE;

	memcpy(&encoder->window[0], &encoder->window[context->bufpos - WINDOW_SIZE], WINDOW_SIZE);

	for (i = 0; i < NUM_DIRECT_LOOKUP_TABLE_ELEMENTS; i++)
	{
		long val = ((long) search_tree_root[i]) - delta;
	
		if (val <= 0)
			search_tree_root[i] = (t_search_node) 0;
		else
			search_tree_root[i] = (t_search_node) val;

		_ASSERT(search_tree_root[i] < WINDOW_SIZE);
	}

	memcpy(&left[0], &left[context->bufpos - WINDOW_SIZE], sizeof(t_search_node)*WINDOW_SIZE);
	memcpy(&right[0], &right[context->bufpos - WINDOW_SIZE], sizeof(t_search_node)*WINDOW_SIZE);

	for (i = 0; i < WINDOW_SIZE; i++)
	{
		long val;
			
		// left
		val = ((long) left[i]) - delta;

		if (val <= 0)
			left[i] = (t_search_node) 0;
		else
			left[i] = (t_search_node) val;

		// right
		val = ((long) right[i]) - delta;

		if (val <= 0)
			right[i] = (t_search_node) 0;
		else
			right[i] = (t_search_node) val;
	}

#ifdef _DEBUG
	// force any search table references to be invalid
	memset(&encoder->window[WINDOW_SIZE], 0, WINDOW_SIZE);
#endif

	context->bufpos = WINDOW_SIZE;
	context->bufpos_end = context->bufpos;

	VERIFY_HASHES(context->bufpos);
}


//
// Calculate the frequencies of all literal and distance codes, for tree-making, then
// make the trees
//
static void calculateUpdatedEstimates(t_encoder_context *context)
{
    USHORT code[MAX_LITERAL_TREE_ELEMENTS];
    t_optimal_encoder *encoder = context->optimal_encoder;

	// create the trees, we're interested only in len[], not code[]
    // BUGBUG perf optimisation: make makeTree() not call MakeCode() in this situation
	makeTree(
		MAX_LITERAL_TREE_ELEMENTS, 
		15, 
		encoder->literal_tree_freq, 
		code,
		encoder->literal_tree_len
	);

	makeTree(
		MAX_DIST_TREE_ELEMENTS, 
		15, 
		encoder->dist_tree_freq, 
		code,
		encoder->dist_tree_len
	);
}


//
// Zero the running frequency counts
//
// Also set freq[END_OF_BLOCK_CODE] = 1
//
void OptimalEncoderZeroFrequencyCounts(t_optimal_encoder *encoder)
{
    _ASSERT(encoder != NULL);

    memset(encoder->literal_tree_freq, 0, sizeof(encoder->literal_tree_freq));
    memset(encoder->dist_tree_freq, 0, sizeof(encoder->dist_tree_freq));
    encoder->literal_tree_freq[END_OF_BLOCK_CODE] = 1;
}


void OptimalEncoderReset(t_encoder_context *context)
{
    t_optimal_encoder *encoder = context->optimal_encoder;

    _ASSERT(encoder != NULL);

	encoder->recording_bitbuf		= 0;
	encoder->recording_bitcount     = 0;
    encoder->recording_bufptr       = encoder->lit_dist_buffer;

    context->window_size            = WINDOW_SIZE;
	context->bufpos		            = context->window_size;
	context->bufpos_end             = context->bufpos;

	DeflateInitRecordingTables(
	    encoder->recording_literal_tree_len,
    	encoder->recording_literal_tree_code, 
	    encoder->recording_dist_tree_len,
    	encoder->recording_dist_tree_code
    );

	// clear the search table
	memset(
		encoder->search_tree_root,
		0, 
		sizeof(encoder->search_tree_root)
	);

	encoder->next_tree_update = FIRST_TREE_UPDATE;

	initOptimalEstimates(context);
    OptimalEncoderZeroFrequencyCounts(encoder);
}


BOOL OptimalEncoderInit(t_encoder_context *context)
{
	context->optimal_encoder = (t_optimal_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_optimal_encoder));

    if (context->optimal_encoder == NULL)
        return FALSE;

    OptimalEncoderReset(context);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\optenc.h ===
/*
 * optenc.h
 *
 * Defines for the optimal encoder
 */


// lookahead
#define LOOK			1024

// don't-care threshold for tree structure
#define BREAK_LENGTH	50

#define NUM_DIRECT_LOOKUP_TABLE_ELEMENTS    65536

// see stdenc.h for comments on these values
#define OPT_ENCODER_LIT_DIST_BUFFER_SIZE    65536
#define OPT_ENCODER_MAX_ITEMS				65534


//
// For the optimal parser
//
typedef unsigned long numbits_t;

typedef struct
{
	ULONG		link;
	ULONG		path;
	numbits_t	numbits;
} t_decision_node;


//
// Optimal encoder context
//
typedef struct optimal_encoder
{
	BYTE 					window[2*WINDOW_SIZE + MAX_MATCH + 4];
	t_decision_node 		decision_node[LOOK+MAX_MATCH+16];
	t_match_pos				matchpos_table[MAX_MATCH+1];
	t_search_node			search_left[2*WINDOW_SIZE];
	t_search_node			search_right[2*WINDOW_SIZE];
	t_search_node			search_tree_root[65536];

	// recording buffer for recording literals and distances
	BYTE					lit_dist_buffer[OPT_ENCODER_LIT_DIST_BUFFER_SIZE];
	unsigned long			recording_bitbuf;
	unsigned long			recording_bitcount;
    BYTE *                  recording_bufptr;

	unsigned int			next_tree_update;

	short					recording_dist_tree_table[REC_DISTANCES_DECODING_TABLE_SIZE];
	short					recording_dist_tree_left[2*MAX_DIST_TREE_ELEMENTS];
	short					recording_dist_tree_right[2*MAX_DIST_TREE_ELEMENTS];
    BYTE					recording_dist_tree_len[MAX_DIST_TREE_ELEMENTS];
    USHORT                  recording_dist_tree_code[MAX_DIST_TREE_ELEMENTS];

	short					recording_literal_tree_table[REC_LITERALS_DECODING_TABLE_SIZE];
	short					recording_literal_tree_left[2*MAX_LITERAL_TREE_ELEMENTS];
	short					recording_literal_tree_right[2*MAX_LITERAL_TREE_ELEMENTS];
	BYTE					recording_literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  recording_literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];

	// literal trees
    unsigned short          literal_tree_freq[2*MAX_LITERAL_TREE_ELEMENTS];
	unsigned short			literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];
	BYTE					literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	
	// dist trees
    unsigned short          dist_tree_freq[2*MAX_DIST_TREE_ELEMENTS];
	unsigned short			dist_tree_code[MAX_DIST_TREE_ELEMENTS];
	BYTE					dist_tree_len[MAX_DIST_TREE_ELEMENTS];

} t_optimal_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\output.c ===
/*
 * output.c
 *
 * General outputting routines
 */
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>


//
// Output an element from the pre-tree
//
#define OUTPUT_PRETREE_ELEMENT(element) \
	_ASSERT(pretree_len[element] != 0); \
	outputBits(context, pretree_len[element], pretree_code[element]);


//
// Output the tree structure for a dynamic block
//
void outputTreeStructure(t_encoder_context *context, const BYTE *literal_tree_len, const BYTE *dist_tree_len)
{
	int		hdist, hlit, combined_tree_elements, i, pass;
	USHORT	pretree_freq[NUM_PRETREE_ELEMENTS*2];
	USHORT	pretree_code[NUM_PRETREE_ELEMENTS];
	byte	pretree_len[NUM_PRETREE_ELEMENTS];

	//
	// combined literal + distance length code array for outputting the trees
	// in compressed form
	//
	// +3 is so we can overflow the array when performing run length encoding
	// (dummy values are inserted at the end so that run length encoding fails
	// before falling off the end of the array)
	//
	BYTE	lens[MAX_LITERAL_TREE_ELEMENTS + MAX_DIST_TREE_ELEMENTS + 3];

	//
	// Calculate HDIST
	//
	for (hdist = MAX_DIST_TREE_ELEMENTS - 1; hdist >= 1; hdist--)
	{
		if (dist_tree_len[hdist] != 0)
			break;
	}

	hdist++;

	//
	// Calculate HLIT
	//
	for (hlit = MAX_LITERAL_TREE_ELEMENTS - 1; hlit >= 257; hlit--)
	{
		if (literal_tree_len[hlit] != 0)
			break;
	}

	hlit++;

	//
	// Now initialise the array to have all of the hlit and hdist codes
	// in it
	//
	combined_tree_elements = hdist + hlit;

	memcpy(lens, literal_tree_len, hlit);
	memcpy(&lens[hlit], dist_tree_len, hdist);

	//
	// Stick in some dummy values at the end so that we don't overflow the 
	// array when comparing
	//
	for (i = combined_tree_elements; i < sizeof(lens); i++)
		lens[i] = -1;

	for (i = 0; i < NUM_PRETREE_ELEMENTS; i++)
		pretree_freq[i] = 0;

	//
	// Output the bitlengths in compressed (run length encoded) form.
	//
	// Make two passes; on the first pass count the various codes, create
	// the tree and output it, on the second pass output the codes using
	// the tree.
	//
	for (pass = 0; pass < 2; pass++)
	{
		int		cur_element;

		// are we outputting during this pass?
		BOOL	outputting = (pass == 1); 

		cur_element = 0;

		while (cur_element < combined_tree_elements)
		{
			int curlen = lens[cur_element];
			int run_length;

			//
			// See how many consecutive elements have the same value
			//
			// This won't run off the end of the array; it will hit the -1's
			// we stored there
			//
			for (run_length = cur_element+1; lens[run_length] == curlen; run_length++)
				;

			run_length -= cur_element;

			//
			// For non-zero codes need 4 identical in a row (original code
			// plus 3 repeats).  We decrement the run_length by one if the
			// code is not zero, since we don't count the first (original)
			// code in this case.
			//
			// For zero codes, need 3 zeroes in a row.
			//
			if (curlen != 0)
				run_length--;

			if (run_length < 3)
			{
				if (outputting)
				{
					OUTPUT_PRETREE_ELEMENT(curlen);
				}
				else
					pretree_freq[curlen]++;

				cur_element++;
			}
			else 
			{
				//
				// Elements with zero values are encoded specially
				//
				if (curlen == 0)
				{
					//
					// Do we use code 17 (3-10 repeated zeroes) or 
					// code 18 (11-138 repeated zeroes)?
					//
					if (run_length <= 10)
					{
						// code 17
						if (outputting)
						{
							OUTPUT_PRETREE_ELEMENT(17);
							outputBits(context, 3, run_length - 3);
						}
						else
						{
							pretree_freq[17]++;
						}
					}
					else
					{
						// code 18
						if (run_length > 138)
							run_length = 138;

						if (outputting)
						{
							OUTPUT_PRETREE_ELEMENT(18);
							outputBits(context, 7, run_length - 11);
						}
						else
						{
							pretree_freq[18]++;
						}
					}  

					cur_element += run_length;
				}
				else
				{
					//
					// Number of lengths actually encoded.  This may end up 
					// being less than run_length if we have a run length of
					// 7 (6 + 1 [which cannot be encoded with a code 16])
					//
					int run_length_encoded = 0;

					// curlen != 0

					// can output 3...6 repeats of a non-zero code, so split
					// longer runs into short ones (if possible)

					// remember to output the code itself first!
					if (outputting)
					{
						OUTPUT_PRETREE_ELEMENT(curlen);

						while (run_length >= 3)
						{
							int this_run = (run_length <= 6) ? run_length : 6;

							OUTPUT_PRETREE_ELEMENT(16);
							outputBits(context, 2, this_run - 3);

							run_length_encoded += this_run;
							run_length -= this_run;
						}
					}
					else
					{
						pretree_freq[curlen]++;

						while (run_length >= 3)
						{
							int this_run = (run_length <= 6) ? run_length : 6;

							pretree_freq[16]++;

							run_length_encoded += this_run;
							run_length -= this_run;
						}
					}

					// +1 for the original code itself
					cur_element += (run_length_encoded+1);
				}
			}
		}

		//
		// If this is the first pass, create the pretree from the
		// frequency data and output it, as well as the values of
		// HLIT, HDIST, HDCLEN (# pretree codes used)
		//
		if (pass == 0)
		{
			int hclen, i;

			makeTree(
				NUM_PRETREE_ELEMENTS,
				7, 
				pretree_freq, 
				pretree_code,
				pretree_len
			);

			//
			// Calculate HCLEN
			//
			for (hclen = NUM_PRETREE_ELEMENTS-1; hclen >= 4; hclen--)
			{
				if (pretree_len[ g_CodeOrder[hclen] ] != 0)
					break;
			}
			
			hclen++;

			//
			// Dynamic block header
			//
			outputBits(context, 5, hlit - 257);
			outputBits(context, 5, hdist - 1);
			outputBits(context, 4, hclen - 4);

			for (i = 0; i < hclen; i++)
			{
				outputBits(context, 3, pretree_len[g_CodeOrder[i]]);
			}
		}
	}
}


//
// bitwise i/o
//
void flushOutputBitBuffer(t_encoder_context *context)
{
	if (context->bitcount > 0)
	{
		int prev_bitcount = context->bitcount;
			
		outputBits(context, 16 - context->bitcount, 0);

		// backtrack if we have to; ZIP is byte aligned, not 16-bit word aligned
		if (prev_bitcount <= 8)
			context->output_curpos--;
	}
}


//
// Does not check for output overflow, so make sure to call checkOutputOverflow()
// often enough!
//
void outputBits(t_encoder_context *context, int n, int x)
{
	_ASSERT(context->output_curpos < context->output_endpos-1);
    _ASSERT(n > 0 && n <= 16);

	context->bitbuf |= (x << context->bitcount);
	context->bitcount += n;

	if (context->bitcount >= 16)                     
	{   
		*context->output_curpos++ = (BYTE) context->bitbuf;
		*context->output_curpos++ = (BYTE) (context->bitbuf >> 8);

		context->bitbuf >>= 16;
		context->bitcount -= 16;                         
	} 
}


// initialise the bit buffer
void InitBitBuffer(t_encoder_context *context)
{
	context->bitbuf		= 0;
	context->bitcount	= 0;
}


void OutputBlock(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL);
    
    // we never call OutputBlock() with the fast encoder
    _ASSERT(context->fast_encoder == NULL);

    if (context->std_encoder != NULL)
	    StdEncoderOutputBlock(context);
    else if (context->optimal_encoder != NULL)
        OptimalEncoderOutputBlock(context);
}


void FlushRecordingBuffer(t_encoder_context *context)
{
    _ASSERT(context->std_encoder != NULL || context->optimal_encoder != NULL);
    _ASSERT(context->fast_encoder == NULL); // fast encoder does not record

    if (context->std_encoder != NULL)
    {
        *context->std_encoder->recording_bufptr++ = (BYTE) context->std_encoder->recording_bitbuf; 
		*context->std_encoder->recording_bufptr++ = (BYTE) (context->std_encoder->recording_bitbuf >> 8); 
    }
    else if (context->optimal_encoder != NULL)
    {
        *context->optimal_encoder->recording_bufptr++ = (BYTE) context->optimal_encoder->recording_bitbuf; 
	    *context->optimal_encoder->recording_bufptr++ = (BYTE) (context->optimal_encoder->recording_bitbuf >> 8); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\stddebug.c ===
/*
 * stddebug.c
 *
 * Debugging stubs for std encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#ifdef FULL_DEBUG
// verify all hash chains
void StdEncoderVerifyHashes(t_encoder_context *context, long bufpos)
{
	int i;
	const t_search_node *lookup = context->std_encoder->lookup;
	const t_search_node *prev = context->std_encoder->prev;
	const BYTE *window = context->std_encoder->window;

	for (i = 0; i < STD_ENCODER_HASH_TABLE_SIZE; i++)
	{
		t_search_node where = lookup[i];
		t_search_node next_where;

		while (where != 0 && bufpos - where < WINDOW_SIZE)
		{
			int hash = STD_ENCODER_RECALCULATE_HASH(where);

			_ASSERT(hash == i);

			next_where = prev[where & WINDOW_MASK];

			if (bufpos - next_where >= WINDOW_SIZE)
				break;

			_ASSERT(next_where < where);

			where = next_where;
		} 
	}
}


// verify that a particular hash chain is correct
void StdEncoderVerifyHashChain(t_encoder_context *context, long bufpos, int chain_number)
{
	const t_search_node *lookup = context->std_encoder->lookup;
	const t_search_node *prev = context->std_encoder->prev;
	BYTE *window = context->std_encoder->window;
	t_search_node where;
	t_search_node next_where;
	int print = 0;

top:
	where = lookup[chain_number];

//	if (print)
//		printf("Verify chain %d\n", chain_number);

	while (where != 0 && bufpos - where < WINDOW_SIZE)
	{
		int hash = STD_ENCODER_RECALCULATE_HASH(where);
        BYTE *window = context->std_encoder->window;

//		if (print)
//			printf("   loc %d: char = %3d %3d %3d\n", where, window[where], window[where+1], window[where+2]);

		if (hash != chain_number && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(hash == chain_number);

		next_where = prev[where & WINDOW_MASK];

		if (bufpos - next_where >= WINDOW_SIZE)
			break;

		if (next_where >= where && print == 0)
		{
			print = 1;
			goto top;
		}

		_ASSERT(next_where < where);

		where = next_where;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\daytona\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\optfmtch.c ===
/*
 * optfmtch.c
 *
 * Match finder for the optimal parser
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


#define VERIFY_SEARCH_CODE(routine_name) \
{ \
	int debug_search; \
	for (debug_search = 0; debug_search < clen; debug_search++) \
	{ \
		if (window[ptr+debug_search] != window[BufPos+debug_search]) \
		{ \
			_RPT2( \
				_CRT_WARN, \
				routine_name \
				" char mismatch @%3d (clen=%d)\n", \
				debug_search, clen); \
			\
			_RPT3( \
				_CRT_WARN, \
				" ptr=%8d, bufpos=%8d, end_pos=%8d\n\n", \
				ptr, BufPos, end_pos); \
			_ASSERT(0); \
		} \
	} \
}


#define VERIFY_MULTI_TREE_SEARCH_CODE(routine_name) \
	_ASSERT(window[BufPos] == window[ptr]); \
	_ASSERT(window[BufPos+1] == window[ptr+1]);


/*
 * Finds the closest matches of all possible lengths, MIN_MATCH <= x <= MAX_MATCH,
 * at position BufPos.
 *
 * The positions of each match location are stored in context->matchpos_table[]
 *
 * Returns the longest such match length found, or zero if no matches found.
 */
int optimal_find_match(t_encoder_context *context, long BufPos)
{
	ULONG		ptr;
	ULONG       a, b;
	t_search_node *small_ptr, *big_ptr;
	t_search_node *left = context->optimal_encoder->search_left;
	t_search_node *right = context->optimal_encoder->search_right;
	t_match_pos *matchpos_table = context->optimal_encoder->matchpos_table;
	BYTE *window = context->optimal_encoder->window;
	ULONG       end_pos;
	int         val; /* must be signed */
	int         clen;
	int         same;
	int         match_length;
	int         small_len, big_len;
	USHORT      tree_to_use;

	/*
	 * Retrieve root node of tree to search, and insert current node at
	 * the root.
	 */
	tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);
	
	ptr        = context->optimal_encoder->search_tree_root[tree_to_use];
	context->optimal_encoder->search_tree_root[tree_to_use] = (t_search_node) BufPos;

	/*
	 * end_pos is the furthest location back we will search for matches 
	 *
	 * Remember that our window size is reduced by 3 bytes because of
	 * our repeated offset codes.
	 *
	 * Since BufPos starts at WINDOW_SIZE when compression begins,
	 * end_pos will never become negative.  
	 */
	end_pos = BufPos - (WINDOW_SIZE-4);

	/*
	 * Root node is either NULL, or points to a really distant position.
	 */
	if (ptr <= end_pos)
	{
		left[BufPos] = right[BufPos] = 0;
		return 0;
	}

	/*
	 * confirmed length (no need to check the first clen chars in a search)
	 *
	 * note: clen is always equal to min(small_len, big_len)
	 */
	clen            = 2;

	/*
	 * current best match length
	 */
	match_length    = 2;

	/*
	 * longest match which is < our string
	 */
	small_len       = 2;

	/*
	 * longest match which is > our string
	 */
	big_len         = 2;

#ifdef _DEBUG
	VERIFY_MULTI_TREE_SEARCH_CODE("binary_search_findmatch()");
#endif

	/*
	 * pointers to nodes to check
	 */
	small_ptr             = &left[BufPos];
	big_ptr               = &right[BufPos];

	do
	{
		/* compare bytes at current node */
		same = clen;

#ifdef _DEBUG
		VERIFY_SEARCH_CODE("optimal_findmatch()")
#endif

		/* don't need to check first clen characters */
		a    = ptr + clen;
		b    = BufPos + clen;

		while ((val = ((int) window[a++]) - ((int) window[b++])) == 0)
		{
			/* don't exceed MAX_MATCH */
			if (++same >= MAX_MATCH)
				goto long_match;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same > match_length)
				{
long_match:
					do
					{
						matchpos_table[++match_length] = BufPos-ptr-1;
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
						goto end_bsearch;
					}
				}

				big_len = same;
				clen = min(small_len, big_len);
			}

			*big_ptr = (t_search_node) ptr;
			big_ptr  = &left[ptr];
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same > match_length)
				{
					do
					{
						matchpos_table[++match_length] = BufPos-ptr-1;
					} while (match_length < same);

					if (same >= BREAK_LENGTH)
					{
						*small_ptr = left[ptr];
						*big_ptr   = right[ptr];
						goto end_bsearch;
					}
				}

				small_len = same;
				clen = min(small_len, big_len);
			}
		
			*small_ptr = (t_search_node) ptr;
			small_ptr  = &right[ptr];
			ptr        = *small_ptr;
		}
	} while (ptr > end_pos); /* while we don't go too far backwards */

	*small_ptr = 0;
	*big_ptr   = 0;


end_bsearch:

	/*
	 * If we have multiple search trees, we are already guaranteed
	 * a minimum match length of 2 when we reach here.
	 *
	 * If we only have one tree, then we're not guaranteed anything.
	 */
    if (match_length < MIN_MATCH)
        return 0;
    else
	    return (long) match_length;
}


/*
 * Inserts the string at the current BufPos into the tree.
 *
 * Does not record all the best match lengths or otherwise attempt
 * to search for matches
 *
 * Similar to the above function.
 */
void optimal_insert(t_encoder_context *context, long BufPos, long end_pos)
{
	long        ptr;
	ULONG       a,b;
	t_search_node *small_ptr, *big_ptr;
	t_search_node *left = context->optimal_encoder->search_left;
	t_search_node *right = context->optimal_encoder->search_right;
	BYTE *window = context->optimal_encoder->window;
	int         val;
	int         small_len, big_len;
	int         same;
	int         clen;
	USHORT      tree_to_use;

	tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);
	ptr        = context->optimal_encoder->search_tree_root[tree_to_use];
	context->optimal_encoder->search_tree_root[tree_to_use] = (t_search_node) BufPos;

	if (ptr <= end_pos)
	{
		left[BufPos] = right[BufPos] = 0;
		return;
	}

	clen            = 2;
	small_len       = 2;
	big_len         = 2;

#ifdef _DEBUG
	VERIFY_MULTI_TREE_SEARCH_CODE("quick_insert_bsearch_findmatch()");
#endif

	small_ptr       = &left[BufPos];
	big_ptr         = &right[BufPos];

	do
	{
		same = clen;

		a    = ptr+clen;
		b    = BufPos+clen;

#ifdef _DEBUG
		VERIFY_SEARCH_CODE("quick_insert_bsearch_findmatch()")
#endif

		while ((val = ((int) window[a++]) - ((int) window[b++])) == 0)
		{
			/*
			 * Here we break on BREAK_LENGTH, not MAX_MATCH
			 */
			if (++same >= BREAK_LENGTH) 
				break;
		}

		if (val < 0)
		{
			if (same > big_len)
			{
				if (same >= BREAK_LENGTH)
				{
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
					return;
				}

				big_len = same;
				clen = min(small_len, big_len);
			}
			
			*big_ptr = (t_search_node) ptr;
			big_ptr  = &left[ptr];
			ptr      = *big_ptr;
		}
		else
		{
			if (same > small_len)
			{
				if (same >= BREAK_LENGTH)
				{
					*small_ptr = left[ptr];
					*big_ptr = right[ptr];
					return;
				}

				small_len = same;
				clen = min(small_len, big_len);
			}

			*small_ptr = (t_search_node) ptr;
			small_ptr  = &right[ptr];
			ptr        = *small_ptr;
		}
   } while (ptr > end_pos);

	*small_ptr = 0;
	*big_ptr   = 0;
}


/*
 * Remove a node from the search tree; this is ONLY done for the last
 * BREAK_LENGTH symbols (see optenc.c).  This is because we will have
 * inserted strings that contain undefined data (e.g. we're at the 4th
 * last byte from the file and binary_search_findmatch() a string into
 * the tree - everything from the 4th symbol onwards is invalid, and
 * would cause problems if it remained in the tree, so we have to
 * remove it).
 */
void optimal_remove_node(t_encoder_context *context, long BufPos, ULONG end_pos)
{
	ULONG   ptr;
	ULONG   left_node_pos;
	ULONG   right_node_pos;
	USHORT  tree_to_use;
	t_search_node *link;
	t_search_node *left = context->optimal_encoder->search_left;
	t_search_node *right = context->optimal_encoder->search_right;
	BYTE *window = context->optimal_encoder->window;

	/*
	 * The root node of tree_to_use should equal BufPos, since that is
	 * the most recent insertion into that tree - but if we never
	 * inserted this string (because it was a near match or a long
	 * string of zeroes), then we can't remove it.
	 */
	tree_to_use = *((USHORT UNALIGNED *) &window[BufPos]);


	/*
	 * If we never inserted this string, do not attempt to remove it
	 */

	if (context->optimal_encoder->search_tree_root[tree_to_use] != BufPos)
		return;

	link = &context->optimal_encoder->search_tree_root[tree_to_use];

	/*
	 * If the last occurence was too far away
	 */
	if (*link <= end_pos)
	{
		*link = 0;
		left[BufPos] = right[BufPos] = 0;
		return;
	}

	/*
	 * Most recent location of these chars
	 */
	ptr             = BufPos;

	/*
	 * Most recent location of a string which is "less than" it
	 */
	left_node_pos   = left[ptr];

	if (left_node_pos <= end_pos)
		left_node_pos = left[ptr] = 0;

	/*
	 * Most recent location of a string which is "greater than" it
	 */
	right_node_pos  = right[ptr];

	if (right_node_pos <= end_pos)
		right_node_pos = right[ptr] = 0;

	while (1)
	{
		/*
		 * If left node position is greater than right node position
		 * then follow the left node, since that is the more recent
		 * insertion into the tree.  Otherwise follow the right node.
		 */
		if (left_node_pos > right_node_pos)
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (left_node_pos <= end_pos)
				left_node_pos = 0;

			ptr = *link = (t_search_node) left_node_pos;

			if (!ptr)
				break;

			left_node_pos   = right[ptr];
			link            = &right[ptr];
		}
		else
		{
			/*
			 * If it's too far away, then store that it never happened
			 */
			if (right_node_pos <= end_pos)
				right_node_pos = 0;

			ptr = *link = (t_search_node) right_node_pos;

			if (!ptr) 
				break;

			right_node_pos  = left[ptr];
			link            = &left[ptr];
		}
	}
}


void removeNodes(t_encoder_context *context)
{
	long i;

	// remove the most recent insertions into the hash table, since we had invalid data 
	// sitting at the end of the window
	for (i = 0; i <= BREAK_LENGTH; i++)
	{
		if (context->bufpos-i-1 < WINDOW_SIZE)
			break;

		optimal_remove_node(context, context->bufpos-i-1, context->bufpos-WINDOW_SIZE+BREAK_LENGTH);
	}
}


//
// Reinsert the tree nodes we removed previously
//
void reinsertRemovedNodes(t_encoder_context *context)
{
	long j;

	for (j = BREAK_LENGTH; j > 0; j--)
	{
		if (context->bufpos - j > WINDOW_SIZE)
		{
			optimal_insert(
				context,
	            context->bufpos - j,
		        context->bufpos - j - WINDOW_SIZE + 4
			);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\dll\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\stdenc.c ===
/*
 * stdenc.c
 *
 * Standard encoder
 */
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "deflate.h"


//
// Update hash variable "h" with character c
//
#define UPDATE_HASH(h,c) \
	h = ((h) << STD_ENCODER_HASH_SHIFT) ^ (c);


//
// Insert a string into the hash chain at location bufpos
//
// Assertions check that we never attempt to insert near the end of the buffer
// (since our hash value is based on values at bufpos, bufpos+1, bufpos+2) and
// that our hash value is always valid for the bytes we are inserting.
//
#define INSERT_STRING(search,bufpos) \
{ \
    _ASSERT((bufpos + 2) < context->bufpos_end); \
	UPDATE_HASH(hash, window[bufpos+2]); \
	_ASSERT((unsigned int) STD_ENCODER_RECALCULATE_HASH(bufpos) == (unsigned int) (hash & STD_ENCODER_HASH_MASK)); \
	search = lookup[hash & STD_ENCODER_HASH_MASK]; \
	lookup[hash & STD_ENCODER_HASH_MASK] = (t_search_node) (bufpos); \
	prev[bufpos & WINDOW_MASK] = (t_search_node) search; \
}


#define CHECK_FLUSH_RECORDING_BUFFER() \
	if (recording_bitcount >= 16) \
	{ \
		*recording_bufptr++ = (BYTE) recording_bitbuf; \
		*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); \
		recording_bitbuf >>= 16; \
		recording_bitcount -= 16; \
	}


#define OUTPUT_RECORDING_DATA(count,data) \
	recording_bitbuf |= ((data) << recording_bitcount); \
	recording_bitcount += (count);


//
// Record unmatched symbol c
//
#define RECORD_CHAR(c) \
    context->outputting_block_num_literals++; \
    context->std_encoder->literal_tree_freq[c]++; \
	_ASSERT(context->std_encoder->recording_literal_tree_len[c] != 0); \
	OUTPUT_RECORDING_DATA(context->std_encoder->recording_literal_tree_len[c], context->std_encoder->recording_literal_tree_code[c]); \
	CHECK_FLUSH_RECORDING_BUFFER();


//
// Record a match with length match_len (>= MIN_MATCH) and displacement match_pos
//
#define RECORD_MATCH(match_len, match_pos) \
{ \
	int pos_slot = POS_SLOT(match_pos); \
	int len_slot = g_LengthLookup[match_len - MIN_MATCH]; \
	int item = (NUM_CHARS+1) + len_slot; \
	int extra_dist_bits = g_ExtraDistanceBits[pos_slot]; \
	int extra_len_bits = g_ExtraLengthBits[len_slot]; \
	_ASSERT(match_len >= MIN_MATCH && match_len <= MAX_MATCH); \
	_ASSERT(context->outputting_block_num_literals >= 0 && context->outputting_block_num_literals < STD_ENCODER_MAX_ITEMS); \
	_ASSERT(context->std_encoder->recording_literal_tree_len[item] != 0); \
	_ASSERT(context->std_encoder->recording_dist_tree_len[pos_slot] != 0); \
    context->outputting_block_num_literals++; \
    context->std_encoder->literal_tree_freq[(NUM_CHARS + 1) + len_slot]++; \
    context->std_encoder->dist_tree_freq[pos_slot]++; \
	OUTPUT_RECORDING_DATA(context->std_encoder->recording_literal_tree_len[item], context->std_encoder->recording_literal_tree_code[item]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_len_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_len_bits, (match_len-MIN_MATCH) & ((1 << extra_len_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
	OUTPUT_RECORDING_DATA(context->std_encoder->recording_dist_tree_len[pos_slot], context->std_encoder->recording_dist_tree_code[pos_slot]); \
	CHECK_FLUSH_RECORDING_BUFFER(); \
	if (extra_dist_bits > 0) \
	{ \
		OUTPUT_RECORDING_DATA(extra_dist_bits, match_pos & ((1 << extra_dist_bits)-1)); \
		CHECK_FLUSH_RECORDING_BUFFER(); \
	} \
}


#define FLUSH_RECORDING_BITBUF() \
    *recording_bufptr++ = (BYTE) recording_bitbuf; \
	*recording_bufptr++ = (BYTE) (recording_bitbuf >> 8); 


//
// Verifies that all of the hash pointers in the hash table are correct, and that everything
// in the same hash chain has the same hash value
//
#ifdef FULL_DEBUG
#define VERIFY_HASHES(bufpos) StdEncoderVerifyHashes(context, bufpos)
#else
#define VERIFY_HASHES(bufpos) ;
#endif


static void StdEncoderMoveWindows(t_encoder_context *context);

static int StdEncoderFindMatch(
    const BYTE *        window,
    const USHORT *      prev,
    long                bufpos, 
    long                search, 
    unsigned int *      match_pos, 
    int                 cutoff,
    int                 nice_length
);


void StdEncoderDeflate(
	t_encoder_context *	context, 
    int                 search_depth,
	int					lazy_match_threshold,
    int                 good_length,
    int                 nice_length
)
{
	long			bufpos;
	unsigned int	hash;
    t_std_encoder * encoder = context->std_encoder;
	byte *			window = encoder->window;
	t_search_node *	prev = encoder->prev;
	t_search_node *	lookup = encoder->lookup;
	unsigned long	recording_bitbuf;
	int				recording_bitcount;
	byte *			recording_bufptr;
    byte *          end_recording_bufptr;

	// restore literal/match bitmap variables
    end_recording_bufptr    = &encoder->lit_dist_buffer[STD_ENCODER_LIT_DIST_BUFFER_SIZE-8];
	recording_bufptr        = encoder->recording_bufptr;
    recording_bitbuf        = encoder->recording_bitbuf;
    recording_bitcount      = encoder->recording_bitcount;
	bufpos			        = context->bufpos;

	VERIFY_HASHES(bufpos);

    //
    // Recalculate our hash
    //
    // One disadvantage of the way we do our hashing is that matches are not permitted in the last
    // few characters near bufpos_end.
	//
    hash = 0;
	UPDATE_HASH(hash, window[bufpos]);
	UPDATE_HASH(hash, window[bufpos+1]);

	while (bufpos < context->bufpos_end)
	{
		int				match_len;
		t_match_pos		match_pos;
		t_match_pos		search;

        if (context->bufpos_end - bufpos <= 3)
		{
			// don't insert any strings when we get close to the end of the buffer,
            // since we will end up using corrupted hash values (the data after bufpos_end
            // is undefined, and those bytes would be swept into the hash value if we
            // calculated a hash at bufpos_end-2, for example, since our hash value is
            // build from 3 consecutive characters in the buffer).
			match_len = 0;
		}
		else
		{
			INSERT_STRING(search,bufpos);

			// find a match at what we'll call position X
			if (search != 0)
			{
				match_len = StdEncoderFindMatch(window, prev, bufpos, search, &match_pos, search_depth, nice_length);

				// truncate match if we're too close to the end of the buffer
				if (bufpos + match_len > context->bufpos_end)
					match_len = context->bufpos_end - bufpos;
			}
			else
			{
				match_len = 0;
			}
		}

		if (match_len < MIN_MATCH)
		{
			// didn't find a match, so output unmatched char
			RECORD_CHAR(window[bufpos]);
    		bufpos++;
		}
		else
		{
    		// bufpos now points to X+1
    		bufpos++;

			// is this match so good (long) that we should take it automatically without
			// checking X+1 ?
			if (match_len <= lazy_match_threshold)
			{
				int				next_match_len;
				t_match_pos		next_match_pos;

                // sets search
                INSERT_STRING(search,bufpos);

				// no, so check for a better match at X+1
				if (search != 0)
				{
					next_match_len = StdEncoderFindMatch(
						window,
                        prev,
						bufpos, 
						search,
						&next_match_pos,
						match_len < good_length ? search_depth : (search_depth >> 2),
                        nice_length
					);
				
					// truncate match if we're too close to the end of the buffer
					// note: next_match_len could now be < MIN_MATCH
					if (bufpos + next_match_len > context->bufpos_end)
						next_match_len = context->bufpos_end - bufpos;
				}
				else
				{
					next_match_len = 0;
				}

				// right now X and X+1 are both inserted into the search tree
				if (next_match_len > match_len)
				{
					// since next_match_len > match_len, it can't be < MIN_MATCH here

					// match at X+1 is better, so output unmatched char at X
					RECORD_CHAR(window[bufpos-1]);

					// now output match at location X+1
					RECORD_MATCH(next_match_len, next_match_pos);

					// insert remainder of second match into search tree
					// 
					// example: (*=inserted already)
					//
					// X      X+1               X+2      X+3     X+4
					// *      *
					//        nextmatchlen=3
					//        bufpos
					//
					// If next_match_len == 3, we want to perform 2
					// insertions (at X+2 and X+3).  However, first we must 
					// inc bufpos.
					//
					bufpos++; // now points to X+2
					match_len = next_match_len;
					goto insert;
				}
				else
				{
					// match at X is better, so take it
					RECORD_MATCH(match_len, match_pos);

					//
					// Insert remainder of first match into search tree, minus the first
					// two locations, which were inserted by the FindMatch() calls.
					// 
					// For example, if match_len == 3, then we've inserted at X and X+1
					// already (and bufpos is now pointing at X+1), and now we need to insert 
					// only at X+2.
					//
					match_len--;
					bufpos++; // now bufpos points to X+2
					goto insert;
				}
			}
			else /* match_length >= good_match */
			{
				// in assertion: bufpos points to X+1, location X inserted already
					
				// first match is so good that we're not even going to check at X+1
				RECORD_MATCH(match_len, match_pos);

				// insert remainder of match at X into search tree
insert:
				if (context->bufpos_end - bufpos <= match_len)
				{
					bufpos += (match_len-1);
				}
				else
				{
					while (--match_len > 0)
					{
						t_match_pos ignore; // we're not interested in the search position

						INSERT_STRING(ignore,bufpos);
						bufpos++;
					}
				}
			}
		}

		// literal buffer or distance buffer filled up (or close to filling up)?
		if (context->outputting_block_num_literals >= STD_ENCODER_MAX_ITEMS-4 ||
            recording_bufptr >= end_recording_bufptr)
		{
			// yes, then we must output a block
			_ASSERT(context->outputting_block_num_literals <= STD_ENCODER_MAX_ITEMS);

			// flush our recording matches bit buffer
            FLUSH_RECORDING_BITBUF();

			StdEncoderOutputBlock(context);

			// did we output the whole block?
			if (context->state != STATE_NORMAL)
				break;

			// we did output the whole block, so reset literal encoding
        	recording_bufptr = encoder->recording_bufptr;
            recording_bitbuf = encoder->recording_bitbuf;
            recording_bitcount = encoder->recording_bitcount;
		}
	} /* end ... while (bufpos < bufpos_end) */

    _ASSERT(bufpos <= context->bufpos_end);

	// save recording state
	encoder->recording_bufptr = recording_bufptr;
    encoder->recording_bitbuf = recording_bitbuf;
    encoder->recording_bitcount = recording_bitcount;

	context->bufpos = bufpos;

	VERIFY_HASHES(bufpos);

    if (context->bufpos == 2*WINDOW_SIZE)
        StdEncoderMoveWindows(context);
}


static int StdEncoderFindMatch(
    const BYTE *        window,
    const USHORT *      prev,
    long                bufpos, 
    long                search, 
    unsigned int *      match_pos, 
    int                 cutoff,
    int                 nice_length
)
{
	const BYTE *	window_bufpos = &window[bufpos];
	long			earliest; // how far back we can look
	int				best_match = 0; // best match length found so far
	t_match_pos		l_match_pos = 0;

	_ASSERT(bufpos >= 0 && bufpos < 2*WINDOW_SIZE);
	_ASSERT(search < bufpos);
	_ASSERT(STD_ENCODER_RECALCULATE_HASH(search) == STD_ENCODER_RECALCULATE_HASH(bufpos));

	earliest = bufpos - WINDOW_SIZE;
    _ASSERT(earliest >= 0);

	while (search > earliest)
	{
		_ASSERT(STD_ENCODER_RECALCULATE_HASH(search) == STD_ENCODER_RECALCULATE_HASH(bufpos));
        _ASSERT(search < bufpos);

		if (window_bufpos[best_match] == window[search + best_match])
		{
			int j;

			for (j = 0; j < MAX_MATCH; j++)
			{
				if (window_bufpos[j] != window[search+j])
					break;
			}
	
			if (j > best_match)
			{
				best_match	= j;
				l_match_pos	= search; // absolute position

				if (j > nice_length)
					break;
			}
		}

		if (--cutoff == 0)
			break;

		search = (long) prev[search & WINDOW_MASK];
	}

    // turn l_match_pos into relative position
	l_match_pos = bufpos - l_match_pos - 1; 

	if (best_match == 3 && l_match_pos >= STD_ENCODER_MATCH3_DIST_THRESHOLD)
		return 0;

	_ASSERT(best_match < MIN_MATCH || l_match_pos < WINDOW_SIZE);
    *match_pos = l_match_pos;

	return best_match;
}


static void StdEncoderMoveWindows(t_encoder_context *context)
{
	if (context->bufpos >= 2*WINDOW_SIZE)
	{
		int		i;
		t_search_node *lookup = context->std_encoder->lookup;
		t_search_node *prev = context->std_encoder->prev;
		BYTE *window = context->std_encoder->window;

		VERIFY_HASHES(2*WINDOW_SIZE);

		memcpy(&window[0], &window[context->bufpos - WINDOW_SIZE], WINDOW_SIZE);

		for (i = 0; i < STD_ENCODER_HASH_TABLE_SIZE; i++)
		{
			long val = ((long) lookup[i]) - WINDOW_SIZE;
	
			if (val <= 0)
				lookup[i] = (t_search_node) 0;
			else
				lookup[i] = (t_search_node) val;
		}

		for (i = 0; i < WINDOW_SIZE; i++)
		{
			long val = ((long) prev[i]) - WINDOW_SIZE;
	
			if (val <= 0)
				prev[i] = (t_search_node) 0;
			else
				prev[i] = (t_search_node) val;
		}

#ifdef FULL_DEBUG
		memset(&window[WINDOW_SIZE], 0, WINDOW_SIZE);
#endif

		VERIFY_HASHES(2*WINDOW_SIZE);

		
		context->bufpos = WINDOW_SIZE;
		context->bufpos_end = context->bufpos;
	}
}


//
// Zero the running frequency counts
//
// Also set freq[END_OF_BLOCK_CODE] = 1
//
void StdEncoderZeroFrequencyCounts(t_std_encoder *encoder)
{
    _ASSERT(encoder != NULL);

  	memset(encoder->literal_tree_freq, 0, sizeof(encoder->literal_tree_freq));
    memset(encoder->dist_tree_freq, 0, sizeof(encoder->dist_tree_freq));
    encoder->literal_tree_freq[END_OF_BLOCK_CODE] = 1;
}


void StdEncoderReset(t_encoder_context *context)
{
    t_std_encoder *encoder = context->std_encoder;

	_ASSERT(encoder != NULL);
	memset(encoder->lookup, 0, sizeof(encoder->lookup));

    context->window_size        = WINDOW_SIZE;
	context->bufpos		        = context->window_size;
	context->bufpos_end         = context->bufpos;

	encoder->recording_bitbuf	= 0;
	encoder->recording_bitcount = 0;
    encoder->recording_bufptr   = encoder->lit_dist_buffer;

	DeflateInitRecordingTables(
	    encoder->recording_literal_tree_len,
    	encoder->recording_literal_tree_code, 
	    encoder->recording_dist_tree_len,
    	encoder->recording_dist_tree_code
    );

    StdEncoderZeroFrequencyCounts(encoder);
}


BOOL StdEncoderInit(t_encoder_context *context)
{
	context->std_encoder = (t_std_encoder *) LocalAlloc(LMEM_FIXED, sizeof(t_std_encoder));

    if (context->std_encoder == NULL)
        return FALSE;

	StdEncoderReset(context);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\static.h ===
/* This file generate by gentable.c -- do not modify directly! */
#ifdef DECLARE_DATA
const BYTE g_LengthLookup[256] =
{
 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9,10,10,11,11,
12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,
16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,
18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,
20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,
};

const BYTE g_DistLookup[512] =
{
 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
 0, 0,16,17,18,18,19,19,20,20,20,20,21,21,21,21,
22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,
24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
};
#else /* !DECLARE_DATA */
extern const BYTE g_LengthLookup[];
extern const BYTE g_DistLookup[];
#endif /* DECLARE_DATA */

#ifdef DECLARE_DATA
const BYTE g_CodeOrder[] =
{16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15,};
#else /* !DECLARE_DATA */
extern const BYTE g_CodeOrder[19];
#endif /* !DECLARE_DATA */

#ifdef DECLARE_DATA
const BYTE g_ExtraLengthBits[] =
{0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,};
#else /* !DECLARE_DATA */
extern const BYTE g_ExtraLengthBits[];
#endif /* !DECLARE_DATA */

#ifdef DECLARE_DATA
const BYTE g_ExtraDistanceBits[] =
{0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0,};
#else /* !DECLARE_DATA */
extern const BYTE g_ExtraDistanceBits[];
#endif /* !DECLARE_DATA */

#ifdef DECLARE_DATA
const BYTE g_StaticLiteralTreeLength[] = {
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,
0x09,0x09,0x09,0x09,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,
0x07,0x07,0x07,0x07,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
};
#else /* !DECLARE_DATA */
extern const BYTE g_StaticLiteralTreeLength[];
#endif /* DECLARE_DATA */

#ifdef DECLARE_DATA
const USHORT g_StaticLiteralTreeCode[] = {
0x000c,0x008c,0x004c,0x00cc,0x002c,0x00ac,0x006c,0x00ec,
0x001c,0x009c,0x005c,0x00dc,0x003c,0x00bc,0x007c,0x00fc,
0x0002,0x0082,0x0042,0x00c2,0x0022,0x00a2,0x0062,0x00e2,
0x0012,0x0092,0x0052,0x00d2,0x0032,0x00b2,0x0072,0x00f2,
0x000a,0x008a,0x004a,0x00ca,0x002a,0x00aa,0x006a,0x00ea,
0x001a,0x009a,0x005a,0x00da,0x003a,0x00ba,0x007a,0x00fa,
0x0006,0x0086,0x0046,0x00c6,0x0026,0x00a6,0x0066,0x00e6,
0x0016,0x0096,0x0056,0x00d6,0x0036,0x00b6,0x0076,0x00f6,
0x000e,0x008e,0x004e,0x00ce,0x002e,0x00ae,0x006e,0x00ee,
0x001e,0x009e,0x005e,0x00de,0x003e,0x00be,0x007e,0x00fe,
0x0001,0x0081,0x0041,0x00c1,0x0021,0x00a1,0x0061,0x00e1,
0x0011,0x0091,0x0051,0x00d1,0x0031,0x00b1,0x0071,0x00f1,
0x0009,0x0089,0x0049,0x00c9,0x0029,0x00a9,0x0069,0x00e9,
0x0019,0x0099,0x0059,0x00d9,0x0039,0x00b9,0x0079,0x00f9,
0x0005,0x0085,0x0045,0x00c5,0x0025,0x00a5,0x0065,0x00e5,
0x0015,0x0095,0x0055,0x00d5,0x0035,0x00b5,0x0075,0x00f5,
0x000d,0x008d,0x004d,0x00cd,0x002d,0x00ad,0x006d,0x00ed,
0x001d,0x009d,0x005d,0x00dd,0x003d,0x00bd,0x007d,0x00fd,
0x0013,0x0113,0x0093,0x0193,0x0053,0x0153,0x00d3,0x01d3,
0x0033,0x0133,0x00b3,0x01b3,0x0073,0x0173,0x00f3,0x01f3,
0x000b,0x010b,0x008b,0x018b,0x004b,0x014b,0x00cb,0x01cb,
0x002b,0x012b,0x00ab,0x01ab,0x006b,0x016b,0x00eb,0x01eb,
0x001b,0x011b,0x009b,0x019b,0x005b,0x015b,0x00db,0x01db,
0x003b,0x013b,0x00bb,0x01bb,0x007b,0x017b,0x00fb,0x01fb,
0x0007,0x0107,0x0087,0x0187,0x0047,0x0147,0x00c7,0x01c7,
0x0027,0x0127,0x00a7,0x01a7,0x0067,0x0167,0x00e7,0x01e7,
0x0017,0x0117,0x0097,0x0197,0x0057,0x0157,0x00d7,0x01d7,
0x0037,0x0137,0x00b7,0x01b7,0x0077,0x0177,0x00f7,0x01f7,
0x000f,0x010f,0x008f,0x018f,0x004f,0x014f,0x00cf,0x01cf,
0x002f,0x012f,0x00af,0x01af,0x006f,0x016f,0x00ef,0x01ef,
0x001f,0x011f,0x009f,0x019f,0x005f,0x015f,0x00df,0x01df,
0x003f,0x013f,0x00bf,0x01bf,0x007f,0x017f,0x00ff,0x01ff,
0x0000,0x0040,0x0020,0x0060,0x0010,0x0050,0x0030,0x0070,
0x0008,0x0048,0x0028,0x0068,0x0018,0x0058,0x0038,0x0078,
0x0004,0x0044,0x0024,0x0064,0x0014,0x0054,0x0034,0x0074,
0x0003,0x0083,0x0043,0x00c3,0x0023,0x00a3,0x0063,0x00e3,
};
#else /* !DECLARE_DATA */
extern const USHORT g_StaticLiteralTreeCode[];
#endif /* DECLARE_DATA */

#ifdef DECLARE_DATA
const USHORT g_StaticDistanceTree[] = {
0x0000,0x0010,0x0008,0x0018,0x0004,0x0014,0x000c,0x001c,
0x0002,0x0012,0x000a,0x001a,0x0006,0x0016,0x000e,0x001e,
0x0001,0x0011,0x0009,0x0019,0x0005,0x0015,0x000d,0x001d,
0x0003,0x0013,0x000b,0x001b,0x0007,0x0017,0x000f,0x001f,
};
#else /* !DECLARE_DATA */
extern const USHORT g_StaticDistanceTree[];
#endif /* DECLARE_DATA */

#ifdef DECLARE_DATA
const SHORT g_StaticLiteralTreeTable[] = {
0x0100,0x0050,0x0010,0x0118,0x0110,0x0070,0x0030,0x00c0,
0x0108,0x0060,0x0020,0x00a0,0x0000,0x0080,0x0040,0x00e0,
0x0104,0x0058,0x0018,0x0090,0x0114,0x0078,0x0038,0x00d0,
0x010c,0x0068,0x0028,0x00b0,0x0008,0x0088,0x0048,0x00f0,
0x0102,0x0054,0x0014,0x011c,0x0112,0x0074,0x0034,0x00c8,
0x010a,0x0064,0x0024,0x00a8,0x0004,0x0084,0x0044,0x00e8,
0x0106,0x005c,0x001c,0x0098,0x0116,0x007c,0x003c,0x00d8,
0x010e,0x006c,0x002c,0x00b8,0x000c,0x008c,0x004c,0x00f8,
0x0101,0x0052,0x0012,0x011a,0x0111,0x0072,0x0032,0x00c4,
0x0109,0x0062,0x0022,0x00a4,0x0002,0x0082,0x0042,0x00e4,
0x0105,0x005a,0x001a,0x0094,0x0115,0x007a,0x003a,0x00d4,
0x010d,0x006a,0x002a,0x00b4,0x000a,0x008a,0x004a,0x00f4,
0x0103,0x0056,0x0016,0x011e,0x0113,0x0076,0x0036,0x00cc,
0x010b,0x0066,0x0026,0x00ac,0x0006,0x0086,0x0046,0x00ec,
0x0107,0x005e,0x001e,0x009c,0x0117,0x007e,0x003e,0x00dc,
0x010f,0x006e,0x002e,0x00bc,0x000e,0x008e,0x004e,0x00fc,
0x0100,0x0051,0x0011,0x0119,0x0110,0x0071,0x0031,0x00c2,
0x0108,0x0061,0x0021,0x00a2,0x0001,0x0081,0x0041,0x00e2,
0x0104,0x0059,0x0019,0x0092,0x0114,0x0079,0x0039,0x00d2,
0x010c,0x0069,0x0029,0x00b2,0x0009,0x0089,0x0049,0x00f2,
0x0102,0x0055,0x0015,0x011d,0x0112,0x0075,0x0035,0x00ca,
0x010a,0x0065,0x0025,0x00aa,0x0005,0x0085,0x0045,0x00ea,
0x0106,0x005d,0x001d,0x009a,0x0116,0x007d,0x003d,0x00da,
0x010e,0x006d,0x002d,0x00ba,0x000d,0x008d,0x004d,0x00fa,
0x0101,0x0053,0x0013,0x011b,0x0111,0x0073,0x0033,0x00c6,
0x0109,0x0063,0x0023,0x00a6,0x0003,0x0083,0x0043,0x00e6,
0x0105,0x005b,0x001b,0x0096,0x0115,0x007b,0x003b,0x00d6,
0x010d,0x006b,0x002b,0x00b6,0x000b,0x008b,0x004b,0x00f6,
0x0103,0x0057,0x0017,0x011f,0x0113,0x0077,0x0037,0x00ce,
0x010b,0x0067,0x0027,0x00ae,0x0007,0x0087,0x0047,0x00ee,
0x0107,0x005f,0x001f,0x009e,0x0117,0x007f,0x003f,0x00de,
0x010f,0x006f,0x002f,0x00be,0x000f,0x008f,0x004f,0x00fe,
0x0100,0x0050,0x0010,0x0118,0x0110,0x0070,0x0030,0x00c1,
0x0108,0x0060,0x0020,0x00a1,0x0000,0x0080,0x0040,0x00e1,
0x0104,0x0058,0x0018,0x0091,0x0114,0x0078,0x0038,0x00d1,
0x010c,0x0068,0x0028,0x00b1,0x0008,0x0088,0x0048,0x00f1,
0x0102,0x0054,0x0014,0x011c,0x0112,0x0074,0x0034,0x00c9,
0x010a,0x0064,0x0024,0x00a9,0x0004,0x0084,0x0044,0x00e9,
0x0106,0x005c,0x001c,0x0099,0x0116,0x007c,0x003c,0x00d9,
0x010e,0x006c,0x002c,0x00b9,0x000c,0x008c,0x004c,0x00f9,
0x0101,0x0052,0x0012,0x011a,0x0111,0x0072,0x0032,0x00c5,
0x0109,0x0062,0x0022,0x00a5,0x0002,0x0082,0x0042,0x00e5,
0x0105,0x005a,0x001a,0x0095,0x0115,0x007a,0x003a,0x00d5,
0x010d,0x006a,0x002a,0x00b5,0x000a,0x008a,0x004a,0x00f5,
0x0103,0x0056,0x0016,0x011e,0x0113,0x0076,0x0036,0x00cd,
0x010b,0x0066,0x0026,0x00ad,0x0006,0x0086,0x0046,0x00ed,
0x0107,0x005e,0x001e,0x009d,0x0117,0x007e,0x003e,0x00dd,
0x010f,0x006e,0x002e,0x00bd,0x000e,0x008e,0x004e,0x00fd,
0x0100,0x0051,0x0011,0x0119,0x0110,0x0071,0x0031,0x00c3,
0x0108,0x0061,0x0021,0x00a3,0x0001,0x0081,0x0041,0x00e3,
0x0104,0x0059,0x0019,0x0093,0x0114,0x0079,0x0039,0x00d3,
0x010c,0x0069,0x0029,0x00b3,0x0009,0x0089,0x0049,0x00f3,
0x0102,0x0055,0x0015,0x011d,0x0112,0x0075,0x0035,0x00cb,
0x010a,0x0065,0x0025,0x00ab,0x0005,0x0085,0x0045,0x00eb,
0x0106,0x005d,0x001d,0x009b,0x0116,0x007d,0x003d,0x00db,
0x010e,0x006d,0x002d,0x00bb,0x000d,0x008d,0x004d,0x00fb,
0x0101,0x0053,0x0013,0x011b,0x0111,0x0073,0x0033,0x00c7,
0x0109,0x0063,0x0023,0x00a7,0x0003,0x0083,0x0043,0x00e7,
0x0105,0x005b,0x001b,0x0097,0x0115,0x007b,0x003b,0x00d7,
0x010d,0x006b,0x002b,0x00b7,0x000b,0x008b,0x004b,0x00f7,
0x0103,0x0057,0x0017,0x011f,0x0113,0x0077,0x0037,0x00cf,
0x010b,0x0067,0x0027,0x00af,0x0007,0x0087,0x0047,0x00ef,
0x0107,0x005f,0x001f,0x009f,0x0117,0x007f,0x003f,0x00df,
0x010f,0x006f,0x002f,0x00bf,0x000f,0x008f,0x004f,0x00ff,
};
#else /* !DECLARE_DATA */
extern const USHORT g_StaticLiteralTreeTable[];
#endif /* DECLARE_DATA */

#ifdef DECLARE_DATA
const BYTE g_StaticDistanceTreeTable[] = {
0x00,0x10,0x08,0x18,0x04,0x14,0x0c,0x1c,0x02,0x12,0x0a,0x1a,
0x06,0x16,0x0e,0x1e,0x01,0x11,0x09,0x19,0x05,0x15,0x0d,0x1d,
0x03,0x13,0x0b,0x1b,0x07,0x17,0x0f,0x1f,
};
#else /* !DECLARE_DATA */
extern const BYTE g_StaticDistanceTreeTable[];
#endif /* DECLARE_DATA */

#ifdef DECLARE_DATA
const ULONG g_LengthBase[] =
{
3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,
35,43,51,59,67,83,99,115,131,163,195,227,258,};
#else /* !DECLARE_DATA */
extern const ULONG g_LengthBase[];
#endif /* !DECLARE_DATA */

#ifdef DECLARE_DATA
const ULONG g_DistanceBasePosition[] =
{
1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0,};
#else /* !DECLARE_DATA */
extern const ULONG g_DistanceBasePosition[];
#endif /* !DECLARE_DATA */

#ifdef DECLARE_DATA
const ULONG g_BitMask[] =
{
0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,};
#else /* !DECLARE_DATA */
extern const ULONG g_BitMask[];
#endif /* !DECLARE_DATA */

#ifdef DECLARE_DATA
const BYTE g_FastEncoderTreeStructureData[] = {
0xed,0xbd,0x07,0x60,0x1c,0x49,0x96,0x25,0x26,0x2f,0x6d,0xca,
0x7b,0x7f,0x4a,0xf5,0x4a,0xd7,0xe0,0x74,0xa1,0x08,0x80,0x60,
0x13,0x24,0xd8,0x90,0x40,0x10,0xec,0xc1,0x88,0xcd,0xe6,0x92,
0xec,0x1d,0x69,0x47,0x23,0x29,0xab,0x2a,0x81,0xca,0x65,0x56,
0x65,0x5d,0x66,0x16,0x40,0xcc,0xed,0x9d,0xbc,0xf7,0xde,0x7b,
0xef,0xbd,0xf7,0xde,0x7b,0xef,0xbd,0xf7,0xba,0x3b,0x9d,0x4e,
0x27,0xf7,0xdf,0xff,0x3f,0x5c,0x66,0x64,0x01,0x6c,0xf6,0xce,
0x4a,0xda,0xc9,0x9e,0x21,0x80,0xaa,0xc8,0x1f,0x3f,0x7e,0x7c,
0x1f,0x3f,
};
#else /* !DECLARE_DATA */
extern const BYTE g_FastEncoderTreeStructureData[];
#endif /* DECLARE_DATA */

#define FAST_ENCODER_TREE_LENGTH 98
#define FAST_ENCODER_POST_TREE_BITBUF 0x0022
#define FAST_ENCODER_POST_TREE_BITCOUNT 9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\stdblock.c ===
//
// stdblock.c
//
// Outputting blocks
//
#include "deflate.h"
#include <string.h>
#include <stdio.h>
#include <crtdbg.h>
#include "maketbl.h"


//
// Decode a recorded literal
//
#define DECODE_LITERAL(slot) \
    slot = encoder->recording_literal_tree_table[read_bitbuf & REC_LITERALS_DECODING_TABLE_MASK]; \
    while (slot < 0) \
    {  \
        unsigned long mask = 1 << REC_LITERALS_DECODING_TABLE_BITS; \
        do \
        { \
            slot = -slot; \
            if ((read_bitbuf & mask) == 0) \
                slot = encoder->recording_literal_tree_left[slot]; \
            else \
                slot = encoder->recording_literal_tree_right[slot]; \
            mask <<= 1; \
        } while (slot < 0); \
    }


//
// Decode a recorded distance slot
//
#define DECODE_POS_SLOT(slot) \
    slot = encoder->recording_dist_tree_table[read_bitbuf & REC_DISTANCES_DECODING_TABLE_MASK]; \
    while (slot < 0) \
    {  \
        unsigned long mask = 1 << REC_DISTANCES_DECODING_TABLE_BITS; \
        do \
        { \
            slot = -slot; \
            if ((read_bitbuf & mask) == 0) \
                slot = encoder->recording_dist_tree_left[slot]; \
            else \
                slot = encoder->recording_dist_tree_right[slot]; \
            mask <<= 1; \
        } while (slot < 0); \
    }


//
// Remove count bits from the bit buffer
//
#define DUMP_READBUF_BITS(count) \
    read_bitbuf >>= count; \
    read_bitcount -= count;


//
// Read more bits into the read buffer if our bit buffer if we need to
//
#define CHECK_MORE_READBUF() \
    if (read_bitcount <= 0) \
    { \
        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
        read_bitcount += 8; \
        if (read_bitcount <= 0) \
        { \
            read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); \
            read_bitcount += 8; \
        } \
    }


// output an element from the literal tree
#define OUTPUT_LITERAL(element) \
{ \
    _ASSERT(encoder->literal_tree_len[element] != 0); \
    outputBits(context, encoder->literal_tree_len[element], encoder->literal_tree_code[element]); \
}


// output an element from the distance tree
#define OUTPUT_DIST_SLOT(element) \
{ \
    _ASSERT(encoder->dist_tree_len[element] != 0); \
    outputBits(context, encoder->dist_tree_len[element], encoder->dist_tree_code[element]); \
}



//
// Output a dynamic block
//
static BOOL StdEncoderOutputDynamicBlock(t_encoder_context *context)
{
    unsigned long    read_bitbuf;
    int                read_bitcount;
    byte *            read_bufptr;
    t_std_encoder *encoder = context->std_encoder;

    if (context->state == STATE_NORMAL)
    {
        //
        // If we haven't started to output a block yet
        //
        read_bufptr     = encoder->lit_dist_buffer;
        read_bitbuf        = 0;
        read_bitcount    = -16;

        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
        read_bitcount += 8;

        read_bitbuf |= ((*read_bufptr++) << (read_bitcount+16)); 
        read_bitcount += 8;

        context->outputting_block_bitbuf        = read_bitbuf;
        context->outputting_block_bitcount        = read_bitcount;
        context->outputting_block_bufptr        = read_bufptr;

        outputBits(context, 1, 0); // "final" block flag
        outputBits(context, 2, BLOCKTYPE_DYNAMIC); 

        context->state = STATE_OUTPUTTING_TREE_STRUCTURE;
    }

    if (context->state == STATE_OUTPUTTING_TREE_STRUCTURE)
    {
        //
        // Make sure there is enough room to output the entire tree structure at once
        //
        if (context->output_curpos > context->output_endpos - MAX_TREE_DATA_SIZE)
        {
            _ASSERT(0); // not enough room to output tree structure, fatal error!
            return FALSE;
        }

        outputTreeStructure(context, encoder->literal_tree_len, encoder->dist_tree_len);

        context->state = STATE_OUTPUTTING_BLOCK;
    }

    _ASSERT(context->state == STATE_OUTPUTTING_BLOCK);

    // load state into local variables
    read_bufptr        = context->outputting_block_bufptr;
    read_bitbuf        = context->outputting_block_bitbuf;
    read_bitcount    = context->outputting_block_bitcount;

    // output literals
    while (context->outputting_block_current_literal < context->outputting_block_num_literals)
    {
        int literal;

        // break when we get near the end of our output buffer
        if (context->output_curpos >= context->output_near_end_threshold)
            break;

        DECODE_LITERAL(literal);
        DUMP_READBUF_BITS(encoder->recording_literal_tree_len[literal]);
        CHECK_MORE_READBUF();

        if (literal < NUM_CHARS)
        {
            // it's a char
            OUTPUT_LITERAL(literal);
        }
        else
        {
            // it's a match
            int len_slot, pos_slot, extra_pos_bits;

            // literal == len_slot + (NUM_CHARS+1)
            _ASSERT(literal != END_OF_BLOCK_CODE);

            OUTPUT_LITERAL(literal);

            len_slot = literal - (NUM_CHARS+1);

            //
            // extra_length_bits[len_slot] > 0 when len_slot >= 8
            // (except when length is MAX_MATCH).
            //
            if (len_slot >= 8)
            {
                int extra_bits = g_ExtraLengthBits[len_slot];

                if (extra_bits > 0)
                {
                    unsigned int extra_data = read_bitbuf & ((1 << extra_bits)-1);

                    outputBits(context, extra_bits, extra_data);
                    
                    DUMP_READBUF_BITS(extra_bits);
                    CHECK_MORE_READBUF();
                }
            }

            DECODE_POS_SLOT(pos_slot);
            DUMP_READBUF_BITS(encoder->recording_dist_tree_len[pos_slot]);
            CHECK_MORE_READBUF();

            _ASSERT(pos_slot < 30);

            OUTPUT_DIST_SLOT(pos_slot);

            extra_pos_bits = g_ExtraDistanceBits[pos_slot];

            if (extra_pos_bits > 0)
            {
                unsigned int extra_data = read_bitbuf & ((1 << extra_pos_bits)-1);

                outputBits(context, extra_pos_bits, extra_data);

                DUMP_READBUF_BITS(extra_pos_bits);
                CHECK_MORE_READBUF();
            }
        }

        context->outputting_block_current_literal++;
    }

    // did we output all of our literals without running out of output space?
    if (context->outputting_block_current_literal >= context->outputting_block_num_literals)
    {
        // output the code signifying end-of-block
        OUTPUT_LITERAL(END_OF_BLOCK_CODE);

        // reset state
        context->state = STATE_NORMAL;
    }
    else
    {
        context->outputting_block_bitbuf    = read_bitbuf;
        context->outputting_block_bitcount    = read_bitcount;
        context->outputting_block_bufptr    = read_bufptr;
        context->state                        = STATE_OUTPUTTING_BLOCK;
    }

    return TRUE;
}


//
// Output a block.  This routine will resume outputting a block that was already being
// output if state != STATE_NORMAL.
//
BOOL StdEncoderOutputBlock(t_encoder_context *context)
{
    t_std_encoder *encoder = context->std_encoder;

    //
    // The tree creation routines cannot handle this overflow
    //
    _ASSERT(context->outputting_block_num_literals < 65536);

    if (context->state == STATE_NORMAL)
    {
        //
        // Start outputting literals and distances from the beginning
        //
        context->outputting_block_current_literal = 0;
    
        //
        // Nothing to output?  Then return
        //
        if (context->outputting_block_num_literals == 0)
            return TRUE;

        // make decoding table so that we can decode recorded items
        makeTable(
            MAX_LITERAL_TREE_ELEMENTS,
            REC_LITERALS_DECODING_TABLE_BITS,
            encoder->recording_literal_tree_len,
            encoder->recording_literal_tree_table,
            encoder->recording_literal_tree_left,
            encoder->recording_literal_tree_right
        );

        makeTable(
            MAX_DIST_TREE_ELEMENTS,
            REC_DISTANCES_DECODING_TABLE_BITS,
            encoder->recording_dist_tree_len,
            encoder->recording_dist_tree_table,
            encoder->recording_dist_tree_left,
            encoder->recording_dist_tree_right
        );

//        NormaliseFrequencies(context->literal_tree_freq, context->dist_tree_freq);
//context->dist_tree_freq[30] = 0;
//context->dist_tree_freq[31] = 0;

        // now make the trees used for encoding
        makeTree(
            MAX_LITERAL_TREE_ELEMENTS, 
            15, 
            encoder->literal_tree_freq, 
            encoder->literal_tree_code,
            encoder->literal_tree_len
        );

        makeTree(
            MAX_DIST_TREE_ELEMENTS, 
            15, 
            encoder->dist_tree_freq, 
            encoder->dist_tree_code,
            encoder->dist_tree_len
        );

//GenerateTable("g_FastEncoderLiteralTree", MAX_LITERAL_TREE_ELEMENTS, context->literal_tree_len, context->literal_tree_code);
//GenerateTable("g_FastEncoderDistanceTree", MAX_DIST_TREE_ELEMENTS, context->dist_tree_len, context->dist_tree_code);
    }

    //
    // Try outputting as a dynamic block
    //
    if (StdEncoderOutputDynamicBlock(context) == FALSE)
    {
        return FALSE;
    }

    if (context->state == STATE_NORMAL)
    {
           encoder->recording_bufptr           = context->std_encoder->lit_dist_buffer;
        encoder->recording_bitbuf           = 0;
        encoder->recording_bitcount         = 0;

        context->outputting_block_num_literals = 0;

        // make sure there are no zero frequency items
        NormaliseFrequencies(encoder->literal_tree_freq, encoder->dist_tree_freq);

        // make tree for recording new items
        makeTree(
            MAX_DIST_TREE_ELEMENTS, 
            RECORDING_DIST_MAX_CODE_LEN,
            encoder->dist_tree_freq, 
            encoder->recording_dist_tree_code, 
            encoder->recording_dist_tree_len
        );

        makeTree(
            MAX_LITERAL_TREE_ELEMENTS, 
            RECORDING_LIT_MAX_CODE_LEN,
            encoder->literal_tree_freq, 
            encoder->recording_literal_tree_code, 
            encoder->recording_literal_tree_len
        );

        StdEncoderZeroFrequencyCounts(encoder);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\types.h ===
//
// types.h
//
// Type definitions
//
#ifndef _DEFLATE_TYPES_H
#define _DEFLATE_TYPES_H

#include <windows.h>
#include "api_int.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\compress\gzip\stdenc.h ===
/*
 * stdenc.h
 *
 * Defines for the standard encoder
 */

//
// Size of hash table for std encoder
//
#define STD_ENCODER_HASH_TABLE_SIZE				8192
#define STD_ENCODER_HASH_MASK					(STD_ENCODER_HASH_TABLE_SIZE-1)
#define STD_ENCODER_HASH_SHIFT					5

#define STD_ENCODER_RECALCULATE_HASH(loc) \
	(((window[loc] << (2*STD_ENCODER_HASH_SHIFT)) ^ \
	(window[loc+1] << STD_ENCODER_HASH_SHIFT) ^ \
	(window[loc+2])) & STD_ENCODER_HASH_MASK)


//
// Maximum number of item we allow; this must be <= 65534, since this doesn't include
// freq[END_OF_BLOCK_CODE] = 1, which brings us to 65535; any more than this would make
// the frequency counts overflow, since they are stored in ushort's
//
// Note that this number does not affect the memory requirements in any way; that is
// determined by LIT_DIST_BUFFER_SIZE
//
// -8 for some slack (not really necessary)
//
#define STD_ENCODER_MAX_ITEMS				(65534-8)

//
// Size of the literal/distance buffer
//
#define STD_ENCODER_LIT_DIST_BUFFER_SIZE	32768

//
// Don't take a match 3 further away than this
// BUGBUG 4K seems a little close, but does do a marginally better job than 8K on 
// an 80K html file, so might as well leave it be
//
#define STD_ENCODER_MATCH3_DIST_THRESHOLD   4096


//
// Standard encoder context
//
typedef struct std_encoder
{
	// history window
	BYTE 					window[2*WINDOW_SIZE + MAX_MATCH + 4];

	// next most recent occurance of chars with same hash value
    t_search_node			prev[WINDOW_SIZE + MAX_MATCH];

	// hash table to find most recent occurance of chars with same hash value
	t_search_node			lookup[STD_ENCODER_HASH_TABLE_SIZE];

	// recording buffer for recording literals and distances
	BYTE					lit_dist_buffer[STD_ENCODER_LIT_DIST_BUFFER_SIZE];
	unsigned long			recording_bitbuf;
	unsigned long			recording_bitcount;
    BYTE *                  recording_bufptr;

	short					recording_dist_tree_table[REC_DISTANCES_DECODING_TABLE_SIZE];
	short					recording_dist_tree_left[2*MAX_DIST_TREE_ELEMENTS];
	short					recording_dist_tree_right[2*MAX_DIST_TREE_ELEMENTS];
    BYTE					recording_dist_tree_len[MAX_DIST_TREE_ELEMENTS];
    USHORT                  recording_dist_tree_code[MAX_DIST_TREE_ELEMENTS];

	short					recording_literal_tree_table[REC_LITERALS_DECODING_TABLE_SIZE];
	short					recording_literal_tree_left[2*MAX_LITERAL_TREE_ELEMENTS];
	short					recording_literal_tree_right[2*MAX_LITERAL_TREE_ELEMENTS];
	BYTE					recording_literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  recording_literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];

	// literal trees
    USHORT                  literal_tree_freq[2*MAX_LITERAL_TREE_ELEMENTS];
	USHORT                  literal_tree_code[MAX_LITERAL_TREE_ELEMENTS];
	BYTE					literal_tree_len[MAX_LITERAL_TREE_ELEMENTS];
	
	// dist trees
    USHORT                  dist_tree_freq[2*MAX_DIST_TREE_ELEMENTS];
	USHORT                  dist_tree_code[MAX_DIST_TREE_ELEMENTS];
	BYTE					dist_tree_len[MAX_DIST_TREE_ELEMENTS];
} t_std_encoder;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\dll\daytona\makefile.inc ===
..\urlmon.rc : $(O)\selfreg.inf

$(O)\selfreg.inf : ..\selfreg.inx
        $(CLEANINF) $** $@

$(O)\urlmon.def: ..\urlmon.def
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\urlmonp.def: ..\urlmon.def
    $(C_PREPROCESSOR_NAME) -DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $*.dfp
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $*.dfp > $@

$(O)\urlmonp.lib: $(O)\urlmonp.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\urlmonp.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\dll\dummy.cxx ===
#include <windows.h>

extern BOOL WINAPI (DllMainInternal)(HINSTANCE hInst, DWORD dwReason, LPVOID lpvReserved);

EXTERN_C DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpvReserved);
BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpvReserved)
{
    return ((DllMainInternal)(hInst, dwReason, lpvReserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\cdlpch.h ===
// PCH for code download

// For CoInstall implementation!
#define _OLE32_

#include <urlint.h>
#include <urlmon.h>
#include <wininet.h>
#include <sem.hxx>
#include <cdl.h>
#include <tls.h>
#include <helpers.hxx>
#include <logo3bsc.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\cdl.h ===
#ifndef _CDL_H_
#define _CDL_H_

#define MAX_DEBUG_STRING_LENGTH                    2048
#define MAX_DEBUG_FORMAT_STRING_LENGTH             1024
#define MAX_VERSIONLENGTH                          27  // sizeof(2DWORDS)/(log 10 base 2) + 3 (seperators) 
                                                       // == 64/3 + 3 == 25
// CDL.h
// Code Downloader header file
//
// Read "class descriptions" first for understanding how the
// code downloader works.

#define STRING(x) (((x) != NULL) ? (x) : (L"(null)"))

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(array) \
	(sizeof(array)/sizeof(array[0]))
#endif /* ARRAY_ELEMENTS */

#include <safeocx.h>
#include "debmacro.h"
#include <msxml.h>
#include "wvtp.h"
//#include "..\inc\clist.hxx"
#ifndef unix
#include "..\utils\coll.hxx"
#else
#include "../utils/coll.hxx"
#endif /* !unix */
#include "packet.hxx"
#include "shlwapi.h"
#include "strids.h"

#include <pkgmgr.h>

#ifdef WX86
#ifdef __cplusplus            // make classes invisible to 'C'
// Support for multiple architectures during code download.  This must
// be declared before softdist.hxx can be included.
class CMultiArch {
public:
    CMultiArch() { m_RequiredArch = PROCESSOR_ARCHITECTURE_UNKNOWN; };
    DWORD   GetRequiredArch() { return m_RequiredArch;}
    HRESULT RequirePrimaryArch();
    HRESULT RequireAlternateArch();
    VOID    SelectArchitecturePreferences(
                char *szNativeArch,
                char *szIntelArch,
                char **pszPreferredArch,
                char **pszAlternateArch);

private:
    DWORD             m_RequiredArch;
};
#endif
#endif

#include "softdist.hxx"

#include <capi.h>

#define     MAX_REGSTR_LEN              1024

#define     DU_TAG_SOFTDIST             L"SOFTPKG"
#define     DU_TAG_NATIVECODE           L"msicd::NativeCode"
#define     DU_TAG_JAVA                 L"msicd::Java"
#define     DU_TAG_EXPIRE               L"msicd::Expire"

#define     DU_TAG_UNINSTALL_OLD        L"msicd::UninstallOld"
#define     INF_TAG_UNINSTALL_OLD       "UninstallOld"

#define     DU_TAG_CODE                 L"Code"
#define     DU_TAG_CODEBASE             L"CodeBase"
#define     DU_TAG_PACKAGE              L"Package"
#define     DU_TAG_TITLE                L"TITLE"
#define     DU_TAG_ABSTRACT             L"ABSTRACT"
#define     DU_TAG_LANG                 L"LANGUAGE"
#define     DU_TAG_DEPENDENCY           L"Dependency"
#define     DU_TAG_PROCESSOR            L"Processor"
#define     DU_TAG_PLATFORM             L"Platform"
#define     DU_TAG_CONFIG               L"IMPLEMENTATION"
#define     DU_TAG_USAGE                L"Usage"
#define     DU_TAG_OS                   L"OS"
#define     DU_TAG_OSVERSION            L"OSVersion"
#define     DU_TAG_NAMESPACE            L"NameSpace"
#define     DU_TAG_DELETEONINSTALL      L"DeleteOnInstall"

#define     DU_ATTRIB_NAME              L"NAME"
#define     DU_ATTRIB_FILENAME          L"FILENAME"
#define     DU_ATTRIB_VALUE             L"VALUE"
#define     DU_ATTRIB_VERSION           L"VERSION"
#define     DU_ATTRIB_STYLE             L"STYLE"
#define     DU_ATTRIB_SIZE              L"SIZE"
#define     DU_ATTRIB_PRECACHE          L"PRECACHE"
#define     DU_ATTRIB_AUTOINSTALL       L"AUTOINSTALL"
#define     DU_ATTRIB_EMAIL             L"EMAIL"
#define     DU_ATTRIB_HREF              L"HREF"
#define     DU_ATTRIB_ACTION            L"ACTION"
#define     DU_ATTRIB_CLSID             L"CLASSID"
#define     DU_ATTRIB_DL_GROUP          L"GROUP"
#define     DU_ATTRIB_RANDOM            L"RANDOM"

#define     DU_STYLE_MSICD              "MSICD"
#define     DU_STYLE_ACTIVE_SETUP       "ActiveSetup"
#define     DU_STYLE_MSINSTALL          "MSInstall.SoftDist"
#define     DU_STYLE_LOGO3              "MSAppLogo5"

#define     DU_TAG_SYSTEM               L"System"

// Used by JAVA
#define     DU_TAG_NEEDSTRUSTEDSOURCE   L"NeedsTrustedSource"

#define     CHANNEL_ATTRIB_BASE         L"BASE"

#define     MAX_EXPIRE_DAYS             3650

#ifdef __cplusplus
extern "C" {
#endif

#include "fdi.h"

#ifndef DEB_CODEDL
#define DEB_CODEDL   1
#endif

// JIT Window data

#define JIT_DIALOG_CLASS_NAME    "Internet Explorer_TridentDlgFrame"
#define JIT_DIALOG_CAPTION       "Internet Explorer Install on Demand"

// return value from the JIT setup page.
#define JITPAGE_RETVAL_SUCCESS              0x0     // successfully installed
#define JITPAGE_RETVAL_CANCELLED            0x1     // was cancelled by user
#define JITPAGE_RETVAL_DONTASK_THISWINDOW   0x2     // don;t ask again in this
                                                    // window
#define JITPAGE_RETVAL_DONTASK_EVER         0x3     // don't ask ever. user
                                                    // goes to addon page to
                                                    // install
#define JITPAGE_RETVAL_NEED_REBOOT          ERROR_SUCCESS_REBOOT_REQUIRED

// FaultInIEFeature flags
// urlmon.idl flag definition
// internal flags are here

#define FIEF_FLAG_CHECK_CIFVERSION      0x100       // checks if requested version
                                                    // can be installed by JIT

#define REGSTR_PATH_INFODEL_REST    "Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions"
#define REGVAL_JIT_REST             "NoJITSetup"
#define REGKEY_WEBJITURLS           "Software\\Microsoft\\Active Setup\\WebJITURLS"
#define REGVAL_WEBJIT_REST          "NoWebJITSetup"
#define REGVAL_UI_REST              "NoWinVerifyTrustUI"

// registry paths for ModuleUsage
#define REGSTR_PATH_SHAREDDLLS     "Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls"

#define REGSTR_PATH_MODULE_USAGE   "Software\\Microsoft\\Windows\\CurrentVersion\\ModuleUsage"

#define REGSTR_PATH_CODE_STORE   "Software\\Microsoft\\Code Store Database"
#define REGSTR_PATH_DIST_UNITS   "Software\\Microsoft\\Code Store Database\\Distribution Units"
#define REGSTR_PATH_JAVA_PKGS   "Software\\Microsoft\\Code Store Database\\Java Packages"

#define REGSTR_PATH_IE_SETTINGS     "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define REGSTR_PATH_IE_MAIN     "Software\\Microsoft\\Internet Explorer\\Main"

#define REGSTR_PATH_LOGO3_SETTINGS  "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
#define REGVAL_LOGO3_MAJORVERSION   "VersionMajor"
#define REGVAL_LOGO3_MINORVERSION   "VersionMinor"
#define REGSTR_LOGO3_ADVERTISED_VERSION "AdvertisedVersion"
#define REGKEY_LOGO3_AVAILABLE_VERSION "AvailableVersion"

#define REGSTR_PATH_NT5_LOCKDOWN_TEST    "Software\\Microsoft\\Code Store Database\\NT5LockDownTest"
#define REGVAL_USE_COINSTALL             "UseCoInstall"

// If you modify this then make appropriate entries in urlmon\dll\selfreg.inx
// to clean this out on urlmon dlluninstall
// this key will be renamed before ship of each major release
// so we won't remember the rejected features in PP1 and not prompt for final
// release

#define REGKEY_DECLINED_COMPONENTS     "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Declined Components IE5"

#define REGKEY_DECLINED_IOD   "Software\\Microsoft\\Active Setup\\Declined Install On Demand IEv5"

#define REGKEY_ACTIVESETUP_COMPONENTS   "Software\\Microsoft\\Active Setup\\Installed Components"
#define REGKEY_ACTIVESETUP              "Software\\Microsoft\\Active Setup"
#define REGKEY_ACTIVESETUP_CLSIDFEATURE   "Software\\Microsoft\\Active Setup\\ClsidFeature"
#define REGKEY_ACTIVESETUP_MIMEFEATURE   "Software\\Microsoft\\Active Setup\\MimeFeature"
#define REGKEY_ACTIVESETUP_FEATURECOMPID   "Software\\Microsoft\\Active Setup\\FeatureComponentID"
#define REGVAL_VERSION_AVAILABLE        "Version available"
#define REGVAL_VERSION_ADVERTISED        "Version advertised"
#define REGVAL_ABSTRACT_AVAILABLE        "Abstract"
#define REGVAL_TITLE_AVAILABLE        "Title available"
#define REGVAL_HREF_AVAILABLE        "HREF available"
#define REGVAL_FIRST_HOME_PAGE        "First Home Page"
#define REGKEY_MSICD_ADVERTISED_VERSION "AdvertisedVersion"
#define REGVAL_ADSTATE "AdState"

#define DISTUNIT_NAME_IE4       "{89820200-ECBD-11cf-8B85-00AA005B4383}"


// Code Download Setup Flags
// DWORD  g_dwCodeDownloadSetupFlags = 0;
typedef enum {
    CDSF_INIT,
    CDSF_USE_SETUPAPI
} CodeDownloadSetupFlags;

// buffer size for downloads in CBSC::m_cbuffer
#define BUFFERMAX 2048

// File Name List
//
// used as pFilesToExtract to track files in the CAB we need extracted
//
// or a pFileList in PSESSION
//
// We keep track of all files that are in a cabinet
// keeping their names in a list and when the download
// is complete we use this list to delete temp files

struct sFNAME {
    LPSTR               pszFilename;
    struct sFNAME       *pNextName;
    DWORD               status; /* out */
};

typedef struct sFNAME FNAME;
typedef FNAME *PFNAME;

// SFNAME.status: success is 0 or non-zero error code in extraction
#define SFNAME_INIT         1
#define SFNAME_EXTRACTED    0

// FILE extentions we know about
typedef enum {
    FILEXTN_NONE,
    FILEXTN_UNKNOWN,
    FILEXTN_CAB,
    FILEXTN_DLL,
    FILEXTN_OCX,
    FILEXTN_INF,
    FILEXTN_EXE,
    FILEXTN_OSD,
    FILEXTN_CAT
} FILEXTN;


//
// Master State Information for File Extraction: used by extract.c
//

typedef struct {
    UINT        cbCabSize;
    ERF         erf;
    PFNAME      pFileList;              // List of Files in CAB
    UINT        cFiles;
    DWORD       flags;                  // flags: see below for list
    char        achLocation[MAX_PATH];  // Dest Dir
    char        achFile[MAX_PATH];      // Current File
    char        achCabPath[MAX_PATH];   // Current Path to cabs
    PFNAME      pFilesToExtract;        // files to extract;null=enumerate only

} SESSION, *PSESSION;

typedef enum {
    SESSION_FLAG_NONE           = 0x0,
    SESSION_FLAG_ENUMERATE      = 0x1,
    SESSION_FLAG_EXTRACT_ALL    = 0x2,
    SESSION_FLAG_EXTRACTED_ALL  = 0x4
} SESSION_FLAGS;

typedef struct CodeDownloadDataTag {
    LPCWSTR      szDistUnit;       // Distribution unit to look for
    LPCWSTR      szClassString;    // clsid (or class string) of object desired
    LPCWSTR      szURL;            // codebase to download
    LPCWSTR      szMimeType;       // mime type (com translate -> clsid)
    LPCWSTR      szExtension;     // extension (com translate -> clsid)
    LPCWSTR      szDll;           // dll to load object from after download (for zero impact)
    DWORD       dwFileVersionMS;  // file version
    DWORD       dwFileVersionLS;
    DWORD       dwFlags;          // flags
} CodeDownloadData;

#define    chPATH_SEP1            '\\'
#define    chPATH_SEP2            '/'
#define    chDRIVE_SEP            ':'

// size of [Add.Code] section in INF in bytes
#define MAX_INF_SECTIONS_SIZE       1024

// from extract.c
HRESULT Extract(PSESSION psess, LPCSTR lpCabName);
HRESULT ExtractFromCabinet(PSESSION ps, LPCSTR lpCabFileName);
VOID DeleteExtractedFiles(PSESSION psess);
BOOL catDirAndFile(
    char    *pszResult, 
    int     cbResult, 
    char    *pszDir,
    char    *pszFile);

#ifdef __cplusplus
}
#endif

#define CHECK_ERROR_EXIT(cond, iResID) if (!(cond)) { \
        if (iResID) \
            CodeDownloadDebugOut(DEB_CODEDL, TRUE, iResID); \
        goto Exit;}

// Download states that a CDownload passes thru from obj creation to done.
typedef enum {
    DLSTATE_INIT,                  // obj constructed
    DLSTATE_BINDING,               // download in progress
    DLSTATE_DOWNLOADED,            // at begining of OnStopBinding
    DLSTATE_EXTRACTING,            // begin CAB extraction (where applicable)
    DLSTATE_INF_PROCESSING,        // begin ProcessInf (where applicable)
    DLSTATE_READY_TO_SETUP,        // end of OnStopBinding
    DLSTATE_SETUP,                 // Start DoSetup
    DLSTATE_DONE,                  // all done, ready to free obj,
                                   // delete temp files
    DLSTATE_ABORT                  // aborted this download
} DLSTATE;

// INSTALL_STATE used to give BINDSTATUS_INSTALLING_COMPONENTS OnProgress
// during setup phase
// given as INSTALL_COPY of INSTALL_PHASES, szStatusText pointing to filename

typedef enum {
    INSTALL_INIT = 0,
    INSTALL_VERIFY = 1,
    INSTALL_COPY = 2,
    INSTALL_REGISTER =3,
    INSTALL_PHASES = 4
} INSTALL_STATE;

#define INSTALL_DONE INSTALL_PHASES


// directions to CSetup on dest dir for file if no prev version exists
typedef enum {

    LDID_OCXCACHE=0,                // ocxcache dir, now = windows\ocxcache
    LDID_WIN=10,                    // INF convetion to mean windows dir
    LDID_SYS=11                     // INF convetion to mean sysdir

} DESTINATION_DIR ;


// Software distribution styles
typedef enum {
    STYLE_UNKNOWN = -1,             // Unknown otherwise.
    STYLE_MSICD = 1,
    STYLE_ACTIVE_SETUP,
    STYLE_LOGO3,
    STYLE_MSINSTALL,                // Darwin
    STYLE_OTHER                     // Provides own ISoftDistExt interface for access
};

#ifdef __cplusplus            // make classes invisible to 'C'

#include "langcode.h"

// <Config> tag processor.  Shared by Code Download and CSoftDist.
HRESULT ProcessImplementation(IXMLElement *pConfig,
                              CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList,
                              LCID lcidOverride,
#ifdef WX86
                              CMultiArch *MultiArch,
#endif
                              LPWSTR szBaseURL = NULL);
HRESULT ProcessCodeBaseList(IXMLElement *pCodeBase,
                            CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList,
                            LPWSTR szBaseURL = NULL);

// %%Classes: ----------------------------------------------------------------

/*
 *  class descriptions
 *
 *  CCodeDownload (main class tracking as a whole)
 *  It has the client's BSC and creates a CClBinding for client.
 *
 *  CClBinding (For client's IBinding for code download)
 *
 *  CDownload (tracks individual downloads) implements a
 *
 *  CBindStatusCallback (BSC)
 *
 *  Csetup obj: zero or more associated with every CDownload obj
 *  Some CDownload's may have no CSetup (eg. INF file)
 *
 *
 *
 *
 * We do our code download in 2 stages.
 * 1) download stage
 * 2) setup and registeration stage
 *
 * CCodeDownload is the main class for codedownload.
 * AsyncGetClassBits() the entry into the Code downloader creates this obj
 * for the given CODE, CLSID, FileVersion, BSC (from BindCtx)
 * we do not check to see if a code download is already in progress
 * in the system at a given moment. Nor we do we keep track of individual
 * downloads and possible clashes between various silmultaneous code
 * downloads system wide. We leave it to URL moniker (above us) to ensure
 * that duplicate calls are not made into AsynGetClassBits. The second
 * problem of different code downloads trying to bring down a common
 * dependent DLL is POSTPONED to version 2 implementation.
 *
 * The CodeDownload obj once created is asked to perform its function
 * thru CCodeDownload::DoCodeDownload().
 * This triggers creation of the first CDownload object for the CODE url
 * if a local check for CLSID,FileVersion returns update_needed.
 * (note : it is interesting to note here that if a control needs to just
 * update a dependent DLL file it still needs to update the FileVersion
 * of the primary control file (with CLSID implementation) for triggering
 * any download at all!
 *
 * Once DoCodeDownload determines that an update is in order it creates
 * a CClBinding for its client to call client BSC::OnstartBinding with.
 *
 * It then adds this CDownload obj to its list of downloads.
 *
 * If the m_url is a CAB or INF we need to download it before we know
 * what we need to do next. Otherwise we create a CSetup obj for the
 * download and add it to CDownload's list of pending Setup processing for
 * stage 2 (setup and registeration). CSetup details later.
 *
 * CDownload is the basic download obj. It's action entry point is DoDownload
 * Here it creates a URL moniker for the given m_url and a bind ctx to go
 * with it and then calls pmk->BindToStorage to get the bits. Note how we
 * use URL mon's services to get the bits even as URLmon is our client for
 * the Code Download. We are its client for individual downloads. CDownload
 * has a BSC implementation to track progress and completion. This BSC is
 * where the magic of taking us from one state to next occurs.
 *
 * BSC::OnProgress
 * Here we get the master CodeDownload obj to collate progress and report
 * cumulative code download progress to client BSC::OnProgress.
 *
 * BSC::OnDataAvailable
 * At the last notification we get the filename URLmon has downloaded the
 * m_url data to and rename it to a file in the temp dir.
 *
 * BSC:: OnStopBinding
 * we get here when we have fully downloaded 'this'. this is the place
 * to call into WinVerifyTrust api if appropriate
 * This triggers a change state in our state machine. Depending on the
 * obj we have downloaded (a CAB or INF or DLL/OCX/EXE) we:
 *
 * OCX:
 *    Csetup for this download is usually previously created
 *      mark this download as done and
 *    call into main CodeDownload::CompleteOne (state analyser)
 *
 * CAB:
 *    if we don't have an INF already we look for one in the CAB
 *           if INF in CAB
 *               process INF (may trigger further extractions/downloads/Csetup)
 *           else
 *              look for primary OCX in CAB and create CSetup or it.
 *
 * INF:
 *      Process INF
 *
 * CCodeDownload::CompleteOne is called whenever a CDownload obj completes
 * its download and initiates further downloads if necessary (eg. ProcessInf)
 * It does nothing until all pending downloads are complete. Until then it
 * just returns and we unwind back to BSC::OnStopBinding
 *
 * When all downloads completed, we then start processingall the Csetups
 * We do this code download in two stages to
 * keep capability to back out of entire code download for as late as we can
 * until the setup stage calling CClBinding::Abort with IBinding returned by
 * code downloader in client's BSC::OnStartBinding will cleanly abort and
 * restore initial state.
 * We don't honor Abort once in setup stage.
 *
 * To keep this stage as clean and failsafe as we can we check for
 * disk space in the OCX cache as well as check for IN USE OCXes that we
 * plan on updating. We abort on either of these two conditions.
 *
 * CCodeDownload::CompleteOne than proceeds to walk thru all its download objs
 * calling DoSetup which in turn causes CSetup::DoSetup() to get invoked
 * for every CSetup.
 *
 * In the guts of Csetup we move the temp OCX file to the dest dir ( usually
 * OCXCACHE dir unless upgrading over previous version), and we call
 * register OCX (if version info suggests so)
 *
 * When done with the setup stage CompleteOne calls client's BSC::OnStopBinding
 * and then frees all memory and clens up temp files.
 *
 */

class CLocalComponentInfo {
    public:

    CLocalComponentInfo();
    ~CLocalComponentInfo();
    HRESULT MakeDestDir();

    BOOL IsPresent() { return (dwLocFVMS | dwLocFVLS); }
    BOOL IsLastModifiedTimeAvailable() { 
        return ( ftLastModified.dwHighDateTime | ftLastModified.dwLowDateTime);
        }
    FILETIME * GetLastModifiedTime() {
        return IsLastModifiedTimeAvailable()?&ftLastModified:NULL;
        }

    LPSTR GetLocalVersionEtag() { return pbEtag;}

    LCID GetLocalVersionLCID() { return lcid; }

    // data members

    char            szExistingFileName[MAX_PATH];
    LPSTR           pBaseExistingFileName;
    LPSTR           lpDestDir;
    DWORD           dwLocFVMS;
    DWORD           dwLocFVLS;
    FILETIME        ftLastModified;
    LPSTR           pbEtag;
    LCID            lcid;
    BOOL            bForceLangGetLatest;
    DWORD           dwAvailMS;
    DWORD           dwAvailLS;
};

// CModuleUsage: created for every module added to ModuleUsage
// is walked thru and run after all setups are complete in COmpleteAll
// can also be used to optionally rollback a setup


class CModuleUsage {
  public:

    // constructor
    CModuleUsage(LPCSTR lpFileName, DWORD dwFlags, HRESULT *phr);
    ~CModuleUsage();

    HRESULT Update(LPCSTR szClientName);
    LPCSTR GetFileName() {return m_szFileName;}

    // data members

    LPSTR              m_szFileName;
    DWORD              m_dwFlags;
};

// CSetup: created for every setup item
// each CDownload has zero or more of these linked into a list

typedef enum {

                                            // the default behaviour for
                                            // registering a server is to do
                                            // so only when the version rsrc
                                            // has the string "OleSelfregister"
                                            // the user can override this
                                            // behaviour with setting in .INF
                                            // registerserver=yes/no

    CST_FLAG_REGISTERSERVER_OVERRIDE=1,      // when set user has overriden 
    CST_FLAG_REGISTERSERVER=2                // when set along with above
                                            // means user wants us to register
                                            // server

} CST_FLAGS;

class CDownload;

typedef enum {
    CJS_FLAG_INIT=0,
    CJS_FLAG_NOSETUP=1,                     // don't setup just mark that this
                                            // java package is used by this dist
                                            // unit.
    CJS_FLAG_SYSTEM=2,                      // system class
    CJS_FLAG_NEEDSTRUSTEDSOURCE=4,           // need trusted source
};

class CJavaSetup {
    public:

    CJavaSetup(
        CDownload *pdl,
        LPCWSTR szPackageName,
        LPCWSTR szNameSpace,
        IXMLElement *pPackage,
        DWORD dwVersionMS,
        DWORD dwVersionLS,
        DWORD flags,
        HRESULT *phr);

    ~CJavaSetup();

    HRESULT DoSetup();

    INSTALL_STATE GetState() const { return m_state;}
    VOID SetState(INSTALL_STATE state) { m_state = state;}

    LPCWSTR GetPackageName() { return m_szPackageName; }
    LPCWSTR GetNameSpace() { return m_szNameSpace; }
    void GetPackageVersion(DWORD &dwVersionMS, DWORD &dwVersionLS) {
        dwVersionMS = m_dwVersionMS; 
        dwVersionLS = m_dwVersionLS; 
    }
    DWORD GetPackageFlags() { return m_flags; }
    IXMLElement *GetPackageXMLElement() { return m_pPackage; }

    private:

    INSTALL_STATE      m_state;            // state of install operation
    CDownload*         m_pdl;
    LPWSTR             m_szPackageName;
    LPWSTR             m_szNameSpace;
    IXMLElement *      m_pPackage;
    DWORD              m_dwVersionMS;
    DWORD              m_dwVersionLS;
    DWORD              m_flags;
};

class CSetup {

  public:

    HRESULT DoSetup(CCodeDownload *pcdl, CDownload *pdl);

    LPCSTR GetSrcFileName() const {return m_pSrcFileName;}

    HRESULT SetSrcFileName(LPCSTR pSrcFileName);

    FILEXTN GetExtn() const {return m_extn;}

    CSetup *GetNext() const { return m_pSetupnext;}
    VOID SetNext(CSetup *pSetupnext) { m_pSetupnext = pSetupnext;}

    INSTALL_STATE GetState() const { return m_state;}
    VOID SetState(INSTALL_STATE state) { m_state = state;}

    LPCSTR GetBaseFileName() const { return m_pBaseFileName; }

    // constructor
    CSetup(LPCSTR pSrcFileName, LPCSTR pBaseFileName, FILEXTN extn, LPCSTR pDestDir, HRESULT *phr, DESTINATION_DIR dest = LDID_OCXCACHE);
    ~CSetup();

    HRESULT GetDestDir(CCodeDownload *pcdl, LPSTR szDestDir, int iLen);

    HRESULT CheckForNameCollision(CCodeDownload *pcdl, LPCSTR szCacheDir);

    HRESULT InstallFile(
        CCodeDownload *pcdl,
        LPSTR szDestDir,
        int iLen,
        LPWSTR szStatusText,
        LPUINT pcbStatusText);

    VOID SetCopyFlags(DWORD dwcf) {
        m_advcopyflags = dwcf;
    }

    VOID SetUserOverrideRegisterServer(BOOL fRegister) {
        m_flags |= CST_FLAG_REGISTERSERVER_OVERRIDE;
        if (fRegister) {
            m_flags |= CST_FLAG_REGISTERSERVER;
        }
    }

    BOOL UserOverrideRegisterServer() {
        return (m_flags & CST_FLAG_REGISTERSERVER_OVERRIDE); 
    }

    BOOL WantsRegisterServer() {
        return (m_flags & CST_FLAG_REGISTERSERVER); 
    }

    void SetExactVersion(BOOL bFlag) {m_bExactVersion = bFlag;}

  private:

    CSetup*            m_pSetupnext;

    LPSTR              m_pSrcFileName;     // fully qualified src file name
    LPSTR              m_pBaseFileName;    // base filename
    FILEXTN            m_extn;

    LPCSTR             m_pExistDir;        // dest dir for setting up obj
                                           // if null default to ocxcache dir

    INSTALL_STATE      m_state;            // state of install operation

    DESTINATION_DIR    m_dest;

    DWORD              m_flags;            // overrides for register server
    DWORD              m_advcopyflags;     // flags for AdvInstallFile
    BOOL m_bExactVersion;
};

// CClBinding to pass to client of CodeDownload in client's BSC::OnStartBinding

class CClBinding : public IBinding {

  public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBinding methods
    STDMETHOD(Abort)( void);
    STDMETHOD(Suspend)( void);
    STDMETHOD(Resume)( void);
    STDMETHOD(SetPriority)(LONG nPriority);
    STDMETHOD(GetPriority)(LONG *pnPriority);
    STDMETHOD(GetBindResult)(CLSID *pclsidProtocol, DWORD *pdwResult, LPWSTR *pszResult,DWORD *pdwReserved);


    CClBinding::CClBinding(
        CCodeDownload *pcdl,
        IBindStatusCallback *pAssClientBSC,
        IBindCtx *pAssClientBC,
        REFCLSID rclsid,
        DWORD dwClsContext,
        LPVOID pvReserved,
        REFIID riid,
        IInternetHostSecurityManager* m_pHostSecurityManager);

    ~CClBinding();

    HRESULT InstantiateObjectAndReport(CCodeDownload *pcdl);

    REFCLSID GetClsid() const { return m_clsid;}

    HRESULT ReleaseClient();

    DWORD GetState() const { return m_dwState;}
    VOID SetState(DWORD dwState) { m_dwState = dwState;}

    IBindStatusCallback* GetAssBSC() {return m_pAssClientBSC;}

    IBindCtx* GetAssBC() {return m_pAssClientBC;}

    ICodeInstall* GetICodeInstall(); // side-effect: sets m_pCodeInstall!
    IWindowForBindingUI* GetIWindowForBindingUI(); // side-effect: sets m_pWindowForBindingUI!

    IBindHost* GetIBindHost(); // side-effect: sets m_pBindHost!

    IInternetHostSecurityManager* GetHostSecurityManager();

    HWND GetHWND(REFGUID rguidReason = IID_ICodeInstall);

    HRESULT SetClassString(LPCWSTR pszClassString);
    const LPWSTR GetClassString();

    private:

    CLSID                m_clsid;
                                                // foll: for CoGetClassObject
    DWORD                m_dwClsContext;        // CLSCTX flags
    LPVOID               m_pvReserved;          // Must be NULL
    REFIID               m_riid;                // Usually IID_IClassFactory


    DWORD                m_cRef;
    LONG                 m_nPriority;     // priority of this binding
    DWORD                m_dwState;       // state of operation
    CCodeDownload*       m_pcdl;
    IBindStatusCallback* m_pAssClientBSC; // associated Client BSC
    IBindCtx*            m_pAssClientBC;  // associated client bind ctx


    IBindHost*           m_pBindHost;        // IBindHost

    IWindowForBindingUI* m_pWindowForBindingUI; // IWindowForBindingUI
                                                // passed in by client
                                                // to pass in hwnd for
                                                // WinVerifyTrust as well

    IInternetHostSecurityManager* m_pHostSecurityManager;

    ICodeInstall*        m_pCodeInstall;        // ICodeInstall
                                                // passed in by client
                                                // to pass in hwnd for
                                                // WinVerifyTrust as well
                                                // as handle module update
                                                // contingencies like
                                                // out of disk space and
                                                // permission to update
                                                // existing file with newer ver

    HWND                 m_hWnd;                // client hwnd obtained thru
                                                // ICodeInstall
                                                // ::NeedVerificationUI
                                                // safe to cache this?
    LPWSTR               m_wszClassString;
};


// CodeDownload states 
typedef enum
{
    CDL_NoOperation = 0,            // operation did not start yet
    CDL_Downloading,                // downloading in progress
    CDL_Suspend,                    // operation suspended
    CDL_Aborted,                    // operation aborted
    CDL_ReadyToSetup,               // ready to setup
    CDL_Setup,                      // setup in progress
    CDL_SetupDone,                  // setup done
    CDL_Completed                   // done, and complete signalled CompleteAll
} CDL_STATE;

// values for CCodeDownload::m_flags
//   these will be defined in objbase.h. For now make sure they are defined so we don't break the build
#ifndef CD_FLAGS_DEFINED
#define CD_FLAGS_DEFINED
typedef enum {
    CD_FLAGS_INIT =                     0x0,
    CD_FLAGS_FORCE_DOWNLOAD =           0x1,
    CD_FLAGS_PEEK_STATE =               0x2,
    CD_FLAGS_NEED_CLASSFACTORY =        0x4,
    CD_FLAGS_PARANOID_VERSION_CHECK =   0x8,
    CD_FLAGS_SKIP_DECLINED_LIST_CHECK = 0x20,
    CD_FLAGS_USE_CODEBASE_ONLY      =   0x80,  // Set by OLE32 Class Store
    CD_FLAGS_HINT_JAVA               =  0x100, // to turn off advance
                                               // disabling of code download
                                               // if ActiveX Signed+Unsigned 
                                               // is off unless this flag is
                                               // passed any distunit that looks
                                               // like a clsid will not code
                                               // download if ActiveX is off
    CD_FLAGS_HINT_ACTIVEX            =  0x200,
    CD_FLAGS_FORCE_INTERNET_DOWNLOAD =  0x400, // For OLE32 CoInstall

    // below are internal flags

    CD_FLAGS_WAITING_FOR_EXE =          0x40,
    CD_FLAGS_SILENTOPERATION =          0x800,
    CD_FLAGS_NEED_REBOOT =              0x1000,
    CD_FLAGS_BITS_IN_CACHE =            0x2000,
    CD_FLAGS_NEW_CONTEXT_MONIKER =      0x4000,
    CD_FLAGS_FAKE_SUCCESS =             0x8000,
    CD_FLAGS_DELETE_EXE =               0x10000,
    CD_FLAGS_UNSAFE_ABORT =             0x20000,
    CD_FLAGS_USER_CANCELLED =           0x40000,
    CD_FLAGS_HAVE_INF =                 0x80000,
    CD_FLAGS_ONSTACK =                  0x100000,
    CD_FLAGS_USED_CODE_URL =            0x200000,
    CD_FLAGS_EXACT_VERSION =            0x400000,
    CD_FLAGS_TRUST_SOME_FAILED =        0x800000
    

} CD_FLAGS;

#endif // CD_FLAGS_DEFINED

#define CD_FLAGS_EXTERNAL_MASK      (CD_FLAGS_FORCE_DOWNLOAD| \
                                     CD_FLAGS_PEEK_STATE| \
                                     CD_FLAGS_NEED_CLASSFACTORY| \
                                     CD_FLAGS_PARANOID_VERSION_CHECK| \
                                     CD_FLAGS_SKIP_DECLINED_LIST_CHECK| \
                                     CD_FLAGS_USE_CODEBASE_ONLY| \
                                     CD_FLAGS_HINT_JAVA| \
                                     CD_FLAGS_HINT_ACTIVEX| \
                                     CD_FLAGS_FORCE_INTERNET_DOWNLOAD)

class CDownload;
class DebugLogElement;
class CDLDebugLog;

// main class
class CCodeDownload {

    public:

    // constructor
    CCodeDownload(
        LPCWSTR szDistUnit,
        LPCWSTR szURL,
        LPCWSTR szType, 
        LPCWSTR szExt, 
        DWORD dwFileVersionMS,
        DWORD dwFileVersionLS,
        HRESULT *phr);

    ~CCodeDownload();

    HRESULT DoCodeDownload(
        CLocalComponentInfo *plci,
        DWORD flags);

    HRESULT CCodeDownload::CreateClientBinding(
        CClBinding **ppClientBinding,
        IBindCtx* pClientBC,
        IBindStatusCallback* pClientbsc,
        REFCLSID rclsid,
        DWORD dwClsContext,
        LPVOID pvReserved,
        REFIID riid,
        BOOL fAddHead,
        IInternetHostSecurityManager *pHostSecurityManager);

    int GetCountClientBindings() const {
        return m_pClientbinding.GetCount();
    }

    CClBinding* GetClientBinding() const {
        return m_pClientbinding.GetHead();
    }

    IBindStatusCallback* GetClientBSC() const {
        return (GetClientBinding())->GetAssBSC();
    }

    IBindCtx* GetClientBC() const {
        return (GetClientBinding())->GetAssBC();
    }

    REFCLSID GetClsid() const {
        return (GetClientBinding())->GetClsid();
    }

    CDownload* GetDownloadHead() const {
        return m_pDownloads.GetHead();
    }

    VOID AddDownloadToList(CDownload *pdl);

    HRESULT FindDupCABInThread(IMoniker *pmk, CDownload **ppdlMatch);
    HRESULT FindCABInDownloadList(LPCWSTR szURL, CDownload *pdlHint, CDownload **ppdlMatch);

    VOID CompleteOne(CDownload *pdl, HRESULT hrOSB, HRESULT hrStatus, HRESULT hrResponseHdr, LPCWSTR szError);

    VOID CompleteAll(HRESULT hr, LPCWSTR szError);

    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    HRESULT ProcessHooks(CDownload *pdl);
    HRESULT ProcessHookSection(LPCSTR lpCurHook, CDownload *pdl);

    HRESULT GetSatelliteName( LPSTR lpCurCode, int iLen);

    BOOL IsSectionInINF(LPCSTR lpCurCode);

    HRESULT GetInfCodeLocation( LPCSTR lpCurCode, LPSTR szURL);

    HRESULT GetInfSectionInfo(
        LPSTR lpCurCode,
        int iLen,
        LPSTR szURL,
        LPCLSID *plpClsid,
        LPDWORD pdwFileVersionMS,
        LPDWORD pdwFileVersionLS,
        DESTINATION_DIR *pdest,
        LPDWORD pdwRegisterServer,
        LPDWORD pdwCopyFlags,
        BOOL *pbDestDir
        );

    HRESULT SetupInf(const char *szInf, char *szInfBaseName,CDownload *pdl);

    VOID ProcessInf(CDownload *pdl);

    HRESULT ParseOSD(const char *szOSD, char *szOSDBaseName, CDownload *pdl);

    HRESULT QueueModuleUsage( LPCSTR szFileName, LONG muFlags);
    HRESULT UpdateModuleUsage();

    HRESULT StartDownload(
        LPSTR szCurCode,
        CDownload *pdl,
        LPSTR szURL,
        DESTINATION_DIR dest,
        LPSTR szDestDir,
        DWORD dwRegisterServer,
        DWORD dwCopyFlags,
        CList <CCodeBaseHold *, CCodeBaseHold *> *pcbhList = NULL);

    BOOL HaveManifest() {return (HaveInf() || GetOSD());}

    BOOL NeedToReboot() const {return (m_flags & CD_FLAGS_NEED_REBOOT);}
    VOID SetRebootRequired() {m_flags |= CD_FLAGS_NEED_REBOOT;}

    BOOL IsSilentMode() const {return (m_flags & CD_FLAGS_SILENTOPERATION);}
    VOID SetSilentMode() {m_flags |= CD_FLAGS_SILENTOPERATION;}

    BOOL IsAllTrusted() const {return ((m_flags & CD_FLAGS_TRUST_SOME_FAILED) == 0);}
    VOID SetTrustSomeFailed() {m_flags |= CD_FLAGS_TRUST_SOME_FAILED;}

    BOOL ForceDownload() const {return (m_flags & CD_FLAGS_FORCE_DOWNLOAD);}

    BOOL HaveInf() const {return (m_flags & CD_FLAGS_HAVE_INF);}
    VOID SetHaveInf() {m_flags |= CD_FLAGS_HAVE_INF;}

    BOOL UsedCodeURL() const {return (m_flags & CD_FLAGS_USED_CODE_URL);}
    VOID SetUsedCodeURL() {m_flags |= CD_FLAGS_USED_CODE_URL;}

    BOOL SafeToAbort() const {return ((m_flags & CD_FLAGS_UNSAFE_ABORT) == 0);}
    VOID SetUnsafeToAbort() {m_flags |= CD_FLAGS_UNSAFE_ABORT;}

    BOOL BitsInCache() const {return (m_flags & CD_FLAGS_BITS_IN_CACHE);}
    VOID SetBitsInCache() {m_flags |= CD_FLAGS_BITS_IN_CACHE;}

    BOOL FakeSuccess() const {return (m_flags & CD_FLAGS_FAKE_SUCCESS);}
    VOID SetFakeSuccess() {m_flags |= CD_FLAGS_FAKE_SUCCESS;}

    HRESULT HandleUnSafeAbort();

    BOOL NeedObject() const {return (m_flags & CD_FLAGS_NEED_CLASSFACTORY);}
    VOID SetNeedObject(DWORD fl) { m_flags |= (fl & CD_FLAGS_NEED_CLASSFACTORY);}

    BOOL UseCodebaseOnly() const {return (m_flags & CD_FLAGS_USE_CODEBASE_ONLY);}
    VOID SetUseCodebaseOnly(DWORD fl) { m_flags |= (fl & CD_FLAGS_USE_CODEBASE_ONLY);}

    BOOL RelContextMk() {return (m_flags & CD_FLAGS_NEW_CONTEXT_MONIKER);}
    VOID MarkNewContextMoniker() {m_flags |= CD_FLAGS_NEW_CONTEXT_MONIKER;}
    VOID ResetNewContextMoniker() {m_flags &= ~CD_FLAGS_NEW_CONTEXT_MONIKER;}

    BOOL WaitingForEXE() {return (m_flags & CD_FLAGS_WAITING_FOR_EXE);}
    VOID SetNotWaitingForEXE() {m_flags &= ~CD_FLAGS_WAITING_FOR_EXE;}

    BOOL UserCancelled() {return (m_flags & CD_FLAGS_USER_CANCELLED);}
    VOID SetUserCancelled() {m_flags |= CD_FLAGS_USER_CANCELLED;}

    BOOL IsOnStack() const {return (m_flags & CD_FLAGS_ONSTACK);}
    BOOL SetOnStack() {
            if (IsOnStack()) {
                return FALSE;
            } else {
                m_flags |= CD_FLAGS_ONSTACK;
                return TRUE;
            }
        }

    VOID ResetOnStack() {m_flags &= ~CD_FLAGS_ONSTACK;}

    BOOL SkipDeclinedListCheck() const {return (m_flags & CD_FLAGS_SKIP_DECLINED_LIST_CHECK);}

    BOOL DeleteEXEWhenDone() {return (m_flags & CD_FLAGS_DELETE_EXE);}
    VOID SetDeleteEXEWhenDone() {m_flags |= CD_FLAGS_DELETE_EXE;}
    VOID ResetDeleteEXEWhenDone() {m_flags &= ~CD_FLAGS_DELETE_EXE;}

    HRESULT SetWaitingForEXE(LPCSTR szStatusText, BOOL bDeleteEXEWhenDone);
    VOID SetWaitingForEXEHandle(HANDLE hEXE) {m_pi.hProcess = hEXE;}

    LPSTR GetDestDirHint() const { return m_plci->lpDestDir;}
    BOOL LocalVersionPresent() const { return m_plci->IsPresent();}
    FILETIME * GetLastModifiedTime() { return m_plci->GetLastModifiedTime();}

    VOID InitLastModifiedFromDistUnit();

    IMoniker* GetContextMoniker() const {return m_pmkContext;}
    VOID SetContextMoniker(IMoniker* pmk) {m_pmkContext = pmk;}

    ICodeInstall* GetICodeInstall() const { 
        return GetClientBinding()->GetICodeInstall();
    }

    LPCWSTR GetMainURL() const { return m_url;}
    LPCWSTR GetMainDistUnit() const { return m_szDistUnit;}
    LPCWSTR GetMainType() const { return m_szType;}
    LPCWSTR GetMainExt() const { return m_szExt;}

    LPCSTR GetCacheDir() const { return m_szCacheDir;}
    HRESULT ResolveCacheDirNameConflicts();

    void SetExactVersion(BOOL bExactVersion) { m_bExactVersion = bExactVersion;
                                               if (m_bExactVersion) {
                                                   m_bUninstallOld = TRUE; // implied
                                               }
                                             }

    VOID SetListCookie(LISTPOSITION pos) {m_ListCookie = pos;}
    LISTPOSITION GetListCookie() const {return m_ListCookie;}

    HRESULT AcquireSetupCookie();
    HRESULT RelinquishSetupCookie();

    HRESULT PiggybackDupRequest(
        IBindStatusCallback *pDupClientBSC,
        IBindCtx *pbc,
        REFCLSID rclsid, 
        DWORD dwClsContext,
        LPVOID pvReserved,
        REFIID riid);

    BOOL GenerateErrStrings(HRESULT hr, char **ppszErrMsg, WCHAR **ppwszError);

    static HRESULT CCodeDownload::AnyCodeDownloadsInThread();

    static HRESULT CCodeDownload::HasUserDeclined( 
        LPCWSTR szDistUnit, 
        LPCWSTR szType, 
        LPCWSTR szExt, 
        IBindStatusCallback *pClientBSC,
        IInternetHostSecurityManager *pHostSecurityManager);

    static HRESULT CCodeDownload::HandleDuplicateCodeDownloads( 
        LPCWSTR szURL, 
        LPCWSTR szType, 
        LPCWSTR szExt, 
        REFCLSID rclsid, 
        LPCWSTR szDistUnit, 
        DWORD dwClsContext,
        LPVOID pvReserved,
        REFIID riid,
        IBindCtx* pbc,
        IBindStatusCallback *pDupClientBSC,
        DWORD dwFlags,
        IInternetHostSecurityManager *pHostSecurityManager);

    HRESULT CCodeDownload::SetUserDeclined();

    HRESULT IsDuplicateHook(LPCSTR szHook);
    HRESULT IsDuplicateJavaSetup( LPCWSTR szPackage);

    HRESULT ProcessJavaManifest(IXMLElement *pJava, const char *szOSD, char *szOSDBaseName, CDownload *pdl);
    HRESULT ProcessDependency(CDownload *pdl, IXMLElement *pDepend);
    HRESULT ProcessNativeCode(CDownload *pdl, IXMLElement *pCode);
    HRESULT ExtractInnerCAB(CDownload *pdl, LPSTR szCABFile);
    HRESULT AddDistUnitList(LPWSTR szDistUnit);

    VOID DoSetup();

    HRESULT DealWithExistingFile(
        LPSTR szExistingFile,
        DWORD cbExistingFile,
        LPSTR pBaseExistingName,
        LPSTR *ppDestDir,
        LPDWORD pdwLocFVMS,
        LPDWORD pdwLocFVLS,
        FILETIME *pftLastModified = NULL);

    BOOL NeedLatestVersion() { 
        return (( m_dwFileVersionMS == -1) && (m_dwFileVersionLS == -1));
    }
    LPSTR GetEtag() { return m_pbEtag;}
    VOID SetEtag(LPSTR szEtag) { m_pbEtag = szEtag;}
    LPSTR GetLocalVersionEtag() { return m_plci->GetLocalVersionEtag();}

    LPSTR GetLastMod() { return m_szLastMod[0]?m_szLastMod:NULL;}
    VOID SetLastModifiedTime(LPCSTR szLastMod) {
        lstrcpy(m_szLastMod, szLastMod);
    }

    HRESULT DelayRegisterOCX(LPCSTR pszSrcFileName, FILEXTN extn);

    HRESULT InstallOCX(LPCSTR lpSrcFileName, FILEXTN extn, BOOL fLocalServer);
    HRESULT RegisterPEDll( LPCSTR lpSrcFileName);

#ifdef WX86
    HRESULT RegisterWx86Dll( LPCSTR lpSrcFileName);
    CMultiArch *GetMultiArch() { return &m_MultiArch; }
#endif

    // BUGBUG: put these three in a SearchPath class
    HRESULT SetupCODEUrl(LPWSTR *ppDownloadURL, FILEXTN *pextn);

    HRESULT GetNextComponent( LPSTR szList, LPSTR *ppCur);

    HRESULT GetNextOnInternetSearchPath(
                REFCLSID rclsid,
                HGLOBAL *phPostData,
                DWORD *pcbPostData,
                LPWSTR szURL,
                DWORD dwSize,
                LPWSTR *ppDownloadURL,
                FILEXTN *pextn);

    HRESULT SelfRegEXETimeout();

    HRESULT AbortBinding(CClBinding *pbinding);

    BOOL WeAreReadyToSetup();

    LPCSTR GetMainInf() { return m_szInf;}
    LPCSTR GetOSD() { return m_szOSD;}
    LCID GetLCID() { return m_lcid;}

    BOOL VersionFromManifest(LPSTR szVersionInManifest, int iLen);

    HRESULT SetManifest(FILEXTN extn, LPCSTR szManifest);

    CLangInfo *GetLangInfo() { return &m_langinfo;}
    void CodeDownloadDebugOut(int iOption, BOOL fOperationFailed,
                              UINT iResId, ...);

    HRESULT IsPackageLocallyInstalled(LPCWSTR szPackageName, LPCWSTR szNameSpace, DWORD dwVersionMS, DWORD dwVersionLS);

    IJavaPackageManager * GetPackageManager() { return m_pPackageManager;}
    HRESULT SetCatalogFile(LPSTR szCatalogFile);
    LPSTR GetCatalogFile();
    HRESULT SetMainCABJavaTrustPermissions(PJAVA_TRUST pbJavaTrust);
    PJAVA_TRUST GetJavaTrust();
    void SetDebugLog(CDLDebugLog * debuglog);
    
    void SetCatalogInstalled()
    {
        m_bCatalogInstalled = TRUE;
    }

    BOOL IsCatalogInstalled()
    {
        return m_bCatalogInstalled;
    }

    void SetAtom(ATOM atom)
    {
        if(m_atom)
            DeleteAtom(m_atom);
        m_atom = atom;
    }
    
    HRESULT VerifyFileAgainstSystemCatalog(LPCSTR pFileName, LPWSTR pwszFullCatalogPath, DWORD* pdwBuffer)
    {
        return m_wvt.VerifyFileAgainstSystemCatalog(pFileName, pwszFullCatalogPath, pdwBuffer);
    }

    BOOL FileProtectionCheckSucceeded(LPCSTR lpszExistingFileName);

    BOOL IsFileProtected(LPCSTR pFileName);

    private:

    CDL_STATE GetState() const { return m_state;}
    VOID SetState(CDL_STATE state) { m_state = state;}

    HRESULT UpdateFileList(HKEY hKeyContains);
    HRESULT UpdateDependencyList(HKEY hKeyContains);
    HRESULT UpdateJavaList(HKEY hKeyContains);
    HRESULT UpdateDistUnit(CLocalComponentInfo *plci);
    HRESULT UpdateLanguageCheck(CLocalComponentInfo *plci);

    void DumpDebugLog(char *szCacheFileName, LPTSTR szErrorMsg, HRESULT hrError);
    void DestroyPCBHList(CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList);

    DWORD                m_cRef;

    CDL_STATE            m_state;               // state of code download

    LPWSTR               m_url;
    LPWSTR               m_szDistUnit;
    LPWSTR               m_szType;
    LPWSTR               m_szExt;
    LPSTR                m_szDisplayName;
    LPSTR                m_szVersionInManifest;

    IMoniker*            m_pmkContext;          // first download's pmk
                                                // becomes the context
                                                // for handling subsequent
                                                // relative URLs

    DWORD                m_dwFileVersionMS;     // little quirky that
    DWORD                m_dwFileVersionLS;     // this really the primary
                                                // control's fileversion
                                                // can really be something
                                                // else if deemed appropriate
                                                // eg: subversion of clsid

    LCID                 m_lcid;                // cache lcid client needs
                                                // this is pulled out of the
                                                // bindctx (BIND_OPTS2)

    CList<CModuleUsage*,CModuleUsage*>          // linked list of module usage
                         m_ModuleUsage;         // entries to add

    CList<CClBinding*,CClBinding*>              // linked list of client
                         m_pClientbinding;      // IBindings

    CList<CDownload*,CDownload*>                // linked list of CDownload
                         m_pDownloads;          // pieces

    CList<LPWSTR,LPWSTR>                      // linked list of dependent
                         m_pDependencies;       // distribution units

    DWORD                m_flags;               // provision for hacks :)
                                                // used internally now to
                                                // mark if we have an INF file
                                                // and if safe to abort

    LPSTR                m_szInf;               // INF filename if one exists
    LPSTR                m_szOSD;               // INF filename if one exists

    LPSTR                m_szCacheDir;          // OCCACHE dir that is setup
                                                // for each code download
                                                // is usually = g_szOCXCacheDir
                                                // but if a name conflict arises
                                                // it can be OCCACHE\CONFLICT.n



    LPSTR                m_pAddCodeSection;     // Add.Code section in INF
                                                // bunch of null terminated
                                                // strings, last one double
                                                // null terminated (like env)
    LPSTR                m_pCurCode;            // points at what ProcessInf
                                                // is pending processing

    HKEY                 m_hKeySearchPath;      // key to REGSTR_PATH_ISP

    LPSTR                m_pSearchPath;         // List of searchpath comps
    LPSTR                m_pSearchPathNextComp; // pointer into list above at
                                                // current component

    CLangInfo            m_langinfo;

    LPSTR                m_szWaitForEXE;        // str that points to name of
                                                // self registering EXE that we
                                                // are waiting now to complete
                                                // This is used to give
                                                // detailed CodeInstallProblem
                                                // when we get a ClientBinding::
                                                // Abort wahile waiting for an
                                                // EXE to complete setup/reg

    PROCESS_INFORMATION  m_pi;                  // PI for the currently self-
                                                // registering EXE that we
                                                // are running

    LISTPOSITION         m_ListCookie;          // cookie to remove this
                                                // download from the per-thread
                                                // list of CCodeDownload's in
                                                // progress (CList)

    HRESULT              m_hr;                  // hr to pass to CompleteAll
                                                // this store away the first
                                                // real failure code in a 
                                                // multipart code download


    char                 m_szLastMod[INTERNET_RFC1123_BUFSIZE+1];
                                                // last modified date of the
                                                // main URL (typically CODEBASE
                                                // or the URL redirected by
                                                // Object Index). We save this
                                                // with the dist unit DB to use
                                                // later for Get Latest.

    DWORD               m_dwExpire;             // number of days before DU eligible
                                                // for scavenging.

    DWORD               m_dwSystemComponent;

    char                *m_pbEtag;

    CLocalComponentInfo* m_plci;

    IJavaPackageManager* m_pPackageManager;     // Java pkg mgr

    DWORD                m_grfBINDF;
    CList<CCodeBaseHold *, CCodeBaseHold *> *m_pcbhList;
    LPSTR                m_szCatalogFile;
    BOOL                 m_bCatalogInstalled;
    ATOM                 m_atom;
    PJAVA_TRUST          m_pbJavaTrust;
    CDLDebugLog      *   m_debuglog;

    BOOL  m_bUninstallOld;
    BOOL  m_bExactVersion;
    HMODULE m_hModSFC;

    Cwvt  m_wvt;

#ifdef WX86
    CMultiArch        m_MultiArch;
#endif
};

class DebugLogElement {
    public:
        DebugLogElement() : m_szMessage(NULL) {}
        DebugLogElement(LPSTR szMessage);
        DebugLogElement(const DebugLogElement &ref);
        virtual ~DebugLogElement();

    public:
        LPCSTR GetLogMessage() { return m_szMessage; }
        HRESULT SetLogMessage(LPSTR szMessage);

    private:
        LPSTR           m_szMessage;
};


// Class to make a debug log and pass out error messages

// Note reguarding wide strings vs. ANSI:
// For file-write compatiblity, the private strings of CDLDebugLog
// are stored as multibyte, but the primary accessors (the private
// variables in CCodeDownLoad) are wide characters.  Hence, the
// return values for the accesors are Multibyte, since these are used
// primarily by this class, while the set parameters are wide character
class CDLDebugLog {
    public:
        ~CDLDebugLog();

        // Name accessor functions
        // Return the current value for the requested name (may be "")
        LPCTSTR              GetMainClsid()  {return m_szMainClsid;}
        LPCTSTR              GetMainType()   {return m_szMainType;}
        LPCTSTR              GetMainExt()    {return m_szMainExt;}
        LPCTSTR              GetMainUrl()    {return m_szMainUrl;}
        LPCTSTR              GetFileName()   {return m_szFileName;}
        LPCTSTR              GetUrlName()    {return m_szUrlName;}

        // Functions to access or output error messages
        void                 DebugOut(int iOption, BOOL fOperationFailed,
                                      UINT iResId, ...);
        void                 DebugOutPreFormatted(int iOption, BOOL fOperationFailed,
                                                  LPTSTR szDebugString);
        void                 DumpDebugLog(LPTSTR pszCacheFileName, int cbBufLen, 
                                          LPTSTR szErrorMsg, HRESULT hrError);

        // Deletion and Initialization functions
        void                 Clear();
        BOOL                 Init(CCodeDownload * pcdl);
        BOOL                 Init(LPCWSTR wszMainClsid, LPCWSTR wszMainType, 
                                  LPCWSTR wszMainExt, LPCWSTR wszMainUrl);
        void                 MakeFile();


        // Static functions for storing and accessing stored debug logs
        static void          AddDebugLog(CDLDebugLog * dlog);
        static void          RemoveDebugLog(CDLDebugLog * dlog);
        static CDLDebugLog * GetDebugLog(LPCWSTR wszMainClsid, LPCWSTR wszMainType, 
                                         LPCWSTR wszMainExt, LPCWSTR wszMainUrl);
        // Static functions for saving an error message for the download                            
        static BOOL          SetSavedMessage(LPCTSTR szMessage, BOOL bOverwrite);                             
        static LPCTSTR       GetSavedMessage();

        // Static function for debug log construction
        static CDLDebugLog * MakeDebugLog();

        // Com-type add and release functions
        int AddRef();
        int Release();

    private:

        CDLDebugLog();
        CList<DebugLogElement *, DebugLogElement *> 
                               m_DebugLogList;
        BOOL                   m_fAddedDebugLogHead;
        TCHAR                  m_szFileName[INTERNET_MAX_URL_LENGTH];
        TCHAR                  m_szUrlName[INTERNET_MAX_URL_LENGTH];
        TCHAR                  m_szMainClsid[MAX_DEBUG_STRING_LENGTH];
        TCHAR                  m_szMainType[MAX_DEBUG_STRING_LENGTH];
        TCHAR                  m_szMainExt[MAX_DEBUG_STRING_LENGTH];
        TCHAR                  m_szMainUrl[INTERNET_MAX_URL_LENGTH];

        // Support addref and release
        int m_iRefCount;

        // List and mutex for stored CDLDebugLog's
        static CList<CDLDebugLog *, CDLDebugLog *>
                               s_dlogList;
        static CMutexSem       s_mxsDLogList;
        static CMutexSem       s_mxsMessage;

        // Saved error message
        static TCHAR           s_szMessage[];
        static BOOL            s_bMessage;

};



// values for CDownload::m_flags
typedef enum {
    DL_FLAGS_INIT =                     0x0,
    DL_FLAGS_TRUST_VERIFIED=            0x1,
    DL_FLAGS_EXTRACT_ALL=               0x2,
    DL_FLAGS_CDL_PROTOCOL=              0x4         // using cdl:// to kick off DL
} DL_FLAGS;

class CParentCDL {

    public:

    CParentCDL(CCodeDownload *pcdl) {m_pcdl = pcdl;m_bCompleteSignalled = FALSE;}

    CCodeDownload*  m_pcdl;
    BOOL            m_bCompleteSignalled;
};

class CBindStatusCallback;
class CSetupHook;

// one for each individual downloads
class CDownload {

  public:

    // constructor
    CDownload(LPCWSTR szURL, FILEXTN extn, HRESULT *phr);
    ~CDownload();

    void CDownload::CleanUp();

    HRESULT AddParent(CCodeDownload *pcdl);
    HRESULT ReleaseParent(CCodeDownload *pcdl);

    HRESULT CompleteSignal(HRESULT hrOSB, HRESULT hrStatus, HRESULT hrResponseHdr, LPCWSTR szError);

    HRESULT DoDownload(LPMONIKER *ppmkContext, DWORD grfBINDF,
                      CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList = NULL);

    HRESULT Abort(CCodeDownload *pcdl);

    BOOL IsSignalled(CCodeDownload *pcdl);

    //  for each in list CSetup::DoSetup
    HRESULT DoSetup();

    BOOL IsDuplicateSetup(LPCSTR pBaseFileName);

    // called by CBSC::OnStopBinding as soon as the binding completes
    VOID ProcessPiece();

    // for each in list CSetup::CheckForNameCollision
    HRESULT CheckForNameCollision(LPCSTR szCacheDir);

    HRESULT CleanupFiles();

    CDownload *GetNext() const { return m_pdlnext;}
    VOID SetNext(CDownload *pdlnext) { m_pdlnext = pdlnext;}

    CSetup* GetSetupHead() const {return m_pSetuphead;}
    VOID AddSetupToList(CSetup *pSetup);
    HRESULT RemoveSetupFromList(CSetup *pSetup);

    HRESULT AddHook(
        LPCSTR szHook,
        LPCSTR szInf,
        LPCSTR szInfSection,
        DWORD flags);

    HRESULT AddSetupToExistingCAB(
        char *lpCode,
        const char * szDestDir,
        DESTINATION_DIR dest,
        DWORD dwRegisterServer,
        DWORD dwCopyFlags);

    CCodeDownload* GetCodeDownload() const { return (m_ParentCDL.GetHead())->m_pcdl;}

    CBindStatusCallback* GetBSC() const { return  m_pbsc;}
    IBindCtx* GetBindCtx() const { return m_pbc;}

    VOID SetUnkForCacheFileRelease(IUnknown *pUnk) {m_pUnkForCacheFileRelease = pUnk;}

    LPCSTR GetFileName() const { return m_pFileName;}
    VOID SetFileName(LPSTR pFileName) { m_pFileName = pFileName;}

    HRESULT IsDownloadedVersionRequired();

    LPCWSTR GetURL() const { return m_url;}

    HRESULT GetFriendlyName(LPSTR szUrlPath, LPSTR *ppBaseFileName);

    IMoniker* GetMoniker() const {return m_pmk;}

    HRESULT SetURLAndExtn(LPCWSTR szURL, FILEXTN extn);

    HRESULT SniffType();

    FILEXTN    GetExtn() const {return m_extn;}
    PFNAME GetFilesToExtract() const { return m_pFilesToExtract;}

    DLSTATE GetDLState() const { return m_state;}
    VOID SetDLState(DLSTATE state) 
    {  
        m_state = state;
    }

    VOID SetProgress(ULONG ulProgress, ULONG ulProgressMax) { m_ulProgress = ulProgress; m_ulProgressMax = ulProgressMax;}
    VOID SumProgress(ULONG *pulProgress, ULONG *pulProgressMax) { *pulProgress += m_ulProgress; *pulProgressMax += m_ulProgressMax;}


    PSESSION GetSession() const { return m_psess;}
    VOID SetSession(PSESSION psess) { m_psess = psess;}

    HGLOBAL GetPostData(DWORD *pcbPostData) const {
            *pcbPostData = m_cbPostData;
            return m_hPostData;
            }

    VOID    SetPostData(HGLOBAL hPostData, DWORD cbPostData) {
            m_hPostData = hPostData;
            m_cbPostData = cbPostData;
            }
    BOOL DoPost() const { return (m_hPostData != NULL);}

    HRESULT GetResponseHeaderStatus() const {return m_hrResponseHdr;}
    VOID SetResponseHeaderStatus( HRESULT hrResponseHdr) {
            m_hrResponseHdr = hrResponseHdr;}

    VOID VerifyTrust();

    BOOL TrustVerified() const {return (m_flags & DL_FLAGS_TRUST_VERIFIED);}
    VOID SetTrustVerified() {m_flags |= DL_FLAGS_TRUST_VERIFIED;}

    BOOL NeedToExtractAllFiles() const {return(m_flags & DL_FLAGS_EXTRACT_ALL);}
    VOID SetNeedToExtractAll() {m_flags |= DL_FLAGS_EXTRACT_ALL;}

    BOOL UsingCdlProtocol() const {return(m_flags & DL_FLAGS_CDL_PROTOCOL);}
    HRESULT SetUsingCdlProtocol(LPWSTR szDistUnit);
    LPWSTR GetDistUnitName() const {return(m_wszDistUnit);}

    HRESULT ExtractManifest(FILEXTN extn, LPSTR szFileName, LPSTR& pBaseFileName);

    CSetupHook* FindHook(LPCSTR szHook);
    CJavaSetup* FindJavaSetup(LPCWSTR szPackageName);

    HRESULT AddJavaSetup(LPCWSTR szPackageName, LPCWSTR szNameSpace, IXMLElement *pPackage, DWORD dwVersionMS, DWORD dwVersionLS, DWORD flags);
    CList<CJavaSetup*,CJavaSetup*> *GetJavaSetupList() { return &m_JavaSetupList;}
    BOOL HasJavaPermissions();
    BOOL HasAllActiveXPermissions();
    PJAVA_TRUST GetJavaTrust() {return m_pbJavaTrust;}

    HRESULT PerformVirusScan(LPSTR szFileName);

    STDMETHODIMP DownloadRedundantCodeBase();
    HRESULT SetMainCABJavaTrustPermissions(PJAVA_TRUST pbJavaTrust);

    void SetExactVersion(BOOL bFlag) {m_bExactVersion = bFlag;}

  private:

    LPWSTR               m_url;
    FILEXTN              m_extn;
    LPSTR                m_pFileName;        // filename in temp once downloaded
    
    IMoniker*            m_pmk;
    IBindCtx*            m_pbc;

    IUnknown*            m_pUnkForCacheFileRelease;

    CBindStatusCallback* m_pbsc;

    CDownload*           m_pdlnext;

    CList<CParentCDL *,CParentCDL *>             // linked list of CCodeDownloads
                         m_ParentCDL;        // that have interest in us

    ULONG                m_ulProgress;
    ULONG                m_ulProgressMax;

    DLSTATE              m_state;

    PSESSION             m_psess;            // CAB extraction struc
    PFNAME               m_pFilesToExtract;  // applicable only for CAB objs

    CSetup*              m_pSetuphead;       // list of CSetup's for this dwld

    DWORD                m_flags;            // provision for hacks :)

    HGLOBAL              m_hPostData;        // has the query for the clsid

    DWORD                m_cbPostData;       // has size of post data

    BOOL                 m_bCompleteSignalled;

    LPWSTR               m_wszDistUnit;      // name of distribution for cdl:// dl

    HRESULT              m_hrOSB;            // this is the hr we got
                                             // from OnStopBinding
    HRESULT              m_hrStatus;         // this is the hr we got
                                             // URLMON for the binding
    HRESULT              m_hrResponseHdr;    // this is the hr we got
                                             // from the response headers
                                             // when querying for this clsid
                                             // this is to make sure we have the
                                             // right error status even when
                                             // urlmon does not pass back right
                                             // OnError.

    PJAVA_TRUST          m_pbJavaTrust;

    CList<CSetupHook*,CSetupHook*>           // linked list of setup hooks
                         m_SetupHooks;

    CList<CJavaSetup*,CJavaSetup*>           // linked list of Java setups
                         m_JavaSetupList;

    Cwvt                 m_wvt;              // WinVerifyTrust delay load
                                             // magic in this class

    CList<CCodeBaseHold *, CCodeBaseHold *> *m_pcbhList;
    DWORD               m_grfBINDF;
    LPMONIKER           *m_ppmkContext;

    BOOL m_bExactVersion;

};

// BSC for our indiv. CDownloads
class CBindStatusCallback : public IBindStatusCallback
                            ,public IHttpNegotiate
                            ,public IWindowForBindingUI
                            ,public IServiceProvider
                            ,public ICatalogFileInfo
{

  public:

    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IBindStatusCallback methods
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed);
    STDMETHODIMP    OnObjectAvailable( REFIID riid, IUnknown* punk);

    STDMETHODIMP    OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);

    // *** IHttpNegotiate methods ***
    STDMETHOD(BeginningTransaction) (
        LPCWSTR szURL,
        LPCWSTR szHeaders,
        DWORD dwReserved,
        LPWSTR *pszAdditionalHeaders);

    STDMETHOD(OnResponse) (
        DWORD dwResponseCode,
        LPCWSTR szResponseHeaders,
        LPCWSTR szRequestHeaders,
        LPWSTR *pszAdditionalRequestHeaders);

    // *** IWindowForBindingUI methods ***
    STDMETHOD(GetWindow) (
        REFGUID rguidreason,
                HWND *phWnd);

    // *** IServiceProvider ***
    STDMETHOD(QueryService) (
        REFGUID guidService,
        REFIID riid,
        LPVOID *ppv);


    // *** ICatalogFileInfo ***
    STDMETHODIMP GetCatalogFile(LPSTR *ppszCatalogFile);
    STDMETHODIMP GetJavaTrust(void **ppJavaTrust);

    // constructor
    CBindStatusCallback(CDownload *pdl, DWORD grfBINDF);
    ~CBindStatusCallback();

    IBinding* GetBinding() const {return m_pbinding;}

    private:

    DWORD           m_cRef;
    IBinding*       m_pbinding;
    CDownload*      m_pdl;        // point up into download obj
    DWORD           m_grfBINDF;

    BYTE            m_cbBuffer[BUFFERMAX];

};

class CSetupHook {
    public:

    CSetupHook(
        CDownload *pdl,
        LPCSTR szHook,
        LPCSTR szInf,
        LPCSTR szInfSection,
        DWORD flags,
        HRESULT *phr);

    ~CSetupHook();

    HRESULT Run();

    static HRESULT ExpandCommandLine(
    LPSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],          // array of variable names eg. %EXTRACT_DIR%
    const char * szValues[]);       // corresponding values to expand of vars

    static HRESULT ExpandVar(
        LPSTR& pchSrc,          // passed by ref!
        LPSTR& pchOut,          // passed by ref!
        DWORD& cbLen,           // passed by ref!
        DWORD cbBuffer,         // size of out buffer
        const char * szVars[],  // array of variable names eg. %EXTRACT_DIR%
        const char * szValues[]);// corresponding values to expand of vars

    HRESULT TranslateString();

    INSTALL_STATE GetState() const { return m_state;}
    VOID SetState(INSTALL_STATE state) { m_state = state;}

    LPSTR GetHookName() { return m_szHook; }

    const char * GetObjectDir() { 

        if (m_pdl && m_pdl->GetCodeDownload())
            return m_pdl->GetCodeDownload()->GetCacheDir();
        else
            return NULL;
    }

    LPCWSTR GetSrcURL() {
        if (m_pdl) {
            return m_pdl->GetURL();
        }
        else {
            return NULL;
        }
    }

    LPSTR GetHookDir() { 

        if (m_pdl && m_pdl->GetSession())
            return m_pdl->GetSession()->achLocation;
        else
            return NULL;
    }

    private:

    INSTALL_STATE      m_state;            // state of install operation
    CDownload*         m_pdl;
    LPSTR              m_szHook;
    LPSTR              m_szInf;
    LPSTR              m_szInfSection;
    DWORD              m_flags;
};

HRESULT SetCodeDownloadTLSVars();

// private helpers

// from isctrl.cxx
HRESULT  IsControlLocallyInstalled(
    LPSTR lpCurCode,
    const LPCLSID lpclsid,
    LPCWSTR szDistUnit,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    BOOL bExactVersion = FALSE);

// from isctrl.cxx
HRESULT  IsCLSIDLocallyInstalled(
    LPSTR lpCurCode,
    const LPCLSID lpclsid,
    LPCWSTR szDistUnit,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    HRESULT *pHrExtra,
    BOOL bExactVersion
    );

HRESULT
IsDistUnitLocallyInstalled(
    LPCWSTR szDistUnit,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    LPBOOL pbParanoidCheck,
    DWORD flags);

HRESULT
IsPackageLocallyInstalled(
    IJavaPackageManager **ppPackageManager,
    LPCWSTR szPackageName,
    LPCWSTR szNameSpace,
    DWORD dwVersionMS,
    DWORD dwVersionLS);

HRESULT LocalVersionOK(
    HKEY hkeyClsid,
    CLocalComponentInfo *plci,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    BOOL bExactVersion
    );


HRESULT GetFileVersion(
    CLocalComponentInfo *plci,
    LPDWORD pdwFileVersionMS,
    LPDWORD pdwFileVersionLS);

HRESULT GetVersionFromString(
    const char *szBuf,
    LPDWORD pdwFileVersionMS,
    LPDWORD pdwFileVersionLS,
    char cSeperator = ',');

BOOL AdviseForceDownload( const LPCLSID lpclsid, DWORD dwClsContext);

// flags for UpdateModuleUsage

#define    MU_CLIENT   0        // mark us as a client
#define    MU_OWNER    1        // mark us as the owner (iff no prev ver exists)

HRESULT
UpdateModuleUsage(
    LPCSTR szFileName,
    LPCSTR szClientName,
    LPCSTR szClientPath,
    LONG muFlags);

HRESULT UpdateSharedDlls( LPCSTR szFileName);

BOOL    SupportsSelfRegister(LPSTR szFileName);
BOOL    WantsAutoExpire(LPSTR szFileName, DWORD *pnExpireDays ); 

// from wvt.cxx
HRESULT GetActivePolicy(IInternetHostSecurityManager* pZoneManager, 
                        LPCWSTR pwszZone,
                        DWORD  dwUrlAction,
                        DWORD& dwPolicy,
                        BOOL fEnforceRestricted);

// from peldr.cxx
HRESULT IsCompatibleFile(const char *szFileName, LPDWORD lpdwMachineType=NULL);
HRESULT IsRegisterableDLL(const char *szFileName);


// fro, softdist.cxx
HRESULT GetLangString(LCID localeID, char *szThisLang, int iLen);
HRESULT InitBrowserLangStrings();

// from duman.cxx
HRESULT GetSoftDistFromOSD(LPCSTR szFile, IXMLElement **ppSoftDist);

HRESULT GetFirstChildTag(IXMLElement *pRoot, LPCWSTR szTag, IXMLElement **ppChildReq);
HRESULT GetNextChildTag(IXMLElement *pRoot, LPCWSTR szTag, IXMLElement **ppChildReq, int &nLastChild);

HRESULT GetAttribute(IXMLElement *pElem, LPWSTR szAttribName, VARIANT *pvProp);
HRESULT GetAttributeA(IXMLElement *pElem, LPWSTR szAttribName, LPSTR pAttribValue, DWORD dwBufferLen);
HRESULT DupAttributeA(IXMLElement *pElem, LPWSTR szAttribName, LPSTR *ppszRet);
HRESULT DupAttribute(IXMLElement *pElem, LPWSTR szAttribName, LPWSTR *ppszRet);
HRESULT GetTextContent(IXMLElement *pRoot, LPCWSTR szTag, LPWSTR *ppszContent);

// from jit.cxx
HRESULT
GetIEFeatureFromMime(LPWSTR *ppwszIEFeature, LPCWSTR pwszMimeType, QUERYCONTEXT *pQuery, QUERYCONTEXT *pQueryRec=NULL);
HRESULT
GetIEFeatureFromClass(LPWSTR *ppwszIEFeature, REFCLSID clsid, QUERYCONTEXT *pQuery, QUERYCONTEXT *pQueryRec=NULL);

// from client.cxx
IInternetHostSecurityManager* GetHostSecurityManager(IBindStatusCallback *pclientbsc);

// from helpers.cxx
HRESULT CheckFileImplementsCLSID(const char *pszFileName, REFCLSID rClsid);
FILEXTN GetExtnAndBaseFileName( char *szName, char **plpBaseFileName);
HRESULT MakeUniqueTempDirectory(LPCSTR szTempDir, LPSTR szUniqueTempDir, int iLen);
HRESULT ComposeHackClsidFromMime(LPSTR szHackMimeType, int iLen, LPCSTR szClsid);

HRESULT GetHeaderValue (
    LPCWSTR szResponseHeadersBuffer,
    DWORD   cbResponseHeadersBuffer,
    LPCWSTR lpcszHeaderName,
    LPWSTR  pHeaderValue,
    DWORD   cbHeaderValue);

HRESULT
GetClsidFromExtOrMime(
    REFCLSID rclsid,
    CLSID &clsidout,
    LPCWSTR szExt,
    LPCWSTR szTYPE,
    LPSTR *ppFileName);

STDAPI
AsyncGetClassBitsEx(
    REFCLSID rclsid,                      // CLSID
    CodeDownloadData * pcdd,              // Contains requested object's descriptors    
    IBindCtx *pbc,                        // bind ctx: should contain BSC
    DWORD dwClsContext,                   // CLSCTX flags
    LPVOID pvReserved,                    // Must be NULL
    REFIID riid);                         // Usually IID_IClassFactory

STDAPI
AsyncGetClassBits2Ex(
    LPCWSTR szClientID,                 // client ID, root object if NULL
    CodeDownloadData * pcdd,            // Contains requested object's descriptors
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    IUnknown **pUnk);


STDAPI
AsyncInstallDistributionUnitEx(
    CodeDownloadData * pcdd,            // Contains requested object's descriptors
    IBindCtx *pbc,                      // bind ctx
    REFIID riid,
    IUnknown **pUnk,
    LPVOID pvReserved);                 // Must be NULL


// backwards compatability
STDAPI
AsyncGetClassBits(
    REFCLSID rclsid,                      // CLSID
    LPCWSTR szType,                       // MIME type 
    LPCWSTR szExtension,                  // or Extension
                                          // as alternate
                                          // if CLSID == CLSID_NULL

    DWORD dwFileVersionMS,                // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,                // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                        // CODEBASE= in OBJECT tag
    IBindCtx *pbc,                        // bind ctx: should contain BSC
    DWORD dwClsContext,                   // CLSCTX flags
    LPVOID pvReserved,                    // Must be NULL
    REFIID riid,                          // Usually IID_IClassFactory
    DWORD flags);
STDAPI
AsyncInstallDistributionUnit(
    LPCWSTR szDistUnit,
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODEBASE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODEBASE
    IBindCtx *pbc,                      // bind ctx
    LPVOID pvReserved,                  // Must be NULL
    DWORD flags);
STDAPI
AsyncGetClassBits2(
    LPCWSTR szClientID,                 // client ID, root object if NULL
    LPCWSTR szDistUnit,                 // CLSID, can be an arbit unique str
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODE= in INSERT tag
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    DWORD flags);


#ifdef unix
extern "C"
#endif /* unix */
STDAPI_(DWORD)
CDLGetLongPathNameA( 
    LPSTR lpszLong,
    LPCSTR lpszShort,
    DWORD cchBuffer
    );

#ifdef unix
extern "C"
#endif /* unix */
STDAPI_(DWORD)
CDLGetLongPathNameW(
    LPWSTR lpszLongPath,
    LPCWSTR  lpszShortPath,
    DWORD    cchBuffer
    );

HRESULT
   GetActiveXSafetyProvider(
                            IActiveXSafetyProvider **ppProvider
                           );

extern int  g_CPUType;
extern BOOL g_fRunningOnNT;
extern BOOL  g_bNT5OrGreater;
#ifdef WX86
extern BOOL g_fWx86Present;
#endif

VOID
DetermineOSAndCPUVersion();

#ifdef UNICODE
#define CDLGetLongPathName  CDLGetLongPathNameW
#else
#define CDLGetLongPathName  CDLGetLongPathNameA
#endif // !UNICODE

#endif /* end hide classes from 'C' */
#endif // _CDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\cdlapi.cxx ===
// ===========================================================================
// File: CDLAPI.CXX
//    The main code downloader api file.
//

#include <cdlpch.h>
#include <mshtmhst.h>
#include <shlwapi.h>
#include <inseng.h>

// globals for code downloader
CMutexSem g_mxsCodeDownloadGlobals;

LCID g_lcidBrowser = 0x409;     // default to english
char g_szBrowserLang[20];
int g_lenBrowserLang = 20;
char g_szBrowserPrimaryLang[20];
int g_lenBrowserPrimaryLang = 20;

// Use SetupApi by default!
DWORD  g_dwCodeDownloadSetupFlags = CDSF_USE_SETUPAPI;

char g_szOCXCacheDir[MAX_PATH];
char g_szOCXTempDir[MAX_PATH];
int  g_OCXCacheDirSize = 0;
static BOOL g_fHaveCacheDir = FALSE;

BOOL g_OSInfoInitialized = FALSE;
int g_CPUType = PROCESSOR_ARCHITECTURE_UNKNOWN;   // default
BOOL g_fRunningOnNT = FALSE;
BOOL g_bRunOnWin95 = FALSE;
#ifdef WX86
BOOL g_fWx86Present;    // Set if running on RISC and Wx86 is installed
#endif

BOOL g_bLockedDown = FALSE;

// New default name for ActiveX cache folder! We only use this if occache fails to set up the cache folder.
// const static char *g_szOCXDir = "OCCACHE";
const char *g_szOCXDir = "Downloaded Program Files";
const char *g_szActiveXCache = "ActiveXCache";
const char *g_szRegKeyActiveXCache = "ActiveX Cache";

// This is the client platform specific location name that we look for in INF
// and is built by concatenating g_szProcessorTypes at end of g_szLocPrefix
char g_szPlatform[17]; // sizeof("file-win32-alpha"), (longest possible)
static char *g_szLocPrefix="file-win32-";
// directly indexed into with PROCESSOR_ARCH* returned by GetSystemInfo..
// The "" ones are those we don't support.
char *g_szProcessorTypes[] = {
    "x86",
    "",
    "",
    "",
    "",
    "",
    "ia64",
    "",
    "",
    "amd64"
};

// used for Accept Types doing http based platform independence
// use alpha as the longest of possible g_szProcessorTypes strings
static char *g_szCABAcceptPrefix = "application/x-cabinet-win32-";
static char *g_szPEAcceptPrefix = "application/x-pe-win32-";

// Name of dll that implements ActiveX control cache shell extension
const char *g_szActiveXCacheDll = "occache.dll";

// list that goes into accept types
// this first 2 left null to substitue with strings for this platform (cab, pe)

// the number of media types are are registering as Accept types for 
// HTTP based contente negotiation
#ifdef WX86
#define CDL_NUM_TYPES   7
#else
#define CDL_NUM_TYPES   5
#endif

LPSTR g_rgszMediaStr[CDL_NUM_TYPES] =
{
    CFSTR_MIME_NULL,
    CFSTR_MIME_NULL,
    CFSTR_MIME_RAWDATASTRM,
    "application/x-setupscript",
    "*/*",
#ifdef WX86
    CFSTR_MIME_NULL,
    CFSTR_MIME_NULL,
#endif
};

CLIPFORMAT g_rgclFormat[CDL_NUM_TYPES];


FORMATETC g_rgfmtetc[CDL_NUM_TYPES];


IEnumFORMATETC *g_pEFmtETC;

extern COleAutDll   g_OleAutDll;

typedef HRESULT (STDAPICALLTYPE *PFNCOINSTALL)(
    IBindCtx     *pbc,
    DWORD         dwFlags,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    LPWSTR        pszCodeBase);

PFNCOINSTALL g_pfnCoInstall=NULL;
BOOL         g_bCheckedForCoInstall=FALSE;
HMODULE      g_hOLE32 = 0;
BOOL         g_bUseOLECoInstall = FALSE;

HRESULT GetClassFromExt(LPSTR pszExt, CLSID *pclsid);

STDAPI
WrapCoInstall (
    REFCLSID rCLASSID,          // CLSID of object (may be NULL)
    LPCWSTR szCODE,             // URL to code (may be NULL)
    DWORD dwFileVersionMS,      // Version of primary object
    DWORD dwFileVersionLS,      // Version of primary object
    LPCWSTR szTYPE,             // MIME type (may be NULL)
    LPBINDCTX pBindCtx,         // Bind ctx
    DWORD dwClsContext,         // CLSCTX flags
    LPVOID pvReserved,          // Must be NULL
    REFIID riid,                // Usually IID_IClassFactory
    DWORD flags
    );

#define WRAP_OLE32_COINSTALL

STDAPI PrivateCoInstall(
    IBindCtx     *pbc,
    DWORD         dwFlags,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    LPWSTR        pszCodeBase);



/*
 * RegisterNewActiveXCacheFolder
 * change default ActiveX Cache path to lpszNewPath and properly
 * updates all registry entries 
 */
/*
LONG RegisterNewActiveXCacheFolder(LPCTSTR lpszNewPath, DWORD dwPathLen)
{
    Assert(lpszNewPath != NULL && lpszNewPath[0] != '\0');
    if (lpszNewPath == NULL || lpszNewPath[0] == '\0')
        return ERROR_BAD_ARGUMENTS;

    LONG lResult = ERROR_SUCCESS;
    HKEY hkeyIntSetting = NULL;
    HKEY hkeyActiveXCache = NULL;
    char szOldPath[MAX_PATH];
    char szPath[MAX_PATH];
    char szSubKey[MAX_PATH];
    DWORD dwLen = MAX_PATH;
    DWORD dwKeyLen = MAX_PATH;
    DWORD dwIndex = 0;
    BOOL fOldFound = FALSE;
    BOOL fNewFound = FALSE;
    BOOL fEqual = FALSE;
    LONG lValueIndex = -1;

    lResult = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_SETTINGS,
                      0, KEY_ALL_ACCESS, &hkeyIntSetting);
    if (lResult != ERROR_SUCCESS)
        goto Exit;

    // read ActiveXCache
    lResult = RegQueryValueEx(
                      hkeyIntSetting, g_szActiveXCache, NULL, NULL,
                      (LPBYTE)szOldPath, &dwLen);

    if (lResult != ERROR_SUCCESS)
    {
        fOldFound = TRUE;
        szOldPath[0] = '\0';
    }

    fEqual = (lstrcmpi(lpszNewPath, szOldPath) == 0); 

    lResult = RegSetValueEx(
                      hkeyIntSetting, g_szActiveXCache, 0, REG_SZ,
                      (LPBYTE)lpszNewPath, dwPathLen);
    if (lResult != ERROR_SUCCESS)
        goto Exit;

    // Check to see if new path already exists in the list of paths under
    // HKLM\...\Windows\CurrentVersion\Internet Settings\ActiveX Cache\Paths.
    // If not, add it.
    lResult = RegCreateKey(
                      hkeyIntSetting, g_szRegKeyActiveXCache, 
                      &hkeyActiveXCache);
    if (lResult != ERROR_SUCCESS)
        goto Exit;

    for (dwLen = dwKeyLen = MAX_PATH; 
         lResult == ERROR_SUCCESS; 
         dwLen = dwKeyLen = MAX_PATH)
    {
        lResult = RegEnumValue(
                      hkeyActiveXCache, dwIndex++, szSubKey, &dwKeyLen, 
                      NULL, NULL, (LPBYTE)szPath, &dwLen);

        if (lResult == ERROR_SUCCESS)
        {
            // for find new unique value name later.
            lValueIndex = max(lValueIndex, atol(szSubKey));

            if (!fNewFound)
                fNewFound = (lstrcmpi(lpszNewPath, szPath) == 0);
            if (!fOldFound)
                fOldFound = (lstrcmpi(szOldPath, szPath) == 0);
        }
    }

    // something goes wrong!
    if (lResult != ERROR_NO_MORE_ITEMS)
        goto Exit;

    // Add lpszNewPath to the list of paths
    lResult = ERROR_SUCCESS;

    // keep registry intact
    if (!fOldFound && szOldPath[0] != '\0')
    {
        wsprintf(szSubKey, "%i", ++lValueIndex);
        lResult = RegSetValueEx(
                      hkeyActiveXCache, szSubKey, 0, REG_SZ, 
                      (LPBYTE)szOldPath, lstrlen(szOldPath) + 1);
    }

    // add new path to list of paths
    if (lResult == ERROR_SUCCESS && !fNewFound && !fEqual)
    {
        wsprintf(szSubKey, "%i", ++lValueIndex);
        lResult = RegSetValueEx(
                      hkeyActiveXCache, szSubKey, 0, REG_SZ, 
                      (LPBYTE)lpszNewPath, dwPathLen);
    }

Exit:

    // restore old state if failed
    if (lResult != ERROR_SUCCESS)
    {
        if (szOldPath[0] == '\0')
            RegDeleteValue(hkeyIntSetting, g_szActiveXCache);
        else
            RegSetValueEx(
                      hkeyIntSetting, g_szActiveXCache, 0, REG_SZ,
                      (LPBYTE)lpszNewPath, dwPathLen);
    }

    if (hkeyActiveXCache != NULL)
        RegCloseKey(hkeyActiveXCache);

    if (hkeyIntSetting != NULL)
        RegCloseKey(hkeyIntSetting);

    return lResult;
}

LONG SwitchToNewCachePath(LPCSTR lpszNewPath, DWORD dwPathLen)
{
    Assert(lpszNewPath != NULL);
    if (lpszNewPath == NULL)
        return ERROR_BAD_ARGUMENTS;

    LONG lResult = ERROR_SUCCESS;
    char szKey[MAX_PATH];
    char szPath[MAX_PATH];
    char *pCh = NULL;
    HKEY hkey = NULL;
    DWORD dwIndex = 0;
    DWORD dwLen = MAX_PATH;

    wsprintf(szKey, "%s\\%s", REGSTR_PATH_IE_SETTINGS, g_szRegKeyActiveXCache);

    lResult = RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE, szKey,
                      0, KEY_ALL_ACCESS, &hkey);

    for (; lResult == ERROR_SUCCESS; dwLen = MAX_PATH)
    {
        lResult = RegEnumValue(
                      hkey, dwIndex++, szKey, &dwLen, 
                      NULL, NULL, (LPBYTE)szPath, &dwLen);

        if (lResult == ERROR_SUCCESS && lstrcmpi(szPath, lpszNewPath) == 0)
            break;
    }

    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS)
        return RegisterNewActiveXCacheFolder(lpszNewPath, dwPathLen);

    // return fail to indicate that path has not been changed to
    // Downloaded ActiveX Controls
    return HRESULT_CODE(E_FAIL);
}
*/

HRESULT
SetCoInstall()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "SetCoInstall",
                NULL
                ));
                
    HKEY                    hKeyIESettings = 0;

    //execute entire function under critical section
    CLock lck(g_mxsCodeDownloadGlobals);

    if (!g_bCheckedForCoInstall && !g_pfnCoInstall) 
    {
        // So we don't keep rechecking for this api.
        g_bCheckedForCoInstall = TRUE;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_SETTINGS, 0,
                     KEY_READ, &hKeyIESettings) == ERROR_SUCCESS) {
            if (RegQueryValueEx(hKeyIESettings, REGVAL_USE_COINSTALL, NULL,
                                NULL, NULL, 0) != ERROR_SUCCESS) {

                g_bUseOLECoInstall = FALSE;
                g_pfnCoInstall = NULL;

                RegCloseKey(hKeyIESettings);

                DEBUG_LEAVE(S_OK);
                return S_OK;
            }

            RegCloseKey(hKeyIESettings);
        }
        
        // find CoInstall entry point in OLE32
        if (!g_hOLE32)
        {
            // BUGBUG: We never FreeLibrary on this. Realisticly, someone else will probably already be using this
            // and it will be in use throughout the life of the process, so we won't worry too much.
            g_hOLE32 = LoadLibraryA("ole32.dll");
        }

        if(g_hOLE32 != 0)
        {
            void *pfn = GetProcAddress(g_hOLE32, "CoInstall");
            if(pfn != NULL)
            {
                g_bUseOLECoInstall = TRUE;
                g_pfnCoInstall = (PFNCOINSTALL) pfn;
            }
        }
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

VOID
DetermineOSAndCPUVersion()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "DetermineOSAndCPUVersion",
                NULL
                ));
                
    OSVERSIONINFO osvi;
    SYSTEM_INFO   sysinfo;

    //execute entire function under critical section
    CLock lck(g_mxsCodeDownloadGlobals);

    if (g_OSInfoInitialized) {

        DEBUG_LEAVE(0);
        return;
    }

    // Determine which version of NT we're running on
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    g_fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);

    if (osvi.dwPlatformId & VER_PLATFORM_WIN32_WINDOWS &&
        osvi.dwMinorVersion == 0) {
        g_bRunOnWin95 = TRUE;
    }
    else {
        g_bRunOnWin95 = FALSE;
    }

#ifdef WX86
    if (g_bNT5OrGreater) {
        //
        // The pre-alpha Wx86 that runs on NT 4.0 does not support
        // x86 ActiveX controls inside a RISC host.  Only call Wx86
        // on NT 5.0 machines.
        //
        HKEY hKey;
        LONG Error;

        // Temp hack:  allow users to disable Wx86 support in URLMON if this
        //             key is present.
        // bugbug: probably rip this before ship.
        Error = ::RegOpenKeyW(HKEY_LOCAL_MACHINE,
                  L"System\\CurrentControlSet\\Control\\Wx86\\DisableCDL",
                  &hKey);

        if (Error == ERROR_SUCCESS) {
            ::RegCloseKey(hKey);
        } else {
            g_fWx86Present = TRUE;
        }
    }
#endif  // WX86

    GetSystemInfo(&sysinfo);

    switch(sysinfo.wProcessorArchitecture) {

    case PROCESSOR_ARCHITECTURE_INTEL:
    case PROCESSOR_ARCHITECTURE_AMD64:
    case PROCESSOR_ARCHITECTURE_IA64:

        g_CPUType = sysinfo.wProcessorArchitecture;
        break;

    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        g_CPUType = PROCESSOR_ARCHITECTURE_UNKNOWN;
        break;
    }

    g_OSInfoInitialized = TRUE;
    
    DEBUG_LEAVE(0);
}

/*
 * SetGlobals
 * set all the globals for the Code Downloader
 * called from AsyncGetClassBits. executes under a crit section
 */

HRESULT
SetGlobals()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "SetGlobals",
                NULL
                ));
                
    SYSTEM_INFO sysinfo;
    int nCPUType;
    HRESULT hr = S_OK;
    DWORD lResult;
//    static const char szActiveXCache[] = "ActiveXCache";
    BOOL fRegActiveXCacheDll = FALSE;   // do we need to register occache.dll?

    //execute entire function under critical section
    CLock lck(g_mxsCodeDownloadGlobals);

    if (!g_fHaveCacheDir) {

        // do some init: get ocx ccahe dir

        DWORD Size = MAX_PATH;
        DWORD dwType;
        HKEY hKeyIESettings = 0;
        char szOldCacheDir[MAX_PATH];
        int len = 0;
        int CdlNumTypes;

        lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_SETTINGS, 0,
                                  KEY_READ, &hKeyIESettings );


        if (lResult != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        // Get Code Download flags
        dwType = REG_DWORD;
        Size = sizeof(DWORD);
        lResult = ::RegQueryValueEx(hKeyIESettings, "CodeDownloadFlags",
            NULL, &dwType, (unsigned char *)&g_dwCodeDownloadSetupFlags, &Size);
        Size = MAX_PATH;
        dwType = REG_SZ;

        // Get existing cache path from registry
        lResult = ::RegQueryValueEx(hKeyIESettings, g_szActiveXCache,
            NULL, &dwType, (unsigned char *)g_szOCXCacheDir, &Size);

 
        if (lResult != ERROR_SUCCESS ||
            !PathFileExists( g_szOCXCacheDir ) )
        {
            // OC Cache didn't set up the registry for us...
            // Load it to make sure it has done if regsvring work...
            HRESULT hr = E_FAIL;
            HINSTANCE h = LoadLibrary(g_szActiveXCacheDll);
            HRESULT (STDAPICALLTYPE *pfnReg)(void);
            HRESULT (STDAPICALLTYPE *pfnInst)(BOOL bInstall, LPCWSTR pszCmdLine);
            if (h != NULL)
            {
                (FARPROC&)pfnReg = GetProcAddress(h, "DllRegisterServer");
                if (pfnReg != NULL)
                    hr = (*pfnReg)();

                // also need to call DllInstall to complete the wiring of the shell extension
                (FARPROC&)pfnInst = GetProcAddress(h, "DllInstall");
                if (pfnInst != NULL)
                    hr = (*pfnInst)( TRUE, L"");

                FreeLibrary(h);
            }

            // Retry now that we're sure OCCACHE has had a shot at setting things up for us
            if ( SUCCEEDED(hr) )
                 lResult = ::RegQueryValueEx(hKeyIESettings, g_szActiveXCache,
                                            NULL, &dwType, (unsigned char *)g_szOCXCacheDir, &Size);
            if ( lResult != ERROR_SUCCESS ) {
                // OC Cache is having a bad day. Don't let this stop code download.
                // Compose the default path and see if we need to change
                // old cache path to the new default path.
                if(!(len = GetWindowsDirectory(g_szOCXCacheDir, MAX_PATH)))
                    g_szOCXCacheDir[0] = '\0';
                else 
                {
                    Assert(len <= MAX_PATH);
                    if (g_szOCXCacheDir[len-1] != '\\')
                        lstrcat(g_szOCXCacheDir, "\\");
                }
                StrNCat(g_szOCXCacheDir, g_szOCXDir,MAX_PATH-len-2);
                // OC Cache or not, remember our directory

                HKEY hkeyWriteIESettings;
                if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_SETTINGS,0,
                    KEY_ALL_ACCESS, &hkeyWriteIESettings ) == ERROR_SUCCESS) {

                    RegSetValueEx(hkeyWriteIESettings,g_szActiveXCache,0,REG_SZ,
                       (LPBYTE)g_szOCXCacheDir, lstrlen(g_szOCXCacheDir) + 1);

                    RegCloseKey(hkeyWriteIESettings);
                }

            }


            // load oleaut32.dll
            lResult = g_OleAutDll.Init();

        } // if reg key not set up.

        if (hKeyIESettings) {
            RegCloseKey(hKeyIESettings);
            hKeyIESettings = 0;
        }

        DWORD dwAttr = GetFileAttributes(g_szOCXCacheDir);

        if (dwAttr == -1) {
            if (!CreateDirectory(g_szOCXCacheDir, NULL)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            // if cache dir has just been created, we also need
            // to register occache shell extension
            fRegActiveXCacheDll = TRUE;
            
        } else {
            if ( (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) ||
                        (dwAttr & FILE_ATTRIBUTE_READONLY)) {
                hr = OLE_E_NOCACHE; // closest we can get to!
                goto Exit;
            }
        }

        if (!GetTempPath(MAX_PATH, g_szOCXTempDir) ) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        // Set up g_bRunningOnNT,  g_CpuType, and g_fWx86Present
        DetermineOSAndCPUVersion();

        // Record client architecture to make proper accept types
        // and to use in INF for platform independent CODE=URL

        LPSTR pBaseFileName = NULL;
        
        InitBrowserLangStrings();

        nCPUType = g_CPUType;
        if (g_CPUType == PROCESSOR_ARCHITECTURE_UNKNOWN) {
            nCPUType = PROCESSOR_ARCHITECTURE_INTEL;
        }

        lstrcpy(g_szPlatform, g_szLocPrefix);
        lstrcat(g_szPlatform, g_szProcessorTypes[nCPUType]);

        // Register the Media types
        // first build up the table of eight types we send out

        char szCABStr[MAX_PATH];
        char szPEStr[MAX_PATH];

        lstrcpy(szCABStr, g_szCABAcceptPrefix);
        lstrcat(szCABStr, g_szProcessorTypes[nCPUType]);
        lstrcpy(szPEStr, g_szPEAcceptPrefix);
        lstrcat(szPEStr, g_szProcessorTypes[nCPUType]);


        g_rgszMediaStr[0] = szCABStr;
        g_rgszMediaStr[1] = szPEStr;

#ifdef WX86
        char szCABStrX86[MAX_PATH];
        char szPEStrX86[MAX_PATH];

        if (g_fWx86Present) {
            g_rgszMediaStr[6] = g_rgszMediaStr[4];  // move "*/*" to the end of the list

            lstrcpy(szCABStrX86, g_szCABAcceptPrefix);
            lstrcat(szCABStrX86, g_szProcessorTypes[PROCESSOR_ARCHITECTURE_INTEL]);
            lstrcpy(szPEStrX86, g_szPEAcceptPrefix);
            lstrcat(szPEStrX86, g_szProcessorTypes[PROCESSOR_ARCHITECTURE_INTEL]);

            g_rgszMediaStr[4] = szCABStrX86;
            g_rgszMediaStr[5] = szPEStrX86;

            CdlNumTypes = CDL_NUM_TYPES;
        } else {
            CdlNumTypes = CDL_NUM_TYPES-2;
        }
#else
        CdlNumTypes = CDL_NUM_TYPES;
#endif


        hr = RegisterMediaTypes(CdlNumTypes, (const LPCSTR *)g_rgszMediaStr, g_rgclFormat);

        if (FAILED(hr))
            goto Exit;

        // initialize the formatetc array

        for (int i=0; i< CdlNumTypes; i++) {
            g_rgfmtetc[i].cfFormat = g_rgclFormat[i];
            g_rgfmtetc[i].tymed = TYMED_NULL;
            g_rgfmtetc[i].dwAspect = DVASPECT_CONTENT;
            g_rgfmtetc[i].ptd = NULL;
        }

        // BUGBUG: leaked!
        hr = CreateFormatEnumerator(CdlNumTypes, g_rgfmtetc, &g_pEFmtETC);
        if (FAILED(hr))
            goto Exit;

        if (g_bNT5OrGreater) {
            HKEY hkeyLockedDown = 0;

            // Test for lock-down. If we cannot write to HKLM, then we are in
            // a locked-down environment, and should abort right away.
    
            if (RegCreateKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_NT5_LOCKDOWN_TEST,
                             &hkeyLockedDown) != ERROR_SUCCESS) {
                // We are in lock-down mode; abort.
                g_bLockedDown = TRUE;
            }
            else {
                // Not locked-down. Delete the key, and continue
                RegCloseKey(hkeyLockedDown);
                RegDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_NT5_LOCKDOWN_TEST);
                g_bLockedDown = FALSE;
            }
        }

        g_fHaveCacheDir = TRUE;
    }


Exit:

    if (FAILED(hr))
    {
        UrlMkDebugOut((DEB_CODEDL, "ERR CodeDownload failed to initialize: hr(%lx)\n", hr));
    }

    DEBUG_LEAVE(hr);
    return hr;
}


#define CLSID_ActiveXPlugin                                     \
    {0x06DD38D3L,0xD187,0x11CF,                                 \
    {0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8}}

//
// FindPlugin - delegates this call to the plugin OCX
//
BOOL FindPlugin(char *szFileExt, char *szName, char *szMime)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "FindPlugin",
                "%.80q, %.80q, %.80q",
                szFileExt, szName, szMime
                ));
                
    typedef BOOL (WINAPI *LPFINDPLUGIN_API)(char *ext, char *name, char *mime);
    LPFINDPLUGIN_API pfnFindPlugin;
    BOOL fRet = FALSE;

    HMODULE hLib = LoadLibrary("plugin.ocx");
    if (hLib == NULL) {
        goto Exit;
    }

    pfnFindPlugin = (LPFINDPLUGIN_API)GetProcAddress(hLib, "FindPluginA");
    if (pfnFindPlugin == NULL) {
        goto Exit;
    }

    fRet = pfnFindPlugin(szFileExt, szName, szMime);

Exit:

    if (hLib)
        FreeLibrary(hLib);

    DEBUG_LEAVE(fRet);
    return fRet;
}

// GetClsidFromExtOrMime
//      fills up clsidout with rCLASSID if not CLSID_NULL
//      or gets clsid from passed in ext or mime type
//  returns:
//      S_OK
//      S_FALSE: couldn't convert to a clsid
HRESULT
GetClsidFromExtOrMime(
    REFCLSID rclsid,
    CLSID &clsidout,
    LPCWSTR szExt,
    LPCWSTR szTYPE,
    LPSTR *ppFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetClsidFromExtOrMime",
                "%#x, %#x, %.80wq, %.80wq, %#x",
                &rclsid, &clsidout, szExt, szTYPE, ppFileName
                ));
                
    BOOL fNullClsid;
    HRESULT hr = S_OK;
    char szTypeA[MAX_PATH];
    char szExtA[MAX_PATH];
    LPSTR lpName = NULL;

    memcpy(&clsidout, &rclsid, sizeof(GUID));

    if ((fNullClsid = IsEqualGUID(rclsid , CLSID_NULL))) {

        if (!szTYPE && !szExt) {
            hr = S_FALSE;
            goto Exit;
        }


        if (szTYPE) {
            if (!WideCharToMultiByte(CP_ACP, 0 , szTYPE ,
                                        -1 ,szTypeA, MAX_PATH, NULL, NULL)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            // convert the mime/type into a clsid
            if (SUCCEEDED((GetClassMime(szTypeA, &clsidout)))) {
                fNullClsid = FALSE;
            }

        } else { // szExt

            if (!WideCharToMultiByte(CP_ACP, 0 , szExt ,
                                        -1 ,szExtA, MAX_PATH, NULL, NULL)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            if (SUCCEEDED(GetClassFromExt(szExtA, &clsidout))) {
                fNullClsid = FALSE;
            }

        }

    }

Exit:

    if ((hr == S_OK) && fNullClsid) {

        // still no clsid
        char szName[MAX_PATH];
        BOOL bRet = FindPlugin(szExtA, szName, szTypeA);

        if (bRet) {

            // found a plugin, instantiate the plugin ocx
            CLSID plug = CLSID_ActiveXPlugin;
            clsidout = plug;

            if (ppFileName) {

                lpName = new char [lstrlen(szName) + 1];

                if (lpName)
                    lstrcpy(lpName, szName);
                else
                    hr = E_OUTOFMEMORY;
            }

        } else {

            // not a plugin either!
            hr = S_FALSE;
        }
    }


    if (ppFileName) {
        *ppFileName = lpName;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//BUGBUG this must be defined in a public header. Is currently in ole32\ih\ole2com.h.
#if defined(_X86_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_INTEL
#elif defined(_AMD64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_AMD64
#elif defined(_IA64_)
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_IA64
#else
#define DEFAULT_ARCHITECTURE PROCESSOR_ARCHITECTURE_UNKNOWN
#endif

//+-------------------------------------------------------------------------
//
//  Function:   GetDefaultPlatform    (internal)
//
//  Synopsis:   Gets the current platform
//
//  Returns:    none
//
//--------------------------------------------------------------------------

void
GetDefaultPlatform(CSPLATFORM *pPlatform)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "GetDefaultPlatform",
                "%#x",
                pPlatform
                ));
                
    OSVERSIONINFO VersionInformation;

    VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&VersionInformation);

    pPlatform->dwPlatformId = VersionInformation.dwPlatformId; 
    pPlatform->dwVersionHi = VersionInformation.dwMajorVersion;
    pPlatform->dwVersionLo = VersionInformation.dwMinorVersion;  
    pPlatform->dwProcessorArch = DEFAULT_ARCHITECTURE;

    DEBUG_LEAVE(0);
}

//+-------------------------------------------------------------------------
//
//  Function:   GetActiveXSafetyProvider    (internal)
//
//  Synopsis:   Gets the ActiveXSafetyProvider, if there is one installed.
//
//  Returns:    none
//
//--------------------------------------------------------------------------

HRESULT
   GetActiveXSafetyProvider(IActiveXSafetyProvider **ppProvider)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetActiveXSafetyProvider",
                "%#x",
                ppProvider
                ));
                
    HRESULT hr;
    LONG l;
    HKEY hKey;

    //
    // See if an IActiveXSafetyProvider is present by peeking into the
    // registry.
    //
    l = RegOpenKeyA(HKEY_CLASSES_ROOT,
                    "CLSID\\{aaf8c6ce-f972-11d0-97eb-00aa00615333}",
                    &hKey
                   );
    if (l != ERROR_SUCCESS) {
        //
        // No ActiveXSafetyProvider installed.
        //
        *ppProvider = NULL;
        
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    RegCloseKey(hKey);

    //
    // Call OLE to instantiate the ActiveXSafetyProvider.
    //
    hr = CoCreateInstance(CLSID_IActiveXSafetyProvider,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IActiveXSafetyProvider,
                          (void **)ppProvider
                         );
                         
    DEBUG_LEAVE(hr);
    return hr;
}

#ifdef WRAP_OLE32_COINSTALL

// This currently breaks trident for unknown reasons. 
//   For full class store integration (Darwin packages) this will need to be enabled!!!

// ===========================================================================
//                     CBSCCreateObject Implementation
// ===========================================================================
class CBSCCreateObject : public IServiceProvider,
                         public IBindStatusCallback
{
private:
    DWORD   m_cRef;

    CLSID   m_clsid;
    LPWSTR  m_szExt;
    LPWSTR  m_szType;
    DWORD   m_dwClsContext;
    IID     m_riid;
    IBindStatusCallback* m_pclientbsc;
    //IBindCtx* m_pbc;
    CRITICAL_SECTION m_sect;
    LPVOID m_pvReserved;
    BOOL m_bObjectAvailableCalled;
    DWORD m_dwFlags;

public:
    CBSCCreateObject(REFCLSID rclsid, LPCWSTR szType, LPCWSTR szExt, DWORD dwClsContext, 
                    LPVOID pvReserved, REFIID riid, IBindCtx* pbc, DWORD dwFlags, HRESULT &hr)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    None,
                    "CBSCCreateObject::CBSCCreateObject",
                    "this=%#x, %#x, %.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                    this, &rclsid, szType, szExt, dwClsContext, pvReserved, &riid, pbc, dwFlags, &hr
                    ));
                    
        InitializeCriticalSection(&m_sect);
        m_cRef=1;
        m_clsid=rclsid;
        m_dwClsContext=dwClsContext;
        m_pvReserved=pvReserved;
        m_riid=riid;
        //m_pbc=NULL;
        m_pclientbsc=NULL;
        m_bObjectAvailableCalled=FALSE;

        m_dwFlags = dwFlags;

        if ( szType != NULL )
        {
            m_szType = new WCHAR[lstrlenW(szType) + 1];
            if ( m_szType != NULL )
                StrCpyW( m_szType, szType );
            else
                hr = E_OUTOFMEMORY;
        }
        else
            m_szType = NULL;

        if ( szExt != NULL )
        {
            m_szExt = new WCHAR[lstrlenW(szExt) + 1];
            if ( m_szExt != NULL )
                StrCpyW( m_szExt, szExt );
            else 
                hr = E_OUTOFMEMORY;
        }
        else
            m_szExt = NULL;

        if ( SUCCEEDED(hr) )
        {
            // Get client's BSC and store away for delegation
            hr=RegisterBindStatusCallback(pbc, (IBindStatusCallback*) this, &m_pclientbsc, NULL);
            if (SUCCEEDED(hr))
            {
                if (m_pclientbsc)
                {
                    //m_pbc=pbc;
                    //m_pbc->AddRef();
                }
                else
                {
                    hr=E_INVALIDARG; // need BSC in bind context!
                }
            }
        }

        DEBUG_LEAVE(0);
    }

    ~CBSCCreateObject()
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    None,
                    "CBSCCreateObject::~CBSCCreateObject",
                    "this=%#x",
                    this
                    ));
        //RevokeFromBC();

        if ( m_szType != NULL )
            delete m_szType;

        if ( m_szExt != NULL )
            delete m_szExt;

        if (m_pclientbsc)
        {
            IBindStatusCallback* pclientbsc=m_pclientbsc;
            m_pclientbsc=NULL;
            pclientbsc->Release();
        }
        DeleteCriticalSection(&m_sect);

        DEBUG_LEAVE(0);
    }

    IBindStatusCallback* GetClientBSC()
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Pointer,
                    "CBSCCreateObject::GetClientBSC",
                    "this=%#x",
                    this
                    ));
                    
        EnterCriticalSection(&m_sect);
        IBindStatusCallback* pbsc=m_pclientbsc;
        LeaveCriticalSection(&m_sect);
        
        DEBUG_LEAVE(pbsc);
        return pbsc;
    }

/*    HRESULT RevokeFromBC()
    {
        // Remove from BSC and reestablish original BSC
        HRESULT hr=S_OK;

        EnterCriticalSection(&m_sect);
        if (m_pbc)
        {
            IBindCtx* pbc=m_pbc;
            IBindStatusCallback* pclientbsc=m_pclientbsc;
            m_pbc=NULL;
            m_pclientbsc=NULL;
            LeaveCriticalSection(&m_sect);

            hr=RegisterBindStatusCallback(pbc, pclientbsc, NULL, NULL);
            pbc->Release();
            if (pclientbsc)
            {
                pclientbsc->Release();
            }
        }
        else
        {
            LeaveCriticalSection(&m_sect);
        }
        return hr;
    }
*/
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IUnknown::QueryInterface",
                    "this=%#x, %#x, %#x",
                    this, &riid, ppv
                    ));
                    
        HRESULT hr = S_OK;

        *ppv = NULL;

        if(IsEqualIID(riid, IID_IUnknown) ||
           IsEqualIID(riid, IID_IBindStatusCallback))
        {
            AddRef();
            *ppv = (IBindStatusCallback *) this;
        }
        else if(IsEqualIID(riid, IID_IServiceProvider))
        {
            AddRef();
            *ppv = (IServiceProvider *) this;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
        
        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IUnknown::AddRef",
                    "this=%#x",
                    this
                    ));
                    
        InterlockedIncrement((long *) &m_cRef);

        DEBUG_LEAVE(m_cRef);
        return m_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IUnknown::Release",
                    "this=%#x",
                    this
                    ));
                    
        LONG count = m_cRef - 1;

        if(0 == InterlockedDecrement((long *) &m_cRef))
        {
            delete this;
            count = 0;
        }

        DEBUG_LEAVE(count);
        return count;
    }

    // IBindStatusCallback/Holder
    STDMETHODIMP OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::OnStartBinding",
                    "this=%#x, %#x, %#x",
                    this, grfBSCOption, pbinding
                    ));
                    
        m_bObjectAvailableCalled=FALSE;
        IBindStatusCallback* pclientbsc=GetClientBSC();

        HRESULT hr = S_OK;
        if (pclientbsc)
            hr = pclientbsc->OnStartBinding(grfBSCOption, pbinding);

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP GetPriority(LONG* pnPriority)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::GetPriority",
                    "this=%#x, %#x",
                    this, pnPriority
                    ));
                    
        IBindStatusCallback* pclientbsc=GetClientBSC();

        HRESULT hr = S_OK;
        if (pclientbsc)
            hr = pclientbsc->GetPriority(pnPriority);

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP OnLowResource(DWORD dwReserved)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::OnLowResource",
                    "this=%#x, %#x",
                    this, dwReserved
                    ));
                    
        IBindStatusCallback* pclientbsc=GetClientBSC();

        HRESULT hr = S_OK;
        if (pclientbsc)
            hr = pclientbsc->OnLowResource(dwReserved);

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::OnStopBinding",
                    "this=%#x, %#x, %.80wq",
                    this, hrStatus, pszError
                    ));
                    
        HRESULT hr=S_OK;

        // Save client BSC for last notification
        IBindStatusCallback* pclientbsc=GetClientBSC();
        if (!pclientbsc)
        {
            DEBUG_LEAVE(hr);
            return hr;
        }
        pclientbsc->AddRef();

        // We are done with this bind context! Unregister before caller unregisters it's IBSC
        //hr=RevokeFromBC();

        if (SUCCEEDED(hrStatus))
        {
            if (!m_bObjectAvailableCalled && (m_dwFlags & CD_FLAGS_NEED_CLASSFACTORY ) )
            {
                IUnknown* punk=NULL;
                CLSID     clsid;

                hr = GetClsidFromExtOrMime( m_clsid, clsid, m_szExt, m_szType, NULL );
                if ( SUCCEEDED(hr) )
                    hr = CoGetClassObject(clsid, m_dwClsContext, m_pvReserved, m_riid, (void**) &punk);
                if (FAILED(hr))
                {
                    hr = pclientbsc->OnStopBinding(hr, L"");
                    pclientbsc->Release();

                    DEBUG_LEAVE(hr);
                    return hr;
                }
                pclientbsc->OnObjectAvailable(m_riid, punk);

                // release the IUnkown returned by CoGetClassObject
                punk->Release();

                m_bObjectAvailableCalled=TRUE;
            }
        }

        hr=pclientbsc->OnStopBinding(hrStatus, pszError);
        pclientbsc->Release();

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::GetBindInfo",
                    "this=%#x, %#x, %#x",
                    this, pgrfBINDF, pbindInfo
                    ));
                    
        IBindStatusCallback* pclientbsc=GetClientBSC();

        HRESULT hr = S_OK;
        if (pclientbsc)
            hr = pclientbsc->GetBindInfo(pgrfBINDF, pbindInfo);

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP OnDataAvailable(
        DWORD grfBSCF,
        DWORD dwSize,
        FORMATETC* pfmtetc,
        STGMEDIUM* pstgmed)
     {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::OnDataAvailable",
                    "this=%#x, %#x, %#x, %#x, %#x",
                    this, grfBSCF, dwSize, pfmtetc, pstgmed
                    ));
                    
        IBindStatusCallback* pclientbsc=GetClientBSC();

        HRESULT hr = S_OK;
        if (pclientbsc)
            hr = pclientbsc->OnDataAvailable(grfBSCF, dwSize, pfmtetc, pstgmed);

        DEBUG_LEAVE(hr);
        return hr;
     }

    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown* punk)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::OnObjectAvailable",
                    "this=%#x, %#x, %#x",
                    this, &riid, punk
                    ));
                    
        HRESULT hr=S_OK;
        // Save client BSC
        IBindStatusCallback* pclientbsc=GetClientBSC(); 
        if (pclientbsc) {
            pclientbsc->AddRef();
            hr=pclientbsc->OnObjectAvailable(riid, punk);
            pclientbsc->Release();
            m_bObjectAvailableCalled=TRUE;
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP OnProgress
    (
         ULONG ulProgress,
         ULONG ulProgressMax,
         ULONG ulStatusCode,
         LPCWSTR pwzStatusText
    )
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IBindStatusCallback::OnProgress",
                    "this=%#x, %#x, %#x, %#x, %.80wq",
                    this, ulProgress, ulProgressMax, ulStatusCode, pwzStatusText
                    ));
                    
        IBindStatusCallback* pclientbsc=GetClientBSC();

        HRESULT hr = S_OK;
        if (pclientbsc)
            hr = pclientbsc->OnProgress(ulProgress, ulProgressMax, ulStatusCode, pwzStatusText);

        DEBUG_LEAVE(hr);
        return hr;
    }

    // IServiceProvider, chains all other interfaces
    STDMETHODIMP QueryService( 
        REFGUID rsid,
        REFIID iid,
        void **ppvObj)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CBSCCreateObject::IserviceProvider::QueryService",
                    "this=%#x, %#x, %#x, %#x",
                    this, &rsid, &iid, ppvObj
                    ));
                    
        HRESULT hr=S_OK;
        IServiceProvider* pclientsp=NULL;

        hr=m_pclientbsc->QueryInterface(IID_IServiceProvider, (void**) &pclientsp);
        if (SUCCEEDED(hr))
        {
            hr=pclientsp->QueryService(rsid, iid, ppvObj);
            pclientsp->Release();
            if (SUCCEEDED(hr))
            {
                DEBUG_LEAVE(hr);
                return hr;
            }
        }
        IBindStatusCallback* pclientbsc=GetClientBSC();
        if (pclientbsc)
            hr = pclientbsc->QueryInterface(iid, ppvObj);
        else
            hr = QueryInterface(iid, ppvObj);

        DEBUG_LEAVE(hr);
        return hr;
    }
};

#endif // WRAP_OLE32_COINSTALL

/*
 *  CoGetClassObjectFromURL
 *
 * This is the exposed entry point into the Code Downloader.
 *
 * It takes parameters closely matching the INSERT tag
 *  REFCLSID rCLASSID,          // CLSID of object (may be NULL)
 *  LPCWSTR szCODE,             // URL to code (may be NULL)
 *  DWORD dwFileVersionMS,      // Version of primary object
 *  DWORD dwFileVersionLS,      // Version of primary object
 *  LPCWSTR szTYPE,             // MIME type (may be NULL)
 *  LPBINDCTX pBindCtx,         // Bind ctx
 *  DWORD dwClsContext,         // CLSCTX flags
 *  LPVOID pvReserved,          // Must be NULL
 *  REFIID riid,                // Usually IID_IClassFactory
 *  LPVOID * ppv                // Ret - usually IClassFactory *
 */

STDAPI
CoGetClassObjectFromURL (
    REFCLSID rCLASSID,          // CLSID of object (may be NULL)
    LPCWSTR szCODE,             // URL to code (may be NULL)
    DWORD dwFileVersionMS,      // Version of primary object
    DWORD dwFileVersionLS,      // Version of primary object
    LPCWSTR szTYPE,             // MIME type (may be NULL)
    LPBINDCTX pBindCtx,         // Bind ctx
    DWORD dwClsContext,         // CLSCTX flags
    LPVOID pvReserved,          // Must be NULL
    REFIID riid,                // Usually IID_IClassFactory
    LPVOID * ppv                // Ret - usually IClassFactory *
    )
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "CoGetClassObjectFromURL",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                    &rCLASSID, szCODE, dwFileVersionMS, dwFileVersionLS, szTYPE, pBindCtx, 
                    dwClsContext, pvReserved, &riid, ppv
                    ));
                    
    HRESULT hr = NO_ERROR;
    CLSID myclsid;
    int nForceDownload = 0;
    CDLDebugLog * pdlog = NULL;
    CodeDownloadData cdd;
    LPWSTR pwszClsid = NULL;
    WCHAR szCleanCODE[INTERNET_MAX_URL_LENGTH];
    LPSTR szTmp = NULL;
    LPWSTR wzPtr = NULL;
    LPSTR szBuf = NULL;

    cdd.szDistUnit = NULL;
    cdd.szClassString = NULL;
    
    cdd.szURL = NULL;
    
    cdd.szExtension = NULL;
    cdd.szMimeType = szTYPE;
    cdd.szDll = NULL;
    cdd.dwFileVersionMS = dwFileVersionMS;
    cdd.dwFileVersionLS = dwFileVersionLS;
    cdd.dwFlags = CD_FLAGS_NEED_CLASSFACTORY;

    if (szCODE) {
        StrCpyNW(szCleanCODE, szCODE, INTERNET_MAX_URL_LENGTH);
        wzPtr = szCleanCODE;
        while (*wzPtr && *wzPtr != L'#') {
            wzPtr++;
        }
        *wzPtr = L'\0';

        cdd.szURL = szCleanCODE;

        if (FAILED(Unicode2Ansi(szCODE, &szBuf))) {
            goto Exit;
        }
        szTmp = szBuf;
    }
    
    if (szTmp) {
        while (*szTmp && *szTmp != L'#') {
            szTmp++;
        }

        if (*szTmp == L'#') {
            
            // Actual codebase ends here. Anchor with NULL char.
            *szTmp = L'\0';
            szTmp++;

            // parsing code
            // Only allow: CODEBASE=http://foo.com#VERSION=1,0,0,0
            //         or: CODEBASE=http://foo.com#EXACTVERSION=1,0,0,0

            LPSTR   szStart = szTmp;
            while (*szTmp && *szTmp != '=') {
                szTmp++;
            }

            if (*szTmp) {
                // Found '=' delimiter. Anchor NULL
                *szTmp = '\0';
                szTmp++;

                if (!StrCmpI(szStart, "version")) {
                    GetVersionFromString(szTmp, &dwFileVersionMS, &dwFileVersionLS, ',');
                    cdd.dwFileVersionMS = dwFileVersionMS;
                    cdd.dwFileVersionLS = dwFileVersionLS;
                }
                else if (!StrCmpI(szStart, ("exactversion"))) {
                    cdd.dwFlags |= CD_FLAGS_EXACT_VERSION;
                    GetVersionFromString(szTmp, &dwFileVersionMS, &dwFileVersionLS, ',');
                    cdd.dwFileVersionMS = dwFileVersionMS;
                    cdd.dwFileVersionLS = dwFileVersionLS;
                }
            }
                
        }
    }

    hr = StringFromCLSID(rCLASSID, &pwszClsid);
    if(FAILED(hr))
        pwszClsid = NULL;

    // Prepare the debuglog for this download
    pdlog = CDLDebugLog::MakeDebugLog();
    if(pdlog)
    {
        pdlog->AddRef();
        // If there is some way to name the debug log, go ahead and initialize it
        if(pdlog->Init(pwszClsid, cdd.szMimeType, cdd.szExtension, cdd.szURL) != FALSE)
        {
            CDLDebugLog::AddDebugLog(pdlog);
        }
        else
        {
            pdlog->Release();
            pdlog = NULL;
        }
    }

    UrlMkDebugOut((DEB_CODEDL, "IN CoGetClassObjectFromURL CLASSID: %lx, TYPE=%ws...szCODE:(%ws), VersionMS:%lx, VersionLS:%lx\n",
             rCLASSID.Data1, cdd.szMimeType, cdd.szURL, cdd.dwFileVersionMS, cdd.dwFileVersionLS));

forcedownload:

    // Note about pvReserved: this is used by DCOM to get in the remote server
    // name and other info. If not NULL, then the caller wants us to use
    // dcom. if (pvReserved) just call CoGetClassObject.

    // call AsyncGetClassBits to do the real work
    if (pvReserved == NULL && (nForceDownload <= 1) ) 
        hr = AsyncGetClassBitsEx(rCLASSID, &cdd,
                pBindCtx, dwClsContext, pvReserved, riid);

    if (SUCCEEDED(hr) && (hr != MK_S_ASYNCHRONOUS)) {

        hr = GetClsidFromExtOrMime( rCLASSID, myclsid, cdd.szExtension, cdd.szMimeType, NULL);

        Assert(hr == S_OK);

        if (hr != S_OK)
        {
            hr = E_UNEXPECTED;
            if(pdlog)
                pdlog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_FAILED_CONVERT_CLSID, cdd.szExtension, cdd.szMimeType);
            goto Exit;
        }

        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "EXTERNAL::CoGetClassObject",
                    "%#x, %#x, %#x, %#x, %#x",
                    &myclsid, dwClsContext, pvReserved, &riid, ppv
                    ));
                    
        hr = CoGetClassObject(myclsid, dwClsContext, pvReserved, riid, ppv);

        DEBUG_LEAVE(hr);
        
        // BUGBUG: move this policy into the client with a CodeInstallProblem?
        // this hack is easier than reprocessing INF from previous download

        // if we're not using dcom, and the api thinks we're good to go (didn't need to
        // install), yet for these reasons we couldn't get the class object, force a download
        // If there's some other error, or the get class objct was successful, quit.
        if ( !pvReserved && ((hr == HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)) ||
             (hr == REGDB_E_CLASSNOTREG) ||
             (hr == HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND))) ) {

            if (hr == REGDB_E_CLASSNOTREG) {

                // if its a hack GUID that is not a COM object but just to
                // get the OBJECT tag to automatically slam a reg key or
                // install some software (like java vm) then don't
                // force an install

                if (!AdviseForceDownload(&myclsid, dwClsContext))
                    goto Exit;

            }

            UrlMkDebugOut((DEB_CODEDL, "WRN CoGetClassObjectFromURL hr:%lx%s, CLASSID: %lx..., szCODE:(%ws), VersionMS:%lx, VersionLS:%lx\n",
                           hr,": dependent dll probably missing, forcing download!",myclsid.Data1, cdd.szURL, cdd.dwFileVersionMS, cdd.dwFileVersionLS));

            cdd.dwFlags |= CD_FLAGS_FORCE_DOWNLOAD;
            nForceDownload++;
            goto forcedownload;

        }
        // falling through to exit
    }

Exit:
    // If we had some problem, dump the debuglog
    if(FAILED(hr) && pdlog)
    {
        pdlog->DumpDebugLog(NULL, 0, NULL, hr);
    }
    if(pwszClsid)
        delete pwszClsid;

    UrlMkDebugOut((DEB_CODEDL, "OUT CoGetClassObjectFromURL hr:%lx%s, CLASSID: %lx, TYPE=%ws..., szCODE:(%ws), VersionMS:%lx, VersionLS:%lx\n",
             hr,(hr == MK_S_ASYNCHRONOUS)?"(PENDING)":(hr == S_OK)?"(SUCCESS)":"",rCLASSID.Data1, cdd.szMimeType, cdd.szURL, cdd.dwFileVersionMS, cdd.dwFileVersionLS));
    if(pdlog)
    {
        CDLDebugLog::RemoveDebugLog(pdlog);
        pdlog->Release();
        pdlog = NULL;
    }

    if (szBuf) {
        delete [] szBuf;
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}

/*
 * SetCodeDownloadTLSVars
 *
 * sets up a bunch of tls variables
 * eg, setup cookie, trust cookie list, code download list and
 * the CDLPacket list
 * since TLS vars are HeapAllocated rather than using the new operator
 * the constructors for classes won't get run automatically
 * which is why we have all pointers and the actual classes get allocated
 * here
 */

HRESULT SetCodeDownloadTLSVars()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "SetCodeDownloadTLSVars",
                NULL
                ));
                    
    HRESULT hr = NO_ERROR;
    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr))     // if tls ctor failed above
        goto Exit;

    if (!tls->pSetupCookie) {
        tls->pSetupCookie = new CCookie<CCodeDownload *>(CODE_DOWNLOAD_SETUP);

        if (!tls->pSetupCookie) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    if (!tls->pTrustCookie) {
        tls->pTrustCookie = new CCookie<CDownload *>(CODE_DOWNLOAD_TRUST_PIECE);

        if (!tls->pTrustCookie) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    if (!tls->pCodeDownloadList) {
        tls->pCodeDownloadList = new CList<CCodeDownload *, CCodeDownload *>;

        if (!tls->pCodeDownloadList) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    if (!tls->pRejectedFeaturesList) {
        tls->pRejectedFeaturesList= new CList<LPCWSTR , LPCWSTR >;

        if (!tls->pRejectedFeaturesList) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    if (!tls->pCDLPacketMgr) {
        tls->pCDLPacketMgr = new CCDLPacketMgr();

        if (!tls->pCDLPacketMgr) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

/*
 * CoInstall
 *
 *
 * CoInstall() is a public API, also used by CoGetClassObjectFromUrl
 *
 *  It's primary implementation is in OLE32.
 */

STDAPI CoInstall(
    IBindCtx     *pbc,
    DWORD         dwFlags,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    LPWSTR        pszCodeBase)
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "CoInstall",
                    "%#x, %#x,  %#x, %#x, %.80wq",
                    pbc, dwFlags, pClassSpec, pQuery, pszCodeBase
                    ));
                    
    HRESULT hr;

    // BUGBUG: The real CoInstall needs this always set for now. MSICD/PrivateCoInstall shouldn't,
    // so we'll only set it in the case where we're calling NT5 OLE.
    // Setting this flag unconditionally may have bad side effects on offline mode.
    dwFlags = dwFlags | CD_FLAGS_FORCE_INTERNET_DOWNLOAD;
#ifndef WRAP_OLE32_COINSTALL
    dwFlags = dwFlags | CD_FLAGS_NEED_CLASSFACTORY;
#else
    dwFlags = dwFlags & (~CD_FLAGS_NEED_CLASSFACTORY);
#endif

    hr = SetCoInstall();

    if ( SUCCEEDED(hr) )
    {
        if ( g_bUseOLECoInstall )
            hr = (*g_pfnCoInstall)(pbc, dwFlags, pClassSpec, pQuery, pszCodeBase);
        else
            hr = PrivateCoInstall(pbc, dwFlags, pClassSpec, pQuery, pszCodeBase);
    }

    DEBUG_LEAVE_API(hr);
    return hr;
};

/*
 * AsyncInstallDistUnit
 *
 *
 * AsyncInstallDistributionUnit() the entry into the Code downloader creates this obj
 * for the given CODE, DistUnit, FileVersion, BSC (from BindCtx)
 *
 * The CodeDownload obj once created is asked to perform its function
 * thru CCodeDownload::DoCodeDownload().
 */


STDAPI
AsyncInstallDistributionUnitEx(
    CodeDownloadData * pcdd,            // Contains requested object's descriptors
    IBindCtx *pbc,                      // bind ctx
    REFIID riid,
    IUnknown **ppUnk,
    LPVOID pvReserved)                  // Must be NULL
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "AsyncInstallDistributionUnitEx",
                    "%#x, %#x, %#x, %#x, %#x",
                    pcdd, pbc, &riid, ppUnk, pvReserved
                    ));
    
    LPCWSTR szClientID = NULL;

    pcdd->dwFlags &= (CD_FLAGS_EXTERNAL_MASK | CD_FLAGS_EXACT_VERSION);

    HRESULT hr = AsyncGetClassBits2Ex(szClientID, pcdd, pbc, 0, NULL, riid, ppUnk);

    DEBUG_LEAVE_API(hr);
    return hr;
}

// backwards compatability (no dll name parameter)
STDAPI
AsyncInstallDistributionUnit(
    LPCWSTR szDistUnit,
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODEBASE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODEBASE
    IBindCtx *pbc,                      // bind ctx
    LPVOID pvReserved,                  // Must be NULL
    DWORD flags)
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "AsyncInstallDistributionUnit",
                    "%.80wq, %.80wq, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %#x",
                    szDistUnit, szTYPE, szExt, dwFileVersionMS, dwFileVersionLS, szURL, pbc, pvReserved, flags
                    ));
                    
    CodeDownloadData cdd;
    cdd.szDistUnit = szDistUnit;
    cdd.szClassString = szDistUnit;  // best choice we've got
    cdd.szURL = szURL;
    cdd.szMimeType = szTYPE;
    cdd.szExtension = szExt;
    cdd.szDll = NULL;
    cdd.dwFileVersionMS = dwFileVersionMS;
    cdd.dwFileVersionLS = dwFileVersionLS;
    cdd.dwFlags = flags;
    
    HRESULT hr = AsyncInstallDistributionUnitEx(&cdd, pbc, IID_IUnknown, NULL, pvReserved);

    DEBUG_LEAVE_API(hr);
    return hr;
}

/*
 * AsyncGetClassBits
 *
 *
 * AsyncGetClassBits() the entry into the Code downloader creates this obj
 * for the given CODE, CLSID, FileVersion, BSC (from BindCtx)
 * we do not check to see if a code download is already in progress
 * in the system at a given moment. Nor we do we keep track of individual
 * downloads and possible clashes between various silmultaneous code
 * downloads system wide. We leave it to URL moniker (above us) to ensure
 * that duplicate calls are not made into AsynGetClassBits. The second
 * problem of different code downloads trying to bring down a common
 * dependent DLL is POSTPONED to version 2 implementation.
 *
 * The CodeDownload obj once created is asked to perform its function
 * thru CCodeDownload::DoCodeDownload().
 */

STDAPI
AsyncGetClassBits(
    REFCLSID rclsid,                    // CLSID
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODE= in INSERT tag
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    DWORD flags)
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "AsyncGetClassBits",
                    "%#x, %.80wq, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                    &rclsid, szTYPE, szExt, dwFileVersionMS, dwFileVersionLS, szURL, pbc, dwClsContext, pvReserved, &riid, flags
                    ));
                    
    CodeDownloadData cdd;
    cdd.szDistUnit = NULL;
    cdd.szClassString = NULL;
    cdd.szURL = szURL;
    cdd.szMimeType = szTYPE;
    cdd.szExtension = szExt;
    cdd.szDll = NULL;
    cdd.dwFileVersionMS = dwFileVersionMS;
    cdd.dwFileVersionLS = dwFileVersionLS;
    cdd.dwFlags = flags;
    
    HRESULT hr = AsyncGetClassBitsEx(rclsid, &cdd, pbc, dwClsContext, pvReserved, riid);

    DEBUG_LEAVE_API(hr);
    return hr;
}

STDAPI
AsyncGetClassBitsEx(
    REFCLSID rclsid,                    // CLSID
    CodeDownloadData *pcdd,
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid)                        // Usually IID_IClassFactory
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "AsyncGetClassBitsEx",
                    "%#x, %#x, %#x, %#x, %#x, %#x",
                    &rclsid, pcdd, pbc, dwClsContext, pvReserved, &riid
                    ));
                    
    LPOLESTR pwcsClsid = NULL;
    LPCWSTR szClientID = NULL;
    HRESULT hr=S_OK;
    pcdd->dwFlags &= (CD_FLAGS_EXTERNAL_MASK | CD_FLAGS_EXACT_VERSION);
    CDLDebugLog * pdlog = NULL;

    // return if we can't get a valid string representation of the CLSID
    if (!IsEqualGUID(rclsid , CLSID_NULL) &&
        (FAILED((hr=StringFromCLSID(rclsid, &pwcsClsid)))) )
    {
        pdlog = CDLDebugLog::GetDebugLog(NULL, pcdd->szMimeType, 
                                         pcdd->szExtension, pcdd->szURL);
        if(pdlog)
        {
            pdlog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_FAILED_STRING_FROM_CLSID);
        }
        goto Exit;
    }
    pcdd->szDistUnit = pwcsClsid;
    pcdd->szClassString = pwcsClsid;  // dist unit and clsid are the same from this entry point
#ifndef WRAP_OLE32_COINSTALL

    // Work around a problem with OLE32's CoInstall (until wrappers are enabled or OLE calls PrivateCoInstall):
    //    since CoInstall doesn't known the IID, 
    //    it calls AsyncGetClassBits with IID_IUnknown (instead of IID_IClassFactory)
    if ((pcdd->dwFlags & CD_FLAGS_FORCE_INTERNET_DOWNLOAD) && IsEqualGUID(riid, IID_IUnknown))
    {
        hr = AsyncGetClassBits2Ex(szClientID, pcdd,
            pbc,dwClsContext,pvReserved,IID_IClassFactory,NULL);
    }
    else
    {
#endif
        hr = AsyncGetClassBits2Ex(szClientID, pcdd,
            pbc,dwClsContext,pvReserved,riid,NULL);

#ifndef WRAP_OLE32_COINSTALL
    }
#endif

Exit:

    if (pwcsClsid != NULL)
        delete pwcsClsid;

    DEBUG_LEAVE_API(hr);
    return hr;
}

HRESULT GetIEFeatureVersion(
    LPCWSTR szDistUnit,                 // CLSID, can be an arbit unique str
    LPCWSTR szTYPE,
    CLSID clsid,
    QUERYCONTEXT *pqc)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetIEFeatureVersion",
                "%.80wq, %.80wq, %#x, %#x",
                szDistUnit, szTYPE, &clsid, pqc
                ));
                
    HRESULT     hr  = S_OK;

    memset(pqc, 0, sizeof(QUERYCONTEXT));

    if (!IsEqualGUID(clsid, CLSID_NULL)) {
        hr = GetIEFeatureFromClass(NULL, clsid, pqc);

    } else if (szTYPE) {
        hr = GetIEFeatureFromMime(NULL, szTYPE, pqc);

    } else {
        // not an IE feature
        hr = S_FALSE;
        goto Exit;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT InstallIEFeature(
    LPCWSTR szDistUnit,                 // CLSID, can be an arbit unique str
    LPCWSTR szTYPE,
    CLSID clsid,
    IBindCtx *pbc,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    DWORD dwFlags,
    BOOL bIEVersion
    )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "InstallIEFeature",
                "%.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x, %B",
                szDistUnit, szTYPE, &clsid, pbc, dwFileVersionMS, dwFileVersionLS, dwFlags, bIEVersion
                ));
                
    HRESULT     hr  = S_OK;
    uCLSSPEC classpec;
    IWindowForBindingUI *pWindowForBindingUI = NULL;
    IBindStatusCallback *pclientbsc = NULL;
    HWND hWnd = NULL;
    REFGUID rguidReason = IID_ICodeInstall;
    QUERYCONTEXT qc;
    DWORD dwJITFlags = 0;

    memset(&qc, 0, sizeof(qc));

    qc.dwVersionHi = dwFileVersionMS;
    qc.dwVersionLo = dwFileVersionLS;

    if (!IsEqualGUID(clsid, CLSID_NULL)) {
        classpec.tyspec=TYSPEC_CLSID;
        classpec.tagged_union.clsid=clsid;
    } else if (szTYPE) {
        classpec.tyspec=TYSPEC_MIMETYPE;
        classpec.tagged_union.pMimeType=(LPWSTR)szTYPE;
    } else {
        // not an IE feature
        hr = S_FALSE;
        goto Exit;
    }


    hr = FaultInIEFeature(hWnd, &classpec, &qc, (bIEVersion?0:FIEF_FLAG_CHECK_CIFVERSION)|FIEF_FLAG_PEEK);

    if ( hr == HRESULT_FROM_WIN32(ERROR_UNKNOWN_REVISION) ||
         hr == E_ACCESSDENIED) {

        // the version in the CIF will not satisfy the requested version
        // or the admin has turned off JIT or the user has turned off
        // JIT in Inetcpl: if they wanted to turn off code download
        // they should do it per-zone activex signed/unsigned policy.

        // fall thru to code download from the CODEBASE

        hr = S_FALSE;
    }

    if (hr == S_OK) {

        // We always come in here from code downloader at a point
        // where looking at the com branch and DU key, something is 
        // busted and so needs code download. We can't at this point 
        // succeed. Likely the AS keys are just orphaned and it looks
        // installed, but is not.
        // However, to account for cases where JIT could be right
        // we will only force JIT download when instrcuted to

        if (dwFlags & CD_FLAGS_FORCE_DOWNLOAD) {
            hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED);
            dwJITFlags |= FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK;
        }

    }

    if (hr != HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED)) {
        goto Exit;
    }

    // must really install now, get an hwnd

    hr = pbc->GetObjectParam(REG_BSCB_HOLDER, (IUnknown **)&pclientbsc);
    if (FAILED(hr))
        goto Exit;

    // don't JIT if web crawling
    {
        DWORD grfBINDF = 0;
        BINDINFO bindInfo;
        memset(&bindInfo, 0, sizeof(BINDINFO));
        bindInfo.cbSize = sizeof(BINDINFO);

        pclientbsc->GetBindInfo(&grfBINDF, &bindInfo);

        ReleaseBindInfo(&bindInfo);

        if (grfBINDF & BINDF_SILENTOPERATION)
        {
            hr = MK_E_MUSTBOTHERUSER;
            goto Exit;
        }

    }

    // Get IWindowForBindingUI ptr
    hr = pclientbsc->QueryInterface(IID_IWindowForBindingUI,
            (LPVOID *)&pWindowForBindingUI);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = pclientbsc->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);
            pServProv->Release();
        }
    }

    // get hWnd
    if (pWindowForBindingUI) {
        pWindowForBindingUI->GetWindow(rguidReason, &hWnd);
        pWindowForBindingUI->Release();

        memset(&qc, 0, sizeof(qc)); // reset, peek state modifies this with 
                                    // currently installed version info!

        qc.dwVersionHi = dwFileVersionMS;
        qc.dwVersionLo = dwFileVersionLS;

        hr = FaultInIEFeature(hWnd, &classpec, &qc, dwJITFlags);

    }
    else {
        hr = MK_E_MUSTBOTHERUSER;
        // fallthru to Exit
        // goto Exit;
    }

Exit:

    if (pclientbsc)
        pclientbsc->Release();

    DEBUG_LEAVE(hr);
    return hr;
}


// if both signed and unsigned activex is disallowed then return failure
// so we can avoid downloading the CAB altogether
HRESULT
CheckActiveXDownloadEnabled(
    IInternetHostSecurityManager *pHostSecurityManager,
    LPCWSTR szCodebase,
    IBindStatusCallback* pBSC)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CheckActiveXDownloadEnabled",
                "%#x, %.80wq",
                pHostSecurityManager, szCodebase
                ));
                
    HRESULT hr = S_OK;
    DWORD dwPolicy;
    DWORD grfBINDF = 0;
    BINDINFO bindInfo;
    memset(&bindInfo, 0, sizeof(BINDINFO));
    bindInfo.cbSize = sizeof(BINDINFO);
    BOOL fEnforceRestricted = FALSE;
    
    hr = pBSC->GetBindInfo(&grfBINDF, &bindInfo);
    if (SUCCEEDED(hr))
    {
        ReleaseBindInfo(&bindInfo);
        if (grfBINDF & BINDF_ENFORCERESTRICTED)
            fEnforceRestricted = TRUE;
    }
    
    hr = GetActivePolicy(pHostSecurityManager, szCodebase,
                        URLACTION_DOWNLOAD_SIGNED_ACTIVEX, dwPolicy, fEnforceRestricted);

    if (FAILED(hr)) {
        hr = GetActivePolicy(pHostSecurityManager, szCodebase,
                        URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX, dwPolicy, fEnforceRestricted);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// backwards compatability
STDAPI
AsyncGetClassBits2(
    LPCWSTR szClientID,                 // client ID, root object if NULL
    LPCWSTR szDistUnit,                 // CLSID, can be an arbit unique str
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODE= in INSERT tag
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    DWORD flags)
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "AsyncGetClassBits2",
                    "%.80wq, %.80wq, %.80wq, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                    szClientID, szDistUnit, szTYPE, szExt, dwFileVersionMS, dwFileVersionLS, szURL, pbc, dwClsContext, pvReserved, &riid, flags
                    ));
                    
    CodeDownloadData cdd;
    cdd.szDistUnit = szDistUnit;
    cdd.szClassString = szDistUnit;  // best choice we've got
    cdd.szURL = szURL;
    cdd.szMimeType = szTYPE;
    cdd.szExtension = szExt;
    cdd.szDll = NULL;
    cdd.dwFileVersionMS = dwFileVersionMS;
    cdd.dwFileVersionLS = dwFileVersionLS;
    cdd.dwFlags = flags;
    
    HRESULT hr = AsyncGetClassBits2Ex(szClientID,&cdd,pbc,dwClsContext,
                              pvReserved,riid,NULL);

    DEBUG_LEAVE_API(hr);
    return hr;
}

STDAPI
AsyncGetClassBits2Ex(
    LPCWSTR szClientID,                 // client ID, root object if NULL
    CodeDownloadData * pcdd,
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    IUnknown **ppUnk)                   // pass back pUnk for synchronous case
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "AsyncGetClassBits2Ex",
                    "%.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                    szClientID, pcdd, pbc, dwClsContext, pvReserved, &riid, ppUnk
                    ));
                    
    LPCWSTR szDistUnit    = pcdd->szDistUnit;       // Name of dist unit, may be a clsid
    LPCWSTR szClassString = pcdd->szClassString;    // Clsid to call com with/get object on
    LPCWSTR szTYPE        = pcdd->szMimeType;
    LPCWSTR szExt         = pcdd->szExtension;
    DWORD dwFileVersionMS = pcdd->dwFileVersionMS;  // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS = pcdd->dwFileVersionLS;  // MAKEDWORD(c,b) of above
    LPCWSTR szURL         = pcdd->szURL;            // CODE= in INSERT tag
    LPCWSTR szDll         = pcdd->szDll;            // Dll name for zero impact (can be NULL)
    DWORD flags           = pcdd->dwFlags;
     
    CCodeDownload* pcdl = NULL;
    HRESULT hr = NO_ERROR;
    IBindStatusCallback *pclientbsc = NULL;
    LISTPOSITION pos;
    CClBinding *pClientbinding;
    char    szExistingBuf[MAX_PATH];
    DWORD cExistingSize = MAX_PATH;
    char *pBaseExistingName = NULL;
    HKEY hKeyIESettings = 0;
    LONG lResult;
    CLSID myclsid;
    CLSID inclsid = CLSID_NULL;
    LPSTR pPluginFileName = NULL;
    BOOL bHintActiveX = (flags & CD_FLAGS_HINT_ACTIVEX)?TRUE:FALSE;
    BOOL bHintJava = (flags & CD_FLAGS_HINT_JAVA)?TRUE:FALSE;
    BOOL bNullClsid;
    BOOL bIEVersion = FALSE;
    CLocalComponentInfo* plci = NULL;
    IInternetHostSecurityManager *pHostSecurityManager = NULL;
    CDLDebugLog * pdlog = NULL;
    
    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))     // if tls ctor failed above
        goto AGCB_Exit;

    pdlog = CDLDebugLog::GetDebugLog(szDistUnit, szTYPE, szExt, szURL);
    if(pdlog)
        pdlog->AddRef();

    plci = new CLocalComponentInfo();
    if(!plci) {
        hr = E_OUTOFMEMORY;
        goto AGCB_Exit;
    }

    if(szClassString)
        CLSIDFromString((LPOLESTR)szClassString, &inclsid);// if fails szClassString is not clsid

    // Fill myclsid with inclsid (if not null-clsid), the clsid corresponding
    // to the mime type in szTYPE (if not NULL), the clsid corresponding
    // to the file extension in szExt (if not NULL), or the clsid for the
    // plugin corresponging to the mime type or extension (if not NULL),
    // in that order of preference
    hr = GetClsidFromExtOrMime( inclsid, myclsid, szExt, szTYPE,
        &pPluginFileName);

    // hr = S_OK: mapped to a clsid
    // hr = S_FALSE: don't know what it is
    // hr error, fail

    if (FAILED(hr))
    {
        if(pdlog)
        {
            pdlog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_FAILED_CONVERT_CLSID, szExt, szTYPE);
        }
        goto AGCB_Exit;
    }

    hr = S_OK; //reset

    if (!(dwFileVersionMS | dwFileVersionLS)) {

        // maybe this is an IE feature like Java
        // that may require that a matching version
        // that is later than one currently installed
        // is needed

        if (!g_bNT5OrGreater) {
            QUERYCONTEXT qc;
            hr = GetIEFeatureVersion(szDistUnit, szTYPE, inclsid, &qc);
    
            if (FAILED(hr))
                goto AGCB_Exit;
    
            dwFileVersionMS = qc.dwVersionHi;
            dwFileVersionLS = qc.dwVersionLo;
    
            if (dwFileVersionMS | dwFileVersionLS) {
                bIEVersion = TRUE;
            }
        }
    }


    bNullClsid = IsEqualGUID(myclsid, CLSID_NULL);

    if (szDistUnit || !bNullClsid ) {

        // manage to map to a clsid or has a distunit name

        CLSID pluginclsid = CLSID_ActiveXPlugin;
        if (!IsEqualGUID(myclsid , pluginclsid)) {
            // mark that we now have a clsid throw away TYPE, Ext
            szTYPE = NULL;
            szExt = NULL;
        }

        // check to see if locally installed.
        HRESULT                hrExact;
        HRESULT                hrAny;
        
        if (FAILED((hrAny = IsControlLocallyInstalled(pPluginFileName,
                (pPluginFileName)?(LPCLSID)&inclsid:&myclsid, szDistUnit,
                dwFileVersionMS, dwFileVersionLS, plci, NULL, FALSE)))) {
            goto AGCB_Exit;
        }

        if (pcdd->dwFlags & CD_FLAGS_EXACT_VERSION) {

            if (FAILED((hrExact = IsControlLocallyInstalled(pPluginFileName,
                    (pPluginFileName)?(LPCLSID)&inclsid:&myclsid, szDistUnit,
                    dwFileVersionMS, dwFileVersionLS, plci, NULL, TRUE)))) {
                goto AGCB_Exit;
            }

            if (hrAny != S_OK) {
                // Don't have at least the requested version. Do the download.
                hr = hrAny;
            }
            else if (hrAny == S_OK && hrExact == S_FALSE) {
                // Newer control installed, must downgrade
                // Check if this is a system control, and disallow if it is
                BOOL bIsDPFComponent = FALSE;
                HKEY hKeyIESettings = 0;
                CHAR szOCXCacheDirSFN[MAX_PATH];
                CHAR szFNameSFN[MAX_PATH];
                DWORD dwType;
                DWORD Size;
                
                Size = MAX_PATH;
                dwType = REG_SZ;

                if (SUCCEEDED(RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_SETTINGS, 0,
                                           KEY_READ, &hKeyIESettings))) {
                
                    if (SUCCEEDED(RegQueryValueEx(hKeyIESettings, g_szActiveXCache,
                        NULL, &dwType, (unsigned char *)g_szOCXCacheDir, &Size))) {
    
                        if (plci->szExistingFileName[0]) {

                            GetShortPathName(plci->szExistingFileName, szFNameSFN, MAX_PATH);
                            GetShortPathName(g_szOCXCacheDir, szOCXCacheDirSFN, MAX_PATH);

                            if (StrStrI(szFNameSFN, szOCXCacheDirSFN)) {
                                bIsDPFComponent = TRUE;
                            }
                        }
    
                        RegCloseKey(hKeyIESettings);
                    }
                }

                if (!bIsDPFComponent) {
                    // Trying to do a downgrade of a non-DPF component.
                    // Cut this off, and just act as if the existing (newer)
                    // version is already good enough. No download/install.

                    hr = S_OK;
                }
                else {
                    // Do the download
                    hr = hrExact;
                }

            }
            else {
                // hrAny == hrExact == S_OK, so we're done
                Assert(hrAny == S_OK && hrExact == S_OK);
                hr = hrAny;
            }

        }
        else {
            // Continue as before
            hr = hrAny;
        }

        if ( hr == S_OK) { // local version OK

            if (!(flags & CD_FLAGS_FORCE_DOWNLOAD)) {
                
                // check here is a new version has been
                // advertised for this DU. If so, force a -1 or Get Latest

                if (!((plci->dwAvailMS > plci->dwLocFVMS) ||
                         ((plci->dwAvailMS == plci->dwLocFVMS) &&
                             (plci->dwAvailLS > plci->dwLocFVLS))) ) {

                    // Code Download thinks the 
                    // current version is good enough
                    goto AGCB_Exit;
                }

                dwFileVersionMS = 0xffffffff;
                dwFileVersionLS = 0xffffffff;
            }

            // force download flag! Fall thru and Do it!
        }
    } else {

        // couldn't map to a clsid
        // just have ext or mime type

    }

    // here if we are going to do a code download.

    if ((flags & CD_FLAGS_NEED_CLASSFACTORY) &&
        (dwFileVersionMS  == 0) && (dwFileVersionLS == 0)) {

        HRESULT               hrResult = S_OK;
        IUnknown             *punk = NULL;

        // We don't care about the version. Check if someone registered
        // themselves with COM via CoRegisterClassObject, and if it
        // succeeds, we don't need to download.

        hrResult = CoGetClassObject(((pPluginFileName) ? (inclsid) : (myclsid)),
                                    dwClsContext, pvReserved, riid, (void**)&punk);
        if (SUCCEEDED(hrResult)) {
            punk->Release();
            hr = S_OK;
            goto AGCB_Exit;
        }
    }

    if (flags & CD_FLAGS_PEEK_STATE) {
        hr = S_FALSE;
        goto AGCB_Exit;
    }

    // check language being right version
    if (plci->bForceLangGetLatest) {
        dwFileVersionMS = 0xffffffff;
        dwFileVersionLS = 0xffffffff;
    } else if ((dwFileVersionMS != 0xffffffff) && (dwFileVersionLS != 0xffffffff)) {
        // try the JIT API first before code download

        hr = InstallIEFeature(szDistUnit, szTYPE, inclsid, pbc, dwFileVersionMS, dwFileVersionLS, flags, bIEVersion);

        if (hr != S_FALSE)
            goto AGCB_Exit;
    }
    hr = SetCoInstall();
    if ( FAILED(hr) )
        goto AGCB_Exit;

    if ( g_bUseOLECoInstall && !(flags & CD_FLAGS_FORCE_INTERNET_DOWNLOAD) )
    {
        CLSID inclsid;

        CLSIDFromString((LPOLESTR)szDistUnit, &inclsid);
        hr = WrapCoInstall( inclsid, szURL, dwFileVersionMS, dwFileVersionLS, szTYPE, pbc,
                              dwClsContext,pvReserved, riid, flags);

        if ( SUCCEEDED(hr) )
            goto AGCB_Exit;
    }

    hr = SetCodeDownloadTLSVars();
    if (FAILED(hr))
        goto AGCB_Exit;

    hr = SetGlobals();
    if (FAILED(hr))
        goto AGCB_Exit;

    if (g_bLockedDown) {
        hr = E_ACCESSDENIED;
        goto AGCB_Exit;
    }

    hr = pbc->GetObjectParam(REG_BSCB_HOLDER, (IUnknown **)&pclientbsc);
    if (FAILED(hr))
        goto AGCB_Exit;

    pbc->AddRef();  // pbc gets saved in the CClBinding and gets released in
                    // ~CClBinding()

    // after this point if a CClBinding does not get
    // created, we will leak the client BC and BSC
    // check appropriately and release client

    // check to see if a code download is in progress for this CLSID
    // Note, this only checks for top level objects now.

    pHostSecurityManager = GetHostSecurityManager(pclientbsc);

    hr = CCodeDownload::HandleDuplicateCodeDownloads(szURL, szTYPE, szExt,
                myclsid, szDistUnit, dwClsContext, pvReserved, riid, pbc, pclientbsc, flags, pHostSecurityManager);

    // if it was a dulplicate request and got piggybacked to
    // a CodeDownload in progress we will get back MK_S_ASYNCHRONOUS
    // return of S_OK means that no DUP was found and we are to issue
    // fresh code download

    if (FAILED(hr)) {
        // release client here
        pclientbsc->Release();
        pbc->Release();
        goto AGCB_Exit;
    }

    if (hr == MK_S_ASYNCHRONOUS)
        goto AGCB_Exit;


    pcdl = new CCodeDownload(szDistUnit, szURL, szTYPE, szExt, dwFileVersionMS, dwFileVersionLS, &hr);

    if (FAILED(hr)) {
        // constructor failed!
        pcdl->Release();
    }

    if (!pcdl) {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        // release client here
        pclientbsc->Release();
        pbc->Release();
        goto AGCB_Exit;
    }

    // Pass off the debug log to the ccodedownload
    if(pdlog)
    {
        pcdl->SetDebugLog(pdlog);
    }    

    pcdl->SetExactVersion((pcdd->dwFlags & CD_FLAGS_EXACT_VERSION) != 0);

    CClBinding *pClientBinding;
    hr = pcdl->CreateClientBinding( &pClientBinding, pbc, pclientbsc,
                inclsid, dwClsContext, pvReserved, riid,
                TRUE /* fAddHead */, pHostSecurityManager);

    if (FAILED(hr)) {
        // release client here
        pclientbsc->Release();
        pbc->Release();
        pcdl->Release();
        goto AGCB_Exit;
    }

    pClientBinding->SetClassString(szClassString);

    // check if our current security settings allow us to do a code download
    // this is a quick out to avoid doing a download when all activex is
    // disabled and we think this is ActiveX.

    if (bHintActiveX || (!bNullClsid && !bHintJava)) {

        // get the zone mgr and check for policy on signed and unsigned
        // activex controls. If both are disabled then stop here
        // otherwise proceed to download main CAB and WVT will determine the
        // policy based on the appropriate urlaction (singed/unsigned)

       hr = CheckActiveXDownloadEnabled(pHostSecurityManager, szURL, pclientbsc);

       if (FAILED(hr)) {
            pcdl->Release();
            goto AGCB_Exit;
       }
    }

    // chain this CodeDownload to the list of downloads in this thread

    pos = tls->pCodeDownloadList->AddHead(pcdl);
    pcdl->SetListCookie(pos);

    hr = pcdl->DoCodeDownload(plci, flags);
    plci = NULL;

    pcdl->Release();    // if async binding OnStartBinding would have addref'ed

AGCB_Exit:


    if (pPluginFileName)
        delete pPluginFileName;

    if(pdlog)
        pdlog->Release();

    SAFEDELETE(plci);

    SAFERELEASE(pHostSecurityManager);

    DEBUG_LEAVE_API(hr);
    return hr;

}

STDAPI
WrapCoInstall (
    REFCLSID rCLASSID,          // CLSID of object (may be NULL)
    LPCWSTR szCODE,             // URL to code (may be NULL)
    DWORD dwFileVersionMS,      // Version of primary object
    DWORD dwFileVersionLS,      // Version of primary object
    LPCWSTR szTYPE,             // MIME type (may be NULL)
    LPBINDCTX pBindCtx,         // Bind ctx
    DWORD dwClsContext,         // CLSCTX flags
    LPVOID pvReserved,          // Must be NULL
    REFIID riid,                // Usually IID_IClassFactory
    DWORD flags
    )
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "WrapCoInstall",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                    &rCLASSID, szCODE, dwFileVersionMS, dwFileVersionLS, szTYPE, pBindCtx, dwClsContext, pvReserved, &riid, flags
                    ));
                    
   HRESULT hr = NO_ERROR;
//    DWORD flags = 0; // CD_FLAGS_NEED_CLASSFACTORY;
    WCHAR *szExt = NULL;

#ifdef WRAP_OLE32_COINSTALL
    CBSCCreateObject* pobjectbsc=NULL;
#endif

    UrlMkDebugOut((DEB_CODEDL, "IN WrapCoInstall CLASSID: %lx, TYPE=%ws...szCODE:(%ws), VersionMS:%lx, VersionLS:%lx\n", rCLASSID.Data1, szTYPE, szCODE, dwFileVersionMS, dwFileVersionLS));

    // Note about pvReserved: this is used by DCOM to get in the remote server
    // name and other info. If not NULL, then the caller wants us to use
    // dcom. if (pvReserved) just call CoGetClassObject.

    // call AsyncGetClassBits to do the real work
    if (pvReserved == NULL)
    {
        // Set up CoInstall parameters
        uCLSSPEC classpec;
        QUERYCONTEXT query;
    
        if (!IsEqualGUID(rCLASSID, CLSID_NULL))
        {
            classpec.tyspec=TYSPEC_CLSID;
            classpec.tagged_union.clsid=rCLASSID; // use original class ID so that MIME can still be processed
        }
        else if (szTYPE && *szTYPE)
        {
            classpec.tyspec=TYSPEC_MIMETYPE;
            classpec.tagged_union.pMimeType=(LPWSTR) szTYPE; // BUGBUG uCLSSPEC::pMimeType should be declared const!
        }
        else
        {
            hr=E_INVALIDARG;
            goto Exit;
        }

        query.dwContext   = dwClsContext;
        GetDefaultPlatform(&query.Platform);
        query.Locale    = GetThreadLocale();
        query.dwVersionHi = dwFileVersionMS;
        query.dwVersionLo = dwFileVersionLS;

#ifdef WRAP_OLE32_COINSTALL
        // Override the client's BSC with a BSC that will create the object when it receives a successful OnStopBinding
        //   CBSCCreateObject registers itself in the bind context and saves a pointer to the client's BSC
        //   it unregisters itself upon OnStopBinding
        pobjectbsc=new CBSCCreateObject(rCLASSID, szTYPE, szExt, dwClsContext, pvReserved, riid, pBindCtx, flags, hr); // hr by reference!
        if (!pobjectbsc)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (FAILED(hr))
        {
            goto Exit;
        }
#endif
        hr=CoInstall(pBindCtx, flags, &classpec, &query, (LPWSTR) szCODE); //BUGBUG CoInstall szCodeBase should be const!
  
        if (hr!=MK_S_ASYNCHRONOUS)
        {
            // clean up the bind context for synchronous and failure case
            // in asynchronous case pobjectbsc revokes itself in OnStopBinding!
            //pobjectbsc->RevokeFromBC();
        }
        //hr = AsyncGetClassBits( rCLASSID,
        //        szTYPE, szExt,
        //        dwFileVersionMS, dwFileVersionLS, szCODE,
        //        pBindCtx, dwClsContext, pvReserved, riid, flags);
#ifdef WRAP_OLE32_COINSTALL
        pobjectbsc->Release();
        pobjectbsc=NULL;
#endif

    }

Exit:
#ifdef WRAP_OLE32_COINSTALL
    if (pobjectbsc)
    {
        pobjectbsc->Release();
        pobjectbsc=NULL;
    }
#endif

    UrlMkDebugOut((DEB_CODEDL, "OUT WrapCoInstall hr:%lx%s, CLASSID: %lx, TYPE=%ws..., szCODE:(%ws), VersionMS:%lx, VersionLS:%lx\n",
    hr,(hr == MK_S_ASYNCHRONOUS)?"(PENDING)":(hr == S_OK)?"(SUCCESS)":"",
    rCLASSID.Data1, szTYPE, szCODE, dwFileVersionMS, dwFileVersionLS));

    DEBUG_LEAVE_API(hr);
    return hr;
}

STDAPI PrivateCoInstall(
    IBindCtx     *pbc,
    DWORD         dwFlags,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    LPWSTR        pszCodeBase)
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "PrivateCoInstall",
                    "%#x, %#x, %#x, %#x, %.80wq",
                    pbc, dwFlags, pClassSpec, pQuery, pszCodeBase
                    ));

    HRESULT hr = NO_ERROR;
    CLSID inclsid = CLSID_NULL;
    LPCWSTR pszDistUnit=NULL; 
    LPCWSTR pszFileExt=NULL;
    LPCWSTR pszMimeType=NULL;
    QUERYCONTEXT    query;


    // "Parse" the parameters from the CLSSPEC and QUERYCONTEXT
    //   Get the class spec.
    if(pClassSpec != NULL)
    {
        switch(pClassSpec->tyspec)
        {
        case TYSPEC_CLSID:
            inclsid = pClassSpec->tagged_union.clsid;
            break;
        case TYSPEC_MIMETYPE:
            pszMimeType = (LPCWSTR) pClassSpec->tagged_union.pMimeType;
            break;
        case TYSPEC_FILEEXT:
            pszFileExt = (LPCWSTR) pClassSpec->tagged_union.pFileExt;
            break;
        case TYSPEC_FILENAME:
            pszDistUnit= (LPCWSTR) pClassSpec->tagged_union.pFileName; // clean-up: this is the only case where we assign existing mem to pszDistUnit!
            // BUGBUG: need to do this in OLE's CoInstall as well!
            CLSIDFromString((LPOLESTR)pszDistUnit, &inclsid);// if fails szDistUnit is not clsid
            break;
        default:
            break;
        }
    }

    //Get the query context.
    if(pQuery != NULL)
    {
        query = *pQuery;
    }
    else
    {
        query.dwContext   = CLSCTX_ALL;
        GetDefaultPlatform(&query.Platform);
        query.Locale    = GetThreadLocale();
        query.dwVersionHi = (DWORD) -1;
        query.dwVersionLo = (DWORD) -1;
    }

    hr = AsyncInstallDistributionUnit(  pszDistUnit,
                                        pszMimeType,
                                        pszFileExt,
                                        query.dwVersionHi, query.dwVersionLo,
                                        pszCodeBase,          
                                        pbc,                
                                        NULL,             
                                        dwFlags | CD_FLAGS_FORCE_INTERNET_DOWNLOAD // ensure no mutual recursion
                                     );

    DEBUG_LEAVE_API(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\advpkp.h ===
#ifdef __cplusplus

// ADVPACK.DLL delay load

class CRunSetupHook
{
    public:

#ifdef WX86
#define DELAYRSCAPI(_fn, _args, _nargs) \
    DWORD _fn _args { \
        HRESULT hres = Init(); \
        DWORD dwRet = (DWORD)hres; \
        if (SUCCEEDED(hres)) { \
            dwRet = _pfn##_fn _nargs; \
        } \
        return dwRet;    } \
    DWORD (STDAPICALLTYPE* _pfn##_fn) _args; \
    DWORD _fn##X86 _args { \
        HRESULT hres = InitX86(); \
        DWORD dwRet = (DWORD)hres; \
        if (SUCCEEDED(hres)) { \
            dwRet = _pfn##_fn##X86 _nargs; \
        } \
        return dwRet;    } \
    DWORD (STDAPICALLTYPE* _pfn##_fn##X86) _args;
#else
#define DELAYRSCAPI(_fn, _args, _nargs) \
    DWORD _fn _args { \
        HRESULT hres = Init(); \
        DWORD dwRet = (DWORD)hres; \
        if (SUCCEEDED(hres)) { \
            dwRet = _pfn##_fn _nargs; \
        } \
        return dwRet;    } \
    DWORD (STDAPICALLTYPE* _pfn##_fn) _args;
#endif

    HRESULT     Init(void);
#ifdef WX86
    HRESULT     InitX86(void);

    typedef BOOL (*pfnUnloadFn)(HMODULE hMod);
    pfnUnloadFn pfnUnload;
#endif
    CRunSetupHook();
    ~CRunSetupHook();

    BOOL    m_fInited;
    HMODULE m_hMod;
#ifdef WX86
    BOOL    m_fInitedX86;
    HMODULE m_hModX86;
    HMODULE m_hModWx86;
#endif

    DELAYRSCAPI( RunSetupCommand,
    (HWND    hWnd,
    LPSTR   szCmdName,
    LPSTR   szInfSection,
    LPSTR   szDir,
    LPSTR   szTitle,
    HANDLE *phEXE,
    DWORD   dwFlags,
    LPVOID  pvReserved),
    (hWnd, szCmdName, szInfSection, szDir, szTitle, phEXE, dwFlags,pvReserved));

    DELAYRSCAPI( NeedReboot,
    (DWORD dwRebootCheck),
    (dwRebootCheck));

    DELAYRSCAPI( NeedRebootInit, (), ());

    DELAYRSCAPI( TranslateInfString,
    (PCSTR  pszInfFilename,
    PCSTR  pszInstallSection,
    PCSTR  pszTranslateSection,
    PCSTR  pszTranslateKey,
    PSTR   pszBuffer,
    DWORD  dwBufferSize,
    PDWORD pdwRequiredSize,
    PVOID  pvReserved),
    (pszInfFilename, pszInstallSection, pszTranslateSection, pszTranslateKey,
    pszBuffer, dwBufferSize, pdwRequiredSize, pvReserved));


    DELAYRSCAPI( AdvInstallFile,
    (HWND hwnd,
    LPCSTR lpszSourceDir,
    LPCSTR lpszSourceFile,
    LPCSTR lpszDestDir,
    LPCSTR lpszDestFile,
    DWORD dwFlags,
    DWORD dwReserved),
    (hwnd, lpszSourceDir, lpszSourceFile, lpszDestDir, lpszDestFile, dwFlags,
    dwReserved));

};

inline
CRunSetupHook::CRunSetupHook()
{
    m_fInited = FALSE;
    m_hMod = NULL;
#ifdef WX86
    m_hModX86 = m_hModWx86 = NULL;
#endif
}

inline
CRunSetupHook::~CRunSetupHook()
{
    if (m_fInited) {
        if (m_hMod) {
            FreeLibrary(m_hMod);
        }
#ifdef WX86
        if (m_hModX86) {
            if (pfnUnload) {
                (*pfnUnload)(m_hModX86);    // free x86 advpack.dll
            }
        }
        
        if (m_hModWx86) {
            FreeLibrary(m_hModWx86);    // free wx86.dll
        }
#endif
    }
}

inline
HRESULT 
CRunSetupHook::Init(void)
{
    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary( "ADVPACK.DLL" );

    if (!m_hMod) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) return E_UNEXPECTED;

    CHECKAPI(RunSetupCommand);
    CHECKAPI(NeedReboot);
    CHECKAPI(NeedRebootInit);

    CHECKAPI(TranslateInfString);
    CHECKAPI(AdvInstallFile);

    m_fInited = TRUE;
    return S_OK;
}

#ifdef WX86
inline
HRESULT 
CRunSetupHook::InitX86(void)
{
    typedef HMODULE (*pfnLoadFn)(LPCWSTR name, DWORD dwFlags);
    typedef PVOID (*pfnThunkFn)(PVOID pvAddress, PVOID pvCbDispatch, BOOLEAN fNativeToX86);
    pfnLoadFn pfnLoad;
    pfnThunkFn pfnThunk;

    if (m_fInitedX86) {
        return S_OK;
    }

    // No need to check the reg key to see if Wx86 is installed and enabled.
    // By the time this routine runs, that has already been done.
    m_hModWx86 = LoadLibrary("wx86.dll");
    if (!m_hModWx86) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    pfnLoad = (pfnLoadFn)GetProcAddress(m_hModWx86, "Wx86LoadX86Dll");
    pfnUnload = (pfnUnloadFn)GetProcAddress(m_hModWx86, "Wx86FreeX86Dll");
    pfnThunk = (pfnThunkFn)GetProcAddress(m_hModWx86, "Wx86ThunkProc");
    if (!pfnLoad || !pfnThunk || !pfnUnload) {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        FreeLibrary(m_hModWx86);
        return hr;
    }

    // Load x86 advpack.dll
    m_hModX86 = (*pfnLoad)( L"ADVPACK.DLL", 0 );

    if (!m_hModX86) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#undef CHECKAPI
#define CHECKAPI(_fn, n) \
    *(FARPROC*)&(_pfn##_fn##X86) = GetProcAddress(m_hModX86, #_fn); \
    if (!(_pfn##_fn##X86)) return E_UNEXPECTED;                  \
    *(FARPROC*)&(_pfn##_fn##X86) = (FARPROC)(*pfnThunk)(_pfn##_fn##X86, (PVOID)n, TRUE);

    CHECKAPI(RunSetupCommand, 8);
    CHECKAPI(NeedReboot, 1);
    CHECKAPI(NeedRebootInit, 0);

    CHECKAPI(TranslateInfString, 8);
    CHECKAPI(AdvInstallFile, 7);

    m_fInitedX86 = TRUE;
    return S_OK;
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\cdl.cxx ===
// ===========================================================================
// File: CDL.CXX
//    The main code downloader file.
//

#include <cdlpch.h>
#include <stdio.h>
#include <shlwapi.h>
#include <regstr.h>
#include <initguid.h>
#include <pkgguid.h>
#include <winineti.h>
#include <shlwapip.h>
#include "advpub.h"
#include "advpkp.h"
#include "shlobj.h"
#include "helpers.hxx"

typedef HRESULT (WINAPI *REMOVECONTROLBYNAME)(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove /*= FALSE*/,
             DWORD dwIsDistUnit /*= FALSE*/
             );

typedef BOOL (*pfnSfcIsFileProtected)(HANDLE RpcHandle,LPCWSTR ProtFileName);


extern LCID g_lcidBrowser;     // default to english

extern char g_szOCXCacheDir[];
extern char g_szPlatform[]; // platform specific string for location of file
extern HINSTANCE g_hInst;

const static char *sz_USE_CODE_URL = "CODEBASE";
const static char szCLSID[] = "CLSID";
const static char szVersion[] = "Version";

const static char *szTHISCAB = "thiscab";
const static char *szIGNORE = "ignore";

extern LPCSTR szWinNT;
extern LPCSTR szWin95;

extern LPCSTR szPlatform;

extern char *g_szProcessorTypes[];

extern CRunSetupHook g_RunSetupHook;

extern int g_CPUType;
extern BOOL g_bRunOnWin95;

#define RANDNUM_MAX 0x7fff

#define MAX_ATOM_SIZE 255

LONG InitializeRandomSeed()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "InitializeRandomSeed",
                NULL
                ));
                
    SYSTEMTIME  st;
    GetSystemTime(&st);

    DEBUG_LEAVE((LONG)st.wMilliseconds);
    return (LONG)st.wMilliseconds;
}

//+-------------------------------------------------------------------------
//
//  Function:   randnum
//
//  Synopsys:   Generate random number based on seed. (copied from crt)
//
//+-------------------------------------------------------------------------
int randnum (void)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Int,
                "randnum",
                NULL
                ));
                
    static long holdrand = InitializeRandomSeed();
    holdrand = ((holdrand * 214013L + 2531011L) >> 16) & RANDNUM_MAX;
    
    DEBUG_LEAVE(holdrand);
    return(holdrand);
}

// Disabled by adding a DWORD value "DisableImprovedZoneCheck" with non=zero value under SETTINGS key
BOOL CanUseImprovedZoneCheck()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CanUseImprovedZoneCheck",
                NULL
                ));
                
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fRet = TRUE;
    HKEY  hKeyClient;
    DWORD dwDisable = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;

    dwErr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_IE_SETTINGS,
                0,
                KEY_QUERY_VALUE,
                &hKeyClient
            );

    if( dwErr == ERROR_SUCCESS )
    {
        dwErr = RegQueryValueEx(
                hKeyClient,
                "DisableImprovedZoneCheck",
                0,
                &dwType,
                (LPBYTE)&dwDisable,
                &dwSize
        );

        if((dwErr == ERROR_SUCCESS) && dwDisable)
        {
            fRet = FALSE;
        }
        RegCloseKey(hKeyClient);
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


BOOL CCodeDownload::FileProtectionCheckSucceeded(LPCSTR pszExistingFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CCodeDownload::FileProtectionCheckSucceeded",
                "this=%#x, %.200q",
                this, (pszExistingFileName ? pszExistingFileName : "NULL")
                ));
                
    BOOL bRetval = FALSE;

    if (IsFileProtected(pszExistingFileName)) 
    {
        LPSTR pszCatalogFile = GetCatalogFile();
        LPSTR pszAtomStr;

        if (IsCatalogInstalled())
        {
            bRetval = TRUE;
            goto Exit;
        }
        
        if (pszCatalogFile && pszCatalogFile[0])
        {
            int cbLen = lstrlen(pszCatalogFile);
            if (cbLen >= MAX_ATOM_SIZE)
            {
                pszAtomStr = pszCatalogFile+cbLen+1-MAX_ATOM_SIZE;
            }
            else
            {
                pszAtomStr = pszCatalogFile;
            }

            ATOM atom = FindAtom(pszAtomStr);
            
            if (!atom)
            {
                DEBUG_PRINT(DOWNLOAD, 
                            INFO,
                            ("No atom %d for catalog file atom-str: %.200q\n",
                            atom, pszAtomStr
                            ));
                            
                HRESULT hr = m_wvt.InstallCatalogFile(pszCatalogFile);

                if (SUCCEEDED(hr))
                {
                    SetCatalogInstalled();
                    atom = AddAtom(pszAtomStr);
                    SetAtom(atom);
                    bRetval = TRUE;
                }
            }
            else
            {
                DEBUG_PRINT(DOWNLOAD, 
                            INFO,
                            ("Found atom! %d for catalog file atom-str: %.200q\n",
                            atom, pszAtomStr
                            ));
                            
                SetCatalogInstalled();
                bRetval = TRUE;
            }
        }
    }
    else
    {
        bRetval = TRUE;
    }

Exit:
    DEBUG_LEAVE(bRetval);
    return bRetval;
}

HRESULT ExtractFromCabinet(PSESSION ps, LPCSTR lpCabFileName)
{
    LPSTR lpFileName = NULL;

    if (ps && ps->pFilesToExtract)
        lpFileName = ps->pFilesToExtract->pszFilename;
        
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "ExtractFromCabinet",
                "%#x, %.80q, %.80q",
                ps, lpCabFileName, (lpFileName ? lpFileName : "NULL")
                ));

#ifdef DBG
    PFNAME pfName = ps->pFilesToExtract;

    while(pfName)
    {
        lpFileName = pfName->pszFilename;
        
        DEBUG_PRINT(DOWNLOAD, 
                    INFO,
                    ("ExtractFromCabinet filename: %.80q \n",
                    (lpFileName ? lpFileName : "NULL")
                    ));

        pfName = pfName->pNextName;
    }
#endif

    HRESULT hr = ::Extract(ps, lpCabFileName);

#ifdef DBG
    if (ps->flags & SESSION_FLAG_EXTRACT_ALL)
    {
        pfName = ps->pFileList;

        while(pfName)
        {
            lpFileName = pfName->pszFilename;
            
            DEBUG_PRINT(DOWNLOAD, 
                        INFO,
                        ("ExtractFromCabinet ALL: filename: %.80q \n",
                        (lpFileName ? lpFileName : "NULL")
                        ));

            pfName = pfName->pNextName;  
        }
    }
#endif

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::CCodeDownload
//  CCodeDownload (main class tracking as a whole)
//  It has the client's BSC and creates a CClBinding for client.
// ---------------------------------------------------------------------------
CCodeDownload::CCodeDownload(
    LPCWSTR szDistUnit,
    LPCWSTR szURL,
    LPCWSTR szType,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    HRESULT *phr)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::CCodeDownload",
                "this=%#x, %.80wq, %.80wq, %.80wq, %.80wq, %#x, %#x, %#x",
                this, szDistUnit, szURL, szType, szExt, dwFileVersionMS, dwFileVersionLS, phr
                ));
                
    DllAddRef();
    m_szLastMod[0] = '\0';
    m_plci = NULL;

    m_cRef = 1;

    m_hr = S_OK;    // assume success

    m_url = 0;

    m_szDistUnit = NULL;

    m_pmkContext = NULL;

    m_dwFileVersionMS = dwFileVersionMS;
    m_dwFileVersionLS = dwFileVersionLS;

    m_lcid = GetThreadLocale();

    DEBUG_PRINT(DOWNLOAD, 
                INFO,
                ("CCodeDownload::CCodeDownload::this=%#x, m_lcid: %d (%#x)\n",
                this, m_lcid, m_lcid
                ));
                
    m_flags = CD_FLAGS_INIT;

    m_szInf = NULL;
    m_szOSD = NULL;
    m_szDisplayName = NULL;

    m_szCacheDir = NULL; // set to default of g_szOCXCacheDir by DoSetup
                         // the non-zeroness of this is also used by DoSetup
                         // to find it it's state machine has been init'ed

    m_szWaitForEXE = NULL;

    m_state = CDL_NoOperation;

    m_hKeySearchPath = NULL;
    m_pSearchPath = NULL;
    m_pSearchPathNextComp = NULL;

    m_pDownloads.RemoveAll(); // init to NULL

    m_pClientbinding.RemoveAll(); // init to NULL

    m_ModuleUsage.RemoveAll(); // init to NULL

    m_pDependencies.RemoveAll(); // init to NULL

    m_dwSystemComponent = FALSE;

    m_pCurCode = m_pAddCodeSection = NULL;

    if (szURL) {

        DWORD len = lstrlenW(szURL) +1;

        if (len <= INTERNET_MAX_URL_LENGTH) {

            m_url = new WCHAR [len]; // make private copy

            if (m_url)
                StrCpyW(m_url, szURL);
            else
                *phr = E_OUTOFMEMORY;
        } else {
            // we make assumptions all over that URL size is less than
            // INTERNET_MAX_URL_LENGTH
            *phr = E_INVALIDARG;
        }
    }

    if (szDistUnit) {

        DWORD len = lstrlenW(szDistUnit) +1;

        m_szDistUnit = new WCHAR [len]; // make private copy

        if (m_szDistUnit)
            StrCpyW(m_szDistUnit, szDistUnit);
        else
            *phr = E_OUTOFMEMORY;
    }

    m_pi.hProcess = INVALID_HANDLE_VALUE;
    m_pi.hThread = INVALID_HANDLE_VALUE;

    if (szExt) {

        DWORD len = lstrlenW(szExt) +1;

        m_szExt = new WCHAR [len]; // make private copy

        if (m_szExt)
            StrCpyW(m_szExt, szExt);
        else
            *phr = E_OUTOFMEMORY;
    }

    if (szType) {

        DWORD len = lstrlenW(szType) +1;

        m_szType = new WCHAR [len]; // make private copy

        if (m_szType)
            StrCpyW(m_szType, szType);
        else
            *phr = E_OUTOFMEMORY;
    }

    m_szVersionInManifest = NULL;
    m_szCatalogFile = NULL;
    
    m_dwExpire = 0xFFFFFFFF;

    m_pbEtag = NULL;
    m_pbJavaTrust = NULL;
    m_debuglog = CDLDebugLog::MakeDebugLog();
    if(! m_debuglog)
        *phr = E_OUTOFMEMORY;
    else
        m_debuglog->Init(this);
    m_bUninstallOld = FALSE;
    m_bExactVersion = FALSE;
    m_hModSFC = 0;

    m_bCatalogInstalled = FALSE;
    m_atom = NULL;
    
    DEBUG_LEAVE(0);
}  // CCodeDownload

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::~CCodeDownload
// ---------------------------------------------------------------------------
CCodeDownload::~CCodeDownload()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::~CCodeDownload",
                "this=%#x",
                this
                ));
                
    Assert(m_cRef == 0);
    if (RelContextMk())
        SAFERELEASE(m_pmkContext);


    LISTPOSITION pos = m_pClientbinding.GetHeadPosition();
    int iNum = m_pClientbinding.GetCount();

    for (int i=0; i < iNum; i++) {
        CClBinding *pbinding = m_pClientbinding.GetNext(pos); // pass ref!
        pbinding->ReleaseClient();
        pbinding->Release();
    }
    m_pClientbinding.RemoveAll();

    pos = m_ModuleUsage.GetHeadPosition();
    iNum = m_ModuleUsage.GetCount();

    for (i=0; i < iNum; i++) {
        CModuleUsage *pModuleUsage = m_ModuleUsage.GetNext(pos); // pass ref!
        delete pModuleUsage;
    }
    m_ModuleUsage.RemoveAll(); // init to NULL

    m_pDownloads.RemoveAll(); // init to NULL

    pos = m_pDependencies.GetHeadPosition();
    iNum = m_pDependencies.GetCount();

    for (i=0; i < iNum; i++) {
        LPWSTR szDistUnit = m_pDependencies.GetNext(pos);
        delete szDistUnit;
    }

    if (m_szCacheDir != g_szOCXCacheDir)
        SAFEDELETE(m_szCacheDir);

    if (m_hKeySearchPath)
        ::RegCloseKey(m_hKeySearchPath);

    SAFEDELETE(m_szDistUnit);

    SAFEDELETE(m_url);
    SAFEDELETE(m_szType);
    SAFEDELETE(m_szExt);

    SAFEDELETE(m_szVersionInManifest);
    SAFEDELETE(m_szWaitForEXE);

    SAFEDELETE(m_pSearchPath);
    SAFEDELETE(m_szOSD);
    SAFEDELETE(m_szInf);
    SAFEDELETE(m_szDisplayName);
    SAFEDELETE(m_pAddCodeSection);
    SAFEDELETE(m_plci);
    SAFEDELETE(m_pbEtag);

    SAFERELEASE(m_pPackageManager);
    SAFEDELETE(m_szCatalogFile);
    DllRelease();

    if (m_pbJavaTrust) {
        if (m_pbJavaTrust->pwszZone) {
            delete (LPWSTR)m_pbJavaTrust->pwszZone;
        }
        SAFEDELETE(m_pbJavaTrust->pbSigner);
        SAFEDELETE(m_pbJavaTrust->pbJavaPermissions);
        delete m_pbJavaTrust;
    }

    if(m_debuglog)
    {
        m_debuglog->Release();
        m_debuglog = NULL;
    }

    if (m_hModSFC) {
        FreeLibrary(m_hModSFC);
    }

    if(m_atom)
        DeleteAtom(m_atom);
        
    DEBUG_LEAVE(0);
}  // ~CCodeDownload

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetDebugLog()
// Remove the old log and set a new one
// If debuglog is NULL, starts a new log
// ---------------------------------------------------------------------------

void CCodeDownload::SetDebugLog(CDLDebugLog * debuglog)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::SetDebugLog",
                "this=%#x, %#x",
                this, debuglog
                ));
                
    CDLDebugLog * pdlNew = NULL;

    if(debuglog)
        pdlNew = debuglog;
    else
    {
        pdlNew = CDLDebugLog::MakeDebugLog();
        if(!pdlNew)
        {

            DEBUG_LEAVE(0);
            // Out of Memory
            return;
        }
        pdlNew->Init(this);
    }

    if(pdlNew)
    {
        m_debuglog->Release();
        pdlNew->AddRef();
        m_debuglog = pdlNew;
    }
    
    DEBUG_LEAVE(0);
}


HRESULT
CCodeDownload::CreateClientBinding(
    CClBinding **ppClientBinding,
    IBindCtx* pClientBC,
    IBindStatusCallback* pClientbsc,
    REFCLSID rclsid,
    DWORD dwClsContext,
    LPVOID pvReserved,
    REFIID riid,
    BOOL fAddHead,
    IInternetHostSecurityManager *pHostSecurityManager)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::CreateClientBinding",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %B, %#x",
                this, ppClientBinding, pClientBC, pClientbsc, &rclsid, dwClsContext, pvReserved, &riid, fAddHead, pHostSecurityManager
                ));
                
    HRESULT hr = S_OK;

    Assert(ppClientBinding);
    *ppClientBinding = NULL;

    // make an IBinding for the client
    // this gets passed on the OnstartBinding of first download
    // as parameter for clientbsc::OnstartBinding

    CClBinding *pClientbinding= new
        CClBinding(this, pClientbsc, pClientBC,
            rclsid, dwClsContext, pvReserved, riid, pHostSecurityManager);

    if (pClientbinding) {

        if (fAddHead) {
            m_pClientbinding.AddHead(pClientbinding);
        } else {
            m_pClientbinding.AddTail(pClientbinding);
        }

    } else {
        hr =  E_OUTOFMEMORY;
    }

    *ppClientBinding = pClientbinding;

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CCodeDownload::AbortBinding( CClBinding *pbinding)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::AbortBinding",
                "this=%#x, %#x",
                this, pbinding
                ));
                
    IBindStatusCallback* pbsc;
    int iNumBindings = m_pClientbinding.GetCount();
    ICodeInstall *pCodeInstall;
    HRESULT hr = S_OK;
    LISTPOSITION curpos;

    Assert(iNumBindings > 1);

    if (GetState() == CDL_Completed) {
        goto Exit;
    }

    curpos = m_pClientbinding.Find(pbinding);

    Assert(pbinding == m_pClientbinding.GetAt(curpos));

    if (pbinding != m_pClientbinding.GetAt(curpos)) {
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION);
        goto Exit;
    }

    // now that we know the position of the binding,
    // pull out the binding and its related BSC from the list

    m_pClientbinding.RemoveAt(curpos);

    pbsc = pbinding->GetAssBSC();

    // report completion for this binding
    // note: if we are called to abort on a thread other than the one that
    // initiated the code download, then we report this onstopbinding on the
    // aborting thread (this one).
    pbsc->OnStopBinding(HRESULT_FROM_WIN32(ERROR_CANCELLED), NULL);

    // since we removed this binding from the list
    // we have to release this now. This will release the client BSC, BC
    pbinding->ReleaseClient();
    pbinding->Release();

Exit:
    DEBUG_LEAVE(hr);
    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::PiggybackDupRequest
// piggy backs DUP request on to this exitsing CCodeDownload
// with matching szURL or rclsid
//  Returns:
//          S_OK: piggyback successful
//          Any other error: fatal error: fail
HRESULT
CCodeDownload::PiggybackDupRequest(
    IBindStatusCallback *pDupClientBSC,
    IBindCtx *pbc,
    REFCLSID rclsid,
    DWORD dwClsContext,
    LPVOID pvReserved,
    REFIID riid)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::PiggybackDupRequest",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pDupClientBSC, pbc, &rclsid, dwClsContext, pvReserved, &riid
                ));
                
    HRESULT hr = S_OK;
    CClBinding *pClientBinding = NULL;

    Assert(m_pClientbinding.GetCount() > 0);
    if (m_pClientbinding.GetCount() <= 0) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = CreateClientBinding( &pClientBinding, pbc, pDupClientBSC,
        rclsid, dwClsContext, pvReserved, riid,
        FALSE /* fAddHead */, NULL);

    if (SUCCEEDED(hr)) {

        Assert(pClientBinding);

        pClientBinding->SetState(CDL_Downloading);
        pDupClientBSC->OnStartBinding(0, pClientBinding);
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::AnyCodeDownloadsInThread
// checks if any code downloads are in progress in this thread
//  Returns:
//          S_OK: yes, downloads in progress
//          S_FALSE: none in progress
//          Any other error: fatal error: fail
HRESULT
CCodeDownload::AnyCodeDownloadsInThread()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::AnyCodeDownloadsInThread",
                NULL
                ));
                
    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
    {
        DEBUG_LEAVE(hr);
        return hr;
    }
    
    int iNumCDL = tls->pCodeDownloadList->GetCount();

    if (!iNumCDL)
        hr = S_FALSE;

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::IsDuplicateJavaSetup
//  Returns:
//          S_OK: Yes its a DUP
HRESULT
CCodeDownload::IsDuplicateJavaSetup(
    LPCWSTR szPackage)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::IsDuplicateJavaSetup",
                "this=%#x, %.80wq",
                this, szPackage
                ));
                
    HRESULT hr = S_FALSE;       // assume not found
    CDownload *pdlCur = NULL;

    LISTPOSITION curpos = m_pDownloads.GetHeadPosition();
    for (int i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        if (pdlCur->FindJavaSetup(szPackage) != NULL) {
            hr = S_OK;
            break;
        }

    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::IsDuplicateHook
//  Returns:
//          S_OK: Yes its a DUP
HRESULT
CCodeDownload::IsDuplicateHook(
    LPCSTR szHook)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::IsDuplicateHook",
                "this=%#x, %.80q",
                this, szHook
                ));
                
    HRESULT hr = S_FALSE;       // assume not found
    CDownload *pdlCur = NULL;

    LISTPOSITION curpos = m_pDownloads.GetHeadPosition();
    for (int i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        if (pdlCur->FindHook(szHook) != NULL) {
            hr = S_OK;
            break;
        }

    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
SetComponentDeclined(
    LPCWSTR pwszDistUnit,
    LPSTR pszSecId)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "SetComponentDeclined",
                "%.80wq, %.80q",
                pwszDistUnit, pszSecId
                ));
                
    HRESULT hr = S_FALSE;   // assume need to fault in
    LPSTR pszDistUnit = NULL;
    LONG    lResult = ERROR_SUCCESS;
    HKEY    hkeyDec    = NULL;
    DWORD   dwSize;
    DWORD   dwValue;
    LPSTR szNull = "";
    char szKey[MAX_PATH*2];

    if (FAILED((hr=::Unicode2Ansi(pwszDistUnit, &pszDistUnit))))
    {
        goto Exit;
    }

    lstrcpyn(szKey, REGKEY_DECLINED_COMPONENTS, MAX_PATH*2);

#ifndef ENABLE_PERSIST_DECLINED_COMPONNETS
    if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_WRITE, &hkeyDec) != ERROR_SUCCESS) {
        hr = S_OK;
        goto Exit;
    } else {
        if (hkeyDec) {
            RegCloseKey(hkeyDec);
            hkeyDec = 0;
        }
    }
#endif

    StrCatBuff(szKey, "\\", MAX_PATH*2);
    StrCatBuff(szKey, pszDistUnit, MAX_PATH*2);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, 0, KEY_WRITE, &hkeyDec) != ERROR_SUCCESS)
    {
        if ((lResult = RegCreateKey( HKEY_CURRENT_USER,
                   szKey, &hkeyDec)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }

    if (((lResult = RegSetValueEx (hkeyDec, pszSecId, 0, REG_SZ,
            (unsigned char *)szNull, 1))) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
    }


Exit:

    if (hkeyDec)
        RegCloseKey(hkeyDec);

    SAFEDELETE(pszDistUnit);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetUserDeclined
HRESULT
CCodeDownload::SetUserDeclined()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetUserDeclined",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    LISTPOSITION pos = m_pClientbinding.GetHeadPosition();
    int iNum = m_pClientbinding.GetCount();
    int i;
    BYTE pbSecIdDocBase[INTERNET_MAX_URL_LENGTH];
    DWORD dwSecIdDocBase = INTERNET_MAX_URL_LENGTH;
    IInternetHostSecurityManager *pHostSecurityManager = GetClientBinding()->GetHostSecurityManager();


    if (!pHostSecurityManager) {
        // called by a host without sec mgr, don't record that you have
        // declined this component
        goto Exit;
    }

    hr = pHostSecurityManager->GetSecurityId(pbSecIdDocBase, &dwSecIdDocBase, 0);

    Assert(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    if (FAILED(hr))
        goto Exit;

    // Hack!
    // Assumes internal knowledge of security id
    // the security has the zone id as the last dword, the rest of the stuff is
    // just the protocol followed by the site
    if (dwSecIdDocBase - sizeof(DWORD)) {
        pbSecIdDocBase[dwSecIdDocBase - sizeof(DWORD)] = '\0';
    }

    if (GetMainDistUnit()) {
        hr = SetComponentDeclined(GetMainDistUnit(), (char *)pbSecIdDocBase);

        if (FAILED(hr))
            goto Exit;
    }

    if (GetMainType()) {
        hr = SetComponentDeclined(GetMainType(), (char *)pbSecIdDocBase);

        if (FAILED(hr))
            goto Exit;
    }

    if (GetMainExt()) {
        hr = SetComponentDeclined(GetMainExt(), (char *)pbSecIdDocBase);

        if (FAILED(hr))
            goto Exit;
    }

    for (i=0; i < iNum; i++) {

        CClBinding *pbinding = m_pClientbinding.GetNext(pos); // pass ref!
        LPOLESTR pwszClsid;

        pwszClsid = NULL;

        if (!IsEqualGUID(pbinding->GetClsid() , CLSID_NULL)) {

            hr=StringFromCLSID(pbinding->GetClsid(), &pwszClsid);

            if (FAILED(hr))
                goto Exit;

            hr = SetComponentDeclined(pwszClsid, (char *)pbSecIdDocBase);
            SAFEDELETE(pwszClsid);

            if (FAILED(hr))
                goto Exit;
        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL IsDeclined(
    LPCWSTR pwszDistUnit,
    IInternetHostSecurityManager *pHostSecurityManager)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "IsDeclined",
                "%.80wq, %#x",
                pwszDistUnit, pHostSecurityManager
                ));
                
    BOOL bDeclined = FALSE;
    LPSTR pszDistUnit = NULL;
    BYTE pbSecIdDocBase[INTERNET_MAX_URL_LENGTH];
    DWORD dwSecIdDocBase = INTERNET_MAX_URL_LENGTH;
    HRESULT hr = S_OK;
    char szKey[MAX_PATH*2];


    Assert(pHostSecurityManager);

    hr = pHostSecurityManager->GetSecurityId(pbSecIdDocBase, &dwSecIdDocBase, 0);

    Assert(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    if (FAILED(hr))
        goto Exit;

    // Hack!
    // Assumes internal knowledge of security id
    // the security has the zone id as the last dword, the rest of the stuff is
    // just the protocol followed by the site
    if (dwSecIdDocBase - sizeof(DWORD)) {
        pbSecIdDocBase[dwSecIdDocBase - sizeof(DWORD)] = '\0';
    }

    lstrcpyn(szKey, REGKEY_DECLINED_COMPONENTS, MAX_PATH*2);

    if (SUCCEEDED(::Unicode2Ansi(pwszDistUnit, &pszDistUnit)))
    {
        StrCatBuff(szKey, "\\", MAX_PATH*2);
        StrCatBuff(szKey, pszDistUnit, MAX_PATH*2);

        SAFEDELETE(pszDistUnit);

        if (SHRegGetUSValue( szKey, (char *)pbSecIdDocBase, NULL, NULL, NULL, 0,NULL,0) == ERROR_SUCCESS)
        {
            bDeclined = TRUE;
        }
    }

Exit:

    DEBUG_LEAVE(bDeclined);
    return bDeclined;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::HasUserDeclined
HRESULT
CCodeDownload::HasUserDeclined(
    LPCWSTR szDistUnit,
    LPCWSTR szType,
    LPCWSTR szExt,
    IBindStatusCallback *pClientBSC,
    IInternetHostSecurityManager *pHostSecurityManager)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::HasUserDeclined",
                "%.80wq, %.80wq, %.80wq, %#x, %#x",
                szDistUnit, szType, szExt, pClientBSC, pHostSecurityManager
                ));

    HRESULT hr = S_OK;
    DWORD grfBINDF = 0;
    BINDINFO bindInfo;
    memset(&bindInfo, 0, sizeof(BINDINFO));
    bindInfo.cbSize = sizeof(BINDINFO);

    if (pHostSecurityManager) {

        pClientBSC->GetBindInfo(&grfBINDF, &bindInfo);

        ReleaseBindInfo(&bindInfo);

        if (!(grfBINDF & BINDF_RESYNCHRONIZE)) {    // User has hit refresh

            if ((szDistUnit && IsDeclined(szDistUnit,pHostSecurityManager)) ||
                (szType && IsDeclined(szType,pHostSecurityManager)) ||
                (szExt && IsDeclined(szExt,pHostSecurityManager))) {

                hr = INET_E_CODE_DOWNLOAD_DECLINED;

            }
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::HandleDuplicateCodeDownloads
// handles duplicates by piggy backing them on to exitsing CCodeDownloads
// with matching szURL or rclsid
//  Returns:
//          S_OK: no dups found, do separate code download
//          MK_S_ASYNCHRONOUS: dup piggybacked
//          Any other error: fatal error: fail
HRESULT
CCodeDownload::HandleDuplicateCodeDownloads(
    LPCWSTR szURL,
    LPCWSTR szType,
    LPCWSTR szExt,
    REFCLSID rclsid,
    LPCWSTR szDistUnit,
    DWORD dwClsContext,
    LPVOID pvReserved,
    REFIID riid,
    IBindCtx* pbc,
    IBindStatusCallback *pDupClientBSC,
    DWORD dwFlags,
    IInternetHostSecurityManager *pHostSecurityManager)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::HandleDuplicateCodeDownloads",
                "%.80wq, %.80wq, %.80wq, %#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
                szURL, szType, szExt, &rclsid, szDistUnit, dwClsContext,
                pvReserved, &riid, pbc, pDupClientBSC, dwFlags, pHostSecurityManager
                ));
                
    HRESULT hr = S_OK;
    LISTPOSITION curpos;
    CCodeDownload *pcdl;
    int iNumCDL;
    int i;

    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr))
        goto Exit;

    // first check to make sure that
    // this object has not been cancelled before by user
    // we will skip this check only when the user hits refresh on a page

    if (!(dwFlags & CD_FLAGS_SKIP_DECLINED_LIST_CHECK)) {
        hr = HasUserDeclined(szDistUnit, szType, szExt,pDupClientBSC,pHostSecurityManager);
        if (FAILED(hr))
            goto Exit;
    }

    iNumCDL = tls->pCodeDownloadList->GetCount();
    curpos = tls->pCodeDownloadList->GetHeadPosition();

    // walk thru all the code downloads in the thread and check for DUPs
    for (i=0; i < iNumCDL; i++) {

        pcdl = tls->pCodeDownloadList->GetNext(curpos);

        BOOL bNullClsid = IsEqualGUID(rclsid , CLSID_NULL);

        if (bNullClsid) {

            // handle dups based on TYPE and Ext
            if (! ( ( szDistUnit && pcdl->GetMainDistUnit() &&
                    (StrCmpIW(szDistUnit, pcdl->GetMainDistUnit()) == 0)) ||
                    ( szType && pcdl->GetMainType() &&
                    (StrCmpIW(szType, pcdl->GetMainType()) == 0)) ||
                    ( szExt && pcdl->GetMainExt() &&
                    (StrCmpIW(szExt, pcdl->GetMainExt()) == 0))
                   ) ) {

                // no match by type or ext

                continue;
            }

            // found match, fall thru to piggyback

        } else if (IsEqualGUID(rclsid , pcdl->GetClsid())) {

            if (szURL) {

                if(StrCmpIW(szURL, pcdl->GetMainURL()) != 0) {
                    pcdl->m_debuglog->DebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_OBJ_TAG_MIXED_USAGE,
                                  (pcdl->GetClsid()).Data1,szURL, pcdl->GetMainURL());

                }

            } else {

                if(pcdl->GetMainURL() != NULL) {

                    pcdl->m_debuglog->DebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_OBJ_TAG_MIXED_USAGE,
                    (pcdl->GetClsid()).Data1, pcdl->GetMainURL(), NULL);

                }
            }

            // found matching GUID, fall thru to piggyback

        } else if (szURL && (pcdl->GetMainURL() != NULL)) {

                if (StrCmpIW(szURL, pcdl->GetMainURL()) != 0) {
                    continue;
                }

                // found matching CODEBASE, fall thru to piggyback

        } else {
            continue;
        }

        // found DUP!
        if (pcdl->GetState() != CDL_Completed) {
            hr = pcdl->PiggybackDupRequest(pDupClientBSC, pbc,
                rclsid, dwClsContext, pvReserved, riid);

            if (hr == S_OK) {
                // piggy back was successful
                hr = MK_S_ASYNCHRONOUS;
            }
        }


        break;

    } /* for */

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetWaitingForEXE
//  set that we are waiting for an EXE
//  either a self-registering localserver32 or a setup program
HRESULT
CCodeDownload::SetWaitingForEXE(
    LPCSTR szEXE,
    BOOL bDeleteEXEWhenDone)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetWaitingForEXE",
                "this=%#x, %.80q, %B",
                this, szEXE, bDeleteEXEWhenDone
                ));
                
    m_flags |= CD_FLAGS_WAITING_FOR_EXE;

    SAFEDELETE(m_szWaitForEXE);

    int len = 0;

    if (szEXE)
        len = lstrlen(szEXE);

    if (len) {
        m_szWaitForEXE = new CHAR [len + 1];
    } else {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (!m_szWaitForEXE) {
        DEBUG_LEAVE(E_OUTOFMEMORY);
        return  E_OUTOFMEMORY;
    }

    lstrcpy(m_szWaitForEXE, szEXE);

    if (bDeleteEXEWhenDone)
        SetDeleteEXEWhenDone();

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

typedef HRESULT (STDAPICALLTYPE *LPFNREGSVR)();

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::RegisterPEDll
//              Self-register's the PE OCX.
HRESULT
CCodeDownload::RegisterPEDll(
    LPCSTR lpSrcFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::RegisterPEDll",
                "this=%#x, %.80q",
                this, lpSrcFileName
                ));
                
    HMODULE hMod;
    LPFNREGSVR lpRegSvrFn;
    HRESULT hr = S_OK;
    IActiveXSafetyProvider *pProvider;

    if ((hr = IsRegisterableDLL(lpSrcFileName)) != S_OK) {

        // no DllRegisterServer entry point, don't LoadLibarary it.
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_MISSING_DLLREGISTERSERVER, lpSrcFileName);
        goto Exit;
    }

    m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_DLL_REGISTERED, lpSrcFileName);

    // assuming oleinitialze
    hr = GetActiveXSafetyProvider(&pProvider);
    if (hr != S_OK) {
        goto Exit;
    }

    if (pProvider) {

        hr = pProvider->SafeDllRegisterServerA(lpSrcFileName);
        pProvider->Release();

    } else {
        if ((hMod = LoadLibraryEx(lpSrcFileName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH)) == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        lpRegSvrFn = (LPFNREGSVR) GetProcAddress(hMod, "DllRegisterServer");
        if (lpRegSvrFn == NULL) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if (lpRegSvrFn)
            hr = (*lpRegSvrFn)();

        FreeLibrary(hMod);
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}


#ifdef WX86
// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::RegisterWx86Dll
//              Self-register's the PE OCX.
HRESULT
CCodeDownload::RegisterWx86Dll(
    LPCSTR lpSrcFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::RegisterWx86Dll",
                "this=%#x, %.80q",
                this, lpSrcFileName
                ));
                
    HMODULE hModWx86;
    HMODULE hMod;
    FARPROC lpfnDllRegisterServerX86;
    FARPROC lpfnDllRegisterServer;
    HRESULT hr = S_OK;
    LPWSTR  lpwSrcFileName;

    typedef HMODULE (*pfnLoadFn)(LPCWSTR name, DWORD dwFlags);
    typedef PVOID (*pfnThunkFn)(PVOID pvAddress, PVOID pvCbDispatch, BOOLEAN fNativeToX86);
    typedef BOOL (*pfnUnloadFn)(HMODULE hMod);
    pfnLoadFn pfnLoad;
    pfnThunkFn pfnThunk;
    pfnUnloadFn pfnUnload;

    if ((hr = IsRegisterableDLL(lpSrcFileName)) != S_OK) {

        // no DllRegisterServer entry point, don't LoadLibarary it.
        CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_MISSING_DLLREGISTERSERVER, lpSrcFileName);
        goto Exit;
    }

    // Load Wx86 and get pointers to some useful exports

    hModWx86 = LoadLibrary("wx86.dll");
    if (!hModWx86) {
        hr = HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH);
        CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_INCOMPATIBLE_BINARY, lpSrcFileName);
        goto Exit;
    }
    pfnLoad = (pfnLoadFn)GetProcAddress(hModWx86, "Wx86LoadX86Dll");
    pfnThunk = (pfnThunkFn)GetProcAddress(hModWx86, "Wx86ThunkProc");
    pfnUnload = (pfnUnloadFn)GetProcAddress(hModWx86, "Wx86FreeX86Dll");
    if (!pfnLoad || !pfnThunk || !pfnUnload) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit1;
    }

    CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_DLL_REGISTERED, lpSrcFileName);

    // assuming oleinitialze

    if (FAILED((hr=::Ansi2Unicode(lpSrcFileName, &lpwSrcFileName)))) {
        goto Exit1;
    }

    if ((hMod = (*pfnLoad)(lpwSrcFileName, LOAD_WITH_ALTERED_SEARCH_PATH)) == NULL) {


        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit1;
    }

    delete lpwSrcFileName;

    if ( (lpfnDllRegisterServerX86 = GetProcAddress( hMod,
                        "DllRegisterServer")) == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (lpfnDllRegisterServerX86) {
        //
        // lpfnDllRegisterServerX86 is a pointer to an x86 function which
        // takes no parameters.  Create a native-to-x86 thunk for it.
        //
        lpfnDllRegisterServer = (FARPROC)(*pfnThunk)(lpfnDllRegisterServerX86,
                                                     (PVOID)0,
                                                     TRUE
                                                    );
        if (lpfnDllRegisterServer == (FARPROC)-1) {
            //
            // Something went wrong.  Possibly out-of-memory.
            //
            hr = E_UNEXPECTED;
            goto Exit1;
        }

        hr = (*lpfnDllRegisterServer)();
    }

    (*pfnUnload)(hMod);

Exit1:
    FreeLibrary(hModWx86);

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}
#endif  //WX86


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::DelayRegisterOCX
//              Self-register's the OCX.
HRESULT
CCodeDownload::DelayRegisterOCX(
    LPCSTR pszSrcFileName,
    FILEXTN extn)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::DelayRegisterOCX",
                "this=%#x, %.80q, %#x",
                this, pszSrcFileName, extn
                ));
                
    HRESULT hr = S_OK;
    HKEY hKeyRunOnce = NULL;
    int line = 0;
    char szPath[MAX_PATH];
    char lpszCmdLine[2*MAX_PATH];
    char lpSrcFileName[MAX_PATH];
    char szTgtFileName[MAX_PATH];
    DWORD   dwTmp;
    const char *szICDRUNONCE = "ICDRegOCX%d";
    const char *szICDRUNDLL="rundll32.exe advpack.dll,RegisterOCX %s";



    // See comment in UpdateFileList to see why this is necessary
    // The reason we do this here is the same, except we need to use
    // the ANSI code page for regsvr32 this time.

    //pszSrcFileName restricted to MAX_PATH in context of use (See CSetup::DoSetup)
    
    if (g_bRunOnWin95) {
        OemToCharBuff(pszSrcFileName, lpSrcFileName, sizeof(lpSrcFileName) / sizeof(lpSrcFileName[0]));
        lstrcpy(szTgtFileName, lpSrcFileName);
    }
    else {
        lstrcpy(szTgtFileName, pszSrcFileName);
    }

    if ( RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, (ULONG)0, NULL,
           REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyRunOnce, &dwTmp ) != ERROR_SUCCESS ) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Check if key already exists -- if so, go with next number.
    //
    for (;;)
    {
        wsprintf( szPath, szICDRUNONCE, line++ );
        if ( RegQueryValueEx( hKeyRunOnce, szPath, 0, NULL, NULL, &dwTmp )
             != ERROR_SUCCESS )
        {
            break;
        }
    }

#ifdef WX86
    if (GetMultiArch()->GetRequiredArch() == PROCESSOR_ARCHITECTURE_INTEL) {
        char szSysDirX86[MAX_PATH];

        // An x86 control is downloading.  Tell GetSystemDirectory
        // to return the sys32x86 dir instead of system32
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = TRUE;
        GetSystemDirectory(szSysDirX86, MAX_PATH);

        // Run the RISC rundll32.exe but specify the fully-qualified name of
        // the x86 advpack.dll installed in %windir%\sys32x86.  RISC rundll32
        // is Wx86-aware and will load and run the x86 DLL.
        wnsprintf( lpszCmdLine, sizeof(lpszCmdLine)-1, "rundll32.exe %s\advpack.dll,RegisterOCX %s", szSysDirX86, szTgtFileName );

    } else {
        wnsprintf( lpszCmdLine, sizeof(lpszCmdLine)-1, szICDRUNDLL, szTgtFileName );
    }
#else
    wnsprintf( lpszCmdLine, sizeof(lpszCmdLine)-1, szICDRUNDLL, szTgtFileName );
#endif

    if ( RegSetValueEx( hKeyRunOnce, szPath, 0, REG_SZ, (CONST UCHAR *) lpszCmdLine, lstrlen(lpszCmdLine)+1 )
         != ERROR_SUCCESS ) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:

    if ( hKeyRunOnce != NULL ) {
        RegCloseKey( hKeyRunOnce );
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::InstallOCX
//              Self-register's the OCX.
HRESULT
CCodeDownload::InstallOCX(
    LPCSTR lpSrcFileName,
    FILEXTN extn,
    BOOL bLocalServer)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::InstallOCX",
                "this=%#x, %.80q, %#x, %B",
                this, lpSrcFileName, extn, bLocalServer
                ));
                
    HMODULE hMod;
    FARPROC lpfnDllRegisterServer;
    HRESULT hr = S_OK;
    const static char *szREGSVR = " /RegServer";
    char szCmdLine[MAX_PATH+sizeof(szREGSVR)];
    STARTUPINFO si;
    DWORD dwResult;
    DWORD dwMachineType = 0;

    switch (extn) {

    case FILEXTN_CAB:
    case FILEXTN_INF:

        // can't install cab or INF
        hr = E_INVALIDARG;
        break;

    case FILEXTN_EXE:

	//lpSrcFileName constrained to MAX_PATH in context of use (See CSetup::DoSetup)
	
        lstrcpy(szCmdLine, lpSrcFileName);
        if (bLocalServer)
            lstrcat(szCmdLine, szREGSVR);

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);

        if (!CreateProcess(NULL,
                szCmdLine,
                0,                  // security
                0,                  // security
                FALSE,              // Don't inherit my handles!
                0,                  // Creation flags
                NULL,               // env = inherit
                NULL,               // cur dir. = inherit
                &si,                // no startup info
                &m_pi))
            {

            hr = HRESULT_FROM_WIN32(GetLastError());

        } else {

            hr = SetWaitingForEXE(lpSrcFileName, !bLocalServer);
        }

        goto Exit;


    case FILEXTN_OCX:
    case FILEXTN_DLL:
    case FILEXTN_NONE:
    case FILEXTN_UNKNOWN:


        // sniff machine type of PE

        hr = IsCompatibleFile(lpSrcFileName, &dwMachineType);

        if (hr == HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH)) {

            // if its of worng CPU flavor fail and clean up the OCX
            m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_INCOMPATIBLE_BINARY, lpSrcFileName);
            break;
        }

        if (hr == S_FALSE) {
            // not a PE file, no need to call LoadLibrary
            // just copy and install the file

            break;
        }

#ifdef WX86
        if (g_fWx86Present && dwMachineType == IMAGE_FILE_MACHINE_I386)
            hr = RegisterWx86Dll(lpSrcFileName);
        else
#endif
            hr = RegisterPEDll(lpSrcFileName);

    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::HandleUnSafeAbort
HRESULT
CCodeDownload::HandleUnSafeAbort()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::HandleUnSafeAbort",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_FALSE;
    ICodeInstall* pCodeInstall = GetICodeInstall();

    if(WaitingForEXE()) { // Did the setup start a self-registering EXE?

        // we are waiting for an EXE to complete self-registering
        // notify client of condition and maybe it wants to
        // ask the user if (s)he wants to wait for the EXE or abort
        // download
        // we never kill the EXE though we just ignore it

        if (pCodeInstall) {
            WCHAR szBuf[MAX_PATH];

            szBuf[0] = '\0';

            if (m_szWaitForEXE) {
                MultiByteToWideChar(CP_ACP, 0, m_szWaitForEXE, -1, szBuf, MAX_PATH);
            }
            hr = pCodeInstall->OnCodeInstallProblem(
                                CIP_EXE_SELF_REGISTERATION_TIMEOUT,
                                NULL, szBuf, 0);
        } else {
            hr = S_FALSE; // assume skip EXE and proceed
        }

        if (hr == S_OK)         // continue to wait?
        {
            DEBUG_LEAVE(S_FALSE);
            return S_FALSE;     // yes
        }
        
        // if hr == S_FALSE/E_ABORT ignore this EXE and try to proceed with
        // rest of installation

        if (m_pi.hProcess != INVALID_HANDLE_VALUE) {
            CloseHandle(m_pi.hProcess);
            m_pi.hProcess = INVALID_HANDLE_VALUE;
        }
        if (m_pi.hThread != INVALID_HANDLE_VALUE) {
            CloseHandle(m_pi.hThread);
            m_pi.hThread = INVALID_HANDLE_VALUE;
        }
        SetNotWaitingForEXE();

        m_hr = E_ABORT;
        CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_SETUP, this, 0);

        if (pPkt) {
            hr = pPkt->Post();
        } else {
            hr = E_OUTOFMEMORY;
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    if (pCodeInstall) {
        hr = pCodeInstall->OnCodeInstallProblem(CIP_UNSAFE_TO_ABORT,
                                NULL, NULL, 0);
    } else {
        hr = E_ABORT;
    }

    if (hr == S_OK) {
        hr = S_FALSE;
    } else {
        SetUserCancelled();
        hr = E_ABORT;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SelfRegEXETimeout
HRESULT
CCodeDownload::SelfRegEXETimeout()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SelfRegEXETimeout",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;

    if (!WaitingForEXE())
    {
        DEBUG_LEAVE(hr);
        return S_FALSE;
    }
    
    Assert(m_pi.hProcess != INVALID_HANDLE_VALUE);
    DWORD dwResult = WaitForSingleObject(m_pi.hProcess, 0);

    if (dwResult != WAIT_OBJECT_0) {

        // the EXE has not yet completed.
        // just wait for it till we get it or client calls
        // IClientBinding::Abort()

        CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_WAIT_FOR_EXE,
            this,0);

        if (pPkt) {
            hr = pPkt->Post();
        } else {
            hr = E_OUTOFMEMORY;
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    if (!GetExitCodeProcess(m_pi.hProcess, &dwResult))
        dwResult = GetLastError();

    if (m_pi.hProcess != INVALID_HANDLE_VALUE) {
        CloseHandle(m_pi.hProcess);
        m_pi.hProcess = INVALID_HANDLE_VALUE;
    }
    if (m_pi.hThread != INVALID_HANDLE_VALUE) {
        CloseHandle(m_pi.hThread);
        m_pi.hThread = INVALID_HANDLE_VALUE;
    }

    SetNotWaitingForEXE();

    if (DeleteEXEWhenDone()) {
        DeleteFile(m_szWaitForEXE);
        ResetDeleteEXEWhenDone();
    }

    hr = HRESULT_FROM_WIN32(dwResult);

    if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED) ) {
        SetRebootRequired();
        hr = S_OK;
    }

    m_hr = hr;
    CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_SETUP, this, 0);

    if (pPkt) {
        hr = pPkt->Post();
    } else {
        hr = E_OUTOFMEMORY;
    }

    Assert(SUCCEEDED(hr));

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetManifest()
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::SetManifest(FILEXTN extn, LPCSTR szManifest)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetManifest",
                "this=%#x, %#x, %.80q",
                this, extn, szManifest
                ));
                
    HRESULT hr = S_OK;

    LPSTR szFile = new char [lstrlen(szManifest)+1];

    if (!szFile) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcpy(szFile, szManifest);

    if (extn == FILEXTN_INF) {
        SAFEDELETE(m_szInf);
        m_szInf = szFile;
    } else {
        SAFEDELETE(m_szOSD);
        m_szOSD = szFile;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::VersionFromManifest
// ---------------------------------------------------------------------------
BOOL
CCodeDownload::VersionFromManifest(LPSTR szVersionInManifest, int iLen)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::VersionFromManifest",
                "this=%#x, %.80q",
                this, szVersionInManifest
                ));

    if (m_szVersionInManifest) {

        StrNCpy(szVersionInManifest, m_szVersionInManifest, iLen);

        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ProcessJavaManifest
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::ProcessJavaManifest(IXMLElement *pJava, const char *szOSD, char *szOSDBaseName, CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ProcessJavaManifest",
                "this=%#x, %#x, %.80q, %.80q, %#x",
                this, pJava, szOSD, szOSDBaseName, pdl
                ));
                
    HRESULT hr = S_OK;
    IXMLElement *pPackage = NULL, *pElemTmp = NULL, *pConfig = NULL;
    CDownload *pdlCur = NULL;
    LPWSTR szPackageName = NULL;
    char szPackageVersion[MAX_PATH];
    DWORD dwVersionMS = 0, dwVersionLS = 0, dwJavaFlags = 0;
    int nLastPackage, nLastConfig;
    CCodeBaseHold *pcbh = NULL;
    char szPackageURLA[INTERNET_MAX_URL_LENGTH];
    char *pBaseFileName = NULL;
    LPWSTR pszNameSpace = NULL;
    CList<CCodeBaseHold *, CCodeBaseHold *>    *pcbhList = NULL;
    BOOL bDestroyPCBHList = FALSE;
    int iCount = 0;

    if (!pdl->HasJavaPermissions()) {

        if (IsSilentMode())
        {
            SetBitsInCache();
        } else {

            hr = TRUST_E_FAIL;
            goto Exit;
        }
    }

    hr = GetTextContent(pJava, DU_TAG_NAMESPACE, &pszNameSpace);

    if (FAILED(hr))
        goto Exit;

    // while more packages

    nLastPackage = -1;
    while( (GetNextChildTag(pJava, DU_TAG_PACKAGE, &pPackage, nLastPackage)) == S_OK) {

        SAFEDELETE(szPackageName);

        // process package
        hr = DupAttribute(pPackage, DU_ATTRIB_NAME, &szPackageName);
        CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_JAVAPACKAGE_SYNTAX);

        if (GetAttributeA(pPackage, DU_ATTRIB_VERSION,
            szPackageVersion, MAX_PATH) == S_OK) {

            hr = GetVersionFromString(szPackageVersion, &dwVersionMS, &dwVersionLS);
            CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_JAVAPACKAGE_SYNTAX);
        } else {
            hr = E_INVALIDARG;
            CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_JAVAPACKAGE_SYNTAX);
        }

        if (GetFirstChildTag(pPackage, DU_TAG_SYSTEM, &pElemTmp) == S_OK) {
            m_dwSystemComponent = TRUE;
            SAFERELEASE(pElemTmp);
        }

        // check if package of right version is already locally installed
        // if so go to next package

        hr = IsPackageLocallyInstalled(szPackageName, pszNameSpace, dwVersionMS, dwVersionLS);

        if (FAILED(hr))
            goto Exit;

        if (hr == S_OK) {

            // OK, so this package that is reqd by this dist unit
            // is already present on machine
            // we still need to create a NOSETUP JavaSetup obj just so
            // it gets marked as belonging to/used by this dist unit.

            // for a NOSETUP CJavaSetup it doesn't matter which pdl it gets
            // added on to.
            hr = pdl->AddJavaSetup(szPackageName, pszNameSpace, pPackage, dwVersionMS, dwVersionLS, CJS_FLAG_NOSETUP);

            if (FAILED(hr))
                goto Exit;

            goto nextPackage;
        }

        hr = S_OK;  // reset

        // else, make a CJavaSetup for each package that needs to be installed
        // also make sure that the CABs in those packages are downloaded

        nLastConfig = -1;

        // OR all NEEDSTRUSTEDSOURCE & SYSTEM flags from all CONFIG's since there may be
        // multiple CODEBASE's.
        dwJavaFlags = CJS_FLAG_INIT;

        if (m_dwSystemComponent) {
            dwJavaFlags |= CJS_FLAG_SYSTEM;
        }

        if (GetFirstChildTag(pPackage, DU_TAG_NEEDSTRUSTEDSOURCE, &pElemTmp) == S_OK) {
            dwJavaFlags |= CJS_FLAG_NEEDSTRUSTEDSOURCE;
            SAFERELEASE(pElemTmp);
        }

        // If no CODEBASE specified in CONFIG, add Setup of Java package to this download.
        pdlCur = pdl;

        while (GetNextChildTag(pPackage, DU_TAG_CONFIG, &pConfig, nLastConfig) == S_OK) {

            // This is destroyed by destructor of DoDownload called

            if (bDestroyPCBHList) {
                DestroyPCBHList(pcbhList);
                SAFEDELETE(pcbhList);
            }
            pcbhList = new CList<CCodeBaseHold *, CCodeBaseHold *>;
            if (pcbhList == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            bDestroyPCBHList = TRUE;
            pcbhList->RemoveAll();

            if (ProcessImplementation(pConfig, pcbhList, m_lcid
#ifdef WX86
                                      , GetMultiArch()
#endif
                                      ) == S_OK) {

                iCount = pcbhList->GetCount();
                if (iCount) {
                    pcbh = pcbhList->GetHead();
                    pcbh->dwFlags |= CBH_FLAGS_DOWNLOADED;
                }
                else {
                    pcbh = NULL;
                }

                if (pcbh && pcbh->wszCodeBase) {

                    WideCharToMultiByte(CP_ACP, 0, pcbh->wszCodeBase, -1,
                          szPackageURLA, sizeof(szPackageURLA),NULL, NULL);

                    FILEXTN extn = ::GetExtnAndBaseFileName(szPackageURLA, &pBaseFileName);

                    if (extn != FILEXTN_CAB) {
                        hr = E_INVALIDARG;
                        goto Exit;
                    }

                    if (pcbh->bHREF) {
                        // CODEBASE HREF="..." download CAB with java package

                        hr = FindCABInDownloadList(pcbh->wszCodeBase, pdl, &pdlCur);

                        if (FAILED(hr))
                            goto Exit;

                        if (!pdlCur) {

                            // did not find CAB
                            // fresh CAB needs to get pulled down.

                            pdlCur = new CDownload(pcbh->wszCodeBase, extn, &hr);
                            if (!pdlCur) {
                                hr = E_OUTOFMEMORY;
                            }

                            if (FAILED(hr)) {
                                SAFEDELETE(pdlCur);
                                goto Exit;
                            }

                            AddDownloadToList(pdlCur);

                            {
                            BOOL bSetOnStack = SetOnStack();
                            bDestroyPCBHList = FALSE;
                            hr = pdlCur->DoDownload(&m_pmkContext,
                                                     (BINDF_ASYNCHRONOUS|
                                                     BINDF_ASYNCSTORAGE),
                                                     pcbhList);
                            if (bSetOnStack)
                                ResetOnStack();
                            }

                        }

                    }

                    if (FAILED(hr)) {
                        goto Exit;
                    }


                } else {
                    // found a valid config but no CODEBASE
                    // assume that the pkg is in 'thiscab'
                    // goto add package
                }

                goto addPackage;

            } // Got CONFIG tag successfully

            SAFERELEASE(pConfig);

        } // <CONFIG> tag loop

        if (SUCCEEDED(hr)) {
            hr = HRESULT_FROM_WIN32(ERROR_APP_WRONG_OS);
        }

        goto nextPackage;

addPackage:
        hr = pdlCur->AddJavaSetup(szPackageName, pszNameSpace, pPackage, dwVersionMS, dwVersionLS, dwJavaFlags);

nextPackage:
        SAFERELEASE(pPackage);
        SAFERELEASE(pConfig);

        if (FAILED(hr))
            break;

        if (hr == S_FALSE)
            hr = S_OK;  // reset

    } // <PACKAGE> tag loop

Exit:
    SAFERELEASE(pConfig);
    SAFERELEASE(pPackage);

    SAFEDELETE(szPackageName);
    SAFEDELETE(pszNameSpace);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ProcessDependency
//    Processes <dependency> tag and spins off any dependency code downloads
//    as appropriate.
// ---------------------------------------------------------------------------
HRESULT CCodeDownload::ProcessDependency(CDownload *pdl, IXMLElement *pDepend)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ProcessDependency",
                "this=%#x, %#x, %#x",
                this, pdl, pDepend
                ));
                
    HRESULT              hr = S_OK;
    int                  nLast2, nLast3;
    BOOL                 fAssert = FALSE, fInstall = FALSE;
    IXMLElement         *pSoftDist2 = NULL, *pLang = NULL, *pConfig = NULL;
    LPWSTR               szDistUnit = NULL;
    LPWSTR               pwszURL = NULL;
    LPSTR                szLanguages = NULL;
    LPSTR                pBaseFileName = NULL;
    WCHAR                szCDLURL[2*INTERNET_MAX_URL_LENGTH];
    WCHAR                wszURLBuf[2*INTERNET_MAX_URL_LENGTH];
    WCHAR                szResult[INTERNET_MAX_URL_LENGTH];
    DWORD                dwSize = 0;
    DWORD                dwVersionMS = 0, dwVersionLS = 0, dwStyle;
    CDownload           *pdlCur = NULL;
    CLSID                inclsid = CLSID_NULL;
    CCodeBaseHold       *pcbh = NULL;
    CLocalComponentInfo  lci;
    int                  i, iCount = 0, iLen = 0;
    LISTPOSITION         lpos = 0;
    CCodeBaseHold       *pcbhCur = NULL;
    LPWSTR               pwszStr = NULL;
    CList<CCodeBaseHold *, CCodeBaseHold *>    *pcbhList = NULL;
    BOOL bDestroyPCBHList = FALSE;
    LPWSTR pwszVersion = NULL;

    union {
        char szAction[MAX_PATH];
        char szVersion[MAX_PATH];
        char szStyle[MAX_PATH];
        char szPackageURLA[INTERNET_MAX_URL_LENGTH];
    };

    if (SUCCEEDED(GetAttributeA(pDepend, DU_ATTRIB_ACTION, szAction, MAX_PATH))) {

        if (lstrcmpi(szAction, "ASSERT") == 0)
            fAssert = TRUE;
        else if (lstrcmpi(szAction, "INSTALL") == 0)
            fInstall = TRUE;
        else
            goto Exit;
    } else
        fAssert = TRUE;

    nLast2 = -1;
    while (GetNextChildTag(pDepend, DU_TAG_SOFTDIST, &pSoftDist2, nLast2) == S_OK) {

        if (FAILED(hr))
            break;

        // get NAME attribute
        hr = DupAttribute(pSoftDist2, DU_ATTRIB_NAME, &szDistUnit);
        CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_DEPENDENCY_SYNTAX);

        // get VERSION attribute
        hr = GetAttributeA(pSoftDist2, DU_ATTRIB_VERSION, szVersion, MAX_PATH);
        CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_DEPENDENCY_SYNTAX);

        // convert VERSION string
        hr = GetVersionFromString(szVersion, &dwVersionMS, &dwVersionLS);
        CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_DEPENDENCY_SYNTAX);

        // remember the version string in uni
        hr = Ansi2Unicode(szVersion, &pwszVersion);
        if (FAILED(hr))
            goto Exit;

        // get STYLE attribute
        if (SUCCEEDED(GetAttributeA(pSoftDist2, DU_ATTRIB_STYLE, szStyle, MAX_PATH))) {
            (void) GetStyleFromString(szStyle, &dwStyle);
        } else
            dwStyle = STYLE_MSICD;

        // Check if distribution unit is currently installed
        // NOTE: This assumes MSICD

        inclsid = CLSID_NULL;
        CLSIDFromString((LPOLESTR)szDistUnit, &inclsid);

        if ((hr = IsControlLocallyInstalled(NULL,
                (LPCLSID)&inclsid, szDistUnit,
                dwVersionMS, dwVersionLS, &lci, NULL)) != S_FALSE) {

            // add distribution unit as a dependency
            AddDistUnitList(szDistUnit);

            goto nextDepend;
        }

        // if Action=ASSERT and we don't have distribution unit, then skip this <softdist>.
        if (fAssert) {
            hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
            goto Exit;
        }

        // minimal check for circular dependency
        if (StrCmpIW(szDistUnit, m_szDistUnit)==0) {
            hr = HRESULT_FROM_WIN32(ERROR_CIRCULAR_DEPENDENCY);
            goto Exit;
        }

        // process CONFIG tags
        nLast3 = -1;
        pcbh = NULL;
        while (GetNextChildTag(pSoftDist2, DU_TAG_CONFIG, &pConfig, nLast3) == S_OK) {
            
            if (bDestroyPCBHList) {
                DestroyPCBHList(pcbhList);
                SAFEDELETE(pcbhList);
            }
            pcbhList = new CList<CCodeBaseHold *, CCodeBaseHold *>;
            if (pcbhList == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            bDestroyPCBHList = TRUE;
            pcbhList->RemoveAll();

            pcbh = NULL;
            hr = ProcessImplementation(pConfig, pcbhList, m_lcid
#ifdef WX86
                                       , GetMultiArch()
#endif
                                      );

            if (SUCCEEDED(hr)) {
                iCount = pcbhList->GetCount();
                if (iCount) {
                    pcbh = pcbhList->GetHead();
                    pcbh->dwFlags |= CBH_FLAGS_DOWNLOADED;
                }
                else {
                    pcbh = NULL;
                }
            }
            SAFERELEASE(pConfig);

            if (hr == S_OK) {

                szPackageURLA[0] = '\0';

                //BUGBUG: If no CODEBASE how do we know extension?  Assuming it is CAB
                FILEXTN extn = FILEXTN_CAB;

                if (pcbh && pcbh->wszCodeBase && pcbh->bHREF) {

                    WideCharToMultiByte(CP_ACP, 0, pcbh->wszCodeBase, -1, szPackageURLA,
                        INTERNET_MAX_URL_LENGTH,NULL, NULL);

                    extn = ::GetExtnAndBaseFileName(szPackageURLA, &pBaseFileName);

                }

                // "cdl:[clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];"
                // we use: "cdl:distunit=xxxx[|codebase=xxxx]"

                // BUGBUG: We could mess up CDLProtocol if any of these embedded fields are
                //         illformatted (contains '=' or '\\' or '//').

                // cdl: protocol treats clsid as DistUnit name if not a valid CLSID.
                StrCpyW(szCDLURL, L"cdl:distunit=");
                StrCatBuffW(szCDLURL, szDistUnit, 2*INTERNET_MAX_URL_LENGTH);
                StrCatBuffW(szCDLURL, L";version=", 2*INTERNET_MAX_URL_LENGTH);
                StrCatBuffW(szCDLURL, pwszVersion, 2*INTERNET_MAX_URL_LENGTH);

                if (szPackageURLA[0]) {
                    StrCatBuffW(szCDLURL, L";codebase=", 2*INTERNET_MAX_URL_LENGTH);
                    if (SUCCEEDED(GetContextMoniker()->GetDisplayName(NULL, NULL, &pwszURL))) {
                        dwSize = INTERNET_MAX_URL_LENGTH;
                        if(FAILED(UrlCombineW(pwszURL, pcbh->wszCodeBase, szResult, &dwSize, 0))) {
                            hr = E_UNEXPECTED;
                            goto Exit;
                        }
                        StrCatBuffW(szCDLURL, szResult, 2*INTERNET_MAX_URL_LENGTH);
                        SAFEDELETE(pwszURL);
                    }
                    else {
                        // A context moniker should always exist if we
                        // are looking at a dependency.
                        hr = E_UNEXPECTED;
                        goto Exit;
                    }
                }

                // Iterate over all codebases in the list, and covert them
                // to CDL: protocols instead of HTTP:.

                lpos = pcbhList->GetHeadPosition();
                while (lpos) {
                    pcbhCur = pcbhList->GetNext(lpos);
                    if (pcbhCur != NULL) {
                        StrCpyW(wszURLBuf, L"cdl:distunit=");
                        StrCatBuffW(wszURLBuf, szDistUnit, 2*INTERNET_MAX_URL_LENGTH);
                        StrCatBuffW(wszURLBuf, L";version=", 2*INTERNET_MAX_URL_LENGTH);
                        StrCatBuffW(wszURLBuf, pwszVersion, 2*INTERNET_MAX_URL_LENGTH);
                        StrCatBuffW(wszURLBuf, L";codebase=", 2*INTERNET_MAX_URL_LENGTH);

                        // Combine the context moniker's URL with the
                        // codebase supplied to handle relative dependency
                        // URLs. If the dependency URL is absolute,
                        // UrlCombineW will just return the absolute
                        // dependency URL.

                        if (SUCCEEDED(GetContextMoniker()->GetDisplayName(NULL, NULL, &pwszURL))) {
                            dwSize = INTERNET_MAX_URL_LENGTH;
                            if (FAILED(UrlCombineW(pwszURL, pcbhCur->wszCodeBase, szResult, &dwSize, 0))) {
                                hr = E_UNEXPECTED;
                                goto Exit;
                            }
                            iLen = lstrlenW(szResult) + lstrlenW(wszURLBuf) + 1;
                            pwszStr = new WCHAR[iLen];
                            if (pwszStr == NULL) {
                                SAFEDELETE(pwszURL);
                                hr = E_OUTOFMEMORY;
                                goto Exit;
                            }
                            StrCpyW(pwszStr, wszURLBuf);
                            StrCatW(pwszStr, szResult);
                            SAFEDELETE(pcbhCur->wszCodeBase);
                            pcbhCur->wszCodeBase = pwszStr;
                            SAFEDELETE(pwszURL);
                        }
                        else {
                            hr = E_UNEXPECTED;
                            goto Exit;
                        }
                    }
                }

                // Because of way this is processed it should create URLMoniker, which in
                // turn creates CCodeDownload and properly installs before we do our
                // setup here.  Thus we don't need to do anything else explicit here.

                pdlCur = new CDownload(szCDLURL, extn, &hr);
                if (!pdlCur) {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr)) {
                    SAFEDELETE(pdlCur);
                    goto Exit;
                }

                AddDownloadToList(pdlCur);

                hr = pdlCur->SetUsingCdlProtocol(szDistUnit);

                if (FAILED(hr))
                    goto Exit;


                {
                BOOL bSetOnStack = SetOnStack();
                bDestroyPCBHList = FALSE;
                hr = pdlCur->DoDownload(&m_pmkContext, (BINDF_ASYNCHRONOUS|
                                        BINDF_ASYNCSTORAGE), pcbhList);
                if (bSetOnStack)
                    ResetOnStack();
                }

                // this is an indication "cdl://" is not installed.
                CHECK_ERROR_EXIT((hr != E_NOINTERFACE),ID_CDLDBG_CDL_HANDLER_MISSING);

                if (FAILED(hr))
                    goto Exit;

                goto nextDepend;

            }

            SAFEDELETE(pcbh);
        }

        if (SUCCEEDED(hr))
            hr = HRESULT_FROM_WIN32(ERROR_APP_WRONG_OS);

nextDepend:
        SAFERELEASE(pLang);
        SAFERELEASE(pSoftDist2);
        SAFEDELETE(szDistUnit);
        SAFEDELETE(szLanguages);

        if (FAILED(hr))
            break;
    }

Exit:
    SAFERELEASE(pLang);
    SAFERELEASE(pSoftDist2);
    SAFERELEASE(pConfig);
    SAFEDELETE(szDistUnit);
    SAFEDELETE(szLanguages);
    SAFEDELETE(pwszVersion);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ExtractInnerCAB
//    We have a nested CAB, extract its contents into temporary directory (do not
//    process any OSD, INF files for this).  If duplicate files exist we ignore
//    since this is a design error.
// ---------------------------------------------------------------------------
HRESULT CCodeDownload::ExtractInnerCAB(CDownload *pdl, LPSTR szCABFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ExtractInnerCAB",
                "this=%#x, %#x, %.80q",
                this, pdl, szCABFile
                ));
                
    HRESULT hr = S_OK;
    SESSION *psess;
    CHAR szTempCABFile[MAX_PATH];

    psess = new SESSION;
    if (!psess) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    psess->pFileList        = NULL;
    psess->cFiles           = 0;
    psess->cbCabSize        = 0;
    psess->flags = SESSION_FLAG_ENUMERATE | SESSION_FLAG_EXTRACT_ALL;
    lstrcpy(psess->achLocation,pdl->GetSession()->achLocation);
    psess->pFilesToExtract = NULL;

    if (!catDirAndFile(szTempCABFile, MAX_PATH, psess->achLocation, szCABFile)) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    hr = ExtractFromCabinet(psess, szTempCABFile);

    if (psess->pFileList && SUCCEEDED(hr)) {

        // add extracted files to download list for cleanup purposes
        PFNAME pfl = psess->pFileList;
        SESSION *psessdl = pdl->GetSession();
        while (pfl->pNextName) {
            pfl=pfl->pNextName;
        }
        pfl->pNextName = psessdl->pFileList;
        psessdl->pFileList = psess->pFileList;

    }

Exit:
    SAFEDELETE(psess);

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL CCodeDownload::IsFileProtected(LPCSTR pFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CCodeDownload::IsFileProtected",
                "this=%#x, %.100q",
                this, pFileName
                ));

    LPWSTR                     wzFileName = NULL;
    BOOL                       bIsProtectedFile = FALSE;
    pfnSfcIsFileProtected      pfn = NULL;

    if (SUCCEEDED(::Ansi2Unicode(pFileName, &wzFileName))) 
    {
        if (!m_hModSFC) 
        {
            m_hModSFC = LoadLibrary("SFC.DLL");
        }

        if (m_hModSFC) 
        {
            pfn = (pfnSfcIsFileProtected)GetProcAddress(m_hModSFC, "SfcIsFileProtected");
            if (pfn) 
            {
                bIsProtectedFile = (*pfn)(NULL,wzFileName);
            }
        }

        SAFEDELETE(wzFileName);
    }

    DEBUG_LEAVE(bIsProtectedFile);
    return bIsProtectedFile;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ProcessNativeCode
//    Processes <nativecode> tag and spins off any dependency code downloads
//    as appropriate.
// ---------------------------------------------------------------------------
HRESULT CCodeDownload::ProcessNativeCode(CDownload *pdl, IXMLElement *pNativeCode)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ProcessNativeCode",
                "this=%#x, %#x, %#x",
                this, pdl, pNativeCode
                ));
                
    HRESULT     hr = S_OK;
    int         iCount;


    LPWSTR szName = NULL;
    union {
        char szCLSID[MAX_PATH];
        char szVersion[MAX_PATH];
    };
    char szTempFile[INTERNET_MAX_URL_LENGTH];
    LPSTR szCodeBase = NULL, szNativeName = NULL, pBaseFileName = NULL, szTempDir = NULL;
    CCodeBaseHold *pcbh = NULL;
    int nLast2, nLast3;
    DWORD dwVersionMS = 0, dwVersionLS = 0;
    CLSID clsid = CLSID_NULL;
    IXMLElement *pCode = NULL, *pElemTmp = NULL, *pConfig = NULL;
    BOOL fSetupInf = FALSE;
    CLocalComponentInfo lci;
    CSetup *pSetup = NULL;
    ICodeInstall* pCodeInstall = GetICodeInstall();
    BOOL bSystem = FALSE;
    CList<CCodeBaseHold *, CCodeBaseHold *>     *pcbhList = NULL;
    BOOL bDestroyPCBHList = FALSE;

    if (!pdl->HasAllActiveXPermissions()) {

        if (IsSilentMode())
        {
            SetBitsInCache();
        } else {

            hr = TRUST_E_FAIL;
            goto Exit;
        }
    }

    szTempDir = pdl->GetSession()->achLocation;

    nLast2 = -1;
    while (GetNextChildTag(pNativeCode, DU_TAG_CODE, &pCode, nLast2) == S_OK) {

        SAFEDELETE(szName);
        SAFEDELETE(szNativeName);

        if (FAILED(hr)) break;

        // get CLSID attribute
        hr = GetAttributeA(pCode, DU_ATTRIB_CLSID, szCLSID, MAX_PATH);
        if (SUCCEEDED(hr))
        {
            // convert CLSID attribute
            hr = ConvertFriendlyANSItoCLSID(szCLSID, &clsid);
            CHECK_ERROR_EXIT(SUCCEEDED(hr),ID_CDLDBG_NATIVECODE_SYNTAX);
        }
        else
        {
            clsid = CLSID_NULL;
            szCLSID[0] = '\0';
        }

        // get NAME attribute
        hr = DupAttribute(pCode, DU_ATTRIB_NAME, &szName);
        CHECK_ERROR_EXIT(SUCCEEDED(hr),ID_CDLDBG_NATIVECODE_SYNTAX);

        // use "NAME" attribute as file name to OCX/INF/DLL
        if (FAILED(hr = Unicode2Ansi(szName, &szNativeName)))
             break;

        // get VERSION attribute
        if (SUCCEEDED(GetAttributeA(pCode, DU_ATTRIB_VERSION, szVersion, MAX_PATH))) {

            // convert VERSION string
            hr = GetVersionFromString(szVersion, &dwVersionMS, &dwVersionLS);
            CHECK_ERROR_EXIT(SUCCEEDED(hr),ID_CDLDBG_NATIVECODE_SYNTAX);

        } else {

            dwVersionMS = 0;
            dwVersionLS = 0;

        }

        if (GetFirstChildTag(pCode, DU_TAG_SYSTEM, &pElemTmp) == S_OK) {
            bSystem = TRUE;
            SAFERELEASE(pElemTmp);
        } else {
            bSystem = FALSE;
        }

        // Check if object CLSID unit is currently installed
        // NOTE: This assumes MSICD
        
        HRESULT    hrExact;
        HRESULT    hrAny;

        hrAny = IsControlLocallyInstalled(szNativeName,
                                          (LPCLSID)&clsid, NULL,
                                          dwVersionMS, dwVersionLS,
                                          &lci, GetDestDirHint(),
                                          FALSE);

        if (m_bExactVersion) {
            hrExact = IsControlLocallyInstalled(szNativeName,
                                                (LPCLSID)&clsid, NULL,
                                                dwVersionMS, dwVersionLS,
                                                &lci, GetDestDirHint(),
                                                TRUE);
        }

        if (m_bExactVersion && hrExact == S_FALSE && hrAny == S_OK) {

            // Newer version exists on the machine.
            // Check if we are going to install outside of DPF
            // and disallow if we are going to downgrade.

            BOOL bIsDPFComponent = FALSE;
            CHAR szOCXCacheDirSFN[MAX_PATH];
            CHAR szFNameSFN[MAX_PATH];

            if (lci.szExistingFileName[0]) {

                GetShortPathName(lci.szExistingFileName, szFNameSFN, MAX_PATH);
                GetShortPathName(g_szOCXCacheDir, szOCXCacheDirSFN, MAX_PATH);

                if (StrStrI(szFNameSFN, szOCXCacheDirSFN)) {
                    bIsDPFComponent = TRUE;
                }
            }

            if (!bIsDPFComponent) {
                // Trying to downgrade a system component. Just pretend
                // system component is OK.
                if (!IsEqualGUID(clsid, GetClsid())) {
                    if (lci.szExistingFileName[0]) {
                        hr = QueueModuleUsage(lci.szExistingFileName, MU_CLIENT);
                    }

                }
                goto nextNativeCode;
            }


        }
        // Else, we are a legacy case (non-sxs) or
        // hrExact == S_OK (therefore, hrAny == S_OK) or
        // hrAny == hrExact == S_FALSE (and we fall through).
        else {
            if (hrAny != S_FALSE) {
                if (!IsEqualGUID(clsid, GetClsid())) {

                    if (lci.szExistingFileName[0]) {
                        hr = QueueModuleUsage(lci.szExistingFileName, MU_CLIENT);
                    }

                }
                goto nextNativeCode;
            }

        }

        // Disallow replacement of SFC files for Win2K

        if (g_bNT5OrGreater) 
        {
            if (!FileProtectionCheckSucceeded(lci.szExistingFileName))
            {
                hr = INET_E_CANNOT_REPLACE_SFP_FILE;
                goto Exit;
            }
        }

        // process CONFIG tag.
        nLast3 = -1;
        while (GetNextChildTag(pCode, DU_TAG_CONFIG, &pConfig, nLast3) == S_OK) {
            if (bDestroyPCBHList) {
                DestroyPCBHList(pcbhList);
                SAFEDELETE(pcbhList);
            }
            pcbhList = new CList<CCodeBaseHold *, CCodeBaseHold *>;
            if (pcbhList == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            bDestroyPCBHList = TRUE;
            pcbhList->RemoveAll();

            hr = ProcessImplementation(pConfig, pcbhList, m_lcid
#ifdef WX86
                                       , GetMultiArch()
#endif
                                      );

            SAFERELEASE(pConfig);

            if (FAILED(hr))
                break;

            if (hr == S_OK) {

                pBaseFileName = NULL;

                iCount = pcbhList->GetCount();
                if (iCount) {
                    pcbh = pcbhList->GetHead();
                    pcbh->dwFlags |= CBH_FLAGS_DOWNLOADED;
                }
                else {
                    pcbh = NULL;
                }

                if (pcbh) {

                    if (FAILED(hr = Unicode2Ansi(pcbh->wszCodeBase, &szCodeBase)))
                            break;

                    if (!pcbh->bHREF) {

                        // CODEBASE FILENAME= has precedence over NAME="" for file name.
                        // If FILENAME is CAB, then extract contents
                        //      with szNativeName=NAME, szCodeBase=thiscab
                        // otherwise
                        //      szNativeName=FILENAME, szCodeBase=thiscab, ignore NAME
                        FILEXTN extn = ::GetExtnAndBaseFileName(szCodeBase, &pBaseFileName);
                        if (extn == FILEXTN_CAB) {

                            ExtractInnerCAB(pdl, szCodeBase);

                        } else {

                            SAFEDELETE(szNativeName);
                            if (FAILED(hr = Unicode2Ansi(pcbh->wszCodeBase, &szNativeName)))
                                break;

                        }
                        SAFEDELETE(szCodeBase);

                        szCodeBase = new char[lstrlenA(szTHISCAB)+1];
                        if (!szCodeBase) {
                             hr = E_OUTOFMEMORY;
                             break;
                        }
                        lstrcpyA(szCodeBase, szTHISCAB);
                    }

                } else {

                    // No FILENAME field, szNativeName=NAME & szCodeBase=thiscab
                    szCodeBase = new char[lstrlenA(szTHISCAB)+1];
                    if (!szCodeBase) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    lstrcpyA(szCodeBase,szTHISCAB);

                }

                FILEXTN extn = ::GetExtnAndBaseFileName(szNativeName, &pBaseFileName);

                //BUGBUG: Should we limit ourselves to at most one INF file per OSD?
                if ((!pcbh || !pcbh->bHREF) && extn == FILEXTN_INF) {

                    // File is in temporary directory somewhere,  We extract Temp
                    if (!catDirAndFile(szTempFile, MAX_PATH, (char *)szTempDir, szNativeName)) {
                        hr = E_FAIL;
                        goto Exit;
                    }

                    hr = SetupInf(szTempFile, pBaseFileName, pdl);

                    if (SUCCEEDED(hr)) {
                        fSetupInf = TRUE;
                    }

                } else {

                    if (lci.IsPresent() && pCodeInstall) {

                        // a prev version exists. get permission to overwrite
                        // if ICodeInstall available
                        WCHAR szBuf[MAX_PATH];

                        MultiByteToWideChar(CP_ACP, 0,
                            (lci.szExistingFileName[0])?lci.szExistingFileName:szNativeName, -1, szBuf, MAX_PATH);

                        hr = pCodeInstall->OnCodeInstallProblem( CIP_OLDER_VERSION_EXISTS,
                            NULL, szBuf, 0);

                        if (FAILED(hr)) {

                            if (hr == E_ABORT)
                                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

                            break;
                        }
                    }

                    //BUGBUG: Need a way to do this stuff in OSD
                    DESTINATION_DIR dest = LDID_OCXCACHE;

                    //DWORD dwRegisterServer = CST_FLAG_REGISTERSERVER;
                    // we can't force a register server here as this will
                    // mean as if we have an override in the INF/OSD
                    // whereas there is no support for this in OSD.
                    // turning this off here means:
                    // for EXE we will run if pointed to in the OSD or
                    // directly by codebase, but we will run with /regsvr
                    // and leave installed only if marked oleself register

                    // for an OCX unless overrideen we will alwys register
                    // if the DLL is registerable (has dllregisterserver entrypt

                    DWORD dwRegisterServer = 0;
                    DWORD dwCopyFlags = 0;

                    if (m_dwSystemComponent || bSystem) {
                        m_dwSystemComponent = TRUE;
                        dest = LDID_SYS;
                    }

                    hr = StartDownload(szNativeName, pdl, szCodeBase,
                                dest, lci.lpDestDir, dwRegisterServer, dwCopyFlags,
                                pcbhList);
                    bDestroyPCBHList = FALSE;
                }

                SAFEDELETE(szCodeBase);

                goto nextNativeCode;
            }

            if (FAILED(hr))
                break;

        }


        // here if anything in above loop failed or we never found an
        // implmentation matching our config

        if (SUCCEEDED(hr))
            hr = HRESULT_FROM_WIN32(ERROR_APP_WRONG_OS);

nextNativeCode:
        SAFERELEASE(pCode);
        SAFERELEASE(pConfig);

    }

Exit:
    SAFERELEASE(pCode);
    SAFERELEASE(pConfig);
    SAFEDELETE(szName);
    SAFEDELETE(szNativeName);
    SAFEDELETE(szCodeBase);

    if (SUCCEEDED(hr) && fSetupInf)
        hr = S_FALSE;

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ParseOSD
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::ParseOSD(const char *szOSD, char *szOSDBaseName, CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ParseOSD",
                "this=%#x, %.80q, %.80q, %#x",
                this, szOSD, szOSDBaseName, pdl
                ));

    HRESULT hr = S_OK;
    IXMLElement *pSoftDist = NULL, *pDepend = NULL, *pJava = NULL,
                *pNativeCode = NULL, *pTitle = NULL, *pExpire = NULL,
                *pSystemTag = NULL, *pSXS = NULL;
    LPSTR pBaseFileName = NULL, lpTmpDir = NULL;
    DWORD len = 0;
    int nLast, nLast2, nLast3;
    BOOL bSetupInf = FALSE;

    // create a CSetup OBJ and add it to the CDownload obj
    CSetup *pSetup = new CSetup(szOSD, szOSDBaseName, FILEXTN_OSD, NULL, &hr);
    if(!pSetup) {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr))
        goto Exit;

    pdl->AddSetupToList(pSetup);

    hr = SetManifest(FILEXTN_OSD, szOSD);
    if (FAILED(hr))
        goto Exit;

    hr = GetSoftDistFromOSD(szOSD, &pSoftDist);
    CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_FAILED_OSD_OM);

    hr = DupAttribute(pSoftDist, DU_ATTRIB_NAME, &m_szDistUnit);
    CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_DU_REQUIRED_ATTRIB_MISSING);

    hr = DupAttributeA(pSoftDist, DU_ATTRIB_VERSION, &m_szVersionInManifest);
    CHECK_ERROR_EXIT(SUCCEEDED(hr), ID_CDLDBG_DU_REQUIRED_ATTRIB_MISSING);


    // process TITLE display name
    if (GetFirstChildTag(pSoftDist, DU_TAG_TITLE, &pTitle) == S_OK) {

        BSTR bstrTitle = NULL;
        hr = pTitle->get_text(&bstrTitle);
        if (FAILED(hr)) {
            goto Exit;
        }

        if (FAILED(Unicode2Ansi(bstrTitle, &m_szDisplayName))) {
            hr = E_OUTOFMEMORY;
            SAFESYSFREESTRING(bstrTitle);
            goto Exit;
        }
        SAFESYSFREESTRING(bstrTitle);
    }

    // See if there is a SYSTEM tag

    if (GetFirstChildTag(pSoftDist, DU_TAG_SYSTEM, &pSystemTag) == S_OK) {
        SAFERELEASE(pSystemTag);
        m_dwSystemComponent = TRUE;
    }

    // process expire date
    if (GetFirstChildTag(pSoftDist, DU_TAG_EXPIRE, &pExpire) == S_OK) {

        BSTR bstrExpire = NULL;
        hr = pExpire->get_text(&bstrExpire);
        if (SUCCEEDED(hr)) {
            OLECHAR *pch = bstrExpire;

            m_dwExpire = 0;

            for ( ; *pch && m_dwExpire <= MAX_EXPIRE_DAYS; pch++ ) {
                if ( (*pch >= TEXT('0') && *pch <= TEXT('9')) )
                    m_dwExpire = m_dwExpire * 10 + *pch - TEXT('0');
                else
                    break;
            }

            if (m_dwExpire > MAX_EXPIRE_DAYS)
                m_dwExpire = MAX_EXPIRE_DAYS;
        }
        // else treat failure with a NOP

        SAFESYSFREESTRING(bstrExpire);
    }

    if (!m_bExactVersion) {
        // Exact Version necessarily means uninstall old. Don't bother
        // looking it up.
        if (GetFirstChildTag(pSoftDist, DU_TAG_UNINSTALL_OLD, &pSXS) == S_OK) 
        {
                m_bUninstallOld = TRUE;
        }
    }

    //REVIEW: optionally look for ABSTRACT

    //REVIEW: CONFIG tags at highest level are ignored.

    // process all DEPENDENCY tags (installing Distribution Units)
    nLast = -1;
    while (GetNextChildTag(pSoftDist, DU_TAG_DEPENDENCY, &pDepend, nLast) == S_OK) {

        hr = ProcessDependency(pdl, pDepend);
        SAFERELEASE(pDepend);
        if (FAILED(hr))
            goto Exit;

    }

    // process only one NATIVECODE tags (Installing ActiveX/CLSID specified controls)
    nLast = -1;
    if (GetNextChildTag(pSoftDist, DU_TAG_NATIVECODE, &pNativeCode, nLast) == S_OK) {

        hr = ProcessNativeCode(pdl, pNativeCode);
        SAFERELEASE(pNativeCode);
        if (FAILED(hr))
            goto Exit;

        if (hr == S_FALSE)
            bSetupInf = TRUE;
    }

    // process JAVA tags (Installing Java packages)
    nLast = -1;
    while (GetNextChildTag(pSoftDist, DU_TAG_JAVA, &pJava, nLast) == S_OK) {

        //BUGBUG: Parameters szOSD, szOSDBaseName are currently unused.
        hr = ProcessJavaManifest(pJava, szOSD, szOSDBaseName, pdl);
        SAFERELEASE(pJava);
        if (FAILED(hr))
            goto Exit;
    }


Exit:

    if (!bSetupInf) {

        if (SUCCEEDED(hr)) {

            pdl->SetDLState(DLSTATE_READY_TO_SETUP);

        } else {

            // we encountered an error, go to done state.

            pdl->SetDLState(DLSTATE_DONE);
        }
    }

    SAFERELEASE(pJava);
    SAFERELEASE(pTitle);
    SAFERELEASE(pExpire);
    SAFERELEASE(pNativeCode);
    SAFERELEASE(pDepend);
    SAFERELEASE(pSoftDist);
    SAFERELEASE(pSXS);

    DEBUG_LEAVE(hr);
    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::AddDistUnitList
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::AddDistUnitList(LPWSTR szDistUnit)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::AddDistUnitList",
                "this=%#x, %.80wq",
                this, szDistUnit
                ));
                
    HRESULT hr = E_FAIL;
    LPWSTR wszDistUnit = 0;

    hr = CDLDupWStr(&wszDistUnit, szDistUnit);
    if (SUCCEEDED(hr) && wszDistUnit) {

        m_pDependencies.AddHead(wszDistUnit);

    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetupInf
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::SetupInf(const char *szInf, char *szInfBaseName, CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetupInf",
                "this=%#x, %.80q, %.80q, %#x",
                this, szInf, szInfBaseName, pdl
                ));
                
    HRESULT hr = S_OK;
    CSetup* pSetup = NULL;
    int nBuffSize = MAX_INF_SECTIONS_SIZE;
    char lpSections[MAX_INF_SECTIONS_SIZE];
    const static char *szAddCodeSection = "Add.Code";
    const static char *szHooksSection = "Setup Hooks";
    const static char *szUninstallOld = "UninstallOld";
    static char *szDefault = "";
    DWORD len;

    SetHaveInf();

    if (!pdl->HasAllActiveXPermissions()) {

        if (IsSilentMode())
        {
            SetBitsInCache();
        } else {

            hr = TRUST_E_FAIL;
            goto Exit;
        }
    }

    pdl->SetDLState(DLSTATE_INF_PROCESSING);

    Assert(m_szInf == NULL);

    m_szInf = new char [lstrlen(szInf)+1];

    if (!m_szInf) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    lstrcpy(m_szInf, szInf);

    // Add a setup obj for this INF file
    // We keep the INF file in the ocxcache dir
    // to be able to nuke the OCX

    // create a CSetup OBJ and add it to the CDownload obj
    pSetup = new CSetup(szInf, szInfBaseName, FILEXTN_INF, NULL, &hr);
    if(!pSetup) {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        SAFEDELETE(pSetup);
        goto Exit;
    }

    pdl->AddSetupToList(pSetup);

    len = GetPrivateProfileString(szAddCodeSection, NULL, szDefault,
                                                lpSections, nBuffSize, m_szInf);

    if (!len) {

        // no Internet Code Downloader known sections in INF may be a
        // regular Win32 INF file format, make a hook if the
        // INF came in a CAB, which will be to extract all files in the
        // current CAB and then RunSetupCommand

        // there's no [add.code]
        // look to see if there's a [setup hooks]
        // if not we then create a hook to process the default install section
        // if there's a [setup hooks] we won't make a default hokk for you
        // as you can make a hook yourself to process default install
        // the idea is you either don't know about us (we need to help you)
        // or you are code downloader aware (help yourself with our capabilty)

        // this allows the user to have an INF with any or all of the following
        // 1) [add.code]
        // 2) [Setup hooks]
        // 3) win32 inf : defaultinstall

        len = GetPrivateProfileString(szHooksSection, NULL, szDefault,
                                                lpSections, nBuffSize, m_szInf);
        if (!len) {

            // make a new hook and add it to this CAB
            // post a message to trigger setup phase as nothing else is needed

            hr = pdl->AddHook(NULL, szInfBaseName, NULL/* szInfSection */, RSC_FLAG_INF);

            goto Exit;
        }


    } else {

        m_pCurCode = m_pAddCodeSection = new char [len + 1];

        if (m_pAddCodeSection) {
            memcpy(m_pAddCodeSection, lpSections, len);
            m_pAddCodeSection[len] = '\0';
        }
    }

    if (!m_bExactVersion) {
        m_bUninstallOld=GetPrivateProfileInt(szAddCodeSection, szUninstallOld, 0, m_szInf);
    }

Exit:

    if (SUCCEEDED(hr)) {

        CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_PROCESS_INF, this, (DWORD_PTR)pdl);

        if (pPkt) {
            hr = pPkt->Post();
        } else {
            hr = E_OUTOFMEMORY;
        }

    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::IsSectionInINF
// Checks if a section is in the INF
// returns:
//      S_OK: lpCurCode has the satellite binary name
//      S_FALSE: ignore this code and use default resources in main dll
//      E_XXX: any other error
BOOL
CCodeDownload::IsSectionInINF(
    LPCSTR lpCurCode)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CCodeDownload::IsSectionInINF",
                "this=%#x, %.80q",
                this, lpCurCode
                ));
                
    const char *szDefault = "";
    DWORD len;
#define FAKE_BUF_SIZE   3
    char szBuf[FAKE_BUF_SIZE];

    len = GetPrivateProfileString(lpCurCode, NULL, szDefault,
                                                szBuf, FAKE_BUF_SIZE, m_szInf);

    if (len == (FAKE_BUF_SIZE - 2)) {   // returns Out Of Buffer Space?
        // yes, section found

        DEBUG_LEAVE(TRUE);
        return TRUE;
    } else {

        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
}



void CCodeDownload::CodeDownloadDebugOut(int iOption, BOOL fOperationFailed,
                                         UINT iResId, ...)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::CodeDownloadDebugOut",
                "this=%#x, %d, %B, %#x, ...",
                this, iOption, fOperationFailed, iResId
                ));

    // Temp solution to prevent buffer overruns in debug logging code.
    // Long term, the printfs should be constrained.  It will be a must
    // if URLs become fully dynamic.
    static char             szDebugString[MAX_DEBUG_STRING_LENGTH*5];
    static char             szFormatString[MAX_DEBUG_FORMAT_STRING_LENGTH];
    va_list                 args;

    LoadString(g_hInst, iResId, szFormatString, MAX_DEBUG_FORMAT_STRING_LENGTH);
    va_start(args, iResId);
    vsprintf(szDebugString, szFormatString, args);
    va_end(args);

    m_debuglog->DebugOutPreFormatted(iOption, fOperationFailed, szDebugString);

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GetSatelliteName
// gets the lang specific satellite DLL name
// in the INF
// returns:
//      S_OK: lpCurCode has the satellite binary name
//      S_FALSE: ignore this code and use default resources in main dll
//      E_XXX: any other error
HRESULT
CCodeDownload::GetSatelliteName(
    LPSTR lpCurCode,
    int iLen)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::GetSatelliteName",
                "this=%#x, %.80q",
                this, lpCurCode
                ));
                
    HRESULT hr = S_OK;
    const char *szDefault = "";
    DWORD len;
#define FAKE_BUF_SIZE   3
    char szBuf[FAKE_BUF_SIZE];
    char szExtension[5];
    int iReturn = 0;

    Assert(lpCurCode);

    szExtension[0] = *lpCurCode = '\0';



    // get a quick out for code that does not have any vars in them
    if ((StrChr(m_pCurCode, '%') == NULL) &&
        IsSectionInINF(m_pCurCode)) {

        // not a satellite
        StrNCpy(lpCurCode, m_pCurCode, iLen);
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_ITEM_PROCESSED, lpCurCode);

        DEBUG_LEAVE(hr);
        return hr;
    }

    // allow IE3 workarounds for %LANG%
    // by looking  for sections that have a %LANG% literally in them
    // after looking for sections with the variable expanded

    // BEGIN NOTE: add vars and values in matching order
    // add a var by adding a new define VAR_NEW_VAR = NUM_VARS++
    const char *szVars[] = {

#define VAR_LANG        0       // 3 letter lang extension
        "%LANG%",


#define NUM_VARS            1

        ""
    };

    const char *szValues[NUM_VARS + 1];
    szValues[VAR_LANG] = szExtension;
    szValues[NUM_VARS] = NULL;
    // END NOTE: add vars and values in matching order


    UINT uLocaleTest=0;
    uLocaleTest = (LOWORD(m_lcid) & (~(~0 << 4) << 0)) >> 0;

    // obtain the 3 character Lang abbreviation for the
    // LCID we're running on.
    // if it doesn't exist we'll get just the 2 charact Lang abbreviation
    // and try again, failing that we default to English

    iReturn = m_langinfo.GetLocaleStrings(m_lcid, szExtension, sizeof(szExtension));

    if (!iReturn) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_ERR_PRIMARY_LANGUAGE, hr, lpCurCode);
        goto Exit;
    }

    // expand the variables names if any
    hr = CSetupHook::ExpandCommandLine(m_pCurCode, lpCurCode, MAX_PATH, szVars, szValues);

    if (FAILED(hr)) { // failed
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_ERR_NO_SECTION, m_pCurCode, szExtension);
        goto Exit;
    }

    // vars are expanded correctly (S_OK) or
    // no vars got expanded.(S_FALSE) maybe we could try the section as is
    if ( IsSectionInINF(lpCurCode)) {
        // satellite found!
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_SATELLITE_FOUND, lpCurCode);
        hr = S_OK;
        goto Exit;
    }


    // we couldn't find it with the entire LCID, try it with just the primary
    // langid

    LCID lcid;
    lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(m_lcid)), SUBLANG_DEFAULT), SORT_DEFAULT);

    iReturn = m_langinfo.GetLocaleStrings(lcid, szExtension, sizeof(szExtension));

    if (!iReturn) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_PROCESSINF_FAILED, hr, lpCurCode);
        goto Exit;
    }

    // expand the variables names with new value
    hr = CSetupHook::ExpandCommandLine(m_pCurCode, lpCurCode, MAX_PATH, szVars, szValues);

    if (FAILED(hr) || (hr == S_FALSE))  { // failed or no vars
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_ERR_NO_SECTION, m_pCurCode, szExtension);
        if (hr == S_FALSE)
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Exit;
    }

    // try the INF section again
    if ( !IsSectionInINF(lpCurCode)) {
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_ERR_NO_SECTION, m_pCurCode, szExtension);

        // no section for this language. This is OK skip the file
        // browser will end up using default lang/resources
        hr = S_FALSE;

    } else {

        // satellite found!
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_SATELLITE_FOUND, lpCurCode);

    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GetInfCodeLocation
// gets the platform specific or independent location URL of the code specified
// in the INF
// returns:
//      S_OK: szURL has the location
//      S_FALSE: ignore this code for the current platform
//      E_XXX: any other error
HRESULT
CCodeDownload::GetInfCodeLocation(
    LPCSTR lpCurCode,
    LPSTR szURL)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::GetInfCodeLocation",
                "this=%#x, %.80q, %.80q",
                this, lpCurCode, szURL
                ));
                
    const static char *szLoc = "File";
    static char *szDefault = "";
    HRESULT hr = S_OK;

    Assert(m_szInf);

    szURL[0] = '\0';            // init to empty string

    // look for platform specific URL first
    // this is needed to skip some files for some
    // platforms
#ifdef WX86
    char *szPreferredArch;
    char *szAlternateArch;
    HRESULT hrArch;

    GetMultiArch()->SelectArchitecturePreferences(
                g_szPlatform,
                "file-win32-x86",
                &szPreferredArch,
                &szAlternateArch);

    GetPrivateProfileString(lpCurCode, szPreferredArch, szDefault, szURL,
        INTERNET_MAX_URL_LENGTH, m_szInf);
    if (szURL[0] != '\0' && lstrcmpi(szURL, szIGNORE) != 0) {
        // There was a URL and it was not 'ignore' to indicate it is not
        // applicable to this platform.
        CodeDownloadDebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_WX86_REQUIRE_PRIMARY_ARCH, szURL);
        hrArch = GetMultiArch()->RequirePrimaryArch();
        Assert(SUCCEEDED(hrArch));
    } else if (szAlternateArch) {
        GetPrivateProfileString(lpCurCode, szAlternateArch, szDefault, szURL,
            INTERNET_MAX_URL_LENGTH, m_szInf);
        if (szURL[0]) {
            if (lstrcmpi(szURL, szIGNORE) != 0) {
                // The alternate architecture matched and the URL was not
                // 'ignore' to indicate it is not applicable to this platform.
                CodeDownloadDebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_WX86_REQUIRE_ALTERNATE_ARCH, szURL);
                hrArch = GetMultiArch()->RequireAlternateArch();
                Assert(SUCCEEDED(hrArch));
            }
        }
    }
#else
    GetPrivateProfileString(lpCurCode, g_szPlatform, szDefault, szURL,
        INTERNET_MAX_URL_LENGTH, m_szInf);
#endif

    if (szURL[0] == '\0') {
        GetPrivateProfileString(lpCurCode, szLoc, szDefault,
                        szURL, INTERNET_MAX_URL_LENGTH, m_szInf);
    } else {
        // got a platform specific URL
        // look for 'ignore' keyword to mean that this is
        // not applicable for this platform

        if (lstrcmpi(szURL, szIGNORE) == 0) {
            hr = S_FALSE;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GetInfSectionInfo
HRESULT
CCodeDownload::GetInfSectionInfo(
    LPSTR lpCurCode,
    int iLen,
    LPSTR szURL,
    LPCLSID *plpClsid,
    LPDWORD pdwFileVersionMS,
    LPDWORD pdwFileVersionLS,
    DESTINATION_DIR *pdest,
    LPDWORD pdwRegisterServer,
    LPDWORD pdwCopyFlags,
    BOOL *pbDestDir
)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::GetInfSectionInfo",
                "this=%#x, %.80q, %.80q, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, lpCurCode, szURL, plpClsid, pdwFileVersionMS, pdwFileVersionLS,
                pdest, pdwRegisterServer, pdwCopyFlags, pbDestDir
                ));
                
    const static char *szFileVersion = "FileVersion";
    const static char *szDest = "DestDir";
    const static char *szRegisterServerOverride = "RegisterServer";
    const static char *szCopyFlags = "CopyFlags";
    const static char *szForceDestDir = "ForceDestDir";
    static char *szDefault = "";
    DWORD len;
    HRESULT hr = S_OK;
    char szBuf[MAX_PATH];

    hr = GetSatelliteName(lpCurCode, iLen);

    if (hr != S_OK)
        goto Exit;

    hr =  GetInfCodeLocation( lpCurCode, szURL);

    if (hr != S_OK)
        goto Exit;

    // get RegisterServerOverride if any
    if (GetPrivateProfileString(lpCurCode, szRegisterServerOverride, szDefault,
                                    szBuf, MAX_PATH, m_szInf)) {

        *pdwRegisterServer = CST_FLAG_REGISTERSERVER_OVERRIDE;

        if ((szBuf[0] == 'y') || (szBuf[0] == 'Y') ||
             (szBuf[0] == '1') || (lstrcmpi(szBuf, "true") == 0)) {
            *pdwRegisterServer |= CST_FLAG_REGISTERSERVER;
        }
    }

    // get CopyFlags if any
    *pdwCopyFlags=GetPrivateProfileInt(lpCurCode, szCopyFlags, 0, m_szInf);

    // get version string
    if (!(len =GetPrivateProfileString(lpCurCode, szFileVersion, szDefault,
                                                szBuf, MAX_PATH, m_szInf))) {
        // if no version specified, local copy is always OK!
        szBuf[0] = '\0';
    }


    if ( FAILED(GetVersionFromString(szBuf, pdwFileVersionMS,
                                                        pdwFileVersionLS))){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // get Destination dir if suggested
    *pdest=(DESTINATION_DIR)GetPrivateProfileInt(lpCurCode, szDest, 0, m_szInf);

    // get ForceDestDir flag
    *pbDestDir=GetPrivateProfileInt(lpCurCode, szForceDestDir, 0, m_szInf);

    // get clsid string
    if (!(len = GetPrivateProfileString(lpCurCode, szCLSID, szDefault,
                                                szBuf, MAX_PATH, m_szInf))){
        // if no clsid specified, not a control, just a plain dll?
        *plpClsid = NULL;
        goto Exit;
    }

    // Get CLSID from string
    hr = ConvertANSItoCLSID(szBuf, *plpClsid);

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::StartDownload
HRESULT
CCodeDownload::StartDownload(
    LPSTR szCurCode,
    CDownload *pdl,
    LPSTR szURL,
    DESTINATION_DIR dest,
    LPSTR szDestDir,
    DWORD dwRegisterServer,
    DWORD dwCopyFlags,
    CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::StartDownload",
                "this=%#x, %.80q, %#x, %.80q, %#x, %.80q, %#x, %#x, %#x",
                this, szCurCode, pdl, szURL, dest,
                szDestDir, dwRegisterServer, dwCopyFlags, pcbhList
                ));
                
    FILEXTN extn;
    char *pBaseFileName;
    HRESULT hr = NO_ERROR;
    WCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    CDownload *pdlCur = NULL;
    CSetup* pSetup = NULL;
    BOOL bDestroyList = TRUE;


    extn = ::GetExtnAndBaseFileName(szURL, &pBaseFileName);

    // if this INF came in a CAB then anything pointing to
    // file=thiscab, means this szCurCode can be found in the CAB
    // that this INF came in. This makes authoring the INFs easy
    // because you don't have to know the name of the site that's going
    // to distribute the OCX.
    // Also, allows for web publisher to change the name of the
    // CAB
    if ((pdl->GetExtn() == FILEXTN_CAB) &&
        (lstrcmpi(szTHISCAB, szURL) == 0)) {
        pdl->AddSetupToExistingCAB(szCurCode, szDestDir, dest,
            dwRegisterServer, dwCopyFlags);
        goto Exit;
    }


    switch (extn) {

    case FILEXTN_INF:
    case FILEXTN_OSD:
        hr = E_INVALIDARG; // don't supp multiple INFs (recursive downloads)
        goto Exit;

    case FILEXTN_CAB:

        // check if URL is a cab that the inf came with (pdl->psess)
        // else check if CAB has been submitted for download in some other
        // CDownload that we just started when processing lines in INF
        // above this one
        // either case if you find a CAB then piggy back this code setup to
        // that CDownload of the same CAB file

        MultiByteToWideChar(CP_ACP, 0, szURL, -1, szBuf,
            INTERNET_MAX_URL_LENGTH);

        hr = FindCABInDownloadList(szBuf, pdl, &pdlCur);

        if (FAILED(hr))
            goto Exit;

        if (pdlCur) {

            // matching CAB found that we can pile on this setup
            pdlCur->AddSetupToExistingCAB(szCurCode, szDestDir, dest, dwRegisterServer, dwCopyFlags);
            goto Exit;
        }

        // fresh CAB needs to get pulled down.
        // download the CODE=URL (ie. CAB or INF file first)
        pdlCur = new CDownload(szBuf, extn, &hr);
        if (!pdlCur) {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr)) {
            SAFEDELETE(pdlCur);
            goto Exit;
        }

        AddDownloadToList(pdlCur);

        {
        BOOL bSetOnStack = SetOnStack();
        hr = (pcbhList == NULL) ? (pdlCur->DoDownload(&m_pmkContext,
                                                     (BINDF_ASYNCHRONOUS|
                                                     BINDF_ASYNCSTORAGE)))
                                : (pdlCur->DoDownload(&m_pmkContext,
                                                     (BINDF_ASYNCHRONOUS|
                                                     BINDF_ASYNCSTORAGE),
                                                     pcbhList));
        bDestroyList = FALSE;

        if (bSetOnStack)
            ResetOnStack();
        }

        if (FAILED(hr)) {
            goto Exit;
        }

        pdlCur->AddSetupToExistingCAB(szCurCode, szDestDir, dest, dwRegisterServer, dwCopyFlags);

        break;


    case FILEXTN_EXE:
    case FILEXTN_OCX:
    case FILEXTN_DLL:
    case FILEXTN_NONE:
    case FILEXTN_UNKNOWN:

        MultiByteToWideChar(CP_ACP, 0, szURL, -1, szBuf,
            INTERNET_MAX_URL_LENGTH);

        // download the CODE=URL (ie. CAB or INF file first)
        pdlCur = new CDownload(szBuf, extn, &hr);

        if (!pdlCur){
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr))
            goto Exit;

        AddDownloadToList(pdlCur);

        // create a CSetup OBJ and add it to the CDownload obj
        pSetup = new CSetup(NULL, szCurCode, extn, szDestDir, &hr,dest);


        if(!pSetup) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        } else if (FAILED(hr)) {
            delete pSetup;
            goto Exit;
        }

        pSetup->SetCopyFlags (dwCopyFlags);

        if (dwRegisterServer) {
            pSetup->SetUserOverrideRegisterServer
                (dwRegisterServer&CST_FLAG_REGISTERSERVER);
        }

        pdlCur->AddSetupToList(pSetup);

        {
        BOOL bSetOnStack = SetOnStack();
        hr = (pcbhList == NULL) ? (pdlCur->DoDownload(&m_pmkContext,
                                                     (BINDF_ASYNCHRONOUS|
                                                     BINDF_ASYNCSTORAGE)))
                                : (pdlCur->DoDownload(&m_pmkContext,
                                                     (BINDF_ASYNCHRONOUS|
                                                     BINDF_ASYNCSTORAGE),
                                                     pcbhList));
        bDestroyList = FALSE;


        if (bSetOnStack)
            ResetOnStack();
        }

        if (FAILED(hr)) {
            goto Exit;
        }

    }

Exit:
    if (bDestroyList && pcbhList) {
        DestroyPCBHList(pcbhList);
        SAFEDELETE(pcbhList);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ProcessInf

/*
 *sample INF file:
;This is the INF file for CIRC3.OCX
[Add.Code]
circ3.ocx=circ3.ocx
random.dll=random.dll
mfc40.dll=mfc40.dll
foo.ocx=foo.ocx

[circ3.ocx]
file=http:\\ohserv\users\vatsanp\circ3.cab
clsid={9DBAFCCF-592F-101B-85CE-00608CEC297B}
FileVersion=1,0,0,143

[random.dll]
file=http://ohserv/users/vatsanp/random.dll
FileVersion=
;DestDir = 10 or 11 ( LDID_WIN or LDID_SYS by INF convention)
; if none specified installed in ocxcache directory, which is the typical case.
DestDir=10

[mfc40.dll]
; way of saying I need mfc40 (version 4,0,0,5) but, I can't provide it
; if absent on client fail load!
file=
FileVersion=4,0,0,5

[foo.ocx]
; way of saying I need foo (clsid, version 4,0,0,5) but, I can't provide it
; if absent on client fail load!
file=
clsid={DEADBEEF-592F-101B-85CE-00608CEC297B}
FileVersion=1,0,0,143

*/

//
//    We walk thru all the INF sections of code that needs to get installed.
//    For each we get the CLSID, FileVersion (both optional) and URL to get from
//  Depending on the extension of the URL we:
//
//    CAB:
//        if CAB is the one the INF came with
//            extract file; create CSetup to install it (piggy back to pdl)
//        else if some other CAB that has been set for download
//                attach file to be extracted to pFilesToExtract
//                attach a CSetup for this file
//        else
//            make a CDownload for this new CAB
//            attach file to be extracted to pFilesToExtract
//            attach a CSetup for this file
//            start off download
//    INF:
//        Fail: don't support multiple INFs
//
//    Anything else:
//        Make a new CDownload for this
//        start off download
//        make CSetup
//
// ---------------------------------------------------------------------------
VOID
CCodeDownload::ProcessInf(CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::ProcessInf",
                "this=%#x, %#x",
                this, pdl
                ));
                
    char szURL[INTERNET_MAX_URL_LENGTH];
    static char *szDefault = "";
    const static char *szHOOK = "Hook";
    char szCurCode[MAX_PATH];

    DWORD len = 0;
    FILEXTN extn;
    DESTINATION_DIR dest;

    DWORD dwFileVersionMS = 0;
    DWORD dwFileVersionLS = 0;
    CLSID clsid;
    LPCLSID lpclsid = &clsid;

    HRESULT hr = NO_ERROR;
    char * pFileName = NULL;

    DWORD dwRegisterServer = 0;
    DWORD dwCopyFlags = 0;
    BOOL  bForceDestDir = FALSE;

    CLocalComponentInfo lci;
    ICodeInstall* pCodeInstall = GetICodeInstall();


    if ( pdl->GetDLState() == DLSTATE_ABORT) {
        hr = E_ABORT;
        goto PI_Exit;           // all done
    }

    if (!m_pCurCode || !(*m_pCurCode)) {
        goto PI_Exit;           // all done
    }

    hr = GetInfSectionInfo( szCurCode, sizeof(szCurCode), szURL, &lpclsid,
        &dwFileVersionMS, &dwFileVersionLS, &dest, &dwRegisterServer, &dwCopyFlags,
        &bForceDestDir
        );

    if (hr != S_OK)
        goto PI_Exit;

    HRESULT    hrExact;
    HRESULT    hrAny;

    if (m_bExactVersion) {
        hrExact = IsControlLocallyInstalled(szCurCode,
                                            lpclsid, NULL,
                                            dwFileVersionMS, dwFileVersionLS,
                                            &lci, GetDestDirHint(),
                                            TRUE);
    }

    hrAny = IsControlLocallyInstalled(szCurCode,
                                      lpclsid, NULL,
                                      dwFileVersionMS, dwFileVersionLS,
                                      &lci, GetDestDirHint(),
                                      FALSE);

    if (m_bExactVersion && hrExact == S_FALSE && hrAny == S_OK) {

        // Newer version exists on the machine.
        // Check if we are going to install outside of DPF
        // and disallow if we are going to downgrade.

        BOOL bIsDPFComponent = FALSE;
        CHAR szOCXCacheDirSFN[MAX_PATH];
        CHAR szFNameSFN[MAX_PATH];

        GetShortPathName(lci.szExistingFileName, szFNameSFN, MAX_PATH);
        GetShortPathName(g_szOCXCacheDir, szOCXCacheDirSFN, MAX_PATH);

        if (StrStrI(szFNameSFN, szOCXCacheDirSFN)) {
            bIsDPFComponent = TRUE;
        }

        if (!bIsDPFComponent) {
            // Trying to downgrade a system component. Just pretend
            // system component is OK.
            if (lpclsid && IsEqualGUID(clsid, GetClsid())) {
                goto PI_Exit;
            }

            if (lci.szExistingFileName[0])
                hr= QueueModuleUsage(lci.szExistingFileName, MU_CLIENT);

            goto PI_Exit;
        }


    }
    // Else, we are a legacy case (non-sxs) or
    // hrExact == S_OK (therefore, hrAny == S_OK) or
    // hrAny == hrExact == S_FALSE (and we fall through).
    else {
        if (hrAny == S_OK) {

            // make sure we have a ref count for the code downloader in
            // shareddlls as well as mark us as a client in the usage section
            // we need to do this only for a dependency, not for the main
            // ocx. We can always get the main OCX back with CODEBASE. Its
            // only if the dependency gets removed are we somewhat busted.
            // Keep the registry small and simple.

            if (lpclsid && IsEqualGUID(clsid, GetClsid())) {
                goto PI_Exit;
            }

            if (lci.szExistingFileName[0])
                hr= QueueModuleUsage(lci.szExistingFileName, MU_CLIENT);

            goto PI_Exit;
        }

    }

    if (g_bNT5OrGreater && !(bForceDestDir && dest == LDID_OCXCACHE)) 
    {
        if (!FileProtectionCheckSucceeded(lci.szExistingFileName))
        {
            hr = INET_E_CANNOT_REPLACE_SFP_FILE;
            goto PI_Exit;
        }
    }

    if (szURL[0] == '\0') {

        // if not file/location is available then look to see if a
        // hook is available to download/install this component.

        if (GetPrivateProfileString(szCurCode, szHOOK, szDefault,
                                        szURL, MAX_PATH, m_szInf)) {

            hr = ProcessHookSection(szURL /* hook section */, pdl);
            goto PI_Exit;

        }

        // this is a way someone can say I need this file (clsid, version)
        // to run, if absent just fail the load!
        hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        goto PI_Exit;
    }

    if (lci.IsPresent() && pCodeInstall) {

        // a prev ver exists. get permission to overwrite
        // if ICodeInstall available
        WCHAR szBuf[MAX_PATH];

        MultiByteToWideChar(CP_ACP, 0,
            (lci.szExistingFileName[0])?lci.szExistingFileName:szCurCode, -1, szBuf, MAX_PATH);

        hr = pCodeInstall->OnCodeInstallProblem( CIP_OLDER_VERSION_EXISTS,
                    NULL, szBuf, 0);

        // hr == E_ABORT: abort whole download
        if (FAILED(hr)) {

            if (hr == E_ABORT)
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

            // else preserve error code of OnCodeInstallProblem

            goto PI_Exit;
        }

    }

    hr = StartDownload( szCurCode, pdl, szURL,
        dest, ((bForceDestDir) ? (NULL) : (lci.lpDestDir)), dwRegisterServer, dwCopyFlags);


PI_Exit:

    if (SUCCEEDED(hr)) {

        if (m_pCurCode)
            len = lstrlen(m_pCurCode);
        else
            len = 0;


        if (len) {

            m_pCurCode += (len+1); // next

            // skip side by side
            while (!StrCmpI(m_pCurCode, INF_TAG_UNINSTALL_OLD)) {
                len = lstrlen(m_pCurCode);
                m_pCurCode += (len+1);
            }

            if (*m_pCurCode) {

                CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_PROCESS_INF,
                    this, (DWORD_PTR)pdl);

                if (pPkt) {
                    hr = pPkt->Post();
                } else {
                    hr = E_OUTOFMEMORY;
                }

                if (SUCCEEDED(hr))
                    goto Exit;
            }

        }

        hr = ProcessHooks(pdl);

    }

    if (FAILED(hr)) {
        m_debuglog->DebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_PROCESSINF_FAILED,
                             hr, (m_pCurCode && *m_pCurCode)?m_pCurCode:"Setup Hooks");

        // done with this CDownload. Mark it ready for setup
        pdl->SetDLState(DLSTATE_DONE);

    } else {

        // done with this CDownload. Mark it ready for setup
        pdl->SetDLState(DLSTATE_READY_TO_SETUP);
    }


    pdl->CompleteSignal(hr, S_OK, S_OK, NULL);

Exit:

    DEBUG_LEAVE(0);
    return;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::QueueModuleUsage
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::QueueModuleUsage(
    LPCSTR szFileName,
    LONG muFlags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::QueueModuleUsage",
                "this=%#x, %.80q, %#x",
                this, szFileName, muFlags
                ));
                
    HRESULT hr = S_OK;

    CModuleUsage *pModuleUsage = new CModuleUsage(szFileName, muFlags, &hr);

    if (!pModuleUsage) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    } else if (FAILED(hr)) {
        delete pModuleUsage;
        goto Exit;
    }

    m_ModuleUsage.AddTail(pModuleUsage);

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::UpdateModuleUsage
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::UpdateModuleUsage()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::UpdateModuleUsage",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    char *lpClientName = NULL;
    LPOLESTR pwcsClsid = (LPOLESTR)GetMainDistUnit();
    LISTPOSITION curpos;
    int i, iNumClients;
    CLSID myclsid;

    Assert(pwcsClsid);

    if (FAILED((hr=::Unicode2Ansi(pwcsClsid, &lpClientName))))
    {
        goto Exit;
    }

    curpos = m_ModuleUsage.GetHeadPosition();
    iNumClients = m_ModuleUsage.GetCount();
    for (i=0; i < iNumClients; i++) {

        (m_ModuleUsage.GetNext(curpos))->Update(lpClientName);
    }


Exit:

    if (pwcsClsid && (pwcsClsid != GetMainDistUnit()) )
        delete pwcsClsid;

    if (lpClientName)
        delete lpClientName;

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ProcessHookSection
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::ProcessHookSection(LPCSTR lpCurHook, CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ProcessHookSection",
                "this=%#x, %.80q, %#x",
                this, lpCurHook, pdl
                ));
                
    HRESULT hr = S_OK;
    char szURL[INTERNET_MAX_URL_LENGTH];
    WCHAR szBuf[INTERNET_MAX_URL_LENGTH];
    char szCmdLine[1024];
    char szInfSection[MAX_PATH];
    const static char *szINFNAME = "InfFile";
    const static char *szINFSECTION = "InfSection";
    const static char *szCMDLINE = "Run";
    static char *szDefault = "";
    DWORD flags = 0;
    CDownload *pdlCur = pdl;
    char *pBaseFileName = NULL;

    // initialize szInfSection
    szInfSection[0] = '\0';    

    // Get cmd line for hook if any
    szCmdLine[0] = '\0';
    GetPrivateProfileString(lpCurHook, szCMDLINE, szDefault,
                                    szCmdLine, MAX_PATH, m_szInf);

    if (!szCmdLine[0]) {
        flags |= RSC_FLAG_INF;

        // Get Inf filename if any
        GetPrivateProfileString(lpCurHook, szINFNAME, szDefault,
                                    szCmdLine, MAX_PATH, m_szInf);

        // Get Inf section name if any
        GetPrivateProfileString(lpCurHook, szINFSECTION, szDefault,
                                        szInfSection, MAX_PATH, m_szInf);
    }

    hr = GetInfCodeLocation(lpCurHook, szURL);

    if (hr != S_OK)
        goto Exit;

    if (szURL[0]) {

        MultiByteToWideChar(CP_ACP, 0, szURL, -1, szBuf,
            INTERNET_MAX_URL_LENGTH);

        pdlCur = NULL;
        hr = FindCABInDownloadList(szBuf, pdl, &pdlCur);

        if (FAILED(hr))
            goto Exit;

        if (!pdlCur) {

            // did not find CAB
            // fresh CAB needs to get pulled down.

            FILEXTN extn = ::GetExtnAndBaseFileName(szURL, &pBaseFileName);

            if (extn != FILEXTN_CAB) {
                hr = E_INVALIDARG;
                goto Exit;
            }

            pdlCur = new CDownload(szBuf, extn, &hr);
            if (!pdlCur) {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
                goto Exit;


            AddDownloadToList(pdlCur);

            {
            BOOL bSetOnStack = SetOnStack();
            hr = pdlCur->DoDownload(&m_pmkContext,
                        (BINDF_ASYNCHRONOUS| BINDF_ASYNCSTORAGE));

            if (bSetOnStack)
                ResetOnStack();
            }

            if (FAILED(hr)) {
                goto Exit;
            }

        }
    }

    if ( !szCmdLine[0] )
        ::GetExtnAndBaseFileName(m_szInf, &pBaseFileName);

    Assert(pdlCur);

    hr = pdlCur->AddHook(lpCurHook, (szCmdLine[0])?szCmdLine:pBaseFileName,
        (szInfSection[0])?szInfSection:NULL,
        flags);

Exit:

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ProcessHooks
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::ProcessHooks(CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::ProcessHooks",
                "this=%#x, %#x",
                this, pdl
                ));
                
    HRESULT hr = S_OK;
    int nBuffSize = MAX_INF_SECTIONS_SIZE;
    char lpSections[MAX_INF_SECTIONS_SIZE];
    const static char *szHooksSection = "Setup Hooks";
    static char *szDefault = "";
    char *lpCurHook = NULL;
    DWORD len;

    len = GetPrivateProfileString(szHooksSection, NULL, szDefault,
                                                lpSections, nBuffSize, m_szInf);

    if (len) {

        for (lpCurHook =lpSections;*lpCurHook;
            lpCurHook+= (lstrlen(lpCurHook)+1)) {

            hr = ProcessHookSection(lpCurHook, pdl);

            if (FAILED(hr))
                break;
        }

    } else {
        hr = S_FALSE; // no hooks!
    }

    DEBUG_LEAVE(hr);
    return hr;

}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::Complete
// CCodeDownload::Complete is called whenever a CDownload obj completes
// its download and initiates further downloads if necessary (eg. ProcessInf)
// It does nothing until all pending downloads are complete. Until then it
// just returns and we unwind back to BSC::OnStopBinding
//
// When all downloads completed, we then start processingall the Csetups
// We do this code download in two stages to
// keep capability to back out of entire code download for as late as we can
// until the setup stage calling CClBinding::Abort with IBinding returned by
// code downloader in client's BSC::OnStartBinding will cleanly abort and
// restore initial state.
// We don't honor Abort once in setup stage.
//
// To keep this stage as clean and failsafe as we can we check for
// disk space in the OCX cache as well as check for IN USE OCXes that we
// plan on updating. We abort on either of these two conditions.
//
// CCodeDownload::Complete than proceeds to walk thru all its download objs
// calling DoSetup which in turn causes CSetup::DoSetup() to get invoked
// for every CSetup.
//
// ---------------------------------------------------------------------------
VOID
CCodeDownload::CompleteOne(CDownload *pdl, HRESULT hrOSB, HRESULT hrStatus, HRESULT hrResponseHdr, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::CompleteOne",
                "this=%#x, %#x, %#x, %#x, %#x, %.80wq",
                this, pdl, hrOSB, hrStatus, hrResponseHdr, szError
                ));
                
    CDownload *pdlCur = NULL;
    HRESULT hr = S_OK;
    HGLOBAL hPostData = NULL;
    WCHAR szURL[INTERNET_MAX_URL_LENGTH];
    FILEXTN extn = FILEXTN_UNKNOWN;
    LPWSTR lpDownloadURL;
    CDownload *pdlNew;
    DWORD cbPostData = 0;
    BOOL fWaitForAbortCompletion = FALSE;
    LISTPOSITION curpos;
    int i = 0;

    m_debuglog->DebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_COMPLETEONE_IN,
                         hrStatus, hrOSB, hrResponseHdr, pdl->GetURL());

    CUrlMkTls tls(hr); // hr passed by reference!
    Assert(SUCCEEDED(hr));

    if (pdl->GetDLState() != DLSTATE_READY_TO_SETUP) {

        pdl->SetDLState(DLSTATE_DONE);
    }

    if (FAILED(hr)) {
        goto Complete_failed;
    }

    Assert(tls->pCDLPacketMgr);

    // called each time a download object is done downloading
    // and installing itself
    // this is the master state analyser that will determine if the total
    // code download is complete and clean up if reqd

    Assert(m_pDownloads.GetCount());    // atleast one (this one)

    // the three HRESULTS passed in are as follows

    // hrOSB = hr of OnStopBinding, ie URLMON came back with good HR
    // but we had some 'processing error with the data we got back
    // in such cases just assume a bad install and fail the operation. ie.
    // don't go into next component of CodeSearchPath to retify such errors

    if (FAILED(hrOSB)) {
        hr = hrOSB;
        goto Complete_failed;
    }

    // hrStatus = hr that URLMON came back with for the binding
    // right now URLMON does a terrible job with errors. sometimes we get back
    // an HTML response with a displayable error and URLMON say things
    // succeeded, which is why we have our own hrResponseHdr which is the
    // status as we fill in OnResponse.

    // there are some URLMON errors that make sense to allow further search
    // on CodeSearchPath and some others like E_ABORT, ie the
    // client did an IBinding::Abort().

    if (SUCCEEDED(hrResponseHdr) && SUCCEEDED(hrStatus)) {
            // here if the current download was completely successful
            // if all downloads are done then call DoSetup()

            if (WeAreReadyToSetup()) {              // more processing left?
                                                    // no, enter setup phase

                CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_SETUP, this, 0);

                if (pPkt) {
                    hr = pPkt->Post();
                } else {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr)) {
                    goto Complete_failed;
                }


            }

            goto Exit;

    }

    if (hrStatus == E_ABORT) {
        // USER cancelled, abort entire code download
        hr = hrStatus;
        goto Complete_failed;
    }

    // here if the response header indicated a failure
    // errors we know about now are if the response URL is absent and no
    // suitable MIME tyoe was found or
    // the resource we queried for is absent on this server
    // try the next comp. on CodeSearchPath

    Assert(m_pmkContext);

    // if a top level req. failed wtih a HTTP error
    // we need to go next on searchpath.
    // we detect top level, either by the fact that it involed a POST
    // or by the fact that the context moniker is the same
    // moniker as the current download. By same moniker, we mean
    // the same pointer (not pmk->IsEqual(), this will match for
    // same URLs which is not necessarily top level)

    // This check makes an assumption that we will not change the
    // context moniker, excpet when redirecting a POST. if we do this is a
    // BUGBUG: !!!
    if (!(pdl->DoPost()) && (m_pmkContext != pdl->GetMoniker())) {
        if (FAILED(hrStatus))
            hr = hrStatus;
        else
            hr = hrResponseHdr;

        goto Complete_failed;
    }

    // reset the context to zero, so we will set a fresh one to the next
    // element on code searchpath
    if (RelContextMk()) {
        SAFERELEASE(m_pmkContext);
        ResetNewContextMoniker();
        DEBUG_PRINT(DOWNLOAD, 
                    INFO,
                    ("this=%#x, Releasing m_pmkContext: %#x\n",
                    this, m_pmkContext
                    ));
                    
    } else {
        m_pmkContext = NULL;
        DEBUG_PRINT(DOWNLOAD, 
                    INFO,
                    ("this=%#x, Setting m_pmkContext to NULL: %#x\n",
                    this, m_pmkContext
                    ));
    }

    // if the HTTP_ERROR was Not Modified, then this at the top level
    // is not an error: ie use current version. But, we any way go past
    // CODEBASE (that's the only one that can come back with Not Modified
    // everything else on the searchpath is a POST) to check all
    // servers on searchpath before we decide to use the current local version

    hr = GetNextOnInternetSearchPath(GetClsid(), &hPostData, &cbPostData,
                szURL, INTERNET_MAX_URL_LENGTH, &lpDownloadURL, &extn);

    if (FAILED(hr)) {

        // OK all tries failed at the top level
        // were we monkeying around for the very LATEST version
        // when in fact there was a local version already?
        if ( NeedLatestVersion() && m_plci->IsPresent()) {

                Assert(WeAreReadyToSetup());

                hr = S_OK;                        // no, fake a success
                SetFakeSuccess();
                CompleteAll(hr, NULL);            // and instantiate the object

                goto Exit;

        } else {
            goto Complete_failed;
        }
    }

    // download the CODE=URL (ie. CAB or INF file first)
    pdlNew = new CDownload(lpDownloadURL, extn, &hr);

    if (!pdlNew) {
        hr = E_OUTOFMEMORY;
        goto Complete_failed;
    } else if (FAILED(hr)) {
                delete pdlNew;
                goto Complete_failed;
            }

    AddDownloadToList(pdlNew);

    if (hPostData) {

        pdlNew->SetPostData(hPostData, cbPostData);
        hPostData = NULL; // mark as delegated, destructor for pdl will free
    }

    {
    BOOL bSetOnStack = SetOnStack();
    hr = pdlNew->DoDownload(&m_pmkContext,
                        (BINDF_ASYNCHRONOUS| BINDF_ASYNCSTORAGE));
    if (bSetOnStack)
        ResetOnStack();
    }

    if (SUCCEEDED(hr)) {
        // initiated a new download, return and wait for that to complete
        goto Exit;
    }

    // error initiating new download, abort


Complete_failed:

    Assert(FAILED(hr));

    if (SUCCEEDED(m_hr)) {

        // first failure in a multi-piece download
        // save away the real reason we failed. We pass this to
        // CompleteAll

        m_hr = hr;
    }

    // problem with download
    // abort all other downloads and then CompleteAll/cleanup

    // to mark that atleast one real URLMON bindign was aborted
    // in this case URLMON will post an OnStopBinding for that
    // and we will end up aborting all other bindings and the whole
    // code download. However if that's not the case then we were probably
    // in some post binding processing such as verifytrust cab extraction etc
    // and so we need to post a DoSetup() packet with UserCancelled flag set.

    fWaitForAbortCompletion = FALSE;


    curpos = m_pDownloads.GetHeadPosition();
    for (i=0; !IsOnStack() && ( i < m_pDownloads.GetCount()); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        if (!pdlCur->IsSignalled(this)) {

            // packet processing pending for this state. we will check for
            // DLSTATE_ABORT in each packet processing state and if true
            // it will call CompleteOne(us), which marks each piece DLSTATE_DONE

            BOOL bSetOnStack = SetOnStack();
            pdlCur->Abort(this);
            if (bSetOnStack)
                ResetOnStack();

            if (!pdlCur->IsSignalled(this)) {
                fWaitForAbortCompletion = TRUE;
            }

        }


    }

    if (FAILED(m_hr)) {
        // fail with first real failure of a multipart code download
        hr = m_hr;
    }

    if (!fWaitForAbortCompletion && !IsOnStack())       // more processing left?
        CompleteAll(hr, szError);       // no, call complete all to cleanup

Exit:

    DEBUG_LEAVE(0);
    return;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::WeAreReadyToSetup()
// ---------------------------------------------------------------------------
BOOL
CCodeDownload::WeAreReadyToSetup()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CCodeDownload::WeAreReadyToSetup",
                "this=%#x",
                this
                ));
                
    BOOL fReady = TRUE;
    CDownload *pdlCur = NULL;

    LISTPOSITION curpos = m_pDownloads.GetHeadPosition();
    for (int i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        if (! (( pdlCur->GetDLState() == DLSTATE_READY_TO_SETUP) ||
               ( pdlCur->GetDLState() == DLSTATE_DONE)) ) {

            fReady = FALSE;
            break;
        }
    }

    DEBUG_LEAVE(fReady);
    return fReady;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::ResolveCacheDirNameConflicts()
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::ResolveCacheDirNameConflicts()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CCodeDownload::ResolveCacheDirNameConflicts",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    char szDir[MAX_PATH];
    static char *szCONFLICT = "CONFLICT";
    CDownload *pdlCur = NULL;
    int n = 1;

    if (m_szCacheDir)       // the non-zeroness of this is also used by DoSetup
        goto Exit;          // to find it it's state machine has been init'ed

    // ease the update of in-memory OCXes that have been released
    // but still in memory as an optiization.
    CoFreeUnusedLibraries();

    // get a cache dir that has no name collisions for any of the
    // Csetup objs for this CodeDownload

    m_szCacheDir = g_szOCXCacheDir;

    do {

        LISTPOSITION curpos = m_pDownloads.GetHeadPosition();
        for (int i=0; i < m_pDownloads.GetCount(); i++) {

            pdlCur = m_pDownloads.GetNext(curpos);


            if ( (hr = pdlCur->CheckForNameCollision(m_szCacheDir)) != S_OK)
                break;
        }

        if (hr == S_OK) {

            if (m_szCacheDir == g_szOCXCacheDir)
                goto Exit;
            else
                goto Alloc_new;
        }

        // current m_szCacheDir did not work, try next conflict.<n> dir
        wnsprintf(szDir, sizeof(szDir)-1, "%s\\%s.%d", g_szOCXCacheDir, szCONFLICT, n++);

        m_szCacheDir = szDir;


    } while (GetFileAttributes(szDir) != -1); // while conflict dirs exist

    // none of our existing conflict dirs solved the problem
    // create a new conflict dir named conflict.<n>

    if (!CreateDirectory(szDir, NULL)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Alloc_new:

    m_szCacheDir = new char [lstrlen(szDir)+1];

    if (m_szCacheDir) {
        lstrcpy(m_szCacheDir, szDir);
    } else {
        hr = E_OUTOFMEMORY;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::DoSetup()
//        Setup Phase:
// ---------------------------------------------------------------------------
VOID
CCodeDownload::DoSetup()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::DoSetup",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    CDownload *pdlCur = NULL;
    int nSetupsPerCall = 0;
    HRESULT hr1 = S_OK;
    CUrlMkTls tls(hr1); // hr1 passed by reference!
    Assert(SUCCEEDED(hr1));
    Assert(tls->pCDLPacketMgr);
    int i;
    LISTPOSITION curpos;

    if (FAILED(m_hr)) {
        // the self-registering EXE failed or user cancelled waiting
        // for self-registering EXE
        hr = m_hr;
        goto ErrorExit;
    }

    if (UserCancelled()) {
        // user cancelled and CodeInstallProblem asked to abort
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        goto ErrorExit;
    }

    if (IsSilentMode()) {

        SetBitsInCache();   // flag that we have a new available version

        hr = ERROR_IO_INCOMPLETE;
        goto ErrorExit;
    }

    // ease the update of in-memory OCXes that have been released
    // but still in memory as an optiization.
    CoFreeUnusedLibraries();

    if (m_bUninstallOld) {
        LPSTR pPluginFileName = NULL;
        CLSID myclsid = GetClsid();
        CLocalComponentInfo lci;

        if ((SUCCEEDED(GetClsidFromExtOrMime( GetClsid(), myclsid,
            GetMainExt(), GetMainType(), &pPluginFileName)))) {

            if (IsControlLocallyInstalled(pPluginFileName,
                                          (pPluginFileName)?(LPCLSID)&GetClsid():&myclsid,
                                          GetMainDistUnit(), 0, 0, &lci, NULL) == S_OK) {
                HMODULE                   hMod;
                CHAR                     *szDU = NULL;
                REMOVECONTROLBYNAME pfn =  NULL;

                hMod = LoadLibrary("OCCACHE.DLL");
                if (hMod) {
                    pfn = (REMOVECONTROLBYNAME)GetProcAddress(hMod, "RemoveControlByName");
                    if (pfn) {
                        if (SUCCEEDED(Unicode2Ansi(GetMainDistUnit(), &szDU))) {
                            (*pfn)(lci.szExistingFileName, szDU, NULL, FALSE, TRUE);
                            SAFEDELETE(szDU);
                        }
                    }
                    FreeLibrary(hMod);
                }
            }
        }
    }

    hr = ResolveCacheDirNameConflicts();

    if (FAILED(hr)) {
        goto ErrorExit;
    }


    // -------- UNSAFE TO ABORT BEGIN --------------
    SetUnsafeToAbort();

    //  we can start processing CSetup
    curpos = m_pDownloads.GetHeadPosition();
    for (i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);


        if ( (pdlCur->GetDLState() == DLSTATE_READY_TO_SETUP) ||
            (pdlCur->GetDLState() == DLSTATE_SETUP)) {


            // serialize all setups in this thread
            hr = AcquireSetupCookie();
            if (FAILED(hr)) {
                goto ErrorExit;
            } else if (hr == S_FALSE) {

                goto Exit;     // some other Code download on same thread
                            // is already in Setup phase. We will get a
                            // msg when its our turn
            }

            // acquired the setup cookie!


            if (nSetupsPerCall++) {
                // here if we have already done 1 setup in one
                // CDownload

                // post a message to ourselves and we can do the next
                // setup in that. This will give a chance for our client
                // to process messages.

                CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_SETUP,this,S_OK);

                if (pPkt) {
                    hr = pPkt->Post();
                } else {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr))
                    break;

                goto Exit;
            }

            if (m_bExactVersion)
            {
                pdlCur->SetExactVersion(TRUE);
            }

            hr = pdlCur->DoSetup();

            if (FAILED(hr))
                break;



            if(WaitingForEXE()) { // Did the setup start a self-registering EXE?

                // if we are waiting for an EXE to complete self registeration,
                // we can't proceed unless it completes. So kick off a
                // packet for waiting for the EXE to complete.

                CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_WAIT_FOR_EXE,
                    this,0);

                if (pPkt) {
                    hr = pPkt->Post();
                } else {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr))
                    break;

                goto Exit;
            }


            if ( (pdlCur->GetDLState() == DLSTATE_READY_TO_SETUP) ||
                (pdlCur->GetDLState() == DLSTATE_SETUP)) {

                // more setup work left in pdlCur
                // wait to get to this and other pieces in next msg
                CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_SETUP,this,S_OK);

                if (pPkt) {
                    hr = pPkt->Post();
                } else {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr))
                    break;

                goto Exit;

            }

        } /* if pdlCur needs setup */

    } /* for each pdlCur */


ErrorExit:


    hr1 = tls->pCDLPacketMgr->AbortPackets(GetDownloadHead());//aborts pdlCur, pdlCur->pcdl

    Assert(SUCCEEDED(hr1));
    if (FAILED(hr1)) {
        hr = hr1;
    }

    // here when completed the setup phase
    // give up the cookie and let someone else thru.
    RelinquishSetupCookie();

    CompleteAll(hr, NULL);

Exit:

    DEBUG_LEAVE(0);
    return;
    // -------- NO ABORT TILL SETUP COMPLETES in COmpleteAll --------------

}

HRESULT CCodeDownload::UpdateJavaList(HKEY hkeyContains)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::UpdateJavaList",
                "this=%#x, %#x",
                this, hkeyContains
                ));
                
    HRESULT hr = S_OK;
    HKEY hkeyJava = 0;
    LPSTR lpVersion = "";
    CDownload *pdlCur = NULL;
    int iNumJava = 0;
    int i;
    const static char *szJAVA = "Java";
    LONG lResult = ERROR_SUCCESS;


    //  count total number of Java setups if any
    LISTPOSITION curpos = m_pDownloads.GetHeadPosition();
    for (i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        iNumJava += (pdlCur->GetJavaSetupList())->GetCount();
    }

    if (!iNumJava)
        goto Exit;


    // open/create the Contains\Java key for this dist unit.
    if (RegOpenKeyEx( hkeyContains, szJAVA,
            0, KEY_ALL_ACCESS, &hkeyJava) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyContains,
                   szJAVA, &hkeyJava)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    curpos = m_pDownloads.GetHeadPosition();
    for (i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        LISTPOSITION curJavapos = (pdlCur->GetJavaSetupList())->GetHeadPosition();
        iNumJava = (pdlCur->GetJavaSetupList())->GetCount();


        for (int j=0; j < iNumJava; j++) {

            CJavaSetup *pJavaSetup = (pdlCur->GetJavaSetupList())->GetNext(curJavapos);
            LPCWSTR szPkg = pJavaSetup->GetPackageName();
            LPCWSTR szNameSpace = pJavaSetup->GetNameSpace();
            char szPkgA[MAX_PATH];
            if (szPkg)
                WideCharToMultiByte(CP_ACP, 0, szPkg, -1, szPkgA,
                                MAX_PATH, NULL, NULL);
            char szNameSpaceA[MAX_PATH];
            if (szNameSpace)
                WideCharToMultiByte(CP_ACP, 0, szNameSpace, -1, szNameSpaceA,
                                MAX_PATH, NULL, NULL);

            if (szNameSpace == NULL) { // global namespace if not specified
                if ( (lResult = ::RegSetValueEx(hkeyJava, szPkgA, NULL, REG_SZ,
                        (unsigned char *)lpVersion, 1)) != ERROR_SUCCESS) {

                    hr = HRESULT_FROM_WIN32(lResult);
                    goto Exit;
                }
            } else {

                // specific namespace provided. create a key under java
                // for that namespace

                HKEY hkeyNameSpace = 0;
                // open/create the Contains\Java\<namespace> key
                if (RegOpenKeyEx( hkeyJava, szNameSpaceA,
                        0, KEY_ALL_ACCESS, &hkeyNameSpace) != ERROR_SUCCESS) {
                    if ((lResult = RegCreateKey( hkeyJava,
                               szNameSpaceA, &hkeyNameSpace)) != ERROR_SUCCESS){
                        hr = HRESULT_FROM_WIN32(lResult);
                        goto Exit;
                    }
                }
                if ((lResult=RegSetValueEx(hkeyNameSpace, szPkgA, NULL, REG_SZ,
                        (unsigned char *)lpVersion, 1)) != ERROR_SUCCESS) {

                    hr = HRESULT_FROM_WIN32(lResult);
                    goto Exit;
                }

                if (hkeyNameSpace)
                    RegCloseKey(hkeyNameSpace);

            }

        }

    }

Exit:

    SAFEREGCLOSEKEY(hkeyJava);

    DEBUG_LEAVE(hr);
    return hr;

}

HRESULT CCodeDownload::UpdateFileList(HKEY hkeyContains)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::UpdateFileList",
                "this=%#x, %#x",
                this, hkeyContains
                ));
                
    HRESULT hr = S_OK;
    HKEY hkeyFiles = 0;
    LPSTR lpVersion = "";
    LONG lResult = ERROR_SUCCESS;
    const static char * szFILES = "Files";
    int iNumFiles = m_ModuleUsage.GetCount();
    int i;
    LISTPOSITION curpos = m_ModuleUsage.GetHeadPosition();
    char szAnsiFileName[MAX_PATH];

    // open/create the Contains\Files key for this dist unit.
    if (RegOpenKeyEx( hkeyContains, szFILES,
            0, KEY_ALL_ACCESS, &hkeyFiles) != ERROR_SUCCESS) {
        if (iNumFiles && (lResult = RegCreateKey( hkeyContains,
                   szFILES, &hkeyFiles)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    if ( hkeyFiles) {

        int iValue = 0;
        DWORD dwType = REG_SZ;
        DWORD dwValueSize = MAX_PATH;
        char szFileName[MAX_PATH];

        while (RegEnumValue(hkeyFiles, iValue++,
            szFileName, &dwValueSize, 0, &dwType, NULL, NULL) == ERROR_SUCCESS) {

            dwValueSize = MAX_PATH; // reset

            if (GetFileAttributes(szFileName) == -1) {

                // if file is not physically present then clear out our
                // database. This is typically so, when you update
                // on older version with a newer version, but deleted the
                // old copy before installing the new one + changed the file
                // names or location.


                iValue = 0;
                RegDeleteValue(hkeyFiles, szFileName);
            }
        }
    }

    for (i=0; i < iNumFiles; i++) {

        LPCSTR szFileName = (m_ModuleUsage.GetNext(curpos))->GetFileName();

        char szShortFileName[MAX_PATH];
#ifdef SHORTEN
        if (!GetShortPathName(szFileName, szShortFileName, MAX_PATH)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
#else
        StrNCpy(szShortFileName, szFileName, MAX_PATH);
#endif

        // Under Win95 (and ONLY Win95), Setup API will convert characters
        // from the OEM code page to the ANSI code page. The codebase we have
        // is in the OEM codepage. After the Setup API installed the file,
        // the installed file name is in ANSI. Therefore, in the enumeration,
        // we need to look for the ANSI file name. Under other platforms,
        // this just works, and converting to the ANSI code page should not
        // be done. See IE5 RAID #34606 for more details.

        if (g_bRunOnWin95) {
            OemToCharBuff(szShortFileName, szAnsiFileName, sizeof(szAnsiFileName) / sizeof(szAnsiFileName[0]));
            StrNCpy(szShortFileName, szAnsiFileName, MAX_PATH);
        }

        if ( (lResult = ::RegSetValueEx(hkeyFiles, szShortFileName, NULL, REG_SZ,
                    (unsigned char *)lpVersion, 1)) != ERROR_SUCCESS) {

            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

    }

Exit:
    SAFEREGCLOSEKEY(hkeyFiles);

    DEBUG_LEAVE(hr);
    return hr;

}

HRESULT CCodeDownload::UpdateDependencyList(HKEY hkeyContains)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::UpdateDependencyList",
                "this=%#x, %#x",
                this, hkeyContains
                ));
                
    HRESULT hr = S_OK;
    HKEY hkeyDU = 0;
    LPSTR lpVersion = "";
    LONG lResult = ERROR_SUCCESS;
    const static char * szDU = "Distribution Units";
    int iNumFiles;
    int i;
    LISTPOSITION curpos;
    BOOL fFirstDependency = TRUE;
    LPWSTR wszDistUnit = NULL;
    LPSTR szDistUnit = NULL;

    iNumFiles = m_pDownloads.GetCount();
    curpos = m_pDownloads.GetHeadPosition();

    RegDeleteKey(hkeyContains, szDU);   // delete old version dependencies

    for (i=0; i < iNumFiles; i++) {

        CDownload *pdl = m_pDownloads.GetNext(curpos);

        if (pdl->UsingCdlProtocol() && pdl->GetDLState() == DLSTATE_DONE) {

            AddDistUnitList(pdl->GetDistUnitName());

        }

    }

    iNumFiles = m_pDependencies.GetCount();
    curpos = m_pDependencies.GetHeadPosition();

    if (!iNumFiles)
        goto Exit;

    for (i=0; i < iNumFiles; i++) {

        wszDistUnit = m_pDependencies.GetNext(curpos);

        if (wszDistUnit) {

            SAFEDELETE(szDistUnit);

            if (FAILED(Unicode2Ansi(wszDistUnit, &szDistUnit))) {
                hr = S_OK;
                goto Exit;
            }

            if (fFirstDependency) {

                if ((lResult = RegCreateKey( hkeyContains,
                       szDU, &hkeyDU)) != ERROR_SUCCESS) {
                    hr = HRESULT_FROM_WIN32(lResult);
                    goto Exit;
                }
                fFirstDependency = FALSE;
            }

            if ( (lResult = ::RegSetValueEx(hkeyDU, szDistUnit, NULL, REG_SZ,
                    (unsigned char *)lpVersion, 1)) != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(lResult);
                goto Exit;
            }

        }

    }


Exit:
    SAFEREGCLOSEKEY(hkeyDU);
    SAFEDELETE(szDistUnit);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::UpdateLanguageCheck()
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::UpdateLanguageCheck(CLocalComponentInfo *plci)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::UpdateLanguageCheck",
                "this=%#x, %#x",
                this, plci
                ));
                
    HRESULT hr = S_OK;
    BOOL bNullClsid = IsEqualGUID(GetClsid() , CLSID_NULL);
    HKEY hkeyCheckPeriod = 0;
    HKEY hkeyClsid = 0;
    HKEY hkeyEmbedding = 0;
    LPOLESTR pwcsClsid = NULL;
    DWORD dwType;
    LONG lResult = ERROR_SUCCESS;
    LPSTR pszClsid = NULL;
    FILETIME ftnow;
    SYSTEMTIME st;
    const char *szCHECKPERIOD = "LanguageCheckPeriod";
    const char *szLASTCHECKEDHI = "LastCheckedHi";

    if (bNullClsid)
        goto Exit;

    // return if we can't get a valid string representation of the CLSID
    if (FAILED((hr=StringFromCLSID(GetClsid(), &pwcsClsid))))
        goto Exit;

    Assert(pwcsClsid != NULL);

    // Open root HKEY_CLASSES_ROOT\CLSID key
    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ, &hkeyClsid);


    if (lResult == ERROR_SUCCESS)
    {
        if (FAILED((hr=::Unicode2Ansi(pwcsClsid, &pszClsid))))
        {
            goto Exit;
        }

        // Open the key for this embedding:
        lResult = ::RegOpenKeyEx(hkeyClsid, pszClsid, 0, KEY_ALL_ACCESS,
                        &hkeyEmbedding);

        if (lResult == ERROR_SUCCESS) {

            if ((lResult = RegOpenKeyEx( hkeyEmbedding, szCHECKPERIOD,
                    0, KEY_ALL_ACCESS, &hkeyCheckPeriod)) != ERROR_SUCCESS) {

                if ((lResult = RegCreateKey( hkeyEmbedding,
                           szCHECKPERIOD, &hkeyCheckPeriod)) != ERROR_SUCCESS) {
                    hr = HRESULT_FROM_WIN32(lResult);
                    goto Exit;
                }

            }

            GetSystemTime(&st);
            SystemTimeToFileTime(&st, &ftnow);

            RegSetValueEx(hkeyCheckPeriod, szLASTCHECKEDHI, NULL, REG_DWORD,
               (unsigned char *)&ftnow.dwHighDateTime, sizeof(DWORD));
        }
    }

Exit:
    SAFEDELETE(pwcsClsid);
    SAFEDELETE (pszClsid);

    SAFEREGCLOSEKEY (hkeyClsid);
    SAFEREGCLOSEKEY (hkeyEmbedding);
    SAFEREGCLOSEKEY (hkeyCheckPeriod);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::UpdateDistUnit()
//        Add proper entries to the registry and register control to
//        WebCheck so that control gets updated periodically.
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::UpdateDistUnit(CLocalComponentInfo *plci)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::UpdateDistUnit",
                "this=%#x, %#x",
                this, plci
                ));
                
    HRESULT hr = S_OK;
    LONG lResult = ERROR_SUCCESS;
    HKEY hkeyDist =0;
    HKEY hkeyThisDist = 0;
    HKEY hkeyDownloadInfo = 0;
    HKEY hkeyContains = 0;
    HKEY hkeyVersion = 0;
    const static char * szInstalledVersion = "InstalledVersion";
    const static char * szAvailableVersion = "AvailableVersion";
    const static char * szDownloadInfo = "DownloadInformation";
    const static char * szCODEBASE = "CODEBASE";
    const static char * szContains = "Contains";
    const static char * szLOCALINF = "INF";
    const static char * szLOCALOSD = "OSD";
    const static char * szLASTMODIFIED = "LastModified";
    const static char * szETAG = "Etag";
    const static char * szINSTALLER = "Installer";
    const static char * szExpire = "Expire";
    const static char * szMSICD = "MSICD";
    const static char * szPrecache = "Precache";
    const static char * szSYSTEM = "SystemComponent";
    LPSTR pszDist = NULL;
    LPSTR pszURL = NULL;
    LPWSTR pwszURL = NULL;
    char szVersionBuf[MAX_PATH];
    DWORD dwExpire;

    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS,
                        0, KEY_ALL_ACCESS, &hkeyDist)) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_DIST_UNITS, &hkeyDist)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }

    if (FAILED((hr=::Unicode2Ansi(m_szDistUnit, &pszDist))))
    {
        goto Exit;
    }


    if(GetContextMoniker()) {

        if (SUCCEEDED(hr = GetContextMoniker()->GetDisplayName(NULL, NULL, &pwszURL))) {

            hr = Unicode2Ansi( pwszURL, &pszURL);
        }

        if (FAILED(hr)) {
            goto Exit;
        }
    }

    // open/create the dist unit key for this dist unit.
    if (RegOpenKeyEx( hkeyDist, pszDist,
            0, KEY_ALL_ACCESS, &hkeyThisDist) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyDist,
                   pszDist, &hkeyThisDist)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    if (m_szDisplayName &&
        ((lResult = ::RegSetValueEx(hkeyThisDist, NULL, NULL, REG_SZ,
                (unsigned char *)m_szDisplayName,
                lstrlen(m_szDisplayName)+1)) != ERROR_SUCCESS)){

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    lResult = ::RegSetValueEx(hkeyThisDist, szSYSTEM, NULL, REG_DWORD,
                              (unsigned char *)&m_dwSystemComponent,
                              sizeof(DWORD));
    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    lResult = ::RegSetValueEx(hkeyThisDist, szINSTALLER, NULL, REG_SZ,
                        (unsigned char *)szMSICD, sizeof(szMSICD)+1);

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    // if the OSD told us an expire interval, or the PE specifies it.
    if ( m_dwExpire != 0xFFFFFFFF ||
         (plci->szExistingFileName[0] &&
          WantsAutoExpire( plci->szExistingFileName, &m_dwExpire )) ) {

        lResult = ::RegSetValueEx(hkeyThisDist, szExpire, NULL, REG_DWORD,
                                  (unsigned char *)&m_dwExpire, sizeof(DWORD));

        if (lResult != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }



    // open/create the download info key for this dist unit.
    if (RegOpenKeyEx( hkeyThisDist, szDownloadInfo,
            0, KEY_ALL_ACCESS, &hkeyDownloadInfo) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyThisDist,
                   szDownloadInfo, &hkeyDownloadInfo)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    // set download info params

    if (pszURL && (lResult = ::RegSetValueEx(hkeyDownloadInfo, szCODEBASE,
        NULL, REG_SZ, (unsigned char *)pszURL, lstrlen(pszURL)+1)) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (!BitsInCache()) {

        char szOldManifest[MAX_PATH];
        DWORD Size = MAX_PATH;
        DWORD dwType;
        DWORD lResult = ::RegQueryValueEx(hkeyDownloadInfo, szLOCALINF, NULL, &dwType,
                            (unsigned char *)szOldManifest, &Size);

        if (lResult == ERROR_SUCCESS) {

            if (!(GetMainInf() && (lstrcmpi(GetMainInf(), szOldManifest) == 0)) ) {

                // there is an old entry, clean up the entry and also the file
                // before upgrading to newer version

                DeleteFile(szOldManifest);
                if (!GetMainInf())
                    RegDeleteValue(hkeyDownloadInfo, szLOCALINF);
            }

        }

        Size = MAX_PATH;
        lResult = ::RegQueryValueEx(hkeyDownloadInfo, szLOCALOSD, NULL, &dwType,
                            (unsigned char *)szOldManifest, &Size);

        if (lResult == ERROR_SUCCESS) {

            if (!(GetOSD() && (lstrcmpi(GetOSD(), szOldManifest) == 0)) ) {

                // there is an old entry, clean up the entry and also the file
                // before upgrading to newer version

                DeleteFile(szOldManifest);
                if (!GetOSD())
                    RegDeleteValue(hkeyDownloadInfo, szLOCALOSD);
            }

        }



        if (GetOSD() &&  (lResult = ::RegSetValueEx(hkeyDownloadInfo,
            szLOCALOSD, NULL, REG_SZ, (unsigned char *)GetOSD(), lstrlen(GetOSD())+1)) != ERROR_SUCCESS) {

            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        if (GetMainInf() && (lResult = ::RegSetValueEx(hkeyDownloadInfo,
            szLOCALINF, NULL, REG_SZ, (unsigned char *)GetMainInf(), lstrlen(GetMainInf())+1)) != ERROR_SUCCESS) {

            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

    }

    // end set download info params

    if (!VersionFromManifest(szVersionBuf, sizeof(szVersionBuf))) {

        if (!BitsInCache()) {
            if (!plci->IsPresent()) {
                // This used to be an E_UNEXPECTED case. Still unexpected,
                // but we'll trace it and cope with it.
                m_debuglog->DebugOut(DEB_CODEDL, FALSE,
                                     ID_CDLDBG_DL_UPDATE_DU_NO_VERS,
                                     plci->szExistingFileName);
                plci->dwLocFVLS = 1;
            }

            wsprintf(szVersionBuf, "%d,%d,%d,%d",
                    (plci->dwLocFVMS & 0xffff0000)>>16,
                    (plci->dwLocFVMS & 0xffff),
                    (plci->dwLocFVLS & 0xffff0000)>>16,
                    (plci->dwLocFVLS & 0xffff));
        } else {
            // use the version number in the HTML or
            // the one called by the code download delivery agent
            // if present

            if (m_dwFileVersionMS | m_dwFileVersionLS) {

                wsprintf(szVersionBuf, "%d,%d,%d,%d",
                    (m_dwFileVersionMS & 0xffff0000)>>16,
                    (m_dwFileVersionMS & 0xffff),
                    (m_dwFileVersionLS & 0xffff0000)>>16,
                    (m_dwFileVersionLS & 0xffff));

            } else {
                lstrcpy(szVersionBuf, "-1,-1,-1,-1");
            }
        }
    }

    if (BitsInCache()) {

        if (RegOpenKeyEx( hkeyThisDist, szAvailableVersion,
                0, KEY_ALL_ACCESS, &hkeyVersion) != ERROR_SUCCESS) {
            if ((lResult = RegCreateKey( hkeyThisDist,
                       szAvailableVersion, &hkeyVersion)) != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(lResult);
                goto Exit;
                }
        }

        // record result of caching bits.

        HRESULT hrRecord = m_hr;

        if (m_hr == TRUST_E_FAIL ||
            m_hr == TRUST_E_SUBJECT_NOT_TRUSTED)
        {
            hrRecord = ERROR_IO_INCOMPLETE;
        }

        lResult = ::RegSetValueEx(hkeyVersion, szPrecache, NULL, REG_DWORD,
                            (unsigned char *)&hrRecord, sizeof(DWORD));
        if (lResult != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

    } else {

        if (RegOpenKeyEx( hkeyThisDist, szInstalledVersion,
                0, KEY_ALL_ACCESS, &hkeyVersion) != ERROR_SUCCESS) {
            if ((lResult = RegCreateKey( hkeyThisDist,
                       szInstalledVersion, &hkeyVersion)) != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(lResult);
                goto Exit;
                }
        }

        // when we install a real version take out the
        // AvailableVersion key if one exists

        RegDeleteKey(hkeyThisDist, szAvailableVersion);
    }

    lResult = ::RegSetValueEx(hkeyVersion, NULL, NULL, REG_SZ,
                        (unsigned char *)szVersionBuf, lstrlen(szVersionBuf)+1);

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (BitsInCache()) {   // in silent mode the control is not
                            // installed and so the below params to
                            // the dist unit are not relevant.
        goto Exit;
    }

    if (GetLastMod() && (lResult = ::RegSetValueEx(hkeyVersion,
        szLASTMODIFIED, NULL, REG_SZ, (unsigned char *)GetLastMod(), lstrlen(GetLastMod())+1)) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (GetEtag() && (lResult = ::RegSetValueEx(hkeyVersion,
        szETAG, NULL, REG_SZ, (unsigned char *)GetEtag(), lstrlen(GetEtag())+1)) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    // store dist unit dependencies
    // store the dist unit files, pkgs installed
    // save away the manifest location/name


    // open/create the Contains key for this dist unit.
    if (RegOpenKeyEx( hkeyThisDist, szContains,
            0, KEY_ALL_ACCESS, &hkeyContains) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyThisDist,
                   szContains, &hkeyContains)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    hr = UpdateFileList(hkeyContains);

    if (SUCCEEDED(hr))
        hr = UpdateDependencyList(hkeyContains);

    if (SUCCEEDED(hr))
        hr = UpdateJavaList(hkeyContains);


Exit:
    SAFEDELETE(pszDist);
    SAFEDELETE(pszURL);
    SAFEDELETE(pwszURL);

    SAFEREGCLOSEKEY(hkeyContains);
    SAFEREGCLOSEKEY(hkeyDownloadInfo);
    SAFEREGCLOSEKEY(hkeyVersion);
    SAFEREGCLOSEKEY(hkeyDist);
    SAFEREGCLOSEKEY(hkeyThisDist);

    DEBUG_LEAVE(hr);
    return hr;
}

typedef BOOL (WINAPI *SHRESTARTDIALOG)( HWND, LPTSTR, DWORD );

HRESULT DoReboot(HWND hWndParent)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "DoReboot",
                "%#x",
                hWndParent
                ));
                
    HRESULT hr = S_OK;
    HINSTANCE    hShell32Lib;

#define SHRESTARTDIALOG_ORDINAL    59       // restart only exported by ordinal

    SHRESTARTDIALOG          pfSHRESTARTDIALOG = NULL;

    if ( ( hShell32Lib = LoadLibrary( "shell32.dll" ) ) != NULL )  {

        if ( !( pfSHRESTARTDIALOG = (SHRESTARTDIALOG)
                      GetProcAddress( hShell32Lib, MAKEINTRESOURCE(SHRESTARTDIALOG_ORDINAL)) ) ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        } else {
            pfSHRESTARTDIALOG(hWndParent, NULL, EWX_REBOOT);
        }

    } else  {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (hShell32Lib)
        FreeLibrary( hShell32Lib );

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::CompleteAll(HRESULT hr, LPCWSTR szError)
//        All code is installed. If code install was succesful instantiate
//        object if reqd, and report ClientBSC::OnStopBinding.
// ---------------------------------------------------------------------------
VOID
CCodeDownload::CompleteAll(HRESULT hr, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::CompleteAll",
                "this=%#x, %#x, %.80wq",
                this, hr, szError
                ));
                
    char szCacheFileName[MAX_PATH];
    HRESULT hrTls = S_OK;
    LISTPOSITION curpos;
    int iNumClients;
    int i;
//  TCHAR szBuffer[MAX_FORMAT_MESSAGE_BUFFER_LEN];
    LPTSTR szBuffer = NULL;
    DWORD dwFMResult = 0;
    BOOL bForceWriteLog = FALSE;
    TCHAR szDll[MAX_PATH];
    BOOL            bLogGenOk = FALSE;
    OSVERSIONINFO   osvi;
    WCHAR          *pwszOSBErrMsg = NULL;
    char           *pszExactErrMsg = NULL;
    char            szDPFPath[MAX_PATH];


    Assert(GetState() != CDL_Completed);
    SetState(CDL_Completed);

    CUrlMkTls tls(hrTls); // hr passed by reference!
    if (FAILED(hrTls)) {
        hr = hrTls;
    }

    // get the installed version one more time
    // to store in the dist unit db
    CLocalComponentInfo lci;

    LPSTR pPluginFileName = NULL;
    CLSID myclsid = GetClsid();

    if ((SUCCEEDED(GetClsidFromExtOrMime( GetClsid(), myclsid,
        GetMainExt(), GetMainType(), &pPluginFileName)))) {

        // get current version, pass 0, 1 to goose IsControl
        // into filling in the version data, otherwise UpdateDistUnit
        // will put a funny version in the registry ( which is better
        // than bug 12081

        //BUGBUG: make sure this call does the right things with zero impact

        IsControlLocallyInstalled(pPluginFileName,
                (pPluginFileName)?(LPCLSID)&GetClsid():&myclsid, GetMainDistUnit(),
                0, 1, &lci, NULL);


    }

    if ( m_plci->bForceLangGetLatest ||
         (lci.bForceLangGetLatest && SUCCEEDED(hr)) ) {
        hr = UpdateLanguageCheck(&lci);
    }

    if (SUCCEEDED(hr) && hr != ERROR_IO_INCOMPLETE) 
    {

        // update all the queued up ModuleUsage records
        // we need to also remap to get the main clsid
        // incase we didn't have one to begin with

        UpdateModuleUsage();

    }

    if ( !FakeSuccess() && (SUCCEEDED(hr) || BitsInCache())) {
        UpdateDistUnit(&lci);
    }

    if (NeedToReboot()) {
        HWND hWnd = GetClientBinding()->GetHWND();

        // pass a notification to reboot
        if (hWnd != INVALID_HANDLE_VALUE) {
            // g_RunSetupHook.DoReboot(hWnd, TRUE);
            DoReboot(hWnd);

        } else {

            ICodeInstall* pCodeInstall = GetICodeInstall();
            if (pCodeInstall)
                pCodeInstall->OnCodeInstallProblem( CIP_NEED_REBOOT, NULL, NULL, 0);
       }
    }

    iNumClients = m_pClientbinding.GetCount();

    // if called from CoGetClassFromURL we need to report
    // ClientBSC::OnObjectAvailable with requested obj
    if (SUCCEEDED(hr) && NeedObject() && hr != ERROR_IO_INCOMPLETE) {

        curpos = m_pClientbinding.GetHeadPosition();
        for (i=0; i < iNumClients; i++) {

            hr = (m_pClientbinding.GetNext(curpos))->InstantiateObjectAndReport(this);

            if(FAILED(hr)) {
                bLogGenOk = GenerateErrStrings(hr, &pszExactErrMsg, &pwszOSBErrMsg);
                if (!bLogGenOk) {
                    pwszOSBErrMsg = NULL;
                    pszExactErrMsg = NULL;
                }
            }
        }

    } else {
        // call OnStopBinding for all BSCs (since we either do not need
        // an instantiated object or we don't have one to give)

        if(FAILED(hr)) {
            bLogGenOk = GenerateErrStrings(hr, &pszExactErrMsg, &pwszOSBErrMsg);
            if (!bLogGenOk) {
                pwszOSBErrMsg = NULL;
                pszExactErrMsg = NULL;
            }
        }

        // call client's onstopbinding
        curpos = m_pClientbinding.GetHeadPosition();
        for (i=0; i < iNumClients; i++) {
            ((m_pClientbinding.GetNext(curpos))->GetAssBSC())->
                OnStopBinding(hr, pwszOSBErrMsg);
        }
        SAFEDELETE(pwszOSBErrMsg);

        m_debuglog->DebugOut(DEB_CODEDL, hr != S_OK, ID_CDLDBG_ONSTOPBINDING_CALLED,
                             hr, (hr == S_OK)?TEXT(" (SUCCESS)"):TEXT(" (FAILED)"),
                             (GetClsid()).Data1, GetMainURL(), GetMainType(),
                             GetMainExt());
    }

    if (m_hKeySearchPath) {
        if (RegQueryValueEx(m_hKeySearchPath,"ForceCodeDownloadLog", NULL, NULL,
            NULL, NULL) == ERROR_SUCCESS)
             bForceWriteLog = TRUE;
    }

    if (bForceWriteLog || (hr != S_OK && hr != ERROR_IO_INCOMPLETE)) {
        // BUGBUG: move these into .rc
        if (!bLogGenOk && (HRESULT_FACILITY(hr) == FACILITY_CERT)) {
            DumpDebugLog(szCacheFileName, "Trust verification failed!!", hr);
        } else if (!bLogGenOk &&
                    (hr==HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH))) {
            DumpDebugLog(szCacheFileName,
                "Incompatible Binary for your platform", hr);
        } else if (bLogGenOk) {
            DumpDebugLog(szCacheFileName, pszExactErrMsg, hr);
        } else {
            DumpDebugLog(szCacheFileName, "Unknown Error!!", hr);
        }

    }

    // Refresh OCCACHE

    // Only do this for NT for now. For some reason under Win95, sending
    // this message here will cause a crash in SHELL32.DLL.

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && m_szCacheDir) {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_szCacheDir, 0);
    }

    // free all memory and clean up temp files

    SAFEDELETE(pszExactErrMsg);

    Release();

    DEBUG_LEAVE(0);
    return;
    // -------- END OF UNSAFE TO ABORT --------------
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GenerateErrStrings()
//    Parameters:
//        ppszErrMsg: Saved error message or result of FormatMessage
//        pwszError: Error message to pass back as szError in OSB
//        hr: HRESULT of binding operation
//    Returns:
//        TRUE if successful
// ---------------------------------------------------------------------------

BOOL CCodeDownload::GenerateErrStrings(HRESULT hr, char **ppszErrMsg,
                                       WCHAR **ppwszError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CCodeDownload::GenerateErrStrings",
                "this=%#x, %#x, %#x, %#x",
                this, hr, ppszErrMsg, ppwszError
                ));
                
    DWORD                  dwFMResult;
    LPCTSTR                pszSavedErrMsg = NULL;
    TCHAR                 *szBuf = NULL;
    char                  *szURL = NULL;
    char                  *pszErrorMessage = NULL;
    char                   szErrString[MAX_DEBUG_STRING_LENGTH];
    char                   szDetails[MAX_DEBUG_STRING_LENGTH];
    int                    iSize = 0;

    if (!ppszErrMsg || !ppwszError) {
        dwFMResult = FALSE;
        goto Exit;
    }

    // Get a saved error message if available

    dwFMResult = FALSE;
    pszSavedErrMsg = CDLDebugLog::GetSavedMessage();

    if (pszSavedErrMsg[0] != '\0') {

        *ppszErrMsg = new char[lstrlen(pszSavedErrMsg) + 1];
        if (!*ppszErrMsg) {
            dwFMResult = FALSE;
            goto Exit;
        }

        lstrcpy(*ppszErrMsg, pszSavedErrMsg);
        dwFMResult = TRUE;
    }

    if (!dwFMResult) {

        // We don't have a saved message we can use. Try calling
        // FormatMessage().

        if (!dwFMResult) {
            dwFMResult = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                       FORMAT_MESSAGE_FROM_SYSTEM, 0, hr, 0,
                                       (LPTSTR)&szBuf,
                                       0, NULL);
        }

        if (!dwFMResult) {
            dwFMResult = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                       FORMAT_MESSAGE_FROM_HMODULE, g_hInst,
                                       hr, 0, (LPTSTR)&szBuf, 0, NULL);
        }

        if (dwFMResult) {

            ASSERT(szBuf);
            ASSERT(lstrlen(szBuf));

            *ppszErrMsg = new char[lstrlen(szBuf) + 1];
            if (!*ppszErrMsg) {
                dwFMResult = FALSE;
                goto Exit;
            }

            lstrcpy(*ppszErrMsg, szBuf);
            LocalFree(szBuf);
        }
        else {
            char szUnknown[MAX_DEBUG_FORMAT_STRING_LENGTH];

            if (!dwFMResult && HRESULT_FACILITY(hr) == FACILITY_SETUPAPI) {
                LoadString(g_hInst, ID_CDLDBG_UNKNOWN_SETUP_ERROR, szUnknown,
                           MAX_DEBUG_FORMAT_STRING_LENGTH);
            }
            else {
                LoadString(g_hInst, ID_CDLDBG_UNKNOWN_ERROR, szUnknown,
                           MAX_DEBUG_FORMAT_STRING_LENGTH);
            }

            *ppszErrMsg = new char[lstrlen(szUnknown) + 1];
            if (!*ppszErrMsg) {
                dwFMResult = FALSE;
                goto Exit;
            }

            lstrcpy(*ppszErrMsg, szUnknown);
        }
    }

    // ppszErrMsg now holds saved error message or whatever came back from
    // FormatMessage(). Construct a complete error message.

    m_debuglog->MakeFile();

    LoadString(g_hInst, ID_CDLDBG_ERROR_STRING, szErrString, MAX_DEBUG_STRING_LENGTH);
    LoadString(g_hInst, ID_CDLDBG_DETAILS_STRING, szDetails, MAX_DEBUG_STRING_LENGTH);

    szURL = (char *)m_debuglog->GetUrlName();
    ASSERT(szURL[0] != '\0');

    iSize = lstrlen(*ppszErrMsg) + lstrlen(szErrString) + lstrlen(szDetails)
            + lstrlen(szURL) + 1;

    pszErrorMessage = new char[iSize];
    if (!pszErrorMessage) {
        dwFMResult = FALSE;
        goto Exit;
    }

    wnsprintfA(pszErrorMessage, ID_CDLDBG_UNKNOWN_ERROR, "%s%s%s%s"
                              , szErrString, *ppszErrMsg, szDetails, szURL);

    if (FAILED(Ansi2Unicode(pszErrorMessage, ppwszError))) {
        dwFMResult = FALSE;
        goto Exit;
    }

Exit:

    SAFEDELETE(pszErrorMessage);

    DEBUG_LEAVE((dwFMResult != 0));
    return (dwFMResult != 0);
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::DumpDebugLog()
//   Output the debug error log. This log is written as a cache entry.
// ---------------------------------------------------------------------------

void CCodeDownload::DumpDebugLog(char *szCacheFileName, LPTSTR szErrorMsg,
                                 HRESULT hrError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::DumpDebugLog",
                "this=%#x, %.80q, %#x, %#x",
                this, szCacheFileName, szErrorMsg, hrError
                ));
                
    m_debuglog->DumpDebugLog(szCacheFileName, MAX_PATH,
                          szErrorMsg, hrError);

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CCodeDownload::AddRef()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CCodeDownload::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = m_cRef++;

    DEBUG_LEAVE(ulRet);
    return ulRet;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::Release
//        Clean up all temp files and free all memory
//        Caller of this function cannot rely on accessing any data
//        other than locals on their stack.
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CCodeDownload::Release()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CCodeDownload::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    CDownload *pdlCur;
    HRESULT hr = S_OK;

    Assert(m_cRef > 0);

    if (--m_cRef != 0) {

        DEBUG_LEAVE(m_cRef);
        return m_cRef;
    }

    // release all CDownload objs

    LISTPOSITION curpos = m_pDownloads.GetHeadPosition();
    for (int i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);

        pdlCur->ReleaseParent(this);
    }

    CUrlMkTls tls(hr); // hr passed by reference!

    Assert(SUCCEEDED(hr));

    // remove this CCodeDownload from the per-thread list
    if (m_ListCookie)
        tls->pCodeDownloadList->RemoveAt(m_ListCookie);

    delete this;

    DEBUG_LEAVE(0);
    return 0;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::AcquireSetupCookie()
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::AcquireSetupCookie()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::AcquireSetupCookie",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr))     // if tls ctor failed above
        goto Exit;

    Assert(tls->pSetupCookie);

    // need to serialize all Setup on this thread
    // grab the Setup cookie

    hr = tls->pSetupCookie->Acquire(this);
    if (hr != S_OK) {

        Assert(!tls->pSetupCookie->IsFree());
        Assert(!tls->pSetupCookie->IsOwner(this));

        // wait till we get posted a message when the current owner
        // relinquishes the cookie

        goto Exit;
    }

    // have the cookie
    Assert(tls->pSetupCookie->IsOwner(this));

    SetState(CDL_Setup);

Exit:

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::RelinquishSetupCookie()
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::RelinquishSetupCookie()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::RelinquishSetupCookie",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr))     // if tls ctor failed above
        goto Exit;

    if (tls->pSetupCookie->IsOwner(this)) {

        tls->pSetupCookie->Relinquish(this);

        Assert(!tls->pSetupCookie->IsOwner(this));

    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;

}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::AddDownloadToList
// ---------------------------------------------------------------------------
#ifndef unix
inline VOID
#else
VOID
#endif /* !unix */
CCodeDownload::AddDownloadToList(CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::AddDownloadToList",
                "this=%#x, %#x",
                this, pdl
                ));
                
    pdl->AddParent(this);

    m_pDownloads.AddHead(pdl);

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload:: FindCABInDownloadList(szURL, pdlHint)
//    Find a download (typically a CAB) in download list
//    pdlHint is the first thing we look at (for perf.) as most usually
//    is a case of primary OCX in a CAB that the INF came in
//  Returns:
//      hr = ERROR (some error occurred, ignore *pdlMatch
//      hr = S_OK
//          if (*pdlMatch) match found, match is *pdlMatch
//          else
//              no match, or dups in other code downloads, download your own
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::FindCABInDownloadList(LPCWSTR szURL, CDownload* pdlHint, CDownload **ppdlMatch)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::FindCABInDownloadList",
                "this=%#x, %.80wq, %#x, %#x",
                this, szURL, pdlHint, ppdlMatch
                ));
                
    CDownload *pdlCur = NULL;
    HRESULT hr = S_OK;
    IMoniker* pmk = NULL;
    int i;
    LISTPOSITION curpos;

    *ppdlMatch = pdlCur;

    // create a moniker for the URL passed in and then we can pmk->IsEqual
    // with every other CDownload's moniker.

    IBindHost *pBH = GetClientBinding()->GetIBindHost();
    if (pBH) {
        hr = pBH->CreateMoniker((LPWSTR)szURL, pdlHint->GetBindCtx(), &pmk, 0);
    } else {
        hr =  CreateURLMoniker(m_pmkContext, szURL, &pmk);
    }


    if (FAILED(hr))
        goto Exit;

    pdlCur = pdlHint; // assume hit

    hr = pmk->IsEqual(pdlHint->GetMoniker());

    if (hr != S_FALSE)
        goto Exit;

    if (pdlHint->DoPost()) {

        hr = pmk->IsEqual(m_pmkContext);

        if (hr != S_FALSE)
            goto Exit;
    }

    // hint failed, try the whole list
    curpos = m_pDownloads.GetHeadPosition();
    for (i=0; i < m_pDownloads.GetCount(); i++) {

        pdlCur = m_pDownloads.GetNext(curpos);


        if (pdlCur == pdlHint) // already tried the pdlHint, don't retry
            continue;

        hr = pmk->IsEqual(pdlCur->GetMoniker());

        if (hr != S_FALSE)
            goto Exit;

    }

    pdlCur = NULL;

    // now look across downloads

    hr = FindDupCABInThread(pmk, &pdlCur);

Exit:

    if (pmk)
        pmk->Release();

    *ppdlMatch = pdlCur;

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::FindDupCABInThread(IMoniker *pmk, CDownload **ppdlMatch)
//    Find a download (typically a CAB) across all code downloads in thread
//  Returns:
//      hr = ERROR
//      hr = S_OK pdlCur?(match found):(no match found, do your own download)
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::FindDupCABInThread(IMoniker *pmk, CDownload **ppdlMatch)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::FindDupCABInThread",
                "this=%#x, %#x, %#x",
                this, pmk, ppdlMatch
                ));
                
    CDownload *pdlCur = NULL;
    HRESULT hr = S_OK;
    LISTPOSITION curposCDL, curposDL;
    CCodeDownload *pcdl;
    int iNumCDL;
    int i,j;

    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr))
        goto Exit;

    iNumCDL = tls->pCodeDownloadList->GetCount();
    curposCDL = tls->pCodeDownloadList->GetHeadPosition();

    // walk thru all the code downloads in the thread and check for DUPs
    for (i=0; i < iNumCDL; i++) {

        pcdl = tls->pCodeDownloadList->GetNext(curposCDL);

        if (pcdl == this)
            continue;

        // look into this CCodeDownload tree for dup

        curposDL = pcdl->m_pDownloads.GetHeadPosition();
        for (j=0; j < pcdl->m_pDownloads.GetCount(); j++) {

            pdlCur = pcdl->m_pDownloads.GetNext(curposDL);

            hr = pmk->IsEqual(pdlCur->GetMoniker());

            if (hr != S_FALSE)
                goto Exit;

        }
        pdlCur = NULL;
    }

    hr = S_OK;


Exit:

    if (pdlCur) {

        // found a match in another Code Download
        // add this pdl to our download list as well.


        if (pdlCur->GetDLState() > DLSTATE_SETUP) {
            pdlCur = NULL;          // too late to piggy back
        } else {

            m_debuglog->DebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_FOUND_DUP,
                                 pdlCur->GetURL(), GetClsid().Data1,
                                 GetMainURL(), m_dwFileVersionMS,
                                 m_dwFileVersionLS);

            AddDownloadToList(pdlCur);
        }

    }

    *ppdlMatch = pdlCur;

    DEBUG_LEAVE(hr);
    return hr;

}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::InitLastModifiedFromDistUnit
// ---------------------------------------------------------------------------
VOID
CCodeDownload::InitLastModifiedFromDistUnit()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::InitLastModifiedFromDistUnit",
                "this=%#x",
                this
                ));

    WIN32_FIND_DATA fd;
    HANDLE hf;

    IsDistUnitLocallyInstalled( m_szDistUnit, 0, 0, m_plci, NULL, NULL, 0);

    if (!m_plci->GetLastModifiedTime() ) {

        if ((hf = FindFirstFile(m_plci->szExistingFileName, &fd)) != INVALID_HANDLE_VALUE) {
            memcpy(&(m_plci->ftLastModified), &(fd.ftLastWriteTime), sizeof(FILETIME));
            FindClose(hf);
        }
    }

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::DoCodeDownload
//    Main action entry point for CCodeDownload
//
// This triggers creation of the first CDownload object for the CODE url
// if a local check for CLSID,FileVersion returns update_needed.
// (note : it is interesting to note here that if a control needs to just
// update a dependent DLL file it still needs to update the FileVersion
// of the primary control file (with CLSID implementation) for triggering
// any download at all!
//
// Once DoCodeDownload determines that an update is in order it creates
// a CClBinding for its client to call client BSC::OnstartBinding with.
//
// It then adds this CDownload obj to its list of downloads.
//
// If the m_url is a CAB or INF we need to download it before we know
// what we need to do next. Otherwise we create a CSetup obj for the
// download and add it to CDownload's list of pending Setup processing for
// stage 2 (setup and registeration). CSetup details later.
//
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::DoCodeDownload(
    CLocalComponentInfo *plci,
    DWORD flags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::DoCodeDownload",
                "this=%#x, %#x, %#x",
                this, plci, flags
                ));
                
    CDownload *pdl = NULL;
    HRESULT hr = NOERROR;
    FILEXTN extn = FILEXTN_UNKNOWN;
    WCHAR szURL[INTERNET_MAX_URL_LENGTH];
    LPWSTR lpDownloadURL;
    HGLOBAL hPostData = NULL;
    DWORD cbPostData = 0;
    ICodeInstall* pCodeInstall = GetICodeInstall();


    // set if we need to instantiate the object or just download/install it
    SetNeedObject(flags);

    // set if we should ignore the internet search path
    SetUseCodebaseOnly(flags);

    m_plci = plci;
    Assert(plci);

    // get lcid from the bind context
    BIND_OPTS2 bopts;
    bopts.cbStruct = sizeof(BIND_OPTS2);

    if (SUCCEEDED(GetClientBC()->GetBindOptions(&bopts)) &&
        (bopts.cbStruct == sizeof(BIND_OPTS2)) ) {

        m_lcid = bopts.locale;  // else user default lcid is already in
        
        DEBUG_PRINT(DOWNLOAD, 
                    INFO,
                    ("CCodeDownload::DoCodeDownload::this=%#x, m_lcid: %d (%#x)\n",
                    this, m_lcid, m_lcid
                    ));
    }

    if (m_plci->IsPresent() && pCodeInstall) {

        // a prev ver exists. get permission to overwrite
        // if ICodeInstall available

        WCHAR szBuf[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_plci->szExistingFileName, -1, szBuf, MAX_PATH);
        hr = pCodeInstall->OnCodeInstallProblem( CIP_OLDER_VERSION_EXISTS,
                    NULL, szBuf, 0);

        // hr == E_ABORT: abort whole download
        if (FAILED(hr)) {

            if (hr == E_ABORT)
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);

            // else preserve error code of OnCodeInstallProblem

            goto CD_Exit;
        }

    }



    // we need local version modified time only when doing GetLatest and
    // only for the top most file
    if (NeedLatestVersion() && m_plci->szExistingFileName[0] &&
            !m_plci->GetLastModifiedTime() ) {

        InitLastModifiedFromDistUnit();

    }

    if ((!m_url) || !(*m_url))  // if no CODE= <url>, mark that the option is
        SetUsedCodeURL();       // already exhausted

    // get the first site to try downloading from
    hr = GetNextOnInternetSearchPath(GetClsid(), &hPostData, &cbPostData, szURL,
            INTERNET_MAX_URL_LENGTH, &lpDownloadURL, &extn);

    if ( FAILED(hr))
        goto CD_Exit;

    // download the CODE=URL (ie. CAB or INF file first)
    pdl = new CDownload(lpDownloadURL, extn, &hr);

    if (!pdl) {
        hr = E_OUTOFMEMORY;
        goto CD_Exit;
    } else if (FAILED(hr)) {
        delete pdl;
        goto CD_Exit;
    }

    AddDownloadToList(pdl);

    if (hPostData) {

        pdl->SetPostData(hPostData, cbPostData);
        hPostData = NULL; // mark as delegated, destructor for pdl will free
    }

    // don't need to set on stack for this case as we have addref'ed the
    // pcdl. The reason we don't use the same addref technique on other
    // situations is because while addref controls the life of the object
    // the onstack is a dictate to not issue the OnStopBinding
    // setting onstack from here will prevent the client from getting
    // the OnStopBinding a must if an OnStartBinding has been issued.

    hr = pdl->DoDownload(&m_pmkContext,
                        (BINDF_ASYNCHRONOUS| BINDF_ASYNCSTORAGE));

    if (hr == MK_S_ASYNCHRONOUS) {
        SetState(CDL_Downloading);
    }


CD_Exit:

    if (FAILED(hr)) {

        if (hPostData)
            GlobalFree(hPostData);

    }

    DEBUG_LEAVE(hr);
    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetupCODEUrl
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::SetupCODEUrl(LPWSTR *ppDownloadURL, FILEXTN *pextn)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetupCODEUrl",
                "this=%#x, %#x, %#x",
                this, ppDownloadURL, pextn
                ));
                
    char *pBaseFileName = NULL;
    char szBuf[INTERNET_MAX_URL_LENGTH];

    WideCharToMultiByte(CP_ACP, 0, m_url, -1, szBuf,
        INTERNET_MAX_URL_LENGTH, 0,0);
    *pextn = GetExtnAndBaseFileName( szBuf, &pBaseFileName);

    *ppDownloadURL = m_url;
    SetUsedCodeURL();

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GetNextComponent
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::GetNextComponent(
    LPSTR szURL,
    LPSTR *ppCur
    )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::GetNextComponent",
                "this=%#x, %.80q, %#x",
                this, szURL, ppCur
                ));
                
    HRESULT hr = S_OK;
    LPSTR pch = *ppCur;
    LPSTR pchOut = szURL;
    int cbBuffer = 0;

#define BEGIN_ANGLE_BRKT    '<'
#define END_ANGLE_BRKT  '>'
#define COMP_DELIMITER  ';'

    if (!pch || *pch == '\0') {
        hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        goto Exit;
    }

    if (*pch == BEGIN_ANGLE_BRKT) {

        pch++; // skip BEGIN_ANGLE_BRKT
        for (; *pch && (*pch != END_ANGLE_BRKT);) {
            *pchOut++ = *pch++;
            if (cbBuffer++ >= INTERNET_MAX_URL_LENGTH) {
                hr = E_INVALIDARG;
                goto Exit;
            }
        }

        if (*pch)
            pch++;  // skip the END_ANGLE_BRKT

    } else {

        // assume its CODEBASE, just copy the string till we reach the
        // next COMP_DELIMITER
        for (; *pch && (*pch != COMP_DELIMITER);) {
            *pchOut++ = *pch++;
            if (cbBuffer++ >= INTERNET_MAX_URL_LENGTH) {
                hr = E_INVALIDARG;
                goto Exit;
            }
        }
    }

    *pchOut = '\0';

    if (*pch)
        *ppCur = pch+1; // skip the COMP_DELIMITER
    else
        *ppCur = pch;

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GetNextOnInternetSearchPath
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::GetNextOnInternetSearchPath(
    REFCLSID rclsid,
    HGLOBAL *phPostData,
    DWORD *pcbPostData,
    LPWSTR szURL,
    DWORD dwSize,
    LPWSTR *ppDownloadURL,
    FILEXTN *pextn
    )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::GetNextOnInternetSearchPath",
                "this=%#x, %#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, &rclsid, phPostData, pcbPostData, szURL, dwSize, ppDownloadURL, pextn
                ));

    LONG lResult;
    HRESULT hr = S_OK;
    DWORD Size;
    DWORD dwType;
    char szBuf[INTERNET_MAX_URL_LENGTH];
    DWORD cb;
    static char *szISP = "CodeBaseSearchPath";

    char szClsid[MAX_PATH];
    char szID[MAX_PATH];
    char szHackMimeType[MAX_PATH];
    HGLOBAL hPostData = NULL;
    char szNeedVersion[100]; // enough to hold four shorts as a,b,c,d + nulterm
    BOOL bMimeType = FALSE;

    // Ignore Internet Search path if set.
    if (UseCodebaseOnly())
    {
        SetupCODEUrl(ppDownloadURL,pextn);
        goto Exit;
    }

    if (!m_hKeySearchPath) {

        lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_SETTINGS, 0,
                        KEY_READ, &m_hKeySearchPath);

        if (lResult == ERROR_SUCCESS) {

            // get size reqd to store away entire searchpath
            lResult = ::SHQueryValueEx(m_hKeySearchPath, szISP, NULL, &dwType,
                                /* get size */ NULL, &Size);

            if ( lResult == ERROR_SUCCESS) {

                if (Size == 0) {
                    // we don't check the CODE url in the case where there is a
                    // searchpath specified in the registry, but UseCodeURL is
                    // not one of the elements in the searchpath.
                    // This gives the client a choice to completely ignore the
                    // CODE URL if needed, but without specifying any other
                    // HTTP-POST url either
                    hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
                    goto Exit;
                }

                // alloc memory
                Size++;
                m_pSearchPath = new char [Size];
                if (m_pSearchPath) {
                    lResult = ::SHQueryValueEx(m_hKeySearchPath, szISP, NULL,
                                    &dwType, (unsigned char *)m_pSearchPath,
                                    &Size);
                    Assert(lResult == ERROR_SUCCESS);
                    m_pSearchPathNextComp = m_pSearchPath;
                } else {
                    lResult = E_OUTOFMEMORY;
                }
            }
        }

        if (lResult != ERROR_SUCCESS) {

            if (UsedCodeURL()) { // no searchpath, already used CODE url?
                hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
                goto Exit;
            }

            // no searchpath, use CODE=<url> in OBJECT tag
            SetupCODEUrl(ppDownloadURL,pextn);
            goto Exit;
        }
    }

    do {

        hr = GetNextComponent(szBuf, &m_pSearchPathNextComp);
        if (FAILED(hr))
            goto Exit;

        if (lstrcmpi(szBuf, sz_USE_CODE_URL) == 0) {

            if (UsedCodeURL()) { // already used CODE url?
                continue;
            }

            // use code=<url> in OBJECT tag
            SetupCODEUrl(ppDownloadURL,pextn);
            goto Exit;

        } else {
            break;
        }

    } while (TRUE);

    // here if HTTP-POST url
    MultiByteToWideChar(CP_ACP, 0, szBuf, -1, szURL, dwSize);

    *ppDownloadURL = szURL;

    // do POST: form the post data


    if (GetMainDistUnit()) {

        WideCharToMultiByte(CP_ACP, 0, GetMainDistUnit(), -1, szClsid, MAX_PATH, 0,0);
        wnsprintf(szID, sizeof(szID)-1, "CLSID=%s", szClsid);

    } else {

        // no clsid, dispatch the mime type or ext

        if (GetMainType()) {

            // type available
            WideCharToMultiByte(CP_ACP, 0, GetMainType(), -1, szClsid, MAX_PATH, 0,0);
            wnsprintf(szID, sizeof(szID)-1, "MIMETYPE=%s", szClsid);
            bMimeType = TRUE;

        } else {

            // ext
            Assert(GetMainExt());

            WideCharToMultiByte(CP_ACP, 0, GetMainExt(), -1, szClsid, MAX_PATH, 0,0);
            wnsprintf(szID, sizeof(szID)-1, "EXTENSION=%s", szClsid);
        }

    }

    cb = lstrlen(szID);

    // compute increased size if Version is specified.
    if (m_dwFileVersionMS || m_dwFileVersionLS) {

        wsprintf(szNeedVersion, "&%s=%d,%d,%d,%d",szVersion,
                    (m_dwFileVersionMS & 0xffff0000)>>16,
                    (m_dwFileVersionMS & 0xffff),
                    (m_dwFileVersionLS & 0xffff0000)>>16,
                    (m_dwFileVersionLS & 0xffff));

        cb += lstrlen(szNeedVersion);
    }

    if (bMimeType) {

        // hack the OBJECT index
        // it doesn't support query by mime type
        // so send out post data with the mime type in the CLSID=
        // we also need to escape the '/' if any in the mime type
        ComposeHackClsidFromMime(szHackMimeType, sizeof(szHackMimeType), szClsid);
        cb += lstrlen(szHackMimeType);
    }

    hPostData = GlobalAlloc(GPTR, cb+1 ); // + 1 for null term

    if (!hPostData) {
        hr = HRESULT_FROM_WIN32(GetLastError()); // typically, E_OUTOFMEMORY
        goto ReleaseAndExit;
    }

    lstrcpy((char *)hPostData, szID);

    if (m_dwFileVersionMS || m_dwFileVersionLS)
        lstrcat( (char *)hPostData, szNeedVersion);

    if (bMimeType)
        lstrcat( (char *)hPostData, szHackMimeType);

    Assert(cb == (DWORD)lstrlen((char *)hPostData));

    *pcbPostData = cb;

ReleaseAndExit:


Exit:

    *phPostData = hPostData;

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::IsPackageLocallyInstalled
// ---------------------------------------------------------------------------
HRESULT
CCodeDownload::IsPackageLocallyInstalled(LPCWSTR szPackageName, LPCWSTR szNameSpace, DWORD dwVersionMS, DWORD dwVersionLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::IsPackageLocallyInstalled",
                "this=%#x, %.80wq, %.80wq, %#x, %#x",
                this, szPackageName, szNameSpace, dwVersionMS, dwVersionLS
                ));
                
    HRESULT hr = ::IsPackageLocallyInstalled(&m_pPackageManager, szPackageName, szNameSpace, dwVersionMS, dwVersionLS);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::DestroyPCBHList
// ---------------------------------------------------------------------------
void CCodeDownload::DestroyPCBHList(CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCodeDownload::DestroyPCBHList",
                "this=%#x, %#x",
                this, pcbhList
                ));
                
    LISTPOSITION               lpos = 0;
    CCodeBaseHold             *pcbh = NULL;

    if (pcbhList) {
        lpos = pcbhList->GetHeadPosition();
        while (lpos) {
            pcbh = pcbhList->GetNext(lpos);
            delete pcbh;
        }
        pcbhList->RemoveAll();
    }

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetCatalogFile
// ---------------------------------------------------------------------------
HRESULT CCodeDownload::SetCatalogFile(LPSTR szCatalogFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetCatalogFile",
                "this=%#x, %.80q",
                this, szCatalogFile
                ));
                
    HRESULT                  hr = S_OK;

    SAFEDELETE(m_szCatalogFile);
    m_szCatalogFile = new char[lstrlen(szCatalogFile) + 1];
    if (m_szCatalogFile == NULL) {
        hr = E_OUTOFMEMORY;
    }
    else {
        lstrcpy(m_szCatalogFile, szCatalogFile);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::GetCatalogFile
// ---------------------------------------------------------------------------
LPSTR CCodeDownload::GetCatalogFile()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                String,
                "CCodeDownload::GetCatalogFile",
                "this=%#x",
                this
                ));
                
    HRESULT                  hr = S_OK;
    LPSTR                    szCatalogFile = NULL;
    CClBinding              *pBinding = NULL;
    IBindStatusCallback     *pBSC = NULL;
    IServiceProvider        *pServProv = NULL;
    LPCATALOGFILEINFO        pcfi = NULL;

    if (m_szCatalogFile) {
        szCatalogFile = m_szCatalogFile;
    }
    else {
        pBinding = m_pClientbinding.GetHead();
        if (pBinding) {
            pBSC = pBinding->GetAssBSC();
            if (pBSC) {
                hr = pBSC->QueryInterface(IID_ICatalogFileInfo, (void **)&pcfi);
                if (SUCCEEDED(hr)) {
                    pcfi->GetCatalogFile(&szCatalogFile);
                    m_szCatalogFile = szCatalogFile;
                    SAFERELEASE(pcfi);
                }
                else {
                    hr = pBSC->QueryInterface(IID_IServiceProvider, (void **)&pServProv);
                    if (SUCCEEDED(hr)) {
                        hr = pServProv->QueryService(IID_ICatalogFileInfo, IID_ICatalogFileInfo, (void **)&pcfi);
                        if (SUCCEEDED(hr)) {
                            pcfi->GetCatalogFile(&szCatalogFile);
                            m_szCatalogFile = szCatalogFile;
                        }
                        SAFERELEASE(pServProv);
                        SAFERELEASE(pcfi);
                    }
                }

            }
        }
    }

    DEBUG_LEAVE(szCatalogFile);
    return szCatalogFile;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetMainCABJavaTrustPermissions
// ---------------------------------------------------------------------------
HRESULT CCodeDownload::SetMainCABJavaTrustPermissions(PJAVA_TRUST pbJavaTrust)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCodeDownload::SetMainCABJavaTrustPermissions",
                "this=%#x, %#x",
                this, pbJavaTrust
                ));
                
    DWORD                            dwLen = 0;
    HRESULT                          hr = S_OK;

    if (pbJavaTrust && m_pbJavaTrust == NULL) { // only do this once

        // Clone the JAVA_TRUST object

        if (pbJavaTrust->cbSize) {
            m_pbJavaTrust = (PJAVA_TRUST)new BYTE[pbJavaTrust->cbSize];
            if (m_pbJavaTrust == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        } else {
            m_pbJavaTrust = NULL;
            goto Exit;
        }

        memset(m_pbJavaTrust, 0, sizeof(JAVA_TRUST));

        m_pbJavaTrust->cbJavaPermissions = pbJavaTrust->cbJavaPermissions;
        if (pbJavaTrust->cbJavaPermissions) {
            m_pbJavaTrust->pbJavaPermissions = new BYTE[m_pbJavaTrust->cbJavaPermissions];
            if (m_pbJavaTrust->pbJavaPermissions == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            memcpy(m_pbJavaTrust->pbJavaPermissions, pbJavaTrust->pbJavaPermissions,
                   m_pbJavaTrust->cbJavaPermissions);
        }
        else {
            m_pbJavaTrust->pbJavaPermissions = NULL;
        }

        m_pbJavaTrust->cbSigner = pbJavaTrust->cbSigner;
        if (pbJavaTrust->cbSigner) {
            m_pbJavaTrust->pbSigner = new BYTE[m_pbJavaTrust->cbSigner];
            if (m_pbJavaTrust->pbSigner == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            memcpy(m_pbJavaTrust->pbSigner, pbJavaTrust->pbSigner,
                   m_pbJavaTrust->cbSigner);
        }
        else {
            m_pbJavaTrust->pbSigner = NULL;
        }


        // pbJavaTrust in IE4 had a bug where this zone URL is not NULL
        // terminated. Besides, we don't really require cloning the zone as we
        // don't use it to install. So, we are not cloning the zone url
        m_pbJavaTrust->pwszZone = NULL;


        m_pbJavaTrust->cbSize = pbJavaTrust->cbSize;
        m_pbJavaTrust->flag = pbJavaTrust->flag;
        m_pbJavaTrust->fAllActiveXPermissions = pbJavaTrust->fAllActiveXPermissions;
        m_pbJavaTrust->fAllPermissions = pbJavaTrust->fAllPermissions;
        m_pbJavaTrust->dwEncodingType = pbJavaTrust->dwEncodingType;
        m_pbJavaTrust->guidZone = pbJavaTrust->guidZone;
        m_pbJavaTrust->hVerify = pbJavaTrust->hVerify;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CCodeDownload::SetMainCABJavaTrustPermissions
// ---------------------------------------------------------------------------
PJAVA_TRUST CCodeDownload::GetJavaTrust()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CCodeDownload::GetJavaTrust",
                "this=%#x",
                this
                ));


    DEBUG_LEAVE(m_pbJavaTrust);               
    return m_pbJavaTrust;
}






HRESULT ProcessImplementation(IXMLElement *pConfig,
                              CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList,
                              LCID lcidOverride,
#ifdef WX86
                              CMultiArch *MultiArch,
#endif
                              LPWSTR szBaseURL)
{
#ifdef WX86
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "ProcessImplementation",
                "%#x, %#x, %#x, %#x, %.80wq",
                pConfig, pcbhList, lcidOverride, MultiArch, szBaseURL
                ));
#else
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "ProcessImplementation",
                "%#x, %#x, %#x, %.80wq",
                pConfig, pcbhList, lcidOverride, szBaseURL
                ));
#endif
                
    int nLastChildTag = -1;
    int nLastCodeBase = -1;
    int nLastOS = -1;
    int nLastProc = -1;
    OSVERSIONINFO osvi;
    BOOL fFoundAnyConfig = FALSE;
    BOOL fFoundAnyOS = FALSE, fFoundMatchingOS = FALSE;
    BOOL fFoundAnyProc = FALSE, fFoundMatchingProc = FALSE;
    IXMLElement *pCodeBase = NULL, *pLang = NULL, *pOS = NULL;
    IXMLElement *pOSVersion = NULL, *pProcessor = NULL;
    HRESULT hr = S_FALSE;               // default: failed configuration match
    BOOL bSetMainCodeBase = FALSE;
#ifdef WX86
    char *szPreferredArch;
    char *szAlternateArch;
    HRESULT hrArch;
#endif

    union {
        char szLang[MAX_PATH];
        char szOS[MAX_PATH];
        char szOSVersion[MAX_PATH];
        char szProcessor[MAX_PATH];
    };


    if (pcbhList == NULL)
    {
        DEBUG_LEAVE(hr);
        return E_INVALIDARG;
    }
    
    pcbhList->RemoveAll();

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    // process LANGUAGES tag.
    if (GetFirstChildTag(pConfig, DU_TAG_LANG, &pLang) == S_OK) {

        if (SUCCEEDED(GetAttributeA(pLang, DU_ATTRIB_VALUE, szLang, MAX_PATH))) {

            if (FAILED(CheckLanguage(lcidOverride, szLang))) {

                if ((lcidOverride == g_lcidBrowser) ||
                    (FAILED(CheckLanguage(g_lcidBrowser, szLang)))) {
                        hr = S_FALSE;
                        goto Exit;

                }
            }

        } else {                // improperly formatted, skip it.
            hr = S_FALSE;
            goto Exit;
        }

    } // languages

    // process OS tag
    nLastOS = -1;
    fFoundAnyOS = FALSE;
    fFoundMatchingOS = FALSE;
    while (GetNextChildTag(pConfig, DU_TAG_OS, &pOS, nLastOS) == S_OK) {
        fFoundAnyOS = TRUE;

        if (SUCCEEDED(GetAttributeA(pOS, DU_ATTRIB_VALUE, szOS, MAX_PATH))) {

            if (lstrcmpi(szOS, (const char *) ((g_fRunningOnNT) ? szWinNT : szWin95)) == 0) {

                if (GetFirstChildTag(pOS, DU_TAG_OSVERSION, &pOSVersion) == S_OK) {

                    if (SUCCEEDED(GetAttributeA(pOSVersion, DU_ATTRIB_VALUE, szOSVersion, MAX_PATH))) {

                        DWORD dwVersionMS = 0, dwVersionLS = 0;

                        if (SUCCEEDED(GetVersionFromString(szOSVersion, &dwVersionMS, &dwVersionLS))) {
                            if (!((osvi.dwMajorVersion < (dwVersionMS>>16)) || (osvi.dwMajorVersion == (dwVersionMS>>16) &&
                                 (osvi.dwMinorVersion < (dwVersionMS & 0xFFFF))) )) {
                                fFoundMatchingOS = TRUE;
                                break;
                            }

                        } else {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            goto Exit;
                        }

                    }
                } else {
                    // OS with no version
                    fFoundMatchingOS = TRUE;
                    break;
                }
            }
        }

        SAFERELEASE(pOS);
        SAFERELEASE(pOSVersion);
    }

    if (fFoundAnyOS && !fFoundMatchingOS) {
        hr = S_FALSE;
        goto Exit;
    }

    // check PROCESSOR tag
    nLastProc = -1;
    fFoundAnyProc = FALSE;
    fFoundMatchingProc = FALSE;
#ifdef WX86
    MultiArch->SelectArchitecturePreferences(
                g_szProcessorTypes[g_CPUType],
                g_szProcessorTypes[PROCESSOR_ARCHITECTURE_INTEL],
                &szPreferredArch,
                &szAlternateArch);
#endif

    while (GetNextChildTag(pConfig, DU_TAG_PROCESSOR, &pProcessor, nLastProc) == S_OK) {

        fFoundAnyProc = TRUE;
        if (SUCCEEDED(GetAttributeA(pProcessor, DU_ATTRIB_VALUE, szProcessor, MAX_PATH))) {

#ifdef WX86
            if (lstrcmpi(szPreferredArch, szProcessor) == 0) {
                hrArch = MultiArch->RequirePrimaryArch();
                Assert(SUCCEEDED(hrArch));
                fFoundMatchingProc = TRUE;
                break;
            } else if (szAlternateArch) {
                if (lstrcmpi(szAlternateArch, szProcessor) == 0) {
                    hrArch = MultiArch->RequireAlternateArch();
                    Assert(SUCCEEDED(hrArch));
                    fFoundMatchingProc = TRUE;
                    break;
                }
            }
#else
            if (lstrcmpi(g_szProcessorTypes[g_CPUType],szProcessor) == 0) {
                fFoundMatchingProc = TRUE;
                break;
            }
#endif
        }

        SAFERELEASE(pProcessor);
    }

    if (fFoundAnyProc && !fFoundMatchingProc) {
        hr = S_FALSE;
        goto Exit;
    }

    // process CODEBASE tag.
    nLastCodeBase = -1;
    bSetMainCodeBase = FALSE;
    while (GetNextChildTag(pConfig, DU_TAG_CODEBASE, &pCodeBase, nLastCodeBase) == S_OK) {

        hr = ProcessCodeBaseList(pCodeBase, pcbhList, szBaseURL);
        if (!bSetMainCodeBase) {
            CCodeBaseHold           *pcbhMain;

            pcbhMain = pcbhList->GetHead();
            if (pcbhMain) {
                pcbhMain->dwFlags |= CBH_FLAGS_MAIN_CODEBASE;
                bSetMainCodeBase = TRUE;
            }
        }

        SAFERELEASE(pCodeBase);

    }

    //REVIEW: We could also extract ABSTRACT, TITLE here

    // NEEDSTRUSTEDSOURCE & SYSTEM only apply to Java applets so they can be checked in
    // addition to this by ProcessJavaManifest.

    // we passed all configuration filter criteria
    hr = S_OK;

Exit:
    SAFERELEASE(pCodeBase);
    SAFERELEASE(pLang);
    SAFERELEASE(pOS);
    SAFERELEASE(pOSVersion);
    SAFERELEASE(pProcessor);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT ProcessCodeBaseList(IXMLElement *pCodeBase,
                            CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList,
                            LPWSTR szBaseURL)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "ProcessCodeBaseList",
                "%#x, %#x, %.80wq",
                pCodeBase, pcbhList, szBaseURL
                ));
                
    HRESULT                           hr = S_OK;
    DWORD                             dwSize = 0;
    CCodeBaseHold                    *pcbh = NULL;
    CCodeBaseHold                    *pcbhCur = NULL;
    LISTPOSITION                      lpos = 0;
    LPINTERNET_CACHE_ENTRY_INFO       lpCacheEntryInfo = NULL;
    LPSTR                             szCodeBase = NULL;
    BOOL                              bRandom = FALSE;
    int                               iIndex = 0;
    int                               iCount = 0;
    int                               i;
    int                               iLastIndexInCache;
    char                              achBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    char                              szRandom[MAX_PATH];
    WCHAR                             szResult[INTERNET_MAX_URL_LENGTH];

    union {
        char szSize[MAX_PATH];
        char szStyle[MAX_PATH];
    };

    if (!pcbhList) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pcbh = new CCodeBaseHold();

    if (!pcbh) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    if (SUCCEEDED(hr = DupAttribute(pCodeBase, DU_ATTRIB_HREF, &pcbh->wszCodeBase))) {
        pcbh->bHREF = TRUE;
        if (szBaseURL) {
            dwSize = INTERNET_MAX_PATH_LENGTH;
            UrlCombineW(szBaseURL, pcbh->wszCodeBase, szResult, &dwSize, 0);
            delete pcbh->wszCodeBase;
            pcbh->wszCodeBase = new WCHAR[dwSize + 1];
            if (pcbh->wszCodeBase == NULL) {
                hr = E_OUTOFMEMORY;
                SAFEDELETE(pcbh);
                goto Exit;
            }
            StrCpyW(pcbh->wszCodeBase, szResult);
        }

    } else if (SUCCEEDED(hr = DupAttribute(pCodeBase, DU_ATTRIB_FILENAME, &pcbh->wszCodeBase))) {
        pcbh->bHREF = FALSE;
    } else {
        SAFEDELETE(pcbh);
        goto Exit;
    }

    bRandom = FALSE;
    if (SUCCEEDED(GetAttributeA(pCodeBase, DU_ATTRIB_RANDOM, szRandom, MAX_PATH))) {
        if (szRandom[0] == 'y' || szRandom[0] == 'Y') {
            bRandom = TRUE;
        }
    }

    pcbh->wszDLGroup = NULL;
    pcbh->dwFlags &= ~CBH_FLAGS_DOWNLOADED;
    DupAttribute(pCodeBase, DU_ATTRIB_DL_GROUP, &pcbh->wszDLGroup);

    if (SUCCEEDED(GetAttributeA(pCodeBase, DU_ATTRIB_SIZE, szSize, MAX_PATH))) {
        pcbh->dwSize = StrToIntA(szSize);
    } else {
        pcbh->dwSize = -1;
    }

    pcbh->dwFlags &= ~CBH_FLAGS_MAIN_CODEBASE;

    // If the cache entry for this URL exists, put this at the head of the
    // list.

    lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)achBuffer;
    dwSize = MAX_CACHE_ENTRY_INFO_SIZE;
    if (SUCCEEDED(hr = Unicode2Ansi(pcbh->wszCodeBase, &szCodeBase))) {
        if (GetUrlCacheEntryInfo(szCodeBase, lpCacheEntryInfo,
                                 &dwSize)) {
            pcbhList->AddHead(pcbh);
            goto Exit;
        }
        SAFEDELETE(szCodeBase);
    } else {
        goto Exit;
    }

    if (bRandom) {

        // Set iLastIndexInCache to the last index in the linked list that
        // contains a cache entry. The goal is to ensure all cache entries
        // appear FIRST in the linked list.

        iLastIndexInCache = -1;
        lpos = pcbhList->GetHeadPosition();
        i = 0;
        while (lpos) {
            pcbhCur = pcbhList->GetNext(lpos);
            lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)achBuffer;
            dwSize = MAX_CACHE_ENTRY_INFO_SIZE;

            if (pcbhCur != NULL) {
                if (SUCCEEDED(Unicode2Ansi(pcbhCur->wszCodeBase,
                              &szCodeBase))) {
                    if (GetUrlCacheEntryInfo(szCodeBase, lpCacheEntryInfo,
                                             &dwSize)) {
                        iLastIndexInCache = i;
                    }
                    SAFEDELETE(szCodeBase);
                }
            }
            i++;
        }

        // Place codebase in list in a random order so that redundant codebases
        // can traverse list in order yet still achieve randomness

        iCount = pcbhList->GetCount();
        if (iCount) {
            // Generate random insertion index, x, in the range:
            // (iLastIndexInCache + 1) <= x < iCount

            if (iCount - iLastIndexInCache == 1) {
                // must add at tail, since last list entry == last cache entry
                pcbhList->AddTail(pcbh);
            } else {
                iIndex = (iLastIndexInCache + 1) + (randnum() % (iCount - iLastIndexInCache));
                if (iIndex == iCount) {
                    pcbhList->AddTail(pcbh);
                }
                else {
                    lpos = pcbhList->FindIndex(iIndex);
                    pcbhList->InsertBefore(lpos, pcbh);
                }
            }
        }
        else {
            pcbhList->AddTail(pcbh);
        }
    }
    else {
        // Not random, just ad as tail
        pcbhList->AddTail(pcbh);
    }

Exit:
    SAFEDELETE(szCodeBase);

    DEBUG_LEAVE(hr);
    return hr;
}

#ifdef WX86
// ---------------------------------------------------------------------------
// %%Function: CMultiArch::RequirePrimaryArch
// ---------------------------------------------------------------------------
HRESULT CMultiArch::RequirePrimaryArch()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CMultiArch::RequirePrimaryArch",
                "this=%#x",
                this
                ));
                
    if (m_RequiredArch != PROCESSOR_ARCHITECTURE_UNKNOWN &&
        m_RequiredArch != (DWORD)g_CPUType) {
        //
        // The required arch has already been set for this download.
        // The download to change the required arch in the middle or
        // else a control and its support pieces may end up getting
        // different architectures.
        //

        DEBUG_LEAVE(E_FAIL);
        return E_FAIL;
    }
    m_RequiredArch = (DWORD)g_CPUType;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CMultiArch::RequireAlternateArch
// ---------------------------------------------------------------------------
HRESULT CMultiArch::RequireAlternateArch()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CMultiArch::RequireAlternateArch",
                "this=%#x",
                this
                ));
                
    if (m_RequiredArch != PROCESSOR_ARCHITECTURE_UNKNOWN &&
        m_RequiredArch != PROCESSOR_ARCHITECTURE_INTEL) {
        //
        // The required arch has already been set for this download.
        // The download to change the required arch in the middle or
        // else a control and its support pieces may end up getting
        // different architectures.
        //

        DEBUG_LEAVE(E_FAIL);
        return E_FAIL;
    }
    m_RequiredArch = PROCESSOR_ARCHITECTURE_INTEL;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CMultiArch::SelectArchitecturePreferences
// ---------------------------------------------------------------------------
VOID
CMultiArch::SelectArchitecturePreferences(
    char *szNativeArch,
    char *szIntelArch,
    char **pszPreferredArch,
    char **pszAlternateArch
    )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CMultiArch::SelectArchitecturePreferences",
                "this=%#x, %.80q, %.80q, %#x, %#x",
                this, szNativeArch, szIntelArch, pszPreferredArch, pszAlternateArch
                ));
                
    if (g_fWx86Present) {
        switch (m_RequiredArch) {
        case PROCESSOR_ARCHITECTURE_INTEL:
            // An i386 binary has already been downloaded.  Only download
            // i386 binaries now.
            *pszPreferredArch = szIntelArch;
            *pszAlternateArch = NULL;
            break;

        case PROCESSOR_ARCHITECTURE_UNKNOWN:
            // No binaries downloaded so far.  Prefer native and fallback
            // to i386
            *pszPreferredArch = szNativeArch;
            *pszAlternateArch = szIntelArch;
            break;

        default:
            // A native binary has already been downloaded.  Only download
            // native binaries now.
            *pszPreferredArch = szNativeArch;
            *pszAlternateArch = NULL;
        }
    } else {
        // No Wx86
        *pszPreferredArch = szNativeArch;
        *pszAlternateArch = NULL;
    }

    DEBUG_LEAVE(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\client.cxx ===
// ===========================================================================
// File: CDL.CXX
//    The main code downloader file.
//



#include <cdlpch.h>


// ---------------------------------------------------------------------------
// %%Function: CClBinding::CClBinding
//  CClBinding (For client's IBinding for code download)
// ---------------------------------------------------------------------------
CClBinding::CClBinding(
    CCodeDownload *pcdl,
    IBindStatusCallback *pAssClientBSC,
    IBindCtx *pAssClientBC,
    REFCLSID rclsid,
    DWORD dwClsContext,
    LPVOID pvReserved,
    REFIID riid,
    IInternetHostSecurityManager *pHostSecurityManager): m_riid(riid)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CClBinding::CClBinding",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pcdl, pAssClientBSC, pAssClientBC, &rclsid, dwClsContext, pvReserved, &riid, 
                pHostSecurityManager
                ));
                
    m_cRef = 1; //equ of an internal addref
    m_dwState = CDL_NoOperation;
    m_pcdl = pcdl;
    m_pAssClientBSC = pAssClientBSC;
    m_pAssClientBC = pAssClientBC;
    m_pCodeInstall = NULL;
    m_pWindowForBindingUI = NULL;
    m_wszClassString = NULL;

    m_pHostSecurityManager = pHostSecurityManager;
    if (m_pHostSecurityManager)
        m_pHostSecurityManager->AddRef();
    

    m_pBindHost = NULL;

    m_hWnd = (HWND)INVALID_HANDLE_VALUE;

    m_dwClsContext = dwClsContext;
    m_pvReserved = pvReserved;

    memcpy(&m_clsid, &rclsid, sizeof(GUID));


    DEBUG_LEAVE(0);
}  // CClBinding


// ---------------------------------------------------------------------------
// %%Function: CClBinding::~CClBinding
// ---------------------------------------------------------------------------
CClBinding::~CClBinding()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CClBinding::~CClBinding",
                "this=%#x",
                this
                ));
                
    if (m_wszClassString) {
        delete [] m_wszClassString;
    }

    DEBUG_LEAVE(0);
}  // ~CClBinding

// ---------------------------------------------------------------------------
// %%Function: CClBinding::ReleaseClient
// ---------------------------------------------------------------------------
HRESULT
CClBinding::ReleaseClient()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::ReleaseClient",
                "this=%#x",
                this
                ));
                
    SAFERELEASE(m_pAssClientBSC);
    SAFERELEASE(m_pAssClientBC);
    SAFERELEASE(m_pCodeInstall);
    SAFERELEASE(m_pWindowForBindingUI);
    SAFERELEASE(m_pBindHost);
    SAFERELEASE(m_pHostSecurityManager );

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CClBinding::GetHWnd
// ---------------------------------------------------------------------------
HWND
CClBinding::GetHWND(REFGUID rguidReason)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CClBinding::GetHWND",
                "this=%#x, %#x",
                this, &rguidReason
                ));
                
    m_hWnd = (HWND)INVALID_HANDLE_VALUE;    // don't cache hwnd
                                            // this degrades will
                                            // if CSite goes away but
                                            // code download was not
                                            // aborted.

    if (m_pcdl->IsSilentMode()) {

        DEBUG_LEAVE(m_hWnd);
        return m_hWnd;
    }

    GetIWindowForBindingUI();

    if (m_pWindowForBindingUI) {

        m_pWindowForBindingUI->GetWindow(rguidReason, &m_hWnd);

    } else {

        GetICodeInstall();

        if (m_pCodeInstall)
            HRESULT hr = m_pCodeInstall->GetWindow(rguidReason,&m_hWnd);

    }

    DEBUG_LEAVE(m_hWnd);
    return m_hWnd;
}

// ---------------------------------------------------------------------------
// %%Function: GetHostSecurityManager
// ---------------------------------------------------------------------------
IInternetHostSecurityManager*
GetHostSecurityManager(IBindStatusCallback *pclientbsc)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "GetHostSecurityManager",
                "%#x",
                pclientbsc
                ));
                
    IInternetHostSecurityManager *pHostSecurityManager = NULL;

    // Get IInternetHostSecurityManager ptr
    HRESULT hr = pclientbsc->QueryInterface(IID_IInternetHostSecurityManager,
            (LPVOID *)&pHostSecurityManager);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = pclientbsc->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_IInternetHostSecurityManager,IID_IInternetHostSecurityManager,
                (LPVOID *)&pHostSecurityManager);
            pServProv->Release();
        }
    }

    DEBUG_LEAVE(pHostSecurityManager);
    return pHostSecurityManager;

}

// ---------------------------------------------------------------------------
// %%Function: CClBinding::GetHostSecurityManager
// ---------------------------------------------------------------------------
IInternetHostSecurityManager*
CClBinding::GetHostSecurityManager()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CClBinding::GetHostSecurityManager",
                "this=%#x",
                this
                ));
                
    static BOOL fFailedOnce = FALSE;

    if (m_pHostSecurityManager)
    {
        DEBUG_LEAVE(m_pHostSecurityManager);
        return m_pHostSecurityManager;
    }
    
    if (fFailedOnce) {

        DEBUG_LEAVE(NULL);
        return NULL;
    }

    Assert(m_pcdl);
    Assert(m_pcdl->GetClientBSC());

    m_pHostSecurityManager = ::GetHostSecurityManager(m_pcdl->GetClientBSC());

    if (!m_pHostSecurityManager)
        fFailedOnce = TRUE;

    DEBUG_LEAVE(m_pHostSecurityManager);
    return m_pHostSecurityManager;

}


// ---------------------------------------------------------------------------
// %%Function: CClBinding::GetBindHost
// ---------------------------------------------------------------------------
IBindHost*
CClBinding::GetIBindHost()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CClBinding::GetIBindHost",
                "this=%#x",
                this
                ));
                
    static BOOL fFailedOnce = FALSE;

    if (m_pBindHost)
    {
        DEBUG_LEAVE(m_pBindHost);
        return m_pBindHost;
    }
    
    if (fFailedOnce) {
    
        DEBUG_LEAVE(NULL);
        return NULL;
    }

    Assert(m_pcdl);
    Assert(m_pcdl->GetClientBSC());

    // Get IBindHost ptr
    HRESULT hr = m_pcdl->GetClientBSC()->QueryInterface(IID_IBindHost,
            (LPVOID *)&m_pBindHost);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = m_pcdl->GetClientBSC()->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_IBindHost,IID_IBindHost,
                (LPVOID *)&m_pBindHost);
            pServProv->Release();
        }
    }

    if (!m_pBindHost)
        fFailedOnce = TRUE;

    DEBUG_LEAVE(m_pBindHost);
    return m_pBindHost;

}

// ---------------------------------------------------------------------------
// %%Function: CClBinding::GetIWindowForBindingUI
// ---------------------------------------------------------------------------
IWindowForBindingUI*
CClBinding::GetIWindowForBindingUI()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CClBinding::GetIWindowForBindingUI",
                "this=%#x",
                this
                ));

    if (m_pWindowForBindingUI)
    {
        DEBUG_LEAVE(m_pWindowForBindingUI);
        return m_pWindowForBindingUI;
    }
    
    Assert(m_pcdl);
    Assert(m_pcdl->GetClientBSC());

    // Get IWindowForBindingUI ptr
    HRESULT hr = m_pcdl->GetClientBSC()->QueryInterface(IID_IWindowForBindingUI,
            (LPVOID *)&m_pWindowForBindingUI);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = m_pcdl->GetClientBSC()->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                (LPVOID *)&m_pWindowForBindingUI);
            pServProv->Release();
        }
    }

    if (!m_pWindowForBindingUI) {
        m_pcdl->CodeDownloadDebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_NO_IWINDOWFORBINDINGUI);
    }
    
    DEBUG_LEAVE(m_pWindowForBindingUI);
    return m_pWindowForBindingUI;

}

// ---------------------------------------------------------------------------
// %%Function: CClBinding::GetCodeInstall
// ---------------------------------------------------------------------------
ICodeInstall*
CClBinding::GetICodeInstall()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CClBinding::GetICodeInstall",
                "this=%#x",
                this
                ));

    if (m_pCodeInstall)
    {
        DEBUG_LEAVE(m_pCodeInstall);
        return m_pCodeInstall;
    }
    
    Assert(m_pcdl);
    Assert(m_pcdl->GetClientBSC());

    // Get ICodeInstall ptr
    HRESULT hr = m_pcdl->GetClientBSC()->QueryInterface(IID_ICodeInstall,
            (LPVOID *)&m_pCodeInstall);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = m_pcdl->GetClientBSC()->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_ICodeInstall,IID_ICodeInstall,
                (LPVOID *)&m_pCodeInstall);
            pServProv->Release();
        }
    }

    DEBUG_LEAVE(m_pCodeInstall);
    return m_pCodeInstall;

}


// ---------------------------------------------------------------------------
// %%Function: CClBinding::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CClBinding::AddRef()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CClBinding::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = m_cRef++;

    DEBUG_LEAVE(ulRet);
    return ulRet;
}
// ---------------------------------------------------------------------------
// %%Function: CClBinding::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CClBinding::Release()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CClBinding::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--m_cRef == 0) {
        delete this;

        DEBUG_LEAVE(0);
        return 0;
    }

    DEBUG_LEAVE(m_cRef);
    return m_cRef;
}

// ---------------------------------------------------------------------------
// %%Function: CClBinding::QueryInterface
// ---------------------------------------------------------------------------
 STDMETHODIMP
CClBinding::QueryInterface(REFIID riid, void** ppv)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CClBinding::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBinding)
    {
        *ppv = this;
        AddRef();

        DEBUG_LEAVE(S_OK);
        return S_OK;
    }

    // BUGBUG: what about IWinInetInfo and IWinsock???

    DEBUG_LEAVE(E_NOINTERFACE);
    return E_NOINTERFACE;
}  // CClBinding::QueryInterface


// ---------------------------------------------------------------------------
// %%Function: CClBinding::Abort( void )
// ---------------------------------------------------------------------------
STDMETHODIMP CClBinding::Abort( void )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::IBinding::Abort",
                "this=%#x",
                this
                ));
                
    Assert(m_pcdl);
    HRESULT hr = S_OK;
    CDownload *pdl =  NULL;

    // BUGBUG: need to understand why this pointer might be null
    // nothing to do
    if (m_pcdl == NULL)
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    //BUGBUG: this is hack fix for a stress bug
    __try
    {
        pdl = m_pcdl->GetDownloadHead();
        if (m_pcdl->GetCountClientBindings() > 1)
        {
        }
        pdl->GetDLState();

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
#ifdef unix
    __endexcept
#endif /* unix */
    if (m_pcdl->GetCountClientBindings() > 1) {
        hr = m_pcdl->AbortBinding(this);// not sure what we should do with
                                        // a failed hr!
        if (SUCCEEDED(hr))
        {   
            DEBUG_LEAVE(hr);
            return hr;
        }
        //else fall thru to really abort
        // we have some bad state inside
    }

    if (!m_pcdl->SafeToAbort()) {

        hr = m_pcdl->HandleUnSafeAbort(); // returns either S_FALSE or error

        if (hr == S_FALSE)      // chose not to abort
        {
            DEBUG_LEAVE(hr);
            return hr;          // indicated that we did not abort
        }
        else
        {
            DEBUG_LEAVE(S_OK);
            return S_OK;        // means DoSetp will abort
        }

    }

    CUrlMkTls tls(hr); // hr passed by reference!
    Assert(SUCCEEDED(hr));
    Assert(tls->pCDLPacketMgr);

    // to mark that atleast one real URLMON bindign was aborted
    // in this case URLMON will post an OnStopBinding for that
    // and we will end up aborting all other bindings and the whole
    // code download. However if that's not the case then we were probably
    // in some post binding processing such as verifytrust cab extraction etc
    // and so we need to post a DoSetup() packet with UserCancelled flag set.

    // forward the call to all our IBindings
    do {

        if (!pdl->IsSignalled(m_pcdl)) {
            // packet processing pending for this state. we will check for
            // DLSTATE_ABORT in each packet processing state and if true
            // it will call CompleteOne(us), which marks each piece DLSTATE_DONE

            hr = pdl->Abort(m_pcdl);
            
            DEBUG_LEAVE(hr);
            return hr;


        }


    } while ((pdl = pdl->GetNext()) != NULL);

    m_pcdl->SetUserCancelled();


    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CClBinding::Suspend( void )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::IBinding::Suspend",
                "this=%#x",
                this
                ));
                
    CDownload *pdl = m_pcdl->GetDownloadHead();

    if (m_dwState != CDL_Suspend)
        m_dwState = CDL_Suspend;
    else
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    
    // forward the call to all our IBindings
    do {
        if (pdl->GetBSC()->GetBinding())
            pdl->GetBSC()->GetBinding()->Suspend();
    } while ((pdl = pdl->GetNext()) != NULL);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP CClBinding::Resume( void )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::IBinding::Resume",
                "this=%#x",
                this
                ));
                
    CDownload *pdl = m_pcdl->GetDownloadHead();

    if (m_dwState == CDL_Suspend)
        m_dwState = CDL_Downloading;
    else
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    
    // forward the call to all our IBindings
    do {
        if (pdl->GetBSC()->GetBinding())
            pdl->GetBSC()->GetBinding()->Resume();
    } while ((pdl = pdl->GetNext()) != NULL);


    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP CClBinding::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::IBinding::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));

    CDownload *pdl = m_pcdl->GetDownloadHead();

    m_nPriority = nPriority; // cache pri

    // pass on priorty to our IBindings
    do {
        if (pdl->GetBSC()->GetBinding())
            pdl->GetBSC()->GetBinding()->SetPriority(nPriority);
    } while ((pdl = pdl->GetNext()) != NULL);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP CClBinding::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::IBinding::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));

    *pnPriority = m_nPriority; // don't need to call our IBindings: pri cached

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP CClBinding::GetBindResult(CLSID *pclsidProtocol, DWORD *pdwResult, LPWSTR *pszResult,DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::IBinding::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwResult, pszResult, pdwReserved
                ));
                
    HRESULT     hr = NOERROR;

    if (!pdwResult || !pszResult || pdwReserved)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pdwResult = NOERROR;
        *pszResult = NULL;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CClBinding::InstantiateObjectAndReport()
// ---------------------------------------------------------------------------
HRESULT
CClBinding::InstantiateObjectAndReport(CCodeDownload *pcdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::InstantiateObjectAndReport",
                "this=%#x, %#x",
                this, pcdl
                ));
                
    HRESULT hr = S_OK;

    LPVOID ppv = 0;
    CLSID myclsid;
    BOOL bLogGenOk;
    WCHAR *pwszOSBErrMsg = NULL;
    char *pszExactErrMsg = NULL;
    
    hr = GetClsidFromExtOrMime( m_clsid, myclsid, m_pcdl->GetMainExt(), m_pcdl->GetMainType(), NULL);

    if (SUCCEEDED(hr))
        hr = CoGetClassObject(myclsid, m_dwClsContext, m_pvReserved, m_riid, &ppv);

    if (SUCCEEDED(hr)) {
        (GetAssBSC())->OnObjectAvailable( m_riid, (IUnknown*) ppv);

        Assert(ppv);

        // release the IUnkown returned by CoGetClassObject
        ((IUnknown*)ppv)->Release();

    }

    if (FAILED(hr)) {
        bLogGenOk = pcdl->GenerateErrStrings(hr, &pszExactErrMsg,
                                             &pwszOSBErrMsg);
        if (!bLogGenOk) {
            pwszOSBErrMsg = NULL;
            pszExactErrMsg = NULL;
        }
    }

    (GetAssBSC())->OnStopBinding(hr, pwszOSBErrMsg);
    m_pcdl->CodeDownloadDebugOut(DEB_CODEDL, hr != S_OK, ID_CDLDBG_ONSTOPBINDING_CALLED,
                                 hr, (hr == S_OK)?"(SUCCESS)":"",
                                 myclsid.Data1, m_pcdl->GetMainURL(),
                                 m_pcdl->GetMainType(),
                                 m_pcdl->GetMainExt());

    SAFEDELETE(pwszOSBErrMsg);
    SAFEDELETE(pszExactErrMsg);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CClBinding::SetClassString(LPCWSTR pszClassString)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CClBinding::SetClassString",
                "this=%#x, %.80wq",
                this, pszClassString
                ));
                
    HRESULT                        hr = S_OK;

    if (m_wszClassString) {
        delete [] m_wszClassString;
    }

    if (!pszClassString) {
        m_wszClassString = NULL;
    }
    else {
        m_wszClassString = new WCHAR[lstrlenW(pszClassString) + 1];
        if (m_wszClassString) {
            StrCpyW(m_wszClassString, pszClassString);
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

const LPWSTR CClBinding::GetClassString()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CClBinding::GetClassString",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(m_wszClassString);
    return m_wszClassString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\debmacro.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME "IEXPLORE.EXE: "
#endif	// SZ_COMPNAME

static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
        if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
            break;
    }
    wnsprintf(ach, sizeof(ach)-1, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
	_AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  

#if defined(UNIX) && defined(ux10)
    wvsprintf(ach, pszMsg, (va_list)(&pszMsg + 1));
#else
    wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
#endif
	OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
	_DebugMsg(pszMsg);
#ifndef unix
	_asm {int 3};
#endif
}

#ifndef unix
#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#else
#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__); } }
#endif /* unix */
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP	_DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\dbglog.cxx ===
// ===========================================================================
// File: DBGLOG.CXX
//       CDLDebugLog: Class for Debug Logs
//       DebugLogElement: Node class for debug log messages
//

#include <cdlpch.h>
#include <stdio.h>
extern HINSTANCE g_hInst;

// Initialize static variables
CList<CDLDebugLog *, CDLDebugLog *> CDLDebugLog::s_dlogList;
TCHAR                               CDLDebugLog::s_szMessage[MAX_DEBUG_STRING_LENGTH];
CMutexSem                           CDLDebugLog::s_mxsDLogList;
BOOL                                CDLDebugLog::s_bMessage(FALSE);
CMutexSem                           CDLDebugLog::s_mxsMessage;

CDLDebugLog::CDLDebugLog()
:m_DebugLogList(),
 m_fAddedDebugLogHead(FALSE),
 m_iRefCount(0)
{
    m_szFileName[0] = '\0';
    m_szUrlName[0] = '\0';
    m_szMainClsid[0] = '\0';
    m_szMainType[0] = '\0';
    m_szMainExt[0] = '\0';
    m_szMainUrl[0] = '\0';
}

CDLDebugLog::~CDLDebugLog()
{
    Clear();
}

int CDLDebugLog::AddRef()
{
    return ++m_iRefCount;
}

int CDLDebugLog::Release()
{
    ASSERT(m_iRefCount > 0);
    m_iRefCount--;
    if(m_iRefCount <= 0)
    {
        delete this;
        return 0;
    }
    else
        return m_iRefCount;
}

CDLDebugLog * CDLDebugLog::MakeDebugLog()
{
    return new CDLDebugLog();
}

// Delete all new'd data and start a new log
void CDLDebugLog::Clear()
{
    DebugLogElement            *pMsg = NULL;
    LISTPOSITION                pos;
    int                         iNumMessages;
    int                         i;

    // delete new'd messages
    iNumMessages = m_DebugLogList.GetCount();
    pos = m_DebugLogList.GetHeadPosition();
    for (i = 0; i < iNumMessages; i++) {
        pMsg = m_DebugLogList.GetNext(pos);
        delete pMsg;
    }
    m_DebugLogList.RemoveAll();
    m_fAddedDebugLogHead = FALSE;

    // commit any lingering CacheEntry
    if(m_szUrlName[0])
    {
        FILETIME     ftExpireTime;
        FILETIME     ftTime;

        GetSystemTimeAsFileTime(&ftTime);
        ftExpireTime.dwLowDateTime = (DWORD)0;
        ftExpireTime.dwHighDateTime = (DWORD)0;
        CommitUrlCacheEntry(m_szUrlName, m_szFileName, ftExpireTime,
                            ftTime, NORMAL_CACHE_ENTRY,
                            NULL, 0, NULL, 0);
    }
    m_szUrlName[0] = 0;
    m_szFileName[0] = 0;
}

// Initializes the main clsid, type, ext, and codebase of the debuglog from the
// corresponding values in the CCodeDownload
// If any of the CCodeDownload's parameters are NULL, they are ignored
// (An assertion is thrown if they are all NULL)
// for Retail: returns false if they are all NULL
BOOL CDLDebugLog::Init(CCodeDownload * pcdl)
{
    int iRes = 0;

    if(pcdl->GetMainDistUnit())
    {       
        iRes = WideCharToMultiByte(CP_ACP, 0, pcdl->GetMainDistUnit(), -1, m_szMainClsid,
                                   MAX_DEBUG_STRING_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }
    if(pcdl->GetMainType())
    {
        iRes = WideCharToMultiByte(CP_ACP, 0, pcdl->GetMainType(), -1, m_szMainType,
                                   MAX_DEBUG_STRING_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }                                    
    if(pcdl->GetMainExt())
    {
        iRes = WideCharToMultiByte(CP_ACP, 0, pcdl->GetMainExt(), -1, m_szMainExt,
                                   MAX_DEBUG_STRING_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }
    if(pcdl->GetMainURL())
    {
        iRes = WideCharToMultiByte(CP_ACP, 0, pcdl->GetMainURL(), -1, m_szMainUrl,
                                   INTERNET_MAX_URL_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }

    ASSERT(iRes != 0);

    return(iRes != 0);
}

// Initializes the main clsid, type, ext, and codebase of the debuglog
// If any of the parameters are NULL, they are ignored
// (An assertion is thrown if they are all NULL)
// for Retail: returns false if they are all NULL
BOOL CDLDebugLog::Init(LPCWSTR wszMainClsid, LPCWSTR wszMainType, LPCWSTR wszMainExt, LPCWSTR wszMainUrl)
{
    int iRes = 0;

    if(wszMainClsid)
    {
        iRes = WideCharToMultiByte(CP_ACP, 0, wszMainClsid, -1, m_szMainClsid,
                                   MAX_DEBUG_STRING_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }
    if(wszMainType)
    {
        iRes = WideCharToMultiByte(CP_ACP, 0, wszMainType, -1, m_szMainType,
                                   MAX_DEBUG_STRING_LENGTH, NULL, NULL);                           
        ASSERT(iRes != 0);
    }                                    
    if(wszMainExt)
    {
        WideCharToMultiByte(CP_ACP, 0, wszMainExt, -1, m_szMainExt,
                            MAX_DEBUG_STRING_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }
    if(wszMainUrl)
    {
        WideCharToMultiByte(CP_ACP, 0, wszMainUrl, -1, m_szMainUrl,
                            INTERNET_MAX_URL_LENGTH, NULL, NULL);
        ASSERT(iRes != 0);
    }

    ASSERT(iRes != 0);
    return(iRes != 0);
}

// Make the cache file for the debug log using the current main clsid, type, ext, 
// and url data.  The previous values in m_szUrlName and m_szFileName are cleaned 
// up and written over.
void CDLDebugLog::MakeFile()
{
    TCHAR szExtension[] = TEXT("HTM");

    if(m_szFileName[0])
    {
        return; // Only make the file if we don't already have one
    }

    m_szUrlName[0]  = 0;
    m_szFileName[0] = 0;

    if(m_szMainClsid[0])
    {
        wnsprintf(m_szUrlName, sizeof(m_szUrlName)-1, "?CodeDownloadErrorLog!name=%s", m_szMainClsid);
    }
    else if(m_szMainType[0])
    {
        wnsprintf(m_szUrlName, sizeof(m_szUrlName)-1, "?CodeDownloadErrorLog!type=%s", m_szMainType);
    }
    else if(m_szMainExt[0])
    {
        wnsprintf(m_szUrlName, sizeof(m_szUrlName)-1, "?CodeDownloadErrorLog!ext=%s", m_szMainExt);
    }
    else
    {
        wnsprintf(m_szUrlName, sizeof(m_szUrlName)-1, "?CodeDownloadErrorLog!");
    }

    CreateUrlCacheEntry(m_szUrlName, 0, szExtension, m_szFileName, 0);
}

// ---------------------------------------------------------------------------
// %%Function: CDLDebugLog::DebugOut(int iOption, const char *pscFormat, ...)
//   Replacement for UrlMkDebugOut() and CCodeDownload::CodeDownloadDebugOut
//   calls to log code download debug/error messages
// ---------------------------------------------------------------------------

void CDLDebugLog::DebugOut(int iOption, BOOL fOperationFailed,
                                         UINT iResId, ...)
{
    // Temp solution to prevent buffer overruns in debug logging code.
    // Long term, the printfs should be constrained.  It will be a must
    // if URLs become fully dynamic.
    static char             szDebugString[MAX_DEBUG_STRING_LENGTH*5];
    static char             szFormatString[MAX_DEBUG_FORMAT_STRING_LENGTH];
    va_list                 args;

    LoadString(g_hInst, iResId, szFormatString, MAX_DEBUG_FORMAT_STRING_LENGTH);
    va_start(args, iResId);
    vsprintf(szDebugString, szFormatString, args);
    va_end(args);

    DebugOutPreFormatted(iOption, fOperationFailed, szDebugString);
}


// Debug out taken a preformatted string instead of a resid format address and
// an arbitrary list of arguments.  szDebugString is the string which will be outputted
// as the debug statement
void CDLDebugLog::DebugOutPreFormatted(int iOption, BOOL fOperationFailed,
                                       LPTSTR szDebugString)
{
    static TCHAR           szUrlMkDebugOutString[MAX_DEBUG_STRING_LENGTH];
    DebugLogElement        *pdbglog = NULL;
    DebugLogElement        *pdbglogHead = NULL;


    pdbglog = new DebugLogElement(szDebugString);
    if(! pdbglog)
        return;
    wnsprintf(szUrlMkDebugOutString, MAX_DEBUG_STRING_LENGTH-1, "CODE DL:%s", szDebugString);
    UrlMkDebugOut((iOption,szUrlMkDebugOutString));

    if (pdbglog != NULL) {
        m_DebugLogList.AddTail(pdbglog);
        if (fOperationFailed && !m_fAddedDebugLogHead) {
            m_fAddedDebugLogHead = TRUE;
            pdbglogHead = new DebugLogElement("--- Detailed Error Log Follows ---\n");
            if(! pdbglogHead)
                return;
            m_DebugLogList.AddHead(pdbglogHead);
            pdbglogHead = new DebugLogElement(*pdbglog);
            if(! pdbglogHead)
                return;
            m_DebugLogList.AddHead(pdbglogHead);
        }
    }
}

#define DEBUG_LOG_HTML_START            TEXT("<html><pre>\n")
#define DEBUG_LOG_HTML_END              TEXT("\n</pre></html>")
#define PAD_DIGITS_FOR_STRING(x) (((x) > 9) ? TEXT("") : TEXT("0"))

// ---------------------------------------------------------------------------
// %%Function: CDLDebugLog::DumpDebugLog()
//   Output the debug error log. This log is written as a cache entry.
// pszCacheFileName is an outparam for the name of the file in the cache,
// cbBufLen is the length of the buffer
// szErrorMsg is the error message causing the dump, and hrError the hr causing
//   the dump
// ---------------------------------------------------------------------------

void CDLDebugLog::DumpDebugLog(LPTSTR pszCacheFileName, int cbBufLen, LPTSTR szErrorMsg,
                                 HRESULT hrError)
{
    DebugLogElement     *pMsg = NULL;
    LPCSTR               pszStr = NULL;
    LISTPOSITION         pos = NULL;
    int                  iNumMessages = 0;
    int                  i = 0;
    HANDLE               hFile = INVALID_HANDLE_VALUE;
    FILETIME             ftTime;
    FILETIME             ftExpireTime;
    DWORD                dwBytes = 0;
    SYSTEMTIME           systime;
    static TCHAR         pszHeader[MAX_DEBUG_STRING_LENGTH];
    static const TCHAR  *ppszMonths[] = {TEXT("Jan"), TEXT("Feb"), TEXT("Mar"), 
                                         TEXT("Apr"), TEXT("May"), TEXT("Jun"),
                                         TEXT("Jul"), TEXT("Aug"), TEXT("Sep"), 
                                         TEXT("Oct"), TEXT("Nov"), TEXT("Dec")};
    
    // Get the filename and put it in the out LPTSTR
    if(!m_szFileName[0])
        MakeFile();
    if(pszCacheFileName)
        lstrcpyn(pszCacheFileName,m_szFileName, cbBufLen);

    iNumMessages = m_DebugLogList.GetCount();
    pos = m_DebugLogList.GetHeadPosition();
    if (pos) {
        pMsg = m_DebugLogList.GetAt(pos);
        if (pMsg != NULL) {
            hFile = CreateFile(m_szFileName, GENERIC_READ | GENERIC_WRITE,
                               0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                               NULL);
            if (hFile != INVALID_HANDLE_VALUE) {
                // Write the header
                WriteFile(hFile, DEBUG_LOG_HTML_START, strlen(DEBUG_LOG_HTML_START),
                          &dwBytes, NULL);
                GetLocalTime(&systime);
                wnsprintf(pszHeader, ARRAY_ELEMENTS(pszHeader)-1, "*** Code Download Log entry (%s%d %s %d @ %s%d:%s%d:%s%d) ***\n",
                         PAD_DIGITS_FOR_STRING(systime.wDay), systime.wDay,
                         ppszMonths[systime.wMonth - 1],
                         systime.wYear,
                         PAD_DIGITS_FOR_STRING(systime.wHour), systime.wHour,
                         PAD_DIGITS_FOR_STRING(systime.wMinute), systime.wMinute,
                         PAD_DIGITS_FOR_STRING(systime.wSecond), systime.wSecond);
                WriteFile(hFile, pszHeader, strlen(pszHeader), &dwBytes, NULL);                     

                // Write what error caused this dump
                wnsprintf(pszHeader, ARRAY_ELEMENTS(pszHeader)-1, "Code Download Error: (hr = %lx) %s\n",
                         hrError,
                         (szErrorMsg == NULL) ? ("(null)") : (szErrorMsg));
                WriteFile(hFile, pszHeader, strlen(pszHeader), &dwBytes, NULL);

                wnsprintf(pszHeader, ARRAY_ELEMENTS(pszHeader)-1, "Operation failed. Detailed Information:\n"
                                    "     CodeBase: %s\n"
                                    "     CLSID: %s\n"
                                    "     Extension: %s\n"
                                    "     Type: %s\n\n",
                                    m_szMainUrl,
                                    m_szMainClsid,
                                    m_szMainExt,
                                    m_szMainType);
                WriteFile(hFile, pszHeader, strlen(pszHeader), &dwBytes, NULL);

                // Write the Debug Log
                pos = m_DebugLogList.GetHeadPosition();
                iNumMessages = m_DebugLogList.GetCount();
                for (i = 0; i < iNumMessages; i++) {
                    pMsg = m_DebugLogList.GetNext(pos);
                    pszStr = pMsg->GetLogMessage();
                    WriteFile(hFile, pszStr, strlen(pszStr), &dwBytes, NULL);
                }

                // Close and clean
                WriteFile(hFile, DEBUG_LOG_HTML_END, strlen(DEBUG_LOG_HTML_END),
                          &dwBytes, NULL);
                CloseHandle(hFile);
                GetSystemTimeAsFileTime(&ftTime);
                ftExpireTime.dwLowDateTime = (DWORD)0;
                ftExpireTime.dwHighDateTime = (DWORD)0;
                CommitUrlCacheEntry(m_szUrlName, m_szFileName, ftExpireTime,
                                    ftTime, NORMAL_CACHE_ENTRY,
                                    NULL, 0, NULL, 0);
                m_fAddedDebugLogHead = FALSE;
                m_szUrlName[0] = NULL;
                m_szFileName[0] = NULL;
            }
        }
    }
}


// returns TRUE if there is already a message saved
// (If there is a message saved already, it will not be written over
// unless bOverwrite is true)
BOOL CDLDebugLog::SetSavedMessage(LPCTSTR szMessage, BOOL bOverwrite) 
{
    CLock lck(s_mxsMessage);
    BOOL bRet = FALSE;

    if(s_bMessage)
        bRet = TRUE;

    if((!s_bMessage) || bOverwrite)
    {
        lstrcpyn(s_szMessage, szMessage, MAX_DEBUG_STRING_LENGTH); 
        s_bMessage=TRUE;
    }

    return bRet;
}

LPCTSTR CDLDebugLog::GetSavedMessage() 
{
    CLock lck(s_mxsMessage);
    if(!s_bMessage) // Make sure to return an empty string if one has not been set
    {
        s_szMessage[0] = '\0';
    } 
    return s_szMessage;
}

// add a debug log to the global list
void CDLDebugLog::AddDebugLog(CDLDebugLog * dlog)
{
    CLock lck(s_mxsDLogList);
    if(dlog)
        s_dlogList.AddTail(dlog);
}

// Remove a given debug log from the global list
void CDLDebugLog::RemoveDebugLog(CDLDebugLog * dlog)
{
    CLock lck(s_mxsDLogList);
    if(dlog)
    {
        POSITION pos = s_dlogList.Find(dlog);
        if(pos != NULL)
            s_dlogList.RemoveAt(pos);
    }
}


// Gets the debug log with the given clsid, mime type, file extension or url code base.
// Naming priority is the same as at debug file urlname creation: clsid, then type, then ext, then url
// The names are checked in this order (so two logs with the same extension but different classids will never
// be confused, since clsids are checked before extensions)
// If an earlier name is NULL or doesn't produce a match, the next name is checked.
// If all names fails to produce a match, the return value is NULL
CDLDebugLog * CDLDebugLog::GetDebugLog(LPCWSTR wszMainClsid, LPCWSTR wszMainType, LPCWSTR wszMainExt, LPCWSTR wszMainUrl)
{
    TCHAR szComparer[MAX_DEBUG_STRING_LENGTH];
    POSITION pos = NULL;
    szComparer[0] = NULL;
    CDLDebugLog * dlogCur = NULL;
    const int iSwitchMax = 4;
    LPCWSTR ppwszMains[] = {wszMainClsid, wszMainType, wszMainExt, wszMainUrl};
    int iSwitch = iSwitchMax;
    int iRes = 0;

    // Find the first non-empty name
    for(iSwitch = 0; iSwitch < iSwitchMax; iSwitch++)
    {
        if((ppwszMains[iSwitch]) && (ppwszMains[iSwitch])[0])
            break;
    }

    if(iSwitch >= iSwitchMax)
        return NULL;


    // Grab mutex for accesing the list
    CLock lck(s_mxsDLogList);

    // Loop over the names; a higher array value means a lower priority name;
    // don't check a lower priority name unless all higher priority names have
    // failed
    while(iSwitch < iSwitchMax)
    {
        iRes = WideCharToMultiByte(CP_ACP, 0, ppwszMains[iSwitch], -1, szComparer,
                                   MAX_DEBUG_STRING_LENGTH, NULL, NULL);
        if(iRes == 0)
            return NULL;

        // Look through the entire list for a debuglog whose name (clsid, type, ext, or url)
        // matches the given one
        for(pos = s_dlogList.GetHeadPosition(); pos != NULL; )
        {
            dlogCur = s_dlogList.GetNext(pos);
            switch(iSwitch)
            {
            case 0:
                if(!lstrcmp(szComparer, dlogCur->GetMainClsid()))
                    return dlogCur;
                break;
            case 1:
                if(!lstrcmp(szComparer, dlogCur->GetMainType()))
                    return dlogCur;
                break;
            case 2:
                if(!lstrcmp(szComparer, dlogCur->GetMainExt()))
                    return dlogCur;
                break;
            case 3:
                if(!lstrcmp(szComparer, dlogCur->GetMainUrl()))
                    return dlogCur;
                break;
            default:
                break;
            }
        }
        iSwitch++;
    }

    // No match of any of the non-NULL passed in names was found
    return NULL;
}

DebugLogElement::DebugLogElement(const DebugLogElement &ref)
{
    SetLogMessage(ref.m_szMessage);
}

DebugLogElement::DebugLogElement(LPSTR szMessage)
: m_szMessage(NULL)
{
    SetLogMessage(szMessage);
}

DebugLogElement::~DebugLogElement()
{
    if (m_szMessage != NULL)
    {
        delete [] m_szMessage;
    }
}

HRESULT DebugLogElement::SetLogMessage(LPSTR szMessage)
{
    HRESULT             hr = S_OK;

    if (m_szMessage != NULL)
    {
        delete [] m_szMessage;
        m_szMessage = NULL;
    }
    m_szMessage = new char[strlen(szMessage) + 1];
    if (m_szMessage != NULL)
    {
        strcpy(m_szMessage, szMessage);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\clist.cxx ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//  CLIST.CPP
//

//  HISTORY:
//  
//  9/10/95     philco      Created.
//  4/05/96     VatsanP     Copied from MSHTML to URLMON\DOWNLOAD
//                          to use for the code downloader
//                          changed name to CLIST.CXX to make JoahnnP happy :)
//

//
//  Templated list class "borrowed" from MFC 3.0.  Used to manage a
//  list of IOleObject pointers to embedded items.
//

#include <cdlpch.h>
#ifndef unix
#include "..\inc\clist.hxx"
#else
#include "../inc/clist.hxx"
#endif /* unix */

BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "AfxIsValidAddress",
                "%#x, %x, %B",
                lp, nBytes, bReadWrite
                ));
                
    // simple version using Win-32 APIs for pointer validation.
    BOOL bRet = (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
                    (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));

    DEBUG_LEAVE(bRet);
    return bRet;
}

CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CPlex::Create",
                "%#x, %x, %x",
                &pHead, nMax, cbElement
                ));
                
    ASSERT(nMax > 0 && cbElement > 0);


    CPlex* p = (CPlex*) new (BYTE[sizeof(CPlex) + nMax* cbElement]);
            // may throw exception
           
    Assert(p != NULL);
    
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)

    DEBUG_LEAVE(p);
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CPlex::FreeDataChain",
                "this=%#x",
                this
                ));
                
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete (bytes);
        p = pNext;
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\csetup.cxx ===
// ===========================================================================
// File: CSETUP.CXX
//    CSetup class implementation
//


#include <cdlpch.h>
#include "verp.h"

#include <advpub.h>
#include "advpkp.h"
extern CRunSetupHook g_RunSetupHook;
extern BOOL g_bRunOnWin95;

inline
DWORD Win32ErrorFromHResult( HRESULT hr)
{
    // BUGBUG: assert failed?
    //BUGBUG: assert win32 facility?
    return (DWORD)(hr & 0x0000ffff);
}

DWORD GetFullPathNameA_Wrap(
  LPCSTR lpFileName,  // file name
  DWORD nBufferLength, // size of path buffer
  LPSTR lpBuffer,     // path buffer
  LPSTR *lpFilePart   // address of file name in path
);


// ---------------------------------------------------------------------------
// %%Function: CSetup::CSetup
//
//  Csetup obj: zero or more associated with every CDownload obj
//  Some CDownload's may have no CSetup (eg. INF file)
// ---------------------------------------------------------------------------
CSetup::CSetup(LPCSTR pSrcFileName, LPCSTR pBaseFileName, FILEXTN extn, 
                LPCSTR pDestDir, HRESULT *phr, DESTINATION_DIR dest)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CSetup::CSetup",
                "this=%#x, %.80q, %.80q, %#x, %.80q, %#x, %#x",
                this, pSrcFileName, pBaseFileName, extn, pDestDir, phr, dest
                ));
                
    m_pSetupnext = NULL;

    m_extn = extn;
    m_dest = dest;

    m_flags = 0;
    m_advcopyflags = 0;     // flags for AdvInstallFile

    m_state = INSTALL_INIT;

    m_pExistDir = NULL;

    if (pDestDir) {
        m_pExistDir = new char [lstrlen(pDestDir)+1];

        if (m_pExistDir)
            lstrcpy((char *)m_pExistDir, pDestDir);
        else
            *phr = E_OUTOFMEMORY;
    }

    Assert(pBaseFileName);
    if (pBaseFileName) {
        m_pBaseFileName = new char [lstrlen(pBaseFileName)+1];

        if (m_pBaseFileName)
            lstrcpy(m_pBaseFileName, pBaseFileName);
        else
            *phr = E_OUTOFMEMORY;
    }

    if (pSrcFileName) {

        m_pSrcFileName = new char [lstrlen(pSrcFileName)+1];

        if (m_pSrcFileName)
            lstrcpy(m_pSrcFileName, pSrcFileName);
        else
            *phr = E_OUTOFMEMORY;
    }

    m_bExactVersion = FALSE;

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CSetup::~CSetup
// ---------------------------------------------------------------------------
CSetup::~CSetup()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CSetup::~CSetup",
                "this=%#x",
                this
                ));
                
    if (m_pSrcFileName)
        delete (LPSTR)m_pSrcFileName;

    if (m_pBaseFileName)
        delete (LPSTR)m_pBaseFileName;

    if (m_pExistDir)
        delete (LPSTR)m_pExistDir;

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CSetup::SetSrcFileName
// ---------------------------------------------------------------------------
HRESULT CSetup::SetSrcFileName(LPCSTR pSrcFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetup::SetSrcFileName",
                "this=%#x, %.80q",
                this, pSrcFileName
                ));
                
    if (m_pSrcFileName) {
        SAFEDELETE(m_pSrcFileName);
    }


    ASSERT(pSrcFileName);
    ASSERT(pSrcFileName[0] != '\0');

    HRESULT hr = S_OK;

    if (pSrcFileName) {

        m_pSrcFileName = new char [lstrlen(pSrcFileName)+1];

        if (m_pSrcFileName)
            lstrcpy(m_pSrcFileName, pSrcFileName);
        else
            hr = E_OUTOFMEMORY;
    } else {
        hr = E_INVALIDARG;
    }

    DEBUG_LEAVE(hr);
    return hr;
}



// ---------------------------------------------------------------------------
// %%Function: CSetup::CheckForNameCollisions
// This checks if the given cache dir has name collision for this file
// ---------------------------------------------------------------------------
HRESULT CSetup::CheckForNameCollision(CCodeDownload *pcdl, LPCSTR szCacheDir)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetup::CheckForNameCollision",
                "this=%#x, %#x, %.80q",
                this, pcdl, szCacheDir
                ));

    HRESULT hr = S_OK;
    char szDest[MAX_PATH];


    // INFs don't matter for name collisions or prev version exists
    // the way to handle this is to doc that evryone should choose
    // same name INFs as their primary OCX. This way the INF and OCX will
    // reside in the same dir (szCacheDir) and the primary OCX will handle
    // name collisions and be located in a non-conflicting dir.
    // So, INFs will always be overwritten. If someone defies convention
    // we might end up losing an INF, so we have to gerbage collect the
    // OCX to recover space on disk.

    if ( (m_extn == FILEXTN_INF) || (m_extn == FILEXTN_OSD))
        goto Exit;


    if (m_pExistDir)     // if a previous version exists and this is a
        goto Exit;      // and this is a overwrite all OK (no accidental
                        // name collision issues


    // we don't care now if the dest is either Windows or System dir
    // This case will be tackled in CSetup::DoSetup after we have established
    // a non-colliding OCXCACHE dir for m_dest == LDID_OCXCACHE case
    // to put rest of this OCX files in
    if ((m_dest == LDID_SYS) || (m_dest == LDID_WIN))
        goto Exit;

    if (lstrlen(m_pBaseFileName) + lstrlen(szCacheDir) + 1 > MAX_PATH) {
        // Fatal! The length of the filepath is beyond MAX_PATH.
        hr = E_UNEXPECTED;
        goto Exit;
    }

    lstrcpy(szDest, szCacheDir);
    lstrcat(szDest, "\\");
    lstrcat(szDest, m_pBaseFileName);

    if (GetFileAttributes(szDest) != -1) {    // file exists?


        if (!IsEqualGUID(pcdl->GetClsid() , CLSID_NULL)) {
            hr = S_FALSE;                       // report name conflict
            goto Exit;
        }

        // check if that file implements the main clsid
        HRESULT hr1 = CheckFileImplementsCLSID(szDest, pcdl->GetClsid());

        if (FAILED(hr1))
            hr = S_FALSE;                       // report name conflict
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CSetup::InstallFile
// ---------------------------------------------------------------------------
HRESULT CSetup::InstallFile(CCodeDownload *pcdl, LPSTR szDest, int iLen, LPWSTR szStatusText, 
                            LPUINT pcbStatusText)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetup::InstallFile",
                "this=%#x, %#x, %.80q, %.80wq, %#x",
                this, pcdl, szDest, szStatusText, pcbStatusText
                ));
                
    char *pSrcBaseName;
    char pSrcDir[MAX_PATH];
    HWND hWnd = pcdl->GetClientBinding()->GetHWND();
    HRESULT hr = S_OK;
    char szDestDir[MAX_PATH];
    char szDestDirShort[MAX_PATH];
    DWORD dwMachineType = 0;


    SetState(INSTALL_COPY);

    GetDestDir(pcdl, szDestDir, sizeof(szDestDir));

    if (g_bRunOnWin95) {
        if (!GetShortPathName(szDestDir, szDestDirShort, MAX_PATH)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        lstrcpy(szDestDir, szDestDirShort);
    }

    StrNCpy(szDest, szDestDir, iLen);
    StrCatBuff(szDest, "\\", iLen);
    StrCatBuff(szDest, m_pBaseFileName, iLen);

    //may be MAX_PATH (instead of *pcbStatusText, which in the only case this is called is = INTERNET_MAX_URL_LENGTH + 2*MAX_PATH)
    *pcbStatusText = MultiByteToWideChar(CP_ACP, 0, szDest, -1, szStatusText,
                        MAX_PATH);

    pcdl->GetClientBSC()->OnProgress( INSTALL_COPY, INSTALL_PHASES,
        BINDSTATUS_INSTALLINGCOMPONENTS, szStatusText);


    // get src dir + srcbasename out of src filename
    if (!GetFullPathNameA_Wrap(m_pSrcFileName, MAX_PATH, 
            pSrcDir, &pSrcBaseName)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    // Installed catalog => this setup might be for a SFP-protected file.
    // So check if this file is protected, and if it is 
    if (g_bNT5OrGreater && pcdl->IsCatalogInstalled())
    {
        LPSTR pszFile;
        DWORD cbLen = lstrlen(szDestDir) + lstrlen(m_pBaseFileName);
        pszFile = new CHAR[cbLen+2];
        BOOL bRet;

        if (pszFile)
        {
            lstrcpy(pszFile, szDestDir);
            lstrcat(pszFile, "\\");
            lstrcat(pszFile, m_pBaseFileName);

            bRet = pcdl->IsFileProtected(pszFile);
            delete [] pszFile;

            if (bRet && FAILED(pcdl->VerifyFileAgainstSystemCatalog(pSrcDir, NULL, NULL)))
            {
                hr = INET_E_CANNOT_REPLACE_SFP_FILE;
                goto Exit;
            }
        }
    }

    Assert(pSrcDir != pSrcBaseName);
    Assert(pSrcBaseName);

    *(pSrcBaseName-1) = '\0'; // make a dir out of pSrcDir

    // sniff machine type of PE
            
    hr = IsCompatibleFile(m_pSrcFileName, &dwMachineType);

    if (hr == HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH)) {

        // if its of wrong CPU flavor fail and clean up the OCX
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_INCOMPATIBLE_BINARY, m_pSrcFileName);
        goto Exit;
    }

#ifdef WX86
    if (g_fWx86Present && dwMachineType == IMAGE_FILE_MACHINE_I386) {
        //
        // From here on out, all other binaries downloaded must also be i386
        //
        hr = pcdl->GetMultiArch()->RequireAlternateArch();
        if (FAILED(hr)) {
            //
            // We're in the middle of downloading an Alpha piece, and we ended
            // up finding an x86-only piece.  Fail the download.
            //
            pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_INCOMPATIBLE_BINARY, m_pSrcFileName);
            goto Exit;
        }
    }

    if (pcdl->GetMultiArch()->GetRequiredArch() == PROCESSOR_ARCHITECTURE_INTEL) {
        //
        // Use x86 advpack.dll to install
        //
        hr = g_RunSetupHook.AdvInstallFileX86(hWnd, pSrcDir, pSrcBaseName,
                                              szDestDir, m_pBaseFileName,
                                              m_advcopyflags, 0);
    } else {
        //
        // Use native advpack.dll to install
        //
        hr = g_RunSetupHook.AdvInstallFile(hWnd, pSrcDir, pSrcBaseName,
                                           szDestDir, m_pBaseFileName,
                                           m_advcopyflags, 0);
    }
#else
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "g_RunSetupHook.AdvInstallFile",
                "%#x, %.80q, %.80q, %.80q, %.80q, %x",
                hWnd, pSrcDir, pSrcBaseName, szDestDir, m_pBaseFileName, m_advcopyflags
                ));
                
    hr = g_RunSetupHook.AdvInstallFile(hWnd, pSrcDir, pSrcBaseName,
                                       szDestDir, m_pBaseFileName,
                                       m_advcopyflags, 0);
    DEBUG_LEAVE(hr);
#endif

    if (FAILED(hr)) {
        goto Exit;
    }

    // if error_success_reboot_required
    // then preserve this and return for overall download
    // if overall download fails beyond this point then, we should raise the
    // CIP and then fail with the subsequent error.

    if (hr == ERROR_SUCCESS_REBOOT_REQUIRED) {
        pcdl->SetRebootRequired();
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CSetup::GetDestDir
// ---------------------------------------------------------------------------
HRESULT CSetup::GetDestDir(CCodeDownload *pcdl, LPSTR szDestDir, int iLen)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetup::GetDestDir",
                "this=%#x, %#x, %.80q",
                this, pcdl, szDestDir
                ));

    if (!m_pExistDir) {

        // no existing version of file on client machine
        // if no suggested dest dir was specified move to ocxcachedir
        switch (m_dest) {

        case LDID_SYS:
#ifdef WX86
                if (pcdl->GetMultiArch()->GetRequiredArch() == PROCESSOR_ARCHITECTURE_INTEL) {
                    // An x86 control is downloading.  Tell GetSystemDirectory
                    // to return the sys32x86 dir instead of system32
                    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = TRUE;
                }
#endif
                GetSystemDirectory(szDestDir, MAX_PATH);
                break;

        case LDID_WIN:
                GetWindowsDirectory(szDestDir, MAX_PATH);
                break;

        case LDID_OCXCACHE:

                Assert(pcdl->GetCacheDir());
                StrNCpy(szDestDir, pcdl->GetCacheDir(), iLen);
                break;

        }

    } else {
        StrNCpy(szDestDir, m_pExistDir, iLen);
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}


// ---------------------------------------------------------------------------
// %%Function: CSetup::DoSetup
//    The main action item for CSetup
//    installs file in proper dest dir (if null) defaults to ocxcache dir
//    It then registers the file if registerable
// ---------------------------------------------------------------------------
HRESULT CSetup::DoSetup(CCodeDownload *pcdl, CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetup::DoSetup",
                "this=%#x, %#x, %#x",
                this, pcdl, pdl
                ));
                
    char szDest[MAX_PATH];
    BOOL bModuleUsage = TRUE;

    // url + filename + other parts of msg 
    WCHAR szStatusText[INTERNET_MAX_URL_LENGTH+MAX_PATH+MAX_PATH];

    IBindStatusCallback* pClientBSC = pcdl->GetClientBSC();
    HRESULT hr = S_OK;
    UINT nStatusText =  0;

    BOOL bReboot = FALSE;

    // side-effect of below: changes szStatusText, nStatusText and 
    // fills in szDest to be destination file
    hr = InstallFile(pcdl, szDest, sizeof(szDest), szStatusText, &nStatusText);

    if (hr == ERROR_SUCCESS_REBOOT_REQUIRED) {
        bReboot = TRUE;
        hr = S_OK;
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_FILE_INUSE, szDest);
    }

    if (hr != S_OK)     // skip or abort?
        goto Exit;


    SetState(INSTALL_REGISTER);

    if ((m_extn == FILEXTN_INF) || (m_extn == FILEXTN_OSD)) {
        // nothing to register!
        // but, remember the name of the installed INF/OSD
        // to store away in registry.

        hr = pcdl->SetManifest(m_extn, szDest);
        goto Exit;
    }

    pClientBSC->OnProgress( INSTALL_REGISTER, INSTALL_PHASES, BINDSTATUS_INSTALLINGCOMPONENTS, szStatusText);

    // document one thing and do something else!
    // if its not an EXE try to self register no matter what?!
    // unless overriden not to.
    if (m_extn == FILEXTN_EXE) {

        BOOL bLocalServer = (UserOverrideRegisterServer() && WantsRegisterServer()) || (!UserOverrideRegisterServer() && SupportsSelfRegister(szDest));

        if ( bLocalServer ||
            ((pdl->GetExtn() != FILEXTN_CAB) && !UserOverrideRegisterServer())){

            pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_DLL_REGISTERED, szDest);
            hr = pcdl->InstallOCX(szDest, m_extn, bLocalServer);

            // if we executed an EXE that was not a local server it is
            // probably just a setup EXE that needs to be cleaned up when
            // done. So we don't do ModuleUsage for those.
            if (!bLocalServer)
                bModuleUsage = FALSE;
        }

    } else {

        if (!UserOverrideRegisterServer() || WantsRegisterServer()) {
            if (!bReboot) {
                hr = pcdl->InstallOCX(szDest, m_extn, FALSE);
            } else {

                // we are going to reboot the machine to install the new
                // version of the OCX. So, no point trying to register it here
                // instead we will make it register on the next reboot
                // and proceed here as if it succeded.


                // what could be broken here is that if we proceed and
                // some other setup required this OCX to be registered 
                // then it will fail
                // the work around is for those guys have interdependent
                // registerations to install using a custom EXE that will
                // force the user to reboot.

                if (IsRegisterableDLL(m_pSrcFileName) == S_OK) {
                    hr = pcdl->DelayRegisterOCX(szDest, m_extn);
                    pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_DLL_REGISTERED, szDest);
                }

            }
        }
    }

    if (FAILED(hr)) {

        if (!m_pExistDir)
            DeleteFile(szDest);

    } else {

        // make sure we have a ref count for the code downloader in
        // shareddlls as well as mark us as a client in the usage section
        // if there is no prev version we are upgrading over
        // mark us as the owner

        if (bModuleUsage) {
            if (m_bExactVersion) {
                // Need to do this because in a exact version scenario,
                // we may have upgraded/downgraded in which case m_pExistDir
                // is non-NULL. We want us to be listed as our own owner
                // instead of "Unknown Owner" so OCCache can remove us later.
                hr = pcdl->QueueModuleUsage(szDest, MU_OWNER);
                if (FAILED(hr)) {
                    goto Exit;
                }
            }
            else {
                if (FAILED((hr= pcdl->QueueModuleUsage(szDest,
                                        (m_pExistDir)?MU_CLIENT:MU_OWNER))))
                    goto Exit;
            }
        }

    }

Exit:

    if (FAILED(hr)) {
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_DOSETUP_FAILED, hr, m_pBaseFileName, m_pExistDir, m_dest);
    } else {
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_SETUP_COMPLETE, m_pBaseFileName, m_pExistDir, m_dest);
    }

    SetState(INSTALL_DONE);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\dl.cxx ===
// ===========================================================================
// File: DL.CXX
//    implements CDownload, CBindStatusCallback classes
//

#include <cdlpch.h>

// SILENT MODE
#include <winineti.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <comcat.h>

#include <initguid.h>       // office antivirus goo
#define AVVENDOR            // don't look at unwanted office defs
#include <msoav.h>

extern char g_szOCXTempDir[MAX_PATH];
extern IEnumFORMATETC *g_pEFmtETC;
extern FORMATETC g_rgfmtetc[];

// ---------------------------------------------------------------------------
// %%Function: CDownload::CDownload
// CDownload is the basic download obj.
// ---------------------------------------------------------------------------

CDownload::CDownload(LPCWSTR szURL, FILEXTN extn, HRESULT *phr)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::CDownload",
                "this=%#x, %.80wq, %#x, %#x",
                this, szURL, extn, phr
                ));
                
    DllAddRef();
    DWORD len = lstrlenW(szURL); // make private copy

    m_url = new WCHAR [len + 1];

    if (m_url)
        StrCpyW(m_url, szURL);
    else
        *phr = E_OUTOFMEMORY;

    m_pmk = 0;
    m_pbc = 0;
    m_pbsc = 0;

    m_pdlnext= NULL;

    m_ParentCDL.RemoveAll();

    m_extn = extn;
    m_pFileName = NULL; // we don't know the dest filename
                        // till we create a temp file in the first
                        // notification of OnDataAvailable
                        // This is guaranteed to get set before
                        // OnStopBinding

    m_ulProgress = 0;
    m_ulProgressMax = 0;

    m_state = DLSTATE_INIT;

    m_psess = NULL;
    m_pFilesToExtract = NULL;

    m_pSetuphead = NULL;

    m_hPostData = NULL;
    m_cbPostData = 0;

    m_hrOSB = S_OK;
    m_hrStatus = S_OK;
    m_hrResponseHdr = S_OK;

    m_bCompleteSignalled = FALSE;

    m_flags = DL_FLAGS_INIT;

    m_SetupHooks.RemoveAll();

    m_JavaSetupList.RemoveAll();

    m_pUnkForCacheFileRelease = NULL;

    m_pbJavaTrust = NULL;

    m_wszDistUnit = NULL;

    m_pcbhList = NULL;
    m_ppmkContext = NULL;
    m_grfBINDF = 0;

    m_bExactVersion = FALSE;

    DEBUG_LEAVE(0);
}  // CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::~CDownload
// ---------------------------------------------------------------------------

CDownload::~CDownload()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::~CDownload",
                "this=%#x",
                this
                ));
                
    int               i;
    CCodeBaseHold    *pcbh = NULL;
    LISTPOSITION      lpos = 0;

    CleanUp();
    LISTPOSITION pos = m_ParentCDL.GetHeadPosition();
    int iNum = m_ParentCDL.GetCount();

    Assert(iNum == 0);
    for (i=0; i < iNum; i++) {
        CParentCDL *pParentCDL = m_ParentCDL.GetNext(pos); // pass ref!
        delete pParentCDL;
    }
    m_ParentCDL.RemoveAll();

    if (m_pcbhList != NULL) {
        lpos = m_pcbhList->GetHeadPosition();
        while (lpos) {
            pcbh = m_pcbhList->GetNext(lpos);
            delete pcbh;
        }
        m_pcbhList->RemoveAll();
    }
    SAFEDELETE(m_pcbhList);
    SAFEDELETE(m_wszDistUnit);

    pos = m_SetupHooks.GetHeadPosition();
    iNum = m_SetupHooks.GetCount();
    for (i=0; i < iNum; i++) {
        CSetupHook *pSetupHook = m_SetupHooks.GetNext(pos); // pass ref!
        delete pSetupHook;
    }
    m_SetupHooks.RemoveAll();

    pos = m_JavaSetupList.GetHeadPosition();
    iNum = m_JavaSetupList.GetCount();
    for (i=0; i < iNum; i++) {
        CJavaSetup *pJavaSetup = m_JavaSetupList.GetNext(pos); // pass ref!
        delete pJavaSetup;
    }
    m_JavaSetupList.RemoveAll();
    DllRelease();

    DEBUG_LEAVE(0);
}  // ~CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::HasJavaPermissions
// ---------------------------------------------------------------------------
BOOL
CDownload::HasJavaPermissions()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CDownload::HasJavaPermissions",
                "this=%#x",
                this
                ));
                
    if (m_pbJavaTrust) {
        // new jaavcypt > 2151 succeeds even if one of activex/java
        // is allowed

        DEBUG_LEAVE((m_pbJavaTrust->pbJavaPermissions != NULL));
        return  (m_pbJavaTrust->pbJavaPermissions != NULL);
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}
// ---------------------------------------------------------------------------
// %%Function: CDownload::HasAllActiveXPermissions
// ---------------------------------------------------------------------------
BOOL
CDownload::HasAllActiveXPermissions()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CDownload::HasAllActiveXPermissions",
                "this=%#x",
                this
                ));
                
    PJAVA_TRUST              pbJavaTrust = NULL;

    if (m_pbJavaTrust) {
        // new jaavcypt > 2151 succeeds even if one of activex/java
        // is allowed

        DEBUG_LEAVE(m_pbJavaTrust->fAllActiveXPermissions);
        return  m_pbJavaTrust->fAllActiveXPermissions;
    }
    else {
        pbJavaTrust = GetCodeDownload()->GetJavaTrust();
        if (pbJavaTrust) {
        
            DEBUG_LEAVE(pbJavaTrust->fAllActiveXPermissions);
            return pbJavaTrust->fAllActiveXPermissions;
        }
    }
    
    DEBUG_LEAVE(FALSE);
    return FALSE;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::CompleteSignal
// ---------------------------------------------------------------------------
HRESULT
CDownload::CompleteSignal(HRESULT hrOSB, HRESULT hrStatus, HRESULT hrResponseHdr, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::CompleteSignal",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, hrOSB, hrStatus, hrResponseHdr, szError
                ));

    int i, iNum;
    LISTPOSITION pos;

    m_hrOSB = hrOSB;
    m_hrStatus = hrStatus;
    m_hrResponseHdr = hrResponseHdr;

    m_bCompleteSignalled = TRUE;

restart:

    iNum = m_ParentCDL.GetCount();
    Assert(iNum);

    pos = m_ParentCDL.GetHeadPosition();

    for (i=0; i < iNum; i++) {
        CParentCDL *pParentCDL = m_ParentCDL.GetNext(pos); // pass ref!

        if (!pParentCDL->m_bCompleteSignalled) {

            // unsignalled code download
            pParentCDL->m_bCompleteSignalled = TRUE;
            pParentCDL->m_pcdl->CompleteOne( this ,hrOSB, hrStatus, hrResponseHdr, szError);

            if (iNum > 1) {
                // failed complete reports could cause CodeDownloads to release
                // us and thus change the list
                goto restart;
            }
        }

    }
    
    DEBUG_LEAVE(S_OK);
    return S_OK;
}


// ---------------------------------------------------------------------------
// %%Function: CDownload::AddParent(CCodeDownload *pcdl)
// ---------------------------------------------------------------------------
HRESULT
CDownload::AddParent(CCodeDownload *pcdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::AddParent",
                "this=%#x, %#x",
                this, pcdl
                ));
                
    HRESULT hr = S_OK;

    CParentCDL *pParentCDL = new CParentCDL(pcdl);

    if (pParentCDL)
        m_ParentCDL.AddTail(pParentCDL);
    else
        hr = E_OUTOFMEMORY;


    if (SUCCEEDED(hr)) {
        if (m_bCompleteSignalled) {
            pParentCDL->m_bCompleteSignalled = TRUE;
            pcdl->CompleteOne(this ,m_hrOSB, m_hrStatus, m_hrResponseHdr, NULL);
        } else {

            hr = FAILED(m_hrOSB)?m_hrOSB:(FAILED(m_hrStatus)?m_hrStatus:(FAILED(m_hrResponseHdr)?m_hrResponseHdr:S_OK));

        }
    }
    
    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CDownload::IsSignalled(CCodeDownload *pcdl)
// ---------------------------------------------------------------------------
BOOL
CDownload::IsSignalled(CCodeDownload *pcdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CDownload::IsSignalled",
                "this=%#x, %#x",
                this, pcdl
                ));
                
    CParentCDL            *pParentCDL = NULL;
    BOOL                   bRet = FALSE;
    LISTPOSITION           pos = 0;
    DLSTATE                dls;
    int                    iNum = 0;
    int                    i;

    dls = GetDLState();
    if (dls == DLSTATE_DONE || dls == DLSTATE_READY_TO_SETUP) {
        bRet = TRUE;
        goto Exit;
    }

    iNum = m_ParentCDL.GetCount();
    Assert(iNum);
    pos = m_ParentCDL.GetHeadPosition();

    for (i=0; i < iNum; i++) {
        pParentCDL = m_ParentCDL.GetNext(pos); // pass ref!
        if (pParentCDL->m_pcdl == pcdl && pParentCDL->m_bCompleteSignalled) {
            bRet = TRUE;
            break;
        }
    }

Exit:
    
    DEBUG_LEAVE(bRet);
    return bRet;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::Abort(CCodeDownload *pcdl)
// ---------------------------------------------------------------------------
HRESULT
CDownload::Abort(CCodeDownload *pcdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::Abort",
                "this=%#x, %#x",
                this, pcdl
                ));
                
    int i;
    CParentCDL *pThisParentCDL = NULL;
    BOOL bDelinkParent = FALSE;
    BOOL fWaitForAbortCompletion = FALSE;
    HRESULT hr = S_OK;

    int iNum = m_ParentCDL.GetCount();
    Assert(iNum);
    LISTPOSITION pos = m_ParentCDL.GetHeadPosition();

    for (i=0; i < iNum; i++) {
        CParentCDL *pParentCDL = m_ParentCDL.GetNext(pos); // pass ref!

        if (pParentCDL->m_pcdl == pcdl)
            pThisParentCDL = pParentCDL;
        else if ( !pParentCDL->m_bCompleteSignalled )
            bDelinkParent = TRUE;
    }

    Assert(pThisParentCDL);

    if (!pThisParentCDL)
    {
        DEBUG_LEAVE(E_FAIL);
        return E_FAIL;
    }

    if (bDelinkParent) {

        // multiple code downloads interested in this
        // delink this parent, by marking as complete signalled

        pThisParentCDL->m_bCompleteSignalled = TRUE;

        DEBUG_LEAVE(S_OK);
        return S_OK;
    }

    switch ( GetDLState())  {

    case DLSTATE_BINDING:

        GetBSC()->GetBinding()->Abort();

        break;

    case DLSTATE_ABORT:

        // have aborted this but the OSB has not been recieved yet
        // so wait for that to come to us before we complteall
        // or post the setup packet to completeall

        fWaitForAbortCompletion = TRUE;
        break;

    case DLSTATE_DONE:
    case DLSTATE_READY_TO_SETUP:

        break;

    default:

        // packet processing pending for this state. we will check for
        // DLSTATE_ABORT in each packet processing state and if true
        // it will call CompleteOne(us), which marks each piece DLSTATE_DONE

        SetDLState(DLSTATE_ABORT);
        fWaitForAbortCompletion = TRUE;

    }

    if (fWaitForAbortCompletion) {

        hr = S_FALSE;
    }

    DEBUG_LEAVE(hr);
    return hr;

}


// ---------------------------------------------------------------------------
// %%Function: CDownload::ReleaseParent(CCodeDownload *pcdl)
// ---------------------------------------------------------------------------
HRESULT
CDownload::ReleaseParent(CCodeDownload *pcdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::ReleaseParent",
                "this=%#x, %#x",
                this, pcdl
                ));
                
    int iNum = m_ParentCDL.GetCount();

    Assert(iNum);
    LISTPOSITION pos = m_ParentCDL.GetHeadPosition();

    for (int i=0; i < iNum; i++) {
        CParentCDL *pParentCDL = m_ParentCDL.GetNext(pos); // pass ref!

        if (pParentCDL->m_pcdl == pcdl) {

            // found the item
            // getnext would have stepped past the position
            pos = m_ParentCDL.Find(pParentCDL);
            m_ParentCDL.RemoveAt(pos);
            iNum = m_ParentCDL.GetCount();
            if (iNum == 0) {

                CleanupFiles();

                delete this;
            }
    
            DEBUG_LEAVE(S_OK);
            return S_OK;
        }
    }

    // not found in list
    Assert(TRUE);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}


// ---------------------------------------------------------------------------
// HRESULT CDownload::IsDownloadedVersionRequired()
// returns S_OK if downloaded version is required
// error if local version is OK and new verison is not required
// ---------------------------------------------------------------------------
HRESULT CDownload::IsDownloadedVersionRequired()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::IsDownloadedVersionRequired",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    char szFullURL[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = INTERNET_MAX_URL_LENGTH;
    FILETIME *pftLastMod = GetCodeDownload()->GetLastModifiedTime();
    HANDLE hf = INVALID_HANDLE_VALUE;

    if (!GetCodeDownload()->LocalVersionPresent()) {
        // if no prev version always download
    
        DEBUG_LEAVE(hr);
        return hr;
    } else {
        // if prev version exists, but we are not doing Get Latest
        // then accept the download.
        if (!GetCodeDownload()->NeedLatestVersion())
        {
            DEBUG_LEAVE(hr);
            return hr;
        }
    }

    if (GetMoniker() != GetCodeDownload()->GetContextMoniker()){
        // if we are not the context (or the main moniker then
        // -1 does not apply (to secondary CABs)

        DEBUG_LEAVE(hr);
        return hr;
    }

    dwLen = WideCharToMultiByte(CP_ACP, 0, GetURL(), -1,
                    szFullURL, INTERNET_MAX_URL_LENGTH, NULL, NULL);

    Assert(dwLen);

    if (!dwLen) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (StrCmpNI(szFullURL, "file:", 5) == 0) {

        WIN32_FIND_DATA fd;

        hf = FindFirstFile(GetFileName(), &fd);

        if (hf == INVALID_HANDLE_VALUE) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        
        // BUGBUG: Defend against Bug#40696 - Vatsan should check to see if this is the _right_ defense.
        if ( pftLastMod != NULL &&
             CompareFileTime(pftLastMod, &(fd.ftLastWriteTime)) >= 0) {

            // if the file needs no upgrade then fail!
            // if we succeed then an update will take place.
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            goto Exit;
        }


    }

Exit:

    if ( hf != INVALID_HANDLE_VALUE)
        FindClose(hf);

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::GetFriendlyName
// ---------------------------------------------------------------------------
HRESULT CDownload::GetFriendlyName(LPSTR szUrlPath, LPSTR *ppBaseFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::GetFriendlyName",
                "this=%#x, %.80q, %#x",
                this, szUrlPath, ppBaseFileName
                ));
                
    HRESULT hr = S_OK;
    char szFullURL[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = INTERNET_MAX_URL_LENGTH;
    URL_COMPONENTS UrlComponents;
    char *pBaseFileName = NULL;

    dwLen = WideCharToMultiByte(CP_ACP, 0, GetURL(), -1,
                    szFullURL, INTERNET_MAX_URL_LENGTH, NULL, NULL);


    memset(&UrlComponents, 0, sizeof(URL_COMPONENTS));
    UrlComponents.dwStructSize = sizeof(URL_COMPONENTS);

    UrlComponents.lpszUrlPath = szUrlPath;
    UrlComponents.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

    if (!InternetCrackUrl( szFullURL, 0,
        ICU_DECODE, &UrlComponents)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    Assert(UrlComponents.lpszUrlPath);
    Assert(UrlComponents.dwUrlPathLength);

    if ( !UrlComponents.dwUrlPathLength ||
        !UrlComponents.lpszUrlPath ) {

        hr = E_UNEXPECTED;
        goto Exit;
    }

    if (ppBaseFileName)
        GetExtnAndBaseFileName(szUrlPath, ppBaseFileName);

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::SniffType
// ---------------------------------------------------------------------------
HRESULT CDownload::SniffType()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::SniffType",
                "this=%#x",
                this
                ));
                
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    DWORD dwSignature;
    DWORD dwBytesRead = 0;

#define CAB_SIG 0x4643534d

    if (GetExtn() != FILEXTN_CAB) {


        if ( (hFile = CreateFile(GetFileName(), GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        if ((ReadFile(hFile, &dwSignature, sizeof(DWORD), &dwBytesRead, NULL))
            && (dwSignature == CAB_SIG)) {

            SetURLAndExtn(NULL, FILEXTN_CAB);
        } else {

            // here if its not a CAB
            // check if of compatible type

            hr = IsCompatibleFile(GetFileName());
        }

    }

Exit:

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    
    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::VerifyTrust
// ---------------------------------------------------------------------------
VOID CDownload::VerifyTrust()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::VerifyTrust",
                "this=%#x",
                this
                ));
                
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    HWND hWnd = GetCodeDownload()->GetClientBinding()->GetHWND();
    WCHAR szDisplayUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cchDisplayUrl = INTERNET_MAX_URL_LENGTH;
    LPSTR szCatalogFile = NULL;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))     // if tls ctor failed above
        goto Exit;

    if ( GetDLState() == DLSTATE_ABORT) {
        hr = E_ABORT;
        goto Exit;
    }

    // sniff file for detecting CAB extensions
    // and if not CAB, assume PE and check if of compatible type
    // before calling trust on it. The reason we presniff for
    // compat is because it will make for better user experience to
    // fail if not of correct binary before we present trust dialogs

    hr = SniffType();

    if (FAILED(hr))
        goto Exit;

    Assert(tls->pTrustCookie);

    // need to serialize all trust verification on this thread
    // grab the trust cookie

    hr = tls->pTrustCookie->Acquire(this);
    if (hr != S_OK) {

        Assert(!tls->pTrustCookie->IsFree());
        Assert(!tls->pTrustCookie->IsOwner(this));
 
        DEBUG_LEAVE(0);
        return; // wait till we get posted a message when the current owner
                // relinquishes the cookie
    }

    // have the cookie
    Assert(tls->pTrustCookie->IsOwner(this));

    if ( (hFile = CreateFile(GetFileName(), GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // form friendly displayable URL (ie. decode) in browser mode
    hr = UrlUnescapeW((LPWSTR)GetURL(), szDisplayUrl, &cchDisplayUrl, 0);

    Assert(!GetCodeDownload()->IsSilentMode() || hWnd == INVALID_HANDLE_VALUE);

    // Try to get a catalog file
    szCatalogFile = GetCodeDownload()->GetCatalogFile();

    hr = m_wvt.VerifyTrust(hFile, hWnd, &m_pbJavaTrust, szDisplayUrl, 
                           GetCodeDownload()->GetClientBinding()->GetHostSecurityManager(),
                           (char *)GetFileName(), szCatalogFile, this);

    if(SUCCEEDED(hr)) {

        SetTrustVerified();

    } else {

        // trust failed on this file. Delete it from the cache for
        // added safety. 

        // remove entry from cache only if we're not in silent mode.
        // or we are in silent mode and the hr != TRUST_E_SUBJECT_NOT_TRUSTED
        // when ui choice is NONE, WVT reurns the special error code to
        // mean that all was OK but could not trust because we did not
        // allow them to put up confirmation UI.

        if (!GetCodeDownload()->IsSilentMode())
        {
            CHAR szURL[INTERNET_MAX_URL_LENGTH];
            DWORD cchURL = INTERNET_MAX_URL_LENGTH;

            WideCharToMultiByte(CP_ACP, 0, GetURL(), -1, szURL,
                        INTERNET_MAX_URL_LENGTH, 0,0);

            // If we still have the file open when we call DeleteUrlCacheEntry, then
            // WinInet won't be able to delete it. Having untrusted bits in the cache
            // is dangerous.
            if ( hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            DeleteUrlCacheEntryA(szURL);
        }
        else
            GetCodeDownload()->SetTrustSomeFailed();
    }

Exit:

    // reset status to resume the rest of download if we're in
    // silent mode
    if (GetCodeDownload()->IsSilentMode() && FAILED(hr) && (hr != E_ABORT))
        hr = S_OK;

    if (tls->pTrustCookie->IsOwner(this)) {
        tls->pTrustCookie->Relinquish(this);
    }

    if (SUCCEEDED(hr)) {

        CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_PROCESS_PIECE, this, 0);

        if (pPkt) {
            hr = pPkt->Post();
        } else {
            hr = E_OUTOFMEMORY;
        }

    }

    if (FAILED(hr)) {

        // does all the master state analysis
        CompleteSignal(hr, S_OK, S_OK, NULL);
    }

    if ( hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    DEBUG_LEAVE(0);
    return;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::SetCdlProtocol
// ---------------------------------------------------------------------------
HRESULT
CDownload::SetUsingCdlProtocol(LPWSTR wszDistUnit)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::SetUsingCdlProtocol",
                "this=%#x, %.80wq",
                this, wszDistUnit
                ));
                
    HRESULT hr = S_OK;

    m_wszDistUnit = new WCHAR [lstrlenW(wszDistUnit) + 1];

    if (m_wszDistUnit)
        StrCpyW(m_wszDistUnit, wszDistUnit);
    else
        hr = E_OUTOFMEMORY;

    m_flags |= DL_FLAGS_CDL_PROTOCOL;

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::ExtractManifest()
// ---------------------------------------------------------------------------
HRESULT
CDownload::ExtractManifest(FILEXTN extn, LPSTR szFileName, LPSTR& pBaseFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::ExtractManifest",
                "this=%#x, %#x, %.80q, %#x",
                this, extn, szFileName, &pBaseFileName
                ));
                
    CCodeDownload *pcdl = GetCodeDownload();
    char * pFileName;
    PSESSION psess = NULL;
    PFNAME pf = NULL;
    HRESULT hr = S_FALSE;   // assume not found

    Assert(m_psess);

    for (pf = m_psess->pFileList; pf != NULL; pf = pf->pNextName) {

        FILEXTN curextn = ::GetExtnAndBaseFileName(pf->pszFilename,
                                                &pBaseFileName);

        if (( curextn == extn) && 
            ((szFileName[0] == '\0') || 
                (lstrcmpi(szFileName, pBaseFileName) == 0))) {

            FNAME fne;
            memset(&fne, 0, sizeof(FNAME));
            fne.pszFilename = pf->pszFilename;

            // INF present in CAB, extract it and process it
            m_psess->pFilesToExtract = &fne;
            m_psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated

            if (FAILED((hr=ExtractFromCabinet(m_psess, GetFileName()))))
                goto Exit;

            // side effect!
            // if extract succeeds we also have set the return hr to S_OK.
            // hr = S_OK;

            m_psess->pFilesToExtract = NULL;

            if (!catDirAndFile(szFileName, MAX_PATH, m_psess->achLocation,
                               pf->pszFilename)) {
                hr = E_UNEXPECTED;
            }

            goto Exit;

        }
    }

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::ProcessPiece
//      CBSC::OnStopBinding calls us as soon as a piece gets downloaded
//      and trust is verified.
//      ie. this CDownload obj has completed binding
//      Depending on the Content type we will process further
// This triggers a change state in our state machine. Depending on the
// obj we have downloaded (a CAB or INF or DLL/OCX/EXE) we:
//
// OCX:
//    Csetup for this download is usually previously created
//      mark this download as done and
//    call into main CodeDownload::CompleteOne (state analyser)
//
// CAB:
//    if we don't have an INF already we look for one in the CAB
//           if INF in CAB
//               process INF (may trigger further extractions/downloads/Csetup)
//           else
//              look for primary OCX in CAB and create CSetup or it.
//
// INF:
//      Process INF
//
// ---------------------------------------------------------------------------
VOID
CDownload::ProcessPiece()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::ProcessPiece",
                "this=%#x",
                this
                ));
                
    CCodeDownload *pcdl = GetCodeDownload();
    char * pFileName;
    char *pBaseFileName;
    PSESSION psess = NULL;
    PFNAME pf = NULL;
    HRESULT hr = S_OK; // assume all OK
    CSetup *pSetup;
    char szBuf[INTERNET_MAX_URL_LENGTH];
    char szCatalogBuf[INTERNET_MAX_URL_LENGTH];
    FILEXTN extn = m_extn;

    if ( GetDLState() == DLSTATE_ABORT) {
        hr = E_ABORT;
        goto Exit;
    }

    //REVIEW: Virus scanning a CAB or INF file may not be a bright thing to do since
    //        they are not executable.

    if (FAILED(hr = PerformVirusScan((char *)GetFileName()))) {
        goto Exit;
    }

    switch (extn) {

    case FILEXTN_EXE:
    case FILEXTN_OCX:
    case FILEXTN_DLL:
    case FILEXTN_NONE:
    case FILEXTN_UNKNOWN:

        pSetup = GetSetupHead();

        if (pSetup) {
            // If a CSetup exists for this m_pdl then initialize its
            // m_pSrcFileName using the m_pFileName

            Assert(pSetup->GetNext() == NULL);

            pSetup->SetSrcFileName(GetFileName());

        } else {

            if (!HasAllActiveXPermissions()) {

                if (GetCodeDownload()->IsSilentMode())
                {
                    GetCodeDownload()->SetBitsInCache();
                }

                hr = TRUST_E_FAIL;
                goto Exit;
            }

            // If no CSetup exists then make one and attach it to the m_pdl
            // initiated at top level

            hr = GetFriendlyName(szBuf, &pBaseFileName);
            if (pBaseFileName[0] == '\0') {
                hr = E_UNEXPECTED; // No filename to setup!
                goto Exit;
            }

            if (FAILED(hr)) {
                goto Exit;
            }

            pSetup = new CSetup(GetFileName(), pBaseFileName, extn,
                                                pcdl->GetDestDirHint(), &hr);

            if (!pSetup) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            } else if (FAILED(hr)) {
                delete pSetup;
                goto Exit;
            }

            AddSetupToList(pSetup);

        }

        break;

    case FILEXTN_CAB:
        // if CAB then make SESSION for this CDownload
        Assert(!(GetSession()));

        psess = new SESSION;
        if (!psess) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        SetSession(psess);

        // Initialize the structure
        psess->pFileList        = NULL;
        psess->cFiles           = 0;
        psess->cbCabSize        = 0;
        psess->flags = SESSION_FLAG_ENUMERATE;

        // extract files in a CAB into a unique dir so that
        // parallel downloads of CABs containing same name
        // components can go on without conflict.
        // By serailizing the setup phase we make sure the right
        // latest version is finally left on client machine.

        hr =  MakeUniqueTempDirectory(g_szOCXTempDir, psess->achLocation, sizeof(psess->achLocation));

        if (FAILED(hr)) {
            goto Exit;
        }

        psess->pFilesToExtract = NULL; // just enumerate first

        if (!pcdl->HaveManifest() || NeedToExtractAllFiles()) {
            psess->flags |= SESSION_FLAG_EXTRACT_ALL;
        }

        // enumerate the files of the CAB
        if (FAILED((hr = ExtractFromCabinet(psess, GetFileName()))))
            goto Exit;

        if (!pcdl->HaveManifest() || NeedToExtractAllFiles()) {
            psess->flags |= SESSION_FLAG_EXTRACTED_ALL;
        }

        // if we don't have INF already look for one
        if (!pcdl->HaveManifest()) {

            // Extract catalog file
            szCatalogBuf[0] = '\0';
            if (ExtractManifest(FILEXTN_CAT, szCatalogBuf, pBaseFileName) == S_OK) {
                if (FAILED(pcdl->SetCatalogFile(szCatalogBuf))) {
                    goto Exit;
                }
            } 

            szBuf[0] = '\0';
            hr = ExtractManifest(FILEXTN_OSD , szBuf, pBaseFileName);
            if (FAILED(hr))
                goto Exit;

            if (hr == S_FALSE) {
                szBuf[0] = '\0';

                // if no dist unit profile, process old INF
                hr = ExtractManifest(FILEXTN_INF , szBuf, pBaseFileName);

                if (FAILED(hr))
                    goto Exit;

                if (hr == S_OK) {
                    hr=pcdl->SetupInf(szBuf, pBaseFileName, this);
                    goto Exit;
                }

            } else {
                // process dist unit profile

                hr=pcdl->ParseOSD(szBuf, pBaseFileName, this);
                goto Exit;
            }

            if (!pcdl->HaveManifest()) { // still don't have an INF?


                if (!HasAllActiveXPermissions()) {

                    if (GetCodeDownload()->IsSilentMode())
                    {
                        GetCodeDownload()->SetBitsInCache();
                    }

                    hr = TRUST_E_FAIL;
                    goto Exit;
                }

                // only valid case at this point is
                // case where we have a CAB file with ONE file in it
                if (psess->cFiles != 1) {
                    hr = E_INVALIDARG;
                    goto Exit;
                }

                pf = psess->pFilesToExtract = psess->pFileList;
                psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated

                if (FAILED((hr=ExtractFromCabinet(psess, GetFileName()))))
                    goto Exit;


                extn = GetExtnAndBaseFileName(pf->pszFilename, &pBaseFileName);

                if (!catDirAndFile(szBuf, MAX_PATH, psess->achLocation,
                                   pf->pszFilename)) {
                    hr = E_UNEXPECTED;
                    goto Exit;
                }

                psess->pFilesToExtract = NULL;

                pSetup = new CSetup(szBuf, pBaseFileName, extn,
                                                pcdl->GetDestDirHint(), &hr);
                if (!pSetup) {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                } else if (FAILED(hr)) {
                    delete pSetup;
                    goto Exit;
                }

                AddSetupToList(pSetup);

            }

        } else { /* have inf */

            // INF processor would have made Csetup already

            psess->pFilesToExtract = GetFilesToExtract();

            if (!psess->pFilesToExtract) {
                // no files to extract, means there was only a hook
                // in this CAB and no other particular files
                // the general code downloader is looking for
                // so no setup work either.

                Assert(NeedToExtractAllFiles());

                break;
            }

            psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated

            CSetup *pSetupCur = m_pSetuphead;
            Assert(m_pSetuphead);

            // set fully qual names for all of these
            for (; pSetupCur; pSetupCur = pSetupCur->GetNext()) {

                if (!catDirAndFile(szBuf, MAX_PATH, m_psess->achLocation,
                    (LPSTR)pSetupCur->GetSrcFileName())) {

                    hr = E_UNEXPECTED;
                    goto Exit;
                }

                pSetupCur->SetSrcFileName(szBuf);
            }

            if (FAILED((hr=ExtractFromCabinet(psess, GetFileName()))))
                goto Exit;
        }

        break;

    case FILEXTN_INF:

        if(pcdl->HaveManifest()) {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto Exit;
        }

        hr = GetFriendlyName(szBuf, &pBaseFileName);

        if (FAILED(hr)) {
            goto Exit;
        }

        // get friendly name for INF from URL
        hr=pcdl->SetupInf(GetFileName(), pBaseFileName, this);

        if (FAILED(hr)) {
            SetDLState(DLSTATE_DONE);
        }

        goto Exit;

    case FILEXTN_OSD:

        if(pcdl->HaveManifest()) {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            goto Exit;
        }

        hr = GetFriendlyName(szBuf, &pBaseFileName);

        if (FAILED(hr)) {
            goto Exit;
        }

        // get friendly name for OSD from URL
        hr=pcdl->ParseOSD(GetFileName(), pBaseFileName, this);
        goto Exit;

    } /* end switch (extn) */

    // done with this CDownload. Mark it ready for setup
    SetDLState(DLSTATE_READY_TO_SETUP);

    Assert(SUCCEEDED(hr));

Exit:

    if ( (FAILED(hr)) || (GetDLState() == DLSTATE_READY_TO_SETUP)) {
        CompleteSignal(hr, S_OK, S_OK, NULL);
    }

    // if success setupInf would have dispatched a msg for
    // INF processing and only when that completes this
    // CDownload is deemed completed/ready_to_setup

    DEBUG_LEAVE(0);
    return;
}


// ---------------------------------------------------------------------------
// %%Function: CDownload::SetURLAndExnt(LPCWSTR szURL, FILEXTN extn);
// ---------------------------------------------------------------------------
HRESULT
CDownload::SetURLAndExtn(LPCWSTR szURL, FILEXTN extn)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::ProcessPiece",
                "this=%#x, %.80wq, %#x",
                this, szURL, extn
                ));
                
    m_extn = extn;

    if (!szURL)
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    
    DWORD len = lstrlenW(szURL); // make private copy
    LPWSTR lpch = new WCHAR [len + 1];

    if (!lpch)
    {
        DEBUG_LEAVE(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    
    StrCpyW(lpch, szURL);

    if (m_url)
        SAFEDELETE(m_url);

    m_url = lpch;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::CheckForNameCollision(LPCSTR szCacheDir);
// for each in list CSetup::CheckForNameCollision
// ---------------------------------------------------------------------------
HRESULT
CDownload::CheckForNameCollision(LPCSTR szCacheDir)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::CheckForNameCollision",
                "this=%#x, %.80q",
                this, szCacheDir
                ));
                
    CSetup *pSetupCur = m_pSetuphead;
    HRESULT hr = S_OK;

    for (pSetupCur = m_pSetuphead; pSetupCur; pSetupCur =pSetupCur->GetNext()) {
        if ((hr=pSetupCur->CheckForNameCollision(GetCodeDownload(), szCacheDir)) == S_FALSE)
            break;
    }
    
    DEBUG_LEAVE(hr);
    return hr;

}


// ---------------------------------------------------------------------------
// %%Function: CDownload::FindJavaSetup
// ---------------------------------------------------------------------------
CJavaSetup*
CDownload::FindJavaSetup(LPCWSTR szPackageName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CDownload::FindJavaSetup",
                "this=%#x, %.80wq",
                this, szPackageName
                ));
                
    HRESULT hr = S_OK;
    CJavaSetup *pjs = NULL;

    if (!szPackageName)
    {
        DEBUG_LEAVE(NULL);
        return NULL;
    }

    int iNumJavaSetup = m_JavaSetupList.GetCount();
    LISTPOSITION curpos = m_JavaSetupList.GetHeadPosition();
    for (int i=0; i < iNumJavaSetup; i++) {

        pjs = m_JavaSetupList.GetNext(curpos);

        if (pjs->GetPackageName() && (StrCmpIW(szPackageName, pjs->GetPackageName()) == 0)) {
    
            DEBUG_LEAVE(pjs);
            return pjs;
        }
    }
    
    DEBUG_LEAVE(NULL);
    return NULL;
}


// ---------------------------------------------------------------------------
// %%Function: CDownload::FindHook
// ---------------------------------------------------------------------------
CSetupHook*
CDownload::FindHook(LPCSTR szHook)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Pointer,
                "CDownload::FindHook",
                "this=%#x, %.80q",
                this, szHook
                ));
                
    HRESULT hr = S_OK;
    CSetupHook *psh = NULL;

    if (!szHook)
    {
        DEBUG_LEAVE(NULL);
        return NULL;
    }

    int iNumHooks = m_SetupHooks.GetCount();
    LISTPOSITION curpos = m_SetupHooks.GetHeadPosition();
    for (int i=0; i < iNumHooks; i++) {

        psh = m_SetupHooks.GetNext(curpos);

        if (psh->GetHookName() && (lstrcmpi(szHook, psh->GetHookName()) == 0)) {
    
            DEBUG_LEAVE(psh);
            return psh;
        }
    }

    DEBUG_LEAVE(NULL);
    return NULL;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::DoSetup
// ---------------------------------------------------------------------------
HRESULT
CDownload::DoSetup()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::DoSetup",
                "this=%#x",
                this
                ));
                
    CSetup *pSetupCur = m_pSetuphead;
    HRESULT hr = S_OK;
    int nSetupsPerCall = 0;
    int iNumHooks,i;
    POSITION curpos;

    SetDLState(DLSTATE_SETUP);

    // SILENT MODE
    // determine if we're in silent mode
    if (GetCodeDownload()->IsSilentMode() && !GetCodeDownload()->IsAllTrusted())
    {
        SetDLState(DLSTATE_DONE);
    
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (m_JavaSetupList.GetCount() != 0) {

        CJavaSetup *pjs = m_JavaSetupList.GetHead();
        curpos = m_JavaSetupList.GetHeadPosition();
        BOOL bInstallReqd = FALSE;

        if (pjs != NULL) {

            for (int i=0; i< m_JavaSetupList.GetCount(); i++) {

                CJavaSetup *pjs = m_JavaSetupList.GetNext(curpos);
                Assert(pjs != NULL);

                if (pjs->GetState() != INSTALL_DONE) {
                    bInstallReqd = TRUE;
                    break;
                }
            }


            if (bInstallReqd) {
                Assert(HasJavaPermissions());
                // the below check is our final security test
                // we should never need to test this in retail
                // but, we do anyway
                if (HasJavaPermissions())
                    hr = pjs->DoSetup();
                else 
                    hr = TRUST_E_FAIL;

                if (FAILED(hr))
                    goto Exit;
                else
                {
                    DEBUG_LEAVE(S_OK);
                    return S_OK;
                }
            }
        }

    }

    // done processing Java Setups
    // process all hooks
    iNumHooks = m_SetupHooks.GetCount();
    curpos = m_SetupHooks.GetHeadPosition();
    for (i=0; i < iNumHooks; i++) {

        CSetupHook *psh = m_SetupHooks.GetNext(curpos);

        if (psh->GetState() == INSTALL_DONE)
            continue;

        if (nSetupsPerCall++) {
            // here if we have already done 1 hook and there's more to
            // do in this CDownload

            // we don't set DLState to DONE and just return

            DEBUG_LEAVE(S_OK);
            return S_OK;
        }

        Assert(HasAllActiveXPermissions());
        // the below check is our final security test
        // we should never need to test this in retail
        // but, we do anyway
        if (HasAllActiveXPermissions())
            hr=psh->Run();
        else 
            hr = TRUST_E_FAIL;

        if (FAILED(hr))
            goto Exit;

        if (psh->GetState() != INSTALL_DONE) {

            // more work left in this setup hook
            // wait for next msg, don't mark ourselves done yet.

            DEBUG_LEAVE(S_OK);
            return S_OK;
        }

    }

    // processed all Java Setups, hooks, now run setups
    for (pSetupCur = m_pSetuphead; pSetupCur; pSetupCur = pSetupCur->GetNext()) {

        if (pSetupCur->GetState() == INSTALL_DONE)
            continue;

        if (nSetupsPerCall++) {
            // here if we have already done 1 setup and there's more to
            // do in this CDownload

            // we don't set DLState to DONE and just return
    
            DEBUG_LEAVE(S_OK);
            return S_OK;
        }

        if (m_bExactVersion) {
            pSetupCur->SetExactVersion(TRUE);
        }

        if (pSetupCur->GetExtn() == FILEXTN_OSD) {
            hr=pSetupCur->DoSetup(GetCodeDownload(), this);
        } else {

            Assert(HasAllActiveXPermissions());
            // the below check is our final security test
            // we should never need to test this in retail
            // but, we do anyway
            if (HasAllActiveXPermissions())
                hr=pSetupCur->DoSetup(GetCodeDownload(), this);
            else 
                hr = TRUST_E_FAIL;
        }

        if (FAILED(hr))
            break;

        if (pSetupCur->GetState() != INSTALL_DONE) {

            // more work left in this CSetup (pSetupCur)
            // wait for next msg, don't mark ourselves done yet.

            DEBUG_LEAVE(S_OK);
            return S_OK;
        }

    } /* for each CSetup */


Exit:
    SetDLState(DLSTATE_DONE);

    DEBUG_LEAVE(hr);
    return hr;

}

// ---------------------------------------------------------------------------
// %%Function: CDownload::AddJavaSetup
//
//  create and add a new JavaSetup to the list of setup hooks in this cab
// ---------------------------------------------------------------------------
HRESULT
CDownload::AddJavaSetup(
    LPCWSTR szPackageName,
    LPCWSTR szNameSpace,
    IXMLElement *pPackage,
    DWORD dwVersionMS,
    DWORD dwVersionLS,
    DWORD flags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::AddJavaSetup",
                "this=%#x, %.80wq, %.80wq, %#x, %#x, %#x, %#x",
                this, szPackageName, szNameSpace, pPackage, dwVersionMS, dwVersionLS, flags
                ));
                
    HRESULT hr = S_OK;
    CJavaSetup *pJavaSetup = NULL;

    if (GetCodeDownload()->IsDuplicateJavaSetup(szPackageName) == S_OK) {

        goto Exit;
    }

    // create a CJavaSetup OBJ and add it to the CDownload obj
    pJavaSetup = new CJavaSetup(this, szPackageName, szNameSpace, pPackage, dwVersionMS, dwVersionLS, flags, &hr);
    if(!pJavaSetup) {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        SAFEDELETE(pJavaSetup);
        goto Exit;
    }

    m_JavaSetupList.AddTail(pJavaSetup);

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::AddHook
//
//  create and add a new hook to the list of setup hooks in this cab
// ---------------------------------------------------------------------------
HRESULT
CDownload::AddHook(
    LPCSTR szHook,
    LPCSTR szInf,
    LPCSTR szInfSection,
    DWORD flags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::AddHook",
                "this=%#x, %.80wq, %.80wq, %.80wq, %#x",
                this, szHook, szInf, szInfSection, flags
                ));
                
    HRESULT hr = S_OK;
    CSetupHook *psh;

    Assert(m_state != DLSTATE_EXTRACTING);


    if (GetCodeDownload()->IsDuplicateHook(szHook) == S_OK) {

        goto Exit;
    }


    if (m_extn == FILEXTN_CAB) { // if a CAB

        if (m_state > DLSTATE_DOWNLOADED) {

            // this CAB is ready, extract this code first
            // BUGBUG: multi-threading issue: we are relying on
            // not being re-enterant in our extraction

            Assert(m_psess);

            if (!m_psess) {
                hr = E_UNEXPECTED;
                goto Exit;
            }

            if (!(m_psess->flags & SESSION_FLAG_EXTRACTED_ALL)) {

                m_psess->pFilesToExtract = NULL;
                m_psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated
                m_psess->flags |= SESSION_FLAG_EXTRACT_ALL;

                if (FAILED((hr = ExtractFromCabinet(m_psess, m_pFileName)))) {
                    goto Exit;
                }

                m_psess->flags |= SESSION_FLAG_EXTRACTED_ALL;
            }


        } else {

            // newly initiated download, mark CDownload as extract all.
            SetNeedToExtractAll();

        }

    }


    psh = new CSetupHook(this, szHook, szInf, szInfSection, flags, &hr);

    if (psh && SUCCEEDED(hr)) {

        m_SetupHooks.AddTail(psh);

    } else {

        if (psh)
            delete psh;

        hr = E_OUTOFMEMORY;
    }

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::AddSetupToExistingCAB
//        if CAB is already downloaded
//            extract file; create CSetup to install it (piggy back to pdl)
//        else if some other CAB that has been set for download
//                attach file to be extracted to pFilesToExtract
//                attach a CSetup for this file
//        else
// ---------------------------------------------------------------------------
HRESULT
CDownload::AddSetupToExistingCAB(char * lpCode, const char * szDestDir, DESTINATION_DIR dest, DWORD dwRegisterServer, DWORD dwCopyFlags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::AddSetupToExistingCAB",
                "this=%#x, %.80q, %.80q, %#x, %#x, %#x",
                this, lpCode, szDestDir, dest, dwRegisterServer, dwCopyFlags
                ));

    char *pBaseFileName =  lpCode;
    FILEXTN extn;
    HRESULT hr = NO_ERROR;
    CSetup* pSetup = NULL;
    char szBuf[MAX_PATH];

    Assert(lpCode);

    if (!lpCode) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IsDuplicateSetup(lpCode))
        goto Exit;

    // assumes that both CAB extraction and download
    // are into same temp dir
    // make a name for extraction ie: tempdir\curcode

    extn = GetExtnAndBaseFileName( lpCode, &pBaseFileName);

    // this check is totally legit : ie no race condition here
    // we are on the main wininet thread and all onstopbindgs get
    // posted on this thread. So a newly initialted download could not
    // have completed, and even if so CAB extraction could not have started

    Assert(m_state != DLSTATE_EXTRACTING);
    Assert(m_state != DLSTATE_SETUP);
    Assert(m_state != DLSTATE_DONE);

    if (m_state > DLSTATE_DOWNLOADED) {

        // part of CAB that the INF is in,
        // or part of a CAB of some other code download that matches our spec.
        // extract this code first

        Assert(m_psess);

        if (!m_psess) {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        FNAME fname;

        fname.pszFilename = pBaseFileName;
        fname.pNextName = NULL;
        fname.status = SFNAME_INIT;

        m_psess->pFilesToExtract = &fname;
        m_psess->flags &= ~SESSION_FLAG_ENUMERATE; // already enumerated

        if (FAILED((hr = ExtractFromCabinet(m_psess, m_pFileName)))) {
            goto Exit;
        }

        m_psess->pFilesToExtract = NULL;

    } else {


        // newly initiated download, piggy back to end of extraction list

        PFNAME pf = new FNAME;
        if (!pf) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pf->pszFilename = new char [lstrlen(pBaseFileName)+1];

        if (!pf->pszFilename) {
            delete pf;
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        lstrcpy(pf->pszFilename, pBaseFileName);
        pf->status = SFNAME_INIT;

        pf->pNextName = m_pFilesToExtract; // add to list
        m_pFilesToExtract = pf;
    }

    if (!catDirAndFile(szBuf, MAX_PATH,
        (m_psess)?m_psess->achLocation:NULL, pBaseFileName)) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // create a CSetup OBJ and add it to us
    pSetup = new CSetup(szBuf, pBaseFileName, extn, szDestDir, &hr, dest);
    if (!pSetup) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    } else if (FAILED(hr)) {
        delete pSetup;
        goto Exit;
    }

    AddSetupToList(pSetup);

    pSetup->SetCopyFlags (dwCopyFlags);
    if (dwRegisterServer) {
        pSetup->SetUserOverrideRegisterServer(dwRegisterServer&CST_FLAG_REGISTERSERVER);
    }

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::IsDuplicateSetup
// ---------------------------------------------------------------------------
BOOL
CDownload::IsDuplicateSetup(LPCSTR pBaseFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CDownload::IsDuplicateSetup",
                "this=%#x, %.80q",
                this, pBaseFileName
                ));
                
    CSetup *pSetupCur = m_pSetuphead;

    for (pSetupCur = m_pSetuphead; pSetupCur; pSetupCur=pSetupCur->GetNext()) {

        if (lstrcmpi(pBaseFileName, pSetupCur->GetBaseFileName()) == 0)
        {
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }
    
    DEBUG_LEAVE(FALSE);
    return FALSE;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::AddSetupToList
// ---------------------------------------------------------------------------
VOID
CDownload::AddSetupToList(CSetup *pSetup)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::AddSetupToList",
                "this=%#x, %#x",
                this, pSetup
                ));
                
    pSetup->SetNext(m_pSetuphead);
    m_pSetuphead = pSetup;

    DEBUG_LEAVE(0);
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::RemoveSetupFromList
// ---------------------------------------------------------------------------
HRESULT
CDownload::RemoveSetupFromList(CSetup *pSetup)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::RemoveSetupFromList",
                "this=%#x, %#x",
                this, pSetup
                ));
                
    CSetup *pSetupCur = m_pSetuphead;
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);

    Assert(pSetup);
    Assert(pSetupCur);             // empty list?

    if (pSetupCur == pSetup) {
        m_pSetuphead = pSetup->GetNext();
        hr = S_OK;
        goto Exit;
    }

    do {
        if (pSetupCur->GetNext() == pSetup) {
            pSetupCur->SetNext(pSetup->GetNext());
            hr = S_OK;
            goto Exit;
        }
    } while ( (pSetupCur = pSetupCur->GetNext()));

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;                // not found in list!

}


// ---------------------------------------------------------------------------
// %%Function: CDownload::CleanupFiles
// ---------------------------------------------------------------------------
 HRESULT
CDownload::CleanupFiles()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::CleanupFiles",
                "this=%#x",
                this
                ));

    if (m_psess) { // CAB?

        DeleteExtractedFiles(m_psess);
        RemoveDirectoryAndChildren(m_psess->achLocation);
        SAFEDELETE(m_psess);

    }

    if (!m_pSetuphead) {

        if (m_pFileName) {
            delete (LPSTR)m_pFileName;
            m_pFileName = NULL;
        }

    } else {

        CSetup *pSetupCur = m_pSetuphead;
        CSetup *pSetupNext;

        for (pSetupCur = m_pSetuphead; pSetupCur;
                                    pSetupCur = pSetupNext) {
                pSetupNext = pSetupCur->GetNext();
                SAFEDELETE(pSetupCur);
        }

    }

    if (m_pUnkForCacheFileRelease)
        SAFERELEASE(m_pUnkForCacheFileRelease);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::DoDownload
// CDownload is the basic download obj. It's action entry point is DoDownload
// Here it creates a URL moniker for the given m_url and a bind ctx to go
// with it and then calls pmk->BindToStorage to get the bits. Note how we
// use URL mon's services to get the bits even as URLmon is our client for
// the Code Download. We are its client for individual downloads. CDownload
// has a BSC implementation to track progress and completion. This BSC is
// where the magic of taking us from one state to next occurs.
//
// ---------------------------------------------------------------------------
 HRESULT
CDownload::DoDownload(LPMONIKER *ppmkContext, DWORD grfBINDF,
                      CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::DoDownload",
                "this=%#x, %#x, %#x, %#x",
                this, ppmkContext, grfBINDF, pcbhList
                ));
                
    HRESULT        hr =  NOERROR;
    IBindHost     *pBindHost = NULL;

    m_pcbhList = pcbhList;

    m_ppmkContext = ppmkContext;

    m_grfBINDF = grfBINDF;

    pBindHost = GetCodeDownload()->GetClientBinding()->GetIBindHost();

    hr = CreateBindCtx(0, &m_pbc);

    if (FAILED(hr)) {
        goto Exit;
    }

    // register the format enumerator with the bind ctx if one exists

    if (g_pEFmtETC) {
        hr = RegisterFormatEnumerator(m_pbc, g_pEFmtETC, 0);
    }

    if( SUCCEEDED(hr) ) {

        m_pbsc = new CBindStatusCallback(this, grfBINDF);

        if (m_pbsc == NULL)
            hr = E_OUTOFMEMORY;

        if (!pBindHost)
            if (SUCCEEDED(hr))
                hr = RegisterBindStatusCallback(m_pbc, m_pbsc, 0, 0);
    }

    if (FAILED(hr)) {
        goto Exit;
    }



    if (pBindHost) {

        IMoniker *pmk;

        hr = pBindHost->CreateMoniker(m_url, m_pbc, &pmk, 0);

        if (FAILED(hr)) {
            goto Exit;
        }

        if (*ppmkContext == NULL) { // no context moniker yet?

            m_pmk = pmk;
            m_ppmkContext = &pmk;

        } else {

            hr = (*ppmkContext)->ComposeWith(pmk, FALSE, &m_pmk);

            pmk->Release();

        }

    } else {

        hr =  CreateURLMoniker(*ppmkContext, m_url, &m_pmk);


    }


    if( SUCCEEDED(hr) ) {

        // store away the full URL
        SAFEDELETE(m_url);
        hr = m_pmk->GetDisplayName(m_pbc, NULL, &m_url);

        if (FAILED(hr))
            goto Exit;

        // everything succeeded
        if (*ppmkContext == NULL) { // no context moniker yet?

            // make this the context moniker
            *ppmkContext = m_pmk;
        }

        IUnknown *pUnk = NULL;

        if (pBindHost) {
            hr = pBindHost->MonikerBindToStorage(m_pmk, m_pbc, m_pbsc,
                IID_IUnknown, (void **)&pUnk);
        } else {
            hr = m_pmk->BindToStorage(m_pbc, 0, IID_IUnknown, (void**)&pUnk);
        }
        // m_pbc will get the onstopbinding, ondatavailable, and onprogress
        // messages and pass them on to m_pbsc; wait asynchronously


        if (pUnk) {
            pUnk->Release();
        }

    }


Exit:

    if (FAILED(hr) && hr != E_PENDING) {

        // real failure!
        m_hrOSB = hr;
        SetDLState(DLSTATE_DONE);

        if (*ppmkContext == m_pmk)
            *ppmkContext = NULL;

    }
    else {

/*
        // everything succeeded
        if (*ppmkContext == NULL) { // no context moniker yet?

            // make this the context moniker
            *ppmkContext = m_pmk;
        }
*/
        hr = MK_S_ASYNCHRONOUS;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}  // CDownload::DoDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::PerformVirusScan
//   S_OK : continue with operation
//   S_FALSE : cancel operation.
// ---------------------------------------------------------------------------
HRESULT CDownload::PerformVirusScan(LPSTR szFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::PerformVirusScan",
                "this=%#x, %.80q",
                this, szFileName
                ));
                
    HRESULT             hr = S_OK, hrReturn = S_OK;
    ICatInformation *   pci = NULL;             // category manager
    IEnumCLSID *        peclsid = NULL;         // enum of av objects
    IOfficeAntiVirus *  poav = NULL;            // current av interface
    CLSID               clsidCurrent;           // current av clsid
    ULONG               pcFetched;
    MSOAVINFO           msavi;                  // antivirus struct
    BOOL                fInitStruct = FALSE;

    //
    // Get COM category manager and get an enumerator for our virus
    // scanner category
    //
    // If something goes wrong finding AV objects, proceed as normal.
    //

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                CLSCTX_INPROC_SERVER, IID_ICatInformation, (void **)&pci);
    if(FAILED(hr))
    { 
        DEBUG_LEAVE(NOERROR);
        return NOERROR;
    }

    hr = pci->EnumClassesOfCategories(1, (GUID *)&CATID_MSOfficeAntiVirus, 0, NULL, &peclsid);
    pci->Release();
    if(FAILED(hr))
    {
        DEBUG_LEAVE(NOERROR);
        return NOERROR;
    }

    //
    // Call all scanners.  If any fail, return E_FAIL.
    //

    hr = peclsid->Next(1, &clsidCurrent, &pcFetched);
    while(SUCCEEDED(hr) && pcFetched > 0)
    {
        if(FALSE == fInitStruct)
        {
            if (FAILED(Ansi2Unicode(szFileName,&msavi.u.pwzFullPath)))
            {
                break;
            }
            msavi.cbsize = sizeof(msavi);
            msavi.fPath = TRUE;
            msavi.fHttpDownload = TRUE;
            msavi.fReadOnlyRequest = FALSE;
            msavi.fInstalled = FALSE;
            msavi.hwnd = GetCodeDownload()->GetClientBinding()->GetHWND();
            msavi.pwzOrigURL = (LPWSTR)GetURL();

            // per office spec, this is only meant as a method for the scanner
            // to differentiate the caller.  Not localized.
            msavi.pwzHostName = L"Urlmon";

            fInitStruct = TRUE;
        }

        // have clsid of av component
        hr = CoCreateInstance(clsidCurrent, NULL, CLSCTX_INPROC_SERVER,
                IID_IOfficeAntiVirus, (void **)&poav);
        if(SUCCEEDED(hr))
        {
            // call scan method
            hr = poav->Scan(&msavi);
            poav->Release();

            if(hr == E_FAIL)
            {
                // file could not be cleaned
                hrReturn = E_FAIL;
            }
        }

        hr = peclsid->Next(1, &clsidCurrent, &pcFetched);
    }

    //
    // clean up
    //
    peclsid->Release();

    if(fInitStruct)
    {
        SAFEDELETE(msavi.u.pwzFullPath);
    }

    DEBUG_LEAVE(hrReturn);
    return hrReturn;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::DownloadRedundantCodeBase()
//    Returns S_OK if starting next download, or S_FALSE if no redundant
//    codebases remaining to try.
// ---------------------------------------------------------------------------

STDMETHODIMP CDownload::DownloadRedundantCodeBase()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CDownload::DownloadRedundantCodeBase",
                "this=%#x",
                this
                ));
                
    HRESULT                      hr = S_FALSE;
    LISTPOSITION                 lpos = 0;
    CCodeBaseHold               *pcbh = NULL;

    if (m_pcbhList == NULL) {
        goto Exit;
    }

    lpos = m_pcbhList->GetHeadPosition();
    while (lpos) {
        pcbh = m_pcbhList->GetNext(lpos);
        if (!(pcbh->dwFlags & CBH_FLAGS_DOWNLOADED)) {
            RevokeBindStatusCallback(GetBindCtx(), GetBSC());
            CleanUp();
            m_url = new WCHAR[lstrlenW(pcbh->wszCodeBase) + 1];
            if (m_url == NULL) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            StrCpyW(m_url, pcbh->wszCodeBase);
            SetResponseHeaderStatus(S_OK);
            pcbh->dwFlags |= CBH_FLAGS_DOWNLOADED;

            // Try another download
            hr = DoDownload(m_ppmkContext, m_grfBINDF, m_pcbhList);
            break;
        }
    }

Exit:
    if (hr == S_FALSE) {
        GetCodeDownload()->CodeDownloadDebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_DL_REDUNDANT_FAILED);
    }
    else {
        LPSTR szUrl = NULL;
        Unicode2Ansi(m_url, &szUrl);
        GetCodeDownload()->CodeDownloadDebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_DL_REDUNDANT, (szUrl == NULL) ? ("") : (szUrl), hr);
        delete szUrl;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

void CDownload::CleanUp()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::CleanUp",
                "this=%#x",
                this
                ));
                
    LISTPOSITION               pos = 0;
    int                        i, iNum;

    SAFERELEASE(m_pmk);
    SAFERELEASE(m_pbc);
    SAFERELEASE(m_pbsc);
    SAFEDELETE(m_url);

    if (m_pFilesToExtract) {
        PFNAME pf = m_pFilesToExtract;
        PFNAME pfnext;

        for (;pf != NULL; pf = pfnext) {
            delete pf->pszFilename;
            pfnext = pf->pNextName;
            delete pf;
        }
    }
    m_pFilesToExtract = NULL;

    if (m_hPostData)
        GlobalFree(m_hPostData);

    SAFERELEASE(m_pUnkForCacheFileRelease);

    SAFEDELETE(m_pbJavaTrust);

    DEBUG_LEAVE(0);
}

HRESULT CDownload::SetMainCABJavaTrustPermissions(PJAVA_TRUST pbJavaTrust)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDownload::SetMainCABJavaTrustPermissions",
                "this=%#x, %#x",
                this, pbJavaTrust
                ));
                
    HRESULT hr = GetCodeDownload()->SetMainCABJavaTrustPermissions(pbJavaTrust);
    
    DEBUG_LEAVE(hr);
    return hr; 
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
//    The BSC implementation for CDownload to track progress of indiv dwlds
// ---------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(CDownload *pdl, DWORD grfBINDF)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CBindStatusCallback::CBindStatusCallback",
                "this=%#x, %#x, %#x",
                this, pdl, grfBINDF
                ));
                
    DllAddRef();
    m_pbinding = NULL;
    m_cRef = 1; // equ of internal addref
    m_pdl = pdl;

    m_grfBINDF = grfBINDF;

    DEBUG_LEAVE(0);
}  // CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::~CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CBindStatusCallback::~CBindStatusCallback",
                "this=%#x",
                this
                ));
                
    SAFERELEASE(m_pbinding);
    DllRelease();

    DEBUG_LEAVE(0);
}  // ~CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::AddRef()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CBindStatusCallback::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = m_cRef++;
    
    DEBUG_LEAVE(ulRet);
    return ulRet;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::Release()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CBindStatusCallback::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--m_cRef == 0) {
        delete this;
    
        DEBUG_LEAVE(0);
        return 0;
    }

    DEBUG_LEAVE(m_cRef);
    return m_cRef;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
        *ppv = (IBindStatusCallback *)this;

    if (riid==IID_IHttpNegotiate)
        *ppv = (IHttpNegotiate *)this;

    if (riid==IID_IWindowForBindingUI)
        *ppv = (IWindowForBindingUI*)this;

    if (riid==IID_IServiceProvider)
        *ppv = (IServiceProvider *)this;

    if (riid==IID_ICatalogFileInfo)
        *ppv = (ICatalogFileInfo *)this;

    if (*ppv == NULL)
    {
        DEBUG_LEAVE(E_NOINTERFACE);
        return E_NOINTERFACE;
    }
    
    AddRef();

    DEBUG_LEAVE(S_OK);
    return S_OK;

}  // CBindStatusCallback::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetWindow
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetWindow(REFGUID rguidreason, HWND *phWnd)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IWindowForBindingUI::GetWindow",
                "this=%#x, %#x, %#x",
                this, &rguidreason, phWnd
                ));
                
    HRESULT hr = S_OK;
    CCodeDownload *pcdl = m_pdl->GetCodeDownload();
    HWND hWnd = pcdl->GetClientBinding()->GetHWND(rguidreason);

    if (hWnd == INVALID_HANDLE_VALUE)
        hr = S_FALSE;

    *phWnd = hWnd;

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::QueryService
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppv)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &guidService, &riid, ppv
                ));
                
    IBindStatusCallback *pbsc = m_pdl->GetCodeDownload()->GetClientBSC();
    IServiceProvider *psp = NULL;
    HRESULT hr = E_NOINTERFACE;

    ASSERT(pbsc);

    if (pbsc && SUCCEEDED(pbsc->QueryInterface(IID_IServiceProvider, (void **)&psp)) && psp) {
        hr = psp->QueryService(guidService, riid, ppv);
        SAFERELEASE(psp);
    }
    
    // Since this is QueryService we can QI on our client's BSC object too.
    if (FAILED(hr)) {
    
        // This is special case we handle so we can bind to client's ultimate IBindHost
        // if one exists.  BUG BUG: Support other interfaces here, in general?
        // BUG BUG: Rearrange order of comparisons for performance.

        if (IsEqualGUID(guidService, riid) &&
            (IsEqualGUID(riid, IID_IBindHost) ||
             IsEqualGUID(riid, IID_IWindowForBindingUI) ||
             IsEqualGUID(riid, IID_ICodeInstall) ||
             IsEqualGUID(riid, IID_ICatalogFileInfo) ||
             IsEqualGUID(riid, IID_IInternetHostSecurityManager))) {

            hr = pbsc->QueryInterface(riid, (void **)ppv);
            
        }

    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pgrfBINDF, pbindInfo
                ));
                
    if ((pgrfBINDF == NULL) || (pbindInfo == NULL) || (pbindInfo->cbSize == 0))
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    *pgrfBINDF = m_grfBINDF;

    // clear BINDINFO but keep its size
    DWORD cbSize = pbindInfo->cbSize;
    ZeroMemory( pbindInfo, cbSize );
    pbindInfo->cbSize = cbSize;

    // use IE5's utf-8 policy
    pbindInfo->dwOptions |= BINDINFO_OPTIONS_USE_IE_ENCODING;


    if (m_pdl->DoPost()) {

        pbindInfo->dwBindVerb = BINDVERB_POST;

        pbindInfo->stgmedData.tymed = TYMED_HGLOBAL;
        pbindInfo->stgmedData.hGlobal = m_pdl->GetPostData(&(pbindInfo->cbstgmedData));
        pbindInfo->stgmedData.pUnkForRelease = (IUnknown *) (IBindStatusCallback *) this;
        AddRef();  // AddRef ourselves so we stick around; caller must release!

    }

    DWORD grfBINDF = 0;
    BINDINFO bindInfo;
    memset(&bindInfo, 0, sizeof(BINDINFO));
    bindInfo.cbSize = sizeof(BINDINFO);

    CCodeDownload *pcdl = m_pdl->GetCodeDownload();
    pcdl->GetClientBSC()->GetBindInfo(&grfBINDF, &bindInfo);

    if (grfBINDF & BINDF_SILENTOPERATION)
    {
        *pgrfBINDF |= BINDF_SILENTOPERATION;
        pcdl->SetSilentMode();
    }

    if (grfBINDF & BINDF_OFFLINEOPERATION)
        *pgrfBINDF |= BINDF_OFFLINEOPERATION;

    if (grfBINDF & BINDF_GETNEWESTVERSION)
        *pgrfBINDF |= BINDF_GETNEWESTVERSION;

    if (grfBINDF & BINDF_RESYNCHRONIZE)
        *pgrfBINDF |= BINDF_RESYNCHRONIZE;

    // or should we always insist on this regardless of what client wants?
    if (grfBINDF & BINDF_PREFERDEFAULTHANDLER)
        *pgrfBINDF |= BINDF_PREFERDEFAULTHANDLER;

    if (grfBINDF & BINDF_ENFORCERESTRICTED)
        *pgrfBINDF |= BINDF_ENFORCERESTRICTED;
        
    // To make sure the file winds up on disk even for SSL connections, we need to add
    *pgrfBINDF |= BINDF_NEEDFILE;

    //  BINDINFO_FIX(LaszloG 8/15/97)
    ReleaseBindInfo(&bindInfo);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}  // CBindStatusCallback::GetBindInfo

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD grfBSCOPTION,IBinding* pbinding)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBSCOPTION, pbinding
                ));
                
    CCodeDownload *pcdl = m_pdl->GetCodeDownload();

    Assert(pbinding);

    if (m_pbinding != NULL)
        SAFERELEASE(m_pbinding);
    m_pbinding = pbinding;
    if (m_pbinding != NULL)
        m_pbinding->AddRef();

    m_pdl->SetDLState(DLSTATE_BINDING);

    // call the client BSC::OnStartBinding if not already done

    CClBinding *pClientBinding = pcdl->GetClientBinding();

    if(pClientBinding->GetState() == CDL_NoOperation){

        Assert(pClientBinding->GetAssBSC() == pcdl->GetClientBSC());

        pClientBinding->SetState(CDL_Downloading);
        pcdl->AddRef();
        pcdl->GetClientBSC()->OnStartBinding(grfBSCOPTION, pClientBinding);
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}  // CBindStatusCallback::OnStartBinding

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));

    DEBUG_LEAVE(E_NOTIMPL);
    return E_NOTIMPL;
}  // CBindStatusCallback::GetPriority

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// Here we get the master CodeDownload obj to collate progress and report
// cumulative code download progress to client BSC::OnProgress.
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::GetPriority",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    IBindStatusCallback *pClientBSC = m_pdl->GetCodeDownload()->GetClientBSC();
    char szURL[INTERNET_MAX_URL_LENGTH];
    FILEXTN extn;
    char *pBaseFileName;
    HRESULT hr = S_OK;
    IMoniker *pmk = NULL;
    CCodeDownload *pcdl = m_pdl->GetCodeDownload();

    // if this a redirect set the context appropriately
    // also use this URL to get the extension and base dest name for this
    // component, if its a POST (Search Path)

    if (m_pdl->DoPost() && (ulStatusCode == BINDSTATUS_REDIRECTING)) {

        WideCharToMultiByte(CP_ACP, 0, szStatusText, -1, szURL,
                    INTERNET_MAX_URL_LENGTH, 0,0);


        // BUGBUG: use mime type in response header to determine extn
        extn = GetExtnAndBaseFileName( szURL, &pBaseFileName);

        hr = m_pdl->SetURLAndExtn( szStatusText, extn);

        if (SUCCEEDED(hr)) {

            IBindHost *pBH = pcdl->GetClientBinding()->GetIBindHost();
            if (pBH) {
                hr = pBH->CreateMoniker((LPOLESTR)szStatusText, m_pdl->GetBindCtx(), &pmk, 0);
            } else {
                hr =  CreateURLMoniker(NULL, szStatusText, &pmk);
            }


            if (SUCCEEDED(hr)) {
                pcdl->SetContextMoniker(pmk);
                pcdl->MarkNewContextMoniker();
            }
        }

        if (FAILED(hr))
            m_pdl->SetResponseHeaderStatus( hr );
    }

    // we are only interested in cumulative numbers for "downloading" status
    // for all others progress is usually: "connecting: 0 of 0", so we
    // pass these as is to our client

    if ((ulStatusCode != BINDSTATUS_DOWNLOADINGDATA ) &&
        (ulStatusCode != BINDSTATUS_ENDDOWNLOADDATA )) {

        // pass on progress as is to our client
        pClientBSC->OnProgress(ulProgress, ulProgressMax, ulStatusCode,
                                                                szStatusText);

        DEBUG_LEAVE(S_OK);
        return S_OK;
    }

    // here if Downloading Data progress
    m_pdl->SetProgress(ulProgress, ulProgressMax); // update my dl-object's prog

    // now summate stats and report to client
    CDownload *pdl = m_pdl->GetCodeDownload()->GetDownloadHead();
    ULONG ulSum = 0;
    ULONG ulSumMax = 0;

    // walk each dl object and make a sum of all ulProgress and ulProgressMax
    do {
        pdl->SumProgress(&ulSum, &ulSumMax);
    } while ((pdl = pdl->GetNext()) != NULL);


    // pass on cumulative downloading progress to our client
    pClientBSC->OnProgress(ulSum, ulSumMax, BINDSTATUS_DOWNLOADINGDATA,
                    m_pdl->GetCodeDownload()->GetMainURL());

    if (ulStatusCode == BINDSTATUS_ENDDOWNLOADDATA  ) {
        // pass on progress as is to our client
        pClientBSC->OnProgress(ulProgress, ulProgressMax, ulStatusCode,
                                                                szStatusText);
    }

    DEBUG_LEAVE(NOERROR);
    return(NOERROR);
}  // CBindStatusCallback


// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// At the last notification we get the filename URLmon has downloaded the
// m_url data to and rename it to a file in the temp dir.
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnDataAvailable(DWORD grfBSC, DWORD dwSize, FORMATETC *pFmtetc, STGMEDIUM  __RPC_FAR *pstgmed)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pFmtetc, pstgmed
                ));
                
    HRESULT hr = NO_ERROR;

    // never forward OnDataAvailable to code download's client BSC

    if (grfBSC & BSCF_LASTDATANOTIFICATION)
    {
        // if this is the final notification then get the data and display it

        // we asked for IUnknown, we should get back a filename
        Assert((pFmtetc->tymed & TYMED_FILE));

        if (pFmtetc->tymed & TYMED_FILE) {

            char szFile[MAX_PATH];
            DWORD dwLen = 0;

            if (!(dwLen = WideCharToMultiByte(CP_ACP, 0 , pstgmed->lpszFileName , -1 , szFile, MAX_PATH, NULL, NULL))) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;

            } else {

                LPSTR lpFileName = new char[dwLen + 1];

                if (!lpFileName) {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                } else {

                    lstrcpy(lpFileName, szFile);
                    m_pdl->SetFileName(lpFileName);
                }
            }

            // check last modified date for file: URLs
            // maybe we don't need the file
            HRESULT hr1 = m_pdl->IsDownloadedVersionRequired();

            if (FAILED(hr1)) {
                m_pdl->SetResponseHeaderStatus(hr1);
                goto Exit;
            }


            // ref count on the cache
            // file.

            pstgmed->pUnkForRelease->AddRef();

            m_pdl->SetUnkForCacheFileRelease(pstgmed->pUnkForRelease);

        }


    }


Exit:

    DEBUG_LEAVE(hr);
    return hr;

}  // CBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnObjectAvailable( REFIID riid, IUnknown* punk)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));
                
    // Not applicable: we call pmk->BTS not BTO

    DEBUG_LEAVE(E_NOTIMPL);
    return E_NOTIMPL;
}  // CBindStatusCallback::OnObjectAvailable

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::OnObjectAvailable",
                "this=%#x, %#x",
                this, dwReserved
                ));

    DEBUG_LEAVE(E_NOTIMPL);
    return E_NOTIMPL;
}  // CBindStatusCallback::OnLoadResource

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
//
// we get here when we have fully downloaded 'this'.
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IBindingStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hrStatus, szError
                ));
                
    CCodeDownload *pcdl = m_pdl->GetCodeDownload();
    HRESULT hrResponseHdr = m_pdl->GetResponseHeaderStatus();
    IBindHost *pBindHost = NULL;
    HRESULT hr = S_OK; // assume all OK

    if (pcdl) {
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, FALSE, ID_CDLDBG_DL_ON_STOP_BINDING, hrStatus, hrResponseHdr);
    }
    if ((FAILED(hrStatus) && (SCODE_FACILITY(hrStatus) == FACILITY_INTERNET)) ||
        FAILED(hrResponseHdr) || SCODE_CODE(hrStatus) == ERROR_MOD_NOT_FOUND) {
        hr = m_pdl->DownloadRedundantCodeBase();
        if (hr == E_PENDING || hr == MK_S_ASYNCHRONOUS) {
            goto Exit;
        }
    }

    m_pdl->SetDLState(DLSTATE_DOWNLOADED);

    pBindHost = pcdl->GetClientBinding()->GetIBindHost();

    SAFERELEASE(m_pbinding);

    if (!pBindHost) {
        hr = RevokeBindStatusCallback(m_pdl->GetBindCtx(), m_pdl->GetBSC());

    }

    if (FAILED(hr)) {
        goto OSB_Complete;
    }

    // if URLMON failed the download or if the response hdr indicated
    // a failure that URLMON failed to detect properly
    // pass the problem to pcdl->CompleteOne(). This will determine if it
    // will query for the clsid with more urls in the CodeSearchPath
    // in the registry.
    if (FAILED(hrStatus) || FAILED(hrResponseHdr)) {
        goto OSB_Complete;
    }

    // BUGBUG: also check here for Last Modified Date on the Cache Entry
    // versus Last Modified if a previous version exists and we are doung 
    // GetLatest. If data is in the cache then wininet ignores our
    // if-modified-since and so we will end up re-installing even though
    // there is no version change.

    if (m_pdl->GetFileName() != NULL) { // should be set by OnDataAvailable

        // This takes us to the next state. VerifyTrust moves us when
        // complete to the next state of processing the ProcessPiece.

        CCDLPacket *pPkt= new CCDLPacket(CODE_DOWNLOAD_TRUST_PIECE, m_pdl, 0);

        if (pPkt) {
            hr = pPkt->Post();
        } else {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
            goto Exit;
        // else fall thru to OSB_Complete

    } else if (!m_pdl->UsingCdlProtocol()) {

        // In case of CDL protocol handler we don't need OnDataAvailable or 
        // Trust Verification done here.

        // BindToStorage may have not detected the error
        if (m_pdl->DoPost())
            hrResponseHdr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        else
            hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
    }

OSB_Complete:

    // does all the master state analysis
    m_pdl->CompleteSignal(hr, hrStatus, hrResponseHdr, szError);

    // This very BSC may already have been deleted if all done.
    // Don't access any members. Just return !!!

Exit:

    DEBUG_LEAVE(S_OK);
    return S_OK; // always succeed to url mon.

}  // CBindStatusCallback::OnStopBinding


// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::BeginningTransaction
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::BeginningTransaction(
    LPCWSTR szURL,
    LPCWSTR szHeaders,
    DWORD dwReserved,
    LPWSTR *pszAdditionalHeaders)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IHttpNegotiate::BeginningTransaction",
                "this=%#x, %.80wq, %.80wq, %#x, %#x",
                this, szURL, szHeaders, dwReserved, pszAdditionalHeaders
                ));
                
    HRESULT hr = S_OK;
    char szHttpDate[INTERNET_RFC1123_BUFSIZE+1];
    DWORD dwLen = 0;
    LPWSTR szAHdrs = NULL;
    static const char cszHeaderFmt[] = "%s %s\r\n";
    static const char szIfMod[] = "If-Modified-Since:";
    static const char szNONEMATCH[] = "If-None-Match:";
    static const WCHAR szFORM[] = L"Content-Type: application/x-www-form-urlencoded\r\n";
    static const char szAcceptLanguageFmt[] = "Accept-Language: %s\r\n";
    char szBuf[MAX_PATH];
    WCHAR szAcceptLanguage[MAX_PATH];
    char szLangBuf[10];
    char *pszNoneMatch = NULL;

    CCodeDownload *pcdl = m_pdl->GetCodeDownload();
    LCID lcid = pcdl->GetLCID();

    // BUGBUG: we currently only support primary lang or default
    // it should really be "en-us, en", instead of just "en"
    // waiting for note from TonyCi about some servers like Apache
    // broken by this
    lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(lcid)), SUBLANG_DEFAULT), SORT_DEFAULT);

    DEBUG_PRINT(DOWNLOAD, 
                INFO,
                ("this=%#x, m_lcid: %d (%#x), lcid: %d (%#x)\n",
                this, pcdl->GetLCID(), pcdl->GetLCID(), lcid, lcid
                ));

    *szAcceptLanguage = L'\0';
    if (pcdl->GetLangInfo()->GetAcceptLanguageString(lcid, szLangBuf, sizeof(szLangBuf))
        && (*szLangBuf != '\0'))
    {
        wnsprintf(szBuf, sizeof(szBuf)-1, szAcceptLanguageFmt, szLangBuf);
        dwLen = MultiByteToWideChar(CP_ACP, 0, szBuf, -1, szAcceptLanguage, MAX_PATH);
    }
    
    Assert((pszAdditionalHeaders != NULL));

    FILETIME *pftLastMod = pcdl->GetLastModifiedTime();
    SYSTEMTIME  sSysTime;

    BOOL bSendNoneMatch = !pcdl->ForceDownload() && ( pcdl->LocalVersionPresent() && (pcdl->GetLocalVersionEtag()) ) && pcdl->NeedLatestVersion();

    BOOL bSendLastMod = !bSendNoneMatch && (!pcdl->ForceDownload() && ( pcdl->LocalVersionPresent() && (pftLastMod) ) && pcdl->NeedLatestVersion());


    if ( bSendLastMod) {
        Assert( (pftLastMod != NULL) ); // Check for bug#40696

        // need to send If-Modified-Since

        if (!FileTimeToSystemTime(pftLastMod, &sSysTime)) {
            m_pdl->SetResponseHeaderStatus( HRESULT_FROM_WIN32(GetLastError()));
            goto Exit;
        }

        if (!InternetTimeFromSystemTimeA(&sSysTime, INTERNET_RFC1123_FORMAT,
            szHttpDate, INTERNET_RFC1123_BUFSIZE)) {

            m_pdl->SetResponseHeaderStatus( HRESULT_FROM_WIN32(GetLastError()));
            goto Exit;
        }


       dwLen += (INTERNET_RFC1123_BUFSIZE + 1 + sizeof(szIfMod) +
            sizeof(cszHeaderFmt));

    }

    if (bSendNoneMatch) {

        DWORD dwNoneMatch = lstrlen(pcdl->GetLocalVersionEtag()) + sizeof(szNONEMATCH) + sizeof(cszHeaderFmt);
        pszNoneMatch = new char [dwNoneMatch+1];
        wsprintf(pszNoneMatch, cszHeaderFmt, szNONEMATCH, pcdl->GetLocalVersionEtag());

        dwLen += dwNoneMatch;
    }

    if (m_pdl->DoPost()) {
        dwLen += sizeof(szFORM);
    }

    if (dwLen) {

        szAHdrs = new WCHAR [dwLen + 1];

        if (!szAHdrs) {
            m_pdl->SetResponseHeaderStatus( E_OUTOFMEMORY );

            // BUGBUG: Clean all this up to never return right away, and
            // goto exit to cleanup
            SAFEDELETE(pszNoneMatch);

            DEBUG_LEAVE(hr);
            return hr;
        }

        szAHdrs[0] = '\0';
    }

    if (bSendLastMod) {
        char *szTemp = new char [dwLen + 1];

        if (!szTemp) {
            hr = E_OUTOFMEMORY;
            delete szAHdrs;
            goto Exit;
        }

        wsprintf(szTemp, cszHeaderFmt, szIfMod, szHttpDate);
        MultiByteToWideChar(CP_ACP, 0, szTemp, -1, szAHdrs, dwLen);

        delete szTemp;

    }

    if (bSendNoneMatch) {
        MultiByteToWideChar(CP_ACP, 0, pszNoneMatch, -1, szAHdrs, dwLen);
    }

    if (m_pdl->DoPost()) {
        StrCatW(szAHdrs, szFORM);
    }

    if (*szAcceptLanguage != L'\0')
    {
        StrCatW(szAHdrs, szAcceptLanguage);
    }

Exit:

    SAFEDELETE(pszNoneMatch);

    *pszAdditionalHeaders = szAHdrs;

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnResponse
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnResponse(
    DWORD dwResponseCode,
    LPCWSTR szResponseHeaders,
    LPCWSTR szRequestHeaders,
    LPWSTR *pszAdditionalRequestHeaders)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::IHttpNegotiate::OnResponse",
                "this=%#x, %#x, %.80wq, %.80wq, %#x",
                this, dwResponseCode, szResponseHeaders, szRequestHeaders, pszAdditionalRequestHeaders
                ));
                
    HRESULT hr = S_OK;

    // propogate errors here to CSBC::OnStopBinding
    // we need this as urlmon might just convert any error returned here
    // as user_cancelled
    if (dwResponseCode != HTTP_STATUS_OK) {
        if (dwResponseCode == HTTP_STATUS_NOT_MODIFIED) {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        }
        m_pdl->SetResponseHeaderStatus( hr );
    }

    if (m_pdl->DoPost() || 
        (m_pdl->GetMoniker() == m_pdl->GetCodeDownload()->GetContextMoniker())){

        // Get the HttpQueryInfo wrapper object.
        IWinInetHttpInfo *pHttpInfo = NULL;
        HRESULT hr = GetBinding()->QueryInterface
            (IID_IWinInetHttpInfo, (void **) &pHttpInfo);


        if (SUCCEEDED(hr)) {
            DWORD cbLen = INTERNET_RFC1123_BUFSIZE + 1;
            char szHttpDate[INTERNET_RFC1123_BUFSIZE+1];


            if ((pHttpInfo->QueryInfo (HTTP_QUERY_LAST_MODIFIED,
                (LPVOID)szHttpDate, &cbLen, NULL, 0) == S_OK) && cbLen)
                 m_pdl->GetCodeDownload()->SetLastModifiedTime(szHttpDate);

            cbLen = 0; // reset

            if ( (pHttpInfo->QueryInfo (HTTP_QUERY_ETAG,
                (LPVOID)NULL, &cbLen, NULL, 0) == S_OK) && cbLen) {

                char *pbEtag = new char [cbLen  +1];

                if (pbEtag)
                {
                    *pbEtag = '\0'; // clr

                    pHttpInfo->QueryInfo (HTTP_QUERY_ETAG,
                        (LPVOID)pbEtag, &cbLen, NULL, 0);

                    if (*pbEtag)
                        m_pdl->GetCodeDownload()->SetEtag(pbEtag);
                }
            }
        
            pHttpInfo->Release();
        }
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetCatalogFile
// ---------------------------------------------------------------------------
STDMETHODIMP CBindStatusCallback::GetCatalogFile(LPSTR *ppszCatalogFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::ICatalogFileInfo::GetCatalogFile",
                "this=%#x, %#x",
                this, ppszCatalogFile
                ));
                
    HRESULT                        hr = S_OK;
    LPSTR                          pszCatFile = NULL;

    if (ppszCatalogFile) {
        pszCatFile = m_pdl->GetCodeDownload()->GetCatalogFile();
        if (pszCatFile) {
            *ppszCatalogFile = new char[lstrlen(pszCatFile) + 1];
            if (*ppszCatalogFile == NULL) {
                hr = E_OUTOFMEMORY;
            }
            else {
                lstrcpy(*ppszCatalogFile, pszCatFile);
            }
        }
        else {
            *ppszCatalogFile = NULL;
        }
    }
    else {
        hr = E_INVALIDARG;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetJavaTrust
// ---------------------------------------------------------------------------
STDMETHODIMP CBindStatusCallback::GetJavaTrust(void **ppJavaTrust)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CBindStatusCallback::ICatalogFileInfo::GetJavaTrust",
                "this=%#x, %#x",
                this, ppJavaTrust
                ));
                
    HRESULT                   hr = S_OK;

    if (ppJavaTrust) {
        *ppJavaTrust = (void *)m_pdl->GetCodeDownload()->GetJavaTrust();
    }
    else {
        hr = E_INVALIDARG;
    }

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\duman.cxx ===
// ===========================================================================
// File: DUMAN.CXX
//    Distribution Unit Manager
//

#include <cdlpch.h>
#include <dispex.h>
#include <delaydll.h>

#define ERROR_EXIT(cond) if (!(cond)) { \
        goto Exit;}

HRESULT DupAttributeA(IXMLElement *pElem, LPWSTR szAttribName, LPSTR *ppszRet)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "DupAttributeA",
                "%#x, %.80wq, %#x",
                pElem, szAttribName, ppszRet
                ));
                
    VARIANT vProp;
    LPSTR pVal = NULL;

    HRESULT hr = GetAttribute(pElem, szAttribName, &vProp);

    if (SUCCEEDED(hr)) {

        DWORD len;
        // compute length
        if (!(len = WideCharToMultiByte(CP_ACP, 0, vProp.bstrVal , -1, pVal,
                            0, NULL, NULL))) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        pVal = new char[len+1];
        if (!pVal) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if (!WideCharToMultiByte(CP_ACP, 0, vProp.bstrVal , -1, pVal,
                            len, NULL, NULL)) {

            SAFEDELETE(pVal);
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

Exit:

    VariantClear(&vProp);

    if (pVal) {
        SAFEDELETE((*ppszRet));
        *ppszRet = pVal;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT DupAttribute(IXMLElement *pElem, LPWSTR szAttribName, LPWSTR *ppszRet)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "DupAttribute",
                "%#x, %.80wq, %#x",
                pElem, szAttribName, ppszRet
                ));
                
    VARIANT vProp;
    LPWSTR pVal = NULL;

    HRESULT hr = GetAttribute(pElem, szAttribName, &vProp);

    if (SUCCEEDED(hr)) {

        Assert(vProp.vt == VT_BSTR);
        Assert(vProp.bstrVal);

        if (vProp.bstrVal) {
            hr = CDLDupWStr( &pVal, vProp.bstrVal); 
        } else {
            hr = E_FAIL;
        }
    }

    VariantClear(&vProp);

    if (pVal) {
        SAFEDELETE((*ppszRet));
        *ppszRet = pVal;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetAttributeA(IXMLElement *pElem, LPWSTR szAttribName, LPSTR pAttribValue, DWORD dwBufferLen)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetAttributeA",
                "%#x, %.80wq, %.80q, %#x",
                pElem, szAttribName, pAttribValue, dwBufferLen
                ));
                
    VARIANT vProp;

    HRESULT hr = GetAttribute(pElem, szAttribName, &vProp);

    if (SUCCEEDED(hr)) {


        if (!WideCharToMultiByte(CP_ACP, 0, vProp.bstrVal , -1, pAttribValue,
                            dwBufferLen, NULL, NULL)) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        VariantClear(&vProp);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetAttribute(IXMLElement *pElem, LPWSTR szAttribName, VARIANT *pvProp)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetAttribute",
                "%#x, %.80wq, %#x",
                pElem, szAttribName, pvProp
                ));
                
    HRESULT hr = S_OK;

    VariantInit(pvProp);

    if ((hr = pElem->getAttribute(szAttribName, pvProp)) == S_OK )
    {
        Assert(pvProp->vt == VT_BSTR);
        // caller needs to VariantClear(pvProp);
    }

    if (hr == S_FALSE) {

        hr = REGDB_E_KEYMISSING;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetNextChildTag(IXMLElement *pRoot, LPCWSTR szTag, IXMLElement **ppChildReq, int &nLastChild)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetNextChildTag",
                "%#x, %.80wq, %#x, %#x",
                pRoot, szTag, ppChildReq, &nLastChild
                ));
                
    BSTR bstrTag = NULL;
    IXMLElementCollection * pChildren = NULL;
    HRESULT hr = S_FALSE;   // assume not found.
    IXMLElement * pChild = NULL;

    //
    // Find the children if they exist
    //
    if (SUCCEEDED(pRoot->get_children(&pChildren)) && pChildren)
    {
        long length = 0;

        if (SUCCEEDED(pChildren->get_length(&length)) && length > 0)
        {
            VARIANT vIndex, vEmpty;
            vIndex.vt = VT_I4;
            vEmpty.vt = VT_EMPTY;

            nLastChild++;

            for (long i=nLastChild; i<length; i++)
            {
                vIndex.lVal = i;
                IDispatch *pDispItem = NULL;
                if (SUCCEEDED(pChildren->item(vIndex, vEmpty, &pDispItem)))
                {

                    if (SUCCEEDED(pDispItem->QueryInterface(IID_IXMLElement, (void **)&pChild)))
                    {
                        // look for first SoftDist tag

                        pChild->get_tagName(&bstrTag);

                        // we may get a NULL bstrTag, possibly from a comment TAG, hence check returned bstrTag
                        if (bstrTag && (StrCmpIW(bstrTag, szTag) == 0)) 
                        {
                            nLastChild = i;
                            SAFERELEASE(pDispItem);
                            hr = S_OK;
                            goto Exit;
                        }

                        SAFESYSFREESTRING(bstrTag);

                        SAFERELEASE(pChild);
                    }

                    SAFERELEASE(pDispItem);

                }


            }
        }

    }
    else
    {
        hr = E_FAIL;
    }


Exit:

    *ppChildReq = pChild;

    if (pChildren)
        SAFERELEASE(pChildren);

    SAFESYSFREESTRING(bstrTag);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetFirstChildTag(IXMLElement *pRoot, LPCWSTR szTag, IXMLElement **ppChildReq)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetFirstChildTag",
                "%#x, %.80wq, %#x",
                pRoot, szTag, ppChildReq
                ));
                
    int nLastChild = -1; // first child, never seen any before this one

    HRESULT hr = GetNextChildTag(pRoot, szTag, ppChildReq, nLastChild);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
GetTextContent(IXMLElement *pRoot, LPCWSTR szTag, LPWSTR *ppszContent)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetTextContent",
                "%#x, %.80wq, %#x",
                pRoot, szTag, ppszContent
                ));
                
    IXMLElement *pChild = NULL;
    HRESULT hr = S_OK;

    if (GetFirstChildTag(pRoot, szTag, &pChild) == S_OK) {

        BSTR bstrText = NULL;
        hr = pChild->get_text(&bstrText);
        if (FAILED(hr)) {
            goto Exit;
        }
        if (bstrText) {
            hr = CDLDupWStr( ppszContent, bstrText); 
        } else {
            hr = E_FAIL;
        }
        
        SAFESYSFREESTRING(bstrText);
    }

Exit:

    SAFERELEASE(pChild);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetSoftDistFromOSD(LPCSTR szFile, IXMLElement **ppSoftDist)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetSoftDistFromOSD",
                "%.80q, %#x",
                szFile, ppSoftDist
                ));
                
    HRESULT hr = S_OK;

    IXMLDocument           *pDoc = NULL;
    IStream                *pStm = NULL;
    IPersistStreamInit     *pPSI = NULL;
    IXMLElement            *pRoot = NULL;
    BSTR                    bStrName;


    // BUGBUG: optimize here to keep the xml parser up beyond the current code
    // download?

    //
    // Create an empty XML document
    //
    hr = CoCreateInstance(CLSID_XMLDocument, NULL, CLSCTX_INPROC_SERVER,
                                IID_IXMLDocument, (void**)&pDoc);

    ERROR_EXIT (pDoc);

    //
    // Synchronously create a stream on an URL
    //
    hr = URLOpenBlockingStream(0, szFile, &pStm, 0,0);    
    ERROR_EXIT(SUCCEEDED(hr) && pStm);
    
    //
    // Get the IPersistStreamInit interface to the XML doc
    //
    hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void **)&pPSI);
    ERROR_EXIT(SUCCEEDED(hr));

    //
    // Init the XML doc from the stream
    //
    hr = pPSI->Load(pStm);
    ERROR_EXIT(SUCCEEDED(hr));

    //
    // Now walk the OM and look at interesting things:
    //
    hr = pDoc->get_root(&pRoot);
    ERROR_EXIT(SUCCEEDED(hr));
    hr = pRoot->get_tagName(&bStrName);

    if (StrCmpIW(bStrName, DU_TAG_SOFTDIST) == 0) 
    {
        *ppSoftDist = pRoot;
        (*ppSoftDist)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppSoftDist = NULL;
        hr = E_FAIL;
    }
    

    SAFESYSFREESTRING(bStrName);
    

                         
Exit: 

    SAFERELEASE(pDoc);
    SAFERELEASE(pPSI);
    SAFERELEASE(pStm);
    SAFERELEASE(pRoot);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\fdi.h ===
/***    types.h  - Common defines for FCI/FDI stuff -- goes into FCI/FDI.H
 *
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993-1994
 *  All Rights Reserved.
 *
 *  History:
 *      03-Mar-1993 chuckst Merged from other files
 *      08-Mar-1994 bens    Changed symbol to control recursive include
 *      09-Mar-1994 bens    Cleanups for RESERVE modifications
 *      16-Mar-1994 bens    Nuke padlong()
 *      21-Mar-1994 bens    Spruce up comments
 *      22-Mar-1994 bens    Add BIT16 test so we can build 16 or 32 bit!
 *      26-May-1994 bens    Added Quantum compression definitions
 */

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#pragma warning(disable:4121)

//** Define away for 32-bit (NT/Chicago) build
#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif



#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI
#if !defined(unix) && !defined(_WIN64)
#pragma pack(4)
#endif /* !defined(unix) && !defined(_WIN64) */
//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif


/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  (16-bit clients please note -- the size is a ULONG, so you may need
 *  to write a wrapper routine for halloc!).  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           Diamond/FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    tcompXXX - Diamond compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))


//** Revert to default structure packing
#if !defined(unix) && !defined(_WIN64)
#pragma pack()
#endif /* !defined(unix) && !defined(_WIN64) */
#endif // !INCLUDED_TYPES_FCI_FDI
/***    fdi_int.h - Diamond File Decompression Interface definitions
 *                      
 *      Microsoft Confidential
 *      Copyright (C) Microsoft Corporation 1993-1994
 *      All Rights Reserved.
 *
 *  Author:
 *      Chuck Strouss, Benjamin W. Slivka
 *
 *  History:
 *      30-Nov-1993 chuckst Created
 *      21-Dec-1993 bens    Updated with comments from 12/21/93 design review
 *      09-Mar-1994 bens    Add new error code
 *      17-Mar-1994 bens    Specify structure packing explicitly
 *      21-Mar-1994 bens    Spruce up comments
 *      25-Mar-1994 bens    Add fdintCABINET_INFO notification
 *      31-Mar-1994 bens    Clarify handling of open files when errors occur
 *      01-Apr-1994 bens    Add FDIIsCabinet() function.
 *      07-Apr-1994 bens    Add Decryption interfaces; remove fdintPROGRESS
 *      11-Apr-1994 bens    Add more guidance on how to respond to FDI errors.
 *      13-Apr-1994 bens    Add date & time & attribs to fdintCOPY_FILE
 *      18-Apr-1994 bens    Changed CDECL to DIAMONDAPI
 *      05-May-1994 bens    Clarified error handling (billhu/alanr/migueldc)
 *      11-May-1994 bens    Added setId/iCabinet to fdintNEXT_CABINET
 *      07-Jul-1994 bens    Support Quantum virtual file -- PLEASE note the
 *                              comments about PFNOPEN/PFNCLOSE changes, and
 *                              about reserving memory, if necessary, before
 *                              calling FDICreate()!
 *      19-Aug-1994 bens    Add cpuType parameter to FDICreate().
 *      03-Apr-1995 jeffwe  Added chaining indicators to FDICABINETINFO
 *
 *
 *  ATTENTION:
 *      This is the only documentation on the Diamond File Decompression
 *      Interface (FDI).  Please read it carefully, as there are some subtle
 *      points in FDI that are carefully explained below.
 *
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since Diamond concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but Diamond does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since Diamond compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require Diamond to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      Diamond cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint,...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *                  //NOTE: Be sure to see the (sample) code in EXTRACT.C
 *                  //      for an example of how to do this!
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

#ifndef INCLUDED_FDI
#define INCLUDED_FDI    1

//** Specify structure packing explicitly for clients of FDI
#if !defined(unix) && !defined(_WIN64)
#pragma pack(4)
#endif /* !defined(unix) && !defined(_WIN64) */

/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of Diamond used to
        //              create the cabinet and the FDI. LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinet
        //              in a set.  Diamond will only generate cabinet sets
        //              with these properties.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When DIAMOND.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT                        // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    }
#ifdef unix 
MWUNION_TAG
#endif /* unix */
;
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          Diamond will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    char FAR *psz1;
    char FAR *psz2;
    char FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    INT_PTR   hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET               // File continued to next cabinet
} FDINOTIFICATIONTYPE; /* fdint */

typedef INT_PTR (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                           PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) INT_PTR FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                              PFDINOTIFICATION    pfdin)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *
 *  SPECIAL NOTE FOR QUANTUM DECOMPRESSION:
 *      When using Quantum compression, at compress time (with Diamond)
 *      you specify how much memory Quantum requires at *decompress* time
 *      to store the decompression history buffer.  This can be as large
 *      as *2Mb*, and in an MS-DOS environment, for example, this much
 *      memory may not be available (certainly not under 640K!).  To permit
 *      large CompressionMemory settings on any machine, the Quantum
 *      decompressor will attempt to create a "spill file" if there is not
 *      sufficient memory available.
 *
 *      For PFNOPEN, a special pszFile parameter is passed to indicate that
 *      a temporary "spill file" is requested.  The name passed is "*", and
 *      you should cast the pszFile parameter to an FDISPILLFILE pointer,
 *      and get the requested file size.  You then need to create a file
 *      of the specified size with read/write access, save the file name and
 *      handle for later use by PFNCLOSE, and then return the handle.  If
 *      you cannot create the file of the specified size, you should return
 *      an error (-1).  This file should be placed on a fast local hard disk,
 *      to maximize the speed of decompression.
 *
 *      For PFNCLOSE, you should check the handle to see if it the spill file
 *      created previously by PFNOPEN (FDI will create at most one spill file
 *      per FDICreate() call).  If it is the spill file handle, you should
 *      close the handle and then delete the file, using the file name you
 *      saved when you created the spill file in PFNOPEN.
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (INT_PTR hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(INT_PTR hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(INT_PTR hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (INT_PTR hf, long dist, int seektype);

#if !defined(unix) && !defined(_WIN64)
#pragma pack(1)
#endif /* !defined(unix) && !defined(_WIN64) */
/** FDISPILLFILE - Pass as pszFile on PFNOPEN to create spill file
 *
 *  ach    - A two byte string to signal to PFNOPEN that a spill file is
 *           requested.  Value is '*','\0'.
 *  cbFile - Required spill file size, in bytes.
 */
typedef struct {
    char    ach[2];                 // Set to { '*', '\0' }
    long    cbFile;                 // Required spill file size
} FDISPILLFILE; /* fdisf */
typedef FDISPILLFILE *PFDISPILLFILE; /* pfdisf */
#if !defined(unix) && !defined(_WIN64)
#pragma pack()
#endif /* !defined(unix) && !defined(_WIN64) */

/*** cpuType values for FDICreate()
 *
 *  WARNING: For 16-bit Windows applications, the CPU detection may not
 *           correctly detect 286 CPUs.  Instead, use the following code:
 *
 *              DWORD   flags;
 *              int     cpuType;
 *
 *              flags = GetWinFlags();
 *              if (flags & WF_CPU286)
 *                  cpuType = cpu80286;
 *              else
 *                  cpuType = cpu80386;
 *
 *              hfdi = FDICreate(....,cpuType,...);
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 WARNING: Don't use auto-detect from a 16-bit Windows
 *                          application!  Use GetWinFlags()!
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 *  Special notes for Quantum Decompression:
 *      If you have used a high setting for CompressionMemory in creating
 *      the cabinet file(s), then FDI will attempt to allocate a lot of
 *      memory (as much as 2Mb, if you specified 21 for CompressionMemory).
 *      Therefore, if you plan to allocate additional memory *after* the
 *      FDICreate() call, you should reserve some memory *prior* to calling
 *      FDICreate(), and then free it up afterwards (or do all your allocation
 *      before calling FDICreate().
 */
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);


/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.
 */
BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici);


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).
 */
BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char FAR     *pszCabinet,
                            char FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);


/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 */
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);


//** Revert to default structure packing
#if !defined(unix) && !defined(_WIN64)
#pragma pack()
#endif /* !defined(unix) && !defined(_WIN64) */
#endif //!INCLUDED_FDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\extract.c ===
/*
 *  EXTRACT.C borrowed from TWEX\wextract.c
 *
 *  Has the CAB extraction capabilty for Code Downloader; uses FDI.LIB
 */

#include <urlmon.h>
#include <io.h>
#include <stdio.h>
#include <fcntl.h>
#include "cdl.h"

#ifdef unix
#include "unixfile.h"
#endif /* unix */

//
// single theaded access to the FDI lib
static BOOL fCritCreated = FALSE;
CRITICAL_SECTION g_mxsFDI;

    
/*
 * W i n 3 2 O p e n ( )
 *
 * Routine:     Win32Open()
 *              
 * Purpose:     Translate a C-Runtime _open() call into appropriate Win32
 *              CreateFile()
 *
 * Returns:     Handle to file              on success
 *              INVALID_HANDLE_VALUE        on failure
 *
 *
 * BUGBUG: Doesn't fully implement C-Runtime _open() capability but it
 * BUGBUG: currently supports all callbacks that FDI will give us
 */

HANDLE
Win32Open(char *pszFile, int oflag, int pmode )
{
    HANDLE  FileHandle = INVALID_HANDLE_VALUE;
    BOOL    fExists     = FALSE;
    DWORD   fAccess;
    DWORD   fCreate; 


    ASSERT( pszFile );

        // BUGBUG: No Append Mode Support
    if (oflag & _O_APPEND)
        return( INVALID_HANDLE_VALUE );

        // Set Read-Write Access
    if ((oflag & _O_RDWR) || (oflag & _O_WRONLY))
        fAccess = GENERIC_WRITE;
    else
        fAccess = GENERIC_READ;

        // Set Create Flags
    if (oflag & _O_CREAT)  {
        if (oflag & _O_EXCL)
            fCreate = CREATE_NEW;
        else if (oflag & _O_TRUNC)
            fCreate = CREATE_ALWAYS;
        else 
            fCreate = OPEN_ALWAYS;
    } else {
        if (oflag & _O_TRUNC)  
            fCreate = TRUNCATE_EXISTING;
        else
            fCreate = OPEN_EXISTING;
    }

#ifdef unix
    UnixEnsureDir(pszFile);
#endif /* unix */

    //BUGBUG: seterrormode to no crit errors and then catch sharing violations
    // and access denied

    // Call Win32
    FileHandle = CreateFile(
                        pszFile, fAccess, FILE_SHARE_READ, NULL, fCreate,
                        FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE
                       );

    if (FileHandle == INVALID_HANDLE_VALUE && 
        SetFileAttributes(pszFile, FILE_ATTRIBUTE_NORMAL))
        FileHandle = CreateFile(
                            pszFile, fAccess, FILE_SHARE_READ, NULL, fCreate,
                            FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE
                           );
    return( FileHandle );
}



        

/*
 * O p e n F u n c ( )
 *
 * Routine:     OpenFunc()
 *
 * Purpose:     Open File Callback from FDI
 *
 * Returns:     File Handle (small integer index into file table)
 *              -1 on failure
 *
 */

int FAR DIAMONDAPI openfunc(char FAR *pszFile, int oflag, int pmode )
{
    int     rc;
    HANDLE hf;


    ASSERT( pszFile );

            //BUGBUG Spill File Support for Quantum?
    if ((*pszFile == '*') && (*(pszFile+1) != 'M'))  {
        DEBUGTRAP("Spill File Support for Quantum Not Supported");
    }


    hf = Win32Open(pszFile, oflag, pmode );
    if (hf != INVALID_HANDLE_VALUE)  {
        // SUNDOWN: typecast problem
        rc = PtrToLong(hf);
    } else {
        rc = -1;
    }

    return( rc );
}







/*
 * R E A D F U N C ( )
 *
 * Routine:     readfunc()
 *
 * Purpose:     FDI read() callback
 *
 */

UINT FAR DIAMONDAPI readfunc(INT_PTR hf, void FAR *pv, UINT cb)
{
    int     rc;


    ASSERT( pv );
            
    if (! ReadFile((HANDLE)hf, pv, cb, (DWORD *) &cb, NULL))
        rc = -1;
    else
        rc = cb;

    return( rc );
}





/*
 *  W r i t e F u n c ( )
 *
 * Routine:     WriteFunc()
 *
 * Purpose:     FDI Write() callback
 *
 */

UINT FAR DIAMONDAPI
writefunc(INT_PTR hf, void FAR *pv, UINT cb)
{
    int rc;

    ASSERT( pv );
    
    if (! WriteFile((HANDLE)hf, pv, cb, (DWORD *) &cb, NULL)) 
        rc = -1;
    else
        rc = cb;


    // BUGBUG: implement OnProgress notification

    return( rc );
}




/*
 * C l o s e F u n c ( )
 *
 * Routine:     CloseFunc()
 *
 * Purpose:     FDI Close File Callback
 *
 */

int FAR DIAMONDAPI closefunc( INT_PTR hf )
{
    int rc;


    if (CloseHandle( (HANDLE)hf ))  {
        rc = 0;
    } else {
        rc = -1;
    }

    return( rc );
}





/*
 * S e e k F u n c ( )
 *
 * Routine:     seekfunc()
 *
 * Purpose:     FDI Seek Callback
 */
 
long FAR DIAMONDAPI seekfunc( INT_PTR hf, long dist, int seektype )
{
    long    rc;
    DWORD   W32seektype;


        switch (seektype) {
            case SEEK_SET:
                W32seektype = FILE_BEGIN;
                break;
            case SEEK_CUR:
                W32seektype = FILE_CURRENT;
                break;
            case SEEK_END:
                W32seektype = FILE_END;
                break;
        }

        rc = SetFilePointer((HANDLE)hf, dist, NULL, W32seektype);
        if (rc == 0xffffffff)
            rc = -1;            

    return( rc );
}   



/*
 * A d j u s t F i l e T i m e ( )
 *
 * Routine:     AdjustFileTime()
 *
 * Purpose:     Change the time info for a file
 */

BOOL
AdjustFileTime(INT_PTR hf, USHORT date, USHORT time )
{
    FILETIME    ft;
    FILETIME    ftUTC;


    if (! DosDateTimeToFileTime( date, time, &ft ))
        return( FALSE );

    if (! LocalFileTimeToFileTime(&ft, &ftUTC))
        return( FALSE );

    if (! SetFileTime((HANDLE)hf,&ftUTC,&ftUTC,&ftUTC))
        return( FALSE );

    return( TRUE );
}



/*
 * A t t r 3 2 F r o m A t t r F A T ( )
 *
 * Translate FAT attributes to Win32 Attributes
 */
 
DWORD Attr32FromAttrFAT(WORD attrMSDOS)
{
    //** Quick out for normal file special case
    if (attrMSDOS == _A_NORMAL) {
        return FILE_ATTRIBUTE_NORMAL;
    }

    //** Otherwise, mask off read-only, hidden, system, and archive bits
    //   NOTE: These bits are in the same places in MS-DOS and Win32!
    //
    return attrMSDOS & ~(_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
}





/*
 * A l l o c F u n c ( )
 *
 * FDI Memory Allocation Callback
 */
        
FNALLOC(allocfunc)
{
    void *pv;

    pv = (void *) CoTaskMemAlloc( cb );
    DEBUGMSG("%d = ALLOC( %d )", (DWORD_PTR) pv, cb );
    return( pv );
}




/*
 * F r e e F u n c ( )
 *
 * FDI Memory Deallocation Callback
 *      XXX Return Value?
 */
 
FNFREE(freefunc)
{
    ASSERT(pv);

    DEBUGMSG("FREE( %d )", pv );
    CoTaskMemFree( pv );
}






/*
 * D O  G E T  N E X T  C A B ( )
 *
 * Routine:     doGetNextCab()
 *
 * Purpose:     Get Next Cabinet in chain
 *
 * Returns:     -1
 *
 * BUGBUG: CLEANUP: STUB THIS OUT
 * BUGBUG: STUBBED OUT IN WEXTRACT - CHAINED CABINETS NOT SUPPORTED
 */

FNFDINOTIFY(doGetNextCab)
{
    return( -1 );
}


/***    updateCabinetInfo - update history of cabinets seen
 *
 *  Entry:
 *      psess - Session
 *      pfdin - FDI info structurue
 *
 *  Exit:
 *      Returns 0;
 */

int updateCabinetInfo(PSESSION psess, PFDINOTIFICATION pfdin)
{

    ASSERT(psess);


    // Don't need any of this!

    //** Save cabinet info
    //lstrcpy(psess->acab.achCabPath     ,pfdin->psz3);
    //lstrcpy(psess->acab.achCabFilename ,pfdin->psz1);
    //lstrcpy(psess->acab.achDiskName    ,pfdin->psz2);
    //psess->acab.setID    = pfdin->setID;
    //psess->acab.iCabinet = pfdin->iCabinet;

    return 0;
}





/*
 * A P P E N D  P A T H  S E P A R A T O R ( )
 *
 * Routine: appendPathSeparator()
 *
 * Purpose: Append a path separator only if necessary
 *
 * Returns: TRUE -     Path Separator Added
 *          FALSE      No Path Separator added
 */

BOOL 
appendPathSeparator(char *pszPathEnd)
{
    //** Add path separator if necessary
    if ((*pszPathEnd != '\0')        && // Path is not empty
        (*pszPathEnd != chPATH_SEP1) && // Not a path separator
        (*pszPathEnd != chPATH_SEP2) && // Not a path separator
        (*pszPathEnd != chDRIVE_SEP) ) { // Not a drive separator
        #ifdef unix
        *(++pszPathEnd) = chPATH_SEP2; // Add Unix path separator
        #else
        *(++pszPathEnd) = chPATH_SEP1; // Add path separator
        #endif /* !unix */
        *(++pszPathEnd) = '\0';     // Terminate path
        return TRUE;                   // Account for path separator
    }
    //** No separator added
    return FALSE;
}




/*
 * C A T  D I R  A N D  F I L E ( )
 *
 * Routine: catDirAndFile()
 *
 * Purpose: Concatenate a directory with a filename!
 *
 */

BOOL 
catDirAndFile(  char    *pszResult, 
                int     cbResult, 
                char    *pszDir,
                char    *pszFile
             )
{
    int     cch = 0;


        //** Handle directory
    if (!cbResult)
    	return FALSE;
    
    pszResult[0] = '\0';                // No filespec, yet

    if (pszDir)
        cch = lstrlen(pszDir);              // Get length of dir

    if (cch != 0) {                     // Have to concatenate path
        cbResult -= cch;                // Account for dir
        if (cbResult <= 1)
        {
              //this check also accounts for the next one byte that could be added.
        	return FALSE;
        }
        lstrcpy(pszResult,pszDir);      // Copy destination dir to buffer
           //** Add path separator if necessary, adjust remaining size
        cbResult -= appendPathSeparator(&(pszResult[cch-1]));
        if (cbResult <= 0)
        {
            return FALSE;
        }
    }

        //** Append file name, using default if primary one not supplied
    if (*pszFile == '\0') {
        return( FALSE );
    }
    
    cbResult -= lstrlen(pszFile);            // Update remaining size
    if (cbResult <= 0) {
        return FALSE;
    }
    lstrcat(pszResult,pszFile);              // Append file name

        //** Success
    return TRUE;
}

/*
 * IsExtracted
 *
 *  Look for pszName in psess->pFileList and see if extracted 
 *  
 *  Returns:
 *      Success: TRUE, failure: FALSE
 */

static
BOOL
IsExtracted( PSESSION ps, LPCSTR pszName)
{
    PFNAME CurName = ps->pFileList;

    ASSERT(pszName);
    ASSERT(CurName); // atleast one file needed

    // search for filename in list of files in this CAB
    do {
        if (lstrcmpi(pszName, CurName->pszFilename) == 0) {
            if (CurName->status == SFNAME_EXTRACTED)
                return TRUE;
            else
                return FALSE;
        }

    } while (CurName = CurName->pNextName);

    ASSERT(TRUE); // if here not found in list!

    return FALSE;
}


/*
 * NeedFile
 *
 *  search for pszName in psess->pFilesToExtract (list of PFNAMEs)
 *  Returns:
 *          TRUE -  need file, extract it
 *          FALSE - don't need file, skip it
 *
 */
static
BOOL
NeedFile( PSESSION ps, LPCSTR pszName)
{
    PFNAME CurName;

    ASSERT(pszName);

    if (IsExtracted(ps, pszName) )
        return FALSE;

    if ( ps->flags & SESSION_FLAG_EXTRACT_ALL ) 
        return TRUE;

    // search for filename in list of files needed
    for (CurName = ps->pFilesToExtract; CurName; CurName = CurName->pNextName){

        ASSERT(CurName->pszFilename);

        if (lstrcmpi(CurName->pszFilename, pszName) == 0)
            return TRUE;

    }

    return FALSE;
}

/*
 * MarkExtracted
 *
 *  Look for pszName in psess->pFileList and mark status = status_passed_in
 *      really can be use to mark status as anything else as well (not just
 *      extracted.)
 *  
 *  Returns:
 *      Success: TRUE, failure: FALSE
 */

static
BOOL
MarkExtracted( PSESSION ps, LPCSTR pszName , DWORD status)
{
    PFNAME CurName = ps->pFileList;

    ASSERT(pszName);
    ASSERT(CurName); // atleast one file needed

    // search for filename in list of files in this CAB
    do {
        if (lstrcmpi(pszName, CurName->pszFilename) == 0) {
            CurName->status = status;
            return TRUE;
        }

    } while (CurName = CurName->pNextName);

    ASSERT(TRUE); // if here not found in list!

    return FALSE;
}


/*
 * A d d F i l e ( )
 *
 * Add a file to the list of files we have in the CAB file
 *
 * Singly linked list - items added at front
 */

static
BOOL
AddFile( PSESSION ps, LPCSTR pszName , long cb)
{
    PFNAME NewName;

    ASSERT(pszName);

    if (!(ps->flags & SESSION_FLAG_ENUMERATE))
        return TRUE;

        // Allocate Node
    NewName = (PFNAME) CoTaskMemAlloc(sizeof(FNAME) );
    if (NewName == NULL)  {
        DEBUGMSG("AddFile(): Memory Allocation of structure failed");
        return( FALSE );
    }

        // Allocate String Space
    NewName->pszFilename = (LPSTR) CoTaskMemAlloc(lstrlen(pszName) + 1);
    if (NewName->pszFilename == NULL)  {
        DEBUGMSG("AddFile(): Memory Allocation of name failed");
        CoTaskMemFree(NewName);
        return( FALSE );
    }
    NewName->status = SFNAME_INIT;

        // Copy Filename
    lstrcpy( (char *)NewName->pszFilename, pszName );

        // Link into list
    NewName->pNextName = ps->pFileList;
    ps->pFileList = NewName;

    ps->cFiles++;

    ps->cbCabSize += cb;

    return( TRUE );
}


/* 
 * f d i N o t i f y  E x t r a c t()
 *
 * Routine:     fdiNotifyExtract()
 *
 * Purpose:     Principle FDI Callback in file extraction
 *              
 *
 */

FNFDINOTIFY(fdiNotifyExtract)
{
    int         fh;
    PSESSION    psess;


    psess = (PSESSION) pfdin->pv;


    switch (fdint)  {
        case fdintCABINET_INFO:
            return updateCabinetInfo(psess,pfdin);


        case fdintCOPY_FILE:
            // BUGBUG: implement OnProgress?

#ifdef unix
            UnixifyFileName(pfdin->psz1);
#endif /* unix */

            if (!catDirAndFile(psess->achFile, // Buffer for output filespec
                               sizeof(psess->achFile), // Size of output buffer
                               psess->achLocation,  // Output directory
                               pfdin->psz1)) {
                return -1;                  // Abort with error;
            }

            // always add the file (enumeration)
            if (! AddFile(psess, pfdin->psz1, pfdin->cb))
                return( -1 );

            // check if this is the file we are looking for if any
            if (!NeedFile(psess, pfdin->psz1))
                return( 0 );

            if (StrStrA(pfdin->psz1, "\\")) {
                // cab contains dir struct for this file
                // create struct on dest dir as well.

                char *pBaseFileName = NULL;
                char szDir[MAX_PATH];
                LPSTR pchStart;
                LPSTR pchSlash = NULL;

                lstrcpy(szDir, psess->achFile);
                pchStart = szDir + lstrlen(psess->achLocation) + 1;

                while (*pchStart &&  (pchSlash = StrStrA(pchStart, "\\"))) {

                    *pchSlash = '\0';

                    // don't care if this fails. may even already exist!
                    CreateDirectory(szDir, NULL);

                    *pchSlash = '\\';

                    pchStart = pchSlash +1;
                }


            }

            //** Do overwrite processing
            fh = openfunc( psess->achFile, _O_BINARY | _O_TRUNC | _O_RDWR |
                                                                _O_CREAT, 0 );

            return(fh); // -1 if error on open

        case fdintCLOSE_FILE_INFO:

            if (!catDirAndFile(psess->achFile, // Buffer for output filespec
                               sizeof(psess->achFile), // Size of output buffer
                               psess->achLocation,  // Output directory
                               pfdin->psz1))  {
                return -1;                  // Abort with error;
            }
            if (! AdjustFileTime( pfdin->hf, pfdin->date, pfdin->time ))  {
                return( -1 );
            }
            closefunc( (int) pfdin->hf );
            if (! SetFileAttributes(psess->achFile, Attr32FromAttrFAT(pfdin->attribs)))  
                return( -1 );

            MarkExtracted(psess, pfdin->psz1, SFNAME_EXTRACTED);
            return(TRUE);

        case fdintPARTIAL_FILE:
            return( 0 );


        case fdintNEXT_CABINET:
            return doGetNextCab(fdint,pfdin);

        default:
            DEBUGTRAP("fdiNotifyExtract(): Unknown Callback Type");
            break;
    }
    return( 0 );
}





#ifdef DEBUG
/*
 * V E R I F Y  C A B I N E T ( )
 *
 * Routine: VerifyCabinet()
 *
 * Purpose: Check that cabinet is properly formed
 *
 * Returns: TRUE -  Cabinet OK
 *          FALSE - Cabinet invalid
 */

BOOL
VerifyCabinet( PSESSION psess, LPCSTR lpCabName )
{
    HFDI            hfdi;
    ERF             erf;
    FDICABINETINFO  cabinfo;
    INT             fh;


    hfdi = FDICreate(allocfunc,freefunc,openfunc,readfunc,writefunc,closefunc,seekfunc,cpu80386,&erf);
    if (hfdi == NULL)  {
        DEBUGMSG("VerifyCabinet(): FDICreate() Failed");
            //BUGBUG Error Handling?
        return( FALSE );
    }

    fh = openfunc((char FAR *)lpCabName, _O_BINARY | _O_RDONLY, 0 );
    if (fh == -1)  {
        DEBUGMSG("VerifyCabinet(): Open of Memory File Failed");
        return( FALSE );
    }

    if (FDIIsCabinet(hfdi, fh, &cabinfo ) == FALSE)  {
        DEBUGMSG("VerifyCabinet(): FDIIsCabinet() Returned FALSE");
        return( FALSE );
    }
    
    if (cabinfo.cbCabinet != (long) psess->cbCabSize)  {
        DEBUGMSG("VerifyCabinet(): cabinfo.cbCabinet != cbCabSize");
        return( FALSE );
    }

    if (cabinfo.hasprev || cabinfo.hasnext)  {
        DEBUGMSG("VerifyCabinet(): Cabinet is chained");
        return( FALSE );
    }
    
    if (closefunc( fh ) == -1)   {
        DEBUGMSG("VerifyCabinet(): Closefunc() Failed");
        return( FALSE );
    }
        
    if (FDIDestroy(hfdi) == FALSE)  {
        DEBUGMSG("VerifyCabinet(): FDIDestroy() Failed");
        return( FALSE );
    }

    return( TRUE );
}
#endif /* DEBUG */



/*
 * E X T R A C T ( )
 *
 * Routine: Extract()
 *
 * Parameters:
 *
 *      PSESSION ps = session information tied to this extract session
 *
 *          IN params
 *              ps->pFilesToExtract = linked list of PFNAMEs that point to
 *                                    upper case filenames that need extraction
 *                          
 *              ps->flags SESSION_FLAG_ENUMERATE = whether need to enumerate
 *                                  files in CAB (ie. create a pFileList
 *              ps->flags SESSION_FLAG_EXTRACTALL =  all
 *
 *          OUT params
 *              ps->pFileList = global alloced list of files in CAB
 *                              caller needs to call DeleteExtractedFiles
 *                              to free memory and temp files
 *                  
 *
 *      LPCSTR lpCabName = name of cab file
 *
 *          
 * Returns:
 *          S_OK: sucesss
 *
 *
 */
 
HRESULT
Extract(PSESSION ps, LPCSTR lpCabName )
{
    HFDI        hfdi;
    BOOL        fExtractResult = FALSE;
    HRESULT hr = S_OK;


    if (ps->flags & SESSION_FLAG_EXTRACTED_ALL) {
        // already extracted all files in this CAB
        // nothing to do!
        return S_OK;
    }

    memset(&(ps->erf), 0, sizeof(ERF));

    if (ps->flags & SESSION_FLAG_ENUMERATE) {
        ps->cbCabSize = 0;
    }

    // don't enumerate when pFileList already pre-populated
    ASSERT( (!(ps->flags & SESSION_FLAG_ENUMERATE)) ||  (!ps->pFileList));

    {
        HRESULT hrOut = NOERROR;

        if (fCritCreated == FALSE)
        {
            fCritCreated = TRUE;
            InitializeCriticalSection(&g_mxsFDI);
        }
        EnterCriticalSection(&g_mxsFDI);
        
            // Extract the files
        hfdi = FDICreate(allocfunc,freefunc,openfunc,readfunc,writefunc,closefunc,seekfunc,cpu80386, &(ps->erf));
        if (hfdi == NULL)  {
            // Error value will be retrieved from ps->erf
            hrOut = STG_E_UNKNOWN;
            goto done;
        }

        fExtractResult = FDICopy(hfdi, (char FAR *)lpCabName, "", 0, fdiNotifyExtract, NULL, (void *) ps );
    
        if (FDIDestroy(hfdi) == FALSE)  {
            // Error value will be retrieved from ps->erf
            hrOut = STG_E_UNKNOWN;
        }
        
    done:
        LeaveCriticalSection(&g_mxsFDI);
        // leave now if this failed!
        if (hrOut != NOERROR)
        {
            return hrOut;
        }
    }


    if (fExtractResult && (!ps->erf.fError))
        return S_OK;

    hr = HRESULT_FROM_WIN32(GetLastError());

    if (SUCCEEDED(hr)) {
        // not a win32 failure but a cabinet failure

        // convert CABINET failure to disk full or STG_E_UNKNOWN.
        // On win95 writefile failing with disk full is not 
        // setting the last error correctly

        if (ps->erf.fError && (ps->erf.erfOper == FDIERROR_TARGET_FILE))
            hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
        else
            hr = STG_E_UNKNOWN;
    }

    return hr;
}   



/*
 * D E L E T E  E X T R A C T E D  F I L E S ( )
 *
 * Routine: DeleteExtractedFiles()
 *
 * Purpose: Delete the files that were extracted
 *          into the temporary directory
 *          FREE all the memory in pFileList
 *          make pFileList = NULL.
 *
 * Paramaters:
 *      psess - Pointer to Session Structure containing
 *              all state about this extraction session
 *
 * Returns: None
 */

VOID
DeleteExtractedFiles(PSESSION psess)
{
    PFNAME      rover = psess->pFileList;
    PFNAME      roverprev;
    char szBuf[MAX_PATH];

    ASSERT(psess);
    DEBUGMSG("Deleting Extracted Files");


    while (rover != NULL)  {

        // skip if this is not a tmp file
        if ( rover->status == SFNAME_EXTRACTED) {

            // Get full filename
            if (catDirAndFile(szBuf, MAX_PATH, psess->achLocation,
                               rover->pszFilename)) {

                if (SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL))
                    DeleteFile(szBuf);
            }
        }

        CoTaskMemFree(rover->pszFilename);

        roverprev = rover;  // save for free'ing current rover below
        rover = rover->pNextName;

        CoTaskMemFree(roverprev);

    }

    psess->pFileList = NULL; // prevent use after deletion!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\getlpath.cxx ===
#include <cdlpch.h>
#pragma hdrstop

#include <winnls.h>
#include <shlobj.h>
 
CMutexSem g_mxsCDLGetLongPathNameGlobals;

// stolen from shellp.h
#define ILCreateFromPathORD                     157
#define ILFreeORD                               155

// stolen from shsemip.h
typedef LPITEMIDLIST  (WINAPI *ILCreateFromPathPtr)(LPCWSTR pszPath);
typedef void          (WINAPI *ILFreePtr)(LPITEMIDLIST pidl);

// We'll use this if we're running on Memphis or NT5
#ifdef UNICODE
#define STR_GETLONGPATHNAMEW "GetLongPathNameW"
typedef DWORD (WINAPI *GetLongPathNameWPtr)( LPCWSTR lpszShortPath,
                                             LPWSTR  lpszLongPath,
                                             DWORD    cchBuffer
                                           );
#else
#define STR_GETLONGPATHNAMEA "GetLongPathNameA"
typedef DWORD (WINAPI *GetLongPathNameAPtr)( LPCSTR lpszShortPath,
                                             LPSTR  lpszLongPath,
                                             DWORD    cchBuffer
                                           );
#endif


STATIC ILCreateFromPathPtr     s_pfnILCreate;
STATIC ILFreePtr               s_pfnILFree;
STATIC GetLongPathNameAPtr     s_pfnGetLongPathNameA;

#define cKnownDirs  5
STATIC struct KnownDirsMap {
    BOOL   m_bInited;
    LPTSTR m_aszCaches[cKnownDirs];
    struct _tagKDMap {
        TCHAR szShort[MAX_PATH];
        int cchShort;
        TCHAR szCanonical[MAX_PATH];
        int cchCanonical;
    } m_aKDMap[cKnownDirs];

    int IndexKnownDirs( LPTSTR szName )
    {
        int i;

        for ( i = 0; i < cKnownDirs; i++ ) {
            // we only want to compare out through the cache folder itself 
            BOOL fMatch = (m_aKDMap[i].cchShort != 0 &&
                           CompareString( LOCALE_SYSTEM_DEFAULT,
                                          NORM_IGNORECASE,
                                          m_aKDMap[i].szShort,
                                          m_aKDMap[i].cchShort,
                                          szName,
                                          m_aKDMap[i].cchShort ) == 2)
                                                 ||
                          (m_aKDMap[i].cchCanonical != 0 &&
                           CompareString( LOCALE_SYSTEM_DEFAULT,
                                          NORM_IGNORECASE,
                                          m_aKDMap[i].szCanonical,
                                          m_aKDMap[i].cchCanonical,
                                          szName,
                                          m_aKDMap[i].cchCanonical ) == 2);
            if ( fMatch )
                break;
        }

        if ( i >= cKnownDirs )
            i = -1; // signal a miss
        return i;
    };

} s_kdMap = {
    FALSE,
    { 
    "\\Occache\\",
    "\\OC Cache\\",
    "\\Downloaded ActiveX Controls\\",
    "\\Downloaded Components\\",
    "\\Downloaded Program Files\\"
    },
    {
        { 0, 0, 0, 0 },
        { 0, 0, 0, 0 },
        { 0, 0, 0, 0 }
    }
};

DWORD GetFullPathNameA_Wrap(
  LPCSTR lpFileName,  // file name
  DWORD nBufferLength, // size of path buffer
  LPSTR lpBuffer,     // path buffer
  LPSTR *lpFilePart   // address of file name in path
)
{
    DWORD dwRet = GetFullPathName(lpFileName, nBufferLength, lpBuffer, lpFilePart);

    if (dwRet && (dwRet<nBufferLength))
    {
        if (! *lpFilePart)
        {
            // to prevent crashes where lpFileName == directory name terminating with '\'.
            // See IE6 bug 19001 
            *lpFilePart = lpBuffer+dwRet; //make it point to NULL char.
        }
    }
    else
    {
        dwRet = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return dwRet;
}
   

STATIC BOOL IsCanonicalName( LPCTSTR szName )
{
    // simple test - if there's a ~ in it, it has a contraction in it
    // and is therefore non-canonical
    for ( ; *szName != '\0' && *szName != '~'; szName++ );
    
    return *szName != '~';
}

STATIC DWORD s_CDLGetLongPathName( LPTSTR szLong, LPCTSTR szShort, DWORD cchBuffer)
{
    HRESULT hr = E_FAIL;
    HMODULE hmodS32;
    HMODULE hmodK32;
    DWORD   cchLong = 0;

    // Don't jump through all these hoops if there aren't any contractions in it.
    if ( IsCanonicalName( szShort ) ) {
        lstrcpyn( szLong, szShort, cchBuffer );
        return lstrlen( szLong );
    }

    hmodS32 = LoadLibrary( "SHELL32.DLL" );
    hmodK32 = LoadLibrary( "KERNEL32.DLL" );

    // Set up our globals with short and long versions of the base cache path 
    if ( hmodS32 && hmodK32 ) {
#ifdef UNICODE
        s_pfnGetLongPathNameW = (GetLongPathNameWPtr)GetProcAddress(hmodK32, (LPCSTR)STR_GETLONGPATHNAMEW );
#else
        s_pfnGetLongPathNameA = (GetLongPathNameAPtr)GetProcAddress(hmodK32, (LPCSTR)STR_GETLONGPATHNAMEA );
#endif
        s_pfnILCreate = (ILCreateFromPathPtr)GetProcAddress(hmodS32, (LPCSTR)ILCreateFromPathORD );
        s_pfnILFree = (ILFreePtr)GetProcAddress(hmodS32, (LPCSTR)ILFreeORD );

        if ( s_pfnILCreate != NULL  && s_pfnILFree != NULL ) {
            // We need to initialize our static know directories table.
            // To be safe, we'll grab a mutex while we do the dirty deed.
            {   // constrain the scope of the mutex
                CLock lck(g_mxsCDLGetLongPathNameGlobals);

                if ( !s_kdMap.m_bInited ) {
                     TCHAR szWinDir[MAX_PATH];
                    int i;

                    GetWindowsDirectory( szWinDir, MAX_PATH );
                    for ( i = 0; i < cKnownDirs; i++ ) {
                        lstrcpy( s_kdMap.m_aKDMap[i].szCanonical, szWinDir );
                        StrCatBuff( s_kdMap.m_aKDMap[i].szCanonical, s_kdMap.m_aszCaches[i], MAX_PATH);
                        s_kdMap.m_aKDMap[i].cchCanonical = lstrlen( s_kdMap.m_aKDMap[i].szCanonical );
                        GetShortPathName( s_kdMap.m_aKDMap[i].szCanonical,
                                          s_kdMap.m_aKDMap[i].szShort, MAX_PATH );
                        s_kdMap.m_aKDMap[i].cchShort = lstrlen( s_kdMap.m_aKDMap[i].szShort );
                    }
                    s_kdMap.m_bInited = TRUE;
                }
            }

            TCHAR *pch;
            TCHAR *szT = new CHAR[MAX_PATH];

            if ( szShort != NULL && szT != NULL && s_kdMap.m_bInited ) {
                LPITEMIDLIST pidl = NULL;

                // Okay, kids, now this gets fun.
                // If we're on Memphis or NT5, we can simply call GetLongPathName
                // to get the canonical format.
                // If not, we've a bit more work ahead of us.
                // If the path is not down into one of the dowload cache folders,
                // we can use shell32 functions to create the long path. This involves
                // generating a pidl for the file, then converting the pidl back into a path.
                // If the path goes down into one of the cache directories, we're in
                // a bit of trouble, because OC cache does not implement
                // IShellFolder::ParseDisplayName, so we cannot generate a proper pidl.
                // In that case, we use prefab paths to these known directories
                // and tack on the long name of the file.
#ifdef UNICODE
                // NOTE: the prototypes in Winbase.h are deceiving - look at the argument types,
                // NOT at the argument names, the output parameter is second!
                if ( s_pfnGetLongPathNameW ) {
                    hr = (s_pfnGetLongPathNameW( szShort, szLong, MAX_PATH ) != 0)? S_OK : E_FAIL;
#else
                if ( s_pfnGetLongPathNameA ) {
                    hr = (s_pfnGetLongPathNameA( szShort, szLong, MAX_PATH ) != 0)? S_OK : E_FAIL;
#endif
                } else {
                    LPTSTR szFileName;
                    if ( GetFullPathNameA_Wrap( szShort, MAX_PATH, szT, &szFileName ) ) {
                        int iKnownDir = s_kdMap.IndexKnownDirs( szT );
                        if ( iKnownDir >= 0 ) {
                            WIN32_FIND_DATA wfd;
                            int cchBase = lstrlen(szT) - lstrlen(szFileName);