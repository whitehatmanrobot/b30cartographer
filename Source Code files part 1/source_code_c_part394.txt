     //}
        return status;
    }

    if ((status = I_NetNameCanonicalize(
                      NULL,
                      ComputerName,
                      (LPTSTR) WsInfo.WsComputerName,
                      sizeof( WsInfo.WsComputerName ),
                      NAMETYPE_COMPUTER,
                      0
                      )) != NERR_Success) {

        LPWSTR SubString[1];

        NetpKdPrint((
            PREFIX_WKSTA FORMAT_LPTSTR " is an invalid computername.\n",
            ComputerName
            ));

        SubString[0] = ComputerName;

        WsLogEvent(
            APE_BAD_COMPNAME,
            EVENTLOG_ERROR_TYPE,
            1,
            SubString,
            NERR_Success
            );

        (void) NetApiBufferFree((PVOID) ComputerName);
        RtlReleaseResource(&WsInfo.ConfigResource);
        //IF_DEBUG(START) {
            DbgPrint("WKSSVC Invalid computer name failed %lx\n", status);
        //}
        return status;
    }

    //
    // Free memory allocated by NetpGetComputerName.
    //
    (void) NetApiBufferFree(ComputerName);

    WsInfo.WsComputerNameLength = STRLEN((LPWSTR) WsInfo.WsComputerName);

    //
    // Open config file and get handle to the [LanmanWorkstation] section
    //

    if ((status = NetpOpenConfigData(
                      &WorkstationSection,
                      NULL,             // local (no server name)
                      SECT_NT_WKSTA,
                      TRUE              // want read-only access
                      )) != NERR_Success) {
        RtlReleaseResource(&WsInfo.ConfigResource);
        //IF_DEBUG(START) {
            DbgPrint("WKSSVC Open config file failed %lx\n", status);
        //}
        return status;
    }

    IF_DEBUG(CONFIG) {
        NetpKdPrint((PREFIX_WKSTA "ComputerName " FORMAT_LPTSTR ", length %lu\n",
                     WsInfo.WsComputerName, WsInfo.WsComputerNameLength));
    }

    //
    // Get the primary domain name from the configuration file
    //
    if ((status = NetpGetDomainName(&DomainNameT)) != NERR_Success) {
        //IF_DEBUG(START) {
            DbgPrint("WKSSVC Get the primary domain name failed %lx\n", status);
        //}
        goto CloseConfigFile;
    }
    NetpAssert( DomainNameT != NULL );

    if ( *DomainNameT != 0 ) {

        if ((status = I_NetNameCanonicalize(
                          NULL,
                          DomainNameT,
                          (LPWSTR) WsInfo.WsPrimaryDomainName,
                          (DNLEN + 1) * sizeof(TCHAR),
                          WsInAWorkgroup() ? NAMETYPE_WORKGROUP : NAMETYPE_DOMAIN,
                          0
                          )) != NERR_Success) {

            LPWSTR SubString[1];


            NetpKdPrint((PREFIX_WKSTA FORMAT_LPTSTR
                         " is an invalid primary domain name.\n", DomainNameT));

            SubString[0] = DomainNameT;

            WsLogEvent(
                APE_CS_InvalidDomain,
                EVENTLOG_ERROR_TYPE,
                1,
                SubString,
                NERR_Success
                );

            (void) NetApiBufferFree(DomainNameT);
            //IF_DEBUG(START) {
                DbgPrint("WKSSVC Invalid domain name failed %lx\n", status);
            //}
            goto CloseConfigFile;
        }
    } else {
        WsInfo.WsPrimaryDomainName[0] = 0;
    }

    //
    // Free memory allocated by NetpGetDomainName.
    //
    (void) NetApiBufferFree(DomainNameT);

    WsInfo.WsPrimaryDomainNameLength = STRLEN((LPWSTR) WsInfo.WsPrimaryDomainName);

    //
    // Read the redirector configuration fields
    //
    WsUpdateWkstaToMatchRegistry(WorkstationSection, TRUE);

    //
    // Initialize redirector configuration
    //

    Rrp->Type = ConfigInformation;
    Rrp->Version = REQUEST_PACKET_VERSION;

    STRCPY((LPWSTR) Rrp->Parameters.Start.RedirectorName,
           (LPWSTR) WsInfo.WsComputerName);
    Rrp->Parameters.Start.RedirectorNameLength =
        WsInfo.WsComputerNameLength*sizeof(TCHAR);

    Rrp->Parameters.Start.DomainNameLength = WsInfo.WsPrimaryDomainNameLength*sizeof(TCHAR);
    STRCPY((LPWSTR) (Rrp->Parameters.Start.RedirectorName+WsInfo.WsComputerNameLength),
           (LPWSTR) WsInfo.WsPrimaryDomainName
          );

    status = WsRedirFsControl(
                  WsRedirDeviceHandle,
                  FSCTL_LMR_START,
                  Rrp,
                  sizeof(LMR_REQUEST_PACKET) +
                      Rrp->Parameters.Start.RedirectorNameLength+
                      Rrp->Parameters.Start.DomainNameLength,
                  (LPBYTE) &WSBUF,
                  sizeof(WKSTA_INFO_502),
                  NULL
                  );

    if ((status != NERR_Success) && (status != ERROR_SERVICE_ALREADY_RUNNING)) {

        LPWSTR SubString[1];


        NetpKdPrint((PREFIX_WKSTA "Start redirector failed %lu\n", status));

        SubString[0] = L"redirector";

        WsLogEvent(
            NELOG_Service_Fail,
            EVENTLOG_ERROR_TYPE,
            1,
            SubString,
            status
            );

        //IF_DEBUG(START) {
            DbgPrint("WKSSVC Start redirector failed %lx\n", status);
        //}

        goto CloseConfigFile;
    }

    //
    //  If we still have the default value for number of mailslot buffers,
    //  pick a "reasonable" value based on the amount of physical memory
    //  available in the system.
    //

    if (WSBUF.wki502_num_mailslot_buffers == MAXULONG) {
        MEMORYSTATUS MemoryStatus;

        GlobalMemoryStatus(&MemoryStatus);

        //
        //  Lets take up 1/40th of 1% of physical memory for mailslot buffers
        //

        WSBUF.wki502_num_mailslot_buffers =
            (DWORD)(MemoryStatus.dwTotalPhys / (100 * 40 * 512));


    }


    //
    // Initialize datagram receiver configuration
    //

    Drrp->Version = LMDR_REQUEST_PACKET_VERSION;

    Drrp->Parameters.Start.NumberOfMailslotBuffers =
        WSBUF.wki502_num_mailslot_buffers;
    Drrp->Parameters.Start.NumberOfServerAnnounceBuffers =
        WSBUF.wki502_num_srv_announce_buffers;
    Drrp->Parameters.Start.IllegalDatagramThreshold =
        WSBUF.wki502_max_illegal_datagram_events;
    Drrp->Parameters.Start.EventLogResetFrequency =
        WSBUF.wki502_illegal_datagram_event_reset_frequency;
    Drrp->Parameters.Start.LogElectionPackets =
        (WSBUF.wki502_log_election_packets != FALSE);

    RtlGetNtProductType(&NtProductType);
    Drrp->Parameters.Start.IsLanManNt = (NtProductType == NtProductLanManNt);

    status = WsDgReceiverIoControl(
                  WsDgReceiverDeviceHandle,
                  IOCTL_LMDR_START,
                  Drrp,
                  sizeof(LMDR_REQUEST_PACKET),
                  NULL,
                  0,
                  NULL
                  );


    if ((status != NERR_Success) && (status != ERROR_SERVICE_ALREADY_RUNNING)) {

        LPWSTR SubString[1];


        NetpKdPrint((PREFIX_WKSTA "Start datagram receiver failed %lu\n", status));

        SubString[0] = L"datagram receiver";

        WsLogEvent(
            NELOG_Service_Fail,
            EVENTLOG_ERROR_TYPE,
            1,
            SubString,
            status
            );

        //IF_DEBUG(START) {
            DbgPrint("WKSSVC Start Datagram recevier failed %lx\n", status);
        //}
        goto CloseConfigFile;
    }

    // do all error reporting in the routine
    // don't check any errors here
    WsCSCReportStartRedir();

    status = NERR_Success;

CloseConfigFile:
    (void) NetpCloseConfigData(WorkstationSection);
    RtlReleaseResource(&WsInfo.ConfigResource);

    return status;
}



VOID
WsUpdateWkstaToMatchRegistry(
    IN LPNET_CONFIG_HANDLE WorkstationSection,
    IN BOOL IsWkstaInit
    )
/*++

Routine Description:

    This function reads each redirector configuration field into the
    WsInfo.WsConfigBuf (WSBUF) buffer so that the values are ready to be
    set in the redirector.  If a field is not found or is invalid, the
    default value is set.

Arguments:

    WorkstationSection - Supplies a handle to read the Workstation
        configuration parameters.

    IsWkstaInit - Supplies a flag which if TRUE indicates that this
        routine is called at workstation init time so the non-settable
        fields are acceptable and set in WSBUF.  If FALSE, the
        non-settable fields are ignored.

Return Value:

    None.

--*/
{
    DWORD i;
    NET_API_STATUS status;
    DWORD TempDwordValue;

//
// NTRAID-70687-2/6/2000 davey Invalid keyword value.  How to report error?
//
#define REPORT_KEYWORD_IGNORED( lptstrKeyword ) \
    { \
        NetpKdPrint(( \
                PREFIX_WKSTA "*ERROR* Tried to set keyword '" FORMAT_LPTSTR \
                "' with invalid value.\n" \
                "This error is ignored.\n", \
                lptstrKeyword )); \
    }

    for (i = 0; WsInfo.WsConfigFields[i].Keyword != NULL; i++) {

        //
        // This is to handle fields that are not settable via
        // NetWkstaSetInfo.  However, these non-settable fields,
        // designated by Parmnum == PARMNUM_ALL, can be assigned when
        // the workstation is starting up.
        //
        if ((WsInfo.WsConfigFields[i].Parmnum != PARMNUM_ALL) ||
            IsWkstaInit) {

            //
            // Depending on data type, get the appropriate kind of value.
            //

            switch (WsInfo.WsConfigFields[i].DataType) {

                case BooleanType:

                    status = NetpGetConfigBool(
                                  WorkstationSection,
                                  WsInfo.WsConfigFields[i].Keyword,
                                  WsInfo.WsConfigFields[i].Default,
                                  (LPBOOL) (WsInfo.WsConfigFields[i].FieldPtr)
                                  );

                    if ((status != NO_ERROR) && (status != NERR_CfgParamNotFound)) {

                        REPORT_KEYWORD_IGNORED( WsInfo.WsConfigFields[i].Keyword );

                    }
                    break;


                case DWordType:

                    status = NetpGetConfigDword(
                                 WorkstationSection,
                                 WsInfo.WsConfigFields[i].Keyword,
                                 WsInfo.WsConfigFields[i].Default,
                                 &TempDwordValue
                                 );

                    if ((status == NO_ERROR) || (status == NERR_CfgParamNotFound)) {

                        //
                        // Make sure keyword is in range.
                        //
                        if (TempDwordValue < WsInfo.WsConfigFields[i].Minimum ||
                            TempDwordValue > WsInfo.WsConfigFields[i].Maximum) {

                                //
                                // NTRAID-70689-2/6/2000 davey Better way to report error?
                                //
                                NetpKdPrint((
                                    PREFIX_WKSTA FORMAT_LPTSTR
                                    " value out of range %lu (%lu-%lu)\n",
                                    WsInfo.WsConfigFields[i].Keyword,
                                    TempDwordValue,
                                    WsInfo.WsConfigFields[i].Minimum,
                                    WsInfo.WsConfigFields[i].Maximum
                                    ));
                            //
                            // Set back to default.
                            //
                            *(WsInfo.WsConfigFields[i].FieldPtr)
                                    = WsInfo.WsConfigFields[i].Default;

                        }
                        else {

                            *(WsInfo.WsConfigFields[i].FieldPtr) = TempDwordValue;

                        }
                    }
                    else {

                        REPORT_KEYWORD_IGNORED( WsInfo.WsConfigFields[i].Keyword );

                    }
                    break;

                default:
                    NetpAssert(FALSE);

            } // switch
        }
    }
}



NET_API_STATUS
WsBindToTransports(
    VOID
    )
/*++

Routine Description:

    This function binds the transports specified in the registry to the
    redirector.  The order of priority for the transports follows the order
    they are listed by the "Bind=" valuename.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS              status;
    NET_API_STATUS              tempStatus;
    NTSTATUS                    ntstatus;
    DWORD                       transportsBound;
    PRTL_QUERY_REGISTRY_TABLE   queryTable;
    LIST_ENTRY                  header;
    PLIST_ENTRY                 pListEntry;
    PWS_BIND                    pBind;


    //
    // Ask the RTL to call us back for each subvalue in the MULTI_SZ
    // value \LanmanWorkstation\Linkage\Bind.
    //
    queryTable = (PVOID)LocalAlloc(
                     0,
                     sizeof(RTL_QUERY_REGISTRY_TABLE) * 2
                     );

    if (queryTable == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeListHead( &header);

    queryTable[0].QueryRoutine = WsBindATransport;
    queryTable[0].Flags = 0;
    queryTable[0].Name = WS_BIND_VALUE_NAME;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;
    queryTable[0].DefaultData = NULL;
    queryTable[0].DefaultLength = 0;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;

    ntstatus = RtlQueryRegistryValues(
                   RTL_REGISTRY_SERVICES,       // path relative to ...
                   WS_LINKAGE_REGISTRY_PATH,
                   queryTable,
                   (PVOID) &header,             // context
                   NULL
                   );

    if ( !NT_SUCCESS( ntstatus)) {
        NetpKdPrint((
            PREFIX_WKSTA "WsBindToTransports: RtlQueryRegistryValues Failed:"
                FORMAT_NTSTATUS "\n",
            ntstatus
            ));
        status = NetpNtStatusToApiStatus( ntstatus);
    } else {
        status = NO_ERROR;
    }


    //
    //  First process all the data, then clean up.
    //

    for ( pListEntry = header.Flink;
                pListEntry != &header;
                    pListEntry = pListEntry->Flink) {

        pBind = CONTAINING_RECORD(
            pListEntry,
            WS_BIND,
            ListEntry
            );

        tempStatus = NO_ERROR;

        if ( pBind->Redir->EventHandle != INVALID_HANDLE_VALUE) {
            WaitForSingleObject(
                pBind->Redir->EventHandle,
                INFINITE
                );
            tempStatus = WsMapStatus( pBind->Redir->IoStatusBlock.Status);
            pBind->Redir->Bound = (tempStatus == NO_ERROR);
            if (tempStatus == ERROR_DUP_NAME) {
                status = tempStatus;
            }
        }

        if ( pBind->Dgrec->EventHandle != INVALID_HANDLE_VALUE) {
            WaitForSingleObject(
                pBind->Dgrec->EventHandle,
                INFINITE
                );
            tempStatus = WsMapStatus( pBind->Dgrec->IoStatusBlock.Status);
            pBind->Dgrec->Bound = (tempStatus == NO_ERROR);
            if (tempStatus == ERROR_DUP_NAME) {
                status = tempStatus;
            }
        }

        if ( tempStatus == ERROR_DUP_NAME) {
            NetpKdPrint((
                PREFIX_WKSTA "Computername " FORMAT_LPTSTR
                    " already exists on network " FORMAT_LPTSTR "\n",
                WsInfo.WsComputerName,
                pBind->TransportName
                ));
        }

        //
        //  If one is installed but the other is not, clean up the other.
        //

        if ( pBind->Dgrec->Bound != pBind->Redir->Bound) {
            WsUnbindTransport2( pBind);
        }
    }


    if ( status != NO_ERROR) {

        if (status == ERROR_DUP_NAME) {
            WsLogEvent(
                NERR_DupNameReboot,
                EVENTLOG_ERROR_TYPE,
                0,
                NULL,
                NERR_Success
                );
        }

        for ( pListEntry = header.Flink;
                    pListEntry != &header;
                        pListEntry = pListEntry->Flink) {

            pBind = CONTAINING_RECORD(
                pListEntry,
                WS_BIND,
                ListEntry
                );

            WsUnbindTransport2( pBind);
        }
    }

    for ( transportsBound = 0;
                IsListEmpty( &header) == FALSE;
                        LocalFree((HLOCAL) pBind)) {

        pListEntry = RemoveHeadList( &header);

        pBind = CONTAINING_RECORD(
            pListEntry,
            WS_BIND,
            ListEntry
            );

        if ( pBind->Redir->EventHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( pBind->Redir->EventHandle);
        }

        if ( pBind->Redir->Bound == TRUE) {
            transportsBound++;
        }

        if ( pBind->Dgrec->EventHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( pBind->Dgrec->EventHandle);
        }

    }

    (void) LocalFree((HLOCAL) queryTable);

    if ( WsRedirAsyncDeviceHandle != NULL) {
        (VOID)NtClose( WsRedirAsyncDeviceHandle);
        WsRedirAsyncDeviceHandle = NULL;
    }

    if ( WsDgrecAsyncDeviceHandle != NULL) {
        (VOID)NtClose( WsDgrecAsyncDeviceHandle);
        WsDgrecAsyncDeviceHandle = NULL;
    }

    if (transportsBound == 0) {

        NetpKdPrint((
            PREFIX_WKSTA "WsBindToTransports: Failed to bind to any"
                " transports" FORMAT_API_STATUS "\n",
            status
            ));

        if ( status != ERROR_DUP_NAME) {
            WsLogEvent(
                NELOG_NoTranportLoaded,
                EVENTLOG_ERROR_TYPE,
                0,
                NULL,
                NERR_Success
                );

            status = NO_ERROR;
        }
    }

    return status;
}



STATIC
NTSTATUS
WsBindATransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++
    This routine always returns SUCCESS because we want all transports
    to be processed fully.
--*/
{
    NET_API_STATUS  status;

    DBG_UNREFERENCED_PARAMETER( ValueName);
    DBG_UNREFERENCED_PARAMETER( ValueLength);
    DBG_UNREFERENCED_PARAMETER( EntryContext);


    //
    // The value type must be REG_SZ (translated from REG_MULTI_SZ by the RTL).
    //
    if (ValueType != REG_SZ) {
        NetpKdPrint((
            PREFIX_WKSTA "WsBindATransport: ignored invalid value "
                     FORMAT_LPWSTR "\n",
            ValueName
            ));
        return STATUS_SUCCESS;
    }

    //
    // Bind transport
    //

    status = WsAsyncBindTransport(
        ValueData,                  // name of transport device object
        --QualityOfService,
        (PLIST_ENTRY)Context
        );

    if ( status != NERR_Success) {
        NetpKdPrint((
            PREFIX_WKSTA "WsAsyncBindTransport " FORMAT_LPTSTR
                " returns " FORMAT_API_STATUS "\n",
            ValueData,
            status
            ));
    }

    return STATUS_SUCCESS;
}


NET_API_STATUS
WsAddDomains(
    VOID
    )
/*++

Routine Description:

    This function tells the datagram receiver the names to listen on for
    datagrams.  The names include the computer name, the primary domain,
    name and the other domains.  The logon domain is not added here; it is
    made known to the datagram receiver whenever a user logs on.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

Warning:

    This routine is UNICODE only.

--*/
{
    NET_API_STATUS status;
    LPNET_CONFIG_HANDLE SectionHandle = NULL;
    LPTSTR OtherDomainName = NULL;
    LPTSTR_ARRAY ArrayStart = NULL;

    BYTE Buffer[sizeof(LMDR_REQUEST_PACKET) +
                (max(MAX_PATH, DNLEN) + 1) * sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) Buffer;


    //
    // Now loop through and add all the other domains.
    //

    //
    //  Open registry section listing the other domains.  Note that this
    //  is workstation servive parameter, NOT the browser service parameter.
    //
    if ((status = NetpOpenConfigData(
                      &SectionHandle,
                      NULL,            // no server name
                      SECT_NT_WKSTA,
                      TRUE             // read-only
                      )) != NERR_Success) {

        //
        //  Ignore the error if the config section couldn't be found.
        //
        status = NERR_Success;
        goto DomainsCleanup;
    }

    //
    // Get value for OtherDomains keyword in the wksta section.
    // This is a "NULL-NULL" array (which corresponds to REG_MULTI_SZ).
    //
    status = NetpGetConfigTStrArray(
                 SectionHandle,
                 WKSTA_KEYWORD_OTHERDOMAINS,
                 &ArrayStart          // Must be freed by NetApiBufferFree().
                 );

    if (status != NERR_Success) {
        status = NERR_Success;         // other domain is optional
        goto DomainsCleanup;
    }

    NetpAssert(ArrayStart != NULL);
    if (NetpIsTStrArrayEmpty(ArrayStart)) {
       goto DomainsCleanup;
    }

    OtherDomainName = ArrayStart;
    while (! NetpIsTStrArrayEmpty(OtherDomainName)) {

        if ((status = I_NetNameCanonicalize(
                          NULL,
                          OtherDomainName,
                          (LPWSTR) Drrp->Parameters.AddDelName.Name,
                          (DNLEN + 1) * sizeof(TCHAR),
                          NAMETYPE_DOMAIN,
                          0
                          )) != NERR_Success) {

            LPWSTR SubString[1];


            NetpKdPrint((PREFIX_WKSTA FORMAT_LPTSTR
                         " is an invalid other domain name.\n", OtherDomainName));

            SubString[0] = OtherDomainName;
            WsLogEvent(
                APE_CS_InvalidDomain,
                EVENTLOG_ERROR_TYPE,
                1,
                SubString,
                NERR_Success
                );

            status = NERR_Success; // loading other domains is optional
            goto NextOtherDomain;
        }

        //
        // Tell the datagram receiver about an other domain name
        //
        Drrp->Version = LMDR_REQUEST_PACKET_VERSION;
        Drrp->Parameters.AddDelName.Type = OtherDomain;
        Drrp->Parameters.AddDelName.DgReceiverNameLength =
            STRLEN(OtherDomainName) * sizeof(TCHAR);

        status = WsDgReceiverIoControl(
                     WsDgReceiverDeviceHandle,
                     IOCTL_LMDR_ADD_NAME,
                     Drrp,
                     sizeof(LMDR_REQUEST_PACKET) +
                            Drrp->Parameters.AddDelName.DgReceiverNameLength,
                     NULL,
                     0,
                     NULL
                     );

        //
        // Service install still pending.  Update checkpoint counter and the
        // status with the Service Controller.
        //
        WsGlobalData.Status.dwCheckPoint++;
        WsUpdateStatus();

        if (status != NERR_Success) {

            LPWSTR SubString[1];


            NetpKdPrint((
                PREFIX_WKSTA "Add Other domain name " FORMAT_LPTSTR
                    " failed with error code %lu\n",
                OtherDomainName,
                status
                ));

            SubString[0] = OtherDomainName;
            WsLogEvent(
                APE_CS_InvalidDomain,
                EVENTLOG_ERROR_TYPE,
                1,
                SubString,
                status
                );
            status = NERR_Success; // loading other domains is optional
        }

NextOtherDomain:
        OtherDomainName = NetpNextTStrArrayEntry(OtherDomainName);
    }

DomainsCleanup:
    //
    // Done with reading from config file.  Close file, free memory, etc.
    //
    if (ArrayStart != NULL) {
        (VOID) NetApiBufferFree(ArrayStart);
    }
    if (SectionHandle != NULL) {
        (VOID) NetpCloseConfigData(SectionHandle);
    }

    return status;
}


VOID
WsLogEvent(
    DWORD MessageId,
    WORD EventType,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    )
{

    HANDLE LogHandle;

    PSID UserSid = NULL;


    LogHandle = RegisterEventSourceW (
                    NULL,
                    WORKSTATION_DISPLAY_NAME
                    );

    if (LogHandle == NULL) {
        NetpKdPrint((PREFIX_WKSTA "RegisterEventSourceW failed %lu\n",
                     GetLastError()));
        return;
    }

    if (ErrorCode == NERR_Success) {

        //
        // No error codes were specified
        //
        (void) ReportEventW(
                   LogHandle,
                   EventType,
                   0,            // event category
                   MessageId,
                   UserSid,
                   (WORD)NumberOfSubStrings,
                   0,
                   SubStrings,
                   (PVOID) NULL
                   );

    }
    else {

        //
        // Log the error code specified
        //
        (void) ReportEventW(
                   LogHandle,
                   EventType,
                   0,            // event category
                   MessageId,
                   UserSid,
                   (WORD)NumberOfSubStrings,
                   sizeof(DWORD),
                   SubStrings,
                   (PVOID) &ErrorCode
                   );
    }

    DeregisterEventSource(LogHandle);
}


NET_API_STATUS
WsSetWorkStationDomainName(
    VOID
    )
{
    NET_API_STATUS status;
    LPNET_CONFIG_HANDLE WorkstationSection;
    LPTSTR ComputerName;
    LPTSTR DomainNameT;
    DWORD version;
    NT_PRODUCT_TYPE NtProductType;

    BYTE Buffer[sizeof(LMR_REQUEST_PACKET) + (MAX_PATH + 1) * sizeof(WCHAR) +
                                                 (DNLEN + 1) * sizeof(WCHAR)];

    PLMR_REQUEST_PACKET Rrp = (PLMR_REQUEST_PACKET) Buffer;

    NetpKdPrint((PREFIX_WKSTA "WsSetWorkStationDomainName start.\n"));

    //
    // Lock config information structure for write access since we are
    // modifying the data in the WsInfo.
    //
    if (!RtlAcquireResourceExclusive(&WsInfo.ConfigResource, TRUE)) {
        return NERR_InternalError;
    }

    //
    // Get the primary domain name from the configuration file
    //
    if ((status = NetpGetDomainName(&DomainNameT)) != NERR_Success) {
        goto CloseConfigFile;
    }
    NetpAssert( DomainNameT != NULL );

    if ( *DomainNameT != 0 ) {

        if ((status = I_NetNameCanonicalize(
                          NULL,
                          DomainNameT,
                          (LPWSTR) WsInfo.WsPrimaryDomainName,
                          (DNLEN + 1) * sizeof(TCHAR),
                          WsInAWorkgroup() ? NAMETYPE_WORKGROUP : NAMETYPE_DOMAIN,
                          0
                          )) != NERR_Success) {

            LPWSTR SubString[1];


            NetpKdPrint((PREFIX_WKSTA FORMAT_LPTSTR
                         " is an invalid primary domain name.\n", DomainNameT));

            SubString[0] = DomainNameT;

            WsLogEvent(
                APE_CS_InvalidDomain,
                EVENTLOG_ERROR_TYPE,
                1,
                SubString,
                NERR_Success
                );

            (void) NetApiBufferFree(DomainNameT);
            goto CloseConfigFile;
        }
    } else {
        WsInfo.WsPrimaryDomainName[0] = 0;
    }

    //
    // Free memory allocated by NetpGetDomainName.
    //
    (void) NetApiBufferFree(DomainNameT);

    WsInfo.WsPrimaryDomainNameLength = STRLEN((LPWSTR) WsInfo.WsPrimaryDomainName);

    //
    // Initialize redirector configuration
    //

    Rrp->Type = ConfigInformation;
    Rrp->Version = REQUEST_PACKET_VERSION;

    Rrp->Parameters.Start.RedirectorNameLength = 0;

    Rrp->Parameters.Start.DomainNameLength = WsInfo.WsPrimaryDomainNameLength*sizeof(TCHAR);
    STRCPY((LPWSTR) (Rrp->Parameters.Start.RedirectorName),
           (LPWSTR) WsInfo.WsPrimaryDomainName);

    NetpKdPrint((PREFIX_WKSTA "WsSetWorkStationDomainName call rdr.\n"));

    status = WsRedirFsControl(
                  WsRedirDeviceHandle,
                  FSCTL_LMR_SET_DOMAIN_NAME,
                  Rrp,
                  sizeof(LMR_REQUEST_PACKET) + Rrp->Parameters.Start.DomainNameLength,
                  NULL,
                  0,
                  NULL
                  );

    if ((status != NERR_Success) && (status != ERROR_SERVICE_ALREADY_RUNNING)) {
        LPWSTR SubString[1];

        NetpKdPrint((PREFIX_WKSTA "Set domain name failed %lu\n", status));

        SubString[0] = L"redirector";

        WsLogEvent(
            NELOG_Service_Fail,
            EVENTLOG_ERROR_TYPE,
            1,
            SubString,
            status
            );
    }

CloseConfigFile:
    RtlReleaseResource(&WsInfo.ConfigResource);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsdfs.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       wsdfs.c
//
//  Classes:    None
//
//  Functions:  DfsDcName
//
//  History:    Feb 1, 1996     Milans  Created
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <stdlib.h>
#include <windows.h>
#include <lm.h>

#include <dsgetdc.h>                             // DsGetDcName

#include "wsdfs.h"
#include "dominfo.h"
#include "wsmain.h"

#include "wsutil.h"
#include <config.h>
#include <confname.h>

//
// Timeouts for domian change notifications
//
#define  TIMEOUT_MINUTES(_x)                  (_x) * 1000 * 60
#define  DOMAIN_NAME_CHANGE_TIMEOUT           1
#define  DOMAIN_NAME_CHANGE_TIMEOUT_LONG      15

#define  DFS_DC_NAME_DELAY                    TEXT("DfsDcNameDelay")
extern
NET_API_STATUS
WsSetWorkStationDomainName(
    VOID);

DWORD
DfsGetDelayInterval(void);

VOID
DfsDcName(
    LPVOID   pContext,
    BOOLEAN  fReason
    );

NTSTATUS
DfsGetDomainNameInfo(void);

extern HANDLE hMupEvent;
extern BOOLEAN MupEventSignaled;
extern BOOLEAN GotDomainNameInfo;
extern ULONG DfsDebug;

ULONG  g_ulCount;
ULONG  g_ulLastCount;
ULONG  g_ulInitThreshold;
ULONG  g_ulForce;
ULONG  g_ulForceThreshold;

HANDLE PollDCNameEvent = NULL;
HANDLE TearDownDoneEvent;

HANDLE WsDomainNameChangeEvent = NULL;
HANDLE g_WsDomainNameChangeWorkItem;

//+----------------------------------------------------------------------------
//
//  Function:   WsInitializeDfs
//
//  Synopsis:   Initializes the Dfs thread that waits for calls from the
//              driver to map Domain names into DC lists
//
//  Arguments:  None
//
//  Returns:    WIN32 error from CreateThread
//
//-----------------------------------------------------------------------------

NET_API_STATUS
WsInitializeDfs()
{
    NTSTATUS Status = STATUS_SUCCESS;
    NET_API_STATUS ApiStatus;
    OBJECT_ATTRIBUTES obja;

    DWORD  dwTimeout = INFINITE;
    HANDLE hEvent;

    g_ulInitThreshold = 4;
    g_ulForceThreshold = 60;
    g_ulForce = g_ulForceThreshold;

    // initialize workstation tear down done event
    InitializeObjectAttributes( &obja, NULL, OBJ_OPENIF, NULL, NULL );
    
    Status = NtCreateEvent(
                 &TearDownDoneEvent,
                 SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                 &obja,
                 SynchronizationEvent,
                 FALSE
                 );

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    if (hMupEvent == NULL) {
        hMupEvent = CreateMupEvent();
        if (WsInAWorkgroup() == TRUE && MupEventSignaled == FALSE) {
            SetEvent(hMupEvent);
            MupEventSignaled = TRUE;
        }
    }

    //
    // Watch for Domain Name changes, and automatically pick them up
    //
    ApiStatus = NetRegisterDomainNameChangeNotification( &WsDomainNameChangeEvent );
    if (ApiStatus != NO_ERROR) {
        WsDomainNameChangeEvent = NULL;

        InitializeObjectAttributes( &obja, NULL, OBJ_OPENIF, NULL, NULL );
        Status = NtCreateEvent(
                     &PollDCNameEvent,
                     SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                     &obja,
                     SynchronizationEvent,
                     FALSE
                     );

        if (Status != STATUS_SUCCESS) {
            NtClose(TearDownDoneEvent);
            TearDownDoneEvent = NULL;
            return Status;
        }
    }

    //
    // If we aren't in a workgroup or are in one but
    // don't need to wait for domain name change.
    //
    if (WsInAWorkgroup() != TRUE || WsDomainNameChangeEvent != NULL) {

        if (WsInAWorkgroup() != TRUE) {
            //
            // If we are not in a workgroup, set the timeout value to poll the DC name.
            //
            dwTimeout = 1;
        }

        hEvent = WsDomainNameChangeEvent ? WsDomainNameChangeEvent : PollDCNameEvent;

        Status = RtlRegisterWait(
                    &g_WsDomainNameChangeWorkItem,
                    hEvent,
                    DfsDcName,                      // callback fcn
                    hEvent,                         // parameter
                    dwTimeout,                      // timeout
                    WT_EXECUTEONLYONCE |            // flags
                      WT_EXECUTEDEFAULT |
                      WT_EXECUTELONGFUNCTION);
    }

    if (!NT_SUCCESS(Status)) {

        NtClose(TearDownDoneEvent);
        TearDownDoneEvent = NULL;

        if (PollDCNameEvent != NULL) {
            NtClose(PollDCNameEvent);
            PollDCNameEvent = NULL;
        }

        return( RtlNtStatusToDosError(Status) );
    } else {
        return( NERR_Success );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   WsShutdownDfs
//
//  Synopsis:   Stops the thread created by WsInitializeDfs
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
WsShutdownDfs()
{
    DWORD dwReturn, cbRead;
    NTSTATUS Status;
    HANDLE hDfs;

    Status = DfsOpen( &hDfs, NULL );
    if (NT_SUCCESS(Status)) {

        Status = DfsFsctl(
                    hDfs,
                    FSCTL_DFS_STOP_DFS,
                    NULL,
                    0L,
                    NULL,
                    0L);

        NtClose( hDfs );

    }

    if( WsDomainNameChangeEvent ) {
        //
        // Stop waiting for domain name changes
        //
        SetEvent( WsDomainNameChangeEvent );
        WaitForSingleObject(TearDownDoneEvent, INFINITE);
        NetUnregisterDomainNameChangeNotification( WsDomainNameChangeEvent );
        WsDomainNameChangeEvent = NULL;
    } else {
        SetEvent( PollDCNameEvent );
        WaitForSingleObject(TearDownDoneEvent, INFINITE);
        NtClose(PollDCNameEvent);
        PollDCNameEvent = NULL;
    }

    NtClose(TearDownDoneEvent);
    TearDownDoneEvent = NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDcName
//
//  Synopsis:   Gets a DC name and sends it to the mup(dfs) driver
//
//              This routine is intended to be called as the entry proc for a
//              thread.
//
//  Arguments:  pContext -- Context data (handle to domain name change event)
//              fReason  -- TRUE if the wait timed out
//                          FALSE if the event was signalled
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DfsDcName(
    LPVOID   pContext,
    BOOLEAN  fReason
    )
{
    NTSTATUS            Status;
    HANDLE              hDfs;
    DWORD               dwTimeout = INFINITE;
    ULONG               Flags = 0;
    BOOLEAN             needRefresh = FALSE;
    BOOLEAN             DcNameFailed;
    Status = RtlDeregisterWait(g_WsDomainNameChangeWorkItem);

    if (!NT_SUCCESS(Status)) {
        NetpKdPrint(("WKSTA DfsDcName: RtlDeregisterWait FAILED %#x\n", Status));
    }

    if (WsGlobalData.Status.dwCurrentState == SERVICE_STOP_PENDING
         ||
        WsGlobalData.Status.dwCurrentState == SERVICE_STOPPED)
    {
        //
        // The service is shutting down -- stop waiting for a domain name change
        //
        SetEvent(TearDownDoneEvent);
        return;
    }

    if (fReason) {

        //
        // TRUE == timeout
        //

        if ((g_ulCount <= g_ulInitThreshold) ||
            (g_ulLastCount >= DfsGetDelayInterval())) {
            g_ulLastCount = 0;
            needRefresh = TRUE;
        }

        if (needRefresh) {

           Status = DfsOpen( &hDfs, NULL );
           if (NT_SUCCESS(Status)) {
               Status = DfsFsctl(
                           hDfs,
                           FSCTL_DFS_PKT_SET_DC_NAME,
                           L"",
                           sizeof(WCHAR),
                           NULL,
                           0L);
               NtClose( hDfs );
           }

           if (NT_SUCCESS(Status) && GotDomainNameInfo == FALSE) {
               DfsGetDomainNameInfo();
           }

           if (g_ulCount > g_ulInitThreshold) {
                Flags |= DS_BACKGROUND_ONLY;
           }
           Status = DfsGetDCName(Flags, &DcNameFailed);

           if (!NT_SUCCESS(Status) && 
	        DcNameFailed == FALSE &&
                g_ulForce >= g_ulForceThreshold) {
                g_ulForce = 0;
                Flags |= DS_FORCE_REDISCOVERY;
                Status = DfsGetDCName(Flags, &DcNameFailed);
           }
        }

        if (MupEventSignaled == FALSE) {
#if DBG
            if (DfsDebug)
                DbgPrint("Signaling mup event\n");
#endif
            SetEvent(hMupEvent);
            MupEventSignaled = TRUE;
        }


        if (NT_SUCCESS(Status) || (g_ulCount > g_ulInitThreshold)) {
            dwTimeout = DOMAIN_NAME_CHANGE_TIMEOUT_LONG;
        }
        else {
            dwTimeout = DOMAIN_NAME_CHANGE_TIMEOUT;
        }
	
        g_ulCount += dwTimeout;
        g_ulForce += dwTimeout;
        g_ulLastCount += dwTimeout;
        dwTimeout = TIMEOUT_MINUTES(dwTimeout);
    }
    else {

        // set the new WorkStation domain name if the event is triggered by domain
        // name change event.
        NetpKdPrint(("WKSTA DfsDcName set WorkStation Domain Name\n"));
        WsSetWorkStationDomainName();

        // timeout needs to be adjusted accordingly if change occurs between workgroup
        // and domain so that DC name is also updated on the DFS.
        if (WsInAWorkgroup() != TRUE) {
            dwTimeout = TIMEOUT_MINUTES(DOMAIN_NAME_CHANGE_TIMEOUT);
        } else {
            dwTimeout = INFINITE;

                // DFS needs to take care of the transition from domain to workgroup.
        }
    }

    //
    // Reregister the wait on the domain name change event
    //
    Status = RtlRegisterWait(
                &g_WsDomainNameChangeWorkItem,
                (HANDLE)pContext,               // waitable handle
                DfsDcName,                      // callback fcn
                pContext,                       // parameter
                dwTimeout,                      // timeout
                WT_EXECUTEONLYONCE |            // flags
                WT_EXECUTEDEFAULT |
                WT_EXECUTELONGFUNCTION);

    return;
}


#define DFS_DC_NAME_DELAY_POLICY_KEY TEXT("Software\\Policies\\Microsoft\\System\\DFSClient")

DWORD
DfsGetDelayInterval(void)
{
    NET_API_STATUS ApiStatus;
    LPNET_CONFIG_HANDLE SectionHandle = NULL;
    DWORD Value=0;
    HKEY hKey;
    LONG lResult=0;
    DWORD dwValue=0, dwSize = sizeof(dwValue);
    DWORD dwType = 0;

    // First, check for a policy
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, DFS_DC_NAME_DELAY_POLICY_KEY, 0,
                            KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx (hKey, DFS_DC_NAME_DELAY, 0, &dwType, 
                                   (LPBYTE) &dwValue, &dwSize);
        RegCloseKey (hKey);
    }

    // Exit now if a policy value was found
    if (lResult == ERROR_SUCCESS && dwType == REG_DWORD)
    {
        return dwValue;
    }              

    // Second, check for a preference

    //
    // Open section of config data.
    //
    ApiStatus = NetpOpenConfigData(
                    &SectionHandle,
                    NULL,                      // Local server.
                    SECT_NT_WKSTA,             // Section name.
                    FALSE                      // Don't want read-only access.
                    );

    if (ApiStatus != NERR_Success) {
        return DOMAIN_NAME_CHANGE_TIMEOUT_LONG;
    }

    ApiStatus = NetpGetConfigDword(
                    SectionHandle,
                    DFS_DC_NAME_DELAY,
                    0,
                    &Value
                    );


    NetpCloseConfigData( SectionHandle );

    if (ApiStatus != NERR_Success) {
        return DOMAIN_NAME_CHANGE_TIMEOUT_LONG;
    }

    if (Value < DOMAIN_NAME_CHANGE_TIMEOUT_LONG) {
      Value = DOMAIN_NAME_CHANGE_TIMEOUT_LONG;
    }

    return Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsdevice.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wsdevice.c

Abstract:

    This module contains the support routines for the APIs that call
    into the redirector or the datagram receiver.

Author:

    Rita Wong (ritaw) 20-Feb-1991

Revision History:

--*/

#include "wsutil.h"
#include "wsconfig.h"
#include "wsdevice.h"
#include "wsbind.h"
#include <lmerrlog.h>   // Eventlog message IDs
#include "winreg.h"     // registry API's
#include <prefix.h>     // PREFIX_ equates.


//
// Buffer allocation size for enumeration output buffer.
//
#define INITIAL_ALLOCATION_SIZE  4096  // First attempt size
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount
#define CSC_WAIT_TIME               15 * 1000   // give agent 15 seconds to stop CSC

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsOpenRedirector(
    VOID
    );

STATIC
NET_API_STATUS
WsOpenDgReceiver (
    VOID
    );


HANDLE
CreateNamedEvent(
    LPWSTR  lpwEventName
    );

BOOL
AgentIsAlive(
     VOID
     );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Handle to the Redirector FSD
//
HANDLE WsRedirDeviceHandle = NULL;
HANDLE WsRedirAsyncDeviceHandle = NULL;

BOOLEAN LoadedMRxSmbInsteadOfRdr = FALSE;

//
// Handle to the Datagram Receiver DD
//
HANDLE WsDgReceiverDeviceHandle = NULL;
HANDLE WsDgrecAsyncDeviceHandle = NULL;

HANDLE  heventWkssvcToAgentStart = NULL;
HANDLE  heventWkssvcToAgentStop = NULL;
HANDLE  heventAgentToWkssvc = NULL;

BOOL    vfRedirStarted = FALSE;

static  WCHAR wszWkssvcToAgentStartEvent[] = L"WkssvcToAgentStartEvent";
static  WCHAR wszWkssvcToAgentStopEvent[] = L"WkssvcToAgentStopEvent";
static  WCHAR wszAgentToWkssvcEvent[] = L"AgentToWkssvcEvent";
static  WCHAR wzAgentExistsEvent[] = L"AgentExistsEvent"; // used to detect if agent exists


NET_API_STATUS
WsDeviceControlGetInfo(
    IN  DDTYPE DeviceDriverType,
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPBYTE *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the redirector or datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the redirector or the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;


    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    if (DeviceDriverType == Redirector) {
        PLMR_REQUEST_PACKET Rrp = (PLMR_REQUEST_PACKET) RequestPacket;

        OriginalResumeKey = Rrp->Parameters.Get.ResumeHandle;

        //
        // Make the request of the Redirector
        //

        status = WsRedirFsControl(
                     FileHandle,
                     DeviceControlCode,
                     Rrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength,
                     Information
                     );

        if (status == ERROR_MORE_DATA) {
            TotalBytesNeeded = Rrp->Parameters.Get.TotalBytesNeeded;

        }

    }
    else {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

        //
        // Make the request of the Datagram Receiver
        //
        status = WsDgReceiverIoControl(
                     FileHandle,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength,
                     NULL
                     );

        if (status == ERROR_MORE_DATA) {

            NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

            TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
        }
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        MIDL_user_free(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

        //
        // Try again to get the information from the redirector or datagram
        // receiver
        //
        if (DeviceDriverType == Redirector) {
            PLMR_REQUEST_PACKET Rrp = (PLMR_REQUEST_PACKET) RequestPacket;

            Rrp->Parameters.Get.ResumeHandle = OriginalResumeKey;

            //
            // Make the request of the Redirector
            //
            status = WsRedirFsControl(
                         FileHandle,
                         DeviceControlCode,
                         Rrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength,
                         Information
                         );
        }
        else {
            PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

            NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

            Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;

            //
            // Make the request of the Datagram Receiver
            //

            status = WsDgReceiverIoControl(
                         FileHandle,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength,
                         NULL
                         );
        }
    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != NERR_Success && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA)) {

        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return status;
}


NET_API_STATUS
WsInitializeRedirector(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT LAN Man redirector.  It then reads in
    the configuration information and initializes to redirector.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS  status;


    status = WsLoadRedirector();

    if (status != NERR_Success && status != ERROR_SERVICE_ALREADY_RUNNING) {
        DbgPrint("WKSSVC Load redirector returned %lx\n", status);
        return status;
    }

    //
    // Open redirector FSD to get handle to it
    //

    if ((status = WsOpenRedirector()) != NERR_Success) {
        DbgPrint("WKSSVC Open redirector returned %lx\n", status);
        return status;
    }

//    if ((status = WsLoadDriver(L"DGRcvr")) != NERR_Success) {
//        return status;
//    }

    //
    // Open datagram receiver FSD to get handle to it.
    //
    if ((status = WsOpenDgReceiver()) != NERR_Success) {
        DbgPrint("WKSSVC Open datagram receiver returned %lx\n", status);
        return status;
    }

    //
    // Load redirector and datagram receiver configuration
    //
    if ((status = WsGetWorkstationConfiguration()) != NERR_Success) {

        DbgPrint("WKSSVC Get workstation configuration returned %lx\n", status);
        DbgPrint("WKSSVC Shut down the redirector\n");

        (void) WsShutdownRedirector();
        return status;
    }

    IF_DEBUG(START) {
        DbgPrint("WKSSVC Get workstation configuration returned %lx\n", status);
    }

    return NERR_Success;
}


STATIC
NET_API_STATUS
WsOpenRedirector(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT LAN Man redirector FSD.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName,DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &WsRedirDeviceHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] NtOpenFile redirector failed: 0x%08lx\n",
                     ntstatus));
        WsRedirDeviceHandle = NULL;
        return NetpNtStatusToApiStatus( ntstatus);
    }

    ntstatus = NtOpenFile(
                   &WsRedirAsyncDeviceHandle,
                   FILE_READ_DATA | FILE_WRITE_DATA,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   0L
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] NtOpenFile redirector ASYNC failed: 0x%08lx\n",
                     ntstatus));
        WsRedirAsyncDeviceHandle = NULL;
    }

    return NetpNtStatusToApiStatus(ntstatus);
}


STATIC
NET_API_STATUS
WsOpenDgReceiver(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT LAN Man Datagram Receiver driver.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    RtlInitUnicodeString( &DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    if (WsDgReceiverDeviceHandle == NULL) {
        //
        // Open the BOSWER device. The check is based on the fact that Services process
        // does not actually unload the driver when the service is stopped.
        //

        ntstatus = NtOpenFile(
                       &WsDgReceiverDeviceHandle,
                       SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_VALID_FLAGS,
                       FILE_SYNCHRONOUS_IO_NONALERT
                       );

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }

        if (! NT_SUCCESS(ntstatus)) {
            NetpKdPrint(("[Wksta] NtOpenFile datagram receiver failed: 0x%08lx\n",
                         ntstatus));

            WsDgReceiverDeviceHandle = NULL;
            return NetpNtStatusToApiStatus(ntstatus);
        }
    }

    ntstatus = NtOpenFile(
                   &WsDgrecAsyncDeviceHandle,
                   FILE_READ_DATA | FILE_WRITE_DATA,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   0L
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] NtOpenFile datagram receiver ASYNC failed: 0x%08lx\n",
                     ntstatus));

        WsDgrecAsyncDeviceHandle = NULL;
    }

    return NetpNtStatusToApiStatus(ntstatus);
}


NET_API_STATUS
WsUnloadDriver(
    IN LPWSTR DriverNameString
    )
{
    ULONG Privileges[1];
    LPWSTR DriverRegistryName;
    UNICODE_STRING DriverRegistryString;
    NET_API_STATUS Status;
    NTSTATUS ntstatus;


    DriverRegistryName = (LPWSTR) LocalAlloc(
                                      LMEM_FIXED,
                                      (UINT) (sizeof(SERVICE_REGISTRY_KEY) +
                                              (wcslen(DriverNameString) *
                                               sizeof(WCHAR)))
                                      );

    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = NetpGetPrivilege(1, Privileges);

    if (Status != NERR_Success) {
        LocalFree(DriverRegistryName);
        return Status;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DriverNameString);

    RtlInitUnicodeString(&DriverRegistryString, DriverRegistryName);

    ntstatus = NtUnloadDriver(&DriverRegistryString);

    LocalFree(DriverRegistryName);

    NetpReleasePrivilege();

    return(WsMapStatus(ntstatus));
}


NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    )
{
    ULONG Privileges[1];
    LPWSTR DriverRegistryName;
    UNICODE_STRING DriverRegistryString;
    NET_API_STATUS Status;
    NTSTATUS ntstatus;



    DriverRegistryName = (LPWSTR) LocalAlloc(
                                      LMEM_FIXED,
                                      (UINT) (sizeof(SERVICE_REGISTRY_KEY) +
                                              (wcslen(DriverNameString) *
                                               sizeof(WCHAR)))
                                      );

    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = NetpGetPrivilege(1, Privileges);

    if (Status != NERR_Success) {
        LocalFree(DriverRegistryName);
        return Status;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DriverNameString);

    RtlInitUnicodeString(&DriverRegistryString, DriverRegistryName);

    ntstatus = NtLoadDriver(&DriverRegistryString);

    NetpReleasePrivilege();

    LocalFree(DriverRegistryName);

    if (ntstatus != STATUS_SUCCESS && ntstatus != STATUS_IMAGE_ALREADY_LOADED) {

        LPWSTR  subString[1];


        subString[0] = DriverNameString;

        WsLogEvent(
            NELOG_DriverNotLoaded,
            EVENTLOG_ERROR_TYPE,
            1,
            subString,
            ntstatus
            );
    }

    return(WsMapStatus(ntstatus));
}


NET_API_STATUS
WsShutdownRedirector(
    VOID
    )
/*++

Routine Description:

    This routine close the LAN Man Redirector device.

Arguments:

    None.

Return Value:



--*/
{
    LMR_REQUEST_PACKET Rrp;
    LMDR_REQUEST_PACKET Drp;
    NET_API_STATUS Status;

    // tell csc to stop doing stuff
    if ((Status = WsCSCWantToStopRedir()) != ERROR_SUCCESS)
    {
        return Status;
    }

    Rrp.Version = REQUEST_PACKET_VERSION;

    Status = WsRedirFsControl(
                 WsRedirDeviceHandle,
                 FSCTL_LMR_STOP,
                 &Rrp,
                 sizeof(LMR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL
                 );

    (void) NtClose(WsRedirDeviceHandle);
    WsRedirDeviceHandle = NULL;


    if (Status != ERROR_REDIRECTOR_HAS_OPEN_HANDLES) {
        //
        //  After the workstation has been stopped, we want to unload our
        //  dependant drivers (the RDR and BOWSER).
        //

        if (WsDgReceiverDeviceHandle != NULL) {

            Drp.Version = LMDR_REQUEST_PACKET_VERSION;

            (void) WsDgReceiverIoControl(
                       WsDgReceiverDeviceHandle,
                       IOCTL_LMDR_STOP,
                       &Drp,
                       sizeof(LMDR_REQUEST_PACKET),
                       NULL,
                       0,
                       NULL
                       );

            (void) NtClose(WsDgReceiverDeviceHandle);
            WsDgReceiverDeviceHandle = NULL;

            //
            //  WsUnloadDriver(L"DGRcvr");
            //
        }

        WsUnloadRedirector();
    } else {
       NET_API_STATUS  TempStatus;
       HKEY            hRedirectorKey;
       DWORD           FinalStatus;

       TempStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        MRXSMB_REGISTRY_KEY,
                        0,
                        KEY_ALL_ACCESS,
                        &hRedirectorKey);

       if (TempStatus == ERROR_SUCCESS) {
          // if this is a controlled shutdown and the driver could not be
          // unloaded mark the status in the registry for resumption

          FinalStatus = ERROR_SUCCESS;
          TempStatus = RegSetValueEx(
                              hRedirectorKey,
                              LAST_LOAD_STATUS,
                              0,
                              REG_DWORD,
                              (PCHAR)&FinalStatus,
                              sizeof(DWORD));

          if (TempStatus == ERROR_SUCCESS) {
             NetpKdPrint((PREFIX_WKSTA "New RDR will be loaded on restart\n"));
          }

          RegCloseKey(hRedirectorKey);
       }
    }

    if (Status != NERR_Success)
    {
//        NetpAssert(vfRedirStarted == 0);

        WsCSCReportStartRedir();
    }

    return Status;
}


NET_API_STATUS
WsRedirFsControl(
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PLMR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    RedirControlCode - Supplies the NtFsControlFile function code given to
        the redirector.

    Rrp - Supplies the redirector request packet.

    RrpLength - Supplies the length of the redirector request packet.

    SecondBuffer - Supplies the second buffer in call to NtFsControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Send the request to the Redirector FSD.
    //
    ntstatus = NtFsControlFile(
                   FileHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   RedirControlCode,
                   Rrp,
                   RrpLength,
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

    IF_DEBUG(UTIL) {
        if (! NT_SUCCESS(ntstatus)) {
            NetpKdPrint(("[Wksta] fsctl to redir returns %08lx\n", ntstatus));
        }
    }

    return WsMapStatus(ntstatus);
}



NET_API_STATUS
WsDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;


    if (FileHandle == NULL) {
        IF_DEBUG(UTIL) {
            NetpKdPrint(("[Wksta] Datagram receiver not implemented\n"));
        }
        return ERROR_NOT_SUPPORTED;
    }

    Drp->TransportName.Length = 0;

    //
    // Send the request to the Datagram Receiver DD.
    //
    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   Drp,
                   DrpSize,
                   SecondBuffer,
                   SecondBufferLength
                   );

    // as our handles are always async, only if the driver returned pending
    // do we copy the status from the iostatusblock
    if (ntstatus==STATUS_PENDING) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        if (NT_SUCCESS(ntstatus))
        {
            *Information = IoStatusBlock.Information;
        }
    }

    IF_DEBUG(UTIL) {
        if (! NT_SUCCESS(ntstatus)) {
            NetpKdPrint(("[Wksta] fsctl to dgreceiver returns %08lx\n", ntstatus));
        }
    }

    if (ntstatus == STATUS_TIMEOUT) {
        return ERROR_TIMEOUT;
    } else {
        return WsMapStatus(ntstatus);
    }
}



NET_API_STATUS
WsAsyncBindTransport(
    IN  LPWSTR          transportName,
    IN  DWORD           qualityOfService,
    IN  PLIST_ENTRY     pHeader
    )
/*++

Routine Description:

    This function async binds the specified transport to the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    transportName - Supplies the name of the transport to bind to.

    qualityOfService - Supplies a value which specifies the search
        order of the transport with respect to other transports.  The
        highest value is searched first.

Return Value:

    NO_ERROR

--*/
{
    NTSTATUS                ntStatus;
    NET_API_STATUS          status;
    DWORD                   size;
    DWORD                   redirSize;
    DWORD                   dgrecSize;
    DWORD                   nameLength;
    PWS_BIND                pBind;
    PWS_BIND_REDIR          pBindRedir;
    PWS_BIND_DGREC          pBindDgrec;
    DWORD                   variablePart;

    // we don't need to add in an extra space for the NULL because
    // the structure definitions have the space built in
    nameLength = wcslen(transportName);

    //
    //  Make sure *Size-s are PVOID aligned.
    //

    variablePart = nameLength * sizeof( WCHAR );
    variablePart = (variablePart + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1);

    //
    //  Then add the fixed part to *Size-s.
    //

    size = sizeof( WS_BIND) + variablePart;
    redirSize = sizeof( WS_BIND_REDIR) + variablePart;
    dgrecSize = sizeof( WS_BIND_DGREC) + variablePart;

    pBind = (PVOID) LocalAlloc(
                        LMEM_ZEROINIT,
                        (UINT) (size + redirSize + dgrecSize)
                        );

    if ( pBind == NULL) {
        NetpKdPrint(( "[Wksta] Failed to allocate pBind memory\n"));
        return GetLastError();
    }

    pBind->TransportNameLength = nameLength * sizeof( WCHAR);
    StringCchCopyW(pBind->TransportName, nameLength, transportName);
    pBind->Redir = pBindRedir = (PWS_BIND_REDIR)( (PCHAR)pBind + size);
    pBind->Dgrec = pBindDgrec = (PWS_BIND_DGREC)( (PCHAR)pBindRedir + redirSize);

    pBindRedir->EventHandle = INVALID_HANDLE_VALUE;
    pBindRedir->Bound = FALSE;
    pBindRedir->Packet.Version = REQUEST_PACKET_VERSION;
    pBindRedir->Packet.Parameters.Bind.QualityOfService = qualityOfService;
    pBindRedir->Packet.Parameters.Bind.TransportNameLength =
            nameLength * sizeof( WCHAR);
    StringCchCopyW(pBindRedir->Packet.Parameters.Bind.TransportName,
                   nameLength, transportName);

    pBindDgrec->EventHandle = INVALID_HANDLE_VALUE;
    pBindDgrec->Bound = FALSE;
    pBindDgrec->Packet.Version = LMDR_REQUEST_PACKET_VERSION;
    pBindDgrec->Packet.Level = 0; // Indicate computername doesn't follow transport name
    pBindDgrec->Packet.Parameters.Bind.TransportNameLength =
            nameLength * sizeof( WCHAR);
    StringCchCopyW(pBindDgrec->Packet.Parameters.Bind.TransportName,
                   nameLength, transportName);

    pBindRedir->EventHandle = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

    if ( pBindRedir->EventHandle == NULL) {
        NetpKdPrint(( "[Wksta] Failed to allocate event handle\n"));
        status = GetLastError();
        goto tail_exit;
    }

    ntStatus = NtFsControlFile(
            WsRedirAsyncDeviceHandle,
            pBindRedir->EventHandle,
            NULL,                               // apc routine
            NULL,                               // apc context
            &pBindRedir->IoStatusBlock,
            FSCTL_LMR_BIND_TO_TRANSPORT,        // control code
            &pBindRedir->Packet,
            sizeof( LMR_REQUEST_PACKET) +
                pBindRedir->Packet.Parameters.Bind.TransportNameLength,
            NULL,
            0
            );

    if ( ntStatus != STATUS_PENDING) {
        CloseHandle( pBindRedir->EventHandle);
        pBindRedir->EventHandle = INVALID_HANDLE_VALUE;
        pBindRedir->Bound = NT_SUCCESS( ntStatus );
    }


    pBindDgrec->EventHandle = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

    if ( pBindDgrec->EventHandle == NULL) {
        status = GetLastError();
        goto tail_exit;
    }

#ifdef RDR_PNP_POWER
    ntStatus = STATUS_SUCCESS;
#else
    ntStatus = NtDeviceIoControlFile(
            WsDgrecAsyncDeviceHandle,
            pBindDgrec->EventHandle,
            NULL,
            NULL,
            &pBindDgrec->IoStatusBlock,
            IOCTL_LMDR_BIND_TO_TRANSPORT,
            &pBindDgrec->Packet,
            dgrecSize - FIELD_OFFSET( WS_BIND_DGREC, Packet ),
            NULL,
            0
            );
#endif

    if ( ntStatus != STATUS_PENDING) {
        CloseHandle( pBindDgrec->EventHandle);
        pBindDgrec->EventHandle = INVALID_HANDLE_VALUE;
        pBindDgrec->Bound = NT_SUCCESS( ntStatus );
    }

tail_exit:
    InsertTailList( pHeader, &pBind->ListEntry);
    return NO_ERROR;
}



NET_API_STATUS
WsBindTransport(
    IN  LPTSTR TransportName,
    IN  DWORD QualityOfService,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function binds the specified transport to the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    TransportName - Supplies the name of the transport to bind to.

    QualityOfService - Supplies a value which specifies the search
        order of the transport with respect to other transports.  The
        highest value is searched first.

    ErrorParameter - Returns the identifier to the invalid parameter if
        this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD RequestPacketSize;
    DWORD TransportNameSize = STRLEN(TransportName) * sizeof(TCHAR);

    PLMR_REQUEST_PACKET Rrp;
    PLMDR_REQUEST_PACKET Drrp;


    //
    // Size of request packet buffer
    //
    RequestPacketSize = STRLEN(TransportName) * sizeof(WCHAR) +
                        max(sizeof(LMR_REQUEST_PACKET),
                            sizeof(LMDR_REQUEST_PACKET));

    //
    // Allocate memory for redirector/datagram receiver request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(LMEM_ZEROINIT, (UINT) RequestPacketSize)) == NULL) {
        return GetLastError();
    }

    //
    // Get redirector to bind to transport
    //
    Rrp->Version = REQUEST_PACKET_VERSION;
    Rrp->Parameters.Bind.QualityOfService = QualityOfService;

    Rrp->Parameters.Bind.TransportNameLength = TransportNameSize;
    STRCPY(Rrp->Parameters.Bind.TransportName, TransportName);

    if ((status = WsRedirFsControl(
                      WsRedirDeviceHandle,
                      FSCTL_LMR_BIND_TO_TRANSPORT,
                      Rrp,
                      sizeof(LMR_REQUEST_PACKET) +
                          Rrp->Parameters.Bind.TransportNameLength,
                      NULL,
                      0,
                      NULL
                      )) != NERR_Success) {

        if (status == ERROR_INVALID_PARAMETER &&
            ARGUMENT_PRESENT(ErrorParameter)) {

            IF_DEBUG(INFO) {
                NetpKdPrint((
                    "[Wksta] NetrWkstaTransportAdd: invalid parameter is %lu\n",
                    Rrp->Parameters.Bind.WkstaParameter));
            }

            *ErrorParameter = Rrp->Parameters.Bind.WkstaParameter;
        }

        (void) LocalFree(Rrp);
        return status;
    }


    //
    // Get dgrec to bind to transport
    //

    //
    // Make use of the same request packet buffer as FSCtl to
    // redirector.
    //
    Drrp = (PLMDR_REQUEST_PACKET) Rrp;

    Drrp->Version = LMDR_REQUEST_PACKET_VERSION;

    Drrp->Parameters.Bind.TransportNameLength = TransportNameSize;
    STRCPY(Drrp->Parameters.Bind.TransportName, TransportName);

    status = WsDgReceiverIoControl(
                 WsDgReceiverDeviceHandle,
                 IOCTL_LMDR_BIND_TO_TRANSPORT,
                 Drrp,
                 RequestPacketSize,
                 NULL,
                 0,
                 NULL
                 );

    (void) LocalFree(Rrp);
    return status;
}


VOID
WsUnbindTransport2(
    IN PWS_BIND     pBind
    )
/*++

Routine Description:

    This function unbinds the specified transport from the redirector
    and the datagram receiver.

Arguments:

    pBind - structure constructed via WsAsyncBindTransport()

Return Value:

    None.

--*/
{
//    NET_API_STATUS          status;
    PWS_BIND_REDIR          pBindRedir = pBind->Redir;
    PWS_BIND_DGREC          pBindDgrec = pBind->Dgrec;


    //
    // Get redirector to unbind from transport
    //

    if ( pBindRedir->Bound == TRUE) {
        pBindRedir->Packet.Parameters.Unbind.TransportNameLength
                = pBind->TransportNameLength;
        memcpy(
            pBindRedir->Packet.Parameters.Unbind.TransportName,
            pBind->TransportName,
            pBind->TransportNameLength
            );

        (VOID)NtFsControlFile(
                WsRedirDeviceHandle,
                NULL,
                NULL,                               // apc routine
                NULL,                               // apc context
                &pBindRedir->IoStatusBlock,
                FSCTL_LMR_UNBIND_FROM_TRANSPORT,    // control code
                &pBindRedir->Packet,
                sizeof( LMR_REQUEST_PACKET) +
                    pBindRedir->Packet.Parameters.Unbind.TransportNameLength,
                NULL,
                0
                );
        pBindRedir->Bound = FALSE;
    }

    //
    // Get datagram receiver to unbind from transport
    //

    if ( pBindDgrec->Bound == TRUE) {

        pBindDgrec->Packet.Parameters.Unbind.TransportNameLength
                = pBind->TransportNameLength;
        memcpy(
            pBindDgrec->Packet.Parameters.Unbind.TransportName,
            pBind->TransportName,
            pBind->TransportNameLength
            );

        (VOID)NtDeviceIoControlFile(
                WsDgReceiverDeviceHandle,
                NULL,
                NULL,                               // apc routine
                NULL,                               // apc context
                &pBindDgrec->IoStatusBlock,
                FSCTL_LMR_UNBIND_FROM_TRANSPORT,    // control code
                &pBindDgrec->Packet,
                sizeof( LMR_REQUEST_PACKET) +
                    pBindDgrec->Packet.Parameters.Unbind.TransportNameLength,
                NULL,
                0
                );
         pBindDgrec->Bound = FALSE;
    }
}


NET_API_STATUS
WsUnbindTransport(
    IN LPTSTR TransportName,
    IN DWORD ForceLevel
    )
/*++

Routine Description:

    This function unbinds the specified transport from the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    TransportName - Supplies the name of the transport to bind to.

    ForceLevel - Supplies the force level to delete active connections
        on the specified transport.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD RequestPacketSize;
    DWORD TransportNameSize = STRLEN(TransportName) * sizeof(TCHAR);

    PLMR_REQUEST_PACKET Rrp;
    PLMDR_REQUEST_PACKET Drrp;


    //
    // Size of request packet buffer
    //
    RequestPacketSize = STRLEN(TransportName) * sizeof(WCHAR) +
                        max(sizeof(LMR_REQUEST_PACKET),
                            sizeof(LMDR_REQUEST_PACKET));

    //
    // Allocate memory for redirector/datagram receiver request packet
    //
    if ((Rrp = (PVOID) LocalAlloc(LMEM_ZEROINIT, (UINT) RequestPacketSize)) == NULL) {
        return GetLastError();
    }


    //
    // Get redirector to unbind from transport
    //
    Rrp->Version = REQUEST_PACKET_VERSION;
    Rrp->Level = ForceLevel;

    Rrp->Parameters.Unbind.TransportNameLength = TransportNameSize;
    STRCPY(Rrp->Parameters.Unbind.TransportName, TransportName);

    if ((status = WsRedirFsControl(
                      WsRedirDeviceHandle,
                      FSCTL_LMR_UNBIND_FROM_TRANSPORT,
                      Rrp,
                      sizeof(LMR_REQUEST_PACKET) +
                          Rrp->Parameters.Unbind.TransportNameLength,
                      NULL,
                      0,
                      NULL
                      )) != NERR_Success) {
        (void) LocalFree(Rrp);
        return status;
    }

    //
    // Get datagram receiver to unbind from transport
    //

    //
    // Make use of the same request packet buffer as FSCtl to
    // redirector.
    //
    Drrp = (PLMDR_REQUEST_PACKET) Rrp;

    Drrp->Version = LMDR_REQUEST_PACKET_VERSION;
    Drrp->Level = ForceLevel;

    Drrp->Parameters.Unbind.TransportNameLength = TransportNameSize;
    STRCPY(Drrp->Parameters.Unbind.TransportName, TransportName);

    if ((status = WsDgReceiverIoControl(
                  WsDgReceiverDeviceHandle,
                  IOCTL_LMDR_UNBIND_FROM_TRANSPORT,
                  Drrp,
                  RequestPacketSize,
                  NULL,
                  0,
                  NULL
                  )) != NERR_Success) {

// NTRAID-70693-2/6/2000 davey This is a hack until the bowser supports XNS and LOOP.

        if (status == NERR_UseNotFound) {
            status = NERR_Success;
        }
    }

    (void) LocalFree(Rrp);
    return status;
}


NET_API_STATUS
WsDeleteDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpSize,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    )
/*++

Routine Description:

    This function deletes a domain name from the datagram receiver for
    the current user.  It assumes that enough memory is allocate for the
    request packet that is passed in.

Arguments:

    Drp - Pointer to a datagram receiver request packet with the
        request packet version, and name type initialized.

    DrpSize - Length of datagram receiver request packet in bytes.

    DomainName - Pointer to the domain name to delete.

    DomainNameSize - Length of the domain name in bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    Drp->Parameters.AddDelName.DgReceiverNameLength = DomainNameSize;

    memcpy(
        (LPBYTE) Drp->Parameters.AddDelName.Name,
        (LPBYTE) DomainName,
        DomainNameSize
        );

    return WsDgReceiverIoControl(
               WsDgReceiverDeviceHandle,
               IOCTL_LMDR_DELETE_NAME,
               Drp,
               DrpSize,
               NULL,
               0,
               NULL
               );
}


NET_API_STATUS
WsAddDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpSize,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    )
/*++

Routine Description:

    This function adds a domain name to the datagram receiver for the
    current user.  It assumes that enough memory is allocate for the
    request packet that is passed in.

Arguments:

    Drp - Pointer to a datagram receiver request packet with the
        request packet version, and name type initialized.

    DrpSize - Length of datagram receiver request packet in bytes.

    DomainName - Pointer to the domain name to delete.

    DomainNameSize - Length of the domain name in bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    Drp->Parameters.AddDelName.DgReceiverNameLength = DomainNameSize;

    memcpy(
        (LPBYTE) Drp->Parameters.AddDelName.Name,
        (LPBYTE) DomainName,
        DomainNameSize
        );

    return WsDgReceiverIoControl(
               WsDgReceiverDeviceHandle,
               IOCTL_LMDR_ADD_NAME,
               Drp,
               DrpSize,
               NULL,
               0,
               NULL
               );
}

NET_API_STATUS
WsTryToLoadSmbMiniRedirector(
    VOID
    );

NET_API_STATUS
WsLoadRedirector(
    VOID
    )
/*++

Routine Description:

    This routine loads rdr.sys or mrxsmb.sys et al depending on whether
    the conditions for loading mrxsmb.sys are met.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

Notes:

    The new redirector consists of two parts -- the RDBSS (redirected drive buffering
    subsystem ) and the corresponding smb mini redirectors. Only the minirdr is loaded here;
    the minirdr loads the RDBSS itself.

    As a stopgap measure the old redirector is loaded in the event of any problem
    associated with loading the new redirector.

--*/
{
    NET_API_STATUS  status;

    status = WsTryToLoadSmbMiniRedirector();
    if ((status != ERROR_SUCCESS) &&
        (status != ERROR_SERVICE_ALREADY_RUNNING)) {
       // Either the new redirector load did not succeed or it does not exist.
       // Load the old redirector.

       LoadedMRxSmbInsteadOfRdr = FALSE;
       status = WsLoadDriver(REDIRECTOR);
    }

    return(status);
}

VOID
WsUnloadRedirector(
    VOID
    )
/*++

Routine Description:

    This routine unloads the drivers that we loaded above.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NET_API_STATUS  status;
    DWORD NameLength,NameOffset;
    HKEY            hRedirectorKey;
    DWORD           FinalStatus;

    if (!LoadedMRxSmbInsteadOfRdr) {
        WsUnloadDriver(REDIRECTOR);
        return;
    }

    status = WsUnloadDriver(SMB_MINIRDR);

    if (status == ERROR_SUCCESS) {
        WsUnloadDriver(RDBSS);
    }

    status = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     MRXSMB_REGISTRY_KEY,
                     0,
                     KEY_ALL_ACCESS,
                     &hRedirectorKey);

    if (status == ERROR_SUCCESS) {
        // if the unloading was successful, reset the LastLoadStatus so that
        // the new redirector will be loaded on the next attempt as well.
        FinalStatus = ERROR_SUCCESS;
        status = RegSetValueEx(
                            hRedirectorKey,
                            LAST_LOAD_STATUS,
                            0,
                            REG_DWORD,
                            (PCHAR)&FinalStatus,
                            sizeof(DWORD));

        if (status == ERROR_SUCCESS) {
            NetpKdPrint((PREFIX_WKSTA "New RDR will be loaded on restart\n"));
        }

        RegCloseKey(hRedirectorKey);
    }

    return;
}

////////////////////// minirdr stuff
NET_API_STATUS
WsTryToLoadSmbMiniRedirector(
    VOID
    )
/*++

Routine Description:

    This routine loads rdr.sys or mrxsmb.sys et al depending on whether
    the conditions for loading mrxsmb.sys are met.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

Notes:

    The new redirector consists of two parts -- the RDBSS (redirected drive buffering
    subsystem ) and the corresponding smb mini redirectors. Only the minirdr is loaded here;
    the minirdr loads the RDBSS itself.

    As a stopgap measure the old redirector is loaded in the event of any problem
    associated with loading the new redirector.

--*/
{
    NET_API_STATUS  status;
    ULONG           Attributes;
    DWORD           ValueType;
    DWORD           ValueSize;
    DWORD           NameLength,NameOffset;
    HKEY            hRedirectorKey;

    DWORD FinalStatus;      // Temporary till the new rdr is the default
    DWORD LastLoadStatus;

    //try to open the minirdr's registry key....if fails GET OUT IMMEDIATELY!!!!
    status = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     MRXSMB_REGISTRY_KEY,
                     0,
                     KEY_ALL_ACCESS,
                     &hRedirectorKey);

    if (status != ERROR_SUCCESS) {
        return(status);
    } else {
        status = WsLoadDriver(RDBSS);

        if ((status == ERROR_SUCCESS) ||  (status == ERROR_SERVICE_ALREADY_RUNNING)) {

            status = WsLoadDriver(SMB_MINIRDR);

            if (status == ERROR_SUCCESS) {
                LoadedMRxSmbInsteadOfRdr = TRUE;
            } else if (status == ERROR_SERVICE_ALREADY_RUNNING) {
                NetpKdPrint((PREFIX_WKSTA "Reactivating Previously Loaded Service\n"));
                LoadedMRxSmbInsteadOfRdr = TRUE;
                status = ERROR_SUCCESS;
            } else {
                // error loading the minirdr
                //WsUnloadDriver(RDBSS);
                NetpKdPrint((PREFIX_WKSTA "Error Loading MRxSmb\n"));
            }
        }
//        NetpKdPrint((PREFIX_WKSTA "New redirector(RDR2) load status %lx\n",status));
    }

    // Close the handle to the registry key irrespective of the result.
    RegCloseKey(hRedirectorKey);

    return(status);
}

NET_API_STATUS
WsCSCReportStartRedir(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

Notes:

--*/
{
    NET_API_STATUS  status = ERROR_SUCCESS;
    DWORD   dwError = ERROR_GEN_FAILURE;


//    NetpKdPrint(("Wkssvc: Reporting redir start \n"));

    // ensure that there are named autoreset events
    if (!heventWkssvcToAgentStart)
    {
        NetpAssert(!heventAgentToWkssvc);

        heventWkssvcToAgentStart = CreateNamedEvent(wszWkssvcToAgentStartEvent);

        if (!heventWkssvcToAgentStart)
        {
            dwError = GetLastError();
            NetpKdPrint(("Wkssvc: Failed to create heventWkssvcToAgentStart, error = %d\n", dwError));
            goto bailout;
        }

        heventWkssvcToAgentStop = CreateNamedEvent(wszWkssvcToAgentStopEvent);

        if (!heventWkssvcToAgentStop)
        {
            dwError = GetLastError();
            NetpKdPrint(("Wkssvc: Failed to create heventWkssvcToAgentStop, error = %d\n", dwError));
            goto bailout;
        }

        heventAgentToWkssvc = CreateNamedEvent(wszAgentToWkssvcEvent);

        if (!heventAgentToWkssvc)
        {
            dwError = GetLastError();
            NetpKdPrint(("Wkssvc: Failed to create heventAgentToWkssvc, error = %d\n", dwError));
            goto bailout;
        }
    }

//    NetpAssert(!vfRedirStarted);

    if (!vfRedirStarted)
    {
        SetEvent(heventWkssvcToAgentStart);

        vfRedirStarted = TRUE;

//        NetpKdPrint(("Wkssvc: Reported redir start \n"));
    }

    dwError = ERROR_SUCCESS;

bailout:
    if (dwError != ERROR_SUCCESS)
    {
        if (heventWkssvcToAgentStart)
        {
            CloseHandle(heventWkssvcToAgentStart);
            heventWkssvcToAgentStart = NULL;
        }

        if (heventWkssvcToAgentStop)
        {
            CloseHandle(heventWkssvcToAgentStop);
            heventWkssvcToAgentStop = NULL;
        }

        if (heventAgentToWkssvc)
        {
            CloseHandle(heventAgentToWkssvc);
            heventAgentToWkssvc = NULL;
        }

        NetpKdPrint(("Wkssvc: Failed to report redir start error code=%d\n", dwError));
    }

    return (dwError);
}

NET_API_STATUS
WsCSCWantToStopRedir(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

Notes:

--*/
{
    NET_API_STATUS  status = ERROR_SUCCESS;
    DWORD   dwError;

//    NetpKdPrint(("Wkssvc: Asking agent to stop, so the redir can be stopped\n"));

    if (!vfRedirStarted)
    {
        NetpKdPrint(("Wkssvc: getting a stop without a start\n"));
        return ERROR_GEN_FAILURE;

    }

    if (!heventWkssvcToAgentStop)
    {
        NetpAssert(!heventWkssvcToAgentStart && !heventAgentToWkssvc);

        NetpKdPrint(("Wkssvc: Need events for redir stop\n"));
        return ERROR_GEN_FAILURE;
    }

    // Bleed the event
    WaitForSingleObject(heventAgentToWkssvc, 0);

    if (!AgentIsAlive())
    {
        // the agent isn't up
        // no need to issue stop
        NetpKdPrint(("Wkssvc: Agent not alive\n"));
    }
    else
    {
//        NetpKdPrint(("Wkssvc: Agent Alive\n"));

        // agent is up

        // tell him to stop
        SetEvent(heventWkssvcToAgentStop);

        // Wait some reasonable time to see if he stops
        dwError = WaitForSingleObject(heventAgentToWkssvc, CSC_WAIT_TIME);

        if (dwError!=WAIT_OBJECT_0)
        {
            HANDLE  hT[2];

            NetpKdPrint(("Wkssvc: Agent didn't disbale CSC in %d milli-seconds\n", CSC_WAIT_TIME));

            // let us try to reset our event in a way that we don't just miss the agent
            hT[0] = heventWkssvcToAgentStop;
            hT[1] = heventAgentToWkssvc;

            dwError = WaitForMultipleObjects(2, hT, FALSE, 0);

            // if we fired because of 1, then the agent gave us an ack
            // otherwise the stop event would be reset and the agent won't get confused

            if (dwError == WAIT_OBJECT_0+1)
            {
//                NetpKdPrint(("Wkssvc: Agent disabled CSC\n"));
                vfRedirStarted = FALSE;
            }

            ResetEvent(heventWkssvcToAgentStop);

        }
        else
        {
//            NetpKdPrint(("Wkssvc: Agent disabled CSC\n"));
            vfRedirStarted = FALSE;
        }
    }

    return status;
}

HANDLE
CreateNamedEvent(
    LPWSTR  lpwEventName
    )
/*++

Routine Description:

Arguments:

    lpwEventName    Name of the event to create.

Return Value:


Notes:


--*/
{
    HANDLE hevent = NULL;

    hevent = CreateEvent(NULL, FALSE, FALSE, lpwEventName);

    return hevent;
}

BOOL
AgentIsAlive(
     VOID
     )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    TRUE if agent is alive, FALSE otherwise

Notes:

    The named event is created by the agent thread when it comes up.

--*/
{
    HANDLE    hT;
    BOOL    fRet = FALSE;

    // see whether the agent has already created the event
    hT = OpenEvent(SYNCHRONIZE, FALSE, wzAgentExistsEvent);

    if (hT != NULL)
    {
        CloseHandle(hT);
        fRet = TRUE;
    }
    else
    {
        NetpKdPrint(("Wkssvc: Agent error = %d\n", GetLastError()));
    }
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsdevice.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsdevice.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to call into the NT Redirector and the NT Datagram Receiver.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _WSDEVICE_INCLUDED_
#define _WSDEVICE_INCLUDED_

#include <ntddnfs.h>                  // Redirector include file

#include <ntddbrow.h>                 // Datagram receiver include file

//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef enum _DDTYPE {
    Redirector,
    DatagramReceiver
} DDTYPE, *PDDTYPE;


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes of support routines found in wsdevice.c       //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
WsDeviceControlGetInfo(
    IN  DDTYPE DeviceDriverType,
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPBYTE *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsInitializeRedirector(
    VOID
    );

NET_API_STATUS
WsShutdownRedirector(
    VOID
    );

NET_API_STATUS
WsRedirFsControl (
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PLMR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsBindTransport(
    IN  LPTSTR TransportName,
    IN  DWORD QualityOfService,
    OUT LPDWORD ErrorParameter OPTIONAL
    );

NET_API_STATUS
WsUnbindTransport(
    IN LPTSTR TransportName,
    IN DWORD ForceLevel
    );

NET_API_STATUS
WsDeleteDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpLength,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    );

NET_API_STATUS
WsAddDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpLength,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    );

NET_API_STATUS
WsUnloadDriver(
    IN LPTSTR DriverNameString
    );

NET_API_STATUS
WsLoadDriver(
    IN LPWSTR DriverNameString
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

// Global Registry key definitions for the new Redirector

#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

#define SMB_MINIRDR L"MRxSmb"
#define RDBSS       L"Rdbss"

// the key definition is relative to HKEY_LOCAL_MACHINE
#define MRXSMB_REGISTRY_KEY   L"System\\CurrentControlSet\\Services\\MRxSmb"
#define LAST_LOAD_STATUS      L"LastLoadStatus"

#define REDIRECTOR   L"RDR"

//
// Handle to the Redirector FSD
//
extern HANDLE WsRedirDeviceHandle;

//
// This variable is used to remember whether we loaded rdr.sys or mrxsmb.sys
// and to act accordingly. at this stage, we only load mrxsmb.sys when certain
// conditions are met.
//
extern BOOLEAN LoadedMRxSmbInsteadOfRdr;


extern NET_API_STATUS
WsLoadRedirector(
    VOID
    );

extern VOID
WsUnloadRedirector(
    VOID
    );

extern NET_API_STATUS
WsCSCReportStartRedir(
    VOID
    );

extern NET_API_STATUS
WsCSCWantToStopRedir(
    VOID
    );


//
// Handle to the Datagram Receiver DD
//
extern HANDLE WsDgReceiverDeviceHandle;

#endif   // ifndef _WSDEVICE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wslogon.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    wslogon.c

Abstract:

    This module provides the Workstation service logon support, which
    include sending logoff message for users on the local machine that
    got reset unexpectedly, respond to a relogon request, and respond
    to an interrogation request.

Author:

    Rita Wong (ritaw)  20-Aug-1991

Environment:

    User Mode - Win32

Revision History:
    terryk  10-18-1993  Removed WsInitializeLogon stuff

--*/

#include <stdlib.h>                    // C Runtime: rand()

#include "wsutil.h"
#include "wsdevice.h"
#include "wsconfig.h"
#include "wslsa.h"

#include <netlogon.h>                  // Mailslot message definitions
#include <logonp.h>                    // NetpLogon routines

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


NET_API_STATUS NET_API_FUNCTION
I_NetrLogonDomainNameAdd(
    IN LPTSTR LogonDomainName
    )
/*++

Routine Description:

    This function asks the Datagram Receiver to add the specified
    logon domain for the current user.

Arguments:

    LogonDomainName - Supplies the name of the logon domain to add.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    // terryk added this on 10-15-1993
    // WsInitialLogon is never be called and So WsLogonDomainMutex is
    // never initialize properly.
    return ERROR_NOT_SUPPORTED;
}


NET_API_STATUS NET_API_FUNCTION
I_NetrLogonDomainNameDel(
    IN LPTSTR LogonDomainName
    )
/*++

Routine Description:

    This function asks the Datagram Receiver to delete the specified
    logon domain for the current user.

Arguments:

    LogonDomainName - Supplies the name of the logon domain to
        delete.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    // terryk added this on 10-15-1993
    // WsInitialLogon is never be called and So WsLogonDomainMutex is
    // never initialize properly.
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wslsa.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wswksta.h

Abstract:

    Private header file to be included by Workstation service modules
    need information from the LSA authentication package.

Author:

    Rita Wong (ritaw) 15-May-1991

Revision History:

--*/

#ifndef _WSLSA_INCLUDED_
#define _WSLSA_INCLUDED_

#include <ntmsv1_0.h>

NET_API_STATUS
WsInitializeLsa(
    VOID
    );

VOID
WsShutdownLsa(
    VOID
    );

NET_API_STATUS
WsLsaEnumUsers(
    OUT LPBYTE *EnumUsersResponse
    );

NET_API_STATUS
WsLsaGetUserInfo(
    IN  PLUID LogonId,
    OUT LPBYTE *UserInfoResponse,
    OUT LPDWORD UserInfoResponseLength
    );

NET_API_STATUS
WsLsaRelogonUsers(
    IN LPTSTR LogonServer
    );

// The following variable is used to restrict access to information exposed
// by the LSA. The value is set based upon the following registry key
//
// HKLM\System\CurrentControlSet\Control\Lsa\RestrictAnonymous
//
// If this key is defined and has a value greater than zero then the variable
// WsLsaRestrictAnonymous is set to the value in the registry, otherwise
// the value is zero. This is done in WsInitializeLsa

extern DWORD WsLsaRestrictAnonymous;

#endif // _WSLSA_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wslsa.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wslsa.c

Abstract:

    This module contains the interfaces to the Local Security Authority
    MS V 1.0 authentication package.

Author:

    Rita Wong (ritaw) 15-May-1991

Revision History:

--*/


#include "wsutil.h"
#include "wslsa.h"
#include "winreg.h"

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

STATIC HANDLE LsaHandle = NULL;
STATIC ULONG AuthPackageId = 0;

#define FULL_LSA_CONTROL_REGISTRY_PATH L"SYSTEM\\CurrentControlSet\\Control\\Lsa"
#define LSA_RESTRICT_ANONYMOUS_VALUE_NAME L"RestrictAnonymous"

DWORD WsLsaRestrictAnonymous = 0;


NET_API_STATUS
WsInitializeLsa(
    VOID
    )
/*++

Routine Description:

    This function registers the Workstation service as a logon process and
    gets a handle to the MS V1.0 authentication package.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failing.

--*/
{

    NTSTATUS ntstatus;

    STRING InputString;
    LSA_OPERATIONAL_MODE SecurityMode = 0;

    //
    // Register the Workstation service as a logon process
    //
    RtlInitString(&InputString, "LAN Manager Workstation Service");

    ntstatus = LsaRegisterLogonProcess(
                   &InputString,
                   &LsaHandle,
                   &SecurityMode
                   );

    IF_DEBUG(INFO) {
        NetpKdPrint(("[Wksta] LsaRegisterLogonProcess returns x%08lx, "
                     "SecurityMode=x%08lx\n", ntstatus, SecurityMode));
    }

    if (! NT_SUCCESS(ntstatus)) {
        return WsMapStatus(ntstatus);
    }


    //
    // Look up the MS V1.0 authentication package
    //
    RtlInitString(&InputString,
                  "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");

    ntstatus = LsaLookupAuthenticationPackage(
                   LsaHandle,
                   &InputString,
                   &AuthPackageId
                   );


    if (! NT_SUCCESS(ntstatus)) {

        IF_DEBUG(INFO) {
            NetpKdPrint(("[Wksta] LsaLookupAuthenticationPackage returns x%08lx, "
                         "AuthPackageId=%lu\n", ntstatus, AuthPackageId));
        }

    }

    WsLsaRestrictAnonymous = 0;

    if (NT_SUCCESS(ntstatus)) {
        HKEY  handle;
        DWORD error;

        error = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    FULL_LSA_CONTROL_REGISTRY_PATH,
                    0,
                    KEY_READ,
                    &handle
                    );

        if( error == ERROR_SUCCESS ) {
            DWORD type;
            DWORD size = sizeof( WsLsaRestrictAnonymous );

            error = RegQueryValueEx(
                        handle,
                        LSA_RESTRICT_ANONYMOUS_VALUE_NAME,
                        NULL,
                        &type,
                        (LPBYTE)&WsLsaRestrictAnonymous,
                        &size);

            if ((error != ERROR_SUCCESS) ||
                (type != REG_DWORD) ||
                (size != sizeof(DWORD))) {
                WsLsaRestrictAnonymous = 0;
            }

            RegCloseKey(handle);
        }
    }

    return WsMapStatus(ntstatus);
}


VOID
WsShutdownLsa(
    VOID
    )
/*++

Routine Description:

    This function deregisters the Workstation service as a logon process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (void) LsaDeregisterLogonProcess(
               LsaHandle
               );
}


NET_API_STATUS
WsLsaEnumUsers(
    OUT LPBYTE *EnumUsersResponse
    )
/*++

Routine Description:

    This function asks the MS V1.0 Authentication Package to list all users
    who are physically logged on to the local computer.

Arguments:

    EnumUsersResponse - Returns a pointer to a list of user logon ids.  This
        memory is allocated by the authentication package and must be freed
        with LsaFreeReturnBuffer when done with it.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    MSV1_0_ENUMUSERS_REQUEST EnumUsersRequest;
    ULONG EnumUsersResponseLength;


    //
    // Ask authentication package to enumerate users who are physically
    // logged to the local machine.
    //
    EnumUsersRequest.MessageType = MsV1_0EnumerateUsers;

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &EnumUsersRequest,
                   sizeof(MSV1_0_ENUMUSERS_REQUEST),
                   (PVOID *)EnumUsersResponse,
                   &EnumUsersResponseLength,
                   &AuthPackageStatus
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = AuthPackageStatus;
    }

    if (ntstatus != STATUS_SUCCESS) {
        return WsMapStatus(ntstatus);
    }

    return(NERR_Success);
}


NET_API_STATUS
WsLsaGetUserInfo(
    IN  PLUID LogonId,
    OUT LPBYTE *UserInfoResponse,
    OUT LPDWORD UserInfoResponseLength
    )
/*++

Routine Description:

    This function asks the MS V1.0 Authentication Package for information on
    a specific user.

Arguments:

    LogonId - Supplies the logon id of the user we want information about.

    UserInfoResponse - Returns a pointer to a structure of information about
        the user.  This memory is allocated by the authentication package
        and must be freed with LsaFreeReturnBuffer when done with it.

    UserInfoResponseLength - Returns the length of the returned information
        in number of bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    MSV1_0_GETUSERINFO_REQUEST UserInfoRequest;


    //
    // Ask authentication package for user information.
    //
    UserInfoRequest.MessageType = MsV1_0GetUserInfo;
    RtlCopyLuid(&UserInfoRequest.LogonId, LogonId);

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &UserInfoRequest,
                   sizeof(MSV1_0_GETUSERINFO_REQUEST),
                   (PVOID *)UserInfoResponse,
                   UserInfoResponseLength,
                   &AuthPackageStatus
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = AuthPackageStatus;
    }

    if (ntstatus != STATUS_SUCCESS) {
        return WsMapStatus(ntstatus);
    }

    return(NERR_Success);
}


NET_API_STATUS
WsLsaRelogonUsers(
    IN LPTSTR LogonServer
    )
/*++

Routine Description:

    This function asks the MS V1.0 Authentication Package to relogon users
    that are logged on by the specified logon server.  This is because the
    server had been reset and need to restore the database of users logged
    on by it before it went down.

Arguments:

    LogonServer - Name of logon server which requests that all its previously
        logged on users be relogged on.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    NTSTATUS AuthPackageStatus;

    OEM_STRING AnsiLogonServerName;

    PMSV1_0_RELOGON_REQUEST RelogonUsersRequest;
    ULONG RelogonUsersRequestLength = sizeof(MSV1_0_RELOGON_REQUEST) +
                                 (STRLEN(LogonServer) + 1) * sizeof(WCHAR);

    //
    // NTRAID-70701-2/6/2000 davey Since we cannot yet use optional parameters in call to
    // LsaCallAuthentication package, provide these variables for now.
    //
    PVOID RelogonUsersResponse;
    ULONG ResponseLength;


    //
    // Allocate the relogon request package dynamically because the logon
    // server name length is dynamic
    //
    if ((RelogonUsersRequest = (PMSV1_0_RELOGON_REQUEST)
                               LocalAlloc(
                                   LMEM_ZEROINIT,
                                   (UINT) RelogonUsersRequestLength
                                   )) == NULL) {
        return GetLastError();
    }

    RelogonUsersRequest->LogonServer.Buffer = (LPWSTR)
                                              ((DWORD_PTR) RelogonUsersRequest) +
                                                sizeof(MSV1_0_RELOGON_REQUEST);

    RtlInitUnicodeString(&RelogonUsersRequest->LogonServer, LogonServer);

    //
    // Ask authentication package to relogon users for the specified
    // logon server.
    //
    RelogonUsersRequest->MessageType = MsV1_0ReLogonUsers;

    ntstatus = LsaCallAuthenticationPackage(
                   LsaHandle,
                   AuthPackageId,
                   &RelogonUsersRequest,
                   RelogonUsersRequestLength,
                   &RelogonUsersResponse,  // should be NULL if OPTIONAL
                   &ResponseLength,        // should be NULL if OPTIONAL
                   &AuthPackageStatus
                   );

    //
    // Free memory allocated for request package
    //
    (void) LocalFree(RelogonUsersRequest);

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = AuthPackageStatus;
    }

    if (ntstatus != STATUS_SUCCESS) {
        return WsMapStatus(ntstatus);
    }

    return(NERR_Success);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsmsg.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsmsg.h

Abstract:

    Private header file to be included by Workstation service modules that
    implement the NetMessageBufferSend API.

Author:

    Rita Wong (ritaw) 25-July-1991

Revision History:

--*/

#ifndef _WSMSG_INCLUDED_
#define _WSMSG_INCLUDED_

#include <lmmsg.h>                     // LAN Man Message API definitions
#include <nb30.h>                      // NetBIOS 3.0 definitions

#include <smbtypes.h>                  // Type definitions needed by smb.h
#include <smb.h>                       // SMB structures

#include <msgrutil.h>                  // Netlib helpers for message send

#define MAX_GROUP_MESSAGE_SIZE         128
#define WS_SMB_BUFFER_SIZE             200

#define MESSENGER_MAILSLOT_W           L"\\MAILSLOT\\MESSNGR"

typedef struct _WSNETWORKS {
    LANA_ENUM LanAdapterNumbers;
    UCHAR ComputerNameNumbers[MAX_LANA];
} WSNETWORKS, *PWSNETWORKS;

extern WSNETWORKS WsNetworkInfo;

NET_API_STATUS
WsInitializeMessageSend(
    BOOLEAN FirstTime
    );

VOID
WsShutdownMessageSend(
    VOID
    );

NET_API_STATUS
WsBroadcastMessage(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR ComputerNameNumber,
    IN  LPBYTE Message,
    IN  WORD MessageSize,
    IN  LPTSTR Sender
    );

NET_API_STATUS
WsSendToGroup(
    IN  LPTSTR DomainName,
    IN  LPTSTR FromName,
    IN  LPBYTE Message,
    IN  WORD MessageSize
    );

NET_API_STATUS
WsSendMultiBlockBegin(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  LPTSTR ToName,
    IN  LPTSTR FromName,
    OUT short *MessageId
    );

NET_API_STATUS
WsSendMultiBlockEnd(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  short MessageId
    );

NET_API_STATUS
WsSendMultiBlockText(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  PCHAR TextBuffer,
    IN  WORD TextBufferSize,
    IN  short MessageId
    );

NET_API_STATUS
WsSendSingleBlockMessage(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  LPTSTR ToName,
    IN  LPTSTR FromName,
    IN  PCHAR TextBuffer,
    IN  WORD TextBufferSize
    );

WORD
WsMakeSmb(
    OUT PUCHAR SmbBuffer,                  // Buffer to build SMB in
    IN  UCHAR SmdFunctionCode,             // SMB function code
    IN  WORD NumberOfParameters,           // Number of parameters
    IN  PCHAR FieldsDopeVector,            // Fields dope vector
    ...
    );

#endif // ifndef _WSMSG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsmain.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wsmain.c

Abstract:

    This is the main routine for the NT LAN Manager Workstation service.

Author:

    Rita Wong (ritaw)  06-May-1991

Environment:

    User Mode - Win32

Revision History:

    15-May-1992 JohnRo
        Implement registry watch.
    11-Jun-1992 JohnRo
        Ifdef-out winreg notify stuff until we can fix logoff problem.
        Added assertion checks on registry watch stuff.
    18-Oct-1993 terryk
        Removed WsInitializeLogon stuff
    20-Oct-1993 terryk
        Remove WsInitializeMessage stuff

--*/


#include "wsutil.h"            // Common routines and data
#include "wssec.h"             // WkstaObjects create & destroy
#include "wsdevice.h"          // Device init & shutdown
#include "wsuse.h"             // UseStructures create & destroy
#include "wsconfig.h"          // Configuration loading
#include "wslsa.h"             // Lsa initialization
#include "wsmsg.h"             // Message send initialization
#include "wswksta.h"           // WsUpdateRedirToMatchWksta
#include "wsmain.h"            // Service related global definitions
#include "wsdfs.h"             // Dfs related routines

#include <lmserver.h>          // SV_TYPE_WORKSTATION
#include <srvann.h>            // I_ScSetServiceBits
#include <configp.h>           // Need NET_CONFIG_HANDLE typedef
#include <confname.h>          // NetpAllocConfigName().
#include <prefix.h>            // PREFIX_ equates.


//-------------------------------------------------------------------//
//                                                                   //
// Structures
//                                                                   //
//-------------------------------------------------------------------//
typedef struct _REG_NOTIFY_INFO {
    HANDLE  NotifyEventHandle;
    DWORD   Timeout;
    HANDLE  WorkItemHandle;
    HANDLE  RegistryHandle;
} REG_NOTIFY_INFO, *PREG_NOTIFY_INFO, *LPREG_NOTIFY_INFO;

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

    WS_GLOBAL_DATA      WsGlobalData;

    PSVCHOST_GLOBAL_DATA   WsLmsvcsGlobalData;

    REG_NOTIFY_INFO     RegNotifyInfo = {0};

    HANDLE              TerminateWorkItem = NULL;

    CRITICAL_SECTION    WsWorkerCriticalSection;

    BOOL                WsIsTerminating=FALSE;
    BOOL                WsLUIDDeviceMapsEnabled=FALSE;
    DWORD               WsNumWorkerThreads=0;

// Used by the termination routine:

    BOOL    ConfigHandleOpened = FALSE;
	BOOL 	WsWorkerCriticalSectionInitialized = FALSE;
    HKEY    ConfigHandle;
    HANDLE  RegistryChangeEvent = NULL;
    LPTSTR  RegPathToWatch = NULL;
    DWORD   WsInitState = 0;
	
	// Stores the status with which WsInitializeWorkstation failed, so that it can later
	// be passed to WsShutdownWorkstation
	NET_API_STATUS WsInitializeStatusError = NERR_Success;


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes                                               //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsInitializeWorkstation(
    OUT LPDWORD WsInitState
    );

STATIC
VOID
WsShutdownWorkstation(
    IN NET_API_STATUS ErrorCode,
    IN DWORD WsInitState
    );

STATIC
NET_API_STATUS
WsCreateApiStructures(
    IN OUT LPDWORD WsInitState
    );

STATIC
VOID
WsDestroyApiStructures(
    IN DWORD WsInitState
    );

VOID
WkstaControlHandler(
    IN DWORD Opcode
    );

BOOL
WsReInitChangeNotify(
    PREG_NOTIFY_INFO    pNotifyInfo
    );

DWORD
WsRegistryNotify(
    LPVOID   pParms,
    BOOLEAN  fWaitStatus
    );

VOID
WsTerminationNotify(
    LPVOID  pParms,
    BOOLEAN fWaitStatus
    );


STATIC
BOOL
WsGetLUIDDeviceMapsEnabled(
    VOID
    );


RPC_STATUS WsRpcSecurityCallback(
    IN RPC_IF_HANDLE *Interface,
    IN void *Context
	);

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    WsLmsvcsGlobalData = pGlobals;
}


VOID
ServiceMain(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )
/*++

Routine Description:

    This is the main routine of the Workstation Service which registers
    itself as an RPC server and notifies the Service Controller of the
    Workstation service control entry point.

    After the workstation is started, this thread is used (since it's
    otherwise unused) to watch for changes to the registry.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored by the
        Workstation service.

Return Value:

    None.

--*/
{

    NET_API_STATUS ApiStatus;

    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    //
    // Make sure svchost.exe gave us the global data
    //
    ASSERT(WsLmsvcsGlobalData != NULL);

    WsInitState = 0;
	WsIsTerminating=FALSE;
    WsLUIDDeviceMapsEnabled=FALSE;
	WsWorkerCriticalSectionInitialized = FALSE;
    RegNotifyInfo.NotifyEventHandle = NULL;
    RegNotifyInfo.Timeout = 0;
    RegNotifyInfo.WorkItemHandle = NULL;
    RegNotifyInfo.RegistryHandle = NULL;

    //
    // Initialize the workstation.
    //
    if ((ApiStatus = WsInitializeWorkstation(&WsInitState)) != NERR_Success) {
        DbgPrint("WKSSVC failed to initialize workstation %x\n",WsInitState);
        goto Cleanup;
    }

    //
    // Set up to wait for registry change or terminate event.
    //
    ApiStatus = NetpAllocConfigName(
                    SERVICES_ACTIVE_DATABASE,
                    SERVICE_WORKSTATION,
                    NULL,                     // default area ("Parameters")
                    &RegPathToWatch
                    );

    if (ApiStatus != NERR_Success) {
        goto Cleanup;
    }

    NetpAssert(RegPathToWatch != NULL && *RegPathToWatch != TCHAR_EOS);

    ApiStatus = (NET_API_STATUS) RegOpenKeyEx(
                                     HKEY_LOCAL_MACHINE,    // hKey
                                     RegPathToWatch,        // lpSubKey
                                     0L,                    // ulOptions (reserved)
                                     KEY_READ | KEY_NOTIFY, // desired access
                                     &ConfigHandle          // Newly Opened Key Handle
                                     );
    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    ConfigHandleOpened = TRUE;

    RegistryChangeEvent = CreateEvent(
                              NULL,      // no security descriptor
                              FALSE,     // use automatic reset
                              FALSE,     // initial state: not signalled
                              NULL       // no name
                              );

    if (RegistryChangeEvent == NULL) {
        ApiStatus = (NET_API_STATUS) GetLastError();
        goto Cleanup;
    }

    ApiStatus = RtlRegisterWait(
                   &TerminateWorkItem,             // work item handle
                   WsGlobalData.TerminateNowEvent, // wait handle
                   WsTerminationNotify,            // callback fcn
                   NULL,                           // parameter
                   INFINITE,                       // timeout
                   WT_EXECUTEONLYONCE |            // flags
                     WT_EXECUTELONGFUNCTION);

    if (!NT_SUCCESS(ApiStatus)) {
        ApiStatus = RtlNtStatusToDosError(ApiStatus);
        goto Cleanup;
    }

    //
    // Setup to monitor registry changes.
    //
    RegNotifyInfo.NotifyEventHandle = RegistryChangeEvent;
    RegNotifyInfo.Timeout = INFINITE;
    RegNotifyInfo.WorkItemHandle = NULL;
    RegNotifyInfo.RegistryHandle = ConfigHandle;


    EnterCriticalSection(&WsWorkerCriticalSection);

    if (!WsReInitChangeNotify(&RegNotifyInfo)) {
        ApiStatus = GetLastError();
        RtlDeregisterWait(TerminateWorkItem);
		TerminateWorkItem = NULL;
        LeaveCriticalSection(&WsWorkerCriticalSection);
        goto Cleanup;
    }

    LeaveCriticalSection(&WsWorkerCriticalSection);

    //
    // We are done with starting the Workstation service.  Tell Service
    // Controller our new status.
    //
    WsGlobalData.Status.dwCurrentState = SERVICE_RUNNING;
    WsGlobalData.Status.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                             SERVICE_ACCEPT_PAUSE_CONTINUE |
                                             SERVICE_ACCEPT_SHUTDOWN;
    WsGlobalData.Status.dwCheckPoint = 0;
    WsGlobalData.Status.dwWaitHint = 0;

    if ((ApiStatus = WsUpdateStatus()) != NERR_Success) {

		WsInitializeStatusError = ApiStatus;
        DbgPrint("WKSSVC failed with WsUpdateStatus %x\n",ApiStatus);
        goto Cleanup;
    }

    //
    // This thread has done all that it can do.  So we can return it
    // to the service controller.
    //
    return;

Cleanup:
    DbgPrint("WKSSVC ServiceMain returned with %x\n",ApiStatus);

    WsTerminationNotify(NULL, NO_ERROR);
    return;
}


BOOL
WsReInitChangeNotify(
    PREG_NOTIFY_INFO    pNotifyInfo
    )

/*++

Routine Description:


    NOTE:  This function should only be called when in the
        WsWorkerCriticalSection.

Arguments:


Return Value:



--*/
{
    BOOL     bStat = TRUE;
    NTSTATUS Status;

    Status = RegNotifyChangeKeyValue (ConfigHandle,
                                      TRUE,                  // watch a subtree
                                      REG_NOTIFY_CHANGE_LAST_SET,
                                      RegistryChangeEvent,
                                      TRUE                   // async call
                                      );

    if (!NT_SUCCESS(Status)) {
        NetpKdPrint((PREFIX_WKSTA "Couldn't Initialize Registry Notify %d\n",
                     RtlNtStatusToDosError(Status)));
        bStat = FALSE;
        goto CleanExit;
    }
    //
    // Add the work item that is to be called when the
    // RegistryChangeEvent is signalled.
    //
    Status = RtlRegisterWait(
                &pNotifyInfo->WorkItemHandle,
                pNotifyInfo->NotifyEventHandle,
                WsRegistryNotify,
                (PVOID)pNotifyInfo,
                pNotifyInfo->Timeout,
                WT_EXECUTEONLYONCE | WT_EXECUTEINPERSISTENTIOTHREAD);

    if (!NT_SUCCESS(Status)) {
        NetpKdPrint((PREFIX_WKSTA "Couldn't add Reg Notify work item\n"));
        bStat = FALSE;
    }

CleanExit:
    if (bStat) {
        if (WsNumWorkerThreads == 0) {
            WsNumWorkerThreads++;
        }
    }
    else {
        if (WsNumWorkerThreads == 1) {
            WsNumWorkerThreads--;
        }
    }

    return(bStat);

}

DWORD
WsRegistryNotify(
    LPVOID   pParms,
    BOOLEAN  fWaitStatus
    )

/*++

Routine Description:

    Handles Workstation Registry Notification.  This function is called by a
    thread pool Worker thread when the event used for registry notification is
    signaled.

Arguments:


Return Value:


--*/
{
    NET_API_STATUS      ApiStatus;
    PREG_NOTIFY_INFO    pNotifyinfo=(PREG_NOTIFY_INFO)pParms;
    NET_CONFIG_HANDLE   NetConfigHandle;

    UNREFERENCED_PARAMETER(fWaitStatus);

    //
    // The NT thread pool requires explicit work item deregistration,
    // even if we specified the WT_EXECUTEONLYONCE flag
    //
    RtlDeregisterWait(pNotifyinfo->WorkItemHandle);

    EnterCriticalSection(&WsWorkerCriticalSection);
    if (WsIsTerminating) {
        WsNumWorkerThreads--;
        SetEvent(WsGlobalData.TerminateNowEvent);

        LeaveCriticalSection(&WsWorkerCriticalSection);
        return(NO_ERROR);
    }

    //
    // Serialize write access to config information
    //
    if (RtlAcquireResourceExclusive(&WsInfo.ConfigResource, TRUE)) {

        //
        // Update the redir fields based on change notify.
        // WsUpdateWkstaToMatchRegistry expects a NET_CONFIG_HANDLE
        // handle, so we conjure up one from the HKEY handle.
        //
        NetConfigHandle.WinRegKey = ConfigHandle;

        WsUpdateWkstaToMatchRegistry(&NetConfigHandle, FALSE);

        ApiStatus = WsUpdateRedirToMatchWksta(
                        PARMNUM_ALL,
                        NULL
                        );

//        NetpAssert( ApiStatus == NO_ERROR );

        RtlReleaseResource(&WsInfo.ConfigResource);
    }

    if (!WsReInitChangeNotify(&RegNotifyInfo)) {
        //
        // If we can't add the work item, then we just won't
        // listen for registry changes.  There's not a whole
        // lot we can do here.
        //
        ApiStatus = GetLastError();
    }

    LeaveCriticalSection(&WsWorkerCriticalSection);

    return(NO_ERROR);
}


VOID
WsTerminationNotify(
    LPVOID  pParms,
    BOOLEAN fWaitStatus
    )

/*++

Routine Description:

    This function gets called by a services worker thread when the
    termination event gets signaled.

Arguments:


Return Value:


--*/
{
    UNREFERENCED_PARAMETER(pParms);
    UNREFERENCED_PARAMETER(fWaitStatus);

    IF_DEBUG(MAIN) {
        NetpKdPrint((PREFIX_WKSTA "WORKSTATION_main: cleaning up, "
                "api status.\n"));
    }

    //
    // The NT thread pool requires explicit work item deregistration,
    // even if we specified the WT_EXECUTEONLYONCE flag
    //
    if (TerminateWorkItem != NULL) {
        RtlDeregisterWait(TerminateWorkItem);
		TerminateWorkItem = NULL;
    }

	if ( !WsWorkerCriticalSectionInitialized ) {
		// We try to initialize this at the very beginning.
		// So, if that failed, then nothing else has been done.
		// So, just exit.
		return;
	}

	EnterCriticalSection(&WsWorkerCriticalSection);
    WsIsTerminating = TRUE;

    //
    // Must close winreg handle (which turns off notify) before event handle.
    // Closing the regkey handle generates a change notify event!
    //
    if (ConfigHandleOpened) {
        (VOID) RegCloseKey(ConfigHandle);
		ConfigHandleOpened = FALSE;
#if DBG
        //
        // Workaround for a benign winreg assertion caused by us
        // closing the RegistryChangeEvent handle which it wants
        // to signal.
        //
        Sleep(2000);
#endif
    }
    if (RegPathToWatch != NULL) {
        (VOID) NetApiBufferFree(RegPathToWatch);
		RegPathToWatch = NULL;
    }
    if ((RegistryChangeEvent != NULL) && (WsNumWorkerThreads != 0)) {

        //
        // There is still a RegistryNotify Work Item in the system,  we
        // will attempt to remove it by setting the event to wake it up.
        //

        ResetEvent(WsGlobalData.TerminateNowEvent);

        LeaveCriticalSection(&WsWorkerCriticalSection);
        SetEvent(RegistryChangeEvent);
        //
        // Wait until the WsRegistryNotify Thread is finished.
        // We will give it 60 seconds.  If the thread isn't
        // finished in that time frame, we will go on anyway.
        //
        WaitForSingleObject(
                    WsGlobalData.TerminateNowEvent,
                    60000);

        if (WsNumWorkerThreads != 0) {
            NetpKdPrint((PREFIX_WKSTA "WsTerminationNotify: "
            "Registry Notification thread didn't terminate\n"));
        }

        EnterCriticalSection(&WsWorkerCriticalSection);
    }
	if ( RegistryChangeEvent != NULL ) {
		(VOID) CloseHandle(RegistryChangeEvent);
		RegistryChangeEvent = NULL;
	}

    //
    // Shutting down
    //
    // NOTE:  We must synchronize with the RegistryNotification Thread.
    //
    WsShutdownWorkstation(
        WsInitializeStatusError,
        WsInitState
        );

    WsIsTerminating = FALSE;

    LeaveCriticalSection(&WsWorkerCriticalSection);
    DeleteCriticalSection(&WsWorkerCriticalSection);
	WsWorkerCriticalSectionInitialized = FALSE;

    return;
}

STATIC
NET_API_STATUS
WsInitializeWorkstation(
    OUT LPDWORD WsInitState
    )
/*++

Routine Description:

    This function initializes the Workstation service.

Arguments:

    WsInitState - Returns a flag to indicate how far we got with initializing
        the Workstation service before an error occured.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
	RPC_STATUS rpcStatus;
	int i;

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    WsGlobalData.Status.dwServiceType = SERVICE_WIN32;
    WsGlobalData.Status.dwCurrentState = SERVICE_START_PENDING;
    WsGlobalData.Status.dwControlsAccepted = 0;
    WsGlobalData.Status.dwCheckPoint = 1;
    WsGlobalData.Status.dwWaitHint = WS_WAIT_HINT_TIME;

    SET_SERVICE_EXITCODE(
        NO_ERROR,
        WsGlobalData.Status.dwWin32ExitCode,
        WsGlobalData.Status.dwServiceSpecificExitCode
        );

    //
    // Initialize workstation to receive service requests by registering the
    // control handler.
    //
    if ((WsGlobalData.StatusHandle = RegisterServiceCtrlHandler(
                                         SERVICE_WORKSTATION,
                                         WkstaControlHandler
                                         )) == (SERVICE_STATUS_HANDLE) 0) {

        status = GetLastError();
		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with RegisterServiceCtrlHandler %x\n",status);
        return status;
    }

    //
    // Notify the Service Controller for the first time that we are alive
    // and we are start pending
    //
    if ((status = WsUpdateStatus()) != NERR_Success) {

		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsUpdateStatus %x\n",status);
        return status;
    }

    try {
        InitializeCriticalSection(&WsWorkerCriticalSection);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        
        status = ERROR_NOT_ENOUGH_MEMORY;
        return status;
    }
	WsWorkerCriticalSectionInitialized = TRUE;

    //
    // Initialize NetJoin logging
    //
    NetpInitializeLogFile();

    //
    // Initialize the resource for serializing access to configuration
    // information.
    //
    // This must be done before the redir is initialized

    try {
        RtlInitializeResource(&WsInfo.ConfigResource);
    } except(EXCEPTION_EXECUTE_HANDLER) {
          return RtlNtStatusToDosError(GetExceptionCode());
    }
    (*WsInitState) |= WS_CONFIG_RESOURCE_INITIALIZED;

    //
    // Create an event which is used by the service control handler to notify
    // the Workstation service that it is time to terminate.
    //
    if ((WsGlobalData.TerminateNowEvent =
             CreateEvent(
                 NULL,                // Event attributes
                 TRUE,                // Event must be manually reset
                 FALSE,
                 NULL                 // Initial state not signalled
                 )) == NULL) {

        status = GetLastError();
		WsInitializeStatusError = status;
        return status;
    }
    (*WsInitState) |= WS_TERMINATE_EVENT_CREATED;

    //
    // Initialize the workstation as a logon process with LSA, and
    // get the MS V 1.0 authentication package ID.
    //

    if ((status = WsInitializeLsa()) != NERR_Success) {

		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsInitializeLsa %x\n",status);
        return status;
    }

    (*WsInitState) |= WS_LSA_INITIALIZED;

    //
    // Read the configuration information to initialize the redirector and
    // datagram receiver
    //
    if ((status = WsInitializeRedirector()) != NERR_Success) {

		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsInitializeRedirector %x\n",status);
        return status;
    }
    (*WsInitState) |= WS_DEVICES_INITIALIZED;

    //
    // Service install still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (WsGlobalData.Status.dwCheckPoint)++;
    (void) WsUpdateStatus();

    //
    // Bind to transports
    //
    if ((status = WsBindToTransports()) != NERR_Success) {

		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsBindToTransports %x\n",status);
        return status;
    }

    //
    // Service install still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (WsGlobalData.Status.dwCheckPoint)++;
    (void) WsUpdateStatus();

    //
    // Add domain names.
    //
    if ((status = WsAddDomains()) != NERR_Success) {

		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsAddDomains %x\n",status);
        return status;
    }

    //
    // Service start still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (WsGlobalData.Status.dwCheckPoint)++;
    (void) WsUpdateStatus();

    //
    // Create Workstation service API data structures
    //
    if ((status = WsCreateApiStructures(WsInitState)) != NERR_Success) {

		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsCreateApiStructures %x\n",status);
        return status;
    }

    //
    // Initialize the workstation service to receive RPC requests
    //
    // NOTE:  Now all RPC servers in services.exe share the same pipe name.
    // However, in order to support communication with version 1.0 of WinNt,
    // it is necessary for the Client Pipe name to remain the same as
    // it was in version 1.0.  Mapping to the new name is performed in
    // the Named Pipe File System code.
    //

	//
	// Register with our protseq and the endpoint we expect to get called on
	//
	rpcStatus = RpcServerUseProtseqEpW(
			L"ncacn_np",
			RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
			L"\\PIPE\\wkssvc",
			NULL
			);
	//  duplicate endpoint is ok
	if ( rpcStatus == RPC_S_DUPLICATE_ENDPOINT ) {
		rpcStatus = RPC_S_OK;
	}
	
	//
	// Register our interface as an autolisten interface, and allow clients to call us,
	// even unauthenticated ones. We do the access check separately on a per function
	// basis when that function is called.
	// Some functions can be called by guest / anonymous
	//
	if (rpcStatus == RPC_S_OK) {
		rpcStatus = RpcServerRegisterIfEx(wkssvc_ServerIfHandle, 
										  NULL, 
										  NULL,
										  RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH ,
										  RPC_C_LISTEN_MAX_CALLS_DEFAULT,
										  WsRpcSecurityCallback
										  );
	}
	status = (rpcStatus == RPC_S_OK) ? NERR_Success : rpcStatus;
	if (status != NERR_Success ) {
		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with StartRpcServer %x\n",status);
        return status;
    }

    (*WsInitState) |= WS_RPC_SERVER_STARTED;



    //
    // Lastly, we create a thread to communicate with the
    // Dfs-enabled MUP driver.
    //

    if ((status = WsInitializeDfs()) != NERR_Success) {
		WsInitializeStatusError = status;
        DbgPrint("WKSSVC failed with WsInitializeDfs %x\n",status);
        return status;
    }

    (*WsInitState) |= WS_DFS_THREAD_STARTED;

    WsLUIDDeviceMapsEnabled = WsGetLUIDDeviceMapsEnabled();

    (void) I_ScSetServiceBits(
                WsGlobalData.StatusHandle,
                SV_TYPE_WORKSTATION,
                TRUE,
                TRUE,
                NULL
                );


    IF_DEBUG(MAIN) {
        NetpKdPrint(("[Wksta] Successful Initialization\n"));
    }

    return NERR_Success;
}



VOID
WsShutdownWorkstation(
    IN NET_API_STATUS ErrorCode,
    IN DWORD WsInitState
    )
/*++

Routine Description:

    This function shuts down the Workstation service.

Arguments:

    ErrorCode - Supplies the error code of the failure

    WsInitState - Supplies a flag to indicate how far we got with initializing
        the Workstation service before an error occured, thus the amount of
        clean up needed.

Return Value:

    None.

--*/
{
    NET_API_STATUS status = NERR_Success;


    //
    // Service stop still pending.  Update checkpoint counter and the
    // status with the Service Controller.
    //
    (WsGlobalData.Status.dwCheckPoint)++;
    (void) WsUpdateStatus();

    if (WsInitState & WS_DFS_THREAD_STARTED) {

        //
        // Stop the Dfs thread
        //
        WsShutdownDfs();
    }


    if (WsInitState & WS_RPC_SERVER_STARTED) {
        //
        // Stop the RPC server
        //
		status = RpcServerUnregisterIf( wkssvc_ServerIfHandle,
										NULL, 
										1
										);
		if ( status != NERR_Success ) {
			DbgPrint("WKSSVC failed to unregister rpc interface with status %x\n",status);
		}
    }

    if (WsInitState & WS_API_STRUCTURES_CREATED) {
        //
        // Destroy data structures created for Workstation APIs
        //
        WsDestroyApiStructures(WsInitState);
    }

    WsShutdownMessageSend();

    //
    // Don't need to ask redirector to unbind from its transports when
    // cleaning up because the redirector will tear down the bindings when
    // it stops.
    //

    if (WsInitState & WS_DEVICES_INITIALIZED) {
        //
        // Shut down the redirector and datagram receiver
        //
        status = WsShutdownRedirector();
    }

    //
    // Delete resource for serializing access to config information
    // This must be done only after the redir is shutdown
    // We do this here, (the Init is done in WsInitializeWorkstation routine above)
    // to avoid putting additional synchronization on delete
    // Otherwise we get into the situation where, the redir is shutting down and
    // it deletes the resource while someone has acquired it, causing bad things.
	//
	if ( WsInitState & WS_CONFIG_RESOURCE_INITIALIZED ) {
		RtlDeleteResource(&WsInfo.ConfigResource);
	}

    if (WsInitState & WS_LSA_INITIALIZED) {
        //
        // Deregister workstation as logon process
        //
        WsShutdownLsa();
    }

    if (WsInitState & WS_TERMINATE_EVENT_CREATED) {
        //
        // Close handle to termination event
        //
        CloseHandle(WsGlobalData.TerminateNowEvent);
    }

	//
	// Shut down NetJoin logging
	//
	NetpShutdownLogFile();

    I_ScSetServiceBits(
        WsGlobalData.StatusHandle,
        SV_TYPE_WORKSTATION,
        FALSE,
        TRUE,
        NULL
        );

    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //
    WsGlobalData.Status.dwCurrentState = SERVICE_STOPPED;
    WsGlobalData.Status.dwControlsAccepted = 0;


    if ((ErrorCode == NERR_Success) &&
        (status == ERROR_REDIRECTOR_HAS_OPEN_HANDLES)) {
        ErrorCode = status;
    }

    SET_SERVICE_EXITCODE(
        ErrorCode,
        WsGlobalData.Status.dwWin32ExitCode,
        WsGlobalData.Status.dwServiceSpecificExitCode
        );

    WsGlobalData.Status.dwCheckPoint = 0;
    WsGlobalData.Status.dwWaitHint = 0;

    (void) WsUpdateStatus();
    
}



NET_API_STATUS
WsUpdateStatus(
    VOID
    )
/*++

Routine Description:

    This function updates the Workstation service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;

    if (WsGlobalData.StatusHandle == (SERVICE_STATUS_HANDLE) 0) {
        NetpKdPrint((
            "[Wksta] Cannot call SetServiceStatus, no status handle.\n"
            ));

        return ERROR_INVALID_HANDLE;
    }

    if (! SetServiceStatus(WsGlobalData.StatusHandle, &WsGlobalData.Status)) {

        status = GetLastError();

        IF_DEBUG(MAIN) {
            NetpKdPrint(("[Wksta] SetServiceStatus error %lu\n", status));
        }
    }

    return status;
}



STATIC
NET_API_STATUS
WsCreateApiStructures(
    IN OUT LPDWORD WsInitState
    )
/*++

Routine Description:

    This function creates and initializes all the data structures required
    for the Workstation APIs.

Arguments:

    WsInitState - Returns the supplied flag of how far we got in the
        Workstation service initialization process.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;


    //
    // Create workstation security objects
    //
    if ((status = WsCreateWkstaObjects()) != NERR_Success) {
        return status;
    }
    (*WsInitState) |= WS_SECURITY_OBJECTS_CREATED;

    //
    // Create Use Table
    //
    if ((status = WsInitUseStructures()) != NERR_Success) {
        return status;
    }
    (*WsInitState) |= WS_USE_TABLE_CREATED;

    return NERR_Success;
}



STATIC
VOID
WsDestroyApiStructures(
    IN DWORD WsInitState
    )
/*++

Routine Description:

    This function destroys the data structures created for the Workstation
    APIs.

Arguments:

    WsInitState - Supplies a flag which tells us what API structures
        were created in the initialization process and now have to be
        cleaned up.

Return Value:

    None.

--*/
{
    if (WsInitState & WS_USE_TABLE_CREATED) {
        //
        // Destroy Use Table
        //
        WsDestroyUseStructures();
    }

    if (WsInitState & WS_SECURITY_OBJECTS_CREATED) {
        //
        // Destroy workstation security objects
        //
        WsDestroyWkstaObjects();
    }
}


VOID
WkstaControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Workstation service.

Arguments:

    Opcode - Supplies a value which specifies the action for the Workstation
        service to perform.

    Arg - Supplies a value which tells a service specifically what to do
        for an operation specified by Opcode.

Return Value:

    None.

--*/
{
    IF_DEBUG(MAIN) {
        NetpKdPrint(("[Wksta] In Control Handler\n"));
    }

    switch (Opcode) {

        case SERVICE_CONTROL_PAUSE:

            //
            // Pause redirection of print and comm devices
            //
            WsPauseOrContinueRedirection(
                PauseRedirection
                );

            break;

        case SERVICE_CONTROL_CONTINUE:

            //
            // Resume redirection of print and comm devices
            //
            WsPauseOrContinueRedirection(
                ContinueRedirection
                );

            break;

        case SERVICE_CONTROL_SHUTDOWN:

            //
            // Lack of break is intentional!
            //

        case SERVICE_CONTROL_STOP:

            if (WsGlobalData.Status.dwCurrentState != SERVICE_STOP_PENDING) {

                IF_DEBUG(MAIN) {
                    NetpKdPrint(("[Wksta] Stopping workstation...\n"));
                }

                WsGlobalData.Status.dwCurrentState = SERVICE_STOP_PENDING;
                WsGlobalData.Status.dwCheckPoint = 1;
                WsGlobalData.Status.dwWaitHint = WS_WAIT_HINT_TIME;

                //
                // Send the status response.
                //
                (void) WsUpdateStatus();

                if (! SetEvent(WsGlobalData.TerminateNowEvent)) {

                    //
                    // Problem with setting event to terminate Workstation
                    // service.
                    //
                    NetpKdPrint(("[Wksta] Error setting TerminateNowEvent "
                                 FORMAT_API_STATUS "\n", GetLastError()));
                    NetpAssert(FALSE);
                }

                return;
            }
            break;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        default:
            IF_DEBUG(MAIN) {
                NetpKdPrint(("Unknown workstation opcode " FORMAT_HEX_DWORD
                             "\n", Opcode));
            }
    }

    //
    // Send the status response.
    //
    (void) WsUpdateStatus();
}


STATIC
BOOL
WsGetLUIDDeviceMapsEnabled(
    VOID
    )

/*++

Routine Description:

    This function calls NtQueryInformationProcess() to determine if
    LUID device maps are enabled


Arguments:

    none

Return Value:

    TRUE - LUID device maps are enabled

    FALSE - LUID device maps are disabled

--*/

{

    NTSTATUS   Status;
    ULONG      LUIDDeviceMapsEnabled;
    BOOL       Result;

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        IF_DEBUG(MAIN) {
            NetpKdPrint(("[Wksta] NtQueryInformationProcess(WsLUIDDeviceMapsEnabled) failed "
                "FORMAT_API_STATUS" "\n",Status));
        }
        Result = FALSE;
    }
    else {
        Result = (LUIDDeviceMapsEnabled != 0);
    }

    return( Result );
}


RPC_STATUS WsRpcSecurityCallback(
    IN RPC_IF_HANDLE *Interface,
    IN void *Context
	)
/*++
Routine description:
	RPC security callback - called before any call is passed on to a function.
	Check the protseq to see whether the client is using the protseq we expect - named pipes.
	Lifted from NwRpcSecurityCallback
	
Return value:
	RPC_S_ACCESS_DENIED if the protseq doesnt match named pipes,
	RPC_S_OK otherwise.

--*/
{
    RPC_STATUS          Status;
    RPC_BINDING_HANDLE  ServerIfHandle;
    LPWSTR              binding = NULL;
    LPWSTR              protseq = NULL;

    Status = RpcBindingServerFromClient((RPC_IF_HANDLE)Context, &ServerIfHandle);
    if (Status != RPC_S_OK) 
    {
        return (RPC_S_ACCESS_DENIED);
    }
    Status = RpcBindingToStringBinding(ServerIfHandle, &binding);
    if (Status != RPC_S_OK) 
    {
        Status = RPC_S_ACCESS_DENIED;
        goto CleanUp;
    }
    Status = RpcStringBindingParse(binding, NULL, &protseq, NULL, NULL, NULL);
    if (Status != RPC_S_OK) 
    {
        Status = RPC_S_ACCESS_DENIED;
    }
    else
    {
        if (lstrcmp(protseq, L"ncacn_np") != 0)
            Status = RPC_S_ACCESS_DENIED;
    }
CleanUp:
    RpcBindingFree(&ServerIfHandle);
    if ( binding )
    {
        RpcStringFreeW( &binding );
    }
    if ( protseq )
    {
        RpcStringFreeW( &protseq );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsregcfg.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    wsregcfg.c

Abstract:

    Registry access routines used by the Workstation (formerly in netlib.lib)

Author:

    John Rogers (JohnRo) 08-May-1992

Environment:

    Only requires ANSI C (slash-slash comments, long external names).

Revision History:

    08-May-1992 JohnRo
        Created.

    01-Feb-2001 JSchwart
        Moved from netlib.lib to wkssvc.dll

--*/


#include <nt.h>         // IN, etc.  (Only needed by temporary config.h)
#include <ntrtl.h>      // (Only needed by temporary config.h)
#include <nturtl.h>     // (Only needed by temporary config.h)
#include <windows.h>    // IN, LPTSTR, etc.
#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // (Needed by config.h)

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // USE_WIN32_CONFIG (if defined), NET_CONFIG_HANDLE, etc
#include <debuglib.h>   // IF_DEBUG().
#include <prefix.h>     // PREFIX_ equates.
#include <strarray.h>   // LPTSTR_ARRAY.
#include <tstr.h>       // TCHAR_EOS.
#include <winerror.h>   // ERROR_NOT_SUPPORTED, NO_ERROR, etc.
#include "wsregcfg.h"   // Registry helpers


NET_API_STATUS
WsSetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN LPTSTR_ARRAY ArrayStart
    )
{
    DWORD ArraySize;                // byte count, incl both null chars at end.
    NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type

    if (MyHandle == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (Keyword == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (*Keyword == TCHAR_EOS) {
        return (ERROR_INVALID_PARAMETER);
    } else if (ArrayStart == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    ArraySize = NetpTStrArraySize( ArrayStart );
    if (ArraySize == 0) {
        return (ERROR_INVALID_PARAMETER);
    }

    {
        LONG Error;

        Error = RegSetValueEx (
                MyHandle->WinRegKey,      // open handle (to section)
                Keyword,                  // subkey
                0,
                REG_MULTI_SZ,             // type
                (LPVOID) ArrayStart,      // data
                ArraySize );              // byte count for data

        IF_DEBUG(CONFIG) {
            NetpKdPrint(("[Wksta] WsSetConfigTStrArray: RegSetValueEx("
                    FORMAT_LPTSTR ") returned " FORMAT_LONG ".\n",
                    Keyword, Error ));
        }

        return ( (NET_API_STATUS) Error );
    }
}


NET_API_STATUS
WsSetConfigBool (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN BOOL Value
    )
{

    //
    // Do boolean-specific error checking...
    //
    if ( (Value != TRUE) && (Value != FALSE) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Eventually, this might use some new data type.  But for now, just
    // treat this as a DWORD request.
    //

    return (WsSetConfigDword(
            ConfigHandle,
            Keyword,
            (DWORD) Value) );

}


NET_API_STATUS
WsSetConfigDword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN DWORD Value
    )
{
    NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type

    {
        LONG Error;

        //
        // Set the actual value.  We might have read this as REG_SZ or
        // REG_DWORD, but let's always write it as REG_DWORD.  (This is
        // the WsSetConfigDword routine, after all.)
        //
        Error = RegSetValueEx (
                MyHandle->WinRegKey,      // open handle (to section)
                Keyword,                  // subkey
                0,
                REG_DWORD,                // type
                (LPVOID) &Value,          // data
                sizeof(DWORD) );          // byte count for data

        IF_DEBUG(CONFIG) {
            NetpKdPrint(("[Wksta] WsSetConfigDword: RegSetValueEx("
                    FORMAT_LPTSTR ") returned " FORMAT_LONG ".\n",
                    Keyword, Error ));
        }

        return ( (NET_API_STATUS) Error );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsmain.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsmain.h

Abstract:

    Private header file which defines the global data which is used for
    communication between the service control handler and the
    rest of the NT Workstation service.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:
    terryk  10-18-1993  Remove WsErrorInitializeLogon

--*/

#ifndef _WSMAIN_INCLUDED_
#define _WSMAIN_INCLUDED_

#include <wsnames.h>              // Service interface names

#include <svcs.h>                 // SVCHOST_GLOBAL_DATA


//
// Time for the sender of a start or stop request to the Workstation
// service to wait (in milliseconds) before checking on the
// Workstation service again to see if it is done.
//
#define WS_WAIT_HINT_TIME                    90000  // 90 seconds

//
// Defines to indicate how far we managed to initialize the Workstation
// service before an error is encountered and the extent of clean up needed
//

#define WS_TERMINATE_EVENT_CREATED           0x00000001
#define WS_DEVICES_INITIALIZED               0x00000002
#define WS_MESSAGE_SEND_INITIALIZED          0x00000004
#define WS_RPC_SERVER_STARTED                0x00000008
#define WS_LOGON_INITIALIZED                 0x00000010
#define WS_LSA_INITIALIZED                   0x00000020
#define WS_DFS_THREAD_STARTED                0x00000040
#define WS_CONFIG_RESOURCE_INITIALIZED       0x00000080

#define WS_SECURITY_OBJECTS_CREATED          0x10000000
#define WS_USE_TABLE_CREATED                 0x20000000

#define WS_API_STRUCTURES_CREATED            (WS_SECURITY_OBJECTS_CREATED | \
                                              WS_USE_TABLE_CREATED )

//
// This macro is called after the redirection of print or comm device
// has been paused or continued.  If either the print or comm device is
// paused the service is considered paused.
//
#define WS_RESET_PAUSE_STATE(WsStatus)  {                            \
    WsStatus &= ~(SERVICE_PAUSE_STATE);                              \
    WsStatus |= (WsStatus & SERVICE_REDIR_PAUSED) ? SERVICE_PAUSED : \
                                                    SERVICE_ACTIVE;  \
    }



//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef enum _WS_ERROR_CONDITION {
    WsErrorRegisterControlHandler = 0,
    WsErrorCreateTerminateEvent,
    WsErrorNotifyServiceController,
    WsErrorInitLsa,
    WsErrorStartRedirector,
    WsErrorBindTransport,
    WsErrorAddDomains,
    WsErrorStartRpcServer,
    WsErrorInitMessageSend,
    WsErrorCreateApiStructures
} WS_ERROR_CONDITION, *PWS_ERROR_CONDITION;

typedef struct _WS_GLOBAL_DATA {

    //
    // Workstation service status
    //
    SERVICE_STATUS Status;

    //
    // Service status handle
    //
    SERVICE_STATUS_HANDLE StatusHandle;

    //
    // When the control handler is asked to stop the Workstation service,
    // it signals this event to notify all threads of the Workstation
    // service to terminate.
    //
    HANDLE TerminateNowEvent;

} WS_GLOBAL_DATA, *PWS_GLOBAL_DATA;

extern WS_GLOBAL_DATA WsGlobalData;

extern HANDLE WsDllRefHandle;

extern PSVCHOST_GLOBAL_DATA WsLmsvcsGlobalData;

extern BOOL WsLUIDDeviceMapsEnabled;

#endif // ifndef _WSMAIN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsregcfg.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    wsregcfg.h

Abstract:

    Registry access routines used by the Workstation (formerly in netlib.lib)

Author:

    Jonathan Schwartz (JSchwart) 01-Feb-2001

Environment:

    Only requires ANSI C (slash-slash comments, long external names).

Revision History:

    01-Feb-2001 JSchwart
        Moved from netlib.lib to wkssvc.dll

--*/


NET_API_STATUS
WsSetConfigBool (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN BOOL Value
    );

NET_API_STATUS
WsSetConfigDword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN DWORD Value
    );

NET_API_STATUS
WsSetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    IN LPTSTR_ARRAY Value
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wssec.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wssec.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to enforce security.

Author:

    Rita Wong (ritaw) 19-Feb-1991

Revision History:

--*/

#ifndef _WSSEC_INCLUDED_
#define _WSSEC_INCLUDED_

#include <secobj.h>

//-------------------------------------------------------------------//
//                                                                   //
// Object specific access masks                                      //
//                                                                   //
//-------------------------------------------------------------------//

//
// ConfigurationInfo specific access masks
//
#define WKSTA_CONFIG_GUEST_INFO_GET     0x0001
#define WKSTA_CONFIG_USER_INFO_GET      0x0002
#define WKSTA_CONFIG_ADMIN_INFO_GET     0x0004
#define WKSTA_CONFIG_INFO_SET           0x0008

#define WKSTA_CONFIG_ALL_ACCESS        (STANDARD_RIGHTS_REQUIRED    | \
                                        WKSTA_CONFIG_GUEST_INFO_GET | \
                                        WKSTA_CONFIG_USER_INFO_GET  | \
                                        WKSTA_CONFIG_ADMIN_INFO_GET | \
                                        WKSTA_CONFIG_INFO_SET)

//
// MessageSend specific access masks
//
#define WKSTA_MESSAGE_SEND              0x0001

#define WKSTA_MESSAGE_ALL_ACCESS       (STANDARD_RIGHTS_REQUIRED | \
                                        WKSTA_MESSAGE_SEND)


//
// Object type names for audit alarm tracking
//
#define CONFIG_INFO_OBJECT      TEXT("WkstaConfigurationInfo")
#define MESSAGE_SEND_OBJECT     TEXT("WkstaMessageSend")

//
// Security descriptors of workstation objects to control user accesses
// to the workstation configuration information, sending messages, and the
// logon support functions.
//
extern PSECURITY_DESCRIPTOR ConfigurationInfoSd;
extern PSECURITY_DESCRIPTOR MessageSendSd;


//
// Generic mapping for each workstation object
//
extern GENERIC_MAPPING WsConfigInfoMapping;
extern GENERIC_MAPPING WsMessageSendMapping;


NET_API_STATUS
WsCreateWkstaObjects(
    VOID
    );

VOID
WsDestroyWkstaObjects(
    VOID
    );

#endif // ifndef _WSSEC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsuse.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsuse.h

Abstract:

    Private header file to be included by Workstation service modules that
    implement the NetUse APIs.

Author:

    Rita Wong (ritaw) 05-Mar-1991

Revision History:

--*/

#ifndef _WSUSE_INCLUDED_
#define _WSUSE_INCLUDED_

#include <lmuse.h>                     // LAN Man Use API definitions
#include <dns.h>                       // DNS_MAX_NAME_LENGTH definition


//
// Length of fixed size portion of a use info structure
//
#define USE_FIXED_LENGTH(Level)                                         \
    (DWORD)                                                             \
    ((Level == 0) ? sizeof(USE_INFO_0) :                                \
                   ((Level == 1) ? sizeof(USE_INFO_1) :                 \
                                   ((Level == 2) ? sizeof(USE_INFO_2) : \
                                                   sizeof(USE_INFO_3))))


//
// Total length of a use info structure (fixed and variable length portions)
//
#define USE_TOTAL_LENGTH(Level, LocalandUncNameLength, UserNameLength)         \
    (DWORD)                                                                    \
    ((Level >= 2) ? (LocalandUncNameLength) + (UserNameLength) +               \
                    ((Level == 3) ? sizeof(USE_INFO_3) : sizeof(USE_INFO_2)) : \
                    (LocalandUncNameLength) + ((Level == 1) ?                  \
                                               sizeof(USE_INFO_1) :            \
                                               sizeof(USE_INFO_0)))

//
// Hint size of an entry of use information from redirector
//
#define HINT_REDIR_INFO(Level)                                       \
    (DWORD)                                                          \
    ((Level == 1) ? sizeof(LMR_CONNECTION_INFO_1) +                  \
                        MAX_PATH * sizeof(WCHAR) :                   \
                    sizeof(LMR_CONNECTION_INFO_2) +                  \
                        (MAX_PATH + MAX_PATH) * sizeof(WCHAR))
//
// Length of fixed size portion of a redirector enumerate info structure
//
#define REDIR_ENUM_INFO_FIXED_LENGTH(Level)                        \
    (DWORD)                                                        \
    ((Level == 0) ? sizeof(LMR_CONNECTION_INFO_0) :                \
                   ((Level == 1) ? sizeof(LMR_CONNECTION_INFO_1) : \
                                   sizeof(LMR_CONNECTION_INFO_2)))

#define REDIR_LIST 0x80000000


//-----------------------------------------------------------------------//
//                                                                       //
// Use Table                                                             //
//                                                                       //
//                      +-----------------+     +-----------------+      //
//                      |TotalUseCount = 6|     |TotalUseCount = 1|      //
//                      +-----------------+     +-----------------+      //
//                      |  RedirUseInfo   |     |  RedirUseInfo   |      //
//                      +-----------------+     +-----------------+      //
//                      | UncNameLength   |     | UncNameLength   |      //
//                      +-----------------+     +-----------------+      //
//                      |\\POPCORN\RAZZLE |     |\\FUZZY\PRINTER  |      //
//                      +-----------------+     +-----------------+      //
//                          ^       ^                   ^                //
//                          |       |                   |                //
//                      +---+       +---+               |                //
//                      |               |               |                //
//   +------------+  +--|--+------+  +--|--+------+  +--|--+------+      //
//   |            |  |  *  |   *---->|  *  |   *---->|  *  |   *---->... //
//   |     *-------->+-----+------+  +-----+------+  +-----+------+      //
//   |            |  | P:  |Local |  |NULL |Local |  |LPT1 |Local |      //
//   +------------+  |     |Length|  |     |Length|  |     |Length|      //
//   |            |  +-----+------+  +-----+------+  +-----+------+      //
//   |            |  |UseCount = 1|  |UseCount = 5|  |UseCount = 1|      //
// 0 |  LogonId   |  +------------+  +------------+  +------------+      //
//   |            |  |Tree        |  |Tree        |  |Tree        |      //
//   |            |  |Connection  |  |Connection  |  |Connection  |      //
//   |            |  +------------+  +------------+  +------------+      //
//   |            |  |ResumeKey   |  |ResumeKey   |  |ResumeKey   |      //
//   |            |  +------------+  +------------+  +------------+      //
//   |            |  |TreeConnStr |  |   NULL     |  |TreeConnStr |      //
//   |            |  +------------+  +------------+  +------------+      //
//   |            |                                                      //
//   +============+                                                      //
//   |            |                                                      //
//   |     *--------> ...                                                //
//   |            |                                                      //
//   +------------+                                                      //
//   |            |                                                      //
//   |  LogonId   |                                                      //
// 1 |            |                                                      //
//   |            |                                                      //
//   |            |                                                      //
//   |            |                                                      //
//   |            |                                                      //
//   |            |                                                      //
//   |            |                                                      //
//   |            |                                                      //
//   +============+                                                      //
//   |     .      |                                                      //
//   |     .      |                                                      //
//   |     .      |                                                      //
//                                                                       //
//                                                                       //
// The Use Table maintained by the Workstation service keeps a list of   //
// explicit connections established by each user.  A use entry is always //
// inserted into the end of the list.                                    //
//                                                                       //
// Implicit connections are not maintained in the Use Table.  The        //
// Workstation service has to ask the redirector to list all established //
// implicit connections when enumerating all active connections for a    //
// user.                                                                 //
//                                                                       //
//-----------------------------------------------------------------------//

//
// The structure definition for the per user entry, which consists of a
// Logon Id and a pointer to a list, is defined in wsutil.h
//

//
// A remote entry for every unique shared resource name (\\server\share)
// of explicit connections.
//
typedef struct _UNC_NAME {
    DWORD TotalUseCount;
    DWORD UncNameLength;
    LPTSTR UncName[1];
} UNC_NAME, *PUNC_NAME;

//
// A use entry in the linked list of connections.
//
typedef struct _USE_ENTRY {
    struct _USE_ENTRY *Next;
    PUNC_NAME Remote;
    LPTSTR Local;
    DWORD LocalLength;
    DWORD UseCount;
    HANDLE TreeConnection;
    DWORD ResumeKey;
    LPTSTR TreeConnectStr;
    DWORD Flags;
} USE_ENTRY, *PUSE_ENTRY;

//
// Values for flags field
//
// USE_DEFAULT_CREDENTIALS 0x4 (defined in lmuse.h)

//
// Enumerated data type to say whether to pause or continue the redirection
//
typedef enum _REDIR_OPERATION {
    PauseRedirection,
    ContinueRedirection
} REDIR_OPERATION;


//-------------------------------------------------------------------//
//                                                                   //
// Utility functions from useutil.c                                  //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
WsInitUseStructures(
    VOID
    );

VOID
WsDestroyUseStructures(
    VOID
    );

VOID
WsFindInsertLocation(
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR UncName,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *InsertPointer
    );

NET_API_STATUS
WsFindUse(
    IN  PLUID LogonId,
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR UseName,
    OUT PHANDLE TreeConnection,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *BackPointer OPTIONAL
    );

VOID
WsFindUncName(
    IN  PUSE_ENTRY UseList,
    IN  LPTSTR UncName,
    OUT PUSE_ENTRY *MatchedPointer,
    OUT PUSE_ENTRY *BackPointer
    );

NET_API_STATUS
WsCreateTreeConnectName(
    IN  LPTSTR UncName,
    IN  DWORD UncNameLength,
    IN  LPTSTR LocalName,
    IN  DWORD  SessionId,
    OUT PUNICODE_STRING TreeConnectStr
    );

NET_API_STATUS
WsOpenCreateConnection(
    IN  PUNICODE_STRING TreeConnectionName,
    IN  LPTSTR UserName OPTIONAL,
    IN  LPTSTR DomainName OPTIONAL,
    IN  LPTSTR Password OPTIONAL,
    IN  ULONG CreateFlags,
    IN  ULONG CreateDisposition,
    IN  ULONG ConnectionType,
    OUT PHANDLE TreeConnectionHandle,
    OUT PULONG_PTR Information OPTIONAL
    );

NET_API_STATUS
WsDeleteConnection(
    IN  PLUID LogonId,
    IN  HANDLE TreeConnection,
    IN  DWORD ForceLevel
    );

BOOL
WsRedirectionPaused(
    IN LPTSTR LocalDeviceName
    );

VOID
WsPauseOrContinueRedirection(
    IN  REDIR_OPERATION OperationType
    );

NET_API_STATUS
WsCreateSymbolicLink(
    IN  LPWSTR Local,
    IN  DWORD DeviceType,
    IN  LPWSTR TreeConnectStr,
    IN  PUSE_ENTRY UseList,
    IN  OUT LPWSTR *Session,
    IN  OUT HANDLE  *lphToken
    );


VOID
WsDeleteSymbolicLink(
    IN  LPWSTR  LocalDeviceName,
    IN  LPWSTR  TreeConnectStr,
    IN  LPWSTR  SessionDeviceName,
    IN  HANDLE  hToken
    );

NET_API_STATUS
WsUseCheckRemote(
    IN  LPTSTR RemoteResource,
    OUT LPTSTR UncName,
    OUT LPDWORD UncNameLength
    );

NET_API_STATUS
WsUseCheckLocal(
    IN  LPTSTR LocalDevice,
    OUT LPTSTR Local,
    OUT LPDWORD LocalLength
    );

//-------------------------------------------------------------------//
//                                                                   //
// External global variables                                         //
//                                                                   //
//-------------------------------------------------------------------//

//
// Use Table
//
extern USERS_OBJECT Use;

#endif // ifndef _WSUSE_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsstats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    WsStats.c

Abstract:

    Contains workstation service half of the Net statistics routine:

        NetrWorkstationStatisticsGet
        (GetStatisticsFromRedir)

Author:

    Richard L Firth (rfirth) 12-05-1991

Revision History:

    12-05-1991 rfirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmwksta.h>
#include <lmstats.h>
#include <ntddnfs.h>
#include <memory.h>
#include <netlibnt.h>
#include <ntrpcp.h>

#include "wsdevice.h"

//
// debugging
//

#ifdef DBG
#define STATIC
#ifdef DBGSTATS
BOOL    DbgStats = TRUE;
#else
BOOL    DbgStats = FALSE;
#endif
#ifdef UNICODE
#define PERCENT_S   "%ws"
#else
#define PERCENT_S   "%s"
#endif
#else
#define STATIC  static
#endif

//
// private prototypes
//

static
NTSTATUS
GetStatisticsFromRedir(
    OUT PREDIR_STATISTICS pStats
    );

//
// functions
//

NET_API_STATUS
NET_API_FUNCTION
NetrWorkstationStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  ServiceName,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Returns workstation statistics to the caller. This is the server part of
    the request. Parameters have been validated by the client routine

Arguments:

    ServerName  - IGNORED
    ServiceName - IGNORED
    Level       - of information required. MBZ (IGNORED)
    Options     - MBZ
    Buffer      - pointer to pointer to returned buffer

Return Value:

    NET_API_STATUS
        Success - NERR_Success

        Failure - ERROR_INVALID_LEVEL
                    Level not 0

                  ERROR_INVALID_PARAMETER
                    Unsupported options requested

                  ERROR_NOT_ENOUGH_MEMORY
                    For API buffer

--*/

{
    NET_API_STATUS status;
    NTSTATUS ntStatus;
    PREDIR_STATISTICS stats;

    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(ServiceName);

#if DBG
    if (DbgStats) {
        DbgPrint("NetrWorkstationStatisticsGet: ServerName=" PERCENT_S "\n"
            "ServiceName=" PERCENT_S "\n"
            "Level=%d\n"
            "Options=%x\n",
            ServerName,
            ServiceName,
            Level,
            Options
            );
    }
#endif

    if (Level) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // we don't even allow clearing of stats any more
    //

    if (Options) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get the redir statistics then munge them into API format
    //

    stats = (PREDIR_STATISTICS)MIDL_user_allocate(sizeof(*stats));
    if (stats == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ntStatus = GetStatisticsFromRedir(stats);
    if (NT_SUCCESS(ntStatus)) {
        *Buffer = (LPBYTE)stats;
        status = NERR_Success;
    } else {
        MIDL_user_free(stats);
        status = NetpNtStatusToApiStatus(ntStatus);
    }

#if DBG
    if (DbgStats) {
        DbgPrint("NetrWorkstationStatisticsGet: returning %x\n", status);
    }
#endif

    return status;
}

static
NTSTATUS
GetStatisticsFromRedir(
    OUT PREDIR_STATISTICS pStats
    )

/*++

Routine Description:

    Reads the redir statistics from the Redirector File System Device

Arguments:

    pStats  - place to store statistics (fixed length buffer)

Return Value:

    NTSTATUS
        Success - STATUS_SUCCESS
                    *pStats contains redirector statistics

        Failure -

--*/

{
    HANDLE FileHandle;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;

    RtlInitUnicodeString(&FileName,DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = NtCreateFile(
               &FileHandle,
               SYNCHRONIZE,
               &Obja,
               &IoStatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               FILE_SHARE_READ | FILE_SHARE_WRITE,
               FILE_OPEN_IF,
               FILE_SYNCHRONOUS_IO_NONALERT,
               NULL,
               0
               );
    if ( NT_SUCCESS(Status) ) {
        Status = NtFsControlFile(
                    FileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_LMR_GET_STATISTICS,
                    NULL,
                    0,
                    pStats,
                    sizeof(*pStats)
                    );
    }

    NtClose(FileHandle);

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wssec.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wssec.c

Abstract:

    This module contains the Workstation service support routines
    which create security objects and enforce security _access checking.

Author:

    Rita Wong (ritaw) 19-Feb-1991

Revision History:

--*/

#include "wsutil.h"
#include "wsmain.h"
#include "wssec.h"

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NTSTATUS
WsCreateConfigInfoObject(
    VOID
    );

STATIC
NTSTATUS
WsCreateMessageSendObject(
    VOID
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Security descriptors of workstation objects to control user accesses
// to the workstation configuration information, sending messages, and the
// logon support functions.
//
PSECURITY_DESCRIPTOR ConfigurationInfoSd;
PSECURITY_DESCRIPTOR MessageSendSd;


//
// Structure that describes the mapping of Generic access rights to
// object specific access rights for the ConfigurationInfo object.
//
GENERIC_MAPPING WsConfigInfoMapping = {
    STANDARD_RIGHTS_READ            |      // Generic read
        WKSTA_CONFIG_GUEST_INFO_GET |
        WKSTA_CONFIG_USER_INFO_GET  |
        WKSTA_CONFIG_ADMIN_INFO_GET,
    STANDARD_RIGHTS_WRITE |                // Generic write
        WKSTA_CONFIG_INFO_SET,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    WKSTA_CONFIG_ALL_ACCESS                // Generic all
    };

//
// Structure that describes the mapping of generic access rights to
// object specific access rights for the MessageSend object.
//
GENERIC_MAPPING WsMessageSendMapping = {
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE |                // Generic write
        WKSTA_MESSAGE_SEND,
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    WKSTA_MESSAGE_ALL_ACCESS               // Generic all
    };



NET_API_STATUS
WsCreateWkstaObjects(
    VOID
    )
/*++

Routine Description:

    This function creates the workstation user-mode objects which are
    represented by security descriptors.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;


    //
    // Create ConfigurationInfo object
    //
    if (! NT_SUCCESS (ntstatus = WsCreateConfigInfoObject())) {
        IF_DEBUG(UTIL) {
            NetpKdPrint(("[Wksta] Failure to create ConfigurationInfo object\n"));
        }
        return NetpNtStatusToApiStatus(ntstatus);
    }

    //
    // Create MessageSend object
    //
    if (! NT_SUCCESS (ntstatus = WsCreateMessageSendObject())) {
        IF_DEBUG(UTIL) {
            NetpKdPrint(("[Wksta] Failure to create MessageSend object\n"));
        }
        return NetpNtStatusToApiStatus(ntstatus);
    }

    return NERR_Success;
}



STATIC
NTSTATUS
WsCreateConfigInfoObject(
    VOID
    )
/*++

Routine Description:

    This function creates the workstation configuration information object.

Arguments:

    None.

Return Value:

    NTSTATUS - status returned from NetpCreateSecurityObject.

--*/
{
    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    // Local users, admins, and operators are allowed to get all information.
    // Only admins are allowed to set information.  Users are allowed to get
    // user and guest info; guests are allowed to get guest info only.
    //

#define CONFIG_INFO_ACES  8                 // Number of ACEs in this DACL

    ACE_DATA AceData[CONFIG_INFO_ACES] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET |
               WKSTA_CONFIG_USER_INFO_GET  |
               WKSTA_CONFIG_ADMIN_INFO_GET,  &WsLmsvcsGlobalData->LocalSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,                  &WsLmsvcsGlobalData->AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET |
               WKSTA_CONFIG_USER_INFO_GET  |
               WKSTA_CONFIG_ADMIN_INFO_GET,  &WsLmsvcsGlobalData->AliasAccountOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET |
               WKSTA_CONFIG_USER_INFO_GET  |
               WKSTA_CONFIG_ADMIN_INFO_GET,  &WsLmsvcsGlobalData->AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET |
               WKSTA_CONFIG_USER_INFO_GET  |
               WKSTA_CONFIG_ADMIN_INFO_GET,  &WsLmsvcsGlobalData->AliasPrintOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET |
               WKSTA_CONFIG_USER_INFO_GET,   &WsLmsvcsGlobalData->AliasUsersSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET,  &WsLmsvcsGlobalData->WorldSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_CONFIG_GUEST_INFO_GET,  &WsLmsvcsGlobalData->AnonymousLogonSid}
        };
     

    return NetpCreateSecurityObject(
               AceData,
               CONFIG_INFO_ACES,
               WsLmsvcsGlobalData->LocalSystemSid,
               WsLmsvcsGlobalData->LocalSystemSid,
               &WsConfigInfoMapping,
               &ConfigurationInfoSd
               );
}



STATIC
NTSTATUS
WsCreateMessageSendObject(
    VOID
    )
/*++

Routine Description:

    This function creates the workstation message send object.

Arguments:

    None.

Return Value:

    NTSTATUS - status returned from NetpCreateSecurityObject.

--*/
{
    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    // Any local user, and domain admins and operators are allowed to
    // send messages.  Remote users besides domain admins, and operators
    // are not allowed to send messages.
    //

#define MESSAGE_SEND_ACES  5                // Number of ACEs in this DACL

    ACE_DATA AceData[MESSAGE_SEND_ACES] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,         &WsLmsvcsGlobalData->LocalSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,         &WsLmsvcsGlobalData->AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_MESSAGE_SEND,  &WsLmsvcsGlobalData->AliasAccountOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_MESSAGE_SEND,  &WsLmsvcsGlobalData->AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               WKSTA_MESSAGE_SEND,  &WsLmsvcsGlobalData->AliasPrintOpsSid}

        };


    return NetpCreateSecurityObject(
               AceData,
               MESSAGE_SEND_ACES,
               WsLmsvcsGlobalData->LocalSystemSid,
               WsLmsvcsGlobalData->LocalSystemSid,
               &WsMessageSendMapping,
               &MessageSendSd
               );
}



VOID
WsDestroyWkstaObjects(
    VOID
    )
/*++

Routine Description:

    This function destroys the workstation user-mode objects which are
    represented by security descriptors.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (void) NetpDeleteSecurityObject(&ConfigurationInfoSd);
    (void) NetpDeleteSecurityObject(&MessageSendSd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsutil.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wsutil.c

Abstract:

    This module contains miscellaneous utility routines used by the
    Workstation service.

Author:

    Rita Wong (ritaw) 01-Mar-1991

Revision History:

--*/

#include "wsutil.h"

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
WsGrowTable(
    IN  PUSERS_OBJECT Users
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Debug trace flag for selecting which trace statements to output
//
#if DBG

DWORD WorkstationTrace = 0;

#endif // DBG



NET_API_STATUS
WsInitializeUsersObject(
    IN  PUSERS_OBJECT Users
    )
/*++

Routine Description:

    This function allocates the table of users, and initializes the resource
    to serialize access to this table.

Arguments:

    Users - Supplies a pointer to the users object.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    //
    // Allocate the users table memory so that it can be grown (reallocated)
    // as more entries are needed.
    //
    if ((Users->TableMemory = (HANDLE) LocalAlloc(
                                           LMEM_ZEROINIT | LMEM_MOVEABLE,
                                           INITIAL_USER_COUNT * sizeof(PER_USER_ENTRY)
                                           )) == NULL) {
        return GetLastError();
    }

    Users->TableSize = INITIAL_USER_COUNT;

    //
    // Keep the memory from moving by locking it to a specific location in
    // virtual memory.  When it is necessary to grow this table, which may
    // result in the virtual memory being relocated, it will be unlocked.
    //
    if ((Users->Table = (PPER_USER_ENTRY)
                         LocalLock(Users->TableMemory)) == NULL) {
        return GetLastError();
    }

    //
    // Initialize the resource for the users table.
    //
    try {
        RtlInitializeResource(&Users->TableResource);
    } except(EXCEPTION_EXECUTE_HANDLER) {
          return RtlNtStatusToDosError(GetExceptionCode());
    }

    return NERR_Success;
}


VOID
WsDestroyUsersObject(
    IN  PUSERS_OBJECT Users
    )
/*++

Routine Description:

    This function free the table allocated for logged on users, and deletes
    the resource used to serialize access to this table.

Arguments:

    Users - Supplies a pointer to the users object.

Return Value:

    None.

--*/
{

    //
    //  Unlock the memory holding the table to allow us to free it.
    //

    LocalUnlock(Users->TableMemory);

    (void) LocalFree(Users->TableMemory);
    RtlDeleteResource(&(Users->TableResource));
}



NET_API_STATUS
WsGetUserEntry(
    IN  PUSERS_OBJECT Users,
    IN  PLUID LogonId,
    OUT PULONG Index,
    IN  BOOL IsAdd
    )
/*++

Routine Description:

    This function searches the table of user entries for one that matches the
    specified LogonId, and returns the index to the entry found.  If none is
    found, an error is returned if IsAdd is FALSE.  If IsAdd is TRUE a new
    entry in the users table is created for the user and the index to this
    new entry is returned.

    WARNING: This function assumes that the users table resource has been
             claimed.

Arguments:

    Users - Supplies a pointer to the users object.

    LogonId - Supplies the pointer to the current user's Logon Id.

    Index - Returns the index to the users table of entry belonging to the
        current user.

    IsAdd - Supplies flag to indicate whether to add a new entry for the
        current user if none is found.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD i;
    ULONG FreeEntryIndex = MAXULONG;


    for (i = 0; i < Users->TableSize; i++) {

        //
        // If the LogonId matches the entry in the UsersTable, we've found the
        // correct user entry.
        //
        if (RtlEqualLuid(LogonId, &Users->Table[i].LogonId)) {

            *Index = i;
            return NERR_Success;

        }
        else if (FreeEntryIndex == MAXULONG && Users->Table[i].List == NULL) {
            //
            // Save away first unused entry in table.
            //
            FreeEntryIndex = i;
        }
    }

    if (! IsAdd) {
        //
        // Current user is not found in users table and we are told not to
        // create a new entry
        //
        return NERR_UserNotFound;
    }

    //
    // Could not find an empty entry in the UsersTable, need to grow
    //
    if (FreeEntryIndex == MAXULONG) {

        if ((status = WsGrowTable(Users)) != NERR_Success) {
            return status;
        }

        FreeEntryIndex = i;
    }

    //
    // Create a new entry for current user
    //
    RtlCopyLuid(&Users->Table[FreeEntryIndex].LogonId, LogonId);
    *Index = FreeEntryIndex;

    return NERR_Success;
}



STATIC
NET_API_STATUS
WsGrowTable(
    IN  PUSERS_OBJECT Users
    )
/*++

Routine Description:

    This function grows the users table to accomodate more users.

    WARNING: This function assumes that the users table resource has been
             claimed.

Arguments:

    Users - Supplies a pointer to the users object.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    HANDLE hTemp;
    
    //
    // Unlock the Use Table virtual memory so that Win32 can move it
    // around to find a larger piece of contiguous virtual memory if
    // necessary.
    //
    LocalUnlock(Users->TableMemory);

    //
    // Grow users table
    //
    hTemp = LocalReAlloc(Users->TableMemory,
                         (Users->TableSize + GROW_USER_COUNT)
                         * sizeof(PER_USER_ENTRY),
                         LMEM_ZEROINIT | LMEM_MOVEABLE
                         );

    if (hTemp == NULL) {
        return GetLastError();
    }
    
    Users->TableMemory = hTemp;
    
    //
    // Update new size of Use Table
    //
    Users->TableSize += GROW_USER_COUNT;

    //
    // Lock Use Table virtual memory so that it cannot be moved
    //
    if ((Users->Table = (PPER_USER_ENTRY)
                         LocalLock(Users->TableMemory)) == NULL) {
        return GetLastError();
    }

    return NERR_Success;
}



NET_API_STATUS
WsMapStatus(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    error code expected from calling a LAN Man API.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    //
    // A small optimization for the most common case.
    //
    if (NtStatus == STATUS_SUCCESS) {
        return NERR_Success;
    }

    switch (NtStatus) {
        case STATUS_OBJECT_NAME_COLLISION:
            return ERROR_ALREADY_ASSIGNED;

        case STATUS_OBJECT_NAME_NOT_FOUND:
            return NERR_UseNotFound;

        case STATUS_IMAGE_ALREADY_LOADED:
        case STATUS_REDIRECTOR_STARTED:
            return ERROR_SERVICE_ALREADY_RUNNING;

        case STATUS_REDIRECTOR_HAS_OPEN_HANDLES:
            return ERROR_REDIRECTOR_HAS_OPEN_HANDLES;

        default:
            return NetpNtStatusToApiStatus(NtStatus);
    }

}



int
WsCompareString(
    IN LPTSTR String1,
    IN DWORD Length1,
    IN LPTSTR String2,
    IN DWORD Length2
    )
/*++

Routine Description:

    This function compares two strings based on their lengths.  The return
    value indicates if the strings are equal or String1 is less than String2
    or String1 is greater than String2.

    This function is a modified version of RtlCompareString.

Arguments:

    String1 - Supplies the pointer to the first string.

    Length1 - Supplies the length of String1 in characters.

    String2 - Supplies the pointer to the second string.

    Length2 - Supplies the length of String2 in characters.

Return Value:

    Signed value that gives the results of the comparison:

        0 - String1 equals String2

        < 0 - String1 less than String2

        > 0 - String1 greater than String2


--*/
{
    TCHAR Char1, Char2;
    int CharDiff;

    while (Length1 && Length2) {

        Char1 = *String1++;
        Char2 = *String2++;

        if ((CharDiff = (Char1 - Char2)) != 0) {
            return CharDiff;
        }

        Length1--;
        Length2--;
    }

    return Length1 - Length2;
}

int
WsCompareStringU(
    IN LPWSTR String1,
    IN DWORD Length1,
    IN LPTSTR String2,
    IN DWORD Length2
    )
{
    UNICODE_STRING S1;
    UNICODE_STRING S2;
    int rValue;


    S1.Length =
        S1.MaximumLength = (USHORT) (Length1 * sizeof(WCHAR));
    S1.Buffer = String1;

    S2.Length =
        S2.MaximumLength = (USHORT) (Length2 * sizeof(WCHAR));
    S2.Buffer = String2;

    rValue = RtlCompareUnicodeString(&S1, &S2, TRUE);

    return(rValue);
}


BOOL
WsCopyStringToBuffer(
    IN  PUNICODE_STRING SourceString,
    IN  LPBYTE FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *DestinationStringPointer
    )
/*++

Routine Description:

    This function converts the unicode source string to ANSI string (if
    we haven't flipped the unicode switch yet) and calls
    NetpCopyStringToBuffer.

Arguments:

    SourceString - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    DestinationStringPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    if (! NetpCopyStringToBuffer(
              SourceString->Buffer,
              SourceString->Length / sizeof(WCHAR),
              FixedPortion,
              EndOfVariableData,
              DestinationStringPointer
              )) {
        return FALSE;
    }

    return TRUE;
}


NET_API_STATUS
WsImpersonateClient(
    VOID
    )
/*++

Routine Description:

    This function calls RpcImpersonateClient to impersonate the current caller
    of an API.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS  status;

    if ((status = RpcImpersonateClient(NULL)) != NERR_Success) {
        NetpKdPrint(("[Wksta] Fail to impersonate client 0x%x\n", status));
    }

    return status;
}


NET_API_STATUS
WsRevertToSelf(
    VOID
    )
/*++

Routine Description:

    This function calls RpcRevertToSelf to undo an impersonation.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS  status;


    if (( status = RpcRevertToSelf()) != NERR_Success) {
        NetpKdPrint(("[Wksta] Fail to revert to self 0x%x\n", status));
        NetpAssert(FALSE);
    }

    return status;
}


NET_API_STATUS
WsImpersonateAndGetLogonId(
    OUT PLUID LogonId
    )
/*++

Routine Description:

    This function gets the logon id of the current thread.

Arguments:

    LogonId - Returns the logon id of the current process.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    HANDLE CurrentThreadToken;
    TOKEN_STATISTICS TokenStats;
    ULONG ReturnLength;


    if ((status = WsImpersonateClient()) != NERR_Success) {
        return status;
    }

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use workstation service's security
                                      // context to open thread token
                   &CurrentThreadToken
                   );

    status = NetpNtStatusToApiStatus(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] Cannot open the current thread token %08lx\n",
                     ntstatus));
        goto RevertToSelf;
    }

    //
    // Get the logon id of the current thread
    //
    ntstatus = NtQueryInformationToken(
                  CurrentThreadToken,
                  TokenStatistics,
                  (PVOID) &TokenStats,
                  sizeof(TokenStats),
                  &ReturnLength
                  );

    status = NetpNtStatusToApiStatus(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] Cannot query current thread's token %08lx\n",
                     ntstatus));
        NtClose(CurrentThreadToken);
        goto RevertToSelf;
    }

    RtlCopyLuid(LogonId, &TokenStats.AuthenticationId);

    NtClose(CurrentThreadToken);


RevertToSelf:

    WsRevertToSelf();

    return status;
}


NET_API_STATUS
WsOpenDestinationMailslot(
    IN  LPWSTR TargetName,
    IN  LPWSTR MailslotName,
    OUT PHANDLE MailslotHandle
    )
/*++

Routine Description:

    This function combines the target domain or computer name and the mailslot
    name to form the destination mailslot name.  It then opens this destination
    mailslot and returns a handle to it.

Arguments:

    TargetName - Supplies the name of a domain or computer which we want to
        target when sending a mailslot message.

    MailslotName - Supplies the name of the mailslot.

    MailslotHandle - Returns the handle to the destination mailslot of
        \\TargetName\MailslotName.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;
    LPWSTR DestinationMailslot;


    if ((DestinationMailslot = (LPWSTR) LocalAlloc(
                                            LMEM_ZEROINIT,
                                            (UINT) (wcslen(TargetName) +
                                                     wcslen(MailslotName) +
                                                     3) * sizeof(WCHAR)
                                            )) == NULL) {
        return GetLastError();
    }

    wcscpy(DestinationMailslot, L"\\\\");
    wcscat(DestinationMailslot, TargetName);
    wcscat(DestinationMailslot, MailslotName);

    if ((*MailslotHandle = (HANDLE) CreateFileW(
                                        DestinationMailslot,
                                        GENERIC_WRITE,
                                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                                        (LPSECURITY_ATTRIBUTES) NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL
                                        )) == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        NetpKdPrint(("[Wksta] Error opening mailslot %s %lu",
                     DestinationMailslot, status));
    }

    (void) LocalFree(DestinationMailslot);

    return status;
}



NET_API_STATUS
WsImpersonateAndGetSessionId(
    OUT PULONG pSessionId
    )
/*++

Routine Description:

    This function gets the session id of the current thread.

    Arguments:

    pSessionId - Returns the session id of the current process.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    HANDLE CurrentThreadToken;
    ULONG SessionId;
    ULONG ReturnLength;

    if ((status = WsImpersonateClient()) != NERR_Success) {
        return status;
    }

    ntstatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,              // Use workstation service's security
                                      // context to open thread token
                   &CurrentThreadToken
                   );

    status = NetpNtStatusToApiStatus(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] Cannot open the current thread token %08lx\n",
                     ntstatus));
        goto RevertToSelf;
    }

    //
    // Get the session id of the current thread
    //


    ntstatus = NtQueryInformationToken(
                  CurrentThreadToken,
                  TokenSessionId,
                  &SessionId,
                  sizeof(ULONG),
                  &ReturnLength
                  );

    status = NetpNtStatusToApiStatus(ntstatus);

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Wksta] Cannot query current thread's token %08lx\n",
                     ntstatus));
        NtClose(CurrentThreadToken);
        goto RevertToSelf;
    }


    NtClose(CurrentThreadToken);

    *pSessionId = SessionId;

RevertToSelf:
    WsRevertToSelf();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wssend.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wssend.c

Abstract:

    This module contains the worker routines for sending
    domain wide and directed messages, which are used to implement
    NetMessageBufferSend API.

Author:

    Rita Wong (ritaw) 29-July-1991

Revision History:

--*/


#include "wsutil.h"
#include "wsmsg.h"

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
BOOL
WsVerifySmb(
    IN  PUCHAR SmbBuffer,
    IN  WORD SmbBufferSize,
    IN  UCHAR SmbFunctionCode,
    OUT PUCHAR SmbReturnClass,
    OUT PUSHORT SmbReturnCode
    );

STATIC
NET_API_STATUS
WsMapSmbStatus(
    UCHAR SmbReturnClass,
    USHORT SmbReturnCode
    );


NET_API_STATUS
WsSendToGroup(
    IN  LPTSTR DomainName,
    IN  LPTSTR Sender,
    IN  LPBYTE Message,
    IN  WORD MessageSize
    )
/*++

Routine Description:

    This function writes a datagram to the \\DomainName\MAILSLOT\MESSNGR
    mailslot which is read by every Messenger service of workstations
    that have the domain name as the primary domain.  Reception is not
    guaranteed.

    The DomainName may be a computername.  This is acceptable because the
    Datagram Receiver listens on the computername (besides the primary domain)
    for datagrams.  When a computername is specified, the message is sent
    to that one computer alone.

Arguments:

    DomainName - Supplies the name of the target domain.  This actually
        can be a computername, in which case, the datagram only reaches
        one recipient.

    Sender - Supplies the name of the sender.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;
    HANDLE MessengerMailslot;
    DWORD NumberOfBytesWritten;

    BYTE MailslotBuffer[MAX_GROUP_MESSAGE_SIZE + MAX_PATH + MAX_PATH + 4];
    SHORT MSBLengthRemaining = sizeof(MailslotBuffer);
    LPSTR AnsiSender;
    LPSTR AnsiReceiver;

    LPBYTE CurrentPos;


    //
    // Canonicalize the domain name
    //
    status = I_NetNameCanonicalize(
                 NULL,
                 DomainName,
                 DomainName,
                 (NCBNAMSZ + 2) * sizeof(TCHAR),
                 NAMETYPE_DOMAIN,
                 0
                 );

    if (status != NERR_Success) {
        NetpKdPrint(("[Wksta] Error canonicalizing domain name %ws %lu\n",
                  DomainName, status));
        return status;
    }

    //
    // Open \\DomainName\MAILSLOT\MESSNGR mailslot to
    // send message to.
    //
    if ((status = WsOpenDestinationMailslot(
                      DomainName,
                      MESSENGER_MAILSLOT_W,
                      &MessengerMailslot
                      )) != NERR_Success) {
        return status;
    }

    //
    // Package the message to be sent.  It consists of:
    //           Sender  (must be ANSI)
    //           DomainName (must be ANSI)
    //           Message
    //

    //
    // Convert the names to ANSI
    //
    AnsiSender = NetpAllocStrFromWStr(Sender);
    if (AnsiSender == NULL) {
        (void) CloseHandle(MessengerMailslot);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    AnsiReceiver = NetpAllocStrFromWStr(DomainName);
    if (AnsiReceiver == NULL) {
        NetApiBufferFree(AnsiSender);
        (void) CloseHandle(MessengerMailslot);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory(MailslotBuffer, sizeof( MailslotBuffer ) );

    //
    // Copy Sender into mailslot buffer
    //
    StringCbCopyA(MailslotBuffer,MSBLengthRemaining,AnsiSender);
    CurrentPos = MailslotBuffer + strlen(AnsiSender) + 1;
    MSBLengthRemaining -= strlen(AnsiSender) + 1;

    //
    // Copy DomainName into mailslot buffer
    //
    StringCbCopyA(CurrentPos,MSBLengthRemaining,AnsiReceiver);
    CurrentPos += (strlen(AnsiReceiver) + 1);
    MSBLengthRemaining -= strlen(AnsiReceiver) + 1;

    //
    // Copy Message into mailslot buffer
    //  
    MessageSize = (MSBLengthRemaining >= MessageSize + 1) ? MessageSize : MSBLengthRemaining - 1;
    strncpy(CurrentPos, Message, MessageSize);
    CurrentPos += MessageSize;
    *CurrentPos = '\0';

    //
    // Send the datagram to the domain
    //
    if (WriteFile(
            MessengerMailslot,
            MailslotBuffer,
            (DWORD) (CurrentPos - MailslotBuffer + 1),
            &NumberOfBytesWritten,
            NULL
            ) == FALSE) {

        status = GetLastError();
        NetpKdPrint(("[Wksta] Error sending datagram to %ws %lu\n",
                     AnsiReceiver, status));

        if (status == ERROR_PATH_NOT_FOUND ||
            status == ERROR_BAD_NET_NAME) {
            status = NERR_NameNotFound;
        }
    }
    else {
        NetpAssert(NumberOfBytesWritten ==
                   (DWORD) (CurrentPos - MailslotBuffer + 1));
    }

    NetApiBufferFree(AnsiSender);
    NetApiBufferFree(AnsiReceiver);

    (void) CloseHandle(MessengerMailslot);

    return status;
}


NET_API_STATUS
WsSendMultiBlockBegin(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  LPTSTR ToName,
    IN  LPTSTR FromName,
    OUT short *MessageId
    )
/*++

Routine Description:

    This function sends the header of a multi-block directed message on a
    session we had established earlier.  It waits for an acknowlegement from
    the recipient.  If the recipient got the message successfully, it
    sends back a message group id which is returned by this function for
    subsequent use in sending the body and trailer of a multi-block message.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of a session established with
        NetBIOS CALL and LISTEN commands.

    ToName - Supplies the name of the recipient.

    FromName - Supplies the name of the sender.

    MessageId - Returns the message group id.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    UCHAR SmbBuffer[WS_SMB_BUFFER_SIZE];
    WORD SmbSize;

    char SendName[NCBNAMSZ + 1];

    UCHAR SmbReturnClass;
    USHORT SmbReturnCode;

    LPSTR AnsiToName;
    LPSTR AnsiFromName;

    AnsiToName = NetpAllocStrFromWStr(ToName);
    if (AnsiToName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    AnsiFromName = NetpAllocStrFromWStr(FromName);
    if (AnsiFromName == NULL) {
        NetApiBufferFree(AnsiToName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    StringCbCopyA(SendName,sizeof(SendName),AnsiToName);

    //
    // Make and send the SMB
    //
    SmbSize = WsMakeSmb(
                 SmbBuffer,
                 SMB_COM_SEND_START_MB_MESSAGE,
                 0,
                 "ss",
                 AnsiFromName,
                 SendName
                 );

    NetApiBufferFree(AnsiToName);
    NetApiBufferFree(AnsiFromName);

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] Send start multi-block message. Size=%u\n",
                     SmbSize));
#if DBG
        NetpHexDump(SmbBuffer, SmbSize);
#endif
    }

    if ((status = NetpNetBiosSend(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to send start of multi-block message %lu\n",
                     status));
        return status;
    }

    //
    // Get response
    //
    if ((status = NetpNetBiosReceive(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      WS_SMB_BUFFER_SIZE,
                      (HANDLE) NULL,
                      &SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to receive verification to multi-"
                     "block message start %lu\n", status));
        return status;
    }

    if (! WsVerifySmb(
              SmbBuffer,
              SmbSize,
              SMB_COM_SEND_START_MB_MESSAGE,
              &SmbReturnClass,
              &SmbReturnCode
              )) {

        //
        // Unexpected behaviour
        //
        return NERR_NetworkError;
    }

    //
    // Set the message group id
    //

    *MessageId = *((UNALIGNED short *) &SmbBuffer[sizeof(SMB_HEADER) + 1]);

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] Message Id=x%x\n", *MessageId));
    }

    return WsMapSmbStatus(SmbReturnClass,  SmbReturnCode);
}


NET_API_STATUS
WsSendMultiBlockEnd(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  short MessageId
    )
/*++

Routine Description:

    This function sends the end marker of a multi-block directed message on
    a session we had establised earlier.  It waits for an acknowlegement from
    the recipient.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of a session established with
        NetBIOS CALL and LISTEN commands.

    MessageId - Supplies the message group id gotten from
        WsSendMultiBlockBegin.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

    NET_API_STATUS status;

    UCHAR SmbBuffer[WS_SMB_BUFFER_SIZE];
    WORD SmbSize;                        // Size of SMB data

    UCHAR SmbReturnClass;
    USHORT SmbReturnCode;


    SmbSize = WsMakeSmb(
                  SmbBuffer,
                  SMB_COM_SEND_END_MB_MESSAGE,
                  1,
                  "",
                  MessageId
                  );

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] Send end multi-block message. Size=%u\n",
                     SmbSize));
#if DBG
        NetpHexDump(SmbBuffer, SmbSize);
#endif
    }

    if ((status = NetpNetBiosSend(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to send end of multi-block message %lu\n",
                     status));
        return status;
    }

    //
    // Get response
    //
    if ((status = NetpNetBiosReceive(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      WS_SMB_BUFFER_SIZE,
                      (HANDLE) NULL,
                      &SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to receive verification to multi-"
                     "block message end %lu\n", status));
        return status;
    }

    if (! WsVerifySmb(
              SmbBuffer,
              SmbSize,
              SMB_COM_SEND_END_MB_MESSAGE,
              &SmbReturnClass,
              &SmbReturnCode
              )) {
        return NERR_NetworkError;      // Unexpected behaviour
    }

    return WsMapSmbStatus(SmbReturnClass,SmbReturnCode);
}



NET_API_STATUS
WsSendMultiBlockText(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  PCHAR TextBuffer,
    IN  WORD TextBufferSize,
    IN  short MessageId
    )
/*++

Routine Description:

    This function sends the body of a multi-block directed message on a
    session we had established earlier.   It waits for an acknowlegement from
    the recipient.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of a session established with
        NetBIOS CALL and LISTEN commands.

    TextBuffer - Supplies the buffer of the message to be sent.

    TextBufferSize - Supplies the size of the message buffer.

    MessageId - Supplies the message group id gotten from
        WsSendMultiBlockBegin.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    UCHAR SmbBuffer[WS_SMB_BUFFER_SIZE];
    WORD SmbSize;                         // Buffer length

    UCHAR SmbReturnClass;
    USHORT SmbReturnCode;


    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] Send body multi-block message. Size=%u\n",
                     TextBufferSize));
    }

    SmbSize = WsMakeSmb(
                  SmbBuffer,
                  SMB_COM_SEND_TEXT_MB_MESSAGE,
                  1,
                  "t",
                  MessageId,
                  TextBufferSize,
                  TextBuffer
                  );

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] SMB for body of multi-block message. Size=%u\n",
                     SmbSize));
    }

    if ((status = NetpNetBiosSend(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to send body of multi-block message %lu\n",
                     status));
        return status;
    }

    //
    // Get response
    //
    if ((status = NetpNetBiosReceive(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      WS_SMB_BUFFER_SIZE,
                      (HANDLE) NULL,
                      &SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to receive verification to multi-"
                     "block message body %lu\n", status));
        return status;
    }

    if (! WsVerifySmb(
              SmbBuffer,
              SmbSize,
              SMB_COM_SEND_TEXT_MB_MESSAGE,
              &SmbReturnClass,
              &SmbReturnCode
              )) {
        return NERR_NetworkError;      // Unexpected behaviour
    }

    return WsMapSmbStatus(SmbReturnClass, SmbReturnCode);
}


NET_API_STATUS
WsSendSingleBlockMessage(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  LPTSTR ToName,
    IN  LPTSTR FromName,
    IN  PCHAR Message,
    IN  WORD MessageSize
    )
/*++

Routine Description:

    This function sends a directed message in one SMB on a session we had
    established earlier.   It waits for an acknowlegement from the recipient.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of a session established with
        NetBIOS CALL and LISTEN commands.

    ToName - Supplies the name of the recipient.

    FromName - Supplies the name of the sender.

    Message - Supplies the buffer of the message to be sent.

    MessageSize - Supplies the size of the message.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    UCHAR SmbBuffer[WS_SMB_BUFFER_SIZE];
    WORD SmbSize;                        // Buffer length

    UCHAR SmbReturnClass;
    USHORT SmbReturnCode;

    LPSTR AnsiToName;
    LPSTR AnsiFromName;


    AnsiToName = NetpAllocStrFromWStr(ToName);
    if (AnsiToName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    AnsiFromName = NetpAllocStrFromWStr(FromName);
    if (AnsiFromName == NULL) {
        NetApiBufferFree(AnsiToName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SmbSize = WsMakeSmb(
                  SmbBuffer,
                  SMB_COM_SEND_MESSAGE,
                  0,
                  "sst",
                  AnsiFromName,
                  AnsiToName,
                  MessageSize,
                  Message
                  );

    NetApiBufferFree(AnsiToName);
    NetApiBufferFree(AnsiFromName);

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(("[Wksta] Send single block message. Size=%u\n", SmbSize));
#if DBG
        NetpHexDump(SmbBuffer, SmbSize);
#endif
    }

    //
    // Send SMB
    //
    if ((status = NetpNetBiosSend(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to send single block message %lu\n",
                     status));
        return status;
    }

    //
    // Get response
    //
    if ((status = NetpNetBiosReceive(
                      LanAdapterNumber,
                      SessionNumber,
                      SmbBuffer,
                      WS_SMB_BUFFER_SIZE,
                      (HANDLE) NULL,
                      &SmbSize
                      )) != NERR_Success) {
        NetpKdPrint(("[Wksta] Failed to receive verification to single"
                     " block message %lu\n", status));
        return status;
    }

    if (! WsVerifySmb(
              SmbBuffer,
              SmbSize,
              SMB_COM_SEND_MESSAGE,
              &SmbReturnClass,
              &SmbReturnCode
              )) {
        return NERR_NetworkError;      // Unexpected behaviour
    }

    return WsMapSmbStatus(SmbReturnClass, SmbReturnCode);
}



STATIC
BOOL
WsVerifySmb(
    IN  PUCHAR SmbBuffer,
    IN  WORD SmbBufferSize,
    IN  UCHAR SmbFunctionCode,
    OUT PUCHAR SmbReturnClass,
    OUT PUSHORT SmbReturnCode
    )
/*++

Routine Description:

    This function checks the format of a received SMB; it returns TRUE if
    if the SMB format is valid, and FALSE otherwise.

Arguments:

    SmbBuffer - Supplies the SMB buffer

    SmbBufferSize - Supplies the size of SmbBuffer in bytes

    SmbFunctionCode - Supplies the function code for which the SMB is received
        to determine the proper SMB format.

    SmbReturnClass - Returns the class of the SMB only if the SMB format is
        valid.

    SmbReturnCode - Returns the error code of the SMB.

Return Value:

    TRUE if SMB is valid; FALSE otherwise.

--*/
{
    PSMB_HEADER Smb = (PSMB_HEADER) SmbBuffer;       // Pointer to SMB header
    int SmbCheckCode;
    int ParameterCount;

    //
    // Assume error
    //
    *SmbReturnClass = (UCHAR) 0xff;

    *SmbReturnCode = Smb->Error;

    switch (SmbFunctionCode) {
        case SMB_COM_SEND_MESSAGE:          // Single-block message
        case SMB_COM_SEND_TEXT_MB_MESSAGE:  // Text of multi-block message
        case SMB_COM_SEND_END_MB_MESSAGE:   // End of multi-block message
            ParameterCount = 0;
            break;

        case SMB_COM_SEND_START_MB_MESSAGE: // Beginning of multi-block message
            ParameterCount = 1;
            break;

        default:                            // Unknown SMB
            NetpKdPrint(("[Wksta] WsVerifySmb unknown SMB\n"));
            return FALSE;
      }

      if (! (SmbCheckCode = NetpSmbCheck(
                                SmbBuffer,
                                SmbBufferSize,
                                SmbFunctionCode,
                                ParameterCount,
                                ""
                                ))) {

        //
        // Set the return class if valid SMB
        //
        *SmbReturnClass = Smb->ErrorClass;
        return TRUE;

      }
      else {
        //
        // Invalid SMB
        //
        NetpKdPrint(("[Wksta] WsVerifySmb invalid SMB %d\n", SmbCheckCode));
        return FALSE;
      }
}


STATIC
NET_API_STATUS
WsMapSmbStatus(
    UCHAR SmbReturnClass,
    USHORT SmbReturnCode
    )
/*++

Routine Description:

    This function converts an SMB status to API status.

Arguments:

    SmbReturnClass - Supplies the SMB class

    SmbReturnCode - Supplies the SMB return code.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    switch (SmbReturnClass) {

        case SMB_ERR_SUCCESS:
            return NERR_Success;

        case SMB_ERR_CLASS_SERVER:
            //
            // SMB error
            //
            NetpKdPrint(("[Wksta] SMB error SmbReturnCode=%u\n", SmbReturnCode));

            if (SmbReturnCode == SMB_ERR_SERVER_PAUSED) {
                return NERR_PausedRemote;    // Server paused
            }
            else {
                return NERR_BadReceive;      // Send not received
            }

            break;

        default:
             return NERR_BadReceive;
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wsutil.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsutil.h

Abstract:

    Private header file for the NT Workstation service included by every module
    module of the Workstation service.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _WSUTIL_INCLUDED_
#define _WSUTIL_INCLUDED_

#if _PNP_POWER
#define RDR_PNP_POWER   1
#endif

//
// This include file will be included by tstring.h if Unicode
// is defined.
//
#ifndef UNICODE
#include <stdlib.h>                     // Unicode string functions
#endif

#include "ws.h"


#define INITIAL_USER_COUNT        10   // Initial table size is for
                                       //    number of logged on users

#define GROW_USER_COUNT            5   // When initial size is not enough,
                                       //    grow table for additional users


#define MAX_SINGLE_MESSAGE_SIZE  128   // Maximum size of a datagram message


//
// An invalid parameter is encountered.  Return the value to identify
// the parameter at fault.
//
#define RETURN_INVALID_PARAMETER(ErrorParameter, ParameterId) \
    if (ARGUMENT_PRESENT(ErrorParameter)) {                   \
        *ErrorParameter = ParameterId;                        \
    }                                                         \
    return ERROR_INVALID_PARAMETER;



//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef struct _PER_USER_ENTRY {
    PVOID List;                  // Pointer to linked list of user data
    LUID LogonId;                // Logon Id of user
} PER_USER_ENTRY, *PPER_USER_ENTRY;

typedef struct _USERS_OBJECT {
    PPER_USER_ENTRY Table;       // Table of users
    RTL_RESOURCE TableResource;  // To serialize access to Table
    HANDLE TableMemory;          // Relocatable Table memory
    DWORD TableSize;             // Size of Table
} USERS_OBJECT, *PUSERS_OBJECT;


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes of utility routines found in wsutil.c         //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
WsInitializeUsersObject(
    IN  PUSERS_OBJECT Users
    );

VOID
WsDestroyUsersObject(
    IN  PUSERS_OBJECT Users
    );

NET_API_STATUS
WsGetUserEntry(
    IN  PUSERS_OBJECT Users,
    IN  PLUID LogonId,
    OUT PULONG Index,
    IN  BOOL IsAdd
    );

NET_API_STATUS
WsMapStatus(
    IN  NTSTATUS NtStatus
    );

int
WsCompareString(
    IN LPTSTR String1,
    IN DWORD Length1,
    IN LPTSTR String2,
    IN DWORD Length2
    );

int
WsCompareStringU(
    IN LPWSTR String1,
    IN DWORD Length1,
    IN LPTSTR String2,
    IN DWORD Length2
    );

BOOL
WsCopyStringToBuffer(
    IN  PUNICODE_STRING SourceString,
    IN  LPBYTE FixedPortion,
    IN  OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *DestinationStringPointer
    );

NET_API_STATUS
WsImpersonateClient(
    VOID
    );

NET_API_STATUS
WsRevertToSelf(
    VOID
    );

NET_API_STATUS
WsImpersonateAndGetLogonId(
    OUT PLUID LogonId
    );

NET_API_STATUS
WsImpersonateAndGetSessionId(
    OUT PULONG pSessionId
    );

NET_API_STATUS
WsOpenDestinationMailslot(
    IN  LPWSTR TargetName,
    IN  LPWSTR MailslotName,
    OUT PHANDLE MailslotHandle
    );

DWORD
WsInAWorkgroup(
    VOID
    );

VOID
WsPreInitializeMessageSend(
    VOID
    );

#endif // ifndef _WSUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcdlls\wkssvc\server\wswksta.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wswksta.h

Abstract:

    Private header file to be included by Workstation service module that
    implement the NetWksta APIs.

Author:

    Rita Wong (ritaw) 05-Mar-1991

Revision History:

--*/

#ifndef _WSWKSTA_INCLUDED_
#define _WSWKSTA_INCLUDED_

typedef struct _WSNAME_RECORD {
    LPTSTR Name;
    DWORD Size;
    BOOL IsAdded;
} WSNAME_RECORD, *PWSNAME_RECORD;

typedef struct _WSPER_USER_INFO {
    PMSV1_0_GETUSERINFO_RESPONSE LsaUserInfo;
    PDGRECEIVE_NAMES DgrNames;
    DWORD DgrNamesCount;
} WSPER_USER_INFO, *PWSPER_USER_INFO;

#define DGR_NAME_DELETED    (DGRECEIVER_NAME_TYPE) MAXULONG


#define SYSTEM_INFO_FIXED_LENGTH(Level)               \
    (DWORD)((Level == 102) ? sizeof(WKSTA_INFO_102) : \
                             sizeof(WKSTA_INFO_101))


#define SET_SYSTEM_INFO_POINTER(WkstaInfo, ResultBuffer)  \
    WkstaInfo->WkstaInfo100 = (PWKSTA_INFO_100) ResultBuffer;

#define SET_USER_INFO_POINTER(UserInfo, ResultBuffer)     \
    UserInfo->UserInfo0 = (PWKSTA_USER_INFO_0) ResultBuffer;

#define SET_TRANSPORT_ENUM_POINTER(TransportInfo, ResultBuffer, NumRead)      \
    {                                                                         \
        if (TransportInfo->WkstaTransportInfo.Level0 != NULL) {               \
            TransportInfo->WkstaTransportInfo.Level0->Buffer =                \
                (PWKSTA_TRANSPORT_INFO_0) ResultBuffer;                       \
            TransportInfo->WkstaTransportInfo.Level0->EntriesRead = NumRead;  \
        }                                                                     \
     }

//
// Length of fixed size portion of a user info structure
//
#define USER_FIXED_LENGTH(Level)                                          \
    (DWORD)                                                               \
    ((Level == 0) ? sizeof(WKSTA_USER_INFO_0) :                           \
                    ((Level == 1) ? sizeof(WKSTA_USER_INFO_1) :           \
                                    sizeof(WKSTA_USER_INFO_1101)))

#define FIXED_PLUS_LSA_SIZE(Level, UserNameSize, LogonDomainSize,         \
                            LogonServerSize)                              \
    (DWORD)                                                               \
    ((Level == 0) ? UserNameSize + sizeof(WKSTA_USER_INFO_0) :            \
        UserNameSize + LogonDomainSize + LogonServerSize +                \
        sizeof(WKSTA_USER_INFO_1))


NET_API_STATUS
WsUpdateRedirToMatchWksta(
    IN DWORD Parmnum,
    OUT LPDWORD ErrorParameter OPTIONAL
    );


#endif // _WSWKSTA_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repconn.c ===
/*++

WARNING!!!

	This file is automatically generated and should never be changed.
	All changes should be made to the NTFRSCON.int file.

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	REPCONN.c

Abstract

	This is the file that conatins the initialization values of the PERF_COUNTER_DEFINITION
	array which is initialized in the Open function of the REPLICACONN Object

Environment:

	User Mode Service

Revision History:

--*/

#include "..\PERFDLL\REPCONN.h"

// Initialize the RepConnInitData structure used in the Open function

ReplicaConnValues RepConnInitData[FRC_NUMOFCOUNTERS] = {

	{
	(PWCHAR)"Packets Sent in Bytes            ",
	SIZEOF(ReplicaConnCounters, PacketsSentBytes     ),
	OFFSET(ReplicaConnCounters, PacketsSentBytes     ),
	PERF_COUNTER_BULK_COUNT ,   0    
	},

	{
	(PWCHAR)"Fetch Blocks Sent in Bytes       ",
	SIZEOF(ReplicaConnCounters, FetBSentBytes        ),
	OFFSET(ReplicaConnCounters, FetBSentBytes        ),
	PERF_COUNTER_BULK_COUNT ,   0    
	},

	{
	(PWCHAR)"Fetch Blocks Received in Bytes   ",
	SIZEOF(ReplicaConnCounters, FetBRcvdBytes        ),
	OFFSET(ReplicaConnCounters, FetBRcvdBytes        ),
	PERF_COUNTER_BULK_COUNT ,   0    
	},

	{
	(PWCHAR)"Local Change Orders Sent         ",
	SIZEOF(ReplicaConnCounters, LCOSent              ),
	OFFSET(ReplicaConnCounters, LCOSent              ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Local Change Orders Sent At Join ",
	SIZEOF(ReplicaConnCounters, LCOSentAtJoin        ),
	OFFSET(ReplicaConnCounters, LCOSentAtJoin        ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Remote Change Orders Sent        ",
	SIZEOF(ReplicaConnCounters, RCOSent              ),
	OFFSET(ReplicaConnCounters, RCOSent              ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Remote Change Orders Received    ",
	SIZEOF(ReplicaConnCounters, RCOReceived          ),
	OFFSET(ReplicaConnCounters, RCOReceived          ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Inbound Change Orders Dampened   ",
	SIZEOF(ReplicaConnCounters, InCODampned          ),
	OFFSET(ReplicaConnCounters, InCODampned          ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Outbound Change Orders Dampened  ",
	SIZEOF(ReplicaConnCounters, OutCODampned         ),
	OFFSET(ReplicaConnCounters, OutCODampned         ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Packets Sent                     ",
	SIZEOF(ReplicaConnCounters, PacketsSent          ),
	OFFSET(ReplicaConnCounters, PacketsSent          ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Packets Sent in Error            ",
	SIZEOF(ReplicaConnCounters, PacketsSentError     ),
	OFFSET(ReplicaConnCounters, PacketsSentError     ),
	PERF_COUNTER_RAWCOUNT   ,   0    
	},

	{
	(PWCHAR)"Communication Timeouts           ",
	SIZEOF(ReplicaConnCounters, CommTimeouts         ),
	OFFSET(ReplicaConnCounters, CommTimeouts         ),
	PERF_COUNTER_RAWCOUNT   ,   0    
	},

	{
	(PWCHAR)"Fetch Requests Sent              ",
	SIZEOF(ReplicaConnCounters, FetRSent             ),
	OFFSET(ReplicaConnCounters, FetRSent             ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Fetch Requests Received          ",
	SIZEOF(ReplicaConnCounters, FetRReceived         ),
	OFFSET(ReplicaConnCounters, FetRReceived         ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Fetch Blocks Sent                ",
	SIZEOF(ReplicaConnCounters, FetBSent             ),
	OFFSET(ReplicaConnCounters, FetBSent             ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Fetch Blocks Received            ",
	SIZEOF(ReplicaConnCounters, FetBRcvd             ),
	OFFSET(ReplicaConnCounters, FetBRcvd             ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Join Notifications Sent          ",
	SIZEOF(ReplicaConnCounters, JoinNSent            ),
	OFFSET(ReplicaConnCounters, JoinNSent            ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Join Notifications Received      ",
	SIZEOF(ReplicaConnCounters, JoinNRcvd            ),
	OFFSET(ReplicaConnCounters, JoinNRcvd            ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Joins                            ",
	SIZEOF(ReplicaConnCounters, Joins                ),
	OFFSET(ReplicaConnCounters, Joins                ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Unjoins                          ",
	SIZEOF(ReplicaConnCounters, Unjoins              ),
	OFFSET(ReplicaConnCounters, Unjoins              ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Bindings                         ",
	SIZEOF(ReplicaConnCounters, Bindings             ),
	OFFSET(ReplicaConnCounters, Bindings             ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Bindings in Error                ",
	SIZEOF(ReplicaConnCounters, BindingsError        ),
	OFFSET(ReplicaConnCounters, BindingsError        ),
	PERF_COUNTER_RAWCOUNT   ,   0    
	},

	{
	(PWCHAR)"Authentications                  ",
	SIZEOF(ReplicaConnCounters, Authentications      ),
	OFFSET(ReplicaConnCounters, Authentications      ),
	PERF_COUNTER_COUNTER    ,   0    
	},

	{
	(PWCHAR)"Authentications in Error         ",
	SIZEOF(ReplicaConnCounters, AuthenticationsError ),
	OFFSET(ReplicaConnCounters, AuthenticationsError ),
	PERF_COUNTER_RAWCOUNT   ,   0    
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\repset.c ===
/*++

WARNING!!!

	This file is automatically generated and should never be changed.
	All changes should be made to the NTFRSREP.int file.

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	REPSET.c

Abstract

	This is the file that conatins the initialization values of the PERF_COUNTER_DEFINITION
	array which is initialized in the Open function of the REPLICASET Object

Environment:

	User Mode Service

Revision History:

--*/

#include "..\PERFDLL\REPSET.h"

// Initialize the RepSetInitData structure used in the Open function

ReplicaSetValues RepSetInitData[FRS_NUMOFCOUNTERS] = {

	{
	(PWCHAR)"Bytes of Staging Generated              ",
	SIZEOF(ReplicaSetCounters, SFGeneratedB         ),
	OFFSET(ReplicaSetCounters, SFGeneratedB         ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"Bytes of Staging Fetched                ",
	SIZEOF(ReplicaSetCounters, SFFetchedB           ),
	OFFSET(ReplicaSetCounters, SFFetchedB           ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"Bytes of Staging Regenerated            ",
	SIZEOF(ReplicaSetCounters, SFReGeneratedB       ),
	OFFSET(ReplicaSetCounters, SFReGeneratedB       ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"Bytes of Files Installed                ",
	SIZEOF(ReplicaSetCounters, FInstalledB          ),
	OFFSET(ReplicaSetCounters, FInstalledB          ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"KB of Staging Space In Use              ",
	SIZEOF(ReplicaSetCounters, SSInUseKB            ),
	OFFSET(ReplicaSetCounters, SSInUseKB            ),
	PERF_COUNTER_LARGE_RAWCOUNT  , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"KB of Staging Space Free                ",
	SIZEOF(ReplicaSetCounters, SSFreeKB             ),
	OFFSET(ReplicaSetCounters, SSFreeKB             ),
	PERF_COUNTER_LARGE_RAWCOUNT  , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Packets Received in Bytes               ",
	SIZEOF(ReplicaSetCounters, PacketsRcvdBytes     ),
	OFFSET(ReplicaSetCounters, PacketsRcvdBytes     ),
	PERF_COUNTER_BULK_COUNT      , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Packets Sent in Bytes                   ",
	SIZEOF(ReplicaSetCounters, PacketsSentBytes     ),
	OFFSET(ReplicaSetCounters, PacketsSentBytes     ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"Fetch Blocks Sent in Bytes              ",
	SIZEOF(ReplicaSetCounters, FetBSentBytes        ),
	OFFSET(ReplicaSetCounters, FetBSentBytes        ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"Fetch Blocks Received in Bytes          ",
	SIZEOF(ReplicaSetCounters, FetBRcvdBytes        ),
	OFFSET(ReplicaSetCounters, FetBRcvdBytes        ),
	PERF_COUNTER_BULK_COUNT      ,         0             
	},

	{
	(PWCHAR)"Staging Files Generated                 ",
	SIZEOF(ReplicaSetCounters, SFGenerated          ),
	OFFSET(ReplicaSetCounters, SFGenerated          ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Staging Files Generated with Error      ",
	SIZEOF(ReplicaSetCounters, SFGeneratedError     ),
	OFFSET(ReplicaSetCounters, SFGeneratedError     ),
	PERF_COUNTER_RAWCOUNT        ,         0             
	},

	{
	(PWCHAR)"Staging Files Fetched                   ",
	SIZEOF(ReplicaSetCounters, SFFetched            ),
	OFFSET(ReplicaSetCounters, SFFetched            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Staging Files Regenerated               ",
	SIZEOF(ReplicaSetCounters, SFReGenerated        ),
	OFFSET(ReplicaSetCounters, SFReGenerated        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Files Installed                         ",
	SIZEOF(ReplicaSetCounters, FInstalled           ),
	OFFSET(ReplicaSetCounters, FInstalled           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Files Installed with Error              ",
	SIZEOF(ReplicaSetCounters, FInstalledError      ),
	OFFSET(ReplicaSetCounters, FInstalledError      ),
	PERF_COUNTER_RAWCOUNT        ,         0             
	},

	{
	(PWCHAR)"Change Orders Issued                    ",
	SIZEOF(ReplicaSetCounters, COIssued             ),
	OFFSET(ReplicaSetCounters, COIssued             ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Retired                   ",
	SIZEOF(ReplicaSetCounters, CORetired            ),
	OFFSET(ReplicaSetCounters, CORetired            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Aborted                   ",
	SIZEOF(ReplicaSetCounters, COAborted            ),
	OFFSET(ReplicaSetCounters, COAborted            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Retried                   ",
	SIZEOF(ReplicaSetCounters, CORetried            ),
	OFFSET(ReplicaSetCounters, CORetried            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Retried at Generate       ",
	SIZEOF(ReplicaSetCounters, CORetriedGen         ),
	OFFSET(ReplicaSetCounters, CORetriedGen         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Retried at Fetch          ",
	SIZEOF(ReplicaSetCounters, CORetriedFet         ),
	OFFSET(ReplicaSetCounters, CORetriedFet         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Retried at Install        ",
	SIZEOF(ReplicaSetCounters, CORetriedIns         ),
	OFFSET(ReplicaSetCounters, CORetriedIns         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Retried at Rename         ",
	SIZEOF(ReplicaSetCounters, CORetriedRen         ),
	OFFSET(ReplicaSetCounters, CORetriedRen         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Morphed                   ",
	SIZEOF(ReplicaSetCounters, COMorphed            ),
	OFFSET(ReplicaSetCounters, COMorphed            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Propagated                ",
	SIZEOF(ReplicaSetCounters, COPropagated         ),
	OFFSET(ReplicaSetCounters, COPropagated         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Received                  ",
	SIZEOF(ReplicaSetCounters, COReceived           ),
	OFFSET(ReplicaSetCounters, COReceived           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Sent                      ",
	SIZEOF(ReplicaSetCounters, COSent               ),
	OFFSET(ReplicaSetCounters, COSent               ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Change Orders Evaporated                ",
	SIZEOF(ReplicaSetCounters, COEvaporated         ),
	OFFSET(ReplicaSetCounters, COEvaporated         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Issued              ",
	SIZEOF(ReplicaSetCounters, LCOIssued            ),
	OFFSET(ReplicaSetCounters, LCOIssued            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Retired             ",
	SIZEOF(ReplicaSetCounters, LCORetired           ),
	OFFSET(ReplicaSetCounters, LCORetired           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Aborted             ",
	SIZEOF(ReplicaSetCounters, LCOAborted           ),
	OFFSET(ReplicaSetCounters, LCOAborted           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Retried             ",
	SIZEOF(ReplicaSetCounters, LCORetried           ),
	OFFSET(ReplicaSetCounters, LCORetried           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Retried at Generate ",
	SIZEOF(ReplicaSetCounters, LCORetriedGen        ),
	OFFSET(ReplicaSetCounters, LCORetriedGen        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Retried at Fetch    ",
	SIZEOF(ReplicaSetCounters, LCORetriedFet        ),
	OFFSET(ReplicaSetCounters, LCORetriedFet        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Retried at Install  ",
	SIZEOF(ReplicaSetCounters, LCORetriedIns        ),
	OFFSET(ReplicaSetCounters, LCORetriedIns        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Retried at Rename   ",
	SIZEOF(ReplicaSetCounters, LCORetriedRen        ),
	OFFSET(ReplicaSetCounters, LCORetriedRen        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Morphed             ",
	SIZEOF(ReplicaSetCounters, LCOMorphed           ),
	OFFSET(ReplicaSetCounters, LCOMorphed           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Propagated          ",
	SIZEOF(ReplicaSetCounters, LCOPropagated        ),
	OFFSET(ReplicaSetCounters, LCOPropagated        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Sent                ",
	SIZEOF(ReplicaSetCounters, LCOSent              ),
	OFFSET(ReplicaSetCounters, LCOSent              ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Local Change Orders Sent At Join        ",
	SIZEOF(ReplicaSetCounters, LCOSentAtJoin        ),
	OFFSET(ReplicaSetCounters, LCOSentAtJoin        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Issued             ",
	SIZEOF(ReplicaSetCounters, RCOIssued            ),
	OFFSET(ReplicaSetCounters, RCOIssued            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Retired            ",
	SIZEOF(ReplicaSetCounters, RCORetired           ),
	OFFSET(ReplicaSetCounters, RCORetired           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Aborted            ",
	SIZEOF(ReplicaSetCounters, RCOAborted           ),
	OFFSET(ReplicaSetCounters, RCOAborted           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Retried            ",
	SIZEOF(ReplicaSetCounters, RCORetried           ),
	OFFSET(ReplicaSetCounters, RCORetried           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Retried at Generate",
	SIZEOF(ReplicaSetCounters, RCORetriedGen        ),
	OFFSET(ReplicaSetCounters, RCORetriedGen        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Retried at Fetch   ",
	SIZEOF(ReplicaSetCounters, RCORetriedFet        ),
	OFFSET(ReplicaSetCounters, RCORetriedFet        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Retried at Install ",
	SIZEOF(ReplicaSetCounters, RCORetriedIns        ),
	OFFSET(ReplicaSetCounters, RCORetriedIns        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Retried at Rename  ",
	SIZEOF(ReplicaSetCounters, RCORetriedRen        ),
	OFFSET(ReplicaSetCounters, RCORetriedRen        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Morphed            ",
	SIZEOF(ReplicaSetCounters, RCOMorphed           ),
	OFFSET(ReplicaSetCounters, RCOMorphed           ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Propagated         ",
	SIZEOF(ReplicaSetCounters, RCOPropagated        ),
	OFFSET(ReplicaSetCounters, RCOPropagated        ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Sent               ",
	SIZEOF(ReplicaSetCounters, RCOSent              ),
	OFFSET(ReplicaSetCounters, RCOSent              ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Remote Change Orders Received           ",
	SIZEOF(ReplicaSetCounters, RCOReceived          ),
	OFFSET(ReplicaSetCounters, RCOReceived          ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Inbound Change Orders Dampened          ",
	SIZEOF(ReplicaSetCounters, InCODampned          ),
	OFFSET(ReplicaSetCounters, InCODampned          ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Outbound Change Orders Dampened         ",
	SIZEOF(ReplicaSetCounters, OutCODampned         ),
	OFFSET(ReplicaSetCounters, OutCODampned         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Usn Reads                               ",
	SIZEOF(ReplicaSetCounters, UsnReads             ),
	OFFSET(ReplicaSetCounters, UsnReads             ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Usn Records Examined                    ",
	SIZEOF(ReplicaSetCounters, UsnRecExamined       ),
	OFFSET(ReplicaSetCounters, UsnRecExamined       ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Usn Records Accepted                    ",
	SIZEOF(ReplicaSetCounters, UsnRecAccepted       ),
	OFFSET(ReplicaSetCounters, UsnRecAccepted       ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Usn Records Rejected                    ",
	SIZEOF(ReplicaSetCounters, UsnRecRejected       ),
	OFFSET(ReplicaSetCounters, UsnRecRejected       ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Packets Received                        ",
	SIZEOF(ReplicaSetCounters, PacketsRcvd          ),
	OFFSET(ReplicaSetCounters, PacketsRcvd          ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Packets Received in Error               ",
	SIZEOF(ReplicaSetCounters, PacketsRcvdError     ),
	OFFSET(ReplicaSetCounters, PacketsRcvdError     ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Packets Sent                            ",
	SIZEOF(ReplicaSetCounters, PacketsSent          ),
	OFFSET(ReplicaSetCounters, PacketsSent          ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Packets Sent in Error                   ",
	SIZEOF(ReplicaSetCounters, PacketsSentError     ),
	OFFSET(ReplicaSetCounters, PacketsSentError     ),
	PERF_COUNTER_RAWCOUNT        ,         0             
	},

	{
	(PWCHAR)"Communication Timeouts                  ",
	SIZEOF(ReplicaSetCounters, CommTimeouts         ),
	OFFSET(ReplicaSetCounters, CommTimeouts         ),
	PERF_COUNTER_RAWCOUNT        ,         0             
	},

	{
	(PWCHAR)"Fetch Requests Sent                     ",
	SIZEOF(ReplicaSetCounters, FetRSent             ),
	OFFSET(ReplicaSetCounters, FetRSent             ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Fetch Requests Received                 ",
	SIZEOF(ReplicaSetCounters, FetRReceived         ),
	OFFSET(ReplicaSetCounters, FetRReceived         ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Fetch Blocks Sent                       ",
	SIZEOF(ReplicaSetCounters, FetBSent             ),
	OFFSET(ReplicaSetCounters, FetBSent             ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Fetch Blocks Received                   ",
	SIZEOF(ReplicaSetCounters, FetBRcvd             ),
	OFFSET(ReplicaSetCounters, FetBRcvd             ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Join Notifications Sent                 ",
	SIZEOF(ReplicaSetCounters, JoinNSent            ),
	OFFSET(ReplicaSetCounters, JoinNSent            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Join Notifications Received             ",
	SIZEOF(ReplicaSetCounters, JoinNRcvd            ),
	OFFSET(ReplicaSetCounters, JoinNRcvd            ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Joins                                   ",
	SIZEOF(ReplicaSetCounters, Joins                ),
	OFFSET(ReplicaSetCounters, Joins                ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Unjoins                                 ",
	SIZEOF(ReplicaSetCounters, Unjoins              ),
	OFFSET(ReplicaSetCounters, Unjoins              ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Bindings                                ",
	SIZEOF(ReplicaSetCounters, Bindings             ),
	OFFSET(ReplicaSetCounters, Bindings             ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Bindings in Error                       ",
	SIZEOF(ReplicaSetCounters, BindingsError        ),
	OFFSET(ReplicaSetCounters, BindingsError        ),
	PERF_COUNTER_RAWCOUNT        ,         0             
	},

	{
	(PWCHAR)"Authentications                         ",
	SIZEOF(ReplicaSetCounters, Authentications      ),
	OFFSET(ReplicaSetCounters, Authentications      ),
	PERF_COUNTER_COUNTER         ,         0             
	},

	{
	(PWCHAR)"Authentications in Error                ",
	SIZEOF(ReplicaSetCounters, AuthenticationsError ),
	OFFSET(ReplicaSetCounters, AuthenticationsError ),
	PERF_COUNTER_RAWCOUNT        ,         0             
	},

	{
	(PWCHAR)"DS Polls                                ",
	SIZEOF(ReplicaSetCounters, DSPolls              ),
	OFFSET(ReplicaSetCounters, DSPolls              ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Polls without Changes                ",
	SIZEOF(ReplicaSetCounters, DSPollsWOChanges     ),
	OFFSET(ReplicaSetCounters, DSPollsWOChanges     ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Polls with Changes                   ",
	SIZEOF(ReplicaSetCounters, DSPollsWChanges      ),
	OFFSET(ReplicaSetCounters, DSPollsWChanges      ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Searches                             ",
	SIZEOF(ReplicaSetCounters, DSSearches           ),
	OFFSET(ReplicaSetCounters, DSSearches           ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Searches in Error                    ",
	SIZEOF(ReplicaSetCounters, DSSearchesError      ),
	OFFSET(ReplicaSetCounters, DSSearchesError      ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Objects                              ",
	SIZEOF(ReplicaSetCounters, DSObjects            ),
	OFFSET(ReplicaSetCounters, DSObjects            ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Objects in Error                     ",
	SIZEOF(ReplicaSetCounters, DSObjectsError       ),
	OFFSET(ReplicaSetCounters, DSObjectsError       ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Bindings                             ",
	SIZEOF(ReplicaSetCounters, DSBindings           ),
	OFFSET(ReplicaSetCounters, DSBindings           ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"DS Bindings in Error                    ",
	SIZEOF(ReplicaSetCounters, DSBindingsError      ),
	OFFSET(ReplicaSetCounters, DSBindingsError      ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Replica Sets Created                    ",
	SIZEOF(ReplicaSetCounters, RSCreated            ),
	OFFSET(ReplicaSetCounters, RSCreated            ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Replica Sets Deleted                    ",
	SIZEOF(ReplicaSetCounters, RSDeleted            ),
	OFFSET(ReplicaSetCounters, RSDeleted            ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Replica Sets Removed                    ",
	SIZEOF(ReplicaSetCounters, RSRemoved            ),
	OFFSET(ReplicaSetCounters, RSRemoved            ),
	PERF_COUNTER_RAWCOUNT        , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Replica Sets Started                    ",
	SIZEOF(ReplicaSetCounters, RSStarted            ),
	OFFSET(ReplicaSetCounters, RSStarted            ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Threads started                         ",
	SIZEOF(ReplicaSetCounters, ThreadsStarted       ),
	OFFSET(ReplicaSetCounters, ThreadsStarted       ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	},

	{
	(PWCHAR)"Threads exited                          ",
	SIZEOF(ReplicaSetCounters, ThreadsExited        ),
	OFFSET(ReplicaSetCounters, ThreadsExited        ),
	PERF_COUNTER_COUNTER         , PM_RS_FLAG_SVC_WIDE   
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\eventdmp\eventdmp.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lm.h>

#define MAX_DB_EINTRIES 256
#define MAX_SUB_STRINGS 8
#define MAX_SUB_STR_LEN 128
#define MAX_DESC_LEN  2048
#define SIZE_EVENT_BUFFER 0x8000

typedef struct _DBENTRY{
  DWORD     dwID;
  DWORD     dwTimeFirst;
  DWORD     dwTimeLast;
  DWORD     dwCount;
  char      szSource[64];
  char      szDescription[MAX_DESC_LEN];
  DWORD     dwNumStrings;
  char      szStrings[MAX_SUB_STRINGS][MAX_SUB_STR_LEN];
  } DBENTRY, *PDBENTRY;

typedef enum {
  ePlaceHolder,
  eDbg,
  eCon,
  eBoth
  } OUTPUTS;


#define SplitPrint() \
   if (enumOutput & eDbg) \
     DbgPrint(sp);\
   if (enumOutput & eCon)\
     printf(sp)

char             sp[256];
OUTPUTS          enumOutput=eCon;
BOOLEAN          bRemote = FALSE;
BOOLEAN          bFirst = TRUE;
char             szRemoteComputer[128];
HKEY             hRegistry = 0;



          DbgPrint(PCH x,...);
void      InitializeDatabase(void);
PDBENTRY  SearchDatabase(PEVENTLOGRECORD);
PDBENTRY  AddToDatabase(PEVENTLOGRECORD);
PDBENTRY  UpdateDatabase(PEVENTLOGRECORD,PDBENTRY);
void      DumpDatabase(void);
void      CleanupDatabase(void);
void      Usage(void);
void      PrintEventLogRecord(PEVENTLOGRECORD pelrEvent);


PDBENTRY  Database[MAX_DB_EINTRIES];


char      szLogType[128] = "System";

typedef struct _FRS_EL_ENTRY{
  DWORD     EventId;
  PCHAR     EventTag;
} FRS_EL_ENTRY, *PFRS_EL_ENTRY;

FRS_EL_ENTRY FrsEvents[] = {
    {13500 , "EVENT_FRS_ERROR"},
    {13501 , "EVENT_FRS_STARTING"},
    {13502 , "EVENT_FRS_STOPPING"},
    {13503 , "EVENT_FRS_STOPPED"},
    {13504 , "EVENT_FRS_STOPPED_FORCE"},
    {13505 , "EVENT_FRS_STOPPED_ASSERT"},
    {13506 , "EVENT_FRS_ASSERT"},
    {13507 , "EVENT_FRS_VOLUME_NOT_SUPPORTED"},
    {13508 , "EVENT_FRS_LONG_JOIN"},
    {13509 , "EVENT_FRS_LONG_JOIN_DONE"},
    {13510 , "EVENT_FRS_CANNOT_COMMUNICATE"},
    {13511 , "EVENT_FRS_DATABASE_SPACE"},
    {13512 , "EVENT_FRS_DISK_WRITE_CACHE_ENABLED"},
    {13513 , "EVENT_FRS_JET_1414"},
    {13514 , "EVENT_FRS_SYSVOL_NOT_READY"},
    {13515 , "EVENT_FRS_SYSVOL_NOT_READY_PRIMARY"},
    {13516 , "EVENT_FRS_SYSVOL_READY"},
    {13517 , "EVENT_FRS_ACCESS_CHECKS_DISABLED"},
    {13518 , "EVENT_FRS_ACCESS_CHECKS_FAILED_USER"},
    {13519 , "EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN"},
    {13520 , "EVENT_FRS_MOVED_PREEXISTING"},
    {13521 , "EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS"},
    {13522 , "EVENT_FRS_STAGING_AREA_FULL"},
    {13523 , "EVENT_FRS_HUGE_FILE"},
    {13524 , "EVENT_FRS_CANNOT_CREATE_UUID"},
    {13525 , "EVENT_FRS_NO_DNS_ATTRIBUTE"},
    {13526 , "EVENT_FRS_NO_SID"},
    {13527 , "NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET"},
    {13528 , "NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN"},
    {13529 , "NTFRSPRF_OPEN_RPC_CALL_ERROR_SET"},
    {13530 , "NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN"},
    {13531 , "NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET"},
    {13532 , "NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN"},
    {13533 , "NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET"},
    {13534 , "NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN"},
    {13535 , "NTFRSPRF_VIRTUALALLOC_ERROR_SET"},
    {13536 , "NTFRSPRF_VIRTUALALLOC_ERROR_CONN"},
    {13537 , "NTFRSPRF_REGISTRY_ERROR_SET"},
    {13538 , "NTFRSPRF_REGISTRY_ERROR_CONN"},
    {13539 , "EVENT_FRS_ROOT_NOT_VALID"},
    {13540 , "EVENT_FRS_STAGE_NOT_VALID"},
    {13541 , "EVENT_FRS_OVERLAPS_LOGGING"},
    {13542 , "EVENT_FRS_OVERLAPS_WORKING"},
    {13543 , "EVENT_FRS_OVERLAPS_STAGE"},
    {13544 , "EVENT_FRS_OVERLAPS_ROOT"},
    {13545 , "EVENT_FRS_OVERLAPS_OTHER_STAGE"},
    {13546 , "EVENT_FRS_PREPARE_ROOT_FAILED"},
    {13547 , "EVENT_FRS_BAD_REG_DATA"},
    {13548 , "EVENT_FRS_JOIN_FAIL_TIME_SKEW"},
    {13549 , "EVENT_FRS_RMTCO_TIME_SKEW"},
    {13550 , "EVENT_FRS_CANT_OPEN_STAGE"},
    {13551 , "EVENT_FRS_CANT_OPEN_PREINSTALL"},
    {13552 , "EVENT_FRS_REPLICA_SET_CREATE_FAIL"},
    {13553 , "EVENT_FRS_REPLICA_SET_CREATE_OK"},
    {13554 , "EVENT_FRS_REPLICA_SET_CXTIONS"},
    {13555 , "EVENT_FRS_IN_ERROR_STATE"},
    {13556 , "EVENT_FRS_REPLICA_NO_ROOT_CHANGE"},
    {13557 , "EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL"},
    {13558 , "EVENT_FRS_DUPLICATE_IN_CXTION"},
    {13559 , "EVENT_FRS_ROOT_HAS_MOVED"},
    {13560 , "EVENT_FRS_ERROR_REPLICA_SET_DELETED"},
    {13561 , "EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR"},
    {13562 , "EVENT_FRS_DS_POLL_ERROR_SUMMARY"},
    {13563 , "EVENT_FRS_STAGE_HAS_CHANGED"},
    {13564 , "EVENT_FRS_LOG_SPACE"},
    {13565 , "EVENT_FRS_SYSVOL_NOT_READY_2"},
    {13566 , "EVENT_FRS_SYSVOL_NOT_READY_PRIMARY_2"},
    {13567 , "EVENT_FRS_FILE_UPDATES_SUPPRESSED"},
    {13568 , "EVENT_FRS_REPLICA_IN_JRNL_WRAP_NO_AUTO_RESTORE"},
    {13569 , "EVENT_FRS_FILES_SKIPPED_DURING_PRIMARY_LOAD"},

    {0     , "Event tag not found"}

};



//
// The following was extracted from E:\nt\ds\ese98\src\ese\server\obj\i386\jetmsg.h
//

FRS_EL_ENTRY JetEvents[] = {

    {(0x00000001L), "GENERAL_CATEGORY"},
    {(0x00000002L), "BUFFER_MANAGER_CATEGORY"},
    {(0x00000003L), "LOGGING_RECOVERY_CATEGORY"},
    {(0x00000004L), "SPACE_MANAGER_CATEGORY"},
    {(0x00000005L), "DATA_DEFINITION_CATEGORY"},
    {(0x00000006L), "DATA_MANIPULATION_CATEGORY"},
    {(0x00000007L), "PERFORMANCE_CATEGORY"},
    {(0x00000008L), "REPAIR_CATEGORY"},
    {(0x00000009L), "CONVERSION_CATEGORY"},
    {(0x0000000AL), "ONLINE_DEFRAG_CATEGORY"},
    {(0x0000000BL), "SYSTEM_PARAMETER_CATEGORY"},
    {(0x0000000CL), "DATABASE_CORRUPTION_CATEGORY"},
    {(0x0000000DL), "DATABASE_ZEROING_CATEGORY"},
    {(0x0000000EL), "TRANSACTION_MANAGER_CATEGORY"},
    {(0x0000000FL), "RFS2_CATEGORY"},
    {(0x00000010L), "OS_SNAPSHOT_BACKUP"},
    {(0x00000011L), "MAC_CATEGORY"},
    {(0x00000064L), "START_ID"},
    {(0x00000065L), "STOP_ID"},
    {(0x00000066L), "START_INSTANCE_ID"},
    {(0x00000067L), "STOP_INSTANCE_ID"},
    {(0x00000068L), "STOP_INSTANCE_ID_WITH_ERROR"},
    {(0x000000C8L), "START_FULL_BACKUP_ID"},
    {(0x000000C9L), "START_INCREMENTAL_BACKUP_ID"},
    {(0x000000CAL), "STOP_BACKUP_ID"},
    {(0x000000CBL), "STOP_BACKUP_ERROR_ID"},
    {(0x000000CCL), "START_RESTORE_ID"},
    {(0x000000CDL), "STOP_RESTORE_ID"},
    {(0x000000CEL), "DATABASE_MISS_FULL_BACKUP_ERROR_ID"},
    {(0x000000CFL), "STOP_BACKUP_ERROR_ABORT_BY_CALLER"},
    {(0x000000D2L), "START_FULL_BACKUP_INSTANCE_ID"},
    {(0x000000D3L), "START_INCREMENTAL_BACKUP_INSTANCE_ID"},
    {(0x000000D4L), "START_SNAPSHOT_BACKUP_INSTANCE_ID"},
    {(0x000000D5L), "STOP_BACKUP_INSTANCE_ID"},
    {(0x000000D6L), "STOP_BACKUP_ERROR_INSTANCE_ID"},
    {(0x000000D7L), "STOP_BACKUP_ERROR_ABORT_BY_CALLER_INSTANCE_ID"},
    {(0x000000D8L), "DB_LOCATION_CHANGE_DETECTED"},
    {(0x000000D9L), "BACKUP_ERROR_FOR_ONE_DATABASE"},
    {(0x000000DAL), "BACKUP_ERROR_READ_FILE"},
    {(0x000000DBL), "BACKUP_ERROR_INFO_UPDATE"},
    {(0x000000DCL), "BACKUP_FILE_START"},
    {(0x000000DDL), "BACKUP_FILE_STOP_OK"},
    {(0x000000DEL), "BACKUP_FILE_STOP_BEFORE_END"},
    {(0x000000DFL), "BACKUP_LOG_FILES_START"},
    {(0x000000E0L), "BACKUP_TRUNCATE_LOG_FILES"},
    {(0x000000E1L), "BACKUP_NO_TRUNCATE_LOG_FILES"},
    {(0x0000012CL), "START_REDO_ID"},
    {(0x0000012DL), "STATUS_REDO_ID"},
    {(0x0000012EL), "STOP_REDO_ID"},
    {(0x0000012FL), "ERROR_ID"},
    {(0x00000190L), "S_O_READ_PAGE_TIME_ERROR_ID"},
    {(0x00000191L), "S_O_WRITE_PAGE_ISSUE_ERROR_ID"},
    {(0x00000192L), "S_O_WRITE_PAGE_ERROR_ID"},
    {(0x00000193L), "S_O_PATCH_FILE_WRITE_PAGE_ERROR_ID"},
    {(0x00000194L), "S_READ_PAGE_TIME_ERROR_ID"},
    {(0x00000195L), "PRE_READ_PAGE_TIME_ERROR_ID"},
    {(0x00000196L), "A_DIRECT_READ_PAGE_CORRUPTTED_ERROR_ID"},
    {(0x00000197L), "BFIO_TERM_ID"},
    {(0x00000198L), "LOG_WRITE_ERROR_ID"},
    {(0x00000199L), "LOG_HEADER_WRITE_ERROR_ID"},
    {(0x0000019AL), "LOG_READ_ERROR_ID"},
    {(0x0000019BL), "LOG_BAD_VERSION_ERROR_ID"},
    {(0x0000019CL), "LOG_HEADER_READ_ERROR_ID"},
    {(0x0000019DL), "NEW_LOG_ERROR_ID"},
    {(0x0000019EL), "LOG_FLUSH_WRITE_0_ERROR_ID"},
    {(0x0000019FL), "LOG_FLUSH_WRITE_1_ERROR_ID"},
    {(0x000001A0L), "LOG_FLUSH_WRITE_2_ERROR_ID"},
    {(0x000001A1L), "LOG_FLUSH_WRITE_3_ERROR_ID"},
    {(0x000001A2L), "LOG_FLUSH_OPEN_NEW_FILE_ERROR_ID"},
    {(0x000001A3L), "RESTORE_DATABASE_READ_PAGE_ERROR_ID"},
    {(0x000001A4L), "RESTORE_DATABASE_READ_HEADER_WARNING_ID"},
    {(0x000001A5L), "RESTORE_DATABASE_PARTIALLY_ERROR_ID"},
    {(0x000001A6L), "RESTORE_DATABASE_MISSED_ERROR_ID"},
    {(0x000001A7L), "BAD_PAGE"},
    {(0x000001A8L), "DISK_FULL_ERROR_ID"},
    {(0x000001A9L), "LOG_DATABASE_MISMATCH_ERROR_ID"},
    {(0x000001AAL), "FILE_NOT_FOUND_ERROR_ID"},
    {(0x000001ABL), "FILE_ACCESS_DENIED_ERROR_ID"},
    {(0x000001ACL), "LOW_LOG_DISK_SPACE"},
    {(0x000001ADL), "LOG_DISK_FULL"},
    {(0x000001AEL), "DATABASE_PATCH_FILE_MISMATCH_ERROR_ID"},
    {(0x000001AFL), "STARTING_RESTORE_LOG_TOO_HIGH_ERROR_ID"},
    {(0x000001B0L), "ENDING_RESTORE_LOG_TOO_LOW_ERROR_ID"},
    {(0x000001B1L), "RESTORE_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID"},
    {(0x000001B2L), "RESTORE_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID"},
    {(0x000001B3L), "RESTORE_LOG_FILE_MISSING_ERROR_ID"},
    {(0x000001B4L), "EXISTING_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID"},
    {(0x000001B5L), "EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID"},
    {(0x000001B6L), "BAD_BACKUP_DATABASE_SIZE"},
    {(0x000001B7L), "SHADOW_PAGE_WRITE_FAIL_ID"},
    {(0x000001B8L), "LOG_FILE_CORRUPTED_ID"},
    {(0x000001B9L), "DB_FILE_SYS_ERROR_ID"},
    {(0x000001BAL), "DB_IO_SIZE_ERROR_ID"},
    {(0x000001BBL), "LOG_FILE_SYS_ERROR_ID"},
    {(0x000001BCL), "LOG_IO_SIZE_ERROR_ID"},
    {(0x000001BDL), "SPACE_MAX_DB_SIZE_REACHED_ID"},
    {(0x000001BEL), "REDO_END_ABRUPTLY_ERROR_ID"},
    {(0x000001BFL), "BAD_PAGE_LINKS_ID"},
    {(0x000001C0L), "CORRUPT_LONG_VALUE_ID"},
    {(0x000001C1L), "CORRUPT_SLV_SPACE_ID"},
    {(0x000001C2L), "CURRENT_LOG_FILE_MISSING_ERROR_ID"},
    {(0x000001C3L), "LOG_FLUSH_WRITE_4_ERROR_ID"},
    {(0x000001C4L), "REDO_MISSING_LOW_LOG_ERROR_ID"},
    {(0x000001C5L), "REDO_MISSING_HIGH_LOG_ERROR_ID"},
    {(0x000001C6L), "RESTORE_DATABASE_FAIL_ID"},
    {(0x000001C7L), "LOG_OPEN_FILE_ERROR_ID"},
    {(0x000001C8L), "PRIMARY_PAGE_READ_FAIL_ID"},
    {(0x000001C9L), "EXISTING_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID_2"},
    {(0x000001CAL), "EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2"},
    {(0x000001CBL), "BACKUP_LOG_FILE_MISSING_ERROR_ID"},
    {(0x000001CCL), "LOG_TORN_WRITE_DURING_HARD_RESTORE_ID"},
    {(0x000001CDL), "LOG_TORN_WRITE_DURING_HARD_RECOVERY_ID"},
    {(0x000001CEL), "LOG_TORN_WRITE_DURING_SOFT_RECOVERY_ID"},
    {(0x000001CFL), "LOG_CORRUPTION_DURING_HARD_RESTORE_ID"},
    {(0x000001D0L), "LOG_CORRUPTION_DURING_HARD_RECOVERY_ID"},
    {(0x000001D1L), "LOG_CORRUPTION_DURING_SOFT_RECOVERY_ID"},
    {(0x000001D2L), "LOG_USING_SHADOW_SECTOR_ID"},
    {(0x000001D3L), "INDEX_CORRUPTED_ID"},
    {(0x000001D4L), "LOG_FLUSH_WRITE_5_ERROR_ID"},
    {(0x000001D6L), "DB_PARTIALLY_ATTACHED_ID"},
    {(0x000001D7L), "UNDO_FAILED_ID"},
    {(0x000001D8L), "SHADOW_PAGE_READ_FAIL_ID"},
    {(0x000001D9L), "DB_PARTIALLY_DETACHED_ID"},
    {(0x000001DAL), "DATABASE_PAGE_CHECKSUM_MISMATCH_ID"},
    {(0x000001DBL), "DATABASE_PAGE_NUMBER_MISMATCH_ID"},
    {(0x000001DCL), "DATABASE_PAGE_DATA_MISSING_ID"},
    {(0x000001DDL), "LOG_RANGE_CHECKSUM_MISMATCH_ID"},
    {(0x000001DEL), "SLV_PAGE_CHECKSUM_MISMATCH_ID"},
    {(0x000001DFL), "PATCH_PAGE_CHECKSUM_MISMATCH_ID"},
    {(0x000001E0L), "PATCH_PAGE_NUMBER_MISMATCH_ID"},
    {(0x000001E1L), "OSFILE_READ_ERROR_ID"},
    {(0x000001E2L), "OSFILE_WRITE_ERROR_ID"},
    {(0x000001E3L), "OSFS_CREATE_FOLDER_ERROR_ID"},
    {(0x000001E4L), "OSFS_REMOVE_FOLDER_ERROR_ID"},
    {(0x000001E5L), "OSFS_DELETE_FILE_ERROR_ID"},
    {(0x000001E6L), "OSFS_MOVE_FILE_ERROR_ID"},
    {(0x000001E7L), "OSFS_COPY_FILE_ERROR_ID"},
    {(0x000001E8L), "OSFS_CREATE_FILE_ERROR_ID"},
    {(0x000001E9L), "OSFS_OPEN_FILE_RO_ERROR_ID"},
    {(0x000001EAL), "OSFS_OPEN_FILE_RW_ERROR_ID"},
    {(0x000001EBL), "OSFS_SECTOR_SIZE_ERROR_ID"},
    {(0x000001ECL), "LOG_DOWN_ID"},
    {(0x000001EDL), "TRANSIENT_READ_ERROR_DETECTED_ID"},
    {(0x000001EEL), "ATTACHED_DB_MISMATCH_END_OF_RECOVERY_ID"},
    {(0x000001EFL), "ATTACHED_DB_MISMATCH_DURING_RECOVERY_ID"},
    {(0x000001F0L), "REDO_HIGH_LOG_MISMATCH_ERROR_ID"},
    {(0x000001F1L), "DATABASE_HEADER_ERROR_ID"},
    {(0x000001F2L), "DELETE_LOG_FILE_TOO_NEW_ID"},
    {(0x000001F3L), "DELETE_LAST_LOG_FILE_TOO_OLD_ID"},
    {(0x000001F4L), "REPAIR_BAD_PAGE_ID"},
    {(0x000001F5L), "REPAIR_PAGE_LINK_ID"},
    {(0x000001F6L), "REPAIR_BAD_COLUMN_ID"},
    {(0x000001F7L), "REPAIR_BAD_RECORD_ID"},
    {(0x000001F8L), "REPAIR_BAD_TABLE"},
    {(0x00000258L), "CONVERT_DUPLICATE_KEY"},
    {(0x00000259L), "FUNCTION_NOT_FOUND_ERROR_ID"},
    {(0x0000025AL), "MANY_LOST_COMPACTION_ID"},
    {(0x0000025BL), "SPACE_LOST_ON_FREE_ID"},
    {(0x0000025CL), "LANGUAGE_NOT_SUPPORTED_ID"},
    {(0x0000025DL), "CONVERT_COLUMN_TO_TAGGED_ID"},
    {(0x0000025EL), "CONVERT_COLUMN_TO_NONTAGGED_ID"},
    {(0x0000025FL), "CONVERT_COLUMN_BINARY_TO_LONGBINARY_ID"},
    {(0x00000260L), "CONVERT_COLUMN_TEXT_TO_LONGTEXT_ID"},
    {(0x00000261L), "START_INDEX_CLEANUP_KNOWN_VERSION_ID"},
    {(0x00000262L), "START_INDEX_CLEANUP_UNKNOWN_VERSION_ID"},
    {(0x00000263L), "DO_SECONDARY_INDEX_CLEANUP_ID"},
    {(0x00000264L), "STOP_INDEX_CLEANUP_ID"},
    {(0x00000265L), "PRIMARY_INDEX_CORRUPT_ERROR_ID"},
    {(0x00000266L), "SECONDARY_INDEX_CORRUPT_ERROR_ID"},
    {(0x00000267L), "START_FORMAT_UPGRADE_ID"},
    {(0x00000268L), "STOP_FORMAT_UPGRADE_ID"},
    {(0x00000269L), "CONVERT_INCOMPLETE_ERROR_ID"},
    {(0x0000026AL), "BUILD_SPACE_CACHE_ID"},
    {(0x0000026BL), "ATTACH_TO_BACKUP_SET_DATABASE_ERROR_ID"},
    {(0x0000026CL), "RECORD_FORMAT_CONVERSION_FAILED_ID"},
    {(0x0000026DL), "OUT_OF_OBJID"},
    {(0x0000026EL), "ALMOST_OUT_OF_OBJID"},
    {(0x0000026FL), "VERSION_STORE_REACHED_MAXIMUM_ID"},
    {(0x00000270L), "VERSION_STORE_OUT_OF_MEMORY_ID"},
    {(0x00000271L), "INVALID_LCMAPFLAGS_ID"},
    {(0x000002BCL), "OLD_BEGIN_FULL_PASS_ID"},
    {(0x000002BDL), "OLD_COMPLETE_FULL_PASS_ID"},
    {(0x000002BEL), "OLD_RESUME_PASS_ID"},
    {(0x000002BFL), "OLD_COMPLETE_RESUMED_PASS_ID"},
    {(0x000002C0L), "OLD_INTERRUPTED_PASS_ID"},
    {(0x000002C1L), "OLD_ERROR_ID"},
    {(0x000002C2L), "DATABASE_ZEROING_STARTED_ID"},
    {(0x000002C3L), "DATABASE_ZEROING_STOPPED_ID"},
    {(0x000002C4L), "OLDSLV_BEGIN_FULL_PASS_ID"},
    {(0x000002C5L), "OLDSLV_COMPLETE_FULL_PASS_ID"},
    {(0x000002C6L), "OLDSLV_SHRANK_DATABASE_ID"},
    {(0x000002C7L), "OLDSLV_ERROR_ID"},
    {(0x000002C8L), "DATABASE_SLV_ZEROING_STARTED_ID"},
    {(0x000002C9L), "DATABASE_SLV_ZEROING_STOPPED_ID"},
    {(0x000002CAL), "OLDSLV_STOP_ID"},
    {(0x00000320L), "SYS_PARAM_CACHEMIN_CSESS_ERROR_ID"},
    {(0x00000321L), "SYS_PARAM_CACHEMAX_CACHEMIN_ERROR_ID"},
    {(0x00000322L), "SYS_PARAM_CACHEMAX_STOPFLUSH_ERROR_ID"},
    {(0x00000323L), "SYS_PARAM_STOPFLUSH_STARTFLUSH_ERROR_ID"},
    {(0x00000324L), "SYS_PARAM_LOGBUFFER_FILE_ERROR_ID"},
    {(0x00000325L), "SYS_PARAM_MAXPAGES_PREFER_ID"},
    {(0x00000326L), "SYS_PARAM_VERPREFERREDPAGE_ID"},
    {(0x00000327L), "SYS_PARAM_CFCB_PREFER_ID"},
    {(0x00000328L), "SYS_PARAM_VERPREFERREDPAGETOOBIG_ID"},
    {(0x00000384L), "LOG_COMMIT0_FAIL_ID"},
    {(0x00000385L), "INTERNAL_TRACE_ID"},
    {(0x00000386L), "SESSION_SHARING_VIOLATION_ID"},
    {(0x00000387L), "SESSION_WRITE_CONFLICT_ID"},
    {(0x000007D1L), "OS_SNAPSHOT_FREEZE_START_ID"},
    {(0x000007D2L), "OS_SNAPSHOT_FREEZE_START_ERROR_ID"},
    {(0x000007D3L), "OS_SNAPSHOT_FREEZE_STOP_ID"},
    {(0x000007D4L), "OS_SNAPSHOT_TIME_OUT_ID"},
    {(0x000003E8L), "RFS2_INIT_ID"},
    {(0x000003E9L), "RFS2_PERMITTED_ID"},
    {(0x000003EAL), "RFS2_DENIED_ID"},
    {(0x000003EBL), "RFS2_JET_CALL_ID"},
    {(0x000003ECL), "RFS2_JET_ERROR_ID"},
    {(0x000007D0L), "OS_SNAPSHOT_TRACE_ID"},

    {0     , "Event tag not found"}

};


//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Below is from drivers\nlsmsg\ntiologc.mc
//
// FacilityNames=(System=0x0
//               RpcRuntime=0x2:FACILITY_RPC_RUNTIME
//               RpcStubs=0x3:FACILITY_RPC_STUBS
//               Io=0x4:FACILITY_IO_ERROR_CODE
//              )

FRS_EL_ENTRY SystemIoEvents[] = {
    {0x0001, "IO_ERR_RETRY_SUCCEEDED"},
    {0x0002, "IO_ERR_INSUFFICIENT_RESOURCES"},
    {0x0003, "IO_ERR_CONFIGURATION_ERROR"},
    {0x0004, "IO_ERR_DRIVER_ERROR"},
    {0x0005, "IO_ERR_PARITY"},
    {0x0006, "IO_ERR_SEEK_ERROR"},
    {0x0007, "IO_ERR_BAD_BLOCK"},
    {0x0008, "IO_ERR_OVERRUN_ERROR"},
    {0x0009, "IO_ERR_TIMEOUT"},
    {0x000a, "IO_ERR_SEQUENCE"},
    {0x000b, "IO_ERR_CONTROLLER_ERROR"},
    {0x000c, "IO_ERR_INTERNAL_ERROR"},
    {0x000d, "IO_ERR_INCORRECT_IRQL"},
    {0x000e, "IO_ERR_INVALID_IOBASE"},
    {0x000f, "IO_ERR_NOT_READY"},
    {0x0010, "IO_ERR_INVALID_REQUEST"},
    {0x0011, "IO_ERR_VERSION"},
    {0x0012, "IO_ERR_LAYERED_FAILURE"},
    {0x0013, "IO_ERR_RESET"},
    {0x0014, "IO_ERR_PROTOCOL"},
    {0x0015, "IO_ERR_MEMORY_CONFLICT_DETECTED"},
    {0x0016, "IO_ERR_PORT_CONFLICT_DETECTED"},
    {0x0017, "IO_ERR_DMA_CONFLICT_DETECTED"},
    {0x0018, "IO_ERR_IRQ_CONFLICT_DETECTED"},
    {0x0019, "IO_ERR_BAD_FIRMWARE"},
    {0x001a, "IO_WRN_BAD_FIRMWARE"},
    {0x001b, "IO_ERR_DMA_RESOURCE_CONFLICT"},
    {0x001c, "IO_ERR_INTERRUPT_RESOURCE_CONFLICT"},
    {0x001d, "IO_ERR_MEMORY_RESOURCE_CONFLICT"},
    {0x001e, "IO_ERR_PORT_RESOURCE_CONFLICT"},
    {0x001f, "IO_BAD_BLOCK_WITH_NAME"},
    {0x0020, "IO_WRITE_CACHE_ENABLED"},
    {0x0021, "IO_RECOVERED_VIA_ECC"},
    {0x0022, "IO_WRITE_CACHE_DISABLED"},
    {0x0024, "IO_FILE_QUOTA_THRESHOLD"},
    {0x0025, "IO_FILE_QUOTA_LIMIT"},
    {0x0026, "IO_FILE_QUOTA_STARTED"},
    {0x0027, "IO_FILE_QUOTA_SUCCEEDED"},
    {0x0028, "IO_FILE_QUOTA_FAILED"},
    {0x0029, "IO_FILE_SYSTEM_CORRUPT"},
    {0x002a, "IO_FILE_QUOTA_CORRUPT"},
    {0x002b, "IO_SYSTEM_SLEEP_FAILED"},
    {0x002c, "IO_DUMP_POINTER_FAILURE"},
    {0x002d, "IO_DUMP_DRIVER_LOAD_FAILURE"},
    {0x002e, "IO_DUMP_INITIALIZATION_FAILURE"},
    {0x002f, "IO_DUMP_DUMPFILE_CONFLICT"},
    {0x0030, "IO_DUMP_DIRECT_CONFIG_FAILED"},
    {0x0031, "IO_DUMP_PAGE_CONFIG_FAILED"},
    {0x0032, "IO_LOST_DELAYED_WRITE"},
    {0x0033, "IO_WARNING_PAGING_FAILURE"},
    {0x0034, "IO_WRN_FAILURE_PREDICTED"},
    {0x0035, "IO_WARNING_INTERRUPT_STILL_PENDING"},
    {0x0036, "IO_DRIVER_CANCEL_TIMEOUT"},
    {0x0037, "IO_FILE_SYSTEM_CORRUPT_WITH_NAME"},
    {0x0038, "IO_WARNING_ALLOCATION_FAILED"},
    {0x0039, "IO_WARNING_LOG_FLUSH_FAILED"},
    {0     , "Event tag not found"}

};




// The following came from \base\subsys\sm\sfc\dll\msg.mc
FRS_EL_ENTRY WindowsFileProtEvents[] = {
    {0xfa00,  "MSG_DLL_CHANGE"},
    {0xfa01,  "MSG_DLL_CHANGE2"},
    {0xfa02,  "MSG_DLL_CHANGE3"},
    {0xfa03,  "MSG_DLL_CHANGE_NOVERSION"},
    {0xfa04,  "MSG_RESTORE_FAILURE"},
    {0xfa05,  "MSG_COPY_CANCEL"},
    {0xfa06,  "MSG_COPY_CANCEL_NOUI"},
    {0xfa07,  "MSG_RESTORE_FAILURE_MAX_RETRIES"},
    {0xfa08,  "MSG_DLL_NOVALIDATION_TERMINATION"},
    {0xfa10,  "MSG_SCAN_STARTED"},
    {0xfa11,  "MSG_SCAN_COMPLETED"},
    {0xfa12,  "MSG_SCAN_CANCELLED"},
    {0xfa13,  "MSG_SCAN_FOUND_BAD_FILE_NOVERSION"},
    {0xfa14,  "MSG_SCAN_FOUND_BAD_FILE"},
    {0xfa15,  "MSG_CACHE_COPY_ERROR"},
    {0xfa20,  "MSG_DISABLE"},
    {0xfa21,  "MSG_INITIALIZATION_FAILED"},
    {0xfa22,  "MSG_DLLCACHE_INVALID"},
    {0xfa23,  "MSG_CATALOG_RESTORE_FAILURE"},
    {0xfa24,  "MSG_SXS_INITIALIZATION_FAILED"},

    {0     , "Event tag not found"}
};


// The following came from \drivers\vsm\vsmio\nt\dmiolog.mc
FRS_EL_ENTRY DMIOEvents[] = {

    {0x0001 , "VXERR_SPURCLOSE"},
    {0x0002 , "VXERR_DRLDETLOG"},
    {0x0003 , "VXERR_DRLDET"},
    {0x0004 , "VXERR_RDWR"},
    {0x0005 , "VXERR_OBJDET"},
    {0x0006 , "VXERR_MIRDET"},
    {0x0007 , "VXERR_KLOGFULL"},
    {0x0008 , "VXERR_KLOGUPDATE"},
    {0x0009 , "VXERR_RAID5DET"},
    {0x000a , "VXERR_RAID5OBJDET"},
    {0x000b , "VXERR_RAID5DEGRADE"},
    {0x000c , "VXERR_RAID5FAILED"},
    {0x000d , "VXERR_RAID5LOG"},
    {0x000e , "VXERR_R5LOGDET"},
    {0x000f , "VXERR_ILOCKSTRAND"},
    {0x0010 , "VXERR_ILOCKOVERLAP"},
    {0x0011 , "VXERR_ILLEGALVMINOR"},
    {0x0012 , "VXERR_IOERROR"},
    {0x0013 , "VXERR_IOERROR2"},
    {0x0014 , "VXERR_OPENDISK"},
    {0x0015 , "VXERR_CLOSEDISK"},
    {0x0016 , "VXERR_CORRECTRDERR"},
    {0x0017 , "VXLOG_BBREASSIGN"},
    {0x0018 , "VXLOG_SBBREASSIGN"},
    {0x0019 , "VXLOG_FBBREASSIGN"},
    {0x001a , "VXLOG_FOUNDBB"},
    {0x001b , "VXLOG_RAIDINITCORR"},
    {0x001c , "VXLOG_RAIDINITFAIL"},
    {0x001d , "VXLOG_DISK_READ_ERR"},
    {0x001e , "VXLOG_DISK_WRITE_ERR"},
    {0x001f , "VXLOG_DISKRM_WRITE_ERR"},
    {0x0020 , "VXLOG_DISKRM_READ_ERR"},
    {0x0021 , "VXLOG_DISK_DISABLED"},
    {0x0022 , "VXLOG_DISK_REONLINE"},
    {0x0023 , "VXERR_READ_ERROR"},
    {0x0024 , "VXERR_READ_ERROR2"},
    {0x0025 , "VXERR_WRITE_ERROR"},
    {0x0026 , "VXERR_WRITE_ERROR2"},

    {0     , "Event tag not found"}

};



//
// The below comes from net\netevent\netevent.mc
//

//#define STATUS_SEVERITY_WARNING          0x2
//#define STATUS_SEVERITY_SUCCESS          0x0
//#define STATUS_SEVERITY_INFORMATIONAL    0x1
//#define STATUS_SEVERITY_ERROR            0x3
//
FRS_EL_ENTRY NetEvents[] = {
    {0xC00007D0L, "EVENT_SRV_SERVICE_FAILED"},
    {0xC00007D1L, "EVENT_SRV_RESOURCE_SHORTAGE"},
    {0xC00007D2L, "EVENT_SRV_CANT_CREATE_DEVICE"},
    {0xC00007D3L, "EVENT_SRV_CANT_CREATE_PROCESS"},
    {0xC00007D4L, "EVENT_SRV_CANT_CREATE_THREAD"},
    {0xC00007D5L, "EVENT_SRV_UNEXPECTED_DISC"},
    {0xC00007D6L, "EVENT_SRV_INVALID_REQUEST"},
    {0xC00007D7L, "EVENT_SRV_CANT_OPEN_NPFS"},
    {0x800007D9L, "EVENT_SRV_CANT_GROW_TABLE"},
    {0xC00007DAL, "EVENT_SRV_CANT_START_SCAVENGER"},
    {0xC00007DBL, "EVENT_SRV_IRP_STACK_SIZE"},
    {0x800007DCL, "EVENT_SRV_NETWORK_ERROR"},
    {0x800007DDL, "EVENT_SRV_DISK_FULL"},
    {0xC00007E0L, "EVENT_SRV_NO_VIRTUAL_MEMORY"},
    {0xC00007E1L, "EVENT_SRV_NONPAGED_POOL_LIMIT"},
    {0xC00007E2L, "EVENT_SRV_PAGED_POOL_LIMIT"},
    {0xC00007E3L, "EVENT_SRV_NO_NONPAGED_POOL"},
    {0xC00007E4L, "EVENT_SRV_NO_PAGED_POOL"},
    {0x800007E5L, "EVENT_SRV_NO_WORK_ITEM"},
    {0x800007E6L, "EVENT_SRV_NO_FREE_CONNECTIONS"},
    {0x800007E7L, "EVENT_SRV_NO_FREE_RAW_WORK_ITEM"},
    {0x800007E8L, "EVENT_SRV_NO_BLOCKING_IO"},
    {0x800007E9L, "EVENT_SRV_DOS_ATTACK_DETECTED"},
    {0x800007EAL, "EVENT_SRV_TOO_MANY_DOS"},
    {0x800007EBL, "EVENT_SRV_OUT_OF_WORK_ITEM_DOS"},
    {0xC00009C5L, "EVENT_SRV_KEY_NOT_FOUND"},
    {0xC00009C6L, "EVENT_SRV_KEY_NOT_CREATED"},
    {0xC00009C7L, "EVENT_SRV_NO_TRANSPORTS_BOUND"},
    {0x800009C8L, "EVENT_SRV_CANT_BIND_TO_TRANSPORT"},
    {0xC00009C9L, "EVENT_SRV_CANT_BIND_DUP_NAME"},
    {0x800009CAL, "EVENT_SRV_INVALID_REGISTRY_VALUE"},
    {0x800009CBL, "EVENT_SRV_INVALID_SD"},
    {0x800009CCL, "EVENT_SRV_CANT_LOAD_DRIVER"},
    {0x800009CDL, "EVENT_SRV_CANT_UNLOAD_DRIVER"},
    {0x800009CEL, "EVENT_SRV_CANT_MAP_ERROR"},
    {0x800009CFL, "EVENT_SRV_CANT_RECREATE_SHARE"},
    {0x800009D0L, "EVENT_SRV_CANT_CHANGE_DOMAIN_NAME"},
    {0x80000BB9L, "EVENT_RDR_RESOURCE_SHORTAGE"},
    {0x80000BBAL, "EVENT_RDR_CANT_CREATE_DEVICE"},
    {0x80000BBBL, "EVENT_RDR_CANT_CREATE_THREAD"},
    {0x80000BBCL, "EVENT_RDR_CANT_SET_THREAD"},
    {0x80000BBDL, "EVENT_RDR_INVALID_REPLY"},
    {0x80000BBEL, "EVENT_RDR_INVALID_SMB"},
    {0x80000BBFL, "EVENT_RDR_INVALID_LOCK_REPLY"},
    {0x80000BC1L, "EVENT_RDR_FAILED_UNLOCK"},
    {0x80000BC3L, "EVENT_RDR_CLOSE_BEHIND"},
    {0x80000BC4L, "EVENT_RDR_UNEXPECTED_ERROR"},
    {0x80000BC5L, "EVENT_RDR_TIMEOUT"},
    {0x80000BC6L, "EVENT_RDR_INVALID_OPLOCK"},
    {0x80000BC7L, "EVENT_RDR_CONNECTION_REFERENCE"},
    {0x80000BC8L, "EVENT_RDR_SERVER_REFERENCE"},
    {0x80000BC9L, "EVENT_RDR_SMB_REFERENCE"},
    {0x80000BCAL, "EVENT_RDR_ENCRYPT"},
    {0x80000BCBL, "EVENT_RDR_CONNECTION"},
    {0x80000BCDL, "EVENT_RDR_MAXCMDS"},
    {0x80000BCEL, "EVENT_RDR_OPLOCK_SMB"},
    {0x80000BCFL, "EVENT_RDR_DISPOSITION"},
    {0x80000BD0L, "EVENT_RDR_CONTEXTS"},
    {0x80000BD1L, "EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED"},
    {0x80000BD2L, "EVENT_RDR_AT_THREAD_MAX"},
    {0x80000BD3L, "EVENT_RDR_CANT_READ_REGISTRY"},
    {0x80000BD4L, "EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE"},
    {0x80000BD5L, "EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED"},
    {0x80000BD6L, "EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED"},
    {0x80000BD7L, "EVENT_RDR_DELETEONCLOSE_FAILED"},
    {0x80000BD8L, "EVENT_RDR_CANT_BIND_TRANSPORT"},
    {0x80000BD9L, "EVENT_RDR_CANT_REGISTER_ADDRESS"},
    {0x80000BDAL, "EVENT_RDR_CANT_GET_SECURITY_CONTEXT"},
    {0x80000BDBL, "EVENT_RDR_CANT_BUILD_SMB_HEADER"},
    {0x80000BDCL, "EVENT_RDR_SECURITY_SIGNATURE_MISMATCH"},
    {0x40000C1CL, "EVENT_TCPIP6_STARTED"},
    {0xC0000FA0L, "EVENT_STREAMS_STRLOG"},
    {0x80000FA1L, "EVENT_STREAMS_ALLOCB_FAILURE"},
    {0x80000FA2L, "EVENT_STREAMS_ALLOCB_FAILURE_CNT"},
    {0x80000FA3L, "EVENT_STREAMS_ESBALLOC_FAILURE"},
    {0x80000FA4L, "EVENT_STREAMS_ESBALLOC_FAILURE_CNT"},
    {0xC0001004L, "EVENT_TCPIP_CREATE_DEVICE_FAILED"},
    {0xC0001005L, "EVENT_TCPIP_NO_RESOURCES_FOR_INIT"},
    {0xC0001059L, "EVENT_TCPIP_TOO_MANY_NETS"},
    {0xC000105AL, "EVENT_TCPIP_NO_MASK"},
    {0xC000105BL, "EVENT_TCPIP_INVALID_ADDRESS"},
    {0xC000105CL, "EVENT_TCPIP_INVALID_MASK"},
    {0xC000105DL, "EVENT_TCPIP_NO_ADAPTER_RESOURCES"},
    {0x8000105EL, "EVENT_TCPIP_DHCP_INIT_FAILED"},
    {0xC000105FL, "EVENT_TCPIP_ADAPTER_REG_FAILURE"},
    {0x80001060L, "EVENT_TCPIP_INVALID_DEFAULT_GATEWAY"},
    {0xC0001061L, "EVENT_TCPIP_NO_ADDRESS_LIST"},
    {0xC0001062L, "EVENT_TCPIP_NO_MASK_LIST"},
    {0xC0001063L, "EVENT_TCPIP_NO_BINDINGS"},
    {0xC0001064L, "EVENT_TCPIP_IP_INIT_FAILED"},
    {0x80001065L, "EVENT_TCPIP_TOO_MANY_GATEWAYS"},
    {0xC0001066L, "EVENT_TCPIP_ADDRESS_CONFLICT1"},
    {0xC0001067L, "EVENT_TCPIP_ADDRESS_CONFLICT2"},
    {0xC0001068L, "EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE"},
    {0x40001069L, "EVENT_TCPIP_MEDIA_CONNECT"},
    {0x4000106AL, "EVENT_TCPIP_MEDIA_DISCONNECT"},
    {0xC0001081L, "EVENT_TCPIP_TCP_INIT_FAILED"},
    {0x800010A9L, "EVENT_TCPIP_UDP_LIMIT_REACHED"},
    {0xC00010B9L, "EVENT_IPSEC_NO_RESOURCES_FOR_INIT"},
    {0xC00010BAL, "EVENT_IPSEC_CREATE_DEVICE_FAILED"},
    {0xC00010BBL, "EVENT_IPSEC_BAD_SPI_RECEIVED"},
    {0xC00010BCL, "EVENT_IPSEC_UNEXPECTED_CLEARTEXT"},
    {0xC00010BDL, "EVENT_IPSEC_AUTH_FAILURE"},
    {0xC00010BEL, "EVENT_IPSEC_BAD_PACKET_SYNTAX"},
    {0xC00010BFL, "EVENT_IPSEC_BAD_PROTOCOL_RECEIVED"},
    {0xC00010C0L, "EVENT_IPSEC_GENERIC_FAILURE"},
    {0xC00010C1L, "EVENT_IPSEC_NEG_FAILURE"},
    {0x400010C2L, "EVENT_IPSEC_DROP_PACKET_INBOUND"},
    {0x400010C3L, "EVENT_IPSEC_DROP_PACKET_OUTBOUND"},
    {0xC00010CCL, "EVENT_NBT_CREATE_DRIVER"},
    {0xC00010CDL, "EVENT_NBT_OPEN_REG_PARAMS"},
    {0x800010CEL, "EVENT_NBT_NO_BACKUP_WINS"},
    {0x800010CFL, "EVENT_NBT_NO_WINS"},
    {0x800010D0L, "EVENT_NBT_BAD_BACKUP_WINS_ADDR"},
    {0x800010D1L, "EVENT_NBT_BAD_PRIMARY_WINS_ADDR"},
    {0xC00010D2L, "EVENT_NBT_NAME_SERVER_ADDRS"},
    {0xC00010D3L, "EVENT_NBT_CREATE_ADDRESS"},
    {0xC00010D4L, "EVENT_NBT_CREATE_CONNECTION"},
    {0xC00010D5L, "EVENT_NBT_NON_OS_INIT"},
    {0xC00010D6L, "EVENT_NBT_TIMERS"},
    {0xC00010D7L, "EVENT_NBT_CREATE_DEVICE"},
    {0x800010D8L, "EVENT_NBT_NO_DEVICES"},
    {0xC00010D9L, "EVENT_NBT_OPEN_REG_LINKAGE"},
    {0xC00010DAL, "EVENT_NBT_READ_BIND"},
    {0xC00010DBL, "EVENT_NBT_READ_EXPORT"},
    {0x800010DCL, "EVENT_NBT_OPEN_REG_NAMESERVER"},
    {0x800010DDL, "EVENT_SCOPE_LABEL_TOO_LONG"},
    {0x800010DEL, "EVENT_SCOPE_TOO_LONG"},
    {0xC00010DFL, "EVENT_NBT_DUPLICATE_NAME"},
    {0xC00010E0L, "EVENT_NBT_NAME_RELEASE"},
    {0xC00010E1L, "EVENT_NBT_DUPLICATE_NAME_ERROR"},
    {0xC00010E2L, "EVENT_NBT_NO_RESOURCES"},
    {0xC0001388L, "EVENT_NDIS_RESOURCE_CONFLICT"},
    {0xC0001389L, "EVENT_NDIS_OUT_OF_RESOURCE"},
    {0xC000138AL, "EVENT_NDIS_HARDWARE_FAILURE"},
    {0xC000138BL, "EVENT_NDIS_ADAPTER_NOT_FOUND"},
    {0xC000138CL, "EVENT_NDIS_INTERRUPT_CONNECT"},
    {0xC000138DL, "EVENT_NDIS_DRIVER_FAILURE"},
    {0xC000138EL, "EVENT_NDIS_BAD_VERSION"},
    {0x8000138FL, "EVENT_NDIS_TIMEOUT"},
    {0xC0001390L, "EVENT_NDIS_NETWORK_ADDRESS"},
    {0xC0001391L, "EVENT_NDIS_UNSUPPORTED_CONFIGURATION"},
    {0xC0001392L, "EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER"},
    {0xC0001393L, "EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER"},
    {0xC0001394L, "EVENT_NDIS_BAD_IO_BASE_ADDRESS"},
    {0x40001395L, "EVENT_NDIS_RECEIVE_SPACE_SMALL"},
    {0x80001396L, "EVENT_NDIS_ADAPTER_DISABLED"},
    {0x80001397L, "EVENT_NDIS_IO_PORT_CONFLICT"},
    {0x80001398L, "EVENT_NDIS_PORT_OR_DMA_CONFLICT"},
    {0x80001399L, "EVENT_NDIS_MEMORY_CONFLICT"},
    {0x8000139AL, "EVENT_NDIS_INTERRUPT_CONFLICT"},
    {0x8000139BL, "EVENT_NDIS_DMA_CONFLICT"},
    {0xC000139CL, "EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR"},
    {0x8000139DL, "EVENT_NDIS_MAXRECEIVES_ERROR"},
    {0x8000139EL, "EVENT_NDIS_MAXTRANSMITS_ERROR"},
    {0x8000139FL, "EVENT_NDIS_MAXFRAMESIZE_ERROR"},
    {0x800013A0L, "EVENT_NDIS_MAXINTERNALBUFS_ERROR"},
    {0x800013A1L, "EVENT_NDIS_MAXMULTICAST_ERROR"},
    {0x800013A2L, "EVENT_NDIS_PRODUCTID_ERROR"},
    {0x800013A3L, "EVENT_NDIS_LOBE_FAILUE_ERROR"},
    {0x800013A4L, "EVENT_NDIS_SIGNAL_LOSS_ERROR"},
    {0x800013A5L, "EVENT_NDIS_REMOVE_RECEIVED_ERROR"},
    {0x400013A6L, "EVENT_NDIS_TOKEN_RING_CORRECTION"},
    {0xC00013A7L, "EVENT_NDIS_ADAPTER_CHECK_ERROR"},
    {0x800013A8L, "EVENT_NDIS_RESET_FAILURE_ERROR"},
    {0x800013A9L, "EVENT_NDIS_CABLE_DISCONNECTED_ERROR"},
    {0x800013AAL, "EVENT_NDIS_RESET_FAILURE_CORRECTION"},
    {0x80001770L, "EVENT_LOG_FULL"},
    {0x80001771L, "EVENT_LogFileNotOpened"},
    {0x80001772L, "EVENT_LogFileCorrupt"},
    {0x80001773L, "EVENT_DefaultLogCorrupt"},
    {0x80001774L, "EVENT_BadDriverPacket"},
    {0x80001775L, "EVENT_EventlogStarted"},
    {0x80001776L, "EVENT_EventlogStopped"},
    {0x80001777L, "TITLE_EventlogMessageBox"},
    {0x80001778L, "EVENT_EventlogAbnormalShutdown"},
    {0x80001779L, "EVENT_EventLogProductInfo"},
    {0xC000177AL, "EVENT_ServiceNoEventLog"},
    {0xC000177BL, "EVENT_ComputerNameChange"},
    {0xC000177CL, "EVENT_DNSDomainNameChange"},
    {0xC00017D4L, "EVENT_UP_DRIVER_ON_MP"},
    {0xC0001B58L, "EVENT_SERVICE_START_FAILED"},
    {0xC0001B59L, "EVENT_SERVICE_START_FAILED_II"},
    {0xC0001B5AL, "EVENT_SERVICE_START_FAILED_GROUP"},
    {0xC0001B5BL, "EVENT_SERVICE_START_FAILED_NONE"},
    {0xC0001B5DL, "EVENT_CALL_TO_FUNCTION_FAILED"},
    {0xC0001B5EL, "EVENT_CALL_TO_FUNCTION_FAILED_II"},
    {0xC0001B5FL, "EVENT_REVERTED_TO_LASTKNOWNGOOD"},
    {0xC0001B60L, "EVENT_BAD_ACCOUNT_NAME"},
    {0xC0001B61L, "EVENT_CONNECTION_TIMEOUT"},
    {0xC0001B62L, "EVENT_READFILE_TIMEOUT"},
    {0xC0001B63L, "EVENT_TRANSACT_TIMEOUT"},
    {0xC0001B64L, "EVENT_TRANSACT_INVALID"},
    {0xC0001B65L, "EVENT_FIRST_LOGON_FAILED"},
    {0xC0001B66L, "EVENT_SECOND_LOGON_FAILED"},
    {0xC0001B67L, "EVENT_INVALID_DRIVER_DEPENDENCY"},
    {0xC0001B68L, "EVENT_BAD_SERVICE_STATE"},
    {0xC0001B69L, "EVENT_CIRCULAR_DEPENDENCY_DEMAND"},
    {0xC0001B6AL, "EVENT_CIRCULAR_DEPENDENCY_AUTO"},
    {0xC0001B6BL, "EVENT_DEPEND_ON_LATER_SERVICE"},
    {0xC0001B6CL, "EVENT_DEPEND_ON_LATER_GROUP"},
    {0xC0001B6DL, "EVENT_SEVERE_SERVICE_FAILED"},
    {0xC0001B6EL, "EVENT_SERVICE_START_HUNG"},
    {0xC0001B6FL, "EVENT_SERVICE_EXIT_FAILED"},
    {0xC0001B70L, "EVENT_SERVICE_EXIT_FAILED_SPECIFIC"},
    {0xC0001B71L, "EVENT_SERVICE_START_AT_BOOT_FAILED"},
    {0xC0001B72L, "EVENT_BOOT_SYSTEM_DRIVERS_FAILED"},
    {0xC0001B73L, "EVENT_RUNNING_LASTKNOWNGOOD"},
    {0xC0001B74L, "EVENT_TAKE_OWNERSHIP"},
    {0xC0001B75L, "TITLE_SC_MESSAGE_BOX"},
    {0xC0001B76L, "EVENT_SERVICE_NOT_INTERACTIVE"},
    {0xC0001B77L, "EVENT_SERVICE_CRASH"},
    {0xC0001B78L, "EVENT_SERVICE_RECOVERY_FAILED"},
    {0xC0001B79L, "EVENT_SERVICE_SCESRV_FAILED"},
    {0xC0001B7AL, "EVENT_SERVICE_CRASH_NO_ACTION"},
    {0x40001B7BL, "EVENT_SERVICE_CONTROL_SUCCESS"},
    {0x40001B7CL, "EVENT_SERVICE_STATUS_SUCCESS"},
    {0xC0001B7DL, "EVENT_SERVICE_CONFIG_BACKOUT_FAILED"},
    {0xC0001B7EL, "EVENT_FIRST_LOGON_FAILED_II"},
    {0xC0001EDCL, "EVENT_COMMAND_NOT_INTERACTIVE"},
    {0xC0001EDDL, "EVENT_COMMAND_START_FAILED"},
    {0xC0001F43L, "EVENT_BOWSER_OTHER_MASTER_ON_NET"},
    {0x80001F44L, "EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER"},
    {0x80001F45L, "EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE"},
    {0x80001F46L, "EVENT_BOWSER_ILLEGAL_DATAGRAM"},
    {0xC0001F47L, "EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED"},
    {0xC0001F48L, "EVENT_BROWSER_ROLE_CHANGE_FAILED"},
    {0xC0001F49L, "EVENT_BROWSER_MASTER_PROMOTION_FAILED"},
    {0xC0001F4AL, "EVENT_BOWSER_NAME_CONVERSION_FAILED"},
    {0xC0001F4BL, "EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED"},
    {0x00001F4CL, "EVENT_BOWSER_ELECTION_RECEIVED"},
    {0x40001F4DL, "EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED"},
    {0x40001F4EL, "EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED"},
    {0x40001F4FL, "EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED"},
    {0xC0001F50L, "EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD"},
    {0xC0001F51L, "EVENT_BROWSER_DEPENDANT_SERVICE_FAILED"},
    {0xC0001F53L, "EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING"},
    {0xC0001F54L, "EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER"},
    {0x80001F55L, "EVENT_BROWSER_SERVER_LIST_FAILED"},
    {0x80001F56L, "EVENT_BROWSER_DOMAIN_LIST_FAILED"},
    {0x80001F57L, "EVENT_BROWSER_ILLEGAL_CONFIG"},
    {0x40001F58L, "EVENT_BOWSER_OLD_BACKUP_FOUND"},
    {0x00001F59L, "EVENT_BROWSER_SERVER_LIST_RETRIEVED"},
    {0x00001F5AL, "EVENT_BROWSER_DOMAIN_LIST_RETRIEVED"},
    {0x40001F5BL, "EVENT_BOWSER_PDC_LOST_ELECTION"},
    {0x40001F5CL, "EVENT_BOWSER_NON_PDC_WON_ELECTION"},
    {0x40001F5DL, "EVENT_BOWSER_CANT_READ_REGISTRY"},
    {0x40001F5EL, "EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED"},
    {0x40001F5FL, "EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED"},
    {0xC0001F60L, "EVENT_BROWSER_BACKUP_STOPPED"},
    {0x40001F61L, "EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED"},
    {0xC0001F62L, "EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER"},
    {0x40001F63L, "EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED"},
    {0xC0001F64L, "EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH"},
    {0xC0002134L, "NWSAP_EVENT_KEY_NOT_FOUND"},
    {0xC0002135L, "NWSAP_EVENT_WSASTARTUP_FAILED"},
    {0xC0002136L, "NWSAP_EVENT_SOCKET_FAILED"},
    {0xC0002137L, "NWSAP_EVENT_SETOPTBCAST_FAILED"},
    {0xC0002138L, "NWSAP_EVENT_BIND_FAILED"},
    {0xC0002139L, "NWSAP_EVENT_GETSOCKNAME_FAILED"},
    {0xC000213AL, "NWSAP_EVENT_OPTEXTENDEDADDR_FAILED"},
    {0xC000213BL, "NWSAP_EVENT_OPTBCASTINADDR_FAILED"},
    {0xC000213CL, "NWSAP_EVENT_CARDMALLOC_FAILED"},
    {0xC000213DL, "NWSAP_EVENT_NOCARDS"},
    {0xC000213EL, "NWSAP_EVENT_THREADEVENT_FAIL"},
    {0xC000213FL, "NWSAP_EVENT_RECVSEM_FAIL"},
    {0xC0002140L, "NWSAP_EVENT_SENDEVENT_FAIL"},
    {0xC0002141L, "NWSAP_EVENT_STARTRECEIVE_ERROR"},
    {0xC0002142L, "NWSAP_EVENT_STARTWORKER_ERROR"},
    {0xC0002143L, "NWSAP_EVENT_TABLE_MALLOC_FAILED"},
    {0xC0002144L, "NWSAP_EVENT_HASHTABLE_MALLOC_FAILED"},
    {0xC0002145L, "NWSAP_EVENT_STARTLPCWORKER_ERROR"},
    {0xC0002146L, "NWSAP_EVENT_CREATELPCPORT_ERROR"},
    {0xC0002147L, "NWSAP_EVENT_CREATELPCEVENT_ERROR"},
    {0xC0002148L, "NWSAP_EVENT_LPCLISTENMEMORY_ERROR"},
    {0xC0002149L, "NWSAP_EVENT_LPCHANDLEMEMORY_ERROR"},
    {0xC000214AL, "NWSAP_EVENT_BADWANFILTER_VALUE"},
    {0xC000214BL, "NWSAP_EVENT_CARDLISTEVENT_FAIL"},
    {0xC000214CL, "NWSAP_EVENT_SDMDEVENT_FAIL"},
    {0x8000214DL, "NWSAP_EVENT_INVALID_FILTERNAME"},
    {0xC000214EL, "NWSAP_EVENT_WANSEM_FAIL"},
    {0xC000214FL, "NWSAP_EVENT_WANSOCKET_FAILED"},
    {0xC0002150L, "NWSAP_EVENT_WANBIND_FAILED"},
    {0xC0002151L, "NWSAP_EVENT_STARTWANWORKER_ERROR"},
    {0xC0002152L, "NWSAP_EVENT_STARTWANCHECK_ERROR"},
    {0xC0002153L, "NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR"},
    {0xC0002154L, "NWSAP_EVENT_WANHANDLEMEMORY_ERROR"},
    {0xC0002155L, "NWSAP_EVENT_WANEVENT_ERROR"},
    {0x80002329L, "EVENT_TRANSPORT_RESOURCE_POOL"},
    {0x8000232AL, "EVENT_TRANSPORT_RESOURCE_LIMIT"},
    {0x8000232BL, "EVENT_TRANSPORT_RESOURCE_SPECIFIC"},
    {0xC000232CL, "EVENT_TRANSPORT_REGISTER_FAILED"},
    {0xC000232DL, "EVENT_TRANSPORT_BINDING_FAILED"},
    {0xC000232EL, "EVENT_TRANSPORT_ADAPTER_NOT_FOUND"},
    {0xC000232FL, "EVENT_TRANSPORT_SET_OID_FAILED"},
    {0xC0002330L, "EVENT_TRANSPORT_QUERY_OID_FAILED"},
    {0x40002331L, "EVENT_TRANSPORT_TRANSFER_DATA"},
    {0x40002332L, "EVENT_TRANSPORT_TOO_MANY_LINKS"},
    {0x40002333L, "EVENT_TRANSPORT_BAD_PROTOCOL"},
    {0x4000251DL, "EVENT_IPX_NEW_DEFAULT_TYPE"},
    {0x8000251EL, "EVENT_IPX_SAP_ANNOUNCE"},
    {0x8000251FL, "EVENT_IPX_ILLEGAL_CONFIG"},
    {0xC0002520L, "EVENT_IPX_INTERNAL_NET_INVALID"},
    {0xC0002521L, "EVENT_IPX_NO_FRAME_TYPES"},
    {0xC0002522L, "EVENT_IPX_CREATE_DEVICE"},
    {0xC0002523L, "EVENT_IPX_NO_ADAPTERS"},
    {0xC0002710L, "EVENT_RPCSS_CREATEPROCESS_FAILURE"},
    {0xC0002711L, "EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE"},
    {0xC0002712L, "EVENT_RPCSS_LAUNCH_ACCESS_DENIED"},
    {0xC0002713L, "EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED"},
    {0xC0002714L, "EVENT_RPCSS_RUNAS_CANT_LOGIN"},
    {0xC0002715L, "EVENT_RPCSS_START_SERVICE_FAILURE"},
    {0xC0002716L, "EVENT_RPCSS_REMOTE_SIDE_ERROR"},
    {0xC0002717L, "EVENT_RPCSS_ACTIVATION_ERROR"},
    {0xC0002718L, "EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE"},
    {0xC0002719L, "EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE"},
    {0xC000271AL, "EVENT_RPCSS_SERVER_START_TIMEOUT"},
    {0xC000271BL, "EVENT_RPCSS_SERVER_NOT_RESPONDING"},
    {0xC000271CL, "EVENT_DCOM_ASSERTION_FAILURE"},
    {0xC000271DL, "EVENT_DCOM_INVALID_ENDPOINT_DATA"},
    {0xC0002AF8L, "EVENT_DNS_CACHE_START_FAILURE_NO_DLL"},
    {0xC0002AF9L, "EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY"},
    {0xC0002AFAL, "EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL"},
    {0xC0002AFBL, "EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT"},
    {0xC0002AFCL, "EVENT_DNS_CACHE_START_FAILURE_NO_RPC"},
    {0xC0002AFDL, "EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY"},
    {0xC0002AFEL, "EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE"},
    {0xC0002AFFL, "EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY"},
    {0x80002B2AL, "EVENT_DNS_CACHE_NETWORK_PERF_WARNING"},
    {0x80002B2BL, "EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING"},
    {0x80002B8EL, "EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT"},
    {0x80002B8FL, "EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL"},
    {0x80002B90L, "EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP"},
    {0x80002B91L, "EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED"},
    {0x80002B92L, "EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY"},
    {0x80002B93L, "EVENT_DNSAPI_REGISTRATION_FAILED_OTHER"},
    {0x80002B94L, "EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT"},
    {0x80002B95L, "EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL"},
    {0x80002B96L, "EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP"},
    {0x80002B97L, "EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED"},
    {0x80002B98L, "EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY"},
    {0x80002B99L, "EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER"},
    {0x80002B9AL, "EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN"},
    {0x80002B9BL, "EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN"},
    {0x80002B9CL, "EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN"},
    {0x80002B9DL, "EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN"},
    {0x80002B9EL, "EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN"},
    {0x80002B9FL, "EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN"},
    {0x80002BACL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT"},
    {0x80002BADL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL"},
    {0x80002BAEL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP"},
    {0x80002BAFL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED"},
    {0x80002BB0L, "EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY"},
    {0x80002BB1L, "EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER"},
    {0x80002BB2L, "EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT"},
    {0x80002BB3L, "EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL"},
    {0x80002BB4L, "EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP"},
    {0x80002BB5L, "EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED"},
    {0x80002BB6L, "EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY"},
    {0x80002BB7L, "EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER"},
    {0x80002BB8L, "EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN"},
    {0x80002BB9L, "EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN"},
    {0x80002BBAL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN"},
    {0x80002BBBL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN"},
    {0x80002BBCL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN"},
    {0x80002BBDL, "EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN"},
    {0x40002BC0L, "EVENT_DNSAPI_REGISTERED_ADAPTER"},
    {0x40002BC1L, "EVENT_DNSAPI_REGISTERED_PTR"},
    {0x40002BC2L, "EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN"},
    {0xC0002EE0L, "EVENT_WMI_CANT_OPEN_DEVICE"},
    {0x80002F44L, "EVENT_WMI_INVALID_MOF"},
    {0x80002F45L, "EVENT_WMI_MOF_LOAD_FAILURE"},
    {0x80002F46L, "EVENT_WMI_INVALID_REGINFO"},
    {0x80002F47L, "EVENT_WMI_INVALID_REGPATH"},
    {0x80002F48L, "EVENT_WMI_CANT_RESOLVE_INSTANCE"},
    {0x80002F49L, "EVENT_WMI_CANT_GET_EVENT_DATA"},
    {0xC00030D4L, "EVENT_TRK_INTERNAL_ERROR"},
    {0x400030D5L, "EVENT_TRK_SERVICE_START_SUCCESS"},
    {0xC00030D6L, "EVENT_TRK_SERVICE_START_FAILURE"},
    {0xC00030D7L, "EVENT_TRK_SERVICE_CORRUPT_LOG"},
    {0x800030D8L, "EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED"},
    {0x400030D9L, "EVENT_TRK_SERVICE_VOLUME_CREATE"},
    {0x400030DAL, "EVENT_TRK_SERVICE_VOLUME_CLAIM"},
    {0x400030DBL, "EVENT_TRK_SERVICE_DUPLICATE_VOLIDS"},
    {0x800030DCL, "EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED"},
    {0xC000332CL, "EVENT_ATMLANE_CFGREQ_FAIL_VERSNOSUPP"},
    {0xC000332DL, "EVENT_ATMLANE_JOINREQ_FAIL_VERSNOSUPP"},
    {0xC000332EL, "EVENT_ATMLANE_CFGREQ_FAIL_REQPARMINVAL"},
    {0xC000332FL, "EVENT_ATMLANE_JOINREQ_FAIL_REQPARMINVAL"},
    {0xC0003330L, "EVENT_ATMLANE_JOINREQ_FAIL_DUPLANDEST"},
    {0xC0003331L, "EVENT_ATMLANE_JOINREQ_FAIL_DUPATMADDR"},
    {0xC0003332L, "EVENT_ATMLANE_CFGREQ_FAIL_INSUFFRES"},
    {0xC0003333L, "EVENT_ATMLANE_JOINREQ_FAIL_INSUFFRES"},
    {0xC0003334L, "EVENT_ATMLANE_CFGREQ_FAIL_NOACCESS"},
    {0xC0003335L, "EVENT_ATMLANE_JOINREQ_FAIL_NOACCESS"},
    {0xC0003336L, "EVENT_ATMLANE_CFGREQ_FAIL_REQIDINVAL"},
    {0xC0003337L, "EVENT_ATMLANE_JOINREQ_FAIL_REQIDINVAL"},
    {0xC0003338L, "EVENT_ATMLANE_CFGREQ_FAIL_LANDESTINVAL"},
    {0xC0003339L, "EVENT_ATMLANE_JOINREQ_FAIL_LANDESTINVAL"},
    {0xC000333AL, "EVENT_ATMLANE_CFGREQ_FAIL_ATMADDRINVAL"},
    {0xC000333BL, "EVENT_ATMLANE_JOINREQ_FAIL_ATMADDRINVAL"},
    {0xC000333CL, "EVENT_ATMLANE_CFGREQ_FAIL_NOCONF"},
    {0xC000333DL, "EVENT_ATMLANE_CFGREQ_FAIL_CONFERROR"},
    {0xC000333EL, "EVENT_ATMLANE_CFGREQ_FAIL_INSUFFINFO"},
    {0xC0003390L, "EVENT_ATMARPS_ADDRESS_ALREADY_EXISTS"},
    {0xC00036B0L, "EVENT_PS_GPC_REGISTER_FAILED"},
    {0xC00036B1L, "EVENT_PS_NO_RESOURCES_FOR_INIT"},
    {0xC00036B2L, "EVENT_PS_REGISTER_PROTOCOL_FAILED"},
    {0xC00036B3L, "EVENT_PS_REGISTER_MINIPORT_FAILED"},
    {0x80003714L, "EVENT_PS_BAD_BESTEFFORT_LIMIT"},
    {0xC0003715L, "EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE"},
    {0xC0003716L, "EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE"},
    {0xC0003717L, "EVENT_PS_QUERY_OID_GEN_LINK_SPEED"},
    {0xC0003718L, "EVENT_PS_BINDING_FAILED"},
    {0xC0003719L, "EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA"},
    {0xC000371AL, "EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED"},
    {0xC000371BL, "EVENT_PS_INIT_DEVICE_FAILED"},
    {0xC000371CL, "EVENT_PS_WMI_INSTANCE_NAME_FAILED"},
    {0x8000371DL, "EVENT_PS_WAN_LIMITED_BESTEFFORT"},
    {0xC000371EL, "EVENT_PS_RESOURCE_POOL"},
    {0x8000371FL, "EVENT_PS_ADMISSIONCONTROL_OVERFLOW"},
    {0xC0003720L, "EVENT_PS_NETWORK_ADDRESS_FAIL"},

    // DFS Events.
    {14300 , "EXTRA_EXIT_POINT"},
    {14301 , "MISSING_EXIT_POINT"},
    {14302 , "MISSING_VOLUME"},
    {14303 , "EXTRA_VOLUME"},
    {14304 , "EXTRA_EXIT_POINT_DELETED"},
    {14305 , "EXTRA_EXIT_POINT_NOT_DELETED"},
    {14306 , "MISSING_EXIT_POINT_CREATED"},
    {14307 , "MISSING_EXIT_POINT_NOT_CREATED"},
    {14308 , "MISSING_VOLUME_CREATED"},
    {14309 , "MISSING_VOLUME_NOT_CREATED"},
    {14310 , "EXTRA_VOLUME_DELETED"},
    {14311 , "EXTRA_VOLUME_NOT_DELETED"},
    {14312 , "COULD_NOT_VERIFY_VOLUMES"},
    {14313 , "KNOWLEDGE_INCONSISTENCY_DETECTED"},
    {14314 , "PREFIX_MISMATCH"},
    {14315 , "PREFIX_MISMATCH_FIXED"},
    {14316 , "PREFIX_MISMATCH_NOT_FIXED"},
    {14317 , "MACHINE_UNJOINED"},
    {14318 , "DFS_REFERRAL_REQUEST"},
    {14400 , "NOT_A_DFS_PATH"},
    {14401 , "LM_REDIR_FAILURE"},
    {14402 , "DFS_CONNECTION_FAILURE"},
    {14403 , "DFS_REFERRAL_FAILURE"},
    {14404 , "DFS_REFERRAL_SUCCESS"},
    {14405 , "DFS_MAX_DNR_ATTEMPTS"},
    {14406 , "DFS_SPECIAL_REFERRAL_FAILURE"},
    {14407 , "DFS_OPEN_FAILURE"},
    {14500 , "NET_DFS_ENUM"},
    {14501 , "NET_DFS_ENUMEX"},
    {14502 , "DFS_ERROR_CREATE_DIRECTORY_FAILURE"},
    {14503 , "DFS_ERROR_CREATE_REPARSEPOINT_FAILURE"},
    {14504 , "DFS_ERROR_UNSUPPORTED_FILESYSTEM"},
    {14505 , "DFS_ERROR_OVERLAPPING_DIRECTORIES"},
    {14506 , "DFS_ERROR_AD_WRITE_ERROR"},
    {14507 , "DFS_ERROR_AD_READ_ERROR"},
    {14508 , "DFS_ERROR_DIRECTORY_NOT_EMPTY"},
    {14509 , "DFS_ERROR_TOO_MANY_ERRORS"},
    {14510 , "DFS_ERROR_WINSOCKINIT_FAILED"},
    {14511 , "DFS_ERROR_SECURITYINIT_FAILED"},
    {14512 , "DFS_ERROR_THREADINIT_FAILED"},
    {14513 , "DFS_ERROR_SITECACHEINIT_FAILED"},
    {14514 , "DFS_ERROR_ROOTSYNCINIT_FAILED"},
    {14515 , "DFS_ERROR_CREATEEVENT_FAILED"},
    {14516 , "DFS_ERROR_COMPUTERINFO_FAILED"},
    {14517 , "DFS_ERROR_CLUSTERINFO_FAILED"},
    {14518 , "DFS_ERROR_DCINFO_FAILED"},
    {14519 , "DFS_ERROR_PREFIXTABLE_FAILED"},
    {14520 , "DFS_ERROR_HANDLENAMESPACE_FAILED"},
    {14521 , "DFS_ERROR_REGISTERSTORE_FAILED"},
    {14522 , "DFS_ERROR_REFLECTIONENGINE_FAILED"},
    {14523 , "DFS_ERROR_SPECIALSHARES_FAILED"},
    {14524 , "DFS_ERROR_SITESUPPOR_FAILED"},
    {14525 , "DFS_ERROR_DSINITIALCONNECT_FAILED"},
    {14526 , "DFS_ERROR_DSCONNECT_FAILED"},
    {14527 , "DFS_ERROR_ROOT_TURNED_OFF"},
    {14528 , "DFS_INFO_ROOT_TURNED_ON"},
    {14529 , "DFS_INFO_DS_RECONNECTED"},

    {0xC0003908L, "EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED"},
    {0xC0003909L, "EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING"},
    {0xC000390AL, "EVENT_BRIDGE_MINIPORT_REGISTER_FAILED"},
    {0xC000390BL, "EVENT_BRIDGE_DEVICE_CREATION_FAILED"},
    {0xC000390CL, "EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR"},
    {0xC000390DL, "EVENT_BRIDGE_MINIPORT_INIT_FAILED"},
    {0xC000390EL, "EVENT_BRIDGE_ETHERNET_NOT_OFFERED"},
    {0xC000390FL, "EVENT_BRIDGE_THREAD_CREATION_FAILED"},
    {0xC0003910L, "EVENT_BRIDGE_THREAD_REF_FAILED"},
    {0xC0003911L, "EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED"},
    {0xC0003912L, "EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED"},
    {0xC0003913L, "EVENT_BRIDGE_INIT_MALLOC_FAILED"},
    {0xC000396CL, "EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED"},
    {0xC000396DL, "EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED"},
    {0xC000396EL, "EVENT_BRIDGE_ADAPTER_FILTER_FAILED"},
    {0xC000396FL, "EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED"},
    {0xC0003970L, "EVENT_BRIDGE_ADAPTER_BIND_FAILED"},
    // Time service codes from \nt\ds\security\services\w32time\w32time\obj\i386\w32timemsg.h
    {0xC25A0001L, "MSG_TIMEPROV_ERROR"},
    {0x825A0002L, "MSG_TIMEPROV_WARNING"},
    {0x425A0003L, "MSG_TIMEPROV_INFORMATIONAL"},
    {0xC25A0004L, "MSG_TIMEPROV_FAILED_START"},
    {0xC25A0005L, "MSG_TIMEPROV_FAILED_STOP"},
    {0x825A0006L, "MSG_CONFIG_READ_FAILED_WARNING"},
    {0x825A0007L, "MSG_TIMEPROV_FAILED_UPDATE"},
    {0x825A0008L, "MSG_TIMEPROV_FAILED_POLLUPDATE"},
    {0x825A0009L, "MSG_TIMEPROV_FAILED_TIMEJUMP"},
    {0x825A000AL, "MSG_TIMEPROV_FAILED_GETSAMPLES"},
    {0x825A000BL, "MSG_NOT_DOMAIN_MEMBER"},
    {0x825A000CL, "MSG_DOMAIN_HIERARCHY_ROOT"},
    {0x825A000DL, "MSG_NT4_DOMAIN"},
    {0x825A000EL, "MSG_NO_DC_LOCATED"},
    {0xC25A000FL, "MSG_NO_DC_LOCATED_UNEXPECTED_ERROR"},
    {0x825A0010L, "MSG_MANUAL_PEER_LOOKUP_FAILED_UNEXPECTED"},
    {0x825A0011L, "MSG_MANUAL_PEER_LOOKUP_FAILED_RETRYING"},
    {0x825A0012L, "MSG_RID_LOOKUP_FAILED"},
    {0xC25A0013L, "MSG_FILELOG_FAILED"},
    {0xC25A0014L, "MSG_FILELOG_WRITE_FAILED"},
    {0xC25A0015L, "MSG_NO_INPUT_PROVIDERS_STARTED"},
    {0x825A0016L, "MSG_CLIENT_COMPUTE_SERVER_DIGEST_FAILED"},
    {0x825A0017L, "MSG_SYMMETRIC_COMPUTE_SERVER_DIGEST_FAILED"},
    {0x825A0018L, "MSG_DOMHIER_PEER_TIMEOUT"},
    {0x825A0019L, "MSG_COMPUTE_CLIENT_DIGEST_FAILED"},
    {0x825A001AL, "MSG_BAD_SIGNATURE"},
    {0x825A001BL, "MSG_MISSING_SIGNATURE"},
    {0xC25A001CL, "MSG_NO_NTP_PEERS"},
    {0xC25A001DL, "MSG_NO_NTP_PEERS_BUT_PENDING"},
    {0xC25A001EL, "MSG_CONFIG_READ_FAILED"},
    {0x825A001FL, "MSG_TIME_ZONE_FIXED"},
    {0xC25A0020L, "MSG_TIME_ZONE_FIX_FAILED"},
    {0x825A0021L, "MSG_TIME_JUMPED"},
    {0xC25A0022L, "MSG_TIME_CHANGE_TOO_BIG"},
    {0x425A0023L, "MSG_TIME_SOURCE_CHOSEN"},
    {0x825A0024L, "MSG_TIME_SOURCE_NONE"},
    {0x425A0025L, "MSG_TIME_SOURCE_REACHABLE"},
    {0x425A0026L, "MSG_TIME_SOURCE_UNREACHABLE"},
    {0x825A0027L, "MSG_TCP_NOT_INSTALLED"},
    {0x825A0028L, "MSG_TIMEPROV_STOPPED"},
    {0xC25A0029L, "MSG_NO_INPUT_PROVIDERS_RUNNING"},
    {0xC25A002AL, "MSG_NAMED_EVENT_ALREADY_OPEN"},
    {0x825A002BL, "MSG_TIMEPROV_FAILED_NETTOPOCHANGE"},
    {0xC25A002CL, "MSG_NTPCLIENT_ERROR_SHUTDOWN"},
    {0xC25A002DL, "MSG_NTPSERVER_ERROR_SHUTDOWN"},
    {0xC25A002EL, "MSG_ERROR_SHUTDOWN"},
    {0xC25A002FL, "MSG_MANUAL_PEER_TIMEOUT"},
    {0xC25A0030L, "MSG_MANUAL_PEER_LOOKUP_FAILED"},
    {0xC25A0031L, "MSG_NO_DC_LOCATED_LAST_WARNING"},
    {0xC25A0032L, "MSG_LOCALCLOCK_UNSET"},
    {0xC25A005AL, "W32TIMEMSG_AUTHTYPE_NOAUTH"},
    {0xC25A005BL, "W32TIMEMSG_AUTHTYPE_NTDIGEST"},
    {0xC25A005CL, "W32TIMEMSG_UNREACHABLE_PEER"},
    {0xC25A005EL, "W32TIMEMSG_ERROR_PACKETTEST1"},
    {0xC25A005FL, "W32TIMEMSG_ERROR_PACKETTEST2"},
    {0xC25A0060L, "W32TIMEMSG_ERROR_PACKETTEST3"},
    {0xC25A0061L, "W32TIMEMSG_ERROR_PACKETTEST4"},
    {0xC25A0062L, "W32TIMEMSG_ERROR_PACKETTEST5"},
    {0xC25A0063L, "W32TIMEMSG_ERROR_PACKETTEST6"},
    {0xC25A0064L, "W32TIMEMSG_ERROR_PACKETTEST7"},
    {0xC25A0065L, "W32TIMEMSG_ERROR_PACKETTEST8"},
    {0xC25A0066L, "W32TIMEMSG_SERVICE_DESCRIPTION"},

    {0     , "Event tag not found"}

};


    // The following printer event codes from
    // printscan\print\spooler\inc\messages.mc
FRS_EL_ENTRY PrinterEvents[] = {

    {0x0002 ,"MSG_PRINTER_CREATED"},
    {0x0003 ,"MSG_PRINTER_DELETED"},
    {0x0004 ,"MSG_PRINTER_DELETION_PENDING"},
    {0x0006 ,"MSG_PRINTER_PAUSED"},
    {0x0007 ,"MSG_PRINTER_UNPAUSED"},
    {0x0008 ,"MSG_PRINTER_PURGED"},
    {0x0009 ,"MSG_PRINTER_SET"},
    {0x000a ,"MSG_DOCUMENT_PRINTED"},
    {0x000b ,"MSG_DOCUMENT_PAUSED"},
    {0x000c ,"MSG_DOCUMENT_RESUMED"},
    {0x000d ,"MSG_DOCUMENT_DELETED"},
    {0x000e ,"MSG_DOCUMENT_POSITION_CHANGED"},
    {0x000f ,"MSG_FORM_ADDED"},
    {0x0010 ,"MSG_FORM_DELETED"},
    {0x0012 ,"MSG_DOCUMENT_TIMEOUT"},
    {0x0013 ,"MSG_SHARE_FAILED"},
    {0x0014 ,"MSG_DRIVER_ADDED"},
    {0x0015 ,"MSG_DRIVER_DELETED"},
    {0x0016 ,"MSG_DRIVER_FAILED_UPGRADE"},
    {0x0017 ,"MSG_NO_DRIVER_FOUND_FOR_PRINTER"},
    {0x0018 ,"MSG_NO_PORT_FOUND_FOR_PRINTER"},
    {0x0019 ,"MSG_FILES_COPIED"},
    {0x001A ,"MSG_CANT_PUBLISH_PROPERTY"},
    {0x001B ,"MSG_CANT_GET_CONTAINER"},
    {0x001C ,"MSG_CANT_WRITE_ACL"},
    {0x001D ,"MSG_CANT_DELETE_PRINTQUEUE"},
    {0x001E ,"MSG_CANT_CREATE_PRINTQUEUE"},
    {0x001F ,"MSG_CANT_PUBLISH_MANDATORY_PROPERTIES"},
    {0x0020 ,"MSG_CANT_GET_PRIMARY_DOMAIN_INFO"},
    {0x0021 ,"MSG_CANT_GET_DNS_DOMAIN_NAME"},
    {0x0022 ,"MSG_CANT_BIND"},
    {0x0023 ,"MSG_CANT_CRACK"},
    {0x0024 ,"MSG_PRINTER_PUBLISHED"},
    {0x0025 ,"MSG_PRINTER_NOT_PUBLISHED"},
    {0x0026 ,"MSG_PRINTER_UNPUBLISHED"},
    {0x0027 ,"MSG_PRINTER_NOT_UNPUBLISHED"},
    {0x0028 ,"MSG_PRINTER_UPDATED"},
    {0x0029 ,"MSG_CANT_CRACK_GUID"},
    {0x002A ,"MSG_MISSING_PRINTER_UNPUBLISHED"},
    {0x002B ,"MSG_NO_DS"},
    {0x002C ,"MSG_CANT_GET_DNS_SERVER_NAME"},
    {0x002D ,"MSG_DOCUMENT_FAILED_GDIDRIVER_ERROR"},
    {0x002E ,"MSG_PRUNING_NOUNC_PRINTER"},
    {0x002F ,"MSG_PRUNING_ABSENT_PRINTER"},
    {0x0030 ,"MSG_PRUNING_UNPUBLISHED_PRINTER"},
    {0x0031 ,"MSG_PRUNING_DUPLICATE_PRINTER"},
    {0x0032 ,"MSG_PRUNING_PRINTER"},
    {0x0033 ,"MSG_CANT_PRUNE_PRINTER"},
    {0x0034 ,"MSG_BAD_OEM_DRIVER"},
    {0x0035 ,"MSG_BACKUP_SPOOLER_REGISTRY"},
    {0x0036 ,"MSG_BAD_JOB"},
    {0x0037 ,"MSG_KM_PRINTERS_BLOCKED"},
    {0x0038 ,"MSG_DOCUMENT_PRIORITY_CHANGED"},
    {0x0039 ,"MSG_DOCUMENT_FAILED_ACCESS_DENIED"},
    {0x003A ,"MSG_INIT_FAILED"},
    {0x003B ,"MSG_CANT_ADD_CLUSTER_ACE"},
    {0x003C ,"MSG_CANT_ADD_UPDATE_CLUSTER_DRIVER"},
    {0x003D ,"MSG_PRINT_ON_PROC_FAILED"},
    {0x003E ,"MSG_DRIVER_MISMATCHED_WITH_SERVER"},
    {0x0018 ,"MSG_PORT_INITIALIZATION_ERROR"},

    {0     , "Event tag not found"}

};

    // The following DHCP event codes from
    // \\index1\w2krtm\private\net\sockets\tcpcmd\dhcpm\server\messages\dhcpmsg.mc
FRS_EL_ENTRY DHCPEvents[] = {

    {1000, "EVENT_SERVER_UNKNOWN_OPTION"},
    {1001, "EVENT_SERVER_FAILED_REGISTER_SC"},
    {1002, "EVENT_SERVER_INIT_DATA_FAILED"},
    {1003, "EVENT_SERVER_INIT_REGISTRY_FAILED"},
    {1004, "EVENT_SERVER_INIT_DATABASE_FAILED"},
    {1005, "EVENT_SERVER_INIT_WINSOCK_FAILED"},
    {1006, "EVENT_SERVER_INIT_RPC_FAILED"},
    {1007, "EVENT_SERVER_INIT_SOCK_FAILED"},
    {1008, "EVENT_SERVER_SHUTDOWN"},
    {1009, "EVENT_SERVER_CLIENT_CLEANUP"},
    {1010, "EVENT_SERVER_DATABASE_CLEANUP"},
    {1011, "EVENT_SERVER_LEASE_NACK"},
    {1012, "EVENT_SERVER_LEASE_DECLINED"},
    {1013, "EVENT_SERVER_LEASE_RELEASE"},
    {1014, "EVENT_SERVER_JET_ERROR"},
    {1015, "EVENT_SERVER_JET_WARNING"},
    {1016, "EVENT_SERVER_DATABASE_BACKUP"},
    {1017, "EVENT_SERVER_CONFIG_BACKUP"},
    {1018, "EVENT_SERVER_DATABASE_RESTORE_FAILED"},
    {1019, "EVENT_SERVER_CONFIG_RESTORE_FAILED"},
    {1020, "EVENT_SERVER_LOW_ADDRESS_WARNING"},
    {1021, "EVENT_SERVER_LOAD_JET_FAILED"},
    {1022, "EVENT_SERVER_JET_CONV_REQUIRED"},
    {1023, "EVENT_SERVER_JET_CONV_IN_PROGRESS"},
    {1024, "EVENT_SERVER_INIT_AND_READY"},
    {1025, "EVENT_SERVER_BOOT_FILE_TABLE"},
    {1026, "EVENT_SERVER_BOOT_FILE_NAME"},
    {1027, "EVENT_SERVER_AUDIT_LOG_APPEND_FAILED"},
    {1028, "EVENT_SERVER_INIT_AUDIT_LOG_FAILED"},
    {1029, "EVENT_SERVER_PING_FAILED"},
    {1030, "EVENT_SERVER_MOVE_AUDIT_LOG_FAILED"},
    {1031, "EVENT_SERVER_CALLOUT_UNHANDLED_EXCEPTION"},
    {1032, "EVENT_SERVER_CALLOUT_LOAD_EXCEPTION"},
    {1033, "EVENT_SERVER_CALLOUT_LOAD_SUCCESS"},
    {1034, "EVENT_SERVER_CALLOUT_LOAD_FAILED"},
    {1035, "EVENT_SERVER_READ_ONLY_GROUP_ERROR"},
    {1036, "EVENT_SERVER_ADMIN_GROUP_ERROR"},
    {1037, "EVENT_SERVER_CLEANUP_STARTED"},
    {1038, "EVENT_SERVER_IPCLEANUP_FINISHED"},
    {1039, "EVENT_SERVER_MCASTCLEANUP_FINISHED"},
    {1040, "EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED"},
    {1041, "DHCP_ROGUE_EVENT_NO_NETWORK"},
    {1042, "DHCP_ROGUE_EVENT_UNAUTHORIZED_INFO"},
    {1043, "DHCP_ROGUE_EVENT_STARTED"},
    {1044, "DHCP_ROGUE_EVENT_STARTED_DOMAIN"},
    {1045, "DHCP_ROGUE_EVENT_STOPPED"},
    {1046, "DHCP_ROGUE_EVENT_STOPPED_DOMAIN"},
    {1047, "DHCP_ROGUE_EVENT_JUST_UPGRADED"},
    {1048, "DHCP_ROGUE_EVENT_JUST_UPGRADED_DOMAIN"},
    {1049, "DHCP_ROGUE_EVENT_CANT_FIND_DOMAIN"},
    {1050, "DHCP_ROGUE_EVENT_NETWORK_FAILURE"},
    {1051, "DHCP_ROGUE_EVENT_UNAUTHORIZED"},
    {1052, "DHCP_ROGUE_EVENT_OTHER_SERVER"},
    {1053, "DHCP_ROGUE_EVENT_SAM_OTHER_SERVER"},
    {1054, "DHCP_ROGUE_EVENT_SHUTDOWN"},
    {1055, "DHCP_EVENT_DNS_REGPARAMS_FAILURE"},
    {1056, "DHCP_EVENT_NO_DNSCREDENTIALS_ON_DC"},
    {1057, "EVENT_SERVER_DATABASE_CONVERSION"},
    {1058, "EVENT_SERVER_INIT_CONFIG_FAILED"},
    {1059, "EVENT_SERVER_COULDNT_SEE_DS"},
    {1060, "EVENT_SERVER_AUDITLOG_PATH_NOT_ACCESSIBLE"},
    {1061, "EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE"},
    {1062, "EVENT_SERVER_DB_PATH_NOT_ACCESSIBLE"},
    {1063, "EVENT_SERVER_SCOPE_FULL"},

    {0     , "Event tag not found"}
};


    // The following SceCli event codes from
    // \\index1\sdnt\ds\security\services\scerpc\uevents.mc
FRS_EL_ENTRY SecPolicyEngine[] = {

    {1000, "SCEEVENT_ERROR_BACKUP_SECURITY"},
    {1001, "SCEPOL_ERROR_PROCESS_GPO"},
    {1002, "SCEEVENT_ERROR_CREATE_GPO"},
    {1003, "SCEEVENT_ERROR_QUEUE_RETRY_TIMEOUT"},
    {1004, "SCEEVENT_ERROR_POLICY_QUEUE"},
    {1005, "SCEEVENT_ERROR_JET_DATABASE"},
    {1006, "SCEEVENT_ERROR_POLICY_PDCVERIFY"},
    {1007, "SCEEVENT_ERROR_POLICY_PDCTIMEOUT"},
    {1200, "SCEEVENT_WARNING_BACKUP_SECURITY"},
    {1201, "SCEEVENT_WARNING_REGISTER"},
    {1202, "SCEPOL_WARNING_PROCESS_GPO"},
    {1203, "SCEEVENT_WARNING_MACHINE_ROLE"},
    {1204, "SCEEVENT_WARNING_PROMOTE_SECURITY"},
    {1205, "SCEEVENT_WARNING_LOW_DISK_SPACE"},
    {1500, "SCEEVENT_INFO_BACKUP_SECURITY"},
    {1700, "SCEEVENT_INFO_REPLICA"},
    {1701, "SCEEVENT_INFO_REGISTER"},
    {1702, "SCEPOL_INFO_IGNORE_DOMAINPOLICY"},
    {1703, "SCEPOL_INFO_GPO_NOCHANGE"},
    {1704, "SCEPOL_INFO_GPO_COMPLETED"},
    {1705, "SCEPOL_INFO_PROCESS_GPO"},
    {1706, "SCEEVENT_ERROR_CONVERT_PARAMETER"},
    {1707, "SCEEVENT_ERROR_CONVERT_BAD_ENV_VAR"},
    {1708, "SCEEVENT_INFO_ERROR_CONVERT_DRIVE"},
    {1709, "SCEEVENT_INFO_SUCCESS_CONVERT_DRIVE"},
    {1710, "SCEEVENT_WARNING_BACKUP_SECURITY_ROOT_SDDL"},

    {0     , "Event tag not found"}
};




    // The following time service codes from
    // \\index1\w2krtm\private\ntrk\source\timeserv\timeserv.h
FRS_EL_ENTRY TimeservEvents[] = {
    {0x40000000L, "MSG_TIMESET_SMALL"},
    {0x40000001L, "MSG_TIMESOURCE"},
    {0x40000002L, "MSG_CHANGE"},
    {0x40000003L, "MSG_BC_FLYING"},
    {0x40000004L, "MSG_TOO_OFTEN"},
    {0x40000005L, "MSG_LEAP"},
    {0x40000006L, "MSG_TIMESET_LARGE"},
    {0x40000007L, "MSG_TOO_MUCH_SKEW"},
    {0x80000008L, "MSG_QUAL_A"},
    {0x80000009L, "MSG_NC_NOTSET"},
    {0x8000000AL, "MSG_INET_FAILED"},
    {0x8000000BL, "MSG_NTPTROUBLE"},
    {0x8000000CL, "MSG_NTPBAD"},
    {0x8000000DL, "MSG_GPSBAD"},
    {0x8000000EL, "MSG_TOOBIG"},
    {0x8000000FL, "MSG_DST"},
    {0x80000010L, "MSG_COMM_PORT"},
    {0x80000011L, "MSG_MODEM_TIMEOUT"},
    {0x80000012L, "MSG_LINE_NOISE"},
    {0x80000013L, "MSG_GC_TIMEOUTOK"},
    {0x80000014L, "MSG_GC_NOTSET"},
    {0x80000015L, "MSG_GC_NOTENTHS"},
    {0x80000016L, "MSG_PRIMARY_FAILED"},
    {0x80000017L, "MSG_SECONDARY_FAILED"},
    {0x80000018L, "MSG_TOD_FAILED"},
    {0x80000019L, "MSG_LONG_TIME"},
    {0x8000001AL, "MSG_NO_DELAY"},
    {0x8000001BL, "MSG_BC_NOTSET"},
    {0x8000001CL, "MSG_DELAY_FAIL"},
    {0x8000001DL, "MSG_FIFO"},
    {0x8000001EL, "MSG_HEALTH"},
    {0x8000001FL, "MSG_TOOEARLY"},
    {0xC0000020L, "MSG_EVENT_KEY"},
    {0xC0000021L, "MSG_EVENT_MSG"},
    {0xC0000022L, "MSG_EVENT_TYPES"},
    {0xC0000023L, "MSG_SCM_FAILED"},
    {0xC0000024L, "MSG_CS_FAILED"},
    {0xC0000025L, "MSG_OPT_FAILED"},
    {0xC0000026L, "MSG_ATPE_FAILED"},
    {0xC0000027L, "MSG_ATPD_FAILED"},
    {0xC0000028L, "MSG_GCS_FAILED"},
    {0xC0000029L, "MSG_SCS_FAILED"},
    {0xC000002AL, "MSG_GCT_FAILED"},
    {0xC000002BL, "MSG_SCT_FAILED"},
    {0xC000002CL, "MSG_DEV_TIMEOUT"},
    {0xC000002DL, "MSG_SLT_FAILED"},
    {0xC000002EL, "MSG_SST_FAILED"},
    {0xC000002FL, "MSG_CLOSE_FAILED"},
    {0xC0000030L, "MSG_SSS_FAILED"},
    {0xC0000031L, "MSG_BC_DRIVER"},
    {0xC0000032L, "MSG_WNOE_FAILED"},
    {0xC0000033L, "MSG_SOCKET_FAILED"},
    {0xC0000034L, "MSG_NTP_NAME"},
    {0x40000040L, "MSG_NTP_RFC868"},

    {0     , "Event tag not found"}
};


    // \\index1\w2krtm\private\security\kerb.prx\server\kdcevent.h
FRS_EL_ENTRY KDCEvents[] = {
    {0x00000001L, "CATEGORY_KDC"},
    {0x00000002L, "CATEGORY_MAX_CATEGORY"},
    {0x80000003L, "KDCEVENT_UNKNOWN_PRINCIPAL"},
    {0x80000004L, "KDCEVENT_FAILED_DOMAIN_CREDS"},
    {0xC0000005L, "KDCEVENT_POLICY_UPDATE_FAILED"},
    {0xC0000006L, "KDCEVENT_DOMAIN_LIST_UPDATE_FAILED"},
    {0xC0000007L, "KDCEVENT_SAM_CALL_FAILED"},
    {0xC0000008L, "KDCEVENT_NO_KEY_TYPE"},
    {0x00000009L, "KDCEVENT_KRBTGT_PASSWORD_CHANGED"},
    {0xC000000AL, "KDCEVENT_KRBTGT_PASSWORD_CHANGE_FAILED"},
    {0xC000000BL, "KDCEVENT_NAME_NOT_UNIQUE"},

    {0     , "Event tag not found"}
};


// \nt\ds\ds\src\sam\server\sampmsgs.mc

FRS_EL_ENTRY SAMEvents[] = {
    {0x3000L, "SAMMSG_COMMIT_FAILED"},
    {0x3001L, "SAMMSG_REFRESH_FAILED"},
    {0x3002L, "SAMMSG_UPDATE_FAILED"},
    {0x3003L, "SAMMSG_RPC_INIT_FAILED"},
    {0x3004L, "SAMMSG_DUPLICATE_ACCOUNT_NAME"},
    {0x3005L, "SAMMSG_DUPLICATE_SID"},
    {0x3006L, "SAMMSG_LOCKOUT_NOT_UPDATED"},
    {0x3007L, "SAMMSG_DATABASE_FILE_NOT_DELETED"},
    {0x3008L, "SAMMSG_DATABASE_DIR_NOT_DELETED"},
    {0x3009L, "SAMMSG_PROMOTED_TO_PDC"},
    {0x300AL, "SAMMSG_DC_NEEDS_TO_BE_COMPUTER"},
    {0x300BL, "SAMMSG_SITE_INFO_UPDATE_FAILED"},
    {0x300CL, "SAMMSG_SITE_INFO_UPDATE_SUCCEEDED_ON"},
    {0x300DL, "SAMMSG_SITE_INFO_UPDATE_SUCCEEDED_OFF"},
    {0x300EL, "SAMMSG_CREDENTIAL_UPDATE_PKG_FAILED"},
    {0x4000L, "SAMMSG_DUPLICATE_ACCOUNT"},
    {0x4001L, "SAMMSG_USER_NOT_UPGRADED"},
    {0x4002L, "SAMMSG_UNKNOWN_USER_NOT_UPGRADED"},
    {0x4003L, "SAMMSG_ALIAS_NOT_UPGRADED"},
    {0x4004L, "SAMMSG_UNKNOWN_ALIAS_NOT_UPGRADED"},
    {0x4005L, "SAMMSG_GROUP_NOT_UPGRADED"},
    {0x4006L, "SAMMSG_UNKNOWN_GROUP_NOT_UPGRADED"},
    {0x4007L, "SAMMSG_ERROR_ALIAS_MEMBER"},
    {0x4008L, "SAMMSG_ERROR_ALIAS_MEMBER_UNKNOWN"},
    {0x4009L, "SAMMSG_ERROR_GROUP_MEMBER"},
    {0x400aL, "SAMMSG_ERROR_GROUP_MEMBER_UNKNOWN"},
    {0x400bL, "SAMMSG_FATAL_UPGRADE_ERROR"},
    {0x400cL, "SAMMSG_KRBTGT_RENAMED"},
    {0x400dL, "SAMMSG_BLANK_ADMIN_PASSWORD"},
    {0x400eL, "SAMMSG_ERROR_UPGRADE_USERPARMS"},
    {0x400fL, "SAMMSG_ERROR_SET_USERPARMS"},
    {0x4010L, "SAMMSG_ACCEPTABLE_ERROR_UPGRADE_USER"},
    {0x4011L, "SAMMSG_MEMBERSHIP_SETUP_ERROR_NO_GROUP"},
    {0x4012L, "SAMMSG_MEMBERSHIP_SETUP_ERROR"},
    {0x4013L, "SAMMSG_USER_SETUP_ERROR"},
    {0x4014L, "SAMMSG_EA_TO_ADMIN_FAILED"},
    {0x4015L, "SAMMSG_MACHINE_ACCOUNT_MISSING"},
    {0x4016L, "SAMMSG_WELL_KNOWN_ACCOUNT_RECREATED"},
    {0x4017L, "SAMMSG_WELL_KNOWN_GROUP_RECREATED"},
    {0x4018L, "SAMMSG_CHANGE_TO_NATIVE_MODE"},
    {0x4100L, "SAMMSG_RID_MANAGER_INITIALIZATION"},
    {0x4101L, "SAMMSG_RID_POOL_UPDATE_FAILED"},
    {0x4102L, "SAMMSG_GET_NEXT_RID_ERROR"},
    {0x4103L, "SAMMSG_NO_RIDS_ASSIGNED"},
    {0x4104L, "SAMMSG_MAX_DOMAIN_RID"},
    {0x4105L, "SAMMSG_MAX_DC_RID"},
    {0x4106L, "SAMMSG_INVALID_RID"},
    {0x4107L, "SAMMSG_REQUESTING_NEW_RID_POOL"},
    {0x4108L, "SAMMSG_RID_REQUEST_STATUS_SUCCESS"},
    {0x4109L, "SAMMSG_RID_MANAGER_CREATION"},
    {0x410AL, "SAMMSG_RID_INIT_FAILURE"},
    {0x410BL, "SAMMSG_RID_REQUEST_STATUS_FAILURE"},
    {0x4200L, "SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP"},
    {0x4201L, "SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_LOCAL_GROUP"},
    {0x4202L, "SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP"},
    {0x4203L, "SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP"},
    {0x4204L, "SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_GLOBAL_GROUP"},
    {0x4205L, "SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP"},
    {0x4206L, "SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP"},
    {0x4207L, "SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP"},
    {0x4208L, "SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP"},
    {0x4209L, "SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP"},
    {0x420AL, "SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP"},
    {0x420BL, "SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_LOCAL_GROUP"},
    {0x420CL, "SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP"},
    {0x420DL, "SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP"},
    {0x420EL, "SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_GLOBAL_GROUP"},
    {0x420FL, "SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP"},
    {0x4210L, "SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP"},
    {0x4211L, "SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP"},
    {0x4212L, "SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP"},
    {0x4213L, "SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP"},
    {0x4214L, "SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP"},
    {0x4215L, "SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP"},
    {0x4216L, "SAMMSG_AUDIT_MEMBER_ACCOUNT_NAME_NOT_AVAILABLE"},

    {0     , "Event tag not found"}
};




// The following come from \\index1\sdnt\public\sdk\inc\lmerrlog.h

#define ERRLOG_BASE 3100        /* NELOG errors start here */
#define ERRLOG2_BASE 5700        /* New NT NELOG errors start here */
FRS_EL_ENTRY NetlogonEvents[] = {

    {(ERRLOG_BASE + 0), "NELOG_Internal_Error"},
    {(ERRLOG_BASE + 1), "NELOG_Resource_Shortage"},
    {(ERRLOG_BASE + 2), "NELOG_Unable_To_Lock_Segment"},
    {(ERRLOG_BASE + 3), "NELOG_Unable_To_Unlock_Segment"},
    {(ERRLOG_BASE + 4), "NELOG_Uninstall_Service"},
    {(ERRLOG_BASE + 5), "NELOG_Init_Exec_Fail"},
    {(ERRLOG_BASE + 6), "NELOG_Ncb_Error"},
    {(ERRLOG_BASE + 7), "NELOG_Net_Not_Started"},
    {(ERRLOG_BASE + 8), "NELOG_Ioctl_Error"},
    {(ERRLOG_BASE + 9), "NELOG_System_Semaphore"},
    {(ERRLOG_BASE + 10), "NELOG_Init_OpenCreate_Err"},
    {(ERRLOG_BASE + 11), "NELOG_NetBios"},
    {(ERRLOG_BASE + 12), "NELOG_SMB_Illegal"},
    {(ERRLOG_BASE + 13), "NELOG_Service_Fail"},
    {(ERRLOG_BASE + 14), "NELOG_Entries_Lost"},
    {(ERRLOG_BASE + 20), "NELOG_Init_Seg_Overflow"},
    {(ERRLOG_BASE + 21), "NELOG_Srv_No_Mem_Grow"},
    {(ERRLOG_BASE + 22), "NELOG_Access_File_Bad"},
    {(ERRLOG_BASE + 23), "NELOG_Srvnet_Not_Started"},
    {(ERRLOG_BASE + 24), "NELOG_Init_Chardev_Err"},
    {(ERRLOG_BASE + 25), "NELOG_Remote_API"},
    {(ERRLOG_BASE + 26), "NELOG_Ncb_TooManyErr"},
    {(ERRLOG_BASE + 27), "NELOG_Mailslot_err"},
    {(ERRLOG_BASE + 28), "NELOG_ReleaseMem_Alert"},
    {(ERRLOG_BASE + 29), "NELOG_AT_cannot_write"},
    {(ERRLOG_BASE + 30), "NELOG_Cant_Make_Msg_File"},
    {(ERRLOG_BASE + 31), "NELOG_Exec_Netservr_NoMem"},
    {(ERRLOG_BASE + 32), "NELOG_Server_Lock_Failure"},
    {(ERRLOG_BASE + 40), "NELOG_Msg_Shutdown"},
    {(ERRLOG_BASE + 41), "NELOG_Msg_Sem_Shutdown"},
    {(ERRLOG_BASE + 50), "NELOG_Msg_Log_Err"},
    {(ERRLOG_BASE + 51), "NELOG_VIO_POPUP_ERR"},
    {(ERRLOG_BASE + 52), "NELOG_Msg_Unexpected_SMB_Type"},
    {(ERRLOG_BASE + 60), "NELOG_Wksta_Infoseg"},
    {(ERRLOG_BASE + 61), "NELOG_Wksta_Compname"},
    {(ERRLOG_BASE + 62), "NELOG_Wksta_BiosThreadFailure"},
    {(ERRLOG_BASE + 63), "NELOG_Wksta_IniSeg"},
    {(ERRLOG_BASE + 64), "NELOG_Wksta_HostTab_Full"},
    {(ERRLOG_BASE + 65), "NELOG_Wksta_Bad_Mailslot_SMB"},
    {(ERRLOG_BASE + 66), "NELOG_Wksta_UASInit"},
    {(ERRLOG_BASE + 67), "NELOG_Wksta_SSIRelogon"},
    {(ERRLOG_BASE + 70), "NELOG_Build_Name"},
    {(ERRLOG_BASE + 71), "NELOG_Name_Expansion"},
    {(ERRLOG_BASE + 72), "NELOG_Message_Send"},
    {(ERRLOG_BASE + 73), "NELOG_Mail_Slt_Err"},
    {(ERRLOG_BASE + 74), "NELOG_AT_cannot_read"},
    {(ERRLOG_BASE + 75), "NELOG_AT_sched_err"},
    {(ERRLOG_BASE + 76), "NELOG_AT_schedule_file_created"},
    {(ERRLOG_BASE + 77), "NELOG_Srvnet_NB_Open"},
    {(ERRLOG_BASE + 78), "NELOG_AT_Exec_Err"},
    {(ERRLOG_BASE + 80), "NELOG_Lazy_Write_Err"},
    {(ERRLOG_BASE + 81), "NELOG_HotFix"},
    {(ERRLOG_BASE + 82), "NELOG_HardErr_From_Server"},
    {(ERRLOG_BASE + 83), "NELOG_LocalSecFail1"},
    {(ERRLOG_BASE + 84), "NELOG_LocalSecFail2"},
    {(ERRLOG_BASE + 85), "NELOG_LocalSecFail3"},
    {(ERRLOG_BASE + 86), "NELOG_LocalSecGeneralFail"},
    {(ERRLOG_BASE + 90), "NELOG_NetWkSta_Internal_Error"},
    {(ERRLOG_BASE + 91), "NELOG_NetWkSta_No_Resource"},
    {(ERRLOG_BASE + 92), "NELOG_NetWkSta_SMB_Err"},
    {(ERRLOG_BASE + 93), "NELOG_NetWkSta_VC_Err"},
    {(ERRLOG_BASE + 94), "NELOG_NetWkSta_Stuck_VC_Err"},
    {(ERRLOG_BASE + 95), "NELOG_NetWkSta_NCB_Err"},
    {(ERRLOG_BASE + 96), "NELOG_NetWkSta_Write_Behind_Err"},
    {(ERRLOG_BASE + 97), "NELOG_NetWkSta_Reset_Err"},
    {(ERRLOG_BASE + 98), "NELOG_NetWkSta_Too_Many"},
    {(ERRLOG_BASE + 104), "NELOG_Srv_Thread_Failure"},
    {(ERRLOG_BASE + 105), "NELOG_Srv_Close_Failure"},
    {(ERRLOG_BASE + 106), "NELOG_ReplUserCurDir"},
    {(ERRLOG_BASE + 107), "NELOG_ReplCannotMasterDir"},
    {(ERRLOG_BASE + 108), "NELOG_ReplUpdateError"},
    {(ERRLOG_BASE + 109), "NELOG_ReplLostMaster"},
    {(ERRLOG_BASE + 110), "NELOG_NetlogonAuthDCFail"},
    {(ERRLOG_BASE + 111), "NELOG_ReplLogonFailed"},
    {(ERRLOG_BASE + 112), "NELOG_ReplNetErr"},
    {(ERRLOG_BASE + 113), "NELOG_ReplMaxFiles"},
    {(ERRLOG_BASE + 114), "NELOG_ReplMaxTreeDepth"},
    {(ERRLOG_BASE + 115), "NELOG_ReplBadMsg"},
    {(ERRLOG_BASE + 116), "NELOG_ReplSysErr"},
    {(ERRLOG_BASE + 117), "NELOG_ReplUserLoged"},
    {(ERRLOG_BASE + 118), "NELOG_ReplBadImport"},
    {(ERRLOG_BASE + 119), "NELOG_ReplBadExport"},
    {(ERRLOG_BASE + 120), "NELOG_ReplSignalFileErr"},
    {(ERRLOG_BASE + 121), "NELOG_DiskFT"},
    {(ERRLOG_BASE + 122), "NELOG_ReplAccessDenied"},
    {(ERRLOG_BASE + 123), "NELOG_NetlogonFailedPrimary"},
    {(ERRLOG_BASE + 124), "NELOG_NetlogonPasswdSetFailed"},
    {(ERRLOG_BASE + 125), "NELOG_NetlogonTrackingError"},
    {(ERRLOG_BASE + 126), "NELOG_NetlogonSyncError"},
    {(ERRLOG_BASE + 127), "NELOG_NetlogonRequireSignOrSealError"},
    {(ERRLOG_BASE + 130), "NELOG_UPS_PowerOut"},
    {(ERRLOG_BASE + 131), "NELOG_UPS_Shutdown"},
    {(ERRLOG_BASE + 132), "NELOG_UPS_CmdFileError"},
    {(ERRLOG_BASE + 133), "NELOG_UPS_CannotOpenDriver"},
    {(ERRLOG_BASE + 134), "NELOG_UPS_PowerBack"},
    {(ERRLOG_BASE + 135), "NELOG_UPS_CmdFileConfig"},
    {(ERRLOG_BASE + 136), "NELOG_UPS_CmdFileExec"},
    {(ERRLOG_BASE + 150), "NELOG_Missing_Parameter"},
    {(ERRLOG_BASE + 151), "NELOG_Invalid_Config_Line"},
    {(ERRLOG_BASE + 152), "NELOG_Invalid_Config_File"},
    {(ERRLOG_BASE + 153), "NELOG_File_Changed"},
    {(ERRLOG_BASE + 154), "NELOG_Files_Dont_Fit"},
    {(ERRLOG_BASE + 155), "NELOG_Wrong_DLL_Version"},
    {(ERRLOG_BASE + 156), "NELOG_Error_in_DLL"},
    {(ERRLOG_BASE + 157), "NELOG_System_Error"},
    {(ERRLOG_BASE + 158), "NELOG_FT_ErrLog_Too_Large"},
    {(ERRLOG_BASE + 159), "NELOG_FT_Update_In_Progress"},
    {(ERRLOG_BASE + 160), "NELOG_Joined_Domain"},
    {(ERRLOG_BASE + 199), "NELOG_OEM_Code"},
    {(ERRLOG2_BASE + 0), "NELOG_NetlogonSSIInitError"},
    {(ERRLOG2_BASE + 1), "NELOG_NetlogonFailedToUpdateTrustList"},
    {(ERRLOG2_BASE + 2), "NELOG_NetlogonFailedToAddRpcInterface"},
    {(ERRLOG2_BASE + 3), "NELOG_NetlogonFailedToReadMailslot"},
    {(ERRLOG2_BASE + 4), "NELOG_NetlogonFailedToRegisterSC"},
    {(ERRLOG2_BASE + 5), "NELOG_NetlogonChangeLogCorrupt"},
    {(ERRLOG2_BASE + 6), "NELOG_NetlogonFailedToCreateShare"},
    {(ERRLOG2_BASE + 7), "NELOG_NetlogonDownLevelLogonFailed"},
    {(ERRLOG2_BASE + 8), "NELOG_NetlogonDownLevelLogoffFailed"},
    {(ERRLOG2_BASE + 9), "NELOG_NetlogonNTLogonFailed"},
    {(ERRLOG2_BASE + 10), "NELOG_NetlogonNTLogoffFailed"},
    {(ERRLOG2_BASE + 11), "NELOG_NetlogonPartialSyncCallSuccess"},
    {(ERRLOG2_BASE + 12), "NELOG_NetlogonPartialSyncCallFailed"},
    {(ERRLOG2_BASE + 13), "NELOG_NetlogonFullSyncCallSuccess"},
    {(ERRLOG2_BASE + 14), "NELOG_NetlogonFullSyncCallFailed"},
    {(ERRLOG2_BASE + 15), "NELOG_NetlogonPartialSyncSuccess"},
    {(ERRLOG2_BASE + 16), "NELOG_NetlogonPartialSyncFailed"},
    {(ERRLOG2_BASE + 17), "NELOG_NetlogonFullSyncSuccess"},
    {(ERRLOG2_BASE + 18), "NELOG_NetlogonFullSyncFailed"},
    {(ERRLOG2_BASE + 19), "NELOG_NetlogonAuthNoDomainController"},
    {(ERRLOG2_BASE + 20), "NELOG_NetlogonAuthNoTrustLsaSecret"},
    {(ERRLOG2_BASE + 21), "NELOG_NetlogonAuthNoTrustSamAccount"},
    {(ERRLOG2_BASE + 22), "NELOG_NetlogonServerAuthFailed"},
    {(ERRLOG2_BASE + 23), "NELOG_NetlogonServerAuthNoTrustSamAccount"},
    {(ERRLOG2_BASE + 24), "NELOG_FailedToRegisterSC"},
    {(ERRLOG2_BASE + 25), "NELOG_FailedToSetServiceStatus"},
    {(ERRLOG2_BASE + 26), "NELOG_FailedToGetComputerName"},
    {(ERRLOG2_BASE + 27), "NELOG_DriverNotLoaded"},
    {(ERRLOG2_BASE + 28), "NELOG_NoTranportLoaded"},
    {(ERRLOG2_BASE + 29), "NELOG_NetlogonFailedDomainDelta"},
    {(ERRLOG2_BASE + 30), "NELOG_NetlogonFailedGlobalGroupDelta"},
    {(ERRLOG2_BASE + 31), "NELOG_NetlogonFailedLocalGroupDelta"},
    {(ERRLOG2_BASE + 32), "NELOG_NetlogonFailedUserDelta"},
    {(ERRLOG2_BASE + 33), "NELOG_NetlogonFailedPolicyDelta"},
    {(ERRLOG2_BASE + 34), "NELOG_NetlogonFailedTrustedDomainDelta"},
    {(ERRLOG2_BASE + 35), "NELOG_NetlogonFailedAccountDelta"},
    {(ERRLOG2_BASE + 36), "NELOG_NetlogonFailedSecretDelta"},
    {(ERRLOG2_BASE + 37), "NELOG_NetlogonSystemError"},
    {(ERRLOG2_BASE + 38), "NELOG_NetlogonDuplicateMachineAccounts"},
    {(ERRLOG2_BASE + 39), "NELOG_NetlogonTooManyGlobalGroups"},
    {(ERRLOG2_BASE + 40), "NELOG_NetlogonBrowserDriver"},
    {(ERRLOG2_BASE + 41), "NELOG_NetlogonAddNameFailure"},
    {(ERRLOG2_BASE + 42), "NELOG_RplMessages"},
    {(ERRLOG2_BASE + 43), "NELOG_RplXnsBoot"},
    {(ERRLOG2_BASE + 44), "NELOG_RplSystem"},
    {(ERRLOG2_BASE + 45), "NELOG_RplWkstaTimeout"},
    {(ERRLOG2_BASE + 46), "NELOG_RplWkstaFileOpen"},
    {(ERRLOG2_BASE + 47), "NELOG_RplWkstaFileRead"},
    {(ERRLOG2_BASE + 48), "NELOG_RplWkstaMemory"},
    {(ERRLOG2_BASE + 49), "NELOG_RplWkstaFileChecksum"},
    {(ERRLOG2_BASE + 50), "NELOG_RplWkstaFileLineCount"},
    {(ERRLOG2_BASE + 51), "NELOG_RplWkstaBbcFile"},
    {(ERRLOG2_BASE + 52), "NELOG_RplWkstaFileSize"},
    {(ERRLOG2_BASE + 53), "NELOG_RplWkstaInternal"},
    {(ERRLOG2_BASE + 54), "NELOG_RplWkstaWrongVersion"},
    {(ERRLOG2_BASE + 55), "NELOG_RplWkstaNetwork"},
    {(ERRLOG2_BASE + 56), "NELOG_RplAdapterResource"},
    {(ERRLOG2_BASE + 57), "NELOG_RplFileCopy"},
    {(ERRLOG2_BASE + 58), "NELOG_RplFileDelete"},
    {(ERRLOG2_BASE + 59), "NELOG_RplFilePerms"},
    {(ERRLOG2_BASE + 60), "NELOG_RplCheckConfigs"},
    {(ERRLOG2_BASE + 61), "NELOG_RplCreateProfiles"},
    {(ERRLOG2_BASE + 62), "NELOG_RplRegistry"},
    {(ERRLOG2_BASE + 63), "NELOG_RplReplaceRPLDISK"},
    {(ERRLOG2_BASE + 64), "NELOG_RplCheckSecurity"},
    {(ERRLOG2_BASE + 65), "NELOG_RplBackupDatabase"},
    {(ERRLOG2_BASE + 66), "NELOG_RplInitDatabase"},
    {(ERRLOG2_BASE + 67), "NELOG_RplRestoreDatabaseFailure"},
    {(ERRLOG2_BASE + 68), "NELOG_RplRestoreDatabaseSuccess"},
    {(ERRLOG2_BASE + 69), "NELOG_RplInitRestoredDatabase"},
    {(ERRLOG2_BASE + 70), "NELOG_NetlogonSessionTypeWrong"},
    {(ERRLOG2_BASE + 71), "NELOG_RplUpgradeDBTo40"},
    {(ERRLOG2_BASE + 72), "NELOG_NetlogonLanmanBdcsNotAllowed"},
    {(ERRLOG2_BASE + 73), "NELOG_NetlogonNoDynamicDns"},
    {(ERRLOG2_BASE + 74), "NELOG_NetlogonDynamicDnsRegisterFailure"},
    {(ERRLOG2_BASE + 75), "NELOG_NetlogonDynamicDnsDeregisterFailure"},
    {(ERRLOG2_BASE + 76), "NELOG_NetlogonFailedFileCreate"},
    {(ERRLOG2_BASE + 77), "NELOG_NetlogonGetSubnetToSite"},
    {(ERRLOG2_BASE + 78), "NELOG_NetlogonNoSiteForClient"},
    {(ERRLOG2_BASE + 79), "NELOG_NetlogonBadSiteName"},
    {(ERRLOG2_BASE + 80), "NELOG_NetlogonBadSubnetName"},
    {(ERRLOG2_BASE + 81), "NELOG_NetlogonDynamicDnsServerFailure"},
    {(ERRLOG2_BASE + 82), "NELOG_NetlogonDynamicDnsFailure"},
    {(ERRLOG2_BASE + 83), "NELOG_NetlogonRpcCallCancelled"},
    {(ERRLOG2_BASE + 84), "NELOG_NetlogonDcSiteCovered"},
    {(ERRLOG2_BASE + 85), "NELOG_NetlogonDcSiteNotCovered"},
    {(ERRLOG2_BASE + 86), "NELOG_NetlogonGcSiteCovered"},
    {(ERRLOG2_BASE + 87), "NELOG_NetlogonGcSiteNotCovered"},
    {(ERRLOG2_BASE + 88), "NELOG_NetlogonFailedSpnUpdate"},
    {(ERRLOG2_BASE + 89), "NELOG_NetlogonFailedDnsHostNameUpdate"},
    {(ERRLOG2_BASE + 90), "NELOG_NetlogonAuthNoUplevelDomainController"},
    {(ERRLOG2_BASE + 91), "NELOG_NetlogonAuthDomainDowngraded"},
    {(ERRLOG2_BASE + 92), "NELOG_NetlogonNdncSiteCovered"},
    {(ERRLOG2_BASE + 93), "NELOG_NetlogonNdncSiteNotCovered"},
    {(ERRLOG2_BASE + 94), "NELOG_NetlogonDcOldSiteCovered"},
    {(ERRLOG2_BASE + 95), "NELOG_NetlogonDcSiteNotCoveredAuto"},
    {(ERRLOG2_BASE + 96), "NELOG_NetlogonGcOldSiteCovered"},
    {(ERRLOG2_BASE + 97), "NELOG_NetlogonGcSiteNotCoveredAuto"},
    {(ERRLOG2_BASE + 98), "NELOG_NetlogonNdncOldSiteCovered"},
    {(ERRLOG2_BASE + 99), "NELOG_NetlogonNdncSiteNotCoveredAuto"},
    {(ERRLOG2_BASE + 100), "NELOG_NetlogonSpnMultipleSamAccountNames"},
    {(ERRLOG2_BASE + 101), "NELOG_NetlogonSpnCrackNamesFailure"},
    {(ERRLOG2_BASE + 102), "NELOG_NetlogonNoAddressToSiteMapping"},
    {(ERRLOG2_BASE + 103), "NELOG_NetlogonInvalidGenericParameterValue"},
    {(ERRLOG2_BASE + 104), "NELOG_NetlogonInvalidDwordParameterValue"},
    {(ERRLOG2_BASE + 105), "NELOG_NetlogonServerAuthFailedNoAccount"},
    {(ERRLOG2_BASE + 106), "NELOG_NetlogonNoDynamicDnsManual"},
    {(ERRLOG2_BASE + 107), "NELOG_NetlogonNoSiteForClients"},

    {0     , "Event tag not found"}

};



//
// DS Eventlog codes.
//
// DIR_ETYPE_WARNING                0x2
// DIR_ETYPE_SECURITY               0x0
// DIR_ETYPE_INFORMATIONAL          0x1
// DIR_ETYPE_ERROR                  0x3
// KCC_CATEGORY                     ((MessageId)0x00000001L)
// SECURITY_CATEGORY                ((MessageId)0x00000002L)
// XDS_INTERFACE_CATEGORY           ((MessageId)0x00000003L)
// MAPI_CATEGORY                    ((MessageId)0x00000004L)
// REPLICATION_CATEGORY             ((MessageId)0x00000005L)
// GARBAGE_COLLECTION_CATEGORY      ((MessageId)0x00000006L)
// INTERNAL_CONFIGURATION_CATEGORY  ((MessageId)0x00000007L)
// DIRECTORY_ACCESS_CATEGORY        ((MessageId)0x00000008L)
// INTERNAL_PROCESSING_CATEGORY     ((MessageId)0x00000009L)
// PERFORMANCE_CATEGORY             ((MessageId)0x0000000AL)
// STARTUP_SHUTDOWN_CATEGORY        ((MessageId)0x0000000BL)
// SERVICE_CONTROL_CATEGORY         ((MessageId)0x0000000CL)
// NAME_RESOLUTION_CATEGORY         ((MessageId)0x0000000DL)
// BACKUP_CATEGORY                  ((MessageId)0x0000000EL)
// FIELD_ENGINEERING_CATEGORY       ((MessageId)0x0000000FL)
// LDAP_INTERFACE_CATEGORY          ((MessageId)0x00000010L)
// SETUP_CATEGORY                   ((MessageId)0x00000011L)
// GC_CATEGORY                      ((MessageId)0x00000012L)
// ISM_CATEGORY                     ((MessageId)0x00000013L)
// GROUP_CACHING_CATEGORY           ((MessageId)0x00000014L)
// LVR_CATEGORY                     ((MessageId)0x00000015L)
// DS_RPC_CLIENT_CATEGORY           ((MessageId)0x00000016L)
// DS_RPC_SERVER_CATEGORY           ((MessageId)0x00000017L)
// DS_SCHEMA_CATEGORY               ((MessageId)0x00000018L)
// ALERT_TEMPLATE                   ((MessageId)0x00000320L)

// Below is built from E:\nt\ds\ds\src\idl\mdcodes.mc

FRS_EL_ENTRY DirSvcEvents[] = {
    {0x400003E8, "DIRLOG_STARTED"},
    {0x400003E9, "DIRLOG_START_FAILED"},
    {0x400003EA, "DIRLOG_INSTALLED"},
    {0xC00003EB, "DIRLOG_DBINIT_FAILED"},
    {0x400003EC, "DIRLOG_NORMAL_SHUTDOWN"},
    {0x400003ED, "DIRLOG_GC_STARTED"},
    {0x400003EE, "DIRLOG_GC_COMPLETED"},
    {0x400003EF, "DIRLOG_CHK_INIT_SUCCESS"},
    {0xC00003F0, "DIRLOG_CHK_INIT_FAILURE"},
    {0x400003F1, "DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_BEGIN"},
    {0xC00003F2, "DIRLOG_NO_MEMORY_FOR_LOG_OVERRIDES"},
    {0x400003F3, "DIRLOG_SERVICE_GARBAGE_COLLECT"},
    {0x400003F4, "DIRLOG_SERVICE_UNKNOWN"},
    {0x400003F5, "DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_NORMAL"},
    {0x800003F6, "DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_ABNORMAL"},
    {0x400003F7, "DIRLOG_CHK_STOP_SUCCESS"},
    {0xC00003F8, "DIRLOG_SCHEMA_NOT_LOADED"},
    {0xC00003F9, "DIRLOG_PREFIX_LOAD_FAILED"},
    {0xC00003FA, "DIRLOG_CONFIG_PARAM_MISSING"},
    {0xC00003FB, "DIRLOG_CANT_REMOVE_ATT_CACHE"},
    {0xC00003FC, "DIRLOG_BAD_CONT_REF"},
    {0xC00003FD, "DIRLOG_CANT_REPLACE_HIDDEN_REC"},
    {0xC00003FE, "DIRLOG_READ_CACHE_SKIPPED"},
    {0xC00003FF, "DIRLOG_CODE_INCONSISTENCY"},
    {0xC0000400, "DIRLOG_CHK_STOP_FAILURE"},
    {0xC0000401, "DIRLOG_CANT_RETRIEVE_DN"},
    {0xC0000402, "DIRLOG_CANT_RETRIEVE_RDN"},
    {0xC0000403, "DIRLOG_CANT_RETRIEVE_INSTANCE"},
    {0xC0000404, "DIRLOG_CANT_RETRIEVE_CHILD"},
    {0xC0000405, "DIRLOG_NAME_MISSING_ON_ALIAS"},
    {0xC0000406, "DIRLOG_BAD_ATT_SCHEMA_SYNTAX"},
    {0xC0000407, "DIRLOG_NCNAME_MISSING_CR_REF"},
    {0xC0000408, "DIRLOG_GOVERNSID_MISSING"},
    {0xC0000409, "DIRLOG_CANT_CACHE_CLASS"},
    {0xC000040A, "DIRLOG_CANT_REMOVE_CLASS_CACHE"},
    {0xC000040B, "DIRLOG_ATT_SCHEMA_REQ_ID"},
    {0xC000040C, "DIRLOG_ATT_SCHEMA_REQ_SYNTAX"},
    {0xC000040D, "DIRLOG_MISSING_EXPECTED_ATT"},
    {0xC000040E, "DIRLOG_CANT_FIND_DSA_OBJ"},
    {0xC000040F, "DIRLOG_DATABASE_ERROR"},
    {0xC0000410, "DIRLOG_CANT_FIND_NC_IN_CACHE"},
    {0xC0000411, "DIRLOG_CANT_FIND_EXPECTED_NC"},
    {0xC0000412, "DIRLOG_CANT_FIND_SUBREF_LIST"},
    {0xC0000413, "DIRLOG_CANT_FIND_DSA_NAME"},
    {0xC0000414, "DIRLOG_CANT_FIND_NODE_ADDRESS"},
    {0x40000415, "DIRLOG_DRA_REPLICAMODIFY_ENTRY"},
    {0xC0000416, "DIRLOG_JET_FAULTED"},
    {0xC0000417, "DIRLOG_MISSING_CROSS_REF"},
    {0xC0000418, "DIRLOG_MASTERDSA_MISSING_CR_REF"},
    {0xC0000419, "DIRLOG_MISSING_SUPREF"},
    {0xC000041A, "DIRLOG_UNUSED_1"},
    {0xC000041B, "DIRLOG_LOOP_DETECTED"},
    {0xC000041C, "DIRLOG_MASTERDSA_MISSING_SUBREF"},
    {0xC000041D, "DIRLOG_CANT_CACHE_ATT"},
    {0xC000041E, "DIRLOG_SECURITY_CHECKING_ERROR"},
    {0x4000041F, "DIRLOG_SECURITY_ACCESS_GRANTED_SD"},
    {0x40000420, "DIRLOG_SECURITY_ACCESS_GRANTED_DEFAULT"},
    {0x80000421, "DIRLOG_SECURITY_ACCESS_DENIED"},
    {0x00000422, "DIRLOG_SECURITY_ILLEGAL_MODIFY"},
    {0x40000423, "DIRLOG_DRA_SET_UUID"},
    {0x40000424, "DIRLOG_DRA_CALL_EXIT_OK"},
    {0x80000425, "DIRLOG_DRA_CALL_EXIT_BAD"},
    {0x40000426, "DIRLOG_CHK_LINK_DEL_NONC_BUSY"},
    {0x40000427, "DIRLOG_CHK_LINK_DEL_NOTGC_BUSY"},
    {0x40000428, "DIRLOG_CHK_LINK_DEL_DOMDEL_BUSY"},
    {0x80000429, "DIRLOG_CHK_LINK_DEL_NOCONN_BUSY"},
    {0x4000042A, "DIRLOG_DRA_REPLICAADD_ENTRY"},
    {0x4000042B, "DIRLOG_DRA_REPLICADEL_ENTRY"},
    {0x4000042C, "DIRLOG_DRA_UPDATEREFS_ENTRY"},
    {0x4000042D, "DIRLOG_CHK_LINK_DEL_NOSRC_BUSY"},
    {0x4000042E, "DIRLOG_DRA_REPLICASYNC_ENTRY"},
    {0xC000042F, "DIRLOG_UNUSED_7"},
    {0x40000430, "DIRLOG_DRA_GETNCCH_ENTRY"},
    {0x40000431, "DIRLOG_DRA_GETNCCH_EXIT"},
    {0x80000432, "DIRLOG_DRA_UPDREP_PICFAULT"},
    {0x80000433, "DIRLOG_DRA_REQUPD_PICFAULT"},
    {0x40000434, "DIRLOG_RPC_UNUSED_0"},
    {0xC0000435, "DIRLOG_DRA_PR_ALLOC_FAIL"},
    {0x40000436, "DIRLOG_PERF_OPEN"},
    {0x80000437, "DIRLOG_DRA_OUT_OF_MEMORY"},
    {0x80000438, "DIRLOG_DRA_NOTIFY_FAILED"},
    {0x80000439, "DIRLOG_DRA_IDUPDATE_FAILED"},
    {0x8000043A, "DIRLOG_DRA_IDREQUEST_FAILED"},
    {0x8000043B, "DIRLOG_DRA_UPDATE_FAILURE"},
    {0xC000043C, "DIRLOG_DRA_UPDATE_FAILURE_NOT_BUSY"},
    {0x8000043D, "DIRLOG_DRA_SYNC_FAILURE"},
    {0xC000043E, "DIRLOG_UNUSED_10"},
    {0x4000043F, "DIRLOG_CANT_FIND_REG_PARM"},
    {0x80000440, "DIRLOG_DRA_CONFIG_MISMATCH"},
    {0x40000441, "DIRLOG_DSP_CONFIG_INVALID"},
    {0xC0000442, "DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC"},
    {0x80000443, "DIRLOG_CHK_CANT_REPLICATE_FROM_SELF"},
    {0x80000444, "DIRLOG_DRA_RECORD_TOO_BIG_PRUNE_FAILURE"},
    {0x80000445, "DIRLOG_DRA_RECORD_TOO_BIG_OVERRIDE"},
    {0x80000446, "DIRLOG_DISABLE_DISK_WRITE_CACHE"},
    {0x80000447, "DIRLOG_DRA_MAIL_REQUPD_BADMSG"},
    {0x80000448, "DIRLOG_DRA_MAIL_UPDREP_BADMSG"},
    {0x80000449, "DIRLOG_DRA_MAIL_REQUPD_BADNC"},
    {0x8000044A, "DIRLOG_DRA_MAIL_UPDREP_BADNC"},
    {0x8000044B, "DIRLOG_DRA_MAIL_REQUPD_BADSRC"},
    {0x8000044C, "DIRLOG_DRA_MAIL_UPDREP_BADSRC"},
    {0x4000044D, "DIRLOG_DRA_RECORD_TOO_BIG_SUCCESS"},
    {0x4000044E, "DIRLOG_DRA_MAIL_REQ_UPD_SENT"},
    {0x4000044F, "DIRLOG_DRA_MAIL_UPD_REP_SENT"},
    {0x40000450, "DIRLOG_CHK_REPSTO_DEL_SUCCESS"},
    {0x80000451, "DIRLOG_CHK_REPSTO_DEL_FAILURE"},
    {0x80000452, "DIRLOG_DRA_DISPATCHER_TIMEOUT"},
    {0xC0000453, "DIRLOG_DRA_DISPATCHER_DEAD"},
    {0x40000454, "DIRLOG_KCC_CANDIDATE_CONNECTIONS"},
    {0x40000455, "DIRLOG_DRA_INVOCATION_ID_CHANGED"},
    {0x40000456, "DIRLOG_GC_PROMOTION_DELAYED"},
    {0x40000457, "DIRLOG_DRA_UPDATENC_PROGRESS"},
    {0x80000458, "DIRLOG_DRA_DISP_DEAD_DETAILS"},
    {0x80000459, "DIRLOG_DRA_DISABLED_INBOUND_REPL"},
    {0x4000045A, "DIRLOG_DRA_REENABLED_INBOUND_REPL"},
    {0x8000045B, "DIRLOG_DRA_DISABLED_OUTBOUND_REPL"},
    {0x4000045C, "DIRLOG_DRA_REENABLED_OUTBOUND_REPL"},
    {0x8000045D, "DIRLOG_CHK_ALL_CONNECTIONS_FOR_NC_DISABLED"},
    {0xC000045E, "DIRLOG_CHK_NO_LOCAL_SOURCE_FOR_NC"},
    {0x4000045F, "DIRLOG_GC_PROMOTED"},
    {0x40000460, "DIRLOG_GC_DEMOTED"},
    {0xC0000461, "DIRLOG_CHK_BAD_SCHEDULE"},
    {0x40000462, "DIRLOG_DRA_DELETED_PARENT"},
    {0x40000463, "DIRLOG_CHK_REMOVED_CONN_FROM_DEAD_SERVER"},
    {0x40000464, "DIRLOG_DRA_GET_RPC_HANDLE_FAILURE"},
    {0xC0000465, "DIRLOG_RPC_CONNECTION_FAILED"},
    {0xC0000466, "DIRLOG_GCVERIFY_ERROR"},
    {0xC0000467, "DIRLOG_DRA_NC_HEAD_NAME_CONFLICT"},
    {0x40000468, "DIRLOG_KCC_CONNECTION_OBJECT_CREATED"},
    {0x40000469, "DIRLOG_KCC_CONNECTION_OBJECT_DELETED"},
    {0xC000046A, "DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE"},
    {0x4000046B, "DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT"},
    {0x4000046C, "DIRLOG_GC_REMOVED_OBJECT"},
    {0x4000046D, "DIRLOG_KCC_SITE_GENERATOR"},
    {0x8000046E, "DIRLOG_CHK_DUPLICATE_CONNECTION"},
    {0xC000046F, "DIRLOG_SCHEMA_SEARCH_FAILED"},
    {0x40000470, "DIRLOG_SCHEMA_CREATE_INDEX_FAILED"},
    {0x40000471, "DIRLOG_SCHEMA_INDEX_CREATED"},
    {0x40000472, "DIRLOG_API_TRACE"},
    {0x40000473, "DIRLOG_API_TRACE_COMPLETE"},
    {0xC0000474, "DIRLOG_SCHEMA_ALLOC_FAILED"},
    {0xC0000475, "DIRLOG_SCHEMA_BOGUS_SEARCH"},
    {0xC0000476, "DIRLOG_SCHEMA_INVALID_AUX"},
    {0xC0000477, "DIRLOG_SCHEMA_NOT_AUX"},
    {0xC0000478, "DIRLOG_SCHEMA_AUXILIARY_INHERIT_STRUCTURAL"},
    {0xC0000479, "DIRLOG_SCHEMA_ABSTRACT_INHERIT_NON_ABSTRACT"},
    {0xC000047A, "DIRLOG_SCHEMA_STRUCTURAL_WITH_MULT_INHERIT"},
    {0xC000047B, "DIRLOG_SCHEMA_MISSING_ATT_ID"},
    {0x8000047C, "DIRLOG_SCHEMA_SURPLUS_INFO"},
    {0x4000047D, "DIRLOG_SCHEMA_CREATING_COLUMN"},
    {0xC000047E, "DIRLOG_SCHEMA_COLUMN_ADD_FAILED"},
    {0x4000047F, "DIRLOG_SCHEMA_COLUMN_ADDED"},
    {0xC0000480, "DIRLOG_SCHEMA_CIRCULAR_INHERIT"},
    {0x80000481, "DIRLOG_SCHEMA_INVALID_SUPER"},
    {0x40000482, "DIRLOG_SCHEMA_INVALID_RDN"},
    {0x40000483, "DIRLOG_SCHEMA_INVALID_MUST"},
    {0x40000484, "DIRLOG_SCHEMA_INVALID_MAY"},
    {0x40000485, "DIRLOG_SCHEMA_CREATING_INDEX"},
    {0xC0000486, "DIRLOG_DELAYED_FREE_FAILED"},
    {0xC0000487, "DIRLOG_BAD_CHAR_FOR_LOG_OVERRIDES"},
    {0xC0000488, "DIRLOG_BAD_CHAR_COUNT_FOR_LOG_OVERRIDES"},
    {0xC0000489, "DIRLOG_BUILD_HIERARCHY_TABLE_FAILED"},
    {0x4000048A, "DIRLOG_BUILD_HIERARCHY_TABLE_SUCCEEDED"},
    {0x4000048B, "DIRLOG_HIERARCHY_TABLE_MALLOC_FAILED"},
    {0x8000048C, "DIRLOG_TOO_MANY_OVERRIDES"},
    {0xC000048D, "DIRLOG_GET_GUID_FAILED"},
    {0x4000048E, "DIRLOG_QUERY_INDEX_CONSIDERED"},
    {0x4000048F, "DIRLOG_QUERY_INDEX_CHOSEN"},
    {0xC0000490, "DIRLOG_INTERNAL_FAILURE"},
    {0xC0000491, "DIRLOG_MALLOC_FAILURE"},
    {0xC0000492, "DIRLOG_ASSERTION_FAILURE"},
    {0x80000493, "DIRLOG_EXIT_WITH_ACTIVE_THREADS"},
    {0x40000494, "DIRLOG_RPC_CONNECTION"},
    {0x80000495, "DIRLOG_EXCEPTION"},
    {0x40000496, "DIRLOG_PRIVILEGED_OPERATION_PERFORMED"},
    {0x40000497, "DIRLOG_PRIVILEGED_OPERATION_FAILED"},
    {0x40000498, "DIRLOG_UNAUTHENTICATED_LOGON"},
    {0x40000499, "DIRLOG_SECURITY_ATTS_MODIFIED"},
    {0x8000049A, "DIRLOG_BAD_LANGUAGE"},
    {0x8000049B, "DIRLOG_BAD_CODEPAGE"},
    {0x4000049C, "DIRLOG_SCHEMA_DELETE_COLUMN_FAIL"},
    {0x4000049D, "DIRLOG_SCHEMA_DELETED_COLUMN_IN_USE"},
    {0x4000049E, "DIRLOG_SCHEMA_DELETED_COLUMN"},
    {0xC000049F, "DIRLOG_UNUSED_12"},
    {0x400004A0, "DIRLOG_SCHEMA_DELETE_INDEX_FAIL"},
    {0x400004A1, "DIRLOG_SCHEMA_DELETED_INDEX"},
    {0x800004A2, "DIRLOG_DRA_INCOMPAT_MAIL_MSG_P"},
    {0x800004A3, "DIRLOG_DRA_INCOMPAT_MAIL_MSG_C"},
    {0xC00004A4, "DIRLOG_DRA_DISPATCHER_VILLIAN"},
    {0xC00004A5, "DIRLOG_ABNORMAL_EXIT"},
    {0x400004A6, "DIRLOG_DRA_RPC_EXCEPTION"},
    {0x400004A7, "DIRLOG_DRA_CALL_EXIT_WARN"},
    {0x400004A8, "DIRLOG_DRA_ADUPD_INC_SRC"},
    {0x400004A9, "DIRLOG_DRA_ADUPD_DEC_SRC"},
    {0x400004AA, "DIRLOG_DRA_ADUPD_NC_SYNCED"},
    {0x400004AB, "DIRLOG_DRA_ADUPD_ALL_SYNCED"},
    {0xC00004AC, "DIRLOG_CANT_APPLY_SERVER_SECURITY"},
    {0x400004AD, "DIRLOG_KCC_NC_SITE_TOPOLOGY"},
    {0x400004AE, "DIRLOG_RECOVER_RESTORED_FAILED"},
    {0x400004AF, "DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL"},
    {0x400004B0, "DIRLOG_SCHEMA_DELETED_LOCALIZED_INDEX"},
    {0x400004B1, "DIRLOG_MAIL_COMPRESSED"},
    {0xC00004B2, "DIRLOG_DRA_BAD_NC"},
    {0x400004B3, "DIRLOG_DRA_SCHEMA_MISMATCH"},
    {0xC00004B4, "DIRLOG_ATQ_WRITE_COMPLETION_LIGHT"},
    {0xC00004B5, "DIRLOG_SDPROP_OBJ_CLASS_PROBLEM"},
    {0xC00004B6, "DIRLOG_ATQ_UDP_WRITE_COMPLETION_ERROR"},
    {0xC00004B7, "DIRLOG_SCHEMA_CACHE_UPDATE_RETRY"},
    {0xC00004B8, "DIRLOG_SCHEMA_CACHE_UPDATE_FAILED"},
    {0xC00004B9, "DIRLOG_AUDIT_PRIVILEGE_FAILED"},
    {0xC00004BA, "DIRLOG_ATQ_MAX_CONNECTIONS_EXCEEDED"},
    {0x400004BB, "DIRLOG_ATQ_CLOSE_SOCKET_SHUTDOWN"},
    {0x400004BC, "DIRLOG_ATQ_MULTI_PACKET_UDP"},
    {0x400004BD, "DIRLOG_ATQ_CLOSE_SOCKET_CONTACT_LOST"},
    {0x800004BE, "DIRLOG_SDPROP_NO_SD"},
    {0x400004BF, "DIRLOG_ATQ_CLOSE_SOCKET_OK"},
    {0x800004C0, "DIRLOG_ATQ_CLOSE_SOCKET_ERROR"},
    {0x800004C1, "DIRLOG_LDAP_NTLM_WARNING"},
    {0x800004C2, "DIRLOG_LDAP_NEGOTIATE_WARNING"},
    {0x800004C3, "DIRLOG_LDAP_SIMPLE_WARNING"},
    {0x400004C4, "DIRLOG_LDAP_SSL_NO_CERT"},
    {0x400004C5, "DIRLOG_LDAP_SSL_GOT_CERT"},
    {0xC00004C6, "DIRLOG_DRA_CERT_ACCESS_DENIED_WINERR"},
    {0xC00004C7, "DIRLOG_DRA_CERT_ACCESS_DENIED_TRUSTERR"},
    {0x800004C8, "DIRLOG_SERVER_INFO_UPDATE_FAILED"},
    {0x400004C9, "DIRLOG_DRA_NAME_CONFLICT_ON_RENAME"},
    {0x400004CA, "DIRLOG_DRA_NAME_CONFLICT_ON_ADD"},
    {0x400004CB, "DIRLOG_PERF_CLOSE"},
    {0xC00004CC, "DIRLOG_PERF_FAIL_QUERY_REG"},
    {0xC00004CD, "DIRLOG_PERF_FAIL_OPEN_MEMORY"},
    {0xC00004CE, "DIRLOG_PERF_FAIL_MAP_MEMORY"},
    {0xC00004CF, "DIRLOG_PERF_FAIL_OPEN_REG"},
    {0x800004D0, "DIRLOG_DRA_DISPATCHER_CANCELED"},
    {0x400004D1, "DIRLOG_REPLICATION_REPLACE_EQUAL"},
    {0xC00004D2, "DIRLOG_FAILED_LOOKUP_ACCOUNT_SID"},
    {0xC00004D3, "DIRLOG_OABGEN_FAIL_CREATE_MESSAGE"},
    {0xC00004D4, "DIRLOG_WRONG_SERVER_NAME"},
    {0xC00004D5, "DIRLOG_SAM_LOOPBACK_ERROR"},
    {0xC00004D6, "DIRLOG_LDAP_SSP_ERROR"},
    {0x400004D7, "DIRLOG_DRA_PROPERTY_FILTERED"},
    {0x400004D8, "DIRLOG_DRA_PROPERTY_NOT_FILTERED"},
    {0xC00004D9, "DIRLOG_NO_MORE_OIDS"},
    {0xC00004DA, "DIRLOG_BACKUP_REGISTRY"},
    {0xC00004DB, "DIRLOG_BACKUP_NOT_DONE"},
    {0xC00004DC, "DIRLOG_BACKUP_JET_BACKUP_FAILED"},
    {0xC00004DD, "DIRLOG_BACKUP_UNABLE_TO_RECOVER"},
    {0xC00004DE, "DIRLOG_BACKUP_THREAD_INIT_FAILED"},
    {0x400004DF, "DIRLOG_SEC_PRINCIPAL_NOT_TRANSFERRED"},
    {0xC00004E0, "DIRLOG_RESTORE_UNABLE_TO_RESET_TRIGGER"},
    {0xC00004E1, "DIRLOG_RESTORE_CANT_READ_DB_PATHS"},
    {0xC00004E2, "DIRLOG_RESTORE_UNABLE_TO_CREATE_SD"},
    {0xC00004E3, "DIRLOG_RESTORE_FAILED_NOT_RECOVERED_ORIGINAL"},
    {0xC00004E4, "DIRLOG_RESTORE_FAILED_RECOVERED_ORIGINAL"},
    {0xC00004E5, "DIRLOG_RESTORE_CREATE_DBDIR_FAILED"},
    {0xC00004E6, "DIRLOG_RESTORE_RENAME_DBDIR_FAILED"},
    {0x400004E7, "DIRLOG_RESTORE_SUCCESSFUL"},
    {0xC00004E8, "DIRLOG_CANT_FIND_PARTITIONS_OBJ"},
    {0x400004E9, "DIRLOG_SDPROP_DOING_PROPAGATION"},
    {0x400004EA, "DIRLOG_SDPROP_REPORT_ON_PROPAGATION"},
    {0x400004EB, "DIRLOG_SDPROP_STARTING"},
    {0x400004EC, "DIRLOG_SDPROP_SLEEP"},
    {0x400004ED, "DIRLOG_SDPROP_AWAKE"},
    {0xC00004EE, "DIRLOG_SDPROP_END_ABNORMAL"},
    {0x400004EF, "DIRLOG_SDPROP_END_NORMAL"},
    {0x400004F0, "DIRLOG_CHK_LINK_ADD_SUCCESS"},
    {0x800004F1, "DIRLOG_CHK_LINK_ADD_FAILURE"},
    {0x400004F2, "DIRLOG_CHK_LINK_DEL_NOSRC_SUCCESS"},
    {0x400004F3, "DIRLOG_CHK_LINK_DEL_NOSRC_FAILURE"},
    {0x400004F4, "DIRLOG_CHK_LINK_DEL_NOTGC_SUCCESS"},
    {0x400004F5, "DIRLOG_CHK_LINK_DEL_NOTGC_FAILURE"},
    {0x400004F6, "DIRLOG_CHK_LINK_DEL_DOMDEL_SUCCESS"},
    {0x400004F7, "DIRLOG_CHK_LINK_DEL_DOMDEL_FAILURE"},
    {0x400004F8, "DIRLOG_CHK_LINK_DEL_NOCONN_SUCCESS"},
    {0x400004F9, "DIRLOG_CHK_LINK_DEL_NOCONN_FAILURE"},
    {0x400004FA, "DIRMSG_INSTALL_FAILED_REPLICATION"},
    {0x400004FB, "DIRMSG_INSTALL_FAILED_NC_CREATE"},
    {0x400004FC, "DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT"},
    {0x400004FD, "DIRMSG_INSTALL_FAILED_TO_CREATE_NTDSA_OBJECT"},
    {0x400004FE, "DIRMSG_INSTALL_FAILED_TO_CREATE_DOMAIN_OBJECT"},
    {0x400004FF, "DIRMSG_INSTALL_FAILED_TO_INIT_JET"},
    {0x40000500, "DIRMSG_INSTALL_FAILED_GENERAL"},
    {0x40000501, "DIRMSG_INSTALL_FAILED_LDAP_CONNECT"},
    {0x40000502, "DIRMSG_INSTALL_FAILED_BIND"},
    {0x40000503, "DIRMSG_INSTALL_FAILED_SITE"},
    {0x40000504, "DIRMSG_INSTALL_FAILED_SITE_EXIST"},
    {0x40000505, "DIRLOG_INSTALL_SERVER_EXISTS"},
    {0x40000506, "DIRLOG_INSTALL_FAILED_TO_DELETE_SERVER"},
    {0x40000507, "DIRLOG_INSTALL_DOMAIN_EXISTS"},
    {0x40000508, "DIRLOG_INSTALL_FAILED_TO_DELETE_DOMAIN"},
    {0x40000509, "DIRLOG_INSTALL_FAILED_JOIN_THE_ENTERPRISE"},
    {0x4000050A, "DIRLOG_INSTALL_FAILED_REGISTRY"},
    {0x4000050B, "DIRLOG_INSTALL_FAILED_PERF_COUNTERS"},
    {0x4000050C, "DIRLOG_INSTALL_FAILED_LOAD_SAM_DB"},
    {0x4000050D, "DIRLOG_INSTALL_FAILED_CREATE_NEW_ACCOUNT_INFO"},
    {0x4000050E, "DIRLOG_INSTALL_FAILED_CA_ENROLLMENT"},
    {0x4000050F, "DIRLOG_INSTALL_FAILED_CREATE_BOOT_OPTION"},
    {0x40000510, "DIRLOG_INSTALL_FAILED_ENVIRONMENT"},
    {0x40000511, "DIRLOG_INSTALL_FAILED_GENERAL"},
    {0x40000512, "DIRMSG_INSTALL_FAILED_LDAP_READ_CONFIG"},
    {0x40000513, "DIRMSG_INSTALL_FAILED_SCHEMA_CHECK"},
    {0x40000514, "DIRMSG_INSTALL_CANNOT_DERIVE_DN"},
    {0x40000515, "DIRMSG_INSTALL_SAM_FAILED"},
    {0x40000516, "DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED"},
    {0x40000517, "DIRLOG_DEMOTE_DS_DOMAIN_STATUS"},
    {0x40000518, "DIRLOG_DEMOTE_IS_OPERATION_VALID"},
    {0x40000519, "DIRLOG_DEMOTE_IS_PARTIAL_SHUTDOWN"},
    {0x4000051A, "DIRLOG_KCC_CONNECTION_OBJECT_DELETION_FAILED"},
    {0x4000051B, "DIRLOG_KCC_CONNECTION_NOT_INSTANTIATED"},
    {0x4000051C, "DIRLOG_KCC_REPLICA_LINK_DOWN"},
    {0xC000051D, "DIRLOG_WINSOCK_INIT_FAILED"},
    {0x4000051E, "DIRLOG_RPC_PROTSEQ_FAILED"},
    {0xC000051F, "DIRLOG_KCC_NO_SPANNING_TREE"},
    {0xC0000520, "DIRLOG_ISM_TRANSPORT_FAILURE"},
    {0x80000521, "DIRLOG_CHK_CONFIG_PARAM_TOO_LOW"},
    {0x80000522, "DIRLOG_CHK_CONFIG_PARAM_TOO_HIGH"},
    {0xC0000523, "DIRLOG_SCHEMA_CLOSURE_FAILURE"},
    {0x40000524, "DIRLOG_KCC_KEEPING_INTERSITE_CONN"},
    {0x40000525, "DIRLOG_LDAP_CONNECTION_TIMEOUT"},
    {0x40000526, "DIRMSG_DEMOTE_INIT"},
    {0x40000527, "DIRMSG_DEMOTE_ENTERPRISE_VALIDATE"},
    {0x40000528, "DIRMSG_AUTHENTICATING"},
    {0x40000529, "DIRMSG_DEMOTE_NEW_ACCOUNT_INFO"},
    {0x4000052A, "DIRMSG_DEMOTE_SAM"},
    {0x4000052B, "DIRMSG_DEMOTE_LSA"},
    {0x4000052C, "DIRMSG_DEMOTE_REMOVING_EXTERNAL_REFS"},
    {0x4000052D, "DIRMSG_DEMOTE_REMOVING_FSMOS"},
    {0x4000052E, "DIRMSG_DEMOTE_SHUTTING_DOWN_INTERFACES"},
    {0x4000052F, "DIRMSG_DEMOTE_COMPLETING"},
    {0x40000530, "DIRMSG_INSTALL_INITIALIZATION"},
    {0x40000531, "DIRMSG_INSTALL_VALIDATING_PARAMS"},
    {0x40000532, "DIRMSG_INSTALL_FINDING_SITE"},
    {0x40000533, "DIRMSG_INSTALL_CONTEXT"},
    {0x40000534, "DIRMSG_INSTALL_SITE_EXIST"},
    {0x40000535, "DIRMSG_INSTALL_SERVER_EXIST"},
    {0x40000536, "DIRMSG_INSTALL_DOMAIN_EXIST"},
    {0x40000537, "DIRMSG_INSTALL_CONFIGURE_LOCAL"},
    {0x40000538, "DIRMSG_INSTALL_SETTING_PERF"},
    {0x40000539, "DIRMSG_INSTALL_SECURITY"},
    {0x4000053A, "DIRMSG_INSTALL_REPLICATING_SCHEMA"},
    {0x4000053B, "DIRMSG_INSTALL_CREATE_PROGRESS"},
    {0x4000053C, "DIRMSG_INSTALL_REPLICATING_CONFIG"},
    {0x4000053D, "DIRMSG_INSTALL_CREATING_CONFIG"},
    {0x4000053E, "DIRMSG_INSTALL_REPLICATING_DOMAIN"},
    {0x4000053F, "DIRMSG_INSTALL_CREATING_DOMAIN"},
    {0x40000540, "DIRMSG_INSTALL_CREATING_LOCAL_DS"},
    {0x40000541, "DIRMSG_INSTALL_UPGRADING_SAM"},
    {0x40000542, "DIRMSG_INSTALL_CREATING_SAM"},
    {0x40000543, "DIRMSG_INSTALL_COMPLETING"},
    {0x40000544, "DIRLOG_BEGIN_DIR_SEARCH"},
    {0x40000545, "DIRLOG_END_DIR_SEARCH"},
    {0x40000546, "DIRLOG_BEGIN_DIR_ADDENTRY"},
    {0x40000547, "DIRLOG_END_DIR_ADDENTRY"},
    {0x40000548, "DIRLOG_BEGIN_DIR_REMOVE"},
    {0x40000549, "DIRLOG_END_DIR_REMOVE"},
    {0x4000054A, "DIRLOG_BEGIN_DIR_MODIFY"},
    {0x4000054B, "DIRLOG_END_DIR_MODIFY"},
    {0x4000054C, "DIRLOG_BEGIN_DIR_MODIFYDN"},
    {0x4000054D, "DIRLOG_END_DIR_MODIFYDN"},
    {0x4000054E, "DIRLOG_BEGIN_DIR_COMPARE"},
    {0x4000054F, "DIRLOG_END_DIR_COMPARE"},
    {0x40000550, "DIRLOG_DRA_REPLICASYNC_EXIT"},
    {0x40000551, "DIRMSG_INSTALL_CREATING_REMOTE"},
    {0x40000552, "DIRMSG_INSTALL_REPLICATE_FULL"},
    {0x40000553, "DIRLOG_DRA_IMPROVING_UPTODATE_VECTOR"},
    {0x40000554, "DIRLOG_DRA_IMPROVING_USN_VECTOR"},
    {0x40000555, "DIRLOG_DRA_APPLYING_OBJ_CREATION"},
    {0x40000556, "DIRLOG_DRA_APPLYING_OBJ_UPDATE"},
    {0x40000557, "DIRMSG_INSTALL_REPLICATE_PROGRESS"},
    {0x80000558, "DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED"},
    {0x80000559, "DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED"},
    {0x4000055A, "DIRLOG_ISM_SEND_SUCCESS"},
    {0x8000055B, "DIRLOG_ISM_SEND_FAILURE"},
    {0x4000055C, "DIRLOG_ISM_RECEIVE_SUCCESS"},
    {0xC000055D, "DIRLOG_ISM_RECEIVE_FAILURE"},
    {0xC000055E, "DIRLOG_ISM_GET_CONNECTIVITY_FAILURE"},
    {0xC000055F, "DIRLOG_ISM_GET_TRANSPORT_SERVERS_FAILURE"},
    {0xC0000560, "DIRLOG_ISM_GET_CONECTION_SCHEDULE_FAILURE"},
    {0xC0000561, "DIRLOG_ISM_TRANSPORT_LOAD_FAILURE"},
    {0xC0000562, "DIRLOG_ISM_TRANSPORT_REFRESH_FAILURE"},
    {0x40000563, "DIRLOG_ISM_MESSAGE_PENDING"},
    {0x80000564, "DIRLOG_ISM_TRANSPORT_MONITOR_FAILURE"},
    {0xC0000565, "DIRLOG_ISM_SITELINK_INVALID_SCHEDULE_FORMAT"},
    {0xC0000566, "DIRLOG_ISM_SITELINK_SCHEDULE_NEVER"},
    {0xC0000567, "DIRLOG_DRA_NO_CERTIFICATE"},
    {0x40000568, "DIRLOG_DRA_CERTIFICATE_ACQUIRED"},
    {0xC0000569, "DIRLOG_ISM_IP_RPC_REG_FAILED"},
    {0x4000056A, "DIRLOG_UNUSED_2"},
    {0xC000056B, "DIRLOG_ISM_IP_MESSAGE_DROPPED"},
    {0xC000056C, "DIRLOG_DRA_MISSING_OBJECT"},
    {0xC000056D, "DIRLOG_DEMOTE_SAM_FAILED"},
    {0xC000056E, "DIRLOG_DEMOTE_LSA_FAILED"},
    {0xC000056F, "DIRLOG_DEMOTE_SET_MACHINE_ACC_FAILED"},
    {0x40000570, "DIRLOG_DEMOTE_FAILED_TO_UPDATE_EXTN"},
    {0xC0000571, "DIRLOG_STOPPED_NETLOGON"},
    {0x40000572, "DIRLOG_RESTARTED_NETLOGON"},
    {0x40000573, "DIRMSG_DEMOTE_FAILED_TO_ABANDON_DOMAIN_FSMOS"},
    {0xC0000574, "DIRMSG_DEMOTE_FAILED_TO_ABANDON_ENTERPRISE_FSMOS"},
    {0x40000575, "DIRMSG_DEMOTE_ABANDONING_DOMAIN_FSMOS"},
    {0x40000576, "DIRMSG_DEMOTE_ABANDONING_ENTERPRISE_FSMOS"},
    {0xC0000577, "DIRMSG_INSTALL_FAILED_TO_MOVE_BOOT_SCHEMA"},
    {0xC0000578, "DIRMSG_FAILED_SET_PRODUCT_TYPE"},
    {0x40000579, "DIRLOG_KCC_CONNECTION_EDGE_NEEDED"},
    {0x4000057A, "DIRMSG_DBDUMP_SUCCESS"},
    {0xC000057B, "DIRMSG_DBDUMP_FAILURE"},
    {0x4000057C, "DIRLOG_CHK_CLAIMED_SITE_GENERATOR_ROLE"},
    {0xC000057D, "DIRLOG_ISM_SMTP_MSG_UNREADABLE"},
    {0x8000057E, "DIRLOG_ISM_SMTP_NOTIFY_FAILED"},
    {0xC000057F, "DIRLOG_ISM_LDAP_MODIFY_FAILED"},
    {0x40000580, "DIRLOG_ISM_SMTP_MAIL_ADDRESS"},
    {0x80000581, "DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS"},
    {0x40000582, "DIRMSG_WRONG_PRODUCT_TYPE"},
    {0xC0000583, "DIRLOG_BUILD_SPN_FAILURE"},
    {0x40000584, "DIRLOG_DRA_PROPERTY_APPLIED"},
    {0x40000585, "DIRLOG_DRA_PROPERTY_NOT_APPLIED"},
    {0xC0000586, "DIRLOG_STALE_PHANTOM_CLEANUP_ADD_FAILED"},
    {0xC0000587, "DIRLOG_STALE_PHANTOM_CLEANUP_LOCATE_PHANTOMS_FAILED"},
    {0xC0000588, "DIRLOG_STALE_PHANTOM_CLEANUP_GC_COMM_FAILED"},
    {0xC0000589, "DIRLOG_STALE_PHANTOM_CLEANUP_CANT_USE_INDEX"},
    {0xC000058A, "DIRLOG_STALE_PHANTOM_CLEANUP_CANT_MAKE_INDEX"},
    {0xC000058B, "DIRLOG_STALE_PHANTOM_CLEANUP_MACHINE_IS_GC"},
    {0xC000058C, "DIRLOG_STALE_PHANTOM_CLEANUP_TOO_BUSY"},
    {0x4000058D, "DIRLOG_STALE_PHANTOM_CLEANUP_SUCCESS_AS_MASTER"},
    {0x4000058E, "DIRLOG_STALE_PHANTOM_CLEANUP_SUCCESS_NOT_AS_MASTER"},
    {0x4000058F, "DIRMSG_DOMAIN_SID_EXISTS"},
    {0x40000590, "DIRMSG_SYNCING_RID_FSMO"},
    {0x80000591, "DIRLOG_FAILED_TO_SYNC_RID_FSMO"},
    {0x80000592, "DIRLOG_FAILED_TO_CREATE_BOOT_OPTION"},
    {0xC0000593, "DIRLOG_REMOTE_ADD_FAILED"},
    {0xC0000594, "DIRLOG_REMOTE_ADD_SUCCEEDED"},
    {0xC0000595, "DIRLOG_DUPLICATE_MOVED_OBJECT"},
    {0xC0000596, "DIRLOG_CROSS_DOMAIN_MOVE_SUCCEEDED"},
    {0xC0000597, "DIRLOG_CROSS_DOMAIN_MOVE_FAILED"},
    {0xC0000598, "DIRLOG_CROSS_DOMAIN_MOVE_CLEANUP_REQUIRED"},
    {0x40000599, "DIRLOG_CANT_FIND_REG_PARM_DEFAULT"},
    {0x4000059A, "DIRLOG_DB_REG_PATH_CHANGED"},
    {0x8000059B, "DIRLOG_KCC_DIR_OP_FAILURE"},
    {0x8000059C, "DIRLOG_ISM_OBJECT_FAILURE"},
    {0x8000059D, "DIRMSG_INSTALL_MISSING_INFO"},
    {0x8000059E, "DIRMSG_INSTALL_SPECIAL_NAME"},
    {0x8000059F, "DIRLOG_KCC_TRANSPORT_ADDRESS_MISSING"},
    {0x400005A0, "DIRMSG_FAILED_TO_CREATE_REMOTE_NTDSA"},
    {0x400005A1, "DIRMSG_CREATING_REMOTE_NTDSA"},
    {0x400005A2, "DIRLOG_FAILED_TO_REMOVE_NTDSA"},
    {0x400005A3, "DIRLOG_FAILED_TO_REMOVE_EXTN_OBJECT"},
    {0x400005A4, "DIRLOG_FAILED_TO_CREATE_EXTN_OBJECT"},
    {0x400005A5, "DIRLOG_FAILED_TO_FIND_MACHINE_ACCOUNT"},
    {0xC00005A6, "DIRLOG_FAILED_TO_CREATE_RESTORE_MARKER_FILE"},
    {0xC00005A7, "DIRLOG_FAILED_TO_DELETE_RESTORE_MARKER_FILE"},
    {0xC00005A8, "DIRLOG_ISM_SMTP_DSN"},
    {0x400005A9, "DIRLOG_SDPROP_NO_CLASS_CACHE"},
    {0xC00005AA, "DIRLOG_SDPROP_MERGE_SD_FAIL"},
    {0xC00005AB, "DIRLOG_SDPROP_REMOVE_SD_PROBLEM"},
    {0xC00005AC, "DIRLOG_SDPROP_ADD_SD_PROBLEM"},
    {0x400005AD, "DIRLOG_SDPROP_TOO_BUSY_TO_PROPAGATE"},
    {0x400005AE, "DIRMSG_SEARCHING_FOR_SYNC_SERVER"},
    {0x400005AF, "DIRMSG_FAILED_TO_FIND_SYNC_SERVER"},
    {0x400005B0, "DIRMSG_REPLICATING_OFF_CHANGES"},
    {0x400005B1, "DIRMSG_FAILED_TO_REPLICATE_OFF_CHANGES"},
    {0x400005B2, "DIRLOG_FSMO_XFER"},
    {0x400005B3, "DIRLOG_BEGIN_DIR_FIND"},
    {0x400005B4, "DIRLOG_END_DIR_FIND"},
    {0x400005B5, "DIRLOG_BEGIN_LDAP_BIND"},
    {0x400005B6, "DIRLOG_END_LDAP_BIND"},
    {0x800005B7, "DIRLOG_CORRUPT_INDICES_DELETED"},
    {0x400005B8, "DIRLOG_SCHEMA_INDEX_NEEDED"},
    {0x800005B9, "DIRLOG_ISM_LINK_MONITOR_FAILURE"},
    {0xC00005BA, "DIRLOG_ISM_SMTP_DOMAIN_ADD_FAILURE"},
    {0xC00005BB, "DIRLOG_ISM_SMTP_SINK_REG_FAILURE"},
    {0xC00005BC, "DIRLOG_ISM_SMTP_SINK_BIND_FAILURE"},
    {0xC00005BD, "DIRLOG_ISM_SMTP_CLASS_MISSING"},
    {0x400005BE, "DIRLOG_ISM_SMTP_DOMAIN_ADD"},
    {0x800005BF, "DIRLOG_ISM_SMTP_DROP_DIR_MISSING"},
    {0xC00005C0, "DIRLOG_DUPLICATE_SPN_MAPPING_VALUE"},
    {0x800005C1, "DIRLOG_ISM_TRANSPORT_CONFIG_FAILURE"},
    {0x800005C2, "DIRLOG_KCC_TRANSPORT_BRIDGEHEAD_NOT_FOUND"},
    {0x800005C3, "DIRLOG_PERFMON_COUNTER_UNREG_FAILED"},
    {0x800005C4, "DIRLOG_PERFMON_COUNTER_REG_FAILED"},
    {0x400005C5, "DIRLOG_PERFMON_COUNTER_REG_SUCCESS"},
    {0x400005C6, "DIRLOG_DRA_COMPRESSED_OUTBOUND_RPC"},
    {0xC00005C7, "DIRLOG_DRA_UPDATE_FAILURE_TOO_LARGE"},
    {0xC00005C8, "DIRLOG_DRA_UPDATE_FAILURE_DISK_FULL"},
    {0x800005C9, "DIRLOG_DSA_OBJECT_FAILURE"},
    {0x400005CA, "DIRLOG_CHK_LINK_DEL_NONC_SUCCESS"},
    {0x400005CB, "DIRLOG_CHK_LINK_DEL_NONC_FAILURE"},
    {0x400005CC, "DIRMSG_CANNOT_CONTACT_DOMAIN_FSMO"},
    {0x400005CD, "DIRLOG_KCC_TASK_ENTRY"},
    {0x400005CE, "DIRLOG_KCC_TASK_EXIT"},
    {0x400005CF, "DIRLOG_IDL_DRS_REPLICA_SYNC_ENTRY"},
    {0x400005D0, "DIRLOG_IDL_DRS_REPLICA_SYNC_EXIT"},
    {0x400005D1, "DIRLOG_IDL_DRS_GETCHG_ENTRY"},
    {0x400005D2, "DIRLOG_IDL_DRS_GETCHG_EXIT"},
    {0x400005D3, "DIRLOG_IDL_DRS_UPDREFS_ENTRY"},
    {0x400005D4, "DIRLOG_IDL_DRS_UPDREFS_EXIT"},
    {0x400005D5, "DIRLOG_IDL_DRS_REPLICA_ADD_ENTRY"},
    {0x400005D6, "DIRLOG_IDL_DRS_REPLICA_ADD_EXIT"},
    {0x400005D7, "DIRLOG_IDL_DRS_REPLICA_MODIFY_ENTRY"},
    {0x400005D8, "DIRLOG_IDL_DRS_REPLICA_MODIFY_EXIT"},
    {0x400005D9, "DIRLOG_IDL_DRS_REPLICA_DEL_ENTRY"},
    {0x400005DA, "DIRLOG_IDL_DRS_REPLICA_DEL_EXIT"},
    {0x400005DB, "DIRLOG_IDL_DRS_VERIFY_NAMES_ENTRY"},
    {0x400005DC, "DIRLOG_IDL_DRS_VERIFY_NAMES_EXIT"},
    {0x400005DD, "DIRLOG_IDL_DRS_INTERDOMAIN_MOVE_ENTRY"},
    {0x400005DE, "DIRLOG_IDL_DRS_INTERDOMAIN_MOVE_EXIT"},
    {0x400005DF, "DIRLOG_IDL_DRS_ADD_ENTRY_ENTRY"},
    {0x400005E0, "DIRLOG_IDL_DRS_ADD_ENTRY_EXIT"},
    {0x400005E1, "DIRLOG_IDL_DRS_EXECUTE_KCC_ENTRY"},
    {0x400005E2, "DIRLOG_IDL_DRS_EXECUTE_KCC_EXIT"},
    {0x400005E3, "DIRLOG_IDL_DRS_GET_REPL_INFO_ENTRY"},
    {0x400005E4, "DIRLOG_IDL_DRS_GET_REPL_INFO_EXIT"},
    {0x400005E5, "DIRLOG_IDL_DRS_GET_NT4_CHGLOG_ENTRY"},
    {0x400005E6, "DIRLOG_IDL_DRS_GET_NT4_CHGLOG_EXIT"},
    {0x400005E7, "DIRLOG_IDL_DRS_CRACK_NAMES_ENTRY"},
    {0x400005E8, "DIRLOG_IDL_DRS_CRACK_NAMES_EXIT"},
    {0x400005E9, "DIRLOG_IDL_DRS_WRITE_SPN_ENTRY"},
    {0x400005EA, "DIRLOG_IDL_DRS_WRITE_SPN_EXIT"},
    {0x400005EB, "DIRLOG_IDL_DRS_DC_INFO_ENTRY"},
    {0x400005EC, "DIRLOG_IDL_DRS_DC_INFO_EXIT"},
    {0x400005ED, "DIRLOG_IDL_DRS_GET_MEMBERSHIPS_ENTRY"},
    {0x400005EE, "DIRLOG_IDL_DRS_GET_MEMBERSHIPS_EXIT"},
    {0x800005EF, "DIRLOG_OUT_OF_VERSION_STORE"},
    {0x800005F0, "DIRLOG_GC_FAILED_TO_REMOVE_OBJECT"},
    {0x800005F1, "DIRLOG_NO_LOCALIZED_INDEX_CREATED_FOR_LANGUAGE"},
    {0xC00005F2, "DIRLOG_NO_LOCALIZED_INDICES_CREATED"},
    {0xC00005F3, "DIRLOG_SCHEMA_SD_CONVERSION_FAILED"},
    {0x400005F4, "DIRLOG_BEGIN_LDAP_REQUEST"},
    {0x400005F5, "DIRLOG_END_LDAP_REQUEST"},
    {0x400005F6, "DIRLOG_CHK_UPDATED_SCHEDULE"},
    {0xC00005F7, "DIRLOG_ISM_SMTP_CDO_CLASS_MISSING"},
    {0xC00005F8, "DIRLOG_ISM_SMTP_CDO_ERROR"},
    {0x800005F9, "DIRLOG_DRA_MAIL_BADMSGTYPE"},
    {0x400005FA, "DIRLOG_DRA_MAIL_RECEIVED"},
    {0x800005FB, "DIRLOG_DRA_MAIL_ISM_RECEIVE_RETRY"},
    {0x800005FC, "DIRLOG_DRA_MAIL_ISM_SEND_FAILURE"},
    {0x400005FD, "DIRLOG_CHK_UPDATED_TRANSPORT_TYPE"},
    {0x800005FE, "DIRLOG_DOMAIN_FSMO_AND_NOT_GC"},
    {0x400005FF, "DIRLOG_LDAP_EXT_ERROR"},
    {0xC0000600, "DIRLOG_SCHEMA_VALIDATION_FAILED"},
    {0xC0000601, "DIRLOG_FAILED_TO_DELETE_NEW_DB_GUID_KEY"},
    {0x80000602, "DIRLOG_FAILED_TO_CREATE_INVOCATION_ID"},
    {0x80000603, "DIRLOG_FAILED_TO_DISABLE_DISK_WRITE_CACHE"},
    {0x40000604, "DIRLOG_FAILED_TO_ADD_SID_HISTORY"},
    {0x40000605, "DIRLOG_SID_HISTORY_MODIFIED"},
    {0x40000606, "DIRLOG_KCC_LIVE_CONNECTION"},
    {0x40000607, "DIRLOG_KCC_CONNECTION_REPLICATES_NC"},
    {0x40000608, "DIRLOG_KCC_BRIDGEHEAD_CHOSEN"},
    {0xC0000609, "DIRLOG_DRA_SCHEMA_INFO_MISMATCH"},
    {0xC000060A, "DIRLOG_SCHEMA_ATT_CONFLICT"},
    {0xC000060B, "DIRLOG_SCHEMA_CLASS_CONFLICT"},
    {0x4000060C, "DIRLOG_DRA_OBJ_NC_MISMATCH"},
    {0x4000060D, "DIRLOG_UNUSED_16"},
    {0xC000060E, "DIRLOG_CHK_SITE_HAS_NO_NTDS_SETTINGS"},
    {0x4000060F, "DIRLOG_DSA_UP_TO_DATE"},
    {0x40000610, "DIRLOG_DSA_NOT_ADVERTISE_DC"},
    {0x40000611, "DIRLOG_ADUPD_SYNC_PROGRESS"},
    {0x40000612, "DIRLOG_ADUPD_SYNC_NO_PROGRESS"},
    {0x40000613, "DIRLOG_ADUPD_INIT_SYNC_ONGOING"},
    {0x40000614, "DIRLOG_ADUPD_NC_GAVE_UP"},
    {0x40000615, "DIRLOG_ADUPD_NC_NEVER_SYNCED_WRITE"},
    {0x40000616, "DIRLOG_ADUPD_UNUSED_1"},
    {0x40000617, "DIRLOG_ADUPD_GC_NC_MISSING"},
    {0x40000618, "DIRLOG_DRA_NEW_REPLICA_FULL_SYNC"},
    {0x40000619, "DIRLOG_DRA_USER_REQ_FULL_SYNC"},
    {0x4000061A, "DIRLOG_DRA_FULL_SYNC_CONTINUED"},
    {0x4000061B, "DIRLOG_DRA_SOURCE_RESTORE_FULL_SYNC"},
    {0x4000061C, "DIRLOG_DRA_INIT_SYNCS_DISABLED"},
    {0x8000061D, "DIRLOG_GC_PROMOTION_CHECKS_DISABLED"},
    {0x8000061E, "DIRLOG_KCC_ALL_TRANSPORT_BRIDGEHEADS_STALE"},
    {0xC000061F, "DIRLOG_KCC_EXPLICIT_BRIDGEHEAD_LIST_INCOMPLETE"},
    {0xC0000620, "DIRLOG_KCC_NO_BRIDGEHEADS_ENABLED_FOR_TRANSPORT"},
    {0x40000621, "DIRMSG_NTDSETUP_CANCELLED"},
    {0x40000622, "DIRLOG_ISM_SMTP_DROP_DIRECTORY"},
    {0xC0000623, "DIRLOG_UNUSED_15"},
    {0x40000624, "DIRLOG_UNUSED_14"},
    {0x40000625, "DIRLOG_UNUSED_3"},
    {0x80000626, "DIRLOG_DRA_SDP_LOCK_CONTENTION"},
    {0x40000627, "DIRLOG_DRA_PARTIAL_ATTR_ADD_FULL_SYNC"},
    {0xC0000628, "DIRLOG_INHERIT_SECURITY_IDENTITY_FAILURE"},
    {0x40000629, "DIRLOG_INHERIT_SECURITY_IDENTITY_SUCCEEDED"},
    {0x4000062A, "DIRLOG_GC_OCCUPANCY_NOT_MET"},
    {0x8000062B, "DIRLOG_DRA_MAIL_SEND_CONTENTION"},
    {0x4000062C, "DIRLOG_DRA_REPLICATION_FINISHED"},
    {0x8000062D, "DIRLOG_DS_DNS_HOST_RESOLUTION_FAILED"},
    {0x4000062E, "DIRLOG_SCHEMA_CACHE_UPDATED"},
    {0x8000062F, "DIRLOG_DEMOTE_LAST_DC_MISMATCH"},
    {0x80000630, "DIRLOG_DEMOTE_NOT_LAST_DC_MISMATCH"},
    {0x40000631, "DIRLOG_NT4_REPLICATION_CHECKPOINT_SUCCESSFUL"},
    {0x80000632, "DIRLOG_NT4_REPLICATION_CHECKPOINT_UNSUCCESSFUL"},
    {0x40000633, "DIRLOG_DRA_ADJUSTED_DEST_BOOKMARKS_AFTER_RESTORE"},
    {0x80000634, "DIRLOG_DRA_VALUE_NOT_PROPER_FOR_DELETED"},
    {0x40000635, "DIRLOG_RPC_UNUSED_1"},
    {0x40000636, "DIRLOG_RPC_UNUSED_2"},
    {0x40000637, "DIRLOG_RPC_UNUSED_3"},
    {0x40000638, "DIRLOG_RPC_CALL_GETCHG"},
    {0x40000639, "DIRLOG_RPC_UNUSED_5"},
    {0x4000063A, "DIRLOG_RPC_UNUSED_6"},
    {0x4000063B, "DIRLOG_RPC_UNUSED_7"},
    {0x4000063C, "DIRLOG_RPC_UNUSED_8"},
    {0x4000063D, "DIRLOG_RPC_UNUSED_9"},
    {0x4000063E, "DIRLOG_RPC_UNUSED_10"},
    {0x4000063F, "DIRLOG_RPC_UNUSED_11"},
    {0x40000640, "DIRLOG_RPC_UNUSED_12"},
    {0x40000641, "DIRLOG_RPC_UNUSED_13"},
    {0x40000642, "DIRLOG_RPC_UNUSED_14"},
    {0xC0000643, "DIRLOG_FIXED_INDEX_CREATION_FAILED"},
    {0x40000644, "DIRLOG_NSPI_BEGIN_UPDATE_STAT"},
    {0x40000645, "DIRLOG_NSPI_END_UPDATE_STAT"},
    {0x40000646, "DIRLOG_NSPI_BEGIN_COMPARE_DNT"},
    {0x40000647, "DIRLOG_NSPI_END_COMPARE_DNT"},
    {0x40000648, "DIRLOG_NSPI_BEGIN_QUERY_ROWS"},
    {0x40000649, "DIRLOG_NSPI_END_QUERY_ROWS"},
    {0x4000064A, "DIRLOG_NSPI_BEGIN_SEEK_ENTRIES"},
    {0x4000064B, "DIRLOG_NSPI_END_SEEK_ENTRIES"},
    {0x4000064C, "DIRLOG_NSPI_BEGIN_GET_MATCHES"},
    {0x4000064D, "DIRLOG_NSPI_END_GET_MATCHES"},
    {0x4000064E, "DIRLOG_NSPI_BEGIN_RESOLVE_NAMES"},
    {0x4000064F, "DIRLOG_NSPI_END_RESOLVE_NAMES"},
    {0x40000650, "DIRLOG_NSPI_BEGIN_DNT2EPH"},
    {0x40000651, "DIRLOG_NSPI_END_DNT2EPH"},
    {0x40000652, "DIRLOG_NSPI_BEGIN_HIERARCHY_INFO"},
    {0x40000653, "DIRLOG_NSPI_END_HIERARCHY_INFO"},
    {0x40000654, "DIRLOG_NSPI_BEGIN_RESORT_RESTRICTION"},
    {0x40000655, "DIRLOG_NSPI_END_RESORT_RESTRICTION"},
    {0x40000656, "DIRLOG_NSPI_BEGIN_BIND"},
    {0x40000657, "DIRLOG_NSPI_END_BIND"},
    {0x40000658, "DIRLOG_NSPI_BEGIN_NAME_FROM_ID"},
    {0x40000659, "DIRLOG_NSPI_END_NAME_FROM_ID"},
    {0x4000065A, "DIRLOG_NSPI_BEGIN_ID_FROM_NAME"},
    {0x4000065B, "DIRLOG_NSPI_END_ID_FROM_NAME"},
    {0x4000065C, "DIRLOG_NSPI_BEGIN_GET_PROP_LIST"},
    {0x4000065D, "DIRLOG_NSPI_END_GET_PROP_LIST"},
    {0x4000065E, "DIRLOG_NSPI_BEGIN_QUERY_COLUMNS"},
    {0x4000065F, "DIRLOG_NSPI_END_QUERY_COLUMNS"},
    {0x40000660, "DIRLOG_NSPI_BEGIN_GET_PROPS"},
    {0x40000661, "DIRLOG_NSPI_END_GET_PROPS"},
    {0x40000662, "DIRLOG_NSPI_BEGIN_GET_TEMPLATE_INFO"},
    {0x40000663, "DIRLOG_NSPI_END_GET_TEMPLATE_INFO"},
    {0x40000664, "DIRLOG_NSPI_BEGIN_MOD_PROPS"},
    {0x40000665, "DIRLOG_NSPI_END_MOD_PROPS"},
    {0x40000666, "DIRLOG_NSPI_BEGIN_MOD_LINKATT"},
    {0x40000667, "DIRLOG_NSPI_END_MOD_LINKATT"},
    {0x40000668, "DIRLOG_NSPI_BEGIN_DELETE_ENTRIES"},
    {0x40000669, "DIRLOG_NSPI_END_DELETE_ENTRIES"},
    {0xC000066A, "DIRLOG_DRA_CERT_ACCESS_DENIED_NOT_DC"},
    {0x4000066B, "DIRLOG_SEARCH_OPERATIONS"},
    {0x4000066C, "DIRLOG_SEARCH_FILTER_LOGGING"},
    {0xC000066D, "DIRLOG_DRA_SPN_WRONG_TARGET_NAME"},
    {0x4000066E, "DIRLOG_DB_FREE_SPACE"},
    {0x8000066F, "DIRLOG_DRA_SCHEMA_INFO_WRITE_FAILED"},
    {0x80000670, "DIRLOG_SDPROP_BAD_DELETED_SD"},
    {0x40000671, "DIRLOG_PAO_ADD_REPLICA"},
    {0x40000672, "DIRLOG_PAO_DELETE_REPLICA"},
    {0x40000673, "DIRLOG_PAO_SYNCHRONIZE_REPLICA"},
    {0x40000674, "DIRLOG_PAO_UPDATE_REFERENCES"},
    {0x40000675, "DIRLOG_PAO_MODIFY_REPLICA"},
    {0x80000676, "DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT"},
    {0x80000677, "DIRLOG_GC_INVALIDATED"},
    {0xC0000678, "DIRLOG_NO_RPC_PROTSEQS"},
    {0x80000679, "DIRLOG_ISM_ADS_GET_OBJECT_FAILURE"},
    {0x4000067A, "DIRLOG_DRA_NC_TEARDOWN_BEGIN"},
    {0x4000067B, "DIRLOG_DRA_NC_TEARDOWN_RESUME"},
    {0x4000067C, "DIRLOG_DRA_NC_TEARDOWN_SUCCESS"},
    {0x4000067D, "DIRLOG_DRA_NC_TEARDOWN_FAILURE"},
    {0xC000067E, "DIRLOG_MAPI_TABLE_TOO_BIG"},
    {0x8000067F, "DIRLOG_KCC_CACHE_INIT_FAILED"},
    {0xC0000680, "DIRLOG_KCC_CONNECTION_OBJ_TRANSLATION_DISABLED"},
    {0x40000681, "DIRLOG_IDL_DRS_GET_MEMBERSHIPS2_ENTRY"},
    {0x40000682, "DIRLOG_IDL_DRS_GET_MEMBERSHIPS2_EXIT"},
    {0x80000683, "DIRLOG_GROUP_CACHING_CONFIGURED_SITE_NOT_CLOSEST"},
    {0x80000684, "DIRLOG_GROUP_CACHING_CLOSER_GC_FOUND"},
    {0x80000685, "DIRLOG_GROUP_CACHING_MAX_USERS_REFRESHED"},
    {0x80000686, "DIRLOG_GROUP_CACHING_FALLING_BEHIND"},
    {0x80000687, "DIRLOG_GROUP_CACHING_CANT_FIND_OPEN_SLOT"},
    {0x80000688, "DIRLOG_GROUP_CACHING_NO_SCHEDULE_FOR_PREFERRED_SITE"},
    {0x40000689, "DIRLOG_LVR_SET_META_INSERT_MADE_PRESENT"},
    {0x4000068A, "DIRLOG_LVR_SET_META_INSERT_PRESENT"},
    {0x4000068B, "DIRLOG_LVR_SET_META_REPLACE_MADE_ABSENT"},
    {0x4000068C, "DIRLOG_LVR_SET_META_REPLACE_TOUCHED"},
    {0x4000068D, "DIRLOG_LVR_SET_META_REMOVE_ATT_MADE_ABSENT"},
    {0x4000068E, "DIRLOG_LVR_SET_META_REMOVE_VALUE_MADE_ABSENT"},
    {0x4000068F, "DIRLOG_LVR_META_INFO"},
    {0x40000690, "DIRLOG_LVR_FILTERED_NOT_PAS"},
    {0x40000691, "DIRLOG_LVR_FILTERED_NOT_GROUP"},
    {0x40000692, "DIRLOG_LVR_FILTERED_NOT_NEEDED"},
    {0x40000693, "DIRLOG_LVR_SHIPPED"},
    {0x40000694, "DIRLOG_LVR_NOT_APPLIED_DELETED"},
    {0x40000695, "DIRLOG_LVR_NOT_APPLIED_MISSING"},
    {0x40000696, "DIRLOG_LVR_NOT_APPLIED_NOT_NEEDED"},
    {0x40000697, "DIRLOG_LVR_GET_META_OP"},
    {0x40000698, "DIRLOG_LVR_REMOTE_META_INFO"},
    {0x40000699, "DIRLOG_LVR_APPLIED"},
    {0x4000069A, "DIRLOG_LVR_CONFLICT"},
    {0x4000069B, "DIRLOG_LVR_NOT_APPLIED_VALUE_DELETED"},
    {0x4000069C, "DIRLOG_LVR_NOT_APPLIED_MISSING2"},
    {0x4000069D, "DIRLOG_LVR_SET_META_INSERT_ABSENT"},
    {0xC000069E, "DIRLOG_DRA_UPDATE_VALUE_FAILURE_NOT_BUSY"},
    {0x4000069F, "DIRLOG_LVR_ENABLED"},
    {0x400006A0, "DIRMSG_INSTALL_REPLICATE_PROGRESS_VALUES"},
    {0x400006A1, "DIRLOG_GC_REMOVED_OBJECT_VALUE"},
    {0x800006A2, "DIRLOG_GC_FAILED_TO_REMOVE_OBJECT_VALUE"},
    {0xC00006A3, "DIRLOG_DRA_GETCHANGES_FAILED"},
    {0xC00006A4, "DIRLOG_MAIL_INTERSITE_TRANSPORT_MISSING"},
    {0xC00006A5, "DIRLOG_MAIL_ADD_SCHEMA_INFO_FAILED"},
    {0x400006A6, "DIRLOG_GC_PAS_COMPLETED"},
    {0x400006A7, "DIRLOG_GC_TRIGGER_FULL_SYNC"},
    {0x400006A8, "DIRLOG_GC_PAS_CYCLE"},
    {0x400006A9, "DIRLOG_GC_FOUND_INVALID_PAS_SOURCE"},
    {0x400006AA, "DIRLOG_GC_FOUND_PAS_SOURCE"},
    {0x400006AB, "DIRLOG_GC_PAS_SOURCE_NOT_FOUND"},
    {0x400006AC, "DIRLOG_GC_REGISTER_ACTIVE_PAS"},
    {0x400006AD, "DIRLOG_GC_REGISTER_RESET_PAS"},
    {0x800006AE, "DIRLOG_GC_NO_SOURCES"},
    {0x400006AF, "DIRLOG_GC_SKIP_ENQUEUE"},
    {0x400006B0, "DIRLOG_GC_ABANDON_PAS"},
    {0x400006B1, "DIRLOG_SEARCH_VLV_INDEX_NOT_FOUND"},
    {0x400006B2, "DIRLOG_LVR_SET_META_GROUP_TYPE_CHANGE"},
    {0x800006B3, "DIRLOG_LINK_CLEAN_END_ABNORMAL"},
    {0x400006B4, "DIRLOG_GC_UPDATED_OBJECT_VALUE"},
    {0xC00006B5, "DIRMSG_INSTALL_FAILED_VERSION_CHECK"},
    {0xC00006B6, "DIRLOG_FAILED_VERSION_CHECK"},
    {0xC00006B7, "DIRLOG_UNABLE_TO_CHECK_VERSION"},
    {0xC00006B8, "DIRLOG_HIGHER_DSA_VERSION"},
    {0xC00006B9, "DIRLOG_UNABLE_TO_UPDATE_VERSION"},
    {0x400006BA, "DIRLOG_DSA_VERSION_UPDATED"},
    {0x800006BB, "DIRLOG_LOWER_DSA_VERSION"},
    {0x800006BC, "DIRLOG_NO_VERSION_UPGRADE_IN_MIXED_DOMAIN"},
    {0x800006BD, "DIRLOG_DRA_TOO_LOW_VERSION"},
    {0xC00006BE, "DIRLOG_BAD_VERSION_REP_IN"},
    {0xC00006BF, "DIRLOG_DS_TOO_OLD"},
    {0xC00006C0, "DIRLOG_FAILED_BOOT_OPTION_SETUP"},
    {0xC00006C1, "DIRMSG_INSTALL_FAILED_TOMBSTONE_CHECK"},
    {0x400006C2, "DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_RMSOURCE_SUCCESS"},
    {0x400006C3, "DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_RMSOURCE_FAILURE"},
    {0x400006C4, "DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_SUCCESS"},
    {0x400006C5, "DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_FAILURE"},
    {0x400006C6, "DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_RMSOURCE_SUCCESS"},
    {0x400006C7, "DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_RMSOURCE_FAILURE"},
    {0x400006C8, "DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_TEARDOWN_SUCCESS"},
    {0x400006C9, "DIRLOG_CHK_LINK_DEL_HAVE_READONLY_NEED_WRITEABLE_TEARDOWN_FAILURE"},
    {0x400006CA, "DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_RMSOURCE_SUCCESS"},
    {0x400006CB, "DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_RMSOURCE_FAILURE"},
    {0x400006CC, "DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_TEARDOWN_SUCCESS"},
    {0x400006CD, "DIRLOG_CHK_LINK_DEL_HAVE_WRITEABLE_NEED_READONLY_TEARDOWN_FAILURE"},
    {0x400006CE, "DIRLOG_CHK_LINK_DEL_SOURCE_READONLY_SUCCESS"},
    {0x400006CF, "DIRLOG_CHK_LINK_DEL_SOURCE_READONLY_FAILURE"},
    {0x400006D0, "DIRLOG_CHK_LINK_DEL_NOTGC_TEARDOWN_SUCCESS"},
    {0x400006D1, "DIRLOG_CHK_LINK_DEL_NOTGC_TEARDOWN_FAILURE"},
    {0x400006D2, "DIRLOG_CHK_LINK_DEL_DOMDEL_TEARDOWN_SUCCESS"},
    {0x400006D3, "DIRLOG_CHK_LINK_DEL_DOMDEL_TEARDOWN_FAILURE"},
    {0x800006D4, "DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_NOREPLICACFG"},
    {0x800006D5, "DIRLOG_CHK_LINK_DEL_NDNC_NOTREPLICA_TEARDOWN_NOREPLICAADVERTISING"},
    {0x400006D6, "DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_TEARDOWN_SUCCESS"},
    {0x400006D7, "DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_TEARDOWN_FAILURE"},
    {0x400006D8, "DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_RMSOURCE_SUCCESS"},
    {0x400006D9, "DIRLOG_CHK_LINK_DEL_NDNC_NOCROSSREF_RMSOURCE_FAILURE"},
    {0x400006DA, "DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_RMSOURCE_SUCCESS"},
    {0x400006DB, "DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_RMSOURCE_FAILURE"},
    {0x400006DC, "DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_TEARDOWN_SUCCESS"},
    {0x400006DD, "DIRLOG_CHK_LINK_DEL_READONLY_NOTGCHOSTED_TEARDOWN_FAILURE"},
    {0x400006DE, "DIRMSG_DEMOTE_NC_GIVING_AWAY_FSMO_ROLES"},
    {0x400006DF, "DIRMSG_DEMOTE_NC_COMPLETING_LINK_CLEANUP"},
    {0x400006E0, "DIRMSG_DEMOTE_NC_REPLICATING_OFF_CHANGES"},
    {0x400006E1, "DIRMSG_DEMOTE_NC_GETTING_TARGET"},
    {0x400006E2, "DIRMSG_DEMOTE_NC_BEGIN"},
    {0x400006E3, "DIRMSG_DEMOTE_NC_FAILED"},
    {0x400006E4, "DIRMSG_DEMOTE_NC_SUCCESS"},
    {0x400006E5, "DIRMSG_DEMOTE_NC_NO_TARGETS"},
    {0x400006E6, "DIRLOG_LOCALIZED_CREATE_INDEX_FAILED"},
    {0xC00006E7, "DIRMSG_SPACE_IN_NETBIOSNAME"},
    {0xC00006E8, "DIRLOG_KCC_SITE_LINK_SITE_NOT_IN_SITE_LIST"},
    {0xC00006E9, "DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET"},
    {0xC00006EA, "DIRLOG_UNUSED_4"},
    {0xC00006EB, "DIRLOG_KCC_BRIDGE_SITE_LINK_NOT_IN_SITE_LINK_LIST"},
    {0x800006EC, "DIRLOG_HEAP_CREATE_FAILED"},
    {0xC00006ED, "DIRLOG_FAILED_BOOT_OPTION_SETUP_DISK"},
    {0xC00006EE, "DIRLOG_AUTO_LINK_ID_FAILED"},
    {0x800006EF, "DIRLOG_LDAP_DIGEST_WARNING"},
    {0x400006F0, "DIRLOG_GROUP_CACHING_TASK_STARTING"},
    {0x400006F1, "DIRLOG_GROUP_CACHING_TASK_ENDING"},
    {0x400006F2, "DIRLOG_GROUP_CACHING_TASK_RESCHEDULING"},
    {0x400006F3, "DIRLOG_GROUP_CACHING_GC_FOUND"},
    {0x400006F4, "DIRLOG_GROUP_CACHING_NO_GC_FOUND"},
    {0x400006F5, "DIRLOG_GROUP_CACHING_SITE_FOUND"},
    {0x400006F6, "DIRLOG_GROUP_CACHING_NO_SITE_FOUND"},
    {0x400006F7, "DIRLOG_GROUP_CACHING_GROUP_RETRIEVAL_FAILED"},
    {0x400006F8, "DIRLOG_GROUP_CACHING_GROUP_NO_GC_SITE"},
    {0x400006F9, "DIRLOG_GROUP_CACHING_NO_SCHEDULE_FOR_SITE"},
    {0x800006FA, "DIRLOG_KCC_SITE_LINK_TOO_SMALL"},
    {0xC00006FB, "DIRLOG_KCC_SITE_LINK_BRIDGE_TOO_SMALL"},
    {0xC00006FC, "DIRLOG_KCC_NONINTERSECTING_SCHEDULES"},
    {0xC00006FD, "DIRLOG_KCC_SITE_WITH_NO_LINKS"},
    {0xC00006FE, "DIRLOG_GC_PROMOTION_FAILED"},
    {0xC00006FF, "DIRLOG_REPLICATION_SKIP_REQUEUE"},
    {0x80000700, "DIRLOG_OVERLONG_TRANSACTION"},
    {0x40000701, "DIRLOG_TASK_QUEUE_BEGIN_EXECUTE"},
    {0x40000702, "DIRLOG_TASK_QUEUE_END_EXECUTE"},
    {0x80000703, "DIRLOG_KCC_UNKNOWN_TRANSPORT"},
    {0x80000704, "DIRLOG_KCC_SET_PRIORITY_ERROR"},
    {0x80000705, "DIRLOG_KCC_ALMOST_MADE_DUP_CONNECTION"},
    {0xC0000706, "DIRMSG_FAIL_GET_GUID_REPLSERVER"},
    {0x80000707, "DIRLOG_KCC_DESTINATION_DSA_NOT_FOUND"},
    {0x80000708, "DIRLOG_KCC_NO_WRITEABLE_SOURCE_FOR_GC_TOPOLOGY"},
    {0x80000709, "DIRLOG_KCC_NC_NOT_INSTANTIATED_ANYWHERE"},
    {0x4000070A, "DIRLOG_KCC_NC_HEAD_NOT_FOUND"},
    {0x8000070B, "DIRLOG_CHK_BAD_ISM_SCHEDULE"},
    {0x4000070C, "DIRMSG_DEMOTE_NC_GIVING_AWAY_FSMO_ROLES_COMPELETE"},
    {0x4000070D, "DIRMSG_DEMOTE_NC_REPLICATING_OFF_CHANGES_COMPELETE"},
    {0x4000070E, "DISMSG_INSTALL_SCHEMA_COMPELETE"},
    {0x4000070F, "DISMSG_INSTALL_CONFIGURATION_COMPELETE"},
    {0x40000710, "DISMSG_INSTALL_CRITICAL_COMPELETE"},
    {0x40000711, "DIRLOG_GC_NO_INTRA_SITE_SOURCES"},
    {0xC0000712, "DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED"},
    {0xC0000713, "DIRLOG_ISM_START_SERVICE_CTRL_DISPATCHER_FAILURE"},
    {0xC0000714, "DIRLOG_ISM_INIT_SERVICE"},
    {0xC0000715, "DIRLOG_ISM_CREATE_EVENT_FAILED"},
    {0xC0000716, "DIRLOG_ISM_DS_BAD_NAME_SYNTAX"},
    {0xC0000717, "DIRLOG_ISM_NOT_ENOUGH_MEMORY"},
    {0xC0000718, "DIRLOG_ISM_REGISTER_SERVICE_CONTROL_HANDLER_FAILED"},
    {0xC0000719, "DIRLOG_ISM_START_RPC_SERVER_FAILED"},
    {0xC000071A, "DIRLOG_ISM_CONSTRUCT_SECURITY_DESCRIPTOR_FAILED"},
    {0xC000071B, "DIRLOG_ISM_RPC_SERVER_USE_PROT_SEQ_FAILED"},
    {0xC000071C, "DIRLOG_ISM_RPC_SERVER_REGISTER_IF_FAILED"},
    {0xC000071D, "DIRLOG_ISM_RPC_SERVER_LISTEN_FAILED"},
    {0x8000071E, "DIRLOG_ISM_RPC_SERVER_STOP_FAILED"},
    {0xC000071F, "DIRLOG_ISM_LDAP_ABANDON_FAILED"},
    {0xC0000720, "DIRLOG_ISM_LDAP_BIND_FAILED"},
    {0xC0000721, "DIRLOG_ISM_TRANSPORT_MONITOR_START_FAILURE"},
    {0x80000722, "DIRLOG_ISM_CRITICAL_SITE_ATTRIBUTE_FAILURE"},
    {0x80000723, "DIRLOG_ISM_CRITICAL_TRANSPORT_ATTRIBUTE_FAILURE"},
    {0x80000724, "DIRLOG_KCC_SKIPPED_DIRREPLICAADD"},
    {0xC0000725, "DIRMSG_INSTALL_FAILED_TOO_MANY_STANDARD_SERVERS"},
    {0xC0000726, "DIRMSG_INSTALL_FAILED_NO_VER"},
    {0xC0000727, "DIRMSG_INSTALL_FAILED_IMPROPERLY_DELETED_DOMAIN_FSMO"},
    {0xC0000728, "DIRLOG_ISM_NO_SMTP_DOMAIN"},
    {0x80000729, "DIRLOG_ISM_ADS_DELETE_OBJECT_FAILURE"},
    {0xC000072A, "DIRLOG_ISM_SMTP_DOMAIN_REMOVE_FAILURE"},
    {0x8000072B, "DIRLOG_ISM_ADS_SET_INFO_FAILURE"},
    {0x4000072C, "DIRLOG_ISM_SMTP_MESSAGE_COUNT"},
    {0x4000072D, "DIRLOG_FSMO_XFER_FAILURE"},
    {0x8000072E, "DIRLOG_DRA_REPLICATION_OP_OVER_TIME_LIMIT"},
    {0x8000072F, "DIRLOG_DRA_REPLICATION_OP_NOT_EXECUTING"},
    {0x40000730, "DIRLOG_SCHEMA_DELETED_TUPLE_INDEX"},
    {0x40000731, "DIRLOG_SCHEMA_DELETE_TUPLE_INDEX_FAIL"},
    {0x40000732, "DIRLOG_GROUP_CACHING_PREFERRED_SITE_LINK"},
    {0x40000733, "DIRLOG_DRA_OBJECT_REVIVED"},
    {0xC0000734, "DIRLOG_VERIFY_BY_CRACK_ERROR"},
    {0x80000735, "DIRLOG_SCHEMA_DUP_GOVERNSID"},
    {0x40000736, "DIRLOG_SCHEMA_IGNORE_DEFUNCT"},
    {0x80000737, "DIRLOG_SCHEMA_DUP_GOVERNSID_ATTRIBUTEID"},
    {0x80000738, "DIRLOG_SCHEMA_DUP_SCHEMAIDGUID_CLASS"},
    {0x80000739, "DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_CLASS"},
    {0x8000073A, "DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_CLASS_ATTRIBUTE"},
    {0x8000073B, "DIRLOG_SCHEMA_DUP_ATTRIBUTEID"},
    {0x8000073C, "DIRLOG_SCHEMA_DUP_SCHEMAIDGUID_ATTRIBUTE"},
    {0x8000073D, "DIRLOG_SCHEMA_DUP_MAPIID"},
    {0x8000073E, "DIRLOG_SCHEMA_DUP_LDAPDISPLAYNAME_ATTRIBUTE"},
    {0x4000073F, "DIRLOG_SCHEMA_RESURRECT_RDNATTID"},
    {0x40000740, "DIRLOG_UNUSED_13"},
    {0x40000741, "DIRMSG_INSTALL_FAILED_SCHEMA_RELOAD"},
    {0x40000742, "DISMSG_RELOAD_SCHEMA_COMPELETE"},
    {0x80000743, "DIRLOG_GC_CONFIG_PERIOD_TOOLONG"},
    {0x40000744, "DIRLOG_DRA_SET_IT"},
    {0xC0000745, "DIRLOG_ISM_RPC_SERVER_REGISTER_AUTH_INFO_FAILED"},
    {0x80000746, "DIRLOG_DRA_REPLICATION_LATENCY_WARNINGS"},
    {0xC0000747, "DIRLOG_DRA_REPLICATION_LATENCY_ERRORS"},
    {0xC0000748, "DIRLOG_DRA_REPLICATION_LATENCY_ERRORS_FULL"},
    {0x80000749, "DIRLOG_KCC_DISCONNECTED_SITE"},
    {0xC000074A, "DIRLOG_ISM_LDAP_EXTENDED_SERVER_ERROR"},
    {0x8000074B, "DIRLOG_ISM_LINK_MONITOR_FAILURE_RESTART"},
    {0x4000074C, "DIRLOG_OFFSITE_GC_FAILBACK"},
    {0x4000074D, "DIRLOG_GC_FOUND"},
    {0x8000074E, "DIRLOG_KCC_TOO_MANY_PARTNERS"},
    {0xC000074F, "DIRLOG_DRA_ORPHAN_MOVE_FAILURE"},
    {0x40000750, "DIRLOG_DRA_ORPHAN_MOVE_SUCCESS"},
    {0x40000751, "DIRMSG_COPY_RESTORED_FILES"},
    {0xC0000752, "DIRMSG_COPY_RESTORED_FILES_FAILURE"},
    {0x80000753, "DIRLOG_DRA_REPL_EPOCH_CHANGED"},
    {0x80000754, "DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED"},
    {0xC0000755, "DIRLOG_DOMAIN_RENAME_ACCESS_DENIED"},
    {0xC0000756, "DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED"},
    {0xC0000757, "DIRLOG_DOMAIN_RENAME_READ_SCRIPT_FAILED"},
    {0xC0000758, "DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED"},
    {0xC0000759, "DIRLOG_DOMAIN_RENAME_CANNOT_SET_NEW_DOMAIN_NAME"},
    {0x4000075A, "DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME"},
    {0xC000075B, "DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME_FORCE"},
    {0x4000075C, "DIRLOG_SCRIPT_OPERATION_INSTANTIATED"},
    {0x4000075D, "DIRLOG_SCRIPT_OPERATION_CARDINALITY"},
    {0x4000075E, "DIRLOG_SCRIPT_OPERATION_COMPARE"},
    {0x4000075F, "DIRLOG_SCRIPT_OPERATION_UPDATE"},
    {0x40000760, "DIRLOG_SCRIPT_OPERATION_MOVE"},
    {0x40000761, "DIRLOG_SCRIPT_OPERATION_CREATE"},
    {0xC0000762, "DIRLOG_DRA_NCNAME_CONFLICT_RENAME_FAILURE"},
    {0x40000763, "DIRLOG_DRA_NCNAME_CONFLICT_RENAME_SUCCESS"},
    {0xC0000764, "DIRLOG_DSA_CHILD_CLEANUP_FAILURE"},
    {0xC0000765, "DIRMSG_REPLICATION_EPOCH_NOT_RETRIEVED"},
    {0xC0000766, "DIRMSG_REPLICATION_EPOCH_NOT_MATCHED"},
    {0x40000767, "DIRLOG_SCHEMA_ATTRIBUTE_WON_OID"},
    {0x40000768, "DIRLOG_SCHEMA_ATTRIBUTE_WON_LDN"},
    {0x40000769, "DIRLOG_SCHEMA_ATTRIBUTE_WON_MAPIID"},
    {0x4000076A, "DIRLOG_DSA_SCHEMA_OBJECT_MODIFIED"},
    {0x4000076B, "DIRLOG_DSA_SCHEMA_OBJECT_ADDED"},
    {0xC000076C, "DIRLOG_DUPLICATE_MOVED_OBJECT_CLEANUP"},
    {0x8000076D, "DIRLOG_DEMOTE_REMOVE_CA_ERROR"},
    {0x4000076E, "DIRLOG_KCC_WHISTLER_ELECTION_ALG"},
    {0x4000076F, "DIRLOG_CHK_LINK_ADD_MASTER_SUCCESS"},
    {0x40000770, "DIRLOG_KCC_WHISTLER_TOPOLOGY_ALG"},
    {0x40000771, "DIRLOG_KCC_SITE_GENERATOR_NOT_VIABLE"},
    {0x40000772, "DIRLOG_KCC_SITE_GENERATOR_NO_UTD"},
    {0x40000773, "DIRLOG_KCC_SITE_GENERATOR_CLAIM_VALID"},
    {0x40000774, "DIRLOG_KCC_SITE_GENERATOR_CLAIM_EXPIRED"},
    {0x40000775, "DIRLOG_KCC_ISTG_FAIL_OVER"},
    {0xC0000776, "DIRLOG_KCC_UTD_VEC_WRONG_VERSION"},
    {0x80000777, "DIRLOG_KCC_INTRASITE_UNAVAILABLE"},
    {0xC0000778, "DIRLOG_BACKUP_JET_WRITER_INIT_FAILURE"},
    {0xC0000779, "DIRLOG_BACKUP_UNEXPECTED_WIN32_ERROR"},
    {0xC000077A, "DIRLOG_BACKUP_NO_NTDS_NO_BACKUP"},
    {0xC000077B, "DIRLOG_BACKUP_YES_NTDS_NO_RESTORE"},
    {0xC000077C, "DIRLOG_BACKUP_SNAPSHOT_FAILURE"},
    {0x4000077D, "DIRLOG_BACKUP_SNAPSHOT_SUCCESS"},
    {0xC000077E, "DIRLOG_BACKUP_SNAPSHOT_TOO_OLD"},
    {0xC000077F, "DIRLOG_BACKUP_SNAPSHOT_RESTORE_FAILURE"},
    {0x40000780, "DIRLOG_BACKUP_SNAPSHOT_RESTORE_SUCCESS"},
    {0x80000781, "DIRLOG_BACKUP_DIR_READ_FAILURE"},
    {0x80000782, "DIRLOG_SETUP_MACHINE_ACCOUNT_NOT_REVERTED"},
    {0x80000783, "DIRMSG_SETUP_MACHINE_ACCOUNT_NOT_MORPHED"},
    {0x40000784, "DIRLOG_CHK_LINK_ADD_REPLICA_SUCCESS"},
    {0x80000785, "DIRLOG_CHK_LINK_ADD_MASTER_FAILURE"},
    {0x80000786, "DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE"},
    {0x40000787, "DIRLOG_ADUPD_NC_SYNC_PROGRESS"},
    {0x40000788, "DIRLOG_ADUPD_NC_SYNC_NO_PROGRESS"},
    {0x40000789, "DIRLOG_RPC_MESSAGE"},
    {0x4000078A, "DIRLOG_ADUPD_INIT_SYNC_ONGOING_READONLY"},
    {0xC000078B, "DIRLOG_BACKUP_SNAPSHOT_PRERESTORE_FAILURE"},
    {0x4000078C, "DIRLOG_DEL_SUB_FROM_NC"},
    {0x4000078D, "DIRLOG_ADD_SUB_TO_NC"},
    {0x4000078E, "DIRLOG_DEL_AUTO_SUBREF"},
    {0x4000078F, "DIRLOG_ADD_AUTO_SUBREF"},
    {0x40000790, "DIRLOG_SCRIPT_EXECUTE_STATUS"},
    {0x80000791, "DIRLOG_LOR_BEGIN"},
    {0x40000792, "DIRLOG_LOR_BEGIN_ADVISORY"},
    {0x80000793, "DIRLOG_LOR_END_SUCCESS"},
    {0x40000794, "DIRLOG_LOR_SUCCESS_TRANSACTION"},
    {0x40000795, "DIRLOG_LOR_FAILURE_TRANSACTION"},
    {0x40000796, "DIRLOG_LOR_END_ADVISORY_SUCCESS"},
    {0xC0000797, "DIRLOG_LOR_END_FAILURE"},
    {0xC0000798, "DIRLOG_LOR_END_ADVISORY_FAILURE"},
    {0x80000799, "DIRLOG_LOR_OBJECT_DELETION"},
    {0x4000079A, "DIRLOG_LOR_OBJECT_DELETION_ADVISORY"},
    {0xC000079B, "DIRLOG_LOR_OBJECT_DELETION_FAILED"},
    {0xC000079C, "DIRLOG_LOR_OBJECT_DELETION_FAILED_CRITICAL_OBJECT"},
    {0xC000079D, "DIRLOG_LOR_OBJECT_DELETION_ERROR"},
    {0xC000079E, "DIRLOG_LOR_OBJECT_DELETION_ERROR_FATAL"},
    {0x4000079F, "DIRLOG_REF_CACHE_REBUILD_FAILURE"},
    {0x400007A0, "DIRLOG_KCC_CONN_ON_PROBATION"},
    {0xC0002710, "DIRMSG_DB_success"},
    {0xC0002711, "DIRMSG_DB_ERR_UNKNOWN_ERROR"},
    {0xC0002712, "DIRMSG_DB_ERR_NO_CHILD"},
    {0xC0002713, "DIRMSG_DB_ERR_NEXTCHILD_NOTFOUND"},
    {0xC0002714, "DIRMSG_DB_ERR_CANT_SORT"},
    {0xC0002715, "DIRMSG_DB_ERR_TIMELIMIT"},
    {0xC0002716, "DIRMSG_DB_ERR_NO_VALUE"},
    {0xC0002717, "DIRMSG_DB_ERR_BUFFER_INADEQUATE"},
    {0xC0002718, "DIRMSG_DB_ERR_UNUSED_1"},
    {0xC0002719, "DIRMSG_DB_ERR_VALUE_TRUNCATED"},
    {0xC000271A, "DIRMSG_DB_ERR_ATTRIBUTE_EXISTS"},
    {0xC000271B, "DIRMSG_DB_ERR_ATTRIBUTE_DOESNT_EXIST"},
    {0xC000271C, "DIRMSG_DB_ERR_VALUE_EXISTS"},
    {0xC000271D, "DIRMSG_DB_ERR_SYNTAX_CONVERSION_FAILED"},
    {0xC000271E, "DIRMSG_DB_ERR_NOT_ON_BACKLINK"},
    {0xC000271F, "DIRMSG_DB_ERR_VALUE_DOESNT_EXIST"},
    {0xC0002720, "DIRMSG_DB_ERR_NO_PROPAGATIONS"},
    {0xC0002721, "DIRMSG_DB_ERR_DATABASE_ERROR"},
    {0xC0002722, "DIRMSG_DB_ERR_CANT_ADD_DEL_KEY"},
    {0xC0002723, "DIRMSG_DB_ERR_DSNAME_LOOKUP_FAILED"},
    {0xC0002724, "DIRMSG_DB_ERR_NO_MORE_DEL_RECORD"},
    {0xC0002725, "DIRMSG_DB_ERR_NO_SORT_TABLE"},
    {0xC0002726, "DIRMSG_DB_ERR_NOT_OPTIMIZABLE"},
    {0xC0002727, "DIRMSG_DB_ERR_BAD_INDEX"},
    {0xC0002728, "DIRMSG_DB_ERR_UNUSED_2"},
    {0xC0002729, "DIRMSG_DB_ERR_TOO_MANY"},
    {0xC000272A, "DIRMSG_DB_ERR_SYSERROR"},
    {0xC000272B, "DIRMSG_DB_ERR_BAD_SYNTAX"},
    {0xC000272C, "DIRMSG_DB_ERR_UNUSED_3"},
    {0xC000272D, "DIRMSG_DB_ERR_NOT_ON_CORRECT_VALUE"},
    {0xC000272E, "DIRMSG_DB_ERR_ONLY_ON_LINKED_ATTRIBUTE"},
    {0xC000272F, "DIRMSG_DB_ERR_EXCEPTION"},
    {0xC0002730, "DIRMSG_DB_ERR_SHUTTING_DOWN"},
    {0xC0002731, "DIRMSG_DB_ERR_WRITE_CONFLICT"},
    {0xC0002732, "DIRMSG_DB_ERR_VLV_CONTROL"},
    {0xC0002733, "DIRMSG_DB_ERR_NOT_AN_OBJECT"},
    {0xC0002734, "DIRLOG_DB_ERR_ALREADY_INSERTED"},
    {0xC0002735, "DIRLOG_DB_ERR_NO_CURRENT_RECORD"},
    {0xC0002736, "DIRLOG_DB_ERR_RECORD_NOT_FOUND"},

    {0     , "Event tag not found"}

};


// Below is built from \\index1\sdnt\ds\dns\server\server\dnsmsg.mc

FRS_EL_ENTRY DNSSvcEvents[] = {
    {1 ,"DNS_EVENT_STARTING"},
    {2 ,"DNS_EVENT_STARTUP_OK"},
    {3 ,"DNS_EVENT_SHUTDOWN"},
    {111 ,"DNS_EVENT_CANNOT_CREATE_THREAD"},
    {112 ,"DNS_EVENT_RECURSION_INIT_FAILED"},
    {113 ,"DNS_EVENT_SERVICE_NOTIFY"},
    {130 ,"DNS_EVENT_WINS_INIT_FAILED"},
    {131 ,"DNS_EVENT_NBSTAT_INIT_FAILED"},
    {132 ,"DNS_EVENT_NBSTAT_ADAPTER_FAILED"},
    {140 ,"DNS_EVENT_RPC_SERVER_INIT_FAILED"},
    {403 ,"DNS_EVENT_CANNOT_CREATE_TCP_SOCKET"},
    {404 ,"DNS_EVENT_CANNOT_BIND_TCP_SOCKET"},
    {405 ,"DNS_EVENT_CANNOT_LISTEN_TCP_SOCKET"},
    {406 ,"DNS_EVENT_CANNOT_CREATE_UDP_SOCKET"},
    {407 ,"DNS_EVENT_CANNOT_BIND_UDP_SOCKET"},
    {408 ,"DNS_EVENT_OPEN_SOCKET_FOR_ADDRESS"},
    {409 ,"DNS_EVENT_UPDATE_LISTEN_ADDRESSES"},
    {410 ,"DNS_EVENT_INVALID_LISTEN_ADDRESSES"},
    {411 ,"DNS_EVENT_HOSTENT_MAX_IPS"},
    {412 ,"DNS_EVENT_MANY_IP_INTERFACES"},
    {413 ,"DNS_EVENT_NON_DNS_PORT"},
    {414 ,"DNS_EVENT_SINGLE_LABEL_HOSTNAME"},
    {500 ,"DNS_EVENT_INVALID_REGISTRY_ZONE"},
    {501 ,"DNS_EVENT_INVALID_ZONE_TYPE"},
    {502 ,"DNS_EVENT_NO_ZONE_FILE"},
    {503 ,"DNS_EVENT_SECONDARY_REQUIRES_MASTERS"},
    {504 ,"DNS_EVENT_REG_ZONE_CREATION_FAILED"},
    {505 ,"DNS_EVENT_INVALID_REGISTRY_ZONE_DATA"},
    {506 ,"DNS_EVENT_INVALID_REGISTRY_PARAM"},
    {507 ,"DNS_EVENT_INVALID_REGISTRY_FORWARDERS"},
    {706 ,"DNS_EVENT_NO_ROOT_NAME_SERVER"},
    {707 ,"DNS_EVENT_NO_CACHE_FILE_SPECIFIED"},
    {708 ,"DNS_EVENT_CACHING_SERVER_ONLY"},
    {800 ,"DNS_EVENT_ZONE_BAD_PRIMARY_SERVER"},
    {1000 ,"DNS_EVENT_FILE_OPEN_ERROR"},
    {1001 ,"DNS_EVENT_FILE_NOT_MAPPED"},
    {1003 ,"DNS_EVENT_CACHE_FILE_NOT_FOUND"},
    {1004 ,"DNS_EVENT_COULD_NOT_OPEN_DATABASE"},
    {1008 ,"DNS_EVENT_FILE_PATH_TOO_LONG"},
    {1200 ,"DNS_EVENT_BOOT_FILE_NOT_FOUND"},
    {1201 ,"DNS_EVENT_ZONE_CREATION_FAILED"},
    {1202 ,"DNS_EVENT_DIRECTORY_DIRECTIVE"},
    {1203 ,"DNS_EVENT_NO_FORWARDING_ADDRESSES"},
    {1204 ,"DNS_EVENT_SLAVE_REQUIRES_FORWARDERS"},
    {1205 ,"DNS_EVENT_UNKNOWN_BOOTFILE_OPTION"},
    {1206 ,"DNS_EVENT_MISSING_DIRECTORY_NAME"},
    {1501 ,"DNS_EVENT_COULD_NOT_PARSE_DATABASE"},
    {1502 ,"DNS_EVENT_DATABASE_PARSING_ERROR"},
    {1503 ,"DNS_EVENT_PARSING_ERROR_LINE"},
    {1504 ,"DNS_EVENT_UNEXPECTED_TOKEN"},
    {1505 ,"DNS_EVENT_UNEXPECTED_END_OF_TOKENS"},
    {1506 ,"DNS_EVENT_INVALID_TOKEN"},
    {1507 ,"DNS_EVENT_INVALID_CLASS_TOKEN"},
    {1508 ,"DNS_EVENT_IGNORING_FILE_RECORD"},
    {1520 ,"DNS_EVENT_UNKNOWN_DIRECTIVE"},
    {1521 ,"DNS_EVENT_UNSUPPORTED_DIRECTIVE"},
    {1522 ,"DNS_EVENT_OBSOLETE_DIRECTIVE"},
    {1523 ,"DNS_EVENT_DIRECTIVE_NOT_YET_IMPLEMENTED"},
    {1540 ,"DNS_EVENT_DOMAIN_NODE_CREATION_ERROR"},
    {1541 ,"DNS_EVENT_PARSED_INVALID_DOMAIN_NAME"},
    {1542 ,"DNS_EVENT_INVALID_DOTTED_DOMAIN_NAME"},
    {1543 ,"DNS_EVENT_DOMAIN_NAME_TOO_LONG"},
    {1544 ,"DNS_EVENT_INVALID_ORIGIN_TOKEN"},
    {1545 ,"DNS_EVENT_FILE_NODE_OUTSIDE_ZONE"},
    {1546 ,"DNS_EVENT_FILE_INVALID_NS_NODE"},
    {1547 ,"DNS_EVENT_FILE_INVALID_A_NODE"},
    {1600 ,"DNS_EVENT_UNKNOWN_RESOURCE_RECORD_TYPE"},
    {1601 ,"DNS_EVENT_OBSOLETE_RECORD_SKIPPED"},
    {1602 ,"DNS_EVENT_INVALID_SOA_RECORD"},
    {1610 ,"DNS_EVENT_PARSED_ADD_RR_AT_CNAME"},
    {1611 ,"DNS_EVENT_PARSED_CNAME_NOT_ALONE"},
    {1612 ,"DNS_EVENT_PARSED_CNAME_LOOP"},
    {1613 ,"DNS_EVENT_INVALID_PREFERENCE"},
    {1614 ,"DNS_EVENT_INVALID_DWORD_TOKEN"},
    {1616 ,"DNS_EVENT_TEXT_STRING_TOO_LONG"},
    {1617 ,"DNS_EVENT_INVALID_IP_ADDRESS_STRING"},
    {1618 ,"DNS_EVENT_INVALID_IPV6_ADDRESS"},
    {1619 ,"DNS_EVENT_UNKNOWN_PROTOCOL"},
    {1620 ,"DNS_EVENT_UNKNOWN_SERVICE"},
    {1621 ,"DNS_EVENT_WKS_PORT_UNSUPPORTED"},
    {1650 ,"DNS_EVENT_INVALID_WINS_RECORD"},
    {1651 ,"DNS_EVENT_INVALID_NBSTAT_RECORD"},
    {1654 ,"DNS_EVENT_UNKNOWN_WINS_FLAG"},
    {1656 ,"DNS_EVENT_NO_NBSTAT_DOMAIN"},
    {2000 ,"DNS_BOOTFILE_BACKUP_MESSAGE"},
    {2001 ,"DNS_BOOTFILE_BACKUP_MESSAGE"},
    {2002 ,"DNS_EVENT_BOOTFILE_REWRITE"},
    {2003 ,"DNS_EVENT_BOOTFILE_WRITE_ERROR"},
    {2004 ,"DNS_EVENT_SWITCH_TO_BOOTFILE"},
    {2005 ,"DNS_EVENT_SWITCH_TO_BOOTFILE"},
    {2200 ,"DNS_EVENT_REGISTRY_OPEN_FAILED"},
    {2202 ,"DNS_EVENT_REGISTRY_WRITE_FAILED"},
    {2203 ,"DNS_EVENT_REGISTRY_DELETE_FAILED"},
    {2501 ,"DNS_EVENT_AGING_SCAVENGING_END"},
    {2502 ,"DNS_EVENT_AGING_SCAVENGING_END_NO_WORK"},
    {2600 ,"DNS_EVENT_SERVER_SUPPRESSION"},
    {2601 ,"DNS_EVENT_ZONE_SUPPRESSION"},
    {3000 ,"DNS_EVENT_START_LOG_SUPPRESS"},
    {3150 ,"DNS_EVENT_ZONE_WRITE_COMPLETED"},
    {3151 ,"DNS_EVENT_ZONE_WRITE_FAILED"},
    {3152 ,"DNS_EVENT_FILE_NOT_OPENED_FOR_WRITE"},
    {3153 ,"DNS_EVENT_WRITE_FILE_FAILURE"},
    {3160 ,"DNS_EVENT_UNWRITABLE_RECORD_TYPE"},
    {3162 ,"DNS_EVENT_UNKNOWN_PROTOCOL_NUMBER"},
    {3163 ,"DNS_EVENT_UNKNOWN_SERVICE_PORT"},
    {4000 ,"DNS_EVENT_DS_OPEN_FAILED"},
    {4001 ,"DNS_EVENT_DS_ZONE_OPEN_FAILED"},
    {4002 ,"DNS_EVENT_DS_ZONE_ADD_FAILED"},
    {4003 ,"DNS_EVENT_DS_ZONE_DELETE_FAILED"},
    {4004 ,"DNS_EVENT_DS_ZONE_ENUM_FAILED"},
    {4005 ,"DNS_EVENT_DS_ZONE_DELETE_DETECTED"},
    {4006 ,"DNS_EVENT_DS_NODE_LOAD_FAILED"},
    {4007 ,"DNS_EVENT_DS_REGISTRY_DP_INVALID"},
    {4010 ,"DNS_EVENT_DS_RECORD_LOAD_FAILED"},
    {4011 ,"DNS_EVENT_DS_WRITE_FAILED"},
    {4012 ,"DNS_EVENT_DS_WRITE_TIMEOUT"},
    {4013 ,"DNS_EVENT_DS_OPEN_WAIT"},
    {4014 ,"DNS_EVENT_DS_SECURITY_INIT_FAILURE"},
    {4015 ,"DNS_EVENT_DS_INTERFACE_ERROR"},
    {4016 ,"DNS_EVENT_DS_LDAP_TIMEOUT"},
    {4017 ,"DNS_EVENT_DS_DNSADMINS_ERROR"},
    {4500 ,"DNS_EVENT_DP_CREATED"},
    {4501 ,"DNS_EVENT_DP_DELETED"},
    {4502 ,"DNS_EVENT_DP_ENLISTED"},
    {4503 ,"DNS_EVENT_DP_UNENLISTED"},
    {4510 ,"DNS_EVENT_DP_FSMO_UNAVAILABLE"},
    {4511 ,"DNS_EVENT_DP_DEL_DURING_CHANGE_ERR"},
    {4512 ,"DNS_EVENT_DP_CANT_CREATE_BUILTIN"},
    {4513 ,"DNS_EVENT_DP_CANT_JOIN_FOREST_BUILTIN"},
    {4514 ,"DNS_EVENT_DP_CANT_JOIN_DOMAIN_BUILTIN"},
    {4515 ,"DNS_EVENT_DP_ZONE_CONFLICT"},
    {5050 ,"DNS_EVENT_ASSERT"},
    {5051 ,"DNS_EVENT_EXCESSIVE_MEMORY_USE"},
    {5105 ,"DNS_EVENT_ADDING_RR_AT_CNAME"},
    {5106 ,"DNS_EVENT_CNAME_NOT_ALONE"},
    {5107 ,"DNS_EVENT_CNAME_LOOP"},
    {5108 ,"DNS_EVENT_CNAME_LOOP_LINK"},
    {5500 ,"DNS_EVENT_BAD_QUERY"},
    {5501 ,"DNS_EVENT_BAD_PACKET_LENGTH"},
    {5502 ,"DNS_EVENT_BAD_TCP_MESSAGE"},
    {5504 ,"DNS_EVENT_INVALID_PACKET_DOMAIN_NAME"},
    {5505 ,"DNS_EVENT_PACKET_NAME_TOO_LONG"},
    {5506 ,"DNS_EVENT_PACKET_NAME_BAD_OFFSET"},
    {5507 ,"DNS_EVENT_PACKET_NAME_OFFSET_TOO_LONG"},
    {5508 ,"DNS_EVENT_PACKET_NAME_TOO_MANY_LABELS"},
    {5509 ,"DNS_EVENT_BAD_UPDATE_PACKET"},
    {5510 ,"DNS_EVENT_BAD_RESPONSE_PACKET"},
    {6000 ,"DNS_EVENT_ZONEXFR_START"},
    {6001 ,"DNS_EVENT_ZONEXFR_SUCCESSFUL"},
    {6002 ,"DNS_EVENT_ZONEXFR_ABORTED"},
    {6003 ,"DNS_EVENT_UDP_ZONE_TRANSFER"},
    {6004 ,"DNS_EVENT_BAD_ZONE_TRANSFER_REQUEST"},
    {6520 ,"DNS_EVENT_ZONE_UPDATE"},
    {6521 ,"DNS_EVENT_ZONE_IN_SYNC"},
    {6522 ,"DNS_EVENT_ZONE_TRANSFER_IN_PROGRESS"},
    {6523 ,"DNS_EVENT_XFR_MASTER_UNAVAILABLE"},
    {6524 ,"DNS_EVENT_AXFR_BAD_RESPONSE"},
    {6525 ,"DNS_EVENT_AXFR_REFUSED"},
    {6526 ,"DNS_EVENT_ZONE_NEWER_THAN_SERVER_VERSION"},
    {6527 ,"DNS_EVENT_ZONE_EXPIRATION"},
    {6530 ,"DNS_EVENT_XFR_ADD_RR_AT_CNAME"},
    {6531 ,"DNS_EVENT_XFR_CNAME_NOT_ALONE"},
    {6532 ,"DNS_EVENT_XFR_CNAME_LOOP"},
    {6533 ,"DNS_EVENT_AXFR_INIT_FAILED"},
    {6534 ,"DNS_EVENT_XFR_ABORTED_BY_MASTER"},
    {6535 ,"DNS_EVENT_IXFR_UNSUPPORTED"},
    {6536 ,"DNS_EVENT_IXFR_BAD_RESPONSE"},
    {6701 ,"DNS_EVENT_UPDATE_DS_PEERS_SUCCESS"},
    {6702 ,"DNS_EVENT_UPDATE_DS_PEERS_FAILURE"},
    {7050 ,"DNS_EVENT_RECV_CALL_FAILED"},
    {7051 ,"DNS_EVENT_RECVFROM_CALL_FAILED"},
    {7052 ,"DNS_EVENT_SEND_CALL_FAILED"},
    {7053 ,"DNS_EVENT_SENDTO_CALL_FAILED"},
    {7054 ,"DNS_EVENT_SELECT_CALL_FAILED"},
    {7055 ,"DNS_EVENT_ACCEPT_CALL_FAILED"},
    {7056 ,"DNS_EVENT_GQCS_CALL_FAILED"},
    {7060 ,"DNS_EVENT_CANNOT_CONNECT_TO_SERVER"},
    {7061 ,"DNS_EVENT_CANNOT_SET_WINS_BROADCAST"},
    {7062 ,"DNS_EVENT_SELF_SEND"},
    {7063 ,"DNS_EVENT_NON_RECURSIVE_FORWARDER"},
    {7500 ,"DNS_EVENT_SERVER_FAILURE_PROCESSING_PACKET"},
    {7502 ,"DNS_EVENT_OUT_OF_MEMORY"},
    {7503 ,"DNS_EVENT_CANNOT_ALLOCATE_RECORD"},
    {7504 ,"DNS_EVENT_CANNOT_ALLOCATE_NODE"},
    {9999 ,"DNS_EVENT_CONTINUE_LOG_SUPPRESS"},
    {10101 ,"DNSMSG_FILE_HEADER"},
    {10102 ,"DNSMSG_FILE_VERSION"},
    {10103 ,"DNSMSG_FILE_DELEGATION"},
    {10104 ,"DNSMSG_FILE_DELEGATION_END"},
    {10105 ,"DNSMSG_FILE_NAME_SERVERS"},
    {10106 ,"DNSMSG_FILE_WINS"},
    {10107 ,"DNSMSG_FILE_WINSR"},
    {10108 ,"DNSMSG_FILE_ZONE_RECORDS"},

    {0     , "Event tag not found"}

    };

/*

// The following came from \\index1\sdnt\ds\security\base\lsa\idl\lsapmsgs.mc
// Not sure of the facility names.  Presumably these go into the security event log.

MessageIdTypedef=DWORD
MessageId=0x1FFF SymbolicName=LSAP_UNUSED_MESSAGE
MessageId=0x2000 SymbolicName=LSAP_SID_NAME_NULL
MessageId=0x2001 SymbolicName=LSAP_SID_NAME_WORLD
MessageId=0x2002 SymbolicName=LSAP_SID_NAME_LOCAL
MessageId=0x2003 SymbolicName=LSAP_SID_NAME_CREATOR_OWNER
MessageId=0x2004 SymbolicName=LSAP_SID_NAME_CREATOR_GROUP
MessageId=0x2005 SymbolicName=LSAP_SID_NAME_NT_DOMAIN
MessageId=0x2006 SymbolicName=LSAP_SID_NAME_NT_AUTHORITY
MessageId=0x2007 SymbolicName=LSAP_SID_NAME_DIALUP
MessageId=0x2008 SymbolicName=LSAP_SID_NAME_NETWORK
MessageId=0x2009 SymbolicName=LSAP_SID_NAME_BATCH
MessageId=0x200A SymbolicName=LSAP_SID_NAME_INTERACTIVE
MessageId=0x200B SymbolicName=LSAP_SID_NAME_SERVICE
MessageId=0x200C SymbolicName=LSAP_SID_NAME_BUILTIN
MessageId=0x200D SymbolicName=LSAP_SID_NAME_SYSTEM
MessageId=0x200E SymbolicName=LSAP_SID_NAME_ANONYMOUS
MessageId=0x200f SymbolicName=LSAP_SID_NAME_CREATOR_OWNER_SERVER
MessageId=0x2010 SymbolicName=LSAP_SID_NAME_CREATOR_GROUP_SERVER
MessageId=0x2011 SymbolicName=LSAP_SID_NAME_SERVER
MessageId=0x2012 SymbolicName=LSAP_SID_NAME_SELF
MessageId=0x2013 SymbolicName=LSAP_SID_NAME_AUTHENTICATED_USER
MessageId=0x2014 SymbolicName=LSAP_SID_NAME_RESTRICTED
MessageId=0x2015 SymbolicName=LSAP_SID_NAME_INTERNET
MessageId=0x2016 SymbolicName=LSAP_SID_NAME_TERMINAL_SERVER
MessageId=0x2017 SymbolicName=LSAP_SID_NAME_PROXY
MessageId=0x2018 SymbolicName=LSAP_SID_NAME_LOCALSERVICE
MessageId=0x2019 SymbolicName=LSAP_SID_NAME_NETWORKSERVICE
MessageId=0x201A SymbolicName=LSAP_SID_NAME_REMOTE_INTERACTIVE
MessageId=0x201B SymbolicName=LSAP_SID_NAME_USERS
MessageId=0x4000 SymbolicName=LSAP_DEFAULT_DOMAIN_NAME
MessageId=1 Severity=Success SymbolicName=CATEGORY_SPM
MessageId= Severity=Success SymbolicName=CATEGORY_LOCATOR
MessageId= Severity=Success SymbolicName=CATEGORY_NEGOTIATE
MessageId= Severity=Success SymbolicName=CATEGORY_MAX_CATEGORY
MessageId=4000 Severity=Warning SymbolicName=SPMEVENT_SUPPCRED_FAILED
MessageId=5000 Severity=Error SymbolicName=SPMEVENT_PACKAGE_FAULT
MessageId=6000 Severity=Informational Facility=EFSServer SymbolicName=EFS_RECOVERY_STARTED
MessageId=6001 Severity=Error Facility=EFSServer SymbolicName=EFS_PNP_NOT_READY
MessageId=6002 Severity=Error Facility=EFSServer SymbolicName=EFS_GET_VOLUMES_ERROR
MessageId=6003 Severity=Informational Facility=EFSServer SymbolicName=EFS_FT_STARTED
MessageId=6004 Severity=Error Facility=EFSServer SymbolicName=EFS_OPEN_LOGFILE_ERROR
MessageId=6005 Severity=Error Facility=Io SymbolicName=EFS_READ_LOGFILE_ERROR
MessageId=6006 Severity=Informational Facility=EFSServer SymbolicName=EFS_LOGFILE_FORMAT_ERROR
MessageId=6007 Severity=Error Facility=EFSServer SymbolicName=EFS_OPEN_LOGFILE_NC_ERROR
MessageId=6008 Severity=Warning Facility=EFSServer SymbolicName=EFS_TMP_FILENAME_ERROR
MessageId=6009 Severity=Error Facility=EFSServer SymbolicName=EFS_TMP_FILEID_ERROR
MessageId=6010 Severity=Warning Facility=EFSServer SymbolicName=EFS_TMP_OPEN_NAME_ERROR
MessageId=6011 Severity=Error Facility=EFSServer SymbolicName=EFS_TARGET_OPEN_ERROR
MessageId=6012 Severity=Informational Facility=EFSServer SymbolicName=EFS_TARGET_RECOVERED
MessageId=6013 Severity=Error Facility=EFSServer SymbolicName=EFS_DRIVER_MISSING
MessageId=6014 Severity=Error Facility=EFSServer SymbolicName=EFS_TMPFILE_MISSING
MessageId=6015 Severity=Error Facility=EFSServer SymbolicName=EFS_TMP_STREAM_INFO_ERROR
MessageId=6016 Severity=Error Facility=EFSServer SymbolicName=EFS_TMP_STREAM_OPEN_ERROR
MessageId=6017 Severity=Error Facility=EFSServer SymbolicName=EFS_TARGET_STREAM_OPEN_ERROR
MessageId=6018 Severity=Error Facility=EFSServer SymbolicName=EFS_STREAM_COPY_ERROR
MessageId=6019 Severity=Error Facility=EFSServer SymbolicName=EFS_REPARSE_FILE_ERROR
MessageId=6020 Severity=Error Facility=EFSServer SymbolicName=EFS_TMP_FILE_ERROR
MessageId=6021 Severity=Error Facility=EFSServer SymbolicName=EFS_DIR_MULTISTR_ERROR
MessageId=6022 Severity=Error Facility=EFSServer SymbolicName=EFS_OPEN_CACHE_ERROR
MessageId=6023 Severity=Warning Facility=EFSServer SymbolicName=EFS_DEL_LOGFILE_ERROR
MessageId=6024 Severity=Error Facility=EFSServer SymbolicName=EFS_BAD_RECOVERY_POLICY_ERROR
MessageId=6025 Severity=Error Facility=System SymbolicName=LSA_TRUST_UPGRADE_ERROR
MessageId=6026 Severity=Error Facility=System SymbolicName=LSA_ITA_UPGRADE_ERROR
MessageId=6027 Severity=Error Facility=System SymbolicName=LSA_SECRET_UPGRADE_ERROR
MessageId=6028 Severity=Error Facility=EFSServer SymbolicName=EFS_INVALID_RECOVERY_POLICY_ERROR
MessageId=6029 Severity=Error Facility=System SymbolicName=LSA_DOMAIN_RENAME_ERROR1
;//MessageId=6030 Severity=Error Facility=System SymbolicName=LSA_DOMAIN_RENAME_ERROR2
MessageId=6031 Severity=Error Facility=System SymbolicName=LSA_TRUST_INSERT_ERROR
MessageId=6032 Severity=Error Facility=EFSServer SymbolicName=EFS_NTLM_ERROR
MessageId=0x7000 Severity=Success SymbolicName=DSROLEEVT_SEARCH_DC
MessageId=0x7001 Severity=Success SymbolicName=DSROLEEVT_FOUND_DC
MessageId=0x7002 Severity=Success SymbolicName=DSROLEEVT_FOUND_SITE
MessageId=0x7003 Severity=Success SymbolicName=DSROLEEVT_STOP_SERVICE
MessageId=0x7004 Severity=Success SymbolicName=DSROLEEVT_CONFIGURE_SERVICE
MessageId=0x7005 Severity=Success SymbolicName=DSROLEEVT_START_SERVICE
MessageId=0x7006 Severity=Success SymbolicName=DSROLEEVT_INSTALL_DS
MessageId=0x7007 Severity=Success SymbolicName=DSROLEEVT_REPLICATE_SCHEMA
MessageId=0x7008 Severity=Success SymbolicName=DSROLEEVT_SET_LSA
MessageId=0x7009 Severity=Success SymbolicName=DSROLEEVT_SET_LSA_FROM
MessageId=0x7010 Severity=Success SymbolicName=DSROLEEVT_CREATE_TRUST
MessageId=0x7011 Severity=Success SymbolicName=DSROLEEVT_PRODUCT_TYPE
MessageId=0x7012 Severity=Success SymbolicName=DSROLEEVT_LSA_UPGRADE
MessageId=0x7013 Severity=Success SymbolicName=DSROLEEVT_CREATE_SYSVOL
MessageId=0x7014 Severity=Success SymbolicName=DSROLEEVT_CREATE_SYSVOL_DIR
MessageId=0x7015 Severity=Success SymbolicName=DSROLEEVT_DELETE_TRUST
MessageId=0x7016 Severity=Success SymbolicName=DSROLEEVT_RESTORE_LSA
MessageId=0x7017 Severity=Success SymbolicName=DSROLEEVT_MACHINE_ACCT
MessageId=0x7018 Severity=Success SymbolicName=DSROLEEVT_PROMOTION_COMPLETE
MessageId=0x7019 Severity=Success SymbolicName=DSROLEEVT_CREATE_PARENT_TRUST
MessageId=0x7020 Severity=Success SymbolicName=DSROLEEVT_SEARCH_REPLICA
MessageId=0x7021 Severity=Success SymbolicName=DSROLEEVT_FOUND_REPLICA
MessageId=0x7022 Severity=Success SymbolicName=DSROLEEVT_MACHINE_POLICY
MessageId=0x7023 Severity=Success SymbolicName=DSROLEEVT_IMPERSONATE
MessageId=0x7024 Severity=Success SymbolicName=DSROLEEVT_REVERT
MessageId=0x7025 Severity=Success SymbolicName=DSROLEEVT_LOCAL_POLICY
MessageId=0x7026 Severity=Success SymbolicName=DSROLEEVT_PREPARE_DEMOTION
MessageId=0x7027 Severity=Success SymbolicName=DSROLEEVT_UNINSTALL_DS
MessageId=0x7028 Severity=Success SymbolicName=DSROLEEVT_SVSETUP
MessageId=0x7029 Severity=Success SymbolicName=DSROLEEVT_COPY_DIT
MessageId=0x7030 Severity=Success SymbolicName=DSROLEEVT_FIND_DC_FOR_ACCOUNT
MessageId=0x7031 Severity=Success SymbolicName=DSROLEEVT_SETTING_SECURITY
MessageId=0x7032 Severity=Success SymbolicName=DSROLEEVT_UNJOIN_DOMAIN
MessageId=0x7033 Severity=Success SymbolicName=DSROLEEVT_TIMESYNC
MessageId=0x7034 Severity=Success SymbolicName=DSROLEEVT_UPGRADE_SAM
MessageId=0x7035 Severity=Success SymbolicName=DSROLEEVT_MOVE_SCRIPTS
MessageId=0x7036 Severity=Success SymbolicName=DSROLEEVT_SET_COMPUTER_DNS
MessageId=0x7037 Severity=Success SymbolicName=DSROLEEVT_SCRIPTS_MOVED
MessageId=0x7038 Severity=Success SymbolicName=DSROLEEVT_COPY_RESTORED_FILES
MessageId=0x7100 Severity=Success SymbolicName=DSROLESTATUS_MACH_CONFIG
MessageId=0x7101 Severity=Success SymbolicName=DSROLESTATUS_INSTALL_DS
MessageId=0x7102 Severity=Success SymbolicName=DSROLESTATUS_INSTALL_SYSVOL
MessageId=0x7103 Severity=Success SymbolicName=DSROLESTATUS_TREE
MessageId=0x7104 Severity=Success SymbolicName=DSROLESTATUS_SERVICES
MessageId=0x7105 Severity=Success SymbolicName=DSROLESTATUS_SECURITY
MessageId=0x7106 Severity=Success SymbolicName=DSROLESTATUS_MEMBERSHIP
MessageId=0x7108 Severity=Success SymbolicName=DSROLESTATUS_DEMOTABLE
MessageId=0x7109 Severity=Success SymbolicName=DSROLESTATUS_UNINSTALL_DS
MessageId=0x710a Severity=Success SymbolicName=DSROLESTATUS_UNINSTALL_SYSVOL
MessageId=0x7200 Severity=Success SymbolicName=DSROLERES_PROMO_SUCCEEDED
MessageId=0x7201 Severity=Error SymbolicName=DSROLERES_PROMO_FAILED
MessageId=0x7202 Severity=Error SymbolicName=DSROLERES_FAIL_SCRIPT_COPY
MessageId=0x7203 Severity=Error SymbolicName=DSROLERES_FAIL_SET_SECURITY
MessageId=0x7204 Severity=Error SymbolicName=DSROLERES_INCOMPATIBLE_TRUST
MessageId=0x7205 Severity=Error SymbolicName=DSROLERES_FIND_DC
MessageId=0x7206 Severity=Error SymbolicName=DSROLERES_IMPERSONATION
MessageId=0x7207 Severity=Error SymbolicName=DSROLERES_NET_USE
MessageId=0x7208 Severity=Error SymbolicName=DSROLERES_TIME_SYNC
MessageId=0x7209 Severity=Error SymbolicName=DSROLERES_POLICY_READ_REMOTE
MessageId=0x7210 Severity=Error SymbolicName=DSROLERES_POLICY_READ_LOCAL
MessageId=0x7211 Severity=Error SymbolicName=DSROLERES_POLICY_WRITE_LOCAL
MessageId=0x7212 Severity=Error SymbolicName=DSROLERES_LSA_UPGRADE
MessageId=0x7213 Severity=Error SymbolicName=DSROLERES_LOGON_DOMAIN
MessageId=0x7214 Severity=Error SymbolicName=DSROLERES_SET_COMPUTER_DNS
MessageId=0x7215 Severity=Error SymbolicName=DSROLERES_MODIFY_MACHINE_ACCOUNT
MessageId=0x7216 Severity=Error SymbolicName=DSROLERES_LEAF_DOMAIN
MessageId=0x7217 Severity=Error SymbolicName=DSROLERES_SYSVOL_DEMOTION
MessageId=0x7218 Severity=Error SymbolicName=DSROLERES_DEMOTE_DS
MessageId=0x7219 Severity=Error SymbolicName=DSROLERES_SERVICE_CONFIGURE
MessageId=0x721A Severity=Error SymbolicName=DSROLERES_PRODUCT_TYPE
MessageId=0x721B Severity=Error SymbolicName=DSROLERES_PARENT_TRUST_EXISTS
MessageId=0x721C Severity=Error SymbolicName=DSROLERES_PARENT_TRUST_FAIL
MessageId=0x721D Severity=Error SymbolicName=DSROLERES_NO_PARENT_TRUST
MessageId=0x721E Severity=Error SymbolicName=DSROLERES_TRUST_FAILURE
MessageId=0x721F Severity=Error SymbolicName=DSROLERES_TRUST_CONFIGURE_FAILURE
MessageId=0x7220 Severity=Error SymbolicName=DSROLERES_FAIL_DISABLE_AUTO_LOGON
MessageId=0x7221 Severity=Error SymbolicName=DSROLERES_FAIL_LOGON_DOMAIN
MessageId=0x7222 Severity=Error SymbolicName=DSROLERES_FAIL_UNJOIN
MessageId=0x7223 Severity=Error SymbolicName=DSROLERES_NOT_FOREST_ROOT
MessageId=0x7224 Severity=Error SymbolicName=DSROLERES_GPO_CREATION
MessageId=0x7225 Severity=Error SymbolicName=DSROLERES_FAILED_TO_DELETE_TRUST
MessageId=0x7226 Severity=Error SymbolicName=DSROLERES_FAILED_TO_DEMOTE_FRS
MessageId=0x7227 Severity=Informational SymbolicName=DSROLERES_PROMOTE_SUCCESS
MessageId=0x7228 Severity=Informational SymbolicName=DSROLERES_DEMOTE_SUCCESS
MessageId=0x7229 Severity=Informational SymbolicName=DSROLERES_STARTING
MessageId=0x7230 Severity=Informational SymbolicName=DSROLERES_SYSVOL_DIR_ERROR
MessageId=0x7231 Severity=Informational SymbolicName=DSROLERES_OP_CANCELLED
MessageId=0x7232 Severity=Error SymbolicName=DSROLERES_UPDATE_PRENT4_ACCOUNT
MessageId=0x7233 Severity=Error SymbolicName=DSROLERES_WRONG_DOMAIN
MessageId=0x7234 Severity=Error SymbolicName=DSROLERES_FAILED_SYSVOL_CANNOT_BE_ROOT_DIRECTORY
MessageId=0x7235 Severity=Error SymbolicName=DSROLERES_FAILED_FIND_REQUESTED_DC
MessageId=0x7236 Severity=Error SymbolicName=DSROLERES_FAILED_FIND_SITE
MessageId=0x8000 Severity=Warning SymbolicName=LSAEVENT_ITA_NOT_DELETED
MessageId=0x8001 Severity=Warning SymbolicName=LSAEVENT_TRUST_FOR_ITA_NOT_CREATED
MessageId=0x8002 Severity=Warning SymbolicName=LSAEVENT_TRUST_FOR_ITA_NOT_DELETED
MessageId=0x8003 Severity=Warning SymbolicName=LSAEVENT_DUP_TRUST_REMOVED
MessageId=0x8004 Severity=Warning SymbolicName=LSAEVENT_ITA_FOR_TRUST_NOT_CREATED
MessageId=0x8005 Severity=Warning SymbolicName=LSAEVENT_LOOKUP_SC_FAILED
MessageId=0x8006 Severity=Warning SymbolicName=LSAEVENT_LOOKUP_SC_HANDLE_FAILED
MessageId=0x8007 Severity=Warning SymbolicName=LSAEVENT_LOOKUP_SC_LOOKUP_FAILED
MessageId=0x8008 Severity=Warning SymbolicName=LSAEVENT_LOOKUP_GC_FAILED
MessageId=0x8009 Severity=Warning SymbolicName=LSAEVENT_LOOKUP_TCPIP_NOT_INSTALLED
MessageId=0x800A Severity=Warning SymbolicName=LSAEVENT_LOOKUP_SID_FILTERED
MessageId=0x9000 Severity=Informational SymbolicName=SSLEVENT_SCHANNEL_STARTED
MessageId=0x9001 Severity=Error SymbolicName=SSLEVENT_GLOBAL_ACQUIRE_CONTEXT_FAILED
MessageId=0x9002 Severity=Error SymbolicName=SSLEVENT_SCHANNEL_INIT_FAILURE
MessageId=0x9003 Severity=Informational SymbolicName=SSLEVENT_CREATE_CRED
MessageId=0x9004 Severity=Informational SymbolicName=SSLEVENT_CRED_PROPERTIES
MessageId=0x9005 Severity=Error SymbolicName=SSLEVENT_NO_PRIVATE_KEY
MessageId=0x9006 Severity=Error SymbolicName=SSLEVENT_CRED_ACQUIRE_CONTEXT_FAILED
MessageId=0x9007 Severity=Error SymbolicName=SSLEVENT_CREATE_CRED_FAILED
MessageId=0x9008 Severity=Warning SymbolicName=SSLEVENT_NO_DEFAULT_SERVER_CRED
MessageId=0x9009 Severity=Error SymbolicName=SSLEVENT_NO_CIPHERS_SUPPORTED
MessageId=0x900a Severity=Error SymbolicName=SSLEVENT_CIPHER_MISMATCH
MessageId=0x900b Severity=Warning SymbolicName=SSLEVENT_NO_CLIENT_CERT_FOUND
MessageId=0x900c Severity=Error SymbolicName=SSLEVENT_BOGUS_SERVER_CERT
MessageId=0x900d Severity=Warning SymbolicName=SSLEVENT_BOGUS_CLIENT_CERT
MessageId=0x900e Severity=Warning SymbolicName=SSLEVENT_FAST_MAPPING_FAILURE
MessageId=0x900f Severity=Warning SymbolicName=SSLEVENT_CERT_MAPPING_FAILURE
MessageId=0x9010 Severity=Informational SymbolicName=SSLEVENT_HANDSHAKE_INFO
MessageId=0x9011 Severity=Error SymbolicName=SSLEVENT_EXPIRED_SERVER_CERT
MessageId=0x9012 Severity=Error SymbolicName=SSLEVENT_UNTRUSTED_SERVER_CERT
MessageId=0x9013 Severity=Error SymbolicName=SSLEVENT_REVOKED_SERVER_CERT
MessageId=0x9014 Severity=Error SymbolicName=SSLEVENT_NAME_MISMATCHED_SERVER_CERT
MessageId=0x9015 Severity=Warning SymbolicName=SSLEVENT_ISSUER_LIST_OVERFLOW_FAILURE
MessageId=0x9080 SymbolicName=SSLEVENTTEXT_CLIENT
MessageId=0x9081 SymbolicName=SSLEVENTTEXT_SERVER
MessageId=0xa000 Severity=Warning SymbolicName=NEGOTIATE_DOWNGRADE_DETECTED
MessageId=0xa001 Severity=Warning SymbolicName=NEGOTIATE_INVALID_SERVER
MessageId=0xa002 Severity=Warning SymbolicName=NEGOTIATE_UNBALANCED_EXCHANGE
MessageId=0xa003 Severity=Warning SymbolicName=NEGOTIATE_PACKAGE_FAILED
MessageId=0xa004 Severity=Warning SymbolicName=NEGOTIATE_UNKNOWN_PACKAGE
MessageId=0xa005  Severity=Informational SymbolicName=NEGOTIATE_PACKAGE_SELECTED
MessageId=0xa006  Severity=Informational SymbolicName=NEGOTIATE_MESSAGE_DECODED
MessageId=0xa007  Severity=Informational SymbolicName=NEGOTIATE_RAW_PACKET
MessageId=0xa008 Severity=Warning SymbolicName=NEGOTIATE_UNKNOWN_PACKET
MessageId=0xa009 Severity=Informational SymbolicName=NEGOTIATE_MESSAGE_DECODED_NO_TOKEN



*/



PCHAR GenIdToTag (
    DWORD         ID,
    PFRS_EL_ENTRY Etab
    )
{
    DWORD j = 0;

    while (((Etab[j].EventId & 0x0FFFFFFF) != ID) &&
            (Etab[j].EventId != 0)) {j++;}

    return Etab[j].EventTag;
}



PCHAR JetIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while (((JetEvents[j].EventId & 0x0FFFFFFF) != ID) &&
            (JetEvents[j].EventId != 0)) {j++;}

    return JetEvents[j].EventTag;
}



PCHAR KDCIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while (((KDCEvents[j].EventId & 0x0FFFFFFF) != ID) &&
            (KDCEvents[j].EventId != 0)) {j++;}

    return KDCEvents[j].EventTag;
}

PCHAR TimeservIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while (((TimeservEvents[j].EventId & 0x0FFFFFFF) != ID) &&
            (TimeservEvents[j].EventId != 0)) {j++;}

    return TimeservEvents[j].EventTag;
}


PCHAR NetLogonIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while (((NetlogonEvents[j].EventId & 0x0FFFFFFF) != ID) &&
            (NetlogonEvents[j].EventId != 0)) {j++;}

    return NetlogonEvents[j].EventTag;
}


PCHAR NetEventIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while (((NetEvents[j].EventId & 0x0FFFFFFF) != ID) &&
            (NetEvents[j].EventId != 0)) {j++;}

    return NetEvents[j].EventTag;
}



PCHAR DirSvcEventIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while (((DirSvcEvents[j].EventId & 0x0FFFFFFF) != ID) &&
            (DirSvcEvents[j].EventId != 0)) {j++;}

    return DirSvcEvents[j].EventTag;
}


PCHAR FrsEventIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while ((FrsEvents[j].EventId != ID) && (FrsEvents[j].EventId != 0)) {j++;}

    return FrsEvents[j].EventTag;
}


PCHAR SystemIoEventIdToTag (
    DWORD ID
)
{
    DWORD j = 0;

    while ((SystemIoEvents[j].EventId != ID) && (SystemIoEvents[j].EventId != 0)) {j++;}

    return SystemIoEvents[j].EventTag;
}



VOID
EventLogTimeToLocalTime (
    DWORD       eTime,
    SYSTEMTIME  *plTime
)
{
LONGLONG    time;
FILETIME    ftime;
FILETIME    lftime;


    // file time @ 1970 + nSec since 1970
    time = 0x019DB1DED53E8000 + (LONGLONG)eTime * 10000000;


    // convert the LONGLONG time to file time
    ftime.dwHighDateTime = (DWORD)(time >> 32);
    ftime.dwLowDateTime  = (DWORD)(time & 0x00000000FFFFFFFF);


    // get local file time
    FileTimeToLocalFileTime (&ftime, &lftime);


    // get local system time
    FileTimeToSystemTime (&lftime, plTime);

}




INT
FormatTime (
    SYSTEMTIME  *pLocalTime
)
{
CHAR    szTime[100];
INT     iR;

    iR = GetTimeFormat (LOCALE_USER_DEFAULT, 0, pLocalTime, NULL, szTime, 100);

    if (iR)
        return printf ("%13s", szTime);
    else
        return 0;

}




INT
FormatDate (
    SYSTEMTIME  *pLocalTime
)
{
CHAR    szDate[100];
INT     iR;

    iR = GetDateFormat (LOCALE_USER_DEFAULT, 0, pLocalTime, "M'/'d'/'yyyy", szDate, 100);

    if (iR)
        return printf ("%11s", szDate);
    else
        return 0;

}




int __cdecl main(int argc, char *argv[])

{
 HANDLE           hEventLog = NULL;
 DWORD            dwNumOfEvents = 0;
 PVOID            pvEventBuffer;
 PEVENTLOGRECORD  pelrCurrEvent = NULL;
 DWORD            dwNumRead = 0, dwNumRequired = 0;
 PDBENTRY         Match=NULL;
 DWORD            dwIteration = 0;
 BOOL             boolBackup=FALSE, boolClear=FALSE, boolRemote=FALSE;
 char             szBackupStub[128], szComputerName[24];
 DWORD            dwClearInterval = 96, dwBufferSize;
 DWORD            i;
 DWORD            NumRecordsDisplayed = 200;
 DWORD            LoopCount;


 szBackupStub[0]='\0';
 szComputerName[0]='\0';
 szRemoteComputer[0]='\0';


    for (i=0;i<(unsigned long) argc;i++) {
        if (strstr(_strlwr(argv[i]),"/?") ||
            strstr(argv[i],"-?") ||
            strstr(argv[i],"/h") ||
            strstr(argv[i],"-h")) {
            Usage();
            continue;
        }

        if (strstr(argv[i],"/b")) {
            sscanf(argv[i]," /b:%s",szBackupStub);
            boolBackup = TRUE;
            continue;
        }

        if (strstr(argv[i],"/m")) {
            if (!sscanf(argv[i]," /m:%s",szComputerName)) {
                Usage();
                continue;
            }
            continue;
        }

        if (strstr(argv[i],"/r")) {
            if (!sscanf(argv[i]," /r:%s",szRemoteComputer)) {
                Usage();
                continue;
            }
            bRemote = TRUE;
            continue;
        }

        if (strstr(argv[i],"/l")) {
            if (!sscanf(argv[i]," /l:%s",szLogType)) {
                printf("invalid szlogtype: %s\n", argv[i]);
                Usage();
                continue;
            }

            if (_stricmp("DS", szLogType) == 0) {
                sprintf(szLogType, "Directory Service");
            } else if (_stricmp("DNS", szLogType) == 0) {
                sprintf(szLogType, "DNS Server");
            }
            continue;
        }

        if (strstr(argv[i],"/n")) {
            if (!sscanf(argv[i]," /n:%d", &NumRecordsDisplayed)) {
                printf("invalid NumRecordsDisplayed: %s\n", argv[i]);
                Usage();
                continue;
            }
            continue;
        }

        if (strstr(argv[i],"/c")) {
            sscanf(argv[i]," /c:%lu",&dwClearInterval);
            dwClearInterval *= 4;
            boolClear=TRUE;
            continue;
        }

        if (strstr(argv[i],"/o")) {
            char  c;

            sscanf(argv[i]," /o:%c",&c);
            switch (c) {
            case 'c':
                enumOutput = eCon;
                break;

            case 'd':
                enumOutput = eDbg;
                break;

            default:
                break;
            }
        }
    }

    //
    // Default to local computer if no name supplied.
    //
    if (!strlen(szComputerName)) {
        dwBufferSize = sizeof(szComputerName);
        GetComputerName(szComputerName,&dwBufferSize);
    }

    if (!strlen(szRemoteComputer)) {
        dwBufferSize = sizeof(szRemoteComputer);
        GetComputerName(szRemoteComputer,&dwBufferSize);
    }


    printf("Log Type: %s\n", szLogType);
    printf("Computer: %s\n", szRemoteComputer);
    printf("MaxRecordsDisplayed: %d\n", NumRecordsDisplayed);


    pvEventBuffer = VirtualAlloc(NULL, SIZE_EVENT_BUFFER, MEM_COMMIT, PAGE_READWRITE);

    if (!pvEventBuffer) {
        sprintf(sp,"EVENTDMP: Unable to allocate sufficient memory -> Error: %lu\n", GetLastError());
        SplitPrint();
        exit(1);
    }

    i = 0;
    InitializeDatabase();

    if (!(hEventLog = OpenEventLog(szRemoteComputer, szLogType))) {
        sprintf(sp,"EVENTDMP: Could not open event log -> Error: %lu\n", GetLastError());
        SplitPrint();
        exit(1);
    }

    if (!GetNumberOfEventLogRecords(hEventLog, &dwNumOfEvents)) {
        sprintf(sp,"EVENTDMP: Could not get number of records -> Error: %lu\n", GetLastError());
        SplitPrint();
    }

    if (dwNumOfEvents == 0) {
        sprintf(sp,"EVENTDMP: no event log entries found.\n");
        SplitPrint();
        return 1;
    }

    sprintf(sp,"EVENTDMP: Attempting to read %d event log entries...\n", dwNumOfEvents);
    SplitPrint();

    LoopCount = 0;
    while (i < dwNumOfEvents) {
        if (!ReadEventLog(hEventLog,
                          EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                          1,
                          pvEventBuffer,
                          SIZE_EVENT_BUFFER,
                          &dwNumRead,
                          &dwNumRequired)) {
            sprintf(sp, "EVENTDMP: Unable to read event log -> Error: %lu\n", GetLastError());
            SplitPrint();
            sprintf(sp, "NumRead = %d   NumRequired = %d\n", dwNumRead, dwNumRequired);
            SplitPrint();
            if (++LoopCount > 50) goto SCAN_DONE;
            continue;
        }

        pelrCurrEvent = (PEVENTLOGRECORD) pvEventBuffer;

        while ((char *)pelrCurrEvent < (char *)pvEventBuffer+dwNumRead) {

            if (i < NumRecordsDisplayed) {
                PrintEventLogRecord( pelrCurrEvent );
            } else {
                goto SCAN_DONE;
            }

#if 0
// skip this stuff for now since it doesn't work for remote access anyway.

            if ((pelrCurrEvent->EventType &
                 (EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE)) != 0) {

                if (!(Match = SearchDatabase(pelrCurrEvent))) {
                    if (!(Match = AddToDatabase(pelrCurrEvent))) {
                        sprintf(sp,"EVENTDMP: Database is full.  Unable to add unique Event ID.");
                        SplitPrint();
                    }
                } else {
                    if (!(Match = UpdateDatabase(pelrCurrEvent, Match))) {
                        //sprintf(sp,"EVENTDMP: Match error in Database management code");
                        //SplitPrint();
                    }
                }
            }
#endif
            pelrCurrEvent = (PEVENTLOGRECORD) ((char*) pelrCurrEvent + pelrCurrEvent->Length);
            i++;
        }
    }

    DumpDatabase();
    CleanupDatabase();

SCAN_DONE:

    if (boolClear && !(dwIteration % dwClearInterval)) {
        SYSTEMTIME stCurrentTime;
        char       szBackup[128];

        sprintf(sp,"EVENTDMP: Attempting to clear event log...\n");
        SplitPrint();
        GetLocalTime(&stCurrentTime);
        if (boolBackup) {
            sprintf(szBackup,"%s%s%c%02d%02d.evt",szBackupStub,strlen(szBackupStub)?"\\":"",szComputerName[0],
                    stCurrentTime.wMonth,stCurrentTime.wDay);
        }
        if (!ClearEventLog(hEventLog,szBackup)) {
            sprintf(sp,"EVENTDMP: Unable to clear event log...ERROR: %d\n", GetLastError());
            SplitPrint();
        } else {
            sprintf(sp,"EVENTDMP: Event log cleared...backup file is %s\n", szBackup);
            SplitPrint();
            dwIteration++;
        }
    }


    CloseEventLog(hEventLog);
    if (hRegistry != 0) {
        RegCloseKey(hRegistry);
    }

    free(pvEventBuffer);
    return(0);
}


void InitializeDatabase(void)

{
    DWORD i=0;

    for (;i<MAX_DB_EINTRIES;i++) {
        Database[i]=NULL;
    }

    return;
}


PDBENTRY SearchDatabase(PEVENTLOGRECORD pelrEvent)

{
    DWORD   i=0, j=0;
    char   *szString = (char*)pelrEvent + pelrEvent->StringOffset;


    for (;i<MAX_DB_EINTRIES && Database[i];i++) {
        if (pelrEvent->EventID==Database[i]->dwID) {
            for (;j<pelrEvent->NumStrings && !strcmp(szString,Database[i]->szStrings[j]); j++, szString+=strlen(szString)+1);
        }
        if (j==pelrEvent->NumStrings) {
            break;
        }
    }


    return(Database[i]);
}


PDBENTRY AddToDatabase(
    PEVENTLOGRECORD pelrEvent
)
{
    DWORD      i=0, j=0, dwBuffer=128, dwRegType;
    char      *szString = (char*)pelrEvent + pelrEvent->StringOffset;
    HKEY       hkServiceKey;
    char       szKeyName[128], szMessageFile[128], *szDLLName, szDLLFullPath[128], *szParamStrings[MAX_SUB_STRINGS];
    HINSTANCE  hMessageFile;

    for (;i<MAX_DB_EINTRIES && Database[i];i++);

    if (i==MAX_DB_EINTRIES) {
        return(NULL);
    }

    Database[i] = malloc(sizeof(DBENTRY));

    Database[i]->dwID         = pelrEvent->EventID;
    Database[i]->dwTimeFirst  = pelrEvent->TimeGenerated;
    Database[i]->dwTimeLast   = pelrEvent->TimeGenerated;
    Database[i]->dwNumStrings = pelrEvent->NumStrings;
    strncpy(Database[i]->szSource,(char*)pelrEvent+sizeof(EVENTLOGRECORD),64);
    for (;j<Database[i]->dwNumStrings;j++) {
        strncpy(Database[i]->szStrings[j],szString,MAX_SUB_STR_LEN);
        szString+=strlen(szString)+1;
    }
    Database[i]->dwCount       = 1;

    if (hRegistry == 0) {
        hRegistry = HKEY_LOCAL_MACHINE;
        if (bRemote) {
            if (!RegConnectRegistry(szRemoteComputer, HKEY_LOCAL_MACHINE, &hRegistry)) {
                //sprintf(sp,"EVENTDMP: Unable to open registry on remote computer %s ...ERROR: %d\n",
                //        szRemoteComputer, GetLastError());
                //SplitPrint();
            }
        }
    }

    sprintf(szKeyName,"System\\CurrentControlSet\\Services\\EventLog\\System\\%s",Database[i]->szSource);
    if (RegOpenKeyEx(hRegistry,szKeyName,0,KEY_READ,&hkServiceKey)) {
        //sprintf(sp,"EVENTDMP: Unable to open EventLog service key on source: %s...\n",Database[i]->szSource);
        //SplitPrint();
        //sprintf(sp,"          ...Extended event description unavailable.");
        //SplitPrint();
    } else {
        if (RegQueryValueEx(hkServiceKey,"EventMessageFile", NULL, &dwRegType, szMessageFile, &dwBuffer)) {
            //sprintf(sp,"EVENTDMP: Unable to get message file value from registry on source: %s...\n",Database[i]->szSource);
            //SplitPrint();
            //sprintf(sp,"          ...Extended event description unavailable.");
            //SplitPrint();
        } else {
            szDLLName = strtok(szMessageFile,";\0");
            for (j=0;j<Database[i]->dwNumStrings;j++) {
                szParamStrings[j]=(char *) Database[i]->szStrings[j];
            }

            while (szDLLName) {
                ExpandEnvironmentStrings(szDLLName, szDLLFullPath, 128);
                if (!(hMessageFile = LoadLibrary(szDLLFullPath))) {
                    sprintf(sp,"EVENTDMP: Unable to load message file %s...\n",szDLLName);
                    SplitPrint();
                } else {
#pragma warning( disable : 4090)

                    if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      (LPCVOID)hMessageFile,
                                      Database[i]->dwID,
                                      0,
                                      Database[i]->szDescription,
                                      MAX_DESC_LEN,
                                      szParamStrings)) {
                        break;
                    }
#pragma warning( default : 4090 )
                }
                FreeLibrary(hMessageFile);
                szDLLName = strtok(NULL,";\0");
            }
            if (hMessageFile)
                FreeLibrary(hMessageFile);
        }
    }
    return(Database[i]);
}


PDBENTRY UpdateDatabase(PEVENTLOGRECORD pelrEvent, PDBENTRY pdbEntry)

{
    if (pdbEntry->dwID!=pelrEvent->EventID)
        return(NULL);

    pdbEntry->dwCount++;
    if (pelrEvent->TimeGenerated < pdbEntry->dwTimeFirst) {
        pdbEntry->dwTimeFirst = pelrEvent->TimeGenerated;
    }
    if (pelrEvent->TimeGenerated > pdbEntry->dwTimeLast) {
        pdbEntry->dwTimeLast = pelrEvent->TimeGenerated;
    }

    return(pdbEntry);
}

void DumpDatabase(void)

{
    DWORD i=0;

    return;  // Turn this off for now.

    if (Database[i]) {
        sprintf(sp,"\n\n\nEVENTDMP:\n");
        SplitPrint();
        sprintf(sp,"    Red Event Statistics :\n");
        SplitPrint();
        while (Database[i]) {
            DWORD dwSecFirst  = Database[i]->dwTimeFirst  % 60;
            DWORD dwSecLast   = Database[i]->dwTimeLast   % 60;
            DWORD dwMinFirst  = (Database[i]->dwTimeFirst % 3600)/60;
            DWORD dwMinLast   = (Database[i]->dwTimeLast  % 3600)/60;
            DWORD dwHourFirst = (Database[i]->dwTimeFirst % 86400)/3600;
            DWORD dwHourLast  = (Database[i]->dwTimeLast  % 86400)/3600;
            char  szFirstTime[32];
            char  szLastTime[32];

            sprintf(szFirstTime,"%2d:%02d:%02d",dwHourFirst,dwMinFirst,dwSecFirst);
            sprintf(szLastTime ,"%2d:%02d:%02d",dwHourLast ,dwMinLast ,dwSecLast );

            sprintf(sp,"      %2d.  EVENT SOURCE, ID       : %s, %d\n",i+1,Database[i]->szSource, Database[i]->dwID & 0xffff);
            SplitPrint();
            sprintf(sp,"           DESCRIPTION            : %s",Database[i]->szDescription);
            SplitPrint();
            sprintf(sp,"           OCCURENCES(FIRST/LAST) : %d (%s/%s)\n\n",Database[i]->dwCount,szFirstTime,szLastTime);
            SplitPrint();
            i++;
        }
    }
    return;
}


void PrintEventLogRecord(
    PEVENTLOGRECORD pelrEvent
)
{
    DWORD       j, EvId;
    char       *szString;
    char        szSource[64];
    SYSTEMTIME  LocalTime;
    DWORD       EvType;

    strncpy(szSource, (char*)pelrEvent+sizeof(EVENTLOGRECORD), sizeof(szSource));

    EventLogTimeToLocalTime (pelrEvent->TimeWritten, &LocalTime);

    if (bFirst) {
        printf("Fields are EVENT SOURCE, TIME, TYPE, ID, Tag \n");
        bFirst = FALSE;
    }

    printf("%6d : %-14s ", pelrEvent->RecordNumber, szSource);

    FormatTime (&LocalTime);
    FormatDate (&LocalTime);

    EvType = (DWORD) pelrEvent->EventType;
    if        (EvType == EVENTLOG_SUCCESS)         {szString = "Success";
    } else if (EvType & EVENTLOG_ERROR_TYPE)       {szString = "Error";
    } else if (EvType & EVENTLOG_WARNING_TYPE)     {szString = "Warn";
    } else if (EvType & EVENTLOG_INFORMATION_TYPE) {szString = "Info";
    } else if (EvType & EVENTLOG_AUDIT_SUCCESS)    {szString = "AudSuccess";
    } else if (EvType & EVENTLOG_AUDIT_FAILURE)    {szString = "AudFail";
    }

    printf("%11s ", szString);


    EvId = pelrEvent->EventID & 0xffff;

    //
    // Decode event ID based on Event log.
    // ntfrs, System, Application, Security, DNS, DS
    //

    if (_stricmp("Directory Service", szLogType) == 0) {
        if ((_stricmp("esent", szSource) == 0)) {
            printf("%8d  %s\n", EvId, JetIdToTag(EvId));
        } else if ((_stricmp("NTDS ISAM", szSource) == 0)) {
            printf("%8d  %s\n", EvId, JetIdToTag(EvId));
        } else {
            printf("%8d  %s\n", EvId, DirSvcEventIdToTag(EvId));
        }


    } else if (_stricmp("DNS Server", szLogType) == 0) {
        printf("%8d  %s\n", EvId, GenIdToTag(EvId, DNSSvcEvents));

    } else if (_stricmp("Application", szLogType) == 0) {
        if ((_stricmp("esent", szSource) == 0)) {
            printf("%8d  %s\n", EvId, JetIdToTag(EvId));
        } else
        if ((_stricmp("SceCli", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, SecPolicyEngine));
        } else {
            printf("%8d\n", EvId);
        }


    } else if (_stricmp("Security", szLogType) == 0) {
        printf("%8d\n", EvId);

    } else if (_stricmp("System", szLogType) == 0) {

        if ((_stricmp("Disk", szSource) == 0)     ||
            (_stricmp("scsiport", szSource) == 0) ||
            (_stricmp("ftdisk", szSource) == 0)) {
            printf("%8d  %s\n", EvId, SystemIoEventIdToTag(EvId));
        } else

        if ((_stricmp("netlogon", szSource) == 0)) {
            printf("%8d  %s\n", EvId, NetLogonIdToTag(EvId));
        } else

        if ((_stricmp("print", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, PrinterEvents));
        } else

        if ((_stricmp("Windows File Protection", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, WindowsFileProtEvents));
        } else

        if ((_stricmp("dmio", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, DMIOEvents));
        } else

        if ((_stricmp("sam", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, SAMEvents));
        } else

        if ((_stricmp("kdc", szSource) == 0)) {
            printf("%8d  %s\n", EvId, KDCIdToTag(EvId));
        } else

        if ((_stricmp("w32time", szSource) == 0)) {
            printf("%8d  %s\n", EvId, TimeservIdToTag(EvId));
        } else

        if ((_stricmp("dhcp", szSource) == 0)     ||
            (_stricmp("DhcpServer", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, DHCPEvents));
        } else

        if ((_stricmp("rdr", szSource) == 0)      ||
            (_stricmp("NDIS", szSource) == 0)     ||
            (_stricmp("TrkSvr", szSource) == 0)     ||
            (_stricmp("tcpip", szSource) == 0)    ||
            (_stricmp("rdbss", szSource) == 0)    ||
            (_stricmp("mrxsmb", szSource) == 0)   ||
            (_stricmp("srv", szSource) == 0)      ||
            (_stricmp("Server", szSource) == 0)   ||
            (_stricmp("ipsec", szSource) == 0)    ||
            (_stricmp("EventLog", szSource) == 0) ||
            (_stricmp("DCOM", szSource) == 0)     ||
            (_stricmp("Service Control Manager", szSource) == 0)     ||
            (_stricmp("dfs", szSource) == 0)) {
            printf("%8d  %s\n", EvId, GenIdToTag(EvId, NetEvents));
        } else {
            printf("%8d\n", EvId);
        }

    } else if (_stricmp("ntfrs", szLogType) == 0) {
        if (strcmp("NtFrs", szSource) == 0) {
            printf("%8d  %s\n", EvId, FrsEventIdToTag(EvId));
        } else {
            printf("%8d\n", EvId);
        }
    }


    if (pelrEvent->NumStrings > 0) {

        printf("STRINGS: ");
        szString = (char*)pelrEvent + pelrEvent->StringOffset;

        for (j=0; j<pelrEvent->NumStrings; j++) {
            if (j > 0) {printf(" | ");}
            printf("%s", szString);
            szString += strlen(szString)+1;
        }
        printf("\n");
    }
}




void CleanupDatabase(void)

{
    DWORD i=0;

    for (;i<MAX_DB_EINTRIES && Database[i];i++)
        free(Database[i]);

    return;
}

void Usage(void)

{
    printf("USAGE:\n");
    printf("    EventDmp [options]\n");
    printf("       /r[:machine-name] - If included, this indicates the remote machine whose eventlog\n");
    printf("                           is to be read.  The machine name should be in UNC format, i.e. \\\\G24.\n\n");
    printf("       /l:logname        - ntfrs, System, Application, Security, DNS, DS\n\n");
    printf("       /n:nnnn           - number of event log records to display (default: 200)\n");
    printf("       /b[:pathname]     - Backup eventlog before clearing.  If <path> is included then the\n");
    printf("                           log will be backed up to the indicated path.  Otherwise, the backup\n");
    printf("                           will reside in the current directory.  Backup files take the form\n");
    printf("                           <[First letter of machine name][2 digit month][2 digit day][0-9].evt>.\n");
    printf("                           Backup files are not created by default.\n\n");
    printf("       /c[:#]            - Enables clearing of the log.  If # is included, then the log is cleared\n");
    printf("                           every # hours.  The default value is 24 hours.  Log clearing is disabled\n");
    printf("                           by default.\n\n");
//    printf("       /f:filename       - Specifies a filter file. {This option is currently invalid}\n\n");
//    printf("       /d:filename       - Specifies a dump format file. {This option is currently invalid}\n\n");
//    printf("       /o:{c,d,b}        - Specifies output destination.  The valid options are: \n");
//    printf("                             c = application console\n");
//    printf("                             d = debugger\n");
//    printf("                             b = both\n");
//    printf("                           Default condition is console\n");
    printf("       /?, -?, /h, -h    - This message.");

    exit(0);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\fetch.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    fetch.c

Abstract:
    Staging File Fetcher Command Server.

Author:
    Billy J. Fuller 05-Jun-1997

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#undef DEBSUB
#define DEBSUB  "FETCH:"

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>
// #include <md5.h>

//
// Retry times
//
// NOT TOO LONG; we wouldn't want the comm timeout to hit on our
// downstream partner waiting for the fetch to succeed.
//
// Our downstream partner waits FETCHCS_RETRY_WAIT before retrying.
//
#define FETCHCS_RETRY_MIN   ( 1 * 1000)  //  1 second
#define FETCHCS_RETRY_MAX   (10 * 1000)  // 10 seconds
#define FETCHCS_RETRY_WAIT  ( 5 * 1000)  //  5 seconds

//
// Maximume transfer block size in bytes
//
#define FETCHCS_MAX_BLOCK_SIZE    (64 * 1024)

//
// Struct for the Staging File Fetcher Command Server
//      Contains info about the queues and the threads
//
COMMAND_SERVER FetchCs;
ULONG  MaxFetchCsThreads;

//
// Retry fetch after N fetches and reset N to N + 1
//
#if     DBG

    #define PULL_FETCH_RETRY_TRIGGER(_Coc_, _WStatus_, _Flags_)                \
{                                                                              \
    if (DebugInfo.FetchRetryTrigger && --DebugInfo.FetchRetryTrigger <= 0) {   \
        if (WIN_SUCCESS(_WStatus_)) {                                          \
            StageRelease(&_Coc_->ChangeOrderGuid, _Coc_->FileName, _Flags_, NULL, NULL, NULL); \
            _WStatus_ = ERROR_RETRY;                                           \
        }                                                                      \
        DebugInfo.FetchRetryReset += DebugInfo.FetchRetryInc;                  \
        DebugInfo.FetchRetryTrigger = DebugInfo.FetchRetryReset;               \
        DPRINT2(0, "++ FETCH RETRY TRIGGER FIRED on %ws; reset to %d\n",          \
                _Coc_->FileName, DebugInfo.FetchRetryTrigger);                 \
    }                                                                          \
}


    #define CHECK_FETCH_RETRY_TRIGGER(_Always_)   \
{                                                 \
    if (DebugInfo.FetchRetryReset && !_Always_) { \
        return FALSE;                             \
    }                                             \
}

#else   DBG
    #define PULL_FETCH_RETRY_TRIGGER(_WStatus_)
    #define CHECK_FETCH_RETRY_TRIGGER()
#endif  DBG




DWORD
StuGenerateStage(
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PCHANGE_ORDER_ENTRY      Coe,
    IN BOOL                     FromPreExisting,
    IN MD5_CTX                  *Md5,
    PULONGLONG                  GeneratedSize,
    OUT GUID                    *CompressionFormatUsed
    );

DWORD
StuGenerateDecompressedStage(
    IN PWCHAR   StageDir,
    IN GUID     *CoGuid,
    IN GUID     *CompressionFormatUsed
    );


BOOL
FetchCsDelCsSubmit(
    IN PCOMMAND_PACKET  Cmd,
    IN BOOL             Always
    )
/*++
Routine Description:
    Set the timer and kick off a delayed staging file command

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FetchCsDelCsSubmit:"
    //
    // Don't bother if the fetch retry trigger is set (error injection)
    // MAY RETURN!!!
    //
    CHECK_FETCH_RETRY_TRIGGER(Always);

    //
    // Extend the retry time (but not too long)
    //
    RsTimeout(Cmd) <<= 1;
    if (RsTimeout(Cmd) > FETCHCS_RETRY_MAX) {
        if (Always) {
            RsTimeout(Cmd) = FETCHCS_RETRY_MAX;
        }
        else {
            return (FALSE);
        }
    }
    //
    // or too short
    //
    if (RsTimeout(Cmd) < FETCHCS_RETRY_MIN) {
        RsTimeout(Cmd) = FETCHCS_RETRY_MIN;
    }
    //
    // This command will come back to us in a bit
    //
    FrsDelCsSubmitSubmit(&FetchCs, Cmd, RsTimeout(Cmd));
    return (TRUE);
}


VOID
FetchCsRetryFetch(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our upstream partner has requested that we retry the
    fetch at a later time because the staging file wasn't present
    and couldn't be regenerated because of sharing problems or
    lack of disk space.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FetchCsRetryFetch:"
    DWORD       WStatus;
    DWORD       Flags;
    GUID        *CoGuid;
    PWCHAR      FileName;
    PCHANGE_ORDER_COMMAND   Coc = RsCoc(Cmd);

    //
    // Already waited for a bit; retry
    //
    if (RsTimeout(Cmd)) {
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Retry Initiated");
        RcsSubmitTransferToRcs(Cmd, CMD_RECEIVED_STAGE);
        return;
    }


    CoGuid = &Coc->ChangeOrderGuid;
    FileName = Coc->FileName;

    //
    // Free the data block
    //
    RsBlock(Cmd) = FrsFree(RsBlock(Cmd));
    RsBlockSize(Cmd) = QUADZERO;

    //
    // Delete the current staging file if we are starting over
    //
    if (RsFileOffset(Cmd).QuadPart == QUADZERO) {
        //
        // Acquire access to the staging file
        //
        Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;
        if (CoCmdIsDirectory(Coc)) {
            SetFlag(Flags, STAGE_FLAG_FORCERESERVE);
        }

        WStatus = StageAcquire(CoGuid, FileName, Coc->FileSize, &Flags, 0, NULL);

        if (WIN_SUCCESS(WStatus)) {
            StageDeleteFile(Coc, NULL, FALSE);
            StageRelease(CoGuid, FileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
        }
    }

    RsTimeout(Cmd) = FETCHCS_RETRY_WAIT;
    FrsDelCsSubmitSubmit(&FetchCs, Cmd, RsTimeout(Cmd));
}


VOID
FetchCsAbortFetch(
    IN PCOMMAND_PACKET  Cmd,
    IN DWORD WStatus
    )
/*++
Routine Description:
    Out inbound partner has requested that we abort the fetch.

    The inbound partner sends this response when it is unable to generate
    or deliver the staging file due to a non-recoverable error.  Currently
    this means any error NOT in the following list: (WIN_RETRY_FETCH() Macro)

        ERROR_SHARING_VIOLATION
        ERROR_DISK_FULL
        ERROR_HANDLE_DISK_FULL
        ERROR_DIR_NOT_EMPTY
        ERROR_OPLOCK_NOT_GRANTED
        ERROR_RETRY

    Typically we get an abort if the upstream partner has deleted the underlying
    file and the staging file associated with this change order has been
    cleaned up (e.g. the upstream partner has been stopped and restarted).

Arguments:
    Cmd
    WStatus - Win32 status code.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FetchCsAbortFetch:"

    SET_COE_FLAG(RsCoe(Cmd), COE_FLAG_STAGE_ABORTED | COE_FLAG_STAGE_DELETED);

    ChgOrdInboundRetired(RsCoe(Cmd));

    RsCoe(Cmd) = NULL;
    FrsCompleteCommand(Cmd, WStatus);
}


VOID
FetchCsReceivingStage(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Put this data into the staging file

    TODO -- If the MD5 checksum was updated by the upstream member as a part of
    demand fetch stage file generation (see FetchCsSendStage()) then we need to
    propagate RsMd5Digest(Cmd) into the change order command so it can be
    updated in the IDTable when this Co retires.  Need to decide the correct
    conditions under which this should happen.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FetchCsReceivingStage:"
    DWORD   WStatus;
    ULONG   Flags;
    PWCHAR  StagePath   = NULL;
    PWCHAR  FinalPath   = NULL;
    HANDLE  Handle      = INVALID_HANDLE_VALUE;
    WIN32_FILE_ATTRIBUTE_DATA   Attrs;
    STAGE_HEADER Header;
    PREPLICA Replica    = NULL;

    //
    // If this Cmd was not in response to a request that we made or
    // it was not for the correct offset that we were expecting then
    // just ignore it.
    //

    if (RsCoe(Cmd) == NULL) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    CHANGE_ORDER_TRACE(3, RsCoe(Cmd), "Fetch Receiving");


    DPRINT1(4, "++ RsFileSize(Cmd).QuadPart:   %08x %08x\n",
            PRINTQUAD(RsFileSize(Cmd).QuadPart));

    DPRINT1(4, "++ RsFileOffset(Cmd).QuadPart: %08x %08x\n",
            PRINTQUAD(RsFileOffset(Cmd).QuadPart));

    DPRINT1(4, "++ RsBlockSize(Cmd)          : %08x %08x\n",
            PRINTQUAD(RsBlockSize(Cmd)));
    //
    // Acquire access to the staging file
    //
    Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;
    if (CoCmdIsDirectory(RsCoc(Cmd))) {
        SetFlag(Flags, STAGE_FLAG_FORCERESERVE);
    }
    WStatus = StageAcquire(&RsCoc(Cmd)->ChangeOrderGuid,
                           RsCoc(Cmd)->FileName,
                           RsCoc(Cmd)->FileSize,
                           &Flags,
                           RsReplica(Cmd)->ReplicaNumber,
                           NULL);
    //
    // Retriable problem; Send the CO through retry.
    //
    if (WIN_RETRY_FETCH(WStatus)) {
        CHANGE_ORDER_TRACE(3, RsCoe(Cmd), "Can't Acquire Stage Retry Co");
        ChgOrdInboundRetry(RsCoe(Cmd), IBCO_FETCH_RETRY);
        RsCoe(Cmd) = NULL;
        FrsCompleteCommand(Cmd, WStatus);
        return;
/*
        CHANGE_ORDER_TRACEW(3, RsCoe(Cmd), "Fetch Receiving Retry", WStatus);
        FrsFetchCsSubmitTransfer(Cmd, CMD_RETRY_FETCH);
        return;
*/
    }
    //
    // Unrecoverable error; abort (see FetchCsAbortFetch() for description.)
    //
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACEW(0, RsCoe(Cmd), "fetch Receiving Abort", WStatus);
        FetchCsAbortFetch(Cmd, WStatus);
        return;
    }

    if (RsFileOffset(Cmd).QuadPart == QUADZERO) {
        //
        // This is the first block of file data. It will have the stage header.
        // Read the header and get the compression guid for this stage file from
        // it. Block size is 64K max. 1st block will atleast have the complete header.
        // Check it just to make sure.
        //
        if (RsBlockSize(Cmd) >= sizeof(STAGE_HEADER)) {
            ZeroMemory(&Header, sizeof(STAGE_HEADER));
            CopyMemory(&Header, RsBlock(Cmd), sizeof(STAGE_HEADER));
        }
        if (!IS_GUID_ZERO(&Header.CompressionGuid)) {
            SET_COC_FLAG(RsCoc(Cmd), CO_FLAG_COMPRESSED_STAGE);
        } else {
            CLEAR_COC_FLAG(RsCoc(Cmd), CO_FLAG_COMPRESSED_STAGE);
        }
    }

    //
    // Get a handle to the staging file. Use a different prefix depending
    // on whether the stage file being sent is compressed or uncompressed.
    //
    if (COC_FLAG_ON(RsCoc(Cmd), CO_FLAG_COMPRESSED_STAGE)) {
        StagePath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_GENERATE_COMPRESSED_PREFIX);
        SetFlag(Flags, STAGE_FLAG_COMPRESSED);
    } else {
        StagePath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_GENERATE_PREFIX);
    }

    if ((Flags & STAGE_FLAG_DATA_PRESENT) ||
        (RsFileOffset(Cmd).QuadPart >= RsFileSize(Cmd).QuadPart)) {
        //
        // Data has arrived.  Go complete the stage file final rename.
        //
        goto RESTART;
    }

    if (Flags & STAGE_FLAG_CREATING) {
        //
        // Make sure to truncate the staging file when our upstream
        // partner is sending (or resending) the first block of the
        // staging file.
        //
        // Without the truncation, BackupWrite() can AV if NtFrs
        // passes in garbage at the end of a too-large
        // staging file.  A staging file may be too-large if the
        // preexisting file used to generate the local staging
        // file is smaller than the version of the same file our
        // partner wants to send.
        //
        // Alternatively, I could have truncated the staging file
        // after receiving the last block but this code change is less
        // risk and is just as effective.
        //
        if (RsFileOffset(Cmd).QuadPart == QUADZERO) {
            ClearFlag(Flags, STAGE_FLAG_CREATING | STAGE_FLAG_CREATED | STAGE_FLAG_DATA_PRESENT);
        } else {
            //
            // See if the staging file exists. If not, set the flags
            // to create it.
            //

            StuOpenFile(StagePath, GENERIC_READ | GENERIC_WRITE, &Handle);

            if (!HANDLE_IS_VALID(Handle)) {
                ClearFlag(Flags, STAGE_FLAG_CREATING | STAGE_FLAG_CREATED | STAGE_FLAG_DATA_PRESENT);
            }
        }
    }

    if (!(Flags & STAGE_FLAG_CREATING)) {
        CHANGE_ORDER_TRACE(3, RsCoe(Cmd), "Fetch Receiving Generate Stage");

        //
        // No longer have a staging file; digest invalid
        //
        RsMd5Digest(Cmd) = FrsFree(RsMd5Digest(Cmd));

        //
        // Create and allocate disk space
        //
        WStatus = StuCreateFile(StagePath, &Handle);
        if (!HANDLE_IS_VALID(Handle) || !WIN_SUCCESS(WStatus)) {
            goto ERROUT;
        }

        WStatus = FrsSetFilePointer(StagePath, Handle, RsFileSize(Cmd).HighPart,
                                                       RsFileSize(Cmd).LowPart);
        CLEANUP1_WS(0, "++ SetFilePointer failed on %ws;", StagePath, WStatus, ERROUT);

        WStatus = FrsSetEndOfFile(StagePath, Handle);

        CLEANUP1_WS(0, "++ SetEndOfFile failed on %ws;", StagePath, WStatus, ERROUT);

        //
        // File was deleted during the fetch; start over
        //
        if (RsFileOffset(Cmd).QuadPart != QUADZERO) {
            CHANGE_ORDER_TRACE(3, RsCoe(Cmd), "Fetch Receiving Restart");
            RsFileOffset(Cmd).QuadPart = QUADZERO;
            RsBlock(Cmd) = FrsFree(RsBlock(Cmd));
            RsBlockSize(Cmd) = QUADZERO;
            goto RESTART;
        }
    }
    //
    // Seek to the offset for this block
    //
    WStatus = FrsSetFilePointer(StagePath, Handle, RsFileOffset(Cmd).HighPart,
                                                   RsFileOffset(Cmd).LowPart);
    CLEANUP1_WS(0, "++ SetFilePointer failed on %ws;", StagePath, WStatus, ERROUT);

    //
    // write the file and update the offset for the next block
    //
    WStatus = StuWriteFile(StagePath, Handle, RsBlock(Cmd), (ULONG)RsBlockSize(Cmd));
    CLEANUP1_WS(0, "++ WriteFile failed on %ws;", StagePath, WStatus, ERROUT);

    //
    // Increment the counter Bytes of staging Fetched
    //
    Replica = RsCoe(Cmd)->NewReplica;

    PM_INC_CTR_REPSET(Replica, SFFetchedB, RsBlockSize(Cmd));


RESTART:

    FrsFlushFile(StagePath, Handle);
    FRS_CLOSE(Handle);

    if ((RsFileOffset(Cmd).QuadPart + RsBlockSize(Cmd)) >= RsFileSize(Cmd).QuadPart) {

        //
        // All the stage file data is here.  Do the final rename.
        //
        SetFlag(Flags, STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_RERESERVE);

        if (COC_FLAG_ON(RsCoc(Cmd), CO_FLAG_COMPRESSED_STAGE)) {
            FinalPath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_FINAL_COMPRESSED_PREFIX);
        } else {
            FinalPath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_FINAL_PREFIX);
        }
        if (!MoveFileEx(StagePath,
                        FinalPath,
                        MOVEFILE_WRITE_THROUGH | MOVEFILE_REPLACE_EXISTING)) {
            WStatus = GetLastError();
        } else {
            WStatus = ERROR_SUCCESS;
        }

        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_TRACEW(3, RsCoe(Cmd), "Fetch Receiving Rename fail", WStatus);
            DPRINT2_WS(0, "++ Can't move fetched %ws to %ws;",
                       StagePath, FinalPath, WStatus);
            FinalPath = FrsFree(FinalPath);
            goto ERROUT;
        }

        //
        // Stage file with final name is in place and ready to install
        // and/or deliver to our downstream partners.
        //
        SetFlag(Flags, STAGE_FLAG_CREATED | STAGE_FLAG_INSTALLING);
    }

    //
    // The last block isn't officially "written" into the staging file
    // until the above rename finishes. That is because the write of
    // the last byte of the staging file signifies "all done" to the
    // replica command server (replica.c).
    //
    RsFileOffset(Cmd).QuadPart += RsBlockSize(Cmd);

    //
    // This block has been successfully transferred; free the buffer now
    //
    FrsFree(StagePath);
    FrsFree(FinalPath);
    RsBlock(Cmd) = FrsFree(RsBlock(Cmd));
    RsBlockSize(Cmd) = QUADZERO;

    //
    // Release staging resources
    //
    SetFlag(Flags, STAGE_FLAG_CREATING);
    if (!IS_GUID_ZERO(&Header.CompressionGuid)) {

        StageRelease(&RsCoc(Cmd)->ChangeOrderGuid,
                     RsCoc(Cmd)->FileName,
                     Flags | STAGE_FLAG_COMPRESSED |
                     STAGE_FLAG_COMPRESSION_FORMAT_KNOWN,
                     &(RsFileOffset(Cmd).QuadPart),
                     NULL,
                     &Header.CompressionGuid);
    } else {

        StageRelease(&RsCoc(Cmd)->ChangeOrderGuid,
                     RsCoc(Cmd)->FileName,
                     Flags,
                     &(RsFileOffset(Cmd).QuadPart),
                     NULL,
                     NULL);
    }

    RcsSubmitTransferToRcs(Cmd, CMD_RECEIVED_STAGE);

    return;

ERROUT:
    //
    // Discard local state
    //
    FRS_CLOSE(Handle);

    FrsFree(StagePath);
    if (!IS_GUID_ZERO(&Header.CompressionGuid)) {

        StageRelease(&RsCoc(Cmd)->ChangeOrderGuid,
                     RsCoc(Cmd)->FileName,
                     Flags | STAGE_FLAG_COMPRESSED |
                     STAGE_FLAG_COMPRESSION_FORMAT_KNOWN,
                     NULL,
                     NULL,
                     &Header.CompressionGuid);
    } else {

        StageRelease(&RsCoc(Cmd)->ChangeOrderGuid, RsCoc(Cmd)->FileName, Flags, NULL, NULL, NULL);
    }

    //
    // Pretend it is retriable
    //
    CHANGE_ORDER_TRACE(3, RsCoe(Cmd), "Fetch Receiving Retry on Error");
    FrsFetchCsSubmitTransfer(Cmd, CMD_RETRY_FETCH);
}


VOID
FetchCsSendStage(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Send the local staging file to the requesting outbound partner.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FetchCsSendStage:"

    ULONGLONG   GeneratedSize = 0;

    FILE_NETWORK_OPEN_INFORMATION   Attrs;
    PCHANGE_ORDER_COMMAND           Coc = RsPartnerCoc(Cmd);

    GUID        *CoGuid;
    PWCHAR      FileName;
    ULONG       Flags;
    DWORD       WStatus;
    DWORD       BytesRead;
    USN         Usn        = 0;
    PWCHAR      StagePath  = NULL;
    HANDLE      Handle     = INVALID_HANDLE_VALUE;
    BOOL        Md5Valid   = FALSE;
    MD5_CTX     Md5;
    GUID        CompressionFormatUsed;
    PREPLICA    Replica    = RsReplica(Cmd);
    PCXTION     OutCxtion;
    STAGE_HEADER Header;
    BOOL        DeleteStagingFile = FALSE;

    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send");

    //
    // Check Connection before anything else.  This is checked by the replica
    // command server but this command packet can hang around on the
    // FetchCs queue for a while.  During this time the connection can
    // be unjoined, moved to the deleted connection table, and recreated.
    // The recreated connection may not be fully initialized and this
    // can lead to an access violation.  And yes this did happen.
    // StuGenerateStage is an expensive call. We don't want to generate
    // the stage file and later discard it because the cxtion has unjoined.
    // 
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_FOR_FETCHCS |
                                            CHECK_CXTION_JOIN_OK     |
                                            CHECK_CXTION_OUTBOUND);

    //
    // This connection does not exist any more.
    //
    if (OutCxtion == NULL) {
        goto ERROUT_NOACQUIRE;
    }

    ZeroMemory(&CompressionFormatUsed, sizeof(GUID));

    //
    // Even if the file is 0 bytes in length, the staging file will
    // always have at least the header. There are some retry paths
    // that will incorrectly think the staging file has been fetched
    // if RsFileSize(Cmd) is 0. So make sure it isn't.
    //
    if (RsFileSize(Cmd).QuadPart == QUADZERO) {
        RsFileSize(Cmd).QuadPart = Coc->FileSize;

        if (RsFileSize(Cmd).QuadPart == QUADZERO) {
            RsFileSize(Cmd).QuadPart = sizeof(STAGE_HEADER);
        }
    }

    CoGuid = &Coc->ChangeOrderGuid;
    FileName = Coc->FileName;

    //
    // Acquire shared access to the staging file
    //
    Flags = 0;
    WStatus = StageAcquire(CoGuid, FileName, RsFileSize(Cmd).QuadPart,
                           &Flags, Replica->ReplicaNumber, &CompressionFormatUsed);

    if (!WIN_SUCCESS(WStatus) || !(Flags & STAGE_FLAG_CREATED)) {
        //
        // Acquire exclusive access to the file
        //
        if (WIN_SUCCESS(WStatus)) {
            StageRelease(CoGuid, FileName, Flags, NULL, NULL, NULL);
        }

        Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;

        if (CoCmdIsDirectory(Coc)) {
            SetFlag(Flags, STAGE_FLAG_FORCERESERVE);
        }

        WStatus = StageAcquire(CoGuid, FileName, RsFileSize(Cmd).QuadPart,
                               &Flags, Replica->ReplicaNumber, &CompressionFormatUsed);
    }
    //
    // Retry fetch when fetch retry trigger hits
    //
    PULL_FETCH_RETRY_TRIGGER(Coc, WStatus, Flags);

    //
    // Retriable problem; do so
    //
    if (WIN_RETRY_FETCH(WStatus)) {
        CHANGE_ORDER_COMMAND_TRACEW(3, Coc, "Fetch Send Retry Cmd", WStatus);

        if (FetchCsDelCsSubmit(Cmd, FALSE)) {
            return;
        }

        CHANGE_ORDER_COMMAND_TRACEW(3, Coc, "Fetch Send Retry Co", WStatus);
        RcsSubmitTransferToRcs(Cmd, CMD_SEND_RETRY_FETCH);
        return;
    }

    //
    // Unretriable problem; abort
    //
    if (!WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_COMMAND_TRACEW(3, Coc, "Fetch Send Abort", WStatus);
        RcsSubmitTransferToRcs(Cmd, CMD_SEND_ABORT_FETCH);
        return;
    }

    //
    // Create the staging file, if needed
    //
    if (!(Flags & STAGE_FLAG_CREATED)) {
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send Gen Stage");

        //
        // Make sure we start at the beginning of the staging file
        //
        RsFileOffset(Cmd).QuadPart = QUADZERO;

        //
        // Create the staging file.
        //
        if (RsMd5Digest(Cmd)) {
            //
            // The requesting downstream partner had a pre-exisitng file
            // and included an Md5 digest in the fetch request.  So calc
            // the MD5 digest as we generate the staging file.
            //
            WStatus = StuGenerateStage(Coc, NULL, FALSE, &Md5, &GeneratedSize,
                                       &CompressionFormatUsed);
            Md5Valid = TRUE;
        } else {
            WStatus = StuGenerateStage(Coc, NULL, FALSE, NULL, &GeneratedSize,
                                       &CompressionFormatUsed);
        }

        //
        // Release staging resources if error
        //
        if (!WIN_SUCCESS(WStatus)) {
            StageDeleteFile(Coc, NULL, FALSE);

            StageRelease(CoGuid, FileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
        } else {
            //
            // Increment the staging files regenerated counter
            //
            PM_INC_CTR_REPSET(Replica, SFReGenerated, 1);
        }

        //
        // Retriable problem; do so
        //
        if (WIN_RETRY_FETCH(WStatus)) {
            CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send Gen Stage Retry Cmd");
            if (FetchCsDelCsSubmit(Cmd, FALSE)) {
                return;
            }

            CHANGE_ORDER_COMMAND_TRACEW(3, Coc, "Fetch Send Gen Stage Retry Co", WStatus);
            RcsSubmitTransferToRcs(Cmd, CMD_SEND_RETRY_FETCH);
            return;
        }

        //
        // Unretriable problem; abort
        //
        if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_COMMAND_TRACEW(3, Coc, "Fetch Send Gen Stage Abort", WStatus);
            RcsSubmitTransferToRcs(Cmd, CMD_SEND_ABORT_FETCH);
            return;
        }

        if (!IS_GUID_ZERO(&CompressionFormatUsed)) {
            SetFlag(Flags, (STAGE_FLAG_DATA_PRESENT |
                            STAGE_FLAG_CREATED      | STAGE_FLAG_INSTALLING |
                            STAGE_FLAG_INSTALLED    | STAGE_FLAG_RERESERVE  |
                            STAGE_FLAG_COMPRESSED   | STAGE_FLAG_COMPRESSION_FORMAT_KNOWN));
        } else {
            SetFlag(Flags, (STAGE_FLAG_DATA_PRESENT |
                            STAGE_FLAG_CREATED      | STAGE_FLAG_INSTALLING |
                            STAGE_FLAG_INSTALLED    | STAGE_FLAG_RERESERVE));
        }
    }

    //
    // ERROUT is now valid
    //

    //
    // Open the file
    //
    if (COC_FLAG_ON(Coc, CO_FLAG_COMPRESSED_STAGE) && (Flags & STAGE_FLAG_COMPRESSED) ) {

        StagePath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_FINAL_COMPRESSED_PREFIX);

        if (!(Flags & STAGE_FLAG_COMPRESSION_FORMAT_KNOWN)) {
            //
            // Compression format is not known and should be zero. Read from stage header.
            //
            FRS_ASSERT(IS_GUID_ZERO(&CompressionFormatUsed));


            WStatus = StuOpenFile(StagePath, GENERIC_READ, &Handle);
            if (!HANDLE_IS_VALID(Handle)) {
                //
                // If the staging file is deleted by an external agent,
                // it will still be in the staging table. Jumping to
                // ERROUT_DELETE_STAGING_FILE will cause it to be 
                // unreserved. It will be regenerated on retry
                // if required.
                //
                if (WStatus == ERROR_FILE_NOT_FOUND) {
                    goto ERROUT_DELETE_STAGING_FILE;
                } else{
                    goto ERROUT;
                }
            }

            if (!StuReadBlockFile(StagePath, Handle, &Header, sizeof(STAGE_HEADER))) {
                //
                // Error reading from file. File may be corrupt.
                // Delete the staging file and unreserve the space.
                // Staging file will be regenerated on retry.
                //
                goto ERROUT_DELETE_STAGING_FILE;
            }

            COPY_GUID(&CompressionFormatUsed, &Header.CompressionGuid);
            SetFlag(Flags, STAGE_FLAG_COMPRESSED);
            SetFlag(Flags, STAGE_FLAG_COMPRESSION_FORMAT_KNOWN);
        }

        //
        // This is checked by the replica
        // command server but this command packet can hang around on the
        // FetchCs queue for a while.  During this time the connection can
        // be unjoined, moved to the deleted connection table, and recreated.
        // The recreated connection may not be fully initialized and this
        // can lead to an access violation.  And yes this did happen.
        // StuGenerateStage can take a long time so we have to make this
        // check again because the state may have changed.
        // 
        OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_FOR_FETCHCS |
                                                CHECK_CXTION_JOIN_OK     |
                                                CHECK_CXTION_OUTBOUND);
        //
        // This connection does not exist any more.
        //
        if (OutCxtion == NULL) {
            goto ERROUT;
        }

        //
        // There is a compressed staging file for this change order. Check if the
        // outbound partner understands this compression format.
        //

        if (!GTabIsEntryPresent(OutCxtion->CompressionTable, &CompressionFormatUsed, NULL)) {

            //
            // The outbound partner does not understand this compression format.
            //
            //
            // Unlock the cxtion table here so we do not hold the lock while generating
            // the staging file.
            //
            StagePath = FrsFree(StagePath);
            FRS_CLOSE(Handle);

            StagePath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_FINAL_PREFIX);

            if (!(Flags & STAGE_FLAG_DECOMPRESSED)) {
                //
                // The the file is not decompressed yet. Create decompressed staging file.
                // Acquire exclusive access to the file if we didn't get it above.
                // Case is Stage file exists as compressed so we don't get exclusive
                // access above.
                //
                if (!BooleanFlagOn(Flags, STAGE_FLAG_EXCLUSIVE)) {
                    StageRelease(CoGuid, FileName, Flags, NULL, NULL, &CompressionFormatUsed);

                    Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;

                    if (CoCmdIsDirectory(Coc)) {
                        SetFlag(Flags, STAGE_FLAG_FORCERESERVE);
                    }

                    WStatus = StageAcquire(CoGuid, FileName, RsFileSize(Cmd).QuadPart,
                                           &Flags, RsReplica(Cmd)->ReplicaNumber, NULL);
                    CLEANUP_WS(0,"Error acquiring exclusive access for creating a decompressed staging file.",
                               WStatus, ERROUT_NOACQUIRE);
                }

                CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Decompressing stage for downlevel partner");
                WStatus = StuGenerateDecompressedStage(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), &CompressionFormatUsed);
                CLEANUP_WS(0,"Error generating decompressed staging file.", WStatus, ERROUT_DELETE_STAGING_FILE);
                SetFlag(Flags, STAGE_FLAG_DECOMPRESSED);
                CLEAR_COC_FLAG(Coc, CO_FLAG_COMPRESSED_STAGE);
            }
        }
    } else {
        StagePath = StuCreStgPath(RsReplica(Cmd)->Stage, RsCoGuid(Cmd), STAGE_FINAL_PREFIX);
    }


    if (!HANDLE_IS_VALID(Handle)) {
        WStatus = StuOpenFile(StagePath, GENERIC_READ, &Handle);
    }

    if (!HANDLE_IS_VALID(Handle)) {
        //
        // If the staging file is deleted by an external agent,
        // it will still be in the staging table. Jumping to
        // ERROUT_DELETE_STAGING_FILE will cause it to be 
        // unreserved. It will be regenerated on retry
        // if required.
        //
        if (WStatus == ERROR_FILE_NOT_FOUND) {
            goto ERROUT_DELETE_STAGING_FILE;
        } else{
            goto ERROUT;
        }
    }

    if (RsFileOffset(Cmd).QuadPart == QUADZERO) {
        //
        // This is the first request for this file; Fill in the file size
        //
        if (!FrsGetFileInfoByHandle(StagePath, Handle, &Attrs)) {
            goto ERROUT;
        }
        RsFileSize(Cmd) = Attrs.EndOfFile;
    }

    if (Md5Valid) {

        if (MD5_EQUAL(Md5.digest, RsMd5Digest(Cmd))) {

            //
            // MD5 digest matches so downstream partner's file is good.
            // Set the offset to the size of the stage file so we don't send
            // any data.
            //
            RsFileOffset(Cmd).QuadPart = RsFileSize(Cmd).QuadPart;
            CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send Md5 matches, do not send");

        } else {
            CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send Md5 mismatch, send");
            //
            // Update the MD5 checksum in the cmd so we can send it downstream.
            //
            CopyMemory(RsMd5Digest(Cmd), Md5.digest, MD5DIGESTLEN);
        }
    }

    //
    // Calculate the block size of the next data chunk to deliver.
    //
    RsBlockSize(Cmd) = QUADZERO;
    if (RsFileOffset(Cmd).QuadPart < RsFileSize(Cmd).QuadPart) {
        //
        // Calc bytes left in file.
        //
        RsBlockSize(Cmd) = RsFileSize(Cmd).QuadPart - RsFileOffset(Cmd).QuadPart;

        //
        // But not more than max block size.
        //
        if (RsBlockSize(Cmd) > FETCHCS_MAX_BLOCK_SIZE) {
            RsBlockSize(Cmd) = FETCHCS_MAX_BLOCK_SIZE;
        }
    }

    //
    // If data left to deliver, allocate a buffer, seek to the block offset in
    // the file and read the data. If we fail to get the block of interest then
    // we error out by deleting the staging file.
    //
    RsBlock(Cmd) = NULL;
    if (RsBlockSize(Cmd) > QUADZERO) {
        RsBlock(Cmd) = FrsAlloc((ULONG)RsBlockSize(Cmd));

        WStatus = FrsSetFilePointer(StagePath, Handle, RsFileOffset(Cmd).HighPart,
                                                       RsFileOffset(Cmd).LowPart);
        CLEANUP1_WS(0, "++ SetFilePointer failed on %ws;", StagePath, WStatus, ERROUT_DELETE_STAGING_FILE);

        if (!StuReadBlockFile(StagePath, Handle, RsBlock(Cmd), (ULONG)RsBlockSize(Cmd))) {
            //
            // Error reading from file. File may be corrupt.
            // Delete the staging file and unreserve the space.
            // Staging file will be regenerated on retry.
            //
            goto ERROUT_DELETE_STAGING_FILE;
        }
    }

    //
    // Done, transfer to the replica set command server
    //
    FRS_CLOSE(Handle);
    FrsFree(StagePath);

    if (!IS_GUID_ZERO(&CompressionFormatUsed)) {
        StageRelease(CoGuid, FileName, Flags, &GeneratedSize, NULL, &CompressionFormatUsed);
    } else {
        StageRelease(CoGuid, FileName, Flags, &GeneratedSize, NULL, NULL);
    }

    RcsSubmitTransferToRcs(Cmd, CMD_SENDING_STAGE);

    return;

ERROUT_DELETE_STAGING_FILE:

    //
    // Delete the staging file if we reach here. If we have successfully
    // generated a staging file then we try to keep it.
    //
    DeleteStagingFile = TRUE;

ERROUT:

    //
    // Delete the staging file, if possible. Don't delete a staging
    // file that has not been installed (it cannot be regenerated!).
    //
    if (DeleteStagingFile && (Flags & STAGE_FLAG_INSTALLED)) {
        //
        // Get exclusive access
        //
        WStatus = ERROR_SUCCESS;
        if (!(Flags & STAGE_FLAG_EXCLUSIVE)) {
            StageRelease(CoGuid, FileName, Flags, &GeneratedSize, NULL, NULL);

            Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;
            if (CoCmdIsDirectory(Coc)) {
                SetFlag(Flags, STAGE_FLAG_FORCERESERVE);
            }

            WStatus = StageAcquire(CoGuid, FileName, Coc->FileSize, &Flags, RsReplica(Cmd)->ReplicaNumber, NULL);
        }
        if (WIN_SUCCESS(WStatus)) {

            //
            // Discard the current staging file
            //
            StageDeleteFile(Coc, NULL, FALSE);
            StageRelease(CoGuid, FileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);

            //
            // Make sure we start over at the beginning of the staging file
            //
            RsFileOffset(Cmd).QuadPart = QUADZERO;
        }
    } else {
        StageRelease(CoGuid, FileName, Flags, &GeneratedSize, NULL, NULL);
    }


ERROUT_NOACQUIRE:

    FRS_CLOSE(Handle);

    if (StagePath) {
        FrsFree(StagePath);
    }

    RsBlock(Cmd) = FrsFree(RsBlock(Cmd));
    RsBlockSize(Cmd) = QUADZERO;

    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send Retry on Error");

    if (FetchCsDelCsSubmit(Cmd, FALSE)) {
        return;
    }

    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Fetch Send Retry on Error");
    RcsSubmitTransferToRcs(Cmd, CMD_SEND_RETRY_FETCH);
}


DWORD
MainFetchCs(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for a thread serving the Staging area Command Server.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "MainFetchCs:"
    DWORD               WStatus = ERROR_SUCCESS;
    PCOMMAND_PACKET     Cmd;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)Arg;

    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &FetchCs);
    FrsThread->Exit = ThSupExitWithTombstone;

    //
    // Try-Finally
    //
    try {

        //
        // Capture exception.
        //
        try {

            //
            // Pull entries off the queue and process them
            //
cant_exit_yet:
            while (Cmd = FrsGetCommandServer(&FetchCs)) {

                switch (Cmd->Command) {

                case CMD_SEND_STAGE:
                    DPRINT1(5, "Fetch: command send stage %08x\n", Cmd);
                    FetchCsSendStage(Cmd);
                    break;

                case CMD_RECEIVING_STAGE:
                    DPRINT1(5, "Fetch: command receiving stage %08x\n", Cmd);
                    FetchCsReceivingStage(Cmd);
                    break;

                case CMD_RETRY_FETCH:
                    DPRINT1(5, "Fetch: command retry fetch %08x\n", Cmd);
                    FetchCsRetryFetch(Cmd);
                    break;

                case CMD_ABORT_FETCH:
                    DPRINT1(5, "Fetch: command abort fetch %08x\n", Cmd);
                    CHANGE_ORDER_TRACEW(0, RsCoe(Cmd), "Aborting fetch", ERROR_SUCCESS);
                    FetchCsAbortFetch(Cmd, ERROR_SUCCESS);
                    break;

                default:
                    DPRINT1(0, "Staging File Fetch: unknown command 0x%x\n", Cmd->Command);
                    FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
                    break;
                }
            }
            //
            // Exit
            //
            FrsExitCommandServer(&FetchCs, FrsThread);
            goto cant_exit_yet;

        //
        // Get exception status.
        //
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "MainFetchCs finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "MainFetchCs terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        }
    }

    return (WStatus);
}


VOID
FrsFetchCsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the staging file fetcher

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FetchCsInitialize:"
    //
    // Initialize the command server
    //

    CfgRegReadDWord(FKC_MAX_STAGE_FETCHCS_THREADS, NULL, 0, &MaxFetchCsThreads);

    FrsInitializeCommandServer(&FetchCs, MaxFetchCsThreads, L"FetchCs", MainFetchCs);
}





VOID
ShutDownFetchCs(
    VOID
    )
/*++
Routine Description:
    Shutdown the staging file fetcher command server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownFetchCs:"
    FrsRunDownCommandServer(&FetchCs, &FetchCs.Queue);
}





VOID
FrsFetchCsSubmitTransfer(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command
    )
/*++
Routine Description:
    Transfer a request to the staging file generator

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsFetchCsSubmitTransfer:"
    //
    // Submit a request to allocate staging area
    //
    Cmd->TargetQueue = &FetchCs.Queue;
    Cmd->Command = Command;
    RsTimeout(Cmd) = 0;
    DPRINT1(5, "Fetch: submit 0x%x\n", Cmd);
    FrsSubmitCommandServer(&FetchCs, Cmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsapi_s_stub.c ===
#include "frsapi_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\compress.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    compress.c

Abstract:

    This module implements staging support routines for FRS

Author:

    Sudarshan Chitre 26-Apr-2000

Revision History:

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>

//
// Guids for compression formats that are supported by the service.
//

extern GUID FrsGuidCompressionFormatNone;
extern GUID FrsGuidCompressionFormatLZNT1;
extern BOOL DisableCompressionStageFiles;

DWORD
FrsLZNT1CompressBuffer(
    IN  PUCHAR UnCompressedBuf,
    IN  DWORD  UnCompressedBufLen,
    OUT PUCHAR CompressedBuf,
    IN  DWORD  CompressedBufLen,
    OUT DWORD  *pCompressedSize
    )
/*++
Routine Description:
    Compression routine for default compression format.
    COMPRESSION_FORMAT_LZNT1

Arguments:
    UnCompressedBuf    : Source buffer.
    UnCompressedBufLen : Length of source buffer.
    CompressedBuf      : Resultant compressed buffer.
    CompressedBufLen   : Length of compressed buffer supplied.
    CompressedSize     : Actual size of the compressed data.

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsLZNT1CompressBuffer:"

    DWORD       WStatus                 = ERROR_SUCCESS;
    DWORD       NtStatus;
    PVOID       WorkSpace               = NULL;
    DWORD       WorkSpaceSize           = 0;
    DWORD       FragmentWorkSpaceSize   = 0;

    *pCompressedSize = 0;

    if (UnCompressedBuf  == NULL ||
        UnCompressedBufLen == 0) {

        WStatus = ERROR_INVALID_PARAMETER;
        goto out;
    }

    if (CompressedBuf == NULL    ||
        CompressedBufLen == 0) {

        WStatus = ERROR_MORE_DATA;
        goto out;
    }

    *pCompressedSize = 0;

    NtStatus = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1,
                                              &WorkSpaceSize,
                                              &FragmentWorkSpaceSize);

    WStatus = FrsSetLastNTError(NtStatus);

    if (!WIN_SUCCESS(WStatus)) {
        goto out;
    }

    WorkSpace = FrsAlloc(WorkSpaceSize);

    NtStatus = RtlCompressBuffer(COMPRESSION_FORMAT_LZNT1,           //  compression engine
                                 UnCompressedBuf,                    //  input
                                 UnCompressedBufLen,                 //  length of input
                                 CompressedBuf,                      //  output
                                 CompressedBufLen,                   //  length of output
                                 FRS_UNCOMPRESSED_CHUNK_SIZE,        //  chunking that occurs in buffer
                                 pCompressedSize,                    //  result size
                                 WorkSpace);                         //  used by rtl routines

    if (NtStatus == STATUS_BUFFER_TOO_SMALL) {

        WStatus = ERROR_MORE_DATA;
        goto out;
    } else if (NtStatus == STATUS_BUFFER_ALL_ZEROS) {
        //
        // STATUS_BUFFER_ALL_ZEROS means the compression worked without a hitch
        // and in addition the input buffer was all zeros.
        //
        NtStatus = STATUS_SUCCESS;
    }

    WStatus = FrsSetLastNTError(NtStatus);

    if (!WIN_SUCCESS(WStatus)) {
        *pCompressedSize = 0;
        DPRINT1(0,"ERROR compressing data. NtStatus = 0x%x\n", NtStatus);
        goto out;
    }

    WStatus = ERROR_SUCCESS;

out:
    FrsFree(WorkSpace);
    return WStatus;
}

DWORD
FrsLZNT1DecompressBuffer(
    OUT PUCHAR  DecompressedBuf,
    IN  DWORD   DecompressedBufLen,
    IN  PUCHAR  CompressedBuf,
    IN  DWORD   CompressedBufLen,
    OUT DWORD   *pDecompressedSize,
    OUT DWORD   *pBytesProcessed,
    OUT PVOID   *pDecompressContext
    )
/*++
Routine Description:
    Decompression routine for default compression format.
    COMPRESSION_FORMAT_LZNT1

Arguments:
    DecompressedBuf    : Resultant decompressed buffer.
    DecompressedBufLen : Max size of decompressed buffer.
    CompressedBuf      : Input buffer.
    CompressedBufLen   : Input buffer length.
    pDecompressedSize  : Size of decompressed buffer.
    pBytesProcessed    : Total bytes processed (could be over multiple calls to this function)
    pDecompressContext : Decompress context returned if multiple calls are needed to
                         decompress this buffer. Valid context is returned when ERROR_MORE_DATA
                         is returned.

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsLZNT1DecompressBuffer:"

    DWORD       WStatus             = ERROR_SUCCESS;
    DWORD       NtStatus;
    DWORD       CompressedBufIndex  = 0;
    DWORD       CompressedBufStart  = 0;
    DWORD       CompressedBufEnd    = 0;
    DWORD       NoOfChunks          = 0;
    FRS_COMPRESSED_CHUNK_HEADER ChunkHeader;

    *pDecompressedSize = 0;

    if (CompressedBuf == NULL ||
        CompressedBufLen == 0) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto out;
    }

    if (DecompressedBuf == NULL ||
        DecompressedBufLen < FRS_MAX_CHUNKS_TO_DECOMPRESS * FRS_UNCOMPRESSED_CHUNK_SIZE) {
        //
        // At this point we don't know how much the data will grow when it is
        // decompressed. We don't have to return it all at once. Ask the
        // caller to allocate 64k and then he can make multiple calls
        // if the decompressed data does not fit in 64K buffer.
        //
        *pDecompressedSize = FRS_MAX_CHUNKS_TO_DECOMPRESS * FRS_UNCOMPRESSED_CHUNK_SIZE;
        *pBytesProcessed = 0;
        *pDecompressContext = FrsAlloc(sizeof(FRS_DECOMPRESS_CONTEXT));
        ((PFRS_DECOMPRESS_CONTEXT)(*pDecompressContext))->BytesProcessed;
        WStatus = ERROR_MORE_DATA;
        goto out;
    }

    if (*pDecompressContext != NULL) {
        CompressedBufIndex = ((PFRS_DECOMPRESS_CONTEXT)(*pDecompressContext))->BytesProcessed;
        if (CompressedBufIndex>= CompressedBufLen) {
            WStatus = ERROR_INVALID_PARAMETER;
            goto out;
        }
    }

    //
    // We start deoompressing the buffer from the start if either no context is passed
    // or the index in the context is zero. If this is not the case then we want to
    // start processing the buffer where we left off last time.
    //
    CompressedBufStart = CompressedBufIndex;

    while ((CompressedBufIndex <= CompressedBufLen) &&
           (NoOfChunks < FRS_MAX_CHUNKS_TO_DECOMPRESS)){

        if (CompressedBufIndex  > CompressedBufLen - sizeof(FRS_COMPRESSED_CHUNK_HEADER)) {
            CompressedBufEnd = CompressedBufIndex;
            break;
        }

        CopyMemory(&ChunkHeader, CompressedBuf + CompressedBufIndex,sizeof(FRS_COMPRESSED_CHUNK_HEADER));
        ++NoOfChunks;
        CompressedBufEnd = CompressedBufIndex;
        CompressedBufIndex+=ChunkHeader.Chunk.CompressedChunkSizeMinus3+3;
    }

    if (CompressedBufStart == CompressedBufEnd) {
        //
        // The data left to process in the input buffer is less than 1 chunk.
        //
        *pBytesProcessed = CompressedBufEnd;
        WStatus = ERROR_SUCCESS;
        goto out;
    }

    NtStatus = RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1,              //  decompression engine
                                   DecompressedBuf,                       //  output
                                   DecompressedBufLen,                    //  length of output
                                   CompressedBuf + CompressedBufStart,                         //  input
                                   CompressedBufEnd - CompressedBufStart, //  length of input
                                   pDecompressedSize);                    //  result size

    WStatus = FrsSetLastNTError(NtStatus);

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2(0,"Error decompressing. NtStatus = 0x%x. DeCompressedSize = 0x%x\n", NtStatus, *pDecompressedSize);
        
	// 
	// We don't want to abort this CO just because the was a decompression 
	// error. That error could have been caused by a corruption of the 
	// staging file, which we can recover. Unfortunately the NTStatus
	// STATUS_BAD_COMPRESSION_BUFFER gets mapped to the more generic Win32
	// error ERROR_MR_MID_NOT_FOUND. We can't make that a retriable error 
	// so let's just return ERROR_RETRY here.
	//
	WStatus = ERROR_RETRY;
	goto out;
    }

    //
    // If we maxed out the number of chunks that can be decompressed at 1 time then
    // we have some more compressed data in this buffer left to decompress. Pass the
    // conext back to caller and return ERROR_MORE_DATA. The caller will make this call
    // again to get the next set of decompressed data.
    //
    *pBytesProcessed = CompressedBufEnd;

    if (NoOfChunks >= FRS_MAX_CHUNKS_TO_DECOMPRESS) {
        if (*pDecompressContext == NULL) {
            *pDecompressContext = FrsAlloc(sizeof(FRS_DECOMPRESS_CONTEXT));
        }

        ((PFRS_DECOMPRESS_CONTEXT)(*pDecompressContext))->BytesProcessed = CompressedBufEnd;

        WStatus = ERROR_MORE_DATA;
        goto out;
    }


    WStatus = ERROR_SUCCESS;
out:
    return WStatus;

}

PVOID
FrsLZNT1FreeDecompressContext(
    IN PVOID   *pDecompressContext
    )
/*++
Routine Description:
    Frees the decompresscontext.

Arguments:
    pDecompressContext : Decompress context to free.

Return Value:
    NULL ptr
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsLZNT1FreeDecompressContext:"

    if (pDecompressContext == NULL) {
        return NULL;
    }

    return FrsFree(*pDecompressContext);
}

DWORD
FrsGetCompressionRoutine(
    IN  PWCHAR   FileName,
    IN  HANDLE   FileHandle,
    OUT PFRS_COMPRESS_BUFFER *ppFrsCompressBuffer,
    //OUT DWORD    (**ppFrsCompressBuffer)(IN UnCompressedBuf, IN UnCompressedBufLen,
    //                                     OUT CompressedBuf, IN CompressedBufLen, OUT pCompressedSize),
    OUT GUID     *pCompressionFormatGuid
    )
/*++
Routine Description:
    Find the appropriate routine to compress the file.

Arguments:
    FileName        : Name of the file to compress.
    pFrsCompressBuf : Address of Function pointer to the selected compression routine,

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetCompressionRoutine:"

    if (DisableCompressionStageFiles) {
        *ppFrsCompressBuffer = NULL;
        ZeroMemory(pCompressionFormatGuid, sizeof(GUID));
        return ERROR_SUCCESS;
    }

    *ppFrsCompressBuffer = FrsLZNT1CompressBuffer;
    COPY_GUID(pCompressionFormatGuid, &FrsGuidCompressionFormatLZNT1);
    return ERROR_SUCCESS;
}

DWORD
FrsGetDecompressionRoutine(
    IN  PCHANGE_ORDER_COMMAND Coc,
    IN  PSTAGE_HEADER         Header,
    OUT PFRS_DECOMPRESS_BUFFER      *ppFrsDecompressBuffer,
    OUT PFRS_FREE_DECOMPRESS_BUFFER *ppFrsFreeDecompressContext
    //OUT DWORD (**ppFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed),
    //OUT PVOID (**ppFrsFreeDecompressContext)(IN pDecompressContext)
    )
/*++
Routine Description:
    Find the appropriate routine to decompress the file.

Arguments:
    Coc                        : Change order command.
    StageHeader                : Stage header read from the compressed staging file.
    ppFrsDecompressBuffer      : Function pointer to the decompression api.
    ppFrsFreeDecompressContext : Function pointer to the api used to free
                                 the decompress context.

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetDecompressionRoutine:"

    if (IS_GUID_ZERO(&Header->CompressionGuid)) {
        *ppFrsDecompressBuffer = NULL;
        *ppFrsFreeDecompressContext = NULL;
        return ERROR_SUCCESS;
    }

    *ppFrsDecompressBuffer = FrsLZNT1DecompressBuffer;
    *ppFrsFreeDecompressContext = FrsLZNT1FreeDecompressContext;
    return ERROR_SUCCESS;
}

DWORD
FrsGetDecompressionRoutineByGuid(
    IN  GUID  *CompressionFormatGuid,
    OUT PFRS_DECOMPRESS_BUFFER      *ppFrsDecompressBuffer,
    OUT PFRS_FREE_DECOMPRESS_BUFFER *ppFrsFreeDecompressContext
    //OUT DWORD (**ppFrsDecompressBuffer)(OUT DecompressedBuf, IN DecompressedBufLen, IN CompressedBuf, IN CompressedBufLen, OUT DecompressedSize, OUT BytesProcessed),
    //OUT PVOID (**ppFrsFreeDecompressContext)(IN pDecompressContext)
    )
/*++
Routine Description:
    Find the appropriate routine to decompress the file using the guid.

Arguments:
    CompressionFormatGuid      : Guid for the compression format.
    ppFrsDecompressBuffer      : Function pointer to the decompression api.
    ppFrsFreeDecompressContext : Function pointer to the api used to free
                                 the decompress context.

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsGetDecompressionRoutineByGuid:"

    if (IS_GUID_ZERO(CompressionFormatGuid)) {
        *ppFrsDecompressBuffer = NULL;
        *ppFrsFreeDecompressContext = NULL;
        return ERROR_SUCCESS;
    }

    *ppFrsDecompressBuffer = FrsLZNT1DecompressBuffer;
    *ppFrsFreeDecompressContext = FrsLZNT1FreeDecompressContext;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\ds.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    ds.c

Abstract:
    This command server manages the topology retrieved from the DS.

    The entire DS tree is checked for consistency. But only a copy of
    the information about this server is sent on to the replica control
    command server.

    The consistency of the DS topology is verified before the info
    is merged into the current working topology. N**2 scans are
    prevented by using several temporary tables during the verification.

Author:
    Billy J. Fuller 3-Mar-1997
    Sudarshan A. Chitre 20-Aug-2001 Cleanup: Removed all code that dealt with polling
                                    that was not being used. Finally changed the prefix
                                    of polling code from FrsNewDs to FrsDs.

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop
#include <perrepsr.h>

#undef DEBSUB
#define DEBSUB  "DS:"

#include <ntdsapi.h>
#include <frs.h>
#include <ntdsapip.h>   // ms internal flags for DsCrackNames()
#include <ntfrsapi.h>
#include <tablefcn.h>
#include <lmaccess.h>
#include <dsrole.h>
#include <lmapibuf.h>

#ifdef SECURITY_WIN32
#include <security.h>
#else
#define SECURITY_WIN32
#include <security.h>
#undef SECURITY_WIN32
#endif


#include <winsock2.h>

//
// No reason to hold memory if all we are doing is periodically
// polling the DS to find there is no replication work to be
// performed
//
// extern BOOL MainInitSucceeded;


ULONG
ActiveChildrenHashCalc(
    PVOID Buf,
    PULONGLONG QKey
);

BOOL
ActiveChildrenKeyMatch(
    PVOID Buf,
    PVOID QKey
);


//
// This is a reference counted structure that contains two tables.
// The tables are used to look up valid partners by name or by connection
// guid.
//
// Each time we poll, we create a new struct and then swap the pointer to the
// old struct with a pointer to the new struct. We want to minimize the amount of
// time that a lock needs to be held. We only write to the tables when they are
// being created. At that time, only the local thread will access them so no
// lock needs to be held. Later, we only read form the tables so no lock needs
// to be held either. The thing that needs to be controlled by the lock is
// access to this global pointer.
//
// Before using the struct you must aquire the crit sec, increase the reference
// count, and make a local copy of the pointer. Use the local pointer copy so
// that you do not get screwed up when the pointer is swapped for a new struct.
// We also will hold the crit sec while swapping the pointers.
//
// If you keep the local pointer around, you will not need to hold the lock to
// decrement the ref count. Nobody will be writing to the stuct itself and it
// will not be cleaned up while the reference count is greater than zero. Be
// sure to use InterlockedDecrement since other threads may be touching the ref
// count at the same time.
//
// For simplicity, use ACQUIRE_VALID_PARTNER_TABLE_POINTER,
// RELEASE_VALID_PARTNER_TABLE_POINTER, and SWAP_VALID_PARTNER_TABLE_POINTER.
//
PFRS_VALID_PARTNER_TABLE_STRUCT pValidPartnerTableStruct = NULL;
CRITICAL_SECTION CritSec_pValidPartnerTableStruct;

// List of old structs to be cleaned up when ref counts hit zero.
PFRS_VALID_PARTNER_TABLE_STRUCT OldValidPartnerTableStructListHead = NULL;
CRITICAL_SECTION OldValidPartnerTableStructListHeadLock;

extern BOOL NeedNewPartnerTable;

//
// We will re-read the DS every so often (adjustable with registry)
//
ULONG   DsPollingInterval;
ULONG   DsPollingShortInterval;
ULONG   DsPollingLongInterval;

//
// Don't use a noisy DS; wait until it settles out
//
ULONGLONG   ThisChange;
ULONGLONG   LastChange;

//
// Dont't bother processing the same topology again
//
ULONGLONG   NextChange;
ULONGLONG   ActiveChange;

//
// Try to keep the same binding forever
//
PLDAP   gLdap = NULL;
HANDLE  DsHandle = NULL;
PWCHAR  SitesDn = NULL;
PWCHAR  ServicesDn = NULL;
PWCHAR  SystemDn = NULL;
PWCHAR  ComputersDn = NULL;
PWCHAR  DomainControllersDn = NULL;
PWCHAR  DefaultNcDn = NULL;
BOOL    DsBindingsAreValid = FALSE;


BOOL    DsCreateSysVolsHasRun = FALSE;

//
// Globals for the comm test
//
PWCHAR  DsDomainControllerName;

//
// Have we initialized the rest of the service?
//
extern BOOL MainInitHasRun;

//
// Directory and file filter lists from registry.
//
extern PWCHAR   RegistryFileExclFilterList;
extern PWCHAR   RegistryFileInclFilterList;

extern PWCHAR   RegistryDirExclFilterList;
extern PWCHAR   RegistryDirInclFilterList;

//
// Stop polling the DS
//
BOOL    DsIsShuttingDown;
HANDLE  DsShutDownComplete;

//
// Remember the computer's DN to save calls to GetComputerObjectName().
//
PWCHAR  ComputerCachedFqdn;

PGEN_TABLE      SubscriberTable             = NULL;
PGEN_TABLE      SetTable                    = NULL;
PGEN_TABLE      CxtionTable                 = NULL;
PGEN_TABLE      AllCxtionsTable             = NULL;
PGEN_TABLE      PartnerComputerTable        = NULL;
PGEN_TABLE      MemberTable                 = NULL;
PGEN_TABLE      VolSerialNumberToDriveTable = NULL;  // Mapping of VolumeSerial Number to drive.
PWCHAR          MemberSearchFilter          = NULL;

//
// Collect the errors encountered during polling in this buffer and write it to the eventlog at the
// end of poll.
//

PWCHAR          DsPollSummaryBuf            = NULL;
DWORD           DsPollSummaryBufLen         = 0;
DWORD           DsPollSummaryMaxBufLen      = 0;

//
// Role information
//
PWCHAR  Roles[DsRole_RolePrimaryDomainController + 1] = {
    L"DsRole_RoleStandaloneWorkstation",
    L"DsRole_RoleMemberWorkstation",
    L"DsRole_RoleStandaloneServer",
    L"DsRole_RoleMemberServer",
    L"DsRole_RoleBackupDomainController",
    L"DsRole_RolePrimaryDomainController"
};


//
// Flags to passed into DsGetDcName (see sdk\inc\dsgetdc.h)
//
FLAG_NAME_TABLE DsGetDcNameFlagNameTable[] = {
    {DS_FORCE_REDISCOVERY               , "FORCE_REDISCOVERY "           },
    {DS_DIRECTORY_SERVICE_REQUIRED      , "DIRECTORY_SERVICE_REQUIRED "  },
    {DS_DIRECTORY_SERVICE_PREFERRED     , "DIRECTORY_SERVICE_PREFERRED " },
    {DS_GC_SERVER_REQUIRED              , "GC_SERVER_REQUIRED "          },
    {DS_PDC_REQUIRED                    , "PDC_REQUIRED "                },
    {DS_BACKGROUND_ONLY                 , "DS_BACKGROUND_ONLY "          },
    {DS_IP_REQUIRED                     , "IP_REQUIRED "                 },
    {DS_KDC_REQUIRED                    , "KDC_REQUIRED "                },
    {DS_TIMESERV_REQUIRED               , "TIMESERV_REQUIRED "           },
    {DS_WRITABLE_REQUIRED               , "WRITABLE_REQUIRED "           },
    {DS_GOOD_TIMESERV_PREFERRED         , "GOOD_TIMESERV_PREFERRED "     },
    {DS_AVOID_SELF                      , "AVOID_SELF "                  },
    {DS_ONLY_LDAP_NEEDED                , "ONLY_LDAP_NEEDED "            },
    {DS_IS_FLAT_NAME                    , "IS_FLAT_NAME "                },
    {DS_IS_DNS_NAME                     , "IS_DNS_NAME "                 },
    {DS_RETURN_DNS_NAME                 , "RETURN_DNS_NAME "             },
    {DS_RETURN_FLAT_NAME                , "RETURN_FLAT_NAME "            },

    {0, NULL}
};

//
// return flags from DsGetDCInfo() & DsGetDcName() too?
//
FLAG_NAME_TABLE DsGetDcInfoFlagNameTable[] = {
    {DS_PDC_FLAG               , "DCisPDCofDomain "             },
    {DS_GC_FLAG                , "DCIsGCofForest "              },
    {DS_LDAP_FLAG              , "ServerSupportsLDAP_Server "   },
    {DS_DS_FLAG                , "DCSupportsDSAndIsA_DC "       },
    {DS_KDC_FLAG               , "DCIsRunningKDCSvc "           },
    {DS_TIMESERV_FLAG          , "DCIsRunningTimeSvc "          },
    {DS_CLOSEST_FLAG           , "DCIsInClosestSiteToClient "   },
    {DS_WRITABLE_FLAG          , "DCHasWritableDS "             },
    {DS_GOOD_TIMESERV_FLAG     , "DCRunningTimeSvcWithClockHW " },
    {DS_DNS_CONTROLLER_FLAG    , "DCNameIsDNSName "             },
    {DS_DNS_DOMAIN_FLAG        , "DomainNameIsDNSName "         },
    {DS_DNS_FOREST_FLAG        , "DnsForestNameIsDNSName "      },

    {0, NULL}
};


//
// Flags from Options Attribute in NTDS-Connection object.
//
FLAG_NAME_TABLE CxtionOptionsFlagNameTable[] = {
    {NTDSCONN_OPT_IS_GENERATED                  , "AutoGenCxtion "         },
    {NTDSCONN_OPT_TWOWAY_SYNC                   , "TwoWaySync "            },
    {NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT       , "OverrideNotifyDefault " },
//  {NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION , "DisableIntersiteCompress " },
//  {NTDSCONN_OPT_USER_OWNED_SCHEDULE           , "UserOwnedSchedule "     },
    {NTDSCONN_OPT_IGNORE_SCHEDULE_MASK          , "IgnoreSchedOnInitSync " },

    {0, NULL}
};


//
// Name strings for config node object types.  NOTE: Order must match enum in frs.h
//
PWCHAR DsConfigTypeName[] = {
    L" ",
    L"NTDS-Connection (in)",
    L"NTFRS-Member",
    L"NTFRS-Replica-Set",
    L"NTFRS-Settings",
    L"NTDS-Settings",
    L"NTFRS-Subscriber",
    L"NTFRS-Subscriptions",
    L"NTDS-DSA",
    L"COMPUTER",
    L"USER",
    L"SERVER",
    L"<<SERVICES_ROOT>>",
    L"<<Connection (Out)>>"
};


//
// Client side ldap_connect timeout in seconds. Reg value "Ldap Bind Timeout In Seconds". Default is 30 seconds.
//
extern DWORD LdapBindTimeoutInSeconds;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **               F R S _ L D A P  _ S E A R C H _ C O N T E X T              **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// Client side ldap search timeout in minutes. Reg value "Ldap Search Timeout In Minutes". Default is 10 minutes.
//
extern DWORD LdapSearchTimeoutInMinutes;

//
// Ldap client timeout structure. Value is overwritten by the value of LdapSearchTimeoutInMinutes.
//

LDAP_TIMEVAL    LdapTimeout = { 10 * 60 * 60, 0 }; //Default ldap timeout value. Overridden by registry param Ldap Search Timeout Value In Minutes

#define FRS_LDAP_SEARCH_PAGESIZE 1000

typedef struct _FRS_LDAP_SEARCH_CONTEXT {

    ULONG                     EntriesInPage;     // Number of entries in the current page.
    ULONG                     CurrentEntry;      // Location of the pointer into the page.
    LDAPMessage             * LdapMsg;           // Returned from ldap_search_ext_s()
    LDAPMessage             * CurrentLdapMsg;    // Current entry from current page.
    PWCHAR                    Filter;            // Filter to add to the DS query.
    PWCHAR                    BaseDn;            // Dn to start the query from.
    DWORD                     Scope;             // Scope of the search.
    PWCHAR                  * Attrs;             // Attributes requested by the search.

} FRS_LDAP_SEARCH_CONTEXT, *PFRS_LDAP_SEARCH_CONTEXT;

//
// Registry Command codes for FrsDsEnumerateSysVolKeys()
//
#define REGCMD_CREATE_PRIMARY_DOMAIN       (1)
#define REGCMD_CREATE_MEMBERS              (2)
#define REGCMD_DELETE_MEMBERS              (3)
#define REGCMD_DELETE_KEYS                 (4)


#define MK_ATTRS_1(_attr_, _a1)                                                \
    _attr_[0] = _a1;   _attr_[1] = NULL;

#define MK_ATTRS_2(_attr_, _a1, _a2)                                           \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = NULL;

#define MK_ATTRS_3(_attr_, _a1, _a2, _a3)                                      \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = NULL;

#define MK_ATTRS_4(_attr_, _a1, _a2, _a3, _a4)                                 \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = NULL;

#define MK_ATTRS_5(_attr_, _a1, _a2, _a3, _a4, _a5)                            \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = NULL;

#define MK_ATTRS_6(_attr_, _a1, _a2, _a3, _a4, _a5, _a6)                       \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = NULL;

#define MK_ATTRS_7(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7)                  \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = NULL;

#define MK_ATTRS_8(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)             \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = _a8;  \
    _attr_[8] = NULL;

#define MK_ATTRS_9(_attr_, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8, _a9)        \
    _attr_[0] = _a1;   _attr_[1] = _a2;   _attr_[2] = _a3;   _attr_[3] = _a4;  \
    _attr_[4] = _a5;   _attr_[5] = _a6;   _attr_[6] = _a7;   _attr_[7] = _a8;  \
    _attr_[8] = _a9;   _attr_[9] = NULL;


//
// Merging the information from the Ds with the active replicas.
//
CRITICAL_SECTION    MergingReplicasWithDs;

ULONG
FrsProcessBackupRestore(
    VOID
    );

RcsSetSysvolReady(
    IN DWORD    NewSysvolReady
    );

LONG
PmInitPerfmonRegistryKeys (
    VOID
    );

VOID
DbgQueryDynamicConfigParams(
    );

DWORD
FrsDsGetRole(
    VOID
    );


VOID
FrsDsAddToPollSummary3ws(
    IN DWORD        idsCode,
    IN PWCHAR       WStr1,
    IN PWCHAR       WStr2,
    IN PWCHAR       WStr3
    )
/*++
Routine Description:
    Add to the poll summary event log.

Arguments:
    idsCode - Code of data string from string.rc
    WStr1   - Argument1
    WStr2   - Argument2
    WStr3   - Argument3

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsAddToPollSummary3ws:"

    PWCHAR          ResStr         = NULL;
    PWCHAR          tempMessage    = NULL;
    DWORD           tempMessageLen = 0;

    ResStr = FrsGetResourceStr(idsCode);
    tempMessageLen = (wcslen(ResStr) - wcslen(L"%ws%ws%ws") +
                      wcslen(WStr1) + wcslen(WStr2) +
                      wcslen(WStr3) + 1) * sizeof(WCHAR);
    tempMessage = FrsAlloc(tempMessageLen);
    wsprintf(tempMessage, ResStr, WStr1, WStr2, WStr3);
    //
    // Don't want to copy the trailing null to the event log buffer or else
    // the next message will not be printed.
    //
    FRS_DS_ADD_TO_POLL_SUMMARY(DsPollSummaryBuf, tempMessage, tempMessageLen - 2);
    FrsFree(ResStr);
    FrsFree(tempMessage);
    return;
}

VOID
FrsDsAddToPollSummary1ws(
    IN DWORD        idsCode,
    IN PWCHAR       WStr1
    )
/*++
Routine Description:
    Add to the poll summary event log.

Arguments:
    idsCode - Code of data string from string.rc
    WStr1   - Argument1

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsAddToPollSummary1ws:"

    PWCHAR          ResStr         = NULL;
    PWCHAR          tempMessage    = NULL;
    DWORD           tempMessageLen = 0;

    ResStr = FrsGetResourceStr(idsCode);
    tempMessageLen = (wcslen(ResStr) - wcslen(L"%ws") +
                      wcslen(WStr1) + 1) * sizeof(WCHAR);
    tempMessage = FrsAlloc(tempMessageLen);
    wsprintf(tempMessage, ResStr, WStr1);
    //
    // Don't want to copy the trailing null to the event log buffer or else
    // the next message will not be printed.
    //
    FRS_DS_ADD_TO_POLL_SUMMARY(DsPollSummaryBuf, tempMessage, tempMessageLen - 2);
    FrsFree(ResStr);
    FrsFree(tempMessage);
    return;
}


VOID
FrsDsAddToPollSummary(
    IN DWORD        idsCode
    )
/*++
Routine Description:
    Add to the poll summary event log.

Arguments:
    idsCode - Code of data string from string.rc

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsAddToPollSummary:"

    PWCHAR          ResStr         = NULL;

    ResStr = FrsGetResourceStr(idsCode);

    //
    // Don't want to copy the trailing null to the event log buffer or else
    // the next message will not be printed.
    //
    FRS_DS_ADD_TO_POLL_SUMMARY(DsPollSummaryBuf, ResStr, wcslen(ResStr) * sizeof(WCHAR));
    FrsFree(ResStr);
    return;
}


PVOID *
FrsDsFindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr,
    IN BOOL         DoBerVals
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound Ldap port.
    Entry       - An Ldap entry returned by Ldap_search_s()
    DesiredAttr - Return values for this attribute.
    DoBerVals   - Return the bervals (for binary data, v.s. WCHAR data)

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFindValues:"
    PWCHAR          Attr;       // Retrieved from an Ldap entry
    BerElement      *Ber;       // Needed for scanning attributes

    //
    // Search the entry for the desired attribute
    //
    for (Attr = ldap_first_attribute(Ldap, Entry, &Ber);
         Attr != NULL;
         Attr = ldap_next_attribute(Ldap, Entry, Ber)) {

        if (WSTR_EQ(DesiredAttr, Attr)) {
            //
            // Return the values for DesiredAttr
            //
            if (DoBerVals) {
                return ldap_get_values_len(Ldap, Entry, Attr);
            } else {
                return ldap_get_values(Ldap, Entry, Attr);
            }
        }
    }
    return NULL;
}




PWCHAR
FrsDsFindValue(
    IN PLDAP        Ldap,
    IN PLDAPMessage Entry,
    IN PWCHAR       DesiredAttr
    )
/*++
Routine Description:
    Return a copy of the first DS value for one attribute in an entry.

Arguments:
    ldap        - An open, bound ldap port.
    Entry       - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    A zero-terminated string or NULL if the attribute or its value
    doesn't exist. The string is freed with FREE_NO_HEADER().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFindValue:"
    PWCHAR  Val;
    PWCHAR  *Values;

    // Get ldap's array of values
    Values = (PWCHAR *)FrsDsFindValues(Ldap, Entry, DesiredAttr, FALSE);

    // Copy the first value (if any)
    Val = (Values) ? FrsWcsDup(Values[0]) : NULL;

    // Free ldap's array of values
    LDAP_FREE_VALUES(Values);

    return Val;
}


GUID *
FrsDsFindGuid(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry
    )
/*++
Routine Description:
    Return a copy of the object's guid

Arguments:
    ldap    - An open, bound ldap port.
    Entry   - An ldap entry returned by ldap_search_s()

Return Value:
    The address of a guid or NULL. Free with FrsFree().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFindGuid:"
    GUID            *Guid;
    PLDAP_BERVAL    *Values;

    // Get ldap's array of values
    Values = (PLDAP_BERVAL *)FrsDsFindValues(Ldap, LdapEntry, ATTR_OBJECT_GUID, TRUE);

    // Copy the first value (if any)
    Guid = (Values) ? FrsDupGuid((GUID *)Values[0]->bv_val) : NULL;

    // Free ldap's array of values
    LDAP_FREE_BER_VALUES(Values);

    return Guid;
}





PSCHEDULE
FrsDsFindSchedule(
    IN  PLDAP        Ldap,
    IN  PLDAPMessage LdapEntry,
    OUT PULONG       Len
    )
/*++
Routine Description:
    Return a copy of the object's schedule

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    Len         - length of schedule blob

Return Value:
    The address of a schedule or NULL. Free with FrsFree().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFindSchedule:"
    PLDAP_BERVAL    *Values;
    PSCHEDULE       Schedule;

    //
    // Get ldap's array of values
    //
    Values = (PLDAP_BERVAL *)FrsDsFindValues(Ldap, LdapEntry, ATTR_SCHEDULE, TRUE);
    if (!Values)
        return NULL;

    //
    // Return a copy of the schedule
    //
    *Len = Values[0]->bv_len;
    if (*Len) {
        //
        // Need to check if *Len == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
        //
        Schedule = FrsAlloc(*Len);
        CopyMemory(Schedule, Values[0]->bv_val, *Len);
    } else {
        Schedule = NULL;
    }
    LDAP_FREE_BER_VALUES(Values);
    return Schedule;
}


BOOL
FrsDsLdapSearch(
    IN PLDAP        Ldap,
    IN PWCHAR       Base,
    IN ULONG        Scope,
    IN PWCHAR       Filter,
    IN PWCHAR       Attrs[],
    IN ULONG        AttrsOnly,
    IN LDAPMessage  **Msg
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call, check for errors, and check for
    a shutdown in progress.

Arguments:
    ldap        Session handle to Ldap server.

    Base        The distinguished name of the entry at which to start the search

    Scope
        LDAP_SCOPE_BASE     Search the base entry only.
        LDAP_SCOPE_ONELEVEL Search the base entry and all entries in the first
                            level below the base.
        LDAP_SCOPE_SUBTREE  Search the base entry and all entries in the tree
                            below the base.

    Filter      The search filter.

    Attrs       A null-terminated array of strings indicating the attributes
                to return for each matching entry. Pass NULL to retrieve all
                available attributes.

    AttrsOnly   A boolean value that should be zero if both attribute types
                and values are to be returned, nonzero if only types are wanted.

    mSG         Contains the results of the search upon completion of the call.
                The ldap array of values or NULL if the Base, DesiredAttr, or its
                values does not exist.
                The ldap array is freed with LDAP_FREE_VALUES().

Return Value:

    TRUE if not shutting down.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLdapSearch:"

    DWORD           LStatus;

    *Msg  = NULL;

    //
    // Increment the DS Searches counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, DSSearches, 1);

    //
    // Issue the ldap search
    //
//    LStatus = ldap_search_s(Ldap, Base, Scope, Filter, Attrs, AttrsOnly, Msg);
    LStatus = ldap_search_ext_s(Ldap,
                                Base,
                                Scope,
                                Filter,
                                Attrs,
                                AttrsOnly,
                                NULL,
                                NULL,
                                &LdapTimeout,
                                0,
                                Msg);

    //
    // Check for errors
    //
    if (LStatus != LDAP_SUCCESS) {
        PWCHAR ldapErrorString = NULL;
        DPRINT2_LS(1, ":DS: WARN - Error searching %ws for %ws;", Base, Filter, LStatus);

        //
        // Increment the DS Searches in Error counter
        //
        PM_INC_CTR_SERVICE(PMTotalInst, DSSearchesError, 1);

        //
        // Add to the poll summary event log.
        //
        ldapErrorString = ldap_err2string(LStatus);
        if(ldapErrorString) {
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_SEARCH_ERROR, Filter, Base,
                                     ldapErrorString);
        }

        LDAP_FREE_MSG(*Msg);
        return FALSE;
    }
    //
    // Return FALSE if shutting down.
    //
    if (FrsIsShuttingDown || DsIsShuttingDown) {
        LDAP_FREE_MSG(*Msg);
        return FALSE;
    }
    return TRUE;
}

BOOL
FrsDsLdapSearchInit(
    PLDAP        ldap,
    PWCHAR       Base,
    ULONG        Scope,
    PWCHAR       Filter,
    PWCHAR       Attrs[],
    ULONG        AttrsOnly,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Issue the ldap_create_page_control and  ldap_search_ext_s calls,
    FrsDsLdapSearchInit(), and FrsDsLdapSearchNext() APIs are used to
    make ldap queries and retrieve the results in paged form.

Arguments:
    ldap        Session handle to Ldap server.

    Base        The distinguished name of the entry at which to start the search.
                A copy of base is kept in the context.

    Scope

                LDAP_SCOPE_BASE     Search the base entry only.

                LDAP_SCOPE_ONELEVEL Search the base entry and all entries in the first
                                    level below the base.

                LDAP_SCOPE_SUBTREE  Search the base entry and all entries in the tree
                                    below the base.

    Filter      The search filter. A copy of filter is kept in the context.

    Attrs       A null-terminated array of strings indicating the attributes
                to return for each matching entry. Pass NULL to retrieve all
                available attributes.

    AttrsOnly   A boolean value that should be zero if both attribute types
                and values are to be returned, nonzero if only types are wanted.

    FrsSearchContext
                An opaques structure that links the FrsDsLdapSearchInit() and
                FrsDsLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    BOOL result.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLdapSearchInit:"

    DWORD           LStatus             = LDAP_SUCCESS;
    PLDAPControl    ServerControls[2];
    PLDAPControl    ServerControl       = NULL;
    UINT            i;
    LDAP_BERVAL     cookie1 = { 0, NULL };

    FrsSearchContext->LdapMsg = NULL;
    FrsSearchContext->CurrentLdapMsg = NULL;
    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;

    FrsSearchContext->BaseDn = FrsWcsDup(Base);
    FrsSearchContext->Filter = FrsWcsDup(Filter);
    FrsSearchContext->Scope = Scope;
    FrsSearchContext->Attrs = Attrs;


    LStatus = ldap_create_page_control(ldap,
                                      FRS_LDAP_SEARCH_PAGESIZE,
                                      &cookie1,
                                      FALSE, // is critical
                                      &ServerControl
                                     );

    ServerControls[0] = ServerControl;
    ServerControls[1] = NULL;

    if (LStatus != LDAP_SUCCESS) {
        DPRINT2_LS(2, ":DS: WARN - Error creating page control %ws for %ws;", Base, Filter, LStatus);
        FrsSearchContext->BaseDn = FrsFree(FrsSearchContext->BaseDn);
        FrsSearchContext->Filter = FrsFree(FrsSearchContext->Filter);
        return FALSE;
    }

    LStatus = ldap_search_ext_s(ldap,
                      FrsSearchContext->BaseDn,
                      FrsSearchContext->Scope,
                      FrsSearchContext->Filter,
                      FrsSearchContext->Attrs,
                      FALSE,
                      ServerControls,
                      NULL,
                      &LdapTimeout,
                      0,
                      &FrsSearchContext->LdapMsg);

    ldap_control_free(ServerControl);

    if  (LStatus  == LDAP_SUCCESS) {
       FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
       FrsSearchContext->CurrentEntry = 0;
    }


    if (LStatus != LDAP_SUCCESS) {
        DPRINT2_LS(2, ":DS: WARN - Error searching %ws for %ws;", Base, Filter, LStatus);
        FrsSearchContext->BaseDn = FrsFree(FrsSearchContext->BaseDn);
        FrsSearchContext->Filter = FrsFree(FrsSearchContext->Filter);
        return FALSE;
    }

    return TRUE;
}

PLDAPMessage
FrsDsLdapSearchGetNextEntry(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next entry form the current page of the results
    returned. This call is only made if there is a entry
    in the current page.

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsDsLdapSearchInit() and
                FrsDsLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    The first or the next entry from the current page.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLdapSearchGetNextEntry:"

    FrsSearchContext->CurrentEntry += 1;
    if ( FrsSearchContext->CurrentEntry == 1 ) {
        FrsSearchContext->CurrentLdapMsg = ldap_first_entry(ldap ,FrsSearchContext->LdapMsg);
    } else {
        FrsSearchContext->CurrentLdapMsg = ldap_next_entry(ldap ,FrsSearchContext->CurrentLdapMsg);
    }

    return FrsSearchContext->CurrentLdapMsg;
}

DWORD
FrsDsLdapSearchGetNextPage(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next page from the results returned by ldap_search_ext_s..

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsDsLdapSearchInit() and
                FrsDsLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:
    WINSTATUS

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLdapSearchGetNextPage:"

    DWORD                     LStatus = LDAP_SUCCESS;
    LDAP_BERVAL               * CurrCookie = NULL;
    PLDAPControl            * CurrControls = NULL;
    ULONG                     retcode = 0;
    ULONG                     TotalEntries = 0;
    PLDAPControl              ServerControls[2];
    PLDAPControl              ServerControl= NULL;



    // Get the server control from the message, and make a new control with the cookie from the server
    LStatus = ldap_parse_result(ldap, FrsSearchContext->LdapMsg, &retcode,NULL,NULL,NULL,&CurrControls,FALSE);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);

    if (LStatus != LDAP_SUCCESS) {
        DPRINT2_LS(2, ":DS: WARN - Error in ldap_parse_result %ws for %ws;", FrsSearchContext->BaseDn, FrsSearchContext->Filter, LStatus);
        return LdapMapErrorToWin32(LStatus);
    }

    LStatus = ldap_parse_page_control(ldap, CurrControls, &TotalEntries, &CurrCookie);

    if (LStatus != LDAP_SUCCESS) {
        DPRINT2_LS(2, ":DS: WARN - Error in ldap_parse_page_control %ws for %ws;", FrsSearchContext->BaseDn, FrsSearchContext->Filter, LStatus);
        return LdapMapErrorToWin32(LStatus);
    }

    if ( CurrCookie->bv_len == 0 && CurrCookie->bv_val == 0 ) {
       LStatus = LDAP_CONTROL_NOT_FOUND;
       ldap_controls_free(CurrControls);
       ber_bvfree(CurrCookie);
       return LdapMapErrorToWin32(LStatus);
    }


    LStatus = ldap_create_page_control(ldap,
                            FRS_LDAP_SEARCH_PAGESIZE,
                            CurrCookie,
                            FALSE,
                            &ServerControl);

    ServerControls[0] = ServerControl;
    ServerControls[1] = NULL;

    ldap_controls_free(CurrControls);
    CurrControls = NULL;
    ber_bvfree(CurrCookie);
    CurrCookie = NULL;

    if (LStatus != LDAP_SUCCESS) {
        DPRINT2_LS(2, ":DS: WARN - Error in ldap_parse_page_control %ws for %ws;", FrsSearchContext->BaseDn, FrsSearchContext->Filter, LStatus);
        return LdapMapErrorToWin32(LStatus);
    }

    // continue the search with the new cookie
    LStatus = ldap_search_ext_s(ldap,
                   FrsSearchContext->BaseDn,
                   FrsSearchContext->Scope,
                   FrsSearchContext->Filter,
                   FrsSearchContext->Attrs,
                   FALSE,
                   ServerControls,
                   NULL,
                   &LdapTimeout,
                   0,
                   &FrsSearchContext->LdapMsg);

    ldap_control_free(ServerControl);

    //
    // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results
    //
    if ( (LStatus != LDAP_SUCCESS) && (LStatus != LDAP_CONTROL_NOT_FOUND) ) {
        DPRINT2_LS(2, ":DS: WARN - Error searching %ws for %ws;", FrsSearchContext->BaseDn, FrsSearchContext->Filter, LStatus);

    }

    if (LStatus == LDAP_SUCCESS) {
        FrsSearchContext->EntriesInPage = ldap_count_entries(ldap, FrsSearchContext->LdapMsg);
        FrsSearchContext->CurrentEntry = 0;

    }

    return LdapMapErrorToWin32(LStatus);
}

PLDAPMessage
FrsDsLdapSearchNext(
    PLDAP        ldap,
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    Get the next entry form the current page of the results
    returned or from the next page if we are at the end of the.
    current page.

Arguments:
    ldap        Session handle to Ldap server.

    FrsSearchContext
                An opaques structure that links the FrsDsLdapSearchInit() and
                FrsDsLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    The next entry on this page or the first entry from the next page.
    NULL if there are no more entries to return.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLdapSearchNext:"

    DWORD         WStatus = ERROR_SUCCESS;
    PLDAPMessage  NextEntry = NULL;

    if (FrsSearchContext->EntriesInPage > FrsSearchContext->CurrentEntry )
    {
       // return the next entry from the current page
       return FrsDsLdapSearchGetNextEntry(ldap, FrsSearchContext);
    }
    else
    {
       // see if there are more pages of results to get
       WStatus = FrsDsLdapSearchGetNextPage(ldap, FrsSearchContext);
       if (WStatus == ERROR_SUCCESS)
       {
          return FrsDsLdapSearchGetNextEntry(ldap, FrsSearchContext);
       }
    }

    return NextEntry;
}

VOID
FrsDsLdapSearchClose(
    PFRS_LDAP_SEARCH_CONTEXT FrsSearchContext
    )
/*++
Routine Description:
    The search is complete. Free the elemetns of the context and reset
    them so the same context can be used for another search.

Arguments:

    FrsSearchContext
                An opaques structure that links the FrsDsLdapSearchInit() and
                FrsDsLdapSearchNext() calls together. The structure contains
                the information required to retrieve query results across pages.

Return Value:

    NONE
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLdapSearchClose:"

    FrsSearchContext->EntriesInPage = 0;
    FrsSearchContext->CurrentEntry = 0;

    FrsSearchContext->BaseDn = FrsFree(FrsSearchContext->BaseDn);
    FrsSearchContext->Filter = FrsFree(FrsSearchContext->Filter);
    LDAP_FREE_MSG(FrsSearchContext->LdapMsg);
}


PWCHAR *
FrsDsGetValues(
    IN PLDAP Ldap,
    IN PWCHAR Base,
    IN PWCHAR DesiredAttr
    )
/*++
Routine Description:
    Return all of the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.

Return Value:
    The ldap array of values or NULL if the Base, DesiredAttr, or its values
    does not exist. The ldap array is freed with LDAP_FREE_VALUES().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetValues:"

    PLDAPMessage    Msg = NULL; // Opaque stuff from ldap subsystem
    PWCHAR          *Values;    // Array of values for desired attribute

    //
    // Search Base for all of this attribute + values (objectCategory=*)
    //
    if (!FrsDsLdapSearch(Ldap, Base, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         NULL, 0, &Msg)) {
        return NULL;
    }
    //
    // Return the values for the desired attribute
    //
    Values = (PWCHAR *)FrsDsFindValues(Ldap,
                                       ldap_first_entry(Ldap, Msg),
                                       DesiredAttr,
                                       FALSE);
    LDAP_FREE_MSG(Msg);
    return Values;
}

PWCHAR
FrsDsExtendDn(
    IN PWCHAR Dn,
    IN PWCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsExtendDn:"

    ULONG  Len;
    PWCHAR NewDn;

    if ((Dn == NULL) || (Cn == NULL)) {
        return NULL;
    }

    Len = wcslen(L"CN=,") + wcslen(Dn) + wcslen(Cn) + 1;
    NewDn = (PWCHAR)FrsAlloc(Len * sizeof(WCHAR));
    wcscpy(NewDn, L"CN=");
    wcscat(NewDn, Cn);
    wcscat(NewDn, L",");
    wcscat(NewDn, Dn);
    return NewDn;
}


PWCHAR
FrsDsExtendDnOu(
    IN PWCHAR Dn,
    IN PWCHAR Ou
    )
/*++
Routine Description:
    Extend an existing DN with a new OU= component.

Arguments:
    Dn  - distinguished name
    Ou  - orginizational name

Return Value:
    OU=Ou,Dn
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsExtendDnOu:"
    ULONG  Len;
    PWCHAR NewDn;

    if ((Dn  == NULL) || (Ou == NULL)) {
        return NULL;
    }

    Len = wcslen(L"OU=,") + wcslen(Dn) + wcslen(Ou) + 1;
    NewDn = (PWCHAR)FrsAlloc(Len * sizeof(WCHAR));
    wcscpy(NewDn, L"OU=");
    wcscat(NewDn, Ou);
    wcscat(NewDn, L",");
    wcscat(NewDn, Dn);
    return NewDn;
}


PWCHAR
FrsDsMakeRdn(
    IN PWCHAR DN
    )
/*++
Routine Description:
    Extract the base component (relative distinguished name) from a
    distinguished name. The distinguished name is assumed to be in
    DS format (CN=xyz,CN=next one,...). In this case, the returned
    RDN is "xyz".

Arguments:
    DN      - distinguished name

Return Value:
    A zero-terminated string. The string is freed with FrsFree().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsMakeRdn:"
    DWORD   RDNLen;
    PWCHAR  RDN;

    if (DN == NULL) {
        return NULL;
    }

    //
    // Skip the first CN=; if any
    //
    RDN = wcsstr(DN, L"cn=");
    if (RDN == DN) {
        DN += 3;
    }

    // Return the string up to the first delimiter or EOS
    RDNLen = wcscspn(DN, L",");
    RDN = (PWCHAR)FrsAlloc(sizeof(WCHAR) * (RDNLen + 1));
    wcsncpy(RDN, DN, RDNLen);
    RDN[RDNLen] = L'\0';

    return _wcsupr(RDN);
}



VOID
FrsDsCloseDs(
    VOID
    )
/*++
Routine Description:
    Unbind from the DS.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCloseDs:"
    DsBindingsAreValid = FALSE;
    if (gLdap) {
        ldap_unbind_s(gLdap);
        gLdap = NULL;
    }
    if (HANDLE_IS_VALID(DsHandle)) {
        DsUnBind(&DsHandle);
        DsHandle = NULL;
    }
    SitesDn     = FrsFree(SitesDn);
    ServicesDn  = FrsFree(ServicesDn);
    SystemDn    = FrsFree(SystemDn);
    ComputersDn = FrsFree(ComputersDn);
    DomainControllersDn = FrsFree(DomainControllersDn);
    DefaultNcDn = FrsFree(DefaultNcDn);
}


DWORD
FrsDsGetDcInfo(
    IN PDOMAIN_CONTROLLER_INFO *DcInfo,
    IN DWORD Flags
    )
/*++
Routine Description:
    Open and bind to a dc

Arguments:
    DcInfo  - Dc Info
    Flags   - DsGetDcName(Flags)

Return Value:
    DsGetDcName
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetDcInfo:"
    DWORD   WStatus;
    PWCHAR  DcName;
    DWORD   InfoFlags;
    CHAR    FlagBuffer[220];


    FrsFlagsToStr(Flags, DsGetDcNameFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    DPRINT2(4, ":DS: DsGetDcName (%08x) Flags [%s]\n", Flags, FlagBuffer);


    WStatus = DsGetDcName(NULL,    // Computer to remote to
                          NULL,    // Domain - use our own
                          NULL,    // Domain Guid
                          NULL,    // Site Guid
                          Flags,
                          DcInfo); // Return info

    CLEANUP1_WS(0, ":DS: ERROR - Could not get DC Info for %ws;",
                ComputerName, WStatus, RETURN);

    DcName = (*DcInfo)->DomainControllerName;

    FrsFlagsToStr(Flags, DsGetDcNameFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    DPRINT2(4, ":DS: DcInfo (flags are %08x) Flags [%s]\n", Flags, FlagBuffer);

    DPRINT1(4, ":DS:    DomainControllerName   : %ws\n", DcName);
    DPRINT1(4, ":DS:    DomainControllerAddress: %ws\n", (*DcInfo)->DomainControllerAddress);
    DPRINT1(4, ":DS:    DomainControllerType   : %08x\n",(*DcInfo)->DomainControllerAddressType);
    DPRINT1(4, ":DS:    DomainName             : %ws\n", (*DcInfo)->DomainName);
    DPRINT1(4, ":DS:    DnsForestName          : %ws\n", (*DcInfo)->DnsForestName);
    DPRINT1(4, ":DS:    DcSiteName             : %ws\n", (*DcInfo)->DcSiteName);
    DPRINT1(4, ":DS:    ClientSiteName         : %ws\n", (*DcInfo)->ClientSiteName);

    InfoFlags = (*DcInfo)->Flags;
    FrsFlagsToStr(InfoFlags, DsGetDcInfoFlagNameTable, sizeof(FlagBuffer), FlagBuffer);
    DPRINT2(4, ":DS:    InfoFlags              : %08x Flags [%s]\n",InfoFlags, FlagBuffer);

    DsDomainControllerName = FrsFree(DsDomainControllerName);
    DsDomainControllerName = FrsWcsDup(DcName);

    //
    // DCs should bind to the local DS to avoid ACL problems.
    //
    if (IsADc && DcName && (wcslen(DcName) > 2) &&
        _wcsnicmp(&DcName[2], ComputerName, wcslen(ComputerName))) {

        DPRINT3(0, ":DS: ERROR - The DC %ws is using the DS on DC %ws "
                "Some of the information in the DS"
                " may be unavailable to %ws; possibly disabling "
                "replication with some partners.\n",
                ComputerName, &DcName[2], ComputerName);
    }

RETURN:
    return WStatus;
}





VOID
FrsDsRegisterSpn(
    IN PLDAP Ldap,
    IN PCONFIG_NODE Computer
    )
/*++
Routine Description:
    Register the NtFrs SPN so that authenticated RPC calls can
    use SPN/FQDN as the target principal name

Arguments:
    Computer - Computer node from the ds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsRegisterSpn:"
    DWORD           WStatus;
    PWCHAR          Spn      = NULL;
    PWCHAR          SpnPrefix= NULL;
    PWCHAR          *SpnList = NULL;
    DWORD           SpnNum   = 0;
    static BOOL     RegisteredSpn = FALSE;

    //
    // No Ds binding or no computer or already registered
    //
    if (RegisteredSpn ||
        (ComputerDnsName[0] == L'\0') ||
        !DsBindingsAreValid ||
        !Computer ||
        !Computer->Dn) {
        return;
    }
    //
    // Register the NtFrs SPN so that authenticated RPC calls can
    // use SPN/FQDN as the target principal name
    //
    Spn = FrsAlloc((wcslen(ComputerDnsName) + wcslen(SERVICE_PRINCIPAL_NAME) + 2) * sizeof(WCHAR));
    wcscpy(Spn, SERVICE_PRINCIPAL_NAME);
    wcscat(Spn, L"/");
    wcscat(Spn, ComputerDnsName);

    SpnPrefix = FrsAlloc((wcslen(SERVICE_PRINCIPAL_NAME) + 1) * sizeof(WCHAR));
    wcscpy(SpnPrefix, SERVICE_PRINCIPAL_NAME);

    SpnList = FrsDsGetValues(Ldap, Computer->Dn, ATTR_SERVICE_PRINCIPAL_NAME);

    SpnNum=0;
    while ((SpnList != NULL)&& (SpnList[SpnNum] != NULL)) {
        DPRINT2(5, "Spn list from DS[%d] = %ws\n", SpnNum, SpnList[SpnNum]);
        if (!_wcsicmp(SpnList[SpnNum], Spn)) {
            // Spn found for NtFrs.
            DPRINT1(4, "SPN already registered for Ntfrs: %ws\n", SpnList[SpnNum]);
            RegisteredSpn = TRUE;
        } else if (!_wcsnicmp(SpnList[SpnNum], SpnPrefix, wcslen(SpnPrefix))) {
            //
            // An older SPN exists. Delete it.
            //
            DPRINT1(4, "Deleting stale SPN for Ntfrs: %ws\n", SpnList[SpnNum]);

            WStatus = DsWriteAccountSpn(DsHandle, DS_SPN_DELETE_SPN_OP, Computer->Dn, 1, &SpnList[SpnNum]);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT2_WS(1, "WARN - Delete DsWriteAccountSpn(%ws, %ws);", SpnList[SpnNum], Computer->Dn, WStatus);
            } else {
                DPRINT2(5, "Delete DsWriteAccountSpn(%ws, %ws); success\n", SpnList[SpnNum], Computer->Dn);
            }
        }
        ++SpnNum;
    }

    if (!RegisteredSpn) {

        DPRINT1(4, "Registering SPN for Ntfrs; %ws\n", Spn);
        WStatus = DsWriteAccountSpn(DsHandle, DS_SPN_ADD_SPN_OP, Computer->Dn, 1, &Spn);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(1, "WARN - Add DsWriteAccountSpn(%ws, %ws);", Spn, Computer->Dn, WStatus);
        } else {
            DPRINT2(5, "Add DsWriteAccountSpn(%ws, %ws); success\n", Spn, Computer->Dn);
            RegisteredSpn = TRUE;
        }
    }

    FrsFree(Spn);
    FrsFree(SpnPrefix);

    //
    // Free ldap's array of values
    //
    LDAP_FREE_VALUES(SpnList);

}


BOOL
FrsDsBindDs(
    IN DWORD    Flags
    )
/*++
Routine Description:
    Open and bind to a domain controller.

Arguments:
    Flags - For FrsDsGetDcInfo()

Return Value:
    None. Sets global handles for FrsDsOpenDs().
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsBindDs:"
    DWORD           WStatus;
    DWORD           LStatus    = LDAP_SUCCESS;
    PWCHAR          DcAddr;
    PWCHAR          DcName;
    PWCHAR          DcDnsName;
    BOOL            Bound = FALSE;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    struct l_timeval Timeout;

#define MAX_DC_NAMELIST 8
    ULONG           NameListx, i;
    PWCHAR          NameList[MAX_DC_NAMELIST];
    ULONG           ulOptions;


    //
    // Bind to the local DS if this computer is a DC
    //
    gLdap = NULL;
    if (IsADc) {
        DcAddr = NULL;
        DcName = ComputerName;
        DcDnsName = ComputerDnsName;
    } else {
        //
        // Not a DC; find any DC for this domain
        //
        WStatus = FrsDsGetDcInfo(&DcInfo, Flags);
        CLEANUP2_WS(0, ":DS: ERROR - FrsDsGetDcInfo(%08x, %ws);",
                    Flags, ComputerName, WStatus, CLEANUP);

        //
        // Binding address
        //
        DcAddr = DcInfo->DomainControllerAddress;
        DcName = NULL;
        DcDnsName = DcInfo->DomainControllerName;
    }
    FRS_ASSERT(DcDnsName || DcName || DcAddr);

    //
    // Open the ldap server using various forms of the DC's name
    //
    NameListx = 0;
    if (DcDnsName &&
        (wcslen(DcDnsName) > 2) && DcDnsName[0] == L'\\' &&  DcDnsName[1] == L'\\') {

        // Trim the "\\"
        NameList[NameListx++] = DcDnsName + 2;
    }


    if (DcAddr &&
        (wcslen(DcAddr) > 2) &&  DcAddr[0] == L'\\' &&  DcAddr[1] == L'\\') {

        // Trim the "\\"
        NameList[NameListx++] = DcAddr + 2;
    }

    NameList[NameListx++] = DcDnsName;
    NameList[NameListx++] = DcName;
    NameList[NameListx++] = DcAddr;

    FRS_ASSERT(NameListx <= MAX_DC_NAMELIST);


    ulOptions = PtrToUlong(LDAP_OPT_ON);
    Timeout.tv_sec = LdapBindTimeoutInSeconds;
    Timeout.tv_usec = 0;

    for (i=0; i<NameListx; i++) {
        if (NameList[i] != NULL) {

            //
            // if ldap_open is called with a server name the api will call DsGetDcName
            // passing the server name as the domainname parm...bad, because
            // DsGetDcName will make a load of DNS queries based on the server name,
            // it is designed to construct these queries from a domain name...so all
            // these queries will be bogus, meaning they will waste network bandwidth,
            // time to fail, and worst case cause expensive on demand links to come up
            // as referrals/forwarders are contacted to attempt to resolve the bogus
            // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option
            // after the ldap_init but before any other operation using the ldap
            // handle from ldap_init, the delayed connection setup will not call
            // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client
            // will detect that and use the address directly.
            //
            // gLdap = ldap_open(NameList[i], LDAP_PORT);
            gLdap = ldap_init(NameList[i], LDAP_PORT);
            if (gLdap != NULL) {
                ldap_set_option(gLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);
                LStatus = ldap_connect(gLdap, &Timeout);

                if (LStatus != LDAP_SUCCESS) {
                    DPRINT1_LS(1, ":DS: WARN - ldap_connect(%ws);", NameList[i], LStatus);
                    ldap_unbind_s(gLdap);
                    gLdap = NULL;
                } else {
                    //
                    // Successfully connected.
                    //
                    DPRINT1(5, ":DS: ldap_connect(%ws) succeeded\n", NameList[i]);
                    break;
                }

            }
        }
    }

    //
    // Whatever it is, we can't find it.
    //
    if (!gLdap) {
//        DPRINT3_WS(0, ":DS: ERROR - ldap_open(DNS %ws, BIOS %ws, IP %ws);",
//                   DcDnsName, DcName, DcAddr, WStatus);
        DPRINT3_LS(0, ":DS: ERROR - ldap_init(DNS %ws, BIOS %ws, IP %ws);",
                   DcDnsName, DcName, DcAddr, LStatus);
        goto CLEANUP;
    }

    //
    // Bind to the ldap server
    //
    LStatus = ldap_bind_s(gLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    CLEANUP_LS(0, ":DS: ERROR - Binding to DS.", LStatus, CLEANUP);

    //
    // Bind to the Ds (for various Ds calls such as DsCrackName())
    //

    NameListx = 0;
    NameList[NameListx++] = DcDnsName;
    NameList[NameListx++] = DcName;
    NameList[NameListx++] = DcAddr;

    FRS_ASSERT(NameListx <= MAX_DC_NAMELIST);

    WStatus = ERROR_RETRY;
    for (i=0; i<NameListx; i++) {
        if (NameList[i] != NULL) {
            WStatus = DsBind(NameList[i], NULL, &DsHandle);
            if (!WIN_SUCCESS(WStatus)) {
                DsHandle = NULL;
                DPRINT1_WS(1, ":DS: WARN - DsBind(%ws);", NameList[i], WStatus);
            } else {
                DPRINT1(5, ":DS: DsBind(%ws) succeeded\n", NameList[i]);
                break;
            }
        }
    }

    //
    // Whatever it is, we can't find it
    //
    CLEANUP3_WS(0, ":DS: ERROR - DsBind(DNS %ws, BIOS %ws, IP %ws);",
                DcDnsName, DcName, DcAddr, WStatus, CLEANUP);

    //
    // SUCCESS
    //
    Bound = TRUE;

CLEANUP:
    //
    // Cleanup
    //
    if (!Bound) {
        //
        // Close the connection to release resources if the above failed.
        //
        if (gLdap) {
            ldap_unbind_s(gLdap);
            gLdap = NULL;
        }
    }

    if (DcInfo) {
        NetApiBufferFree(DcInfo);
        DcInfo = NULL;
    }

    return Bound;
}


BOOL
FrsDsOpenDs(
    VOID
    )
/*++
Routine Description:
    Open and bind to a primary domain controller. The DN of the
    sites container is a sideeffect.

Arguments:
    DefaultDn

Return Value:
    Bound ldap structure or NULL

        Sets the following globals -

        SitesDn
        ServicesDn
        SystemDn
        ComputersDn
        DomainControllersDn
        DefaultNcDn

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsOpenDs:"
    DWORD           WStatus;
    DWORD           LStatus;
    DWORD           NumVals;
    PWCHAR          Config;
    PLDAPMessage    LdapEntry;
    PLDAPMessage    LdapMsg = NULL;
    PWCHAR          *Values = NULL;
    PWCHAR          Attrs[3];

    //
    // Time to clean up and exit
    //
    if (FrsIsShuttingDown || DsIsShuttingDown) {
        goto ERROR_BINDING;
    }

    //
    // Use existing bindings if possible
    //
    if (DsBindingsAreValid) {
        return TRUE;
    }

    //
    // The previous poll might have set DsBindingsAreValid to FALSE because one
    // of the handle became invalid. In that case the other handles still need to be
    // closed to prevent leak.
    //
    FrsDsCloseDs();

    //
    // Increment the DS Bindings counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, DSBindings, 1);

    //
    // Bind to a DS.
    //
    // Note the behavior of DsGetDcName for the following four flag combinations.
    //
    // DS_BACKGROUND_ONLY                     (as of 10/10/99)
    //             DS_FORCE_REDISCOVERY
    //    Zero        Zero      Netlogon will attempt to satisfy the request via
    //                          cached info, negative cache entries will be
    //                          returned if they are less than 5 minutes old.
    //                          If it can't it will do a full discovery (dns
    //                          queries, udp pings, poss netbt queries,
    //                          mailslot datagrams, etc)
    //
    //    Zero        One       Netlogon will do a full discovery.
    //
    //    One         Zero      Netlogon will satisfy from the cache, unless the
    //                          backoff routine allows for a retry at this time
    //                          *and* the cache is insufficient.
    //
    //    One         One       The DS_BACKGROUND_ONY flag is ignored, treated
    //                          as a FORCE call.
    //
    if (!FrsDsBindDs(DS_DIRECTORY_SERVICE_REQUIRED |
                     DS_WRITABLE_REQUIRED          |
                     DS_BACKGROUND_ONLY)) {
        //
        // Flush the cache and try again
        //
        DPRINT(1, ":DS: WARN - FrsDsBindDs(no force) failed\n");
        //
        // Because of the use of Dial-up lines at sites without a DC we don't
        // want to use DS_FORCE_REDISCOVERY since that will defeat the generic
        // DC discovery backoff algorithm thus causing FRS to constantly bring
        // up the line.  Bug 412620.
        //FrsDsCloseDs();   // close ldap handle before doing reopen.
        //if (!FrsDsBindDs(DS_DIRECTORY_SERVICE_REQUIRED |
        //                 DS_WRITABLE_REQUIRED          |
        //                 DS_FORCE_REDISCOVERY)) {
        //    DPRINT(1, ":DS: WARN - FrsDsBindDs(force) failed\n");
            goto ERROR_BINDING;
        //}
    }
    DPRINT(4, ":DS: FrsDsBindDs() succeeded\n");

    //
    // Find the naming contexts and the default naming context (objectCategory=*)
    //
    MK_ATTRS_2(Attrs, ATTR_NAMING_CONTEXTS, ATTR_DEFAULT_NAMING_CONTEXT);

    if (!FrsDsLdapSearch(gLdap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         Attrs, 0, &LdapMsg)) {
        goto ERROR_BINDING;
    }

    LdapEntry = ldap_first_entry(gLdap, LdapMsg);
    if (LdapEntry == NULL) {
        goto ERROR_BINDING;
    }

    Values = (PWCHAR *)FrsDsFindValues(gLdap, LdapEntry, ATTR_NAMING_CONTEXTS, FALSE);
    if (Values == NULL) {
        goto ERROR_BINDING;
    }

    //
    // Now, find the naming context that begins with "CN=Configuration"
    //
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        FRS_WCSLWR(Values[NumVals]);
        Config = wcsstr(Values[NumVals], CONFIG_NAMING_CONTEXT);
        if (Config && Config == Values[NumVals]) {
            //
            // Build the pathname for "configuration\sites & services"
            //
            SitesDn = FrsDsExtendDn(Config, CN_SITES);
            ServicesDn = FrsDsExtendDn(Config, CN_SERVICES);
            break;
        }
    }
    LDAP_FREE_VALUES(Values);



    //
    // Finally, find the default naming context
    //
    Values = (PWCHAR *)FrsDsFindValues(gLdap, LdapEntry, ATTR_DEFAULT_NAMING_CONTEXT, FALSE);
    if (Values == NULL) {
        goto ERROR_BINDING;
    }
    DefaultNcDn = FrsWcsDup(Values[0]);
    ComputersDn = FrsDsExtendDn(DefaultNcDn, CN_COMPUTERS);
    SystemDn = FrsDsExtendDn(DefaultNcDn, CN_SYSTEM);
    DomainControllersDn = FrsDsExtendDnOu(DefaultNcDn, CN_DOMAIN_CONTROLLERS);
    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);

    //
    // Polling the ds requires all these distinguished names
    //
    if ((SitesDn == NULL)     || (ServicesDn == NULL)  || (SystemDn == NULL) ||
        (DefaultNcDn == NULL) || (ComputersDn == NULL) || (DomainControllersDn == NULL)) {
        goto ERROR_BINDING;
    }

    //
    // SUCCESS
    //
    DsBindingsAreValid = TRUE;
    return TRUE;

ERROR_BINDING:
    //
    // avoid extraneous error messages during shutdown
    //
    if (!FrsIsShuttingDown && !DsIsShuttingDown) {
        DPRINT(0, ":DS: ERROR - Could not open the DS\n");
    }
    //
    // Cleanup
    //
    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);

    //
    // No ds bindings
    //
    FrsDsCloseDs();

    //
    // Increment the DS Bindings in Error counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, DSBindingsError, 1);

    return FALSE;
}


#if DBG
#define FRS_PRINT_TREE(_Hdr_, _Sites_)  FrsDsFrsPrintTree(_Hdr_, _Sites_)
VOID
FrsDsFrsPrintTree(
    IN PWCHAR       Hdr,
    IN PCONFIG_NODE Sites
    )
/*++
Routine Description:
    print the tree.

Arguments:
    Hdr     - prettyprint
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFrsPrintTree:"
    PCONFIG_NODE    Site;
    PCONFIG_NODE    Settings;
    PCONFIG_NODE    Set;
    PCONFIG_NODE    Server;
    PCONFIG_NODE    Cxtion;
    CHAR            Guid[GUID_CHAR_LEN + 1];

    if (Sites == NULL) {
        return;
    }

    if (Hdr) {
        DPRINT1(5, ":DS: %ws\n", Hdr);
    }

    //
    // Print the tree
    //
    for (Site = Sites; Site; Site = Site->Peer) {

        GuidToStr(Site->Name->Guid, Guid);
        DPRINT2(5, ":DS: %ws (%ws)\n", Site->Name->Name,
                (Site->Consistent) ? L"Consistent" : L"InConsistent");

        for (Settings = Site->Children; Settings; Settings = Settings->Peer) {

            if (Settings->Name) {
                GuidToStr(Settings->Name->Guid, Guid);
                DPRINT2(5, ":DS:    %ws (%ws)\n", Settings->Name->Name,
                        (Settings->Consistent) ? L"Consistent" : L"InConsistent");
            } else {
                DPRINT(5, ":DS:    nTDSSettings\n");
            }

            for (Set = Settings->Children; Set; Set = Set->Peer) {

                GuidToStr(Set->Name->Guid, Guid);
                DPRINT2(5, ":DS:       %ws (%ws)\n", Set->Name->Name,
                        (Set->Consistent) ? L"Consistent" : L"InConsistent");

                for (Server = Set->Children; Server; Server = Server->Peer) {

                    GuidToStr(Server->Name->Guid, Guid);
                    DPRINT3(5, ":DS:          %ws %ws (%ws)\n",
                            Server->Name->Name, Server->Root,
                            (Server->Consistent) ? L"Consistent" : L"InConsistent");

                    for (Cxtion = Server->Children; Cxtion; Cxtion = Cxtion->Peer) {

                        GuidToStr(Cxtion->Name->Guid, Guid);
                        DPRINT4(5, ":DS:             %ws %ws %ws) (%ws)\n",
                                Cxtion->Name->Name,
                                (Cxtion->Inbound) ? L"IN (From" : L"OUT (To",
                                Cxtion->PartnerName->Name,
                                (Cxtion->Consistent) ? L"Consistent" : L"InConsistent");
                    }
                }
            }
        }
    }
    if (Hdr) {
        DPRINT1(5, ":DS: %ws DONE\n", Hdr);
    } else {
        DPRINT(5, ":DS: DONE\n");
    }
}
#else DBG
#define FRS_PRINT_TREE(_Hdr_, _Sites_)
#endif DBG


VOID
FrsDsTreeLink(
    IN PCONFIG_NODE Parent,
    IN PCONFIG_NODE Node
    )
/*++
Routine Description:
    Link the node into the tree and keep a running "change checksum"
    to compare with the previous tree. We don't use a DS that is in
    flux. We wait until two polling cycles return the same "change
    checksum" before using the DS data.

Arguments:
    Entry   - Current entry from the DS
    Parent  - Container which contains Base

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsTreeLink:"
    ULONG           i;
    ULONG           LenChanged; // length of Changed

    DPRINT3(5, ":DS: Linking node type %ws, node name %ws to parent %ws\n",
            DsConfigTypeName[Node->DsObjectType],
            (Node->Name)   ? Node->Name->Name : L"null",
            (Parent->Name) ? Parent->Name->Name : L"null");

    //
    // Link into config
    //
    ++Parent->NumChildren;
    Node->Parent = Parent;
    Node->Peer = Parent->Children;
    Parent->Children = Node;

    //
    // Some indication that the DS is stable
    //
    if (Node->UsnChanged) {
        LenChanged = wcslen(Node->UsnChanged);
        for (i = 0; i < LenChanged; ++i) {
            ThisChange += *(Node->UsnChanged + i);   // sum
            NextChange += ThisChange;       // sum of sums (order dependent)
        }
    }
}


PCONFIG_NODE
FrsDsAllocBasicNode(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN ULONG        NodeType
    )
/*++
Routine Description:
    Allocate a Node and fill in the fields common to all or most nodes.
    (guid, name, dn, schedule, and usnchanged)

Arguments:
    Ldap        - opened and bound ldap connection
    LdapEntry   - from ldap_first/next_entry
    NodeType    - Internal type code for the object represented by this node.

Return Value:
    NULL if basic node cannot be allocated
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsAllocBasicNode:"
    PCONFIG_NODE    Node;

    //
    // Increment the DS Objects counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, DSObjects, 1);

    //
    // Initially, the node is assumed to be consistent
    //
    Node = FrsAllocType(CONFIG_NODE_TYPE);
    Node->Consistent = TRUE;
    Node->DsObjectType = NodeType;

    //
    // A dummy entry can be created by passing NULL for LdapEntry.
    //
    if (LdapEntry == NULL) {
        return Node;
    }
    //
    // Distinguished name
    //
    Node->Dn = FrsDsFindValue(Ldap, LdapEntry, ATTR_DN);
    FRS_WCSLWR(Node->Dn);

    //
    // Name = RDN + Object Guid
    //
    Node->Name = FrsBuildGName(FrsDsFindGuid(Ldap, LdapEntry),
                               FrsDsMakeRdn(Node->Dn));

    //
    // Schedule, if any
    //
    Node->Schedule = FrsDsFindSchedule(Ldap, LdapEntry, &Node->ScheduleLength);

    //
    // USN Changed
    //
    Node->UsnChanged = FrsDsFindValue(Ldap, LdapEntry, ATTR_USN_CHANGED);

    if (!Node->Dn || !Node->Name->Name || !Node->Name->Guid) {

        //
        // Increment the DS Objects in Error counter
        //
        PM_INC_CTR_SERVICE(PMTotalInst, DSObjectsError, 1);

        DPRINT3(0, ":DS: ERROR - Ignoring node; lacks dn (%08x), rdn (%08x), or guid (%08x)\n",
                Node->Dn, Node->Name->Name, Node->Name->Guid);
        Node = FrsFreeType(Node);
    }

    return Node;
}


#define NUM_EQUALS (4)
ULONG
FrsDsSameSite(
    IN PWCHAR       NtDsSettings1,
    IN PWCHAR       NtDsSettings2
    )
/*++
Routine Description:
    Are the ntds settings in the same site?

Arguments:
    NtDsSettings1   - NtDs Settings FQDN
    NtDsSettings2   - NtDs Settings FQDN

Return Value:
    TRUE    - Same site
    FALSE   - Not
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsSameSite:"
    PWCHAR  Equal1 = NULL;
    PWCHAR  Equal2 = NULL;
    DWORD   EqualsFound;

    if (!NtDsSettings1 || !NtDsSettings2) {
        return TRUE;
    }

    //
    // Forth equals sign
    //
    for (EqualsFound = 0; *NtDsSettings1 != L'\0'; ++NtDsSettings1) {
        if (*NtDsSettings1 != L'=') {
            continue;
        }
        if (++EqualsFound == NUM_EQUALS) {
            Equal1 = NtDsSettings1;
            break;
        }
    }
    //
    // Forth equals sign
    //
    for (EqualsFound = 0; *NtDsSettings2 != L'\0'; ++NtDsSettings2) {
        if (*NtDsSettings2 != L'=') {
            continue;
        }
        if (++EqualsFound == NUM_EQUALS) {
            Equal2 = NtDsSettings2;
            break;
        }
    }
    //
    // Not the same length
    //
    if (!Equal1 || !Equal2) {
        return TRUE;
    }

    //
    // Compare up to the first comma
    //
    while (*Equal1 == *Equal2 && (*Equal1 && *Equal1 != L',')) {
        ++Equal1;
        ++Equal2;
    }
    DPRINT3(4, ":DS: %s: %ws %ws\n",
            (*Equal1 == *Equal2) ? "SAME SITE" : "DIFF SITE", Equal1, Equal2);

    return (*Equal1 == *Equal2);
}


DWORD
FrsDsResolveCxtionConflict(
    IN PCONFIG_NODE OldCxtion,
    IN PCONFIG_NODE NewCxtion,
    IN PCONFIG_NODE *Winner,
    IN PCONFIG_NODE *Loser
    )
/*++
Routine Description:
    Resolve the connection conflict.

Arguments:
    OldCxtion
    NewCxtion
    Winner
    Loser

Return Value:
    WIN32 Status
--*/
{

    //
    // Compare the guids and pick a connection. This ensures that both the members
    // at the ends of each connection pick the same one.
    //
    if ((OldCxtion != NULL) && (NewCxtion != NULL) &&
        (OldCxtion->Name != NULL) && (NewCxtion->Name != NULL) &&
        (memcmp(OldCxtion->Name->Guid, NewCxtion->Name->Guid, sizeof(GUID)) > 0) ) {

        *Winner = NewCxtion;
        *Loser = OldCxtion;
    } else {

        *Winner = OldCxtion;
        *Loser = NewCxtion;
    }

    //
    // Add to the poll summary event log.
    //
    FrsDsAddToPollSummary3ws(IDS_POLL_SUM_CXTION_CONFLICT, (*Winner)->Dn,
                             (*Loser)->Dn, (*Winner)->Dn);

    return ERROR_SUCCESS;
}


DWORD
FrsDsResolveSubscriberConflict(
    IN PCONFIG_NODE OldSubscriber,
    IN PCONFIG_NODE NewSubscriber,
    IN PCONFIG_NODE *Winner,
    IN PCONFIG_NODE *Loser
    )
/*++
Routine Description:
    Resolve the subscriber conflict.

Arguments:
    OldSubscriber
    NewSubscriber
    Winner
    Loser

Return Value:
    WIN32 Status
--*/
{

    *Winner = OldSubscriber;
    *Loser = NewSubscriber;

    //
    // Add to the poll summary event log.
    //
    FrsDsAddToPollSummary3ws(IDS_POLL_SUM_SUBSCRIBER_CONFLICT, (*Winner)->Dn,
                             (*Loser)->Dn, (*Winner)->Dn);

    return ERROR_SUCCESS;
}


ULONG
FrsDsGetNonSysvolInboundCxtions(
    IN PLDAP        Ldap,
    IN PWCHAR       SetDn,
    IN PWCHAR       MemberRef
    )
/*++
Routine Description:
    Fetch the non-sysvol inbound connections and add them
    to the CxtionTable. Check for multiple connections between the
    same partners and resolve the conflict.

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection.
    SetDn       - Dn of the set being processed.
    MemberRef   - Member reference from the subscriber object.

Return Value:
    ERROR_SUCCESS - config fetched successfully
    Otherwise     - couldn't get the DS config
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetNonSysvolInboundCxtions:"
    PWCHAR          Attrs[8];
    PLDAPMessage    Entry;                       // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;                        // generic node for the tree
    PWCHAR          TempFilter           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PWCHAR          PartnerCn            = NULL;
    PGEN_ENTRY      ConflictingNodeEntry = NULL;
    PCONFIG_NODE    ConflictingNode      = NULL;
    PCONFIG_NODE    Winner               = NULL;
    PCONFIG_NODE    Loser                = NULL;
    BOOL            Inbound;
    PWCHAR          Options              = NULL;

    //
    // Look for all the connections under our member object.
    //
    MK_ATTRS_7(Attrs, ATTR_DN, ATTR_SCHEDULE, ATTR_FROM_SERVER, ATTR_OBJECT_GUID,
                      ATTR_USN_CHANGED, ATTR_ENABLED_CXTION, ATTR_OPTIONS);

    if (!FrsDsLdapSearchInit(Ldap, MemberRef, LDAP_SCOPE_ONELEVEL, CATEGORY_CXTION,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - There are no connection objects in %ws!\n", MemberRef);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL;
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_IN_CXTION);
        if (!Node) {
            DPRINT(4, ":DS: Cxtion lacks basic info; skipping\n");
            continue;
        }
        Node->EnabledCxtion = FrsDsFindValue(Ldap, Entry, ATTR_ENABLED_CXTION);
        if (Node->EnabledCxtion && WSTR_EQ(Node->EnabledCxtion, ATTR_FALSE)) {
            DPRINT2(1, ":DS: WARN - enabledConnection set to %ws; Ignoring %ws\n",
                    Node->EnabledCxtion, Node->Name->Name);
            Node = FrsFreeType(Node);
            continue;
        }

        //
        // Read the options value on the connection object.
        // We are intersted in the NTDSCONN_OPT_TWOWAY_SYNC flag and the
        // priority on connections.
        //
        Options = FrsDsFindValue(Ldap, Entry, ATTR_OPTIONS);
        if (Options != NULL) {
            Node->CxtionOptions = _wtoi(Options);
            Options = FrsFree(Options);
        } else {
            Node->CxtionOptions = 0;
        }

        //
        // These are inbound connections.
        //
        Node->Inbound = TRUE;

        //
        // Node's partner's name.
        //
        Node->PartnerDn = FrsDsFindValue(Ldap, Entry, ATTR_FROM_SERVER);
        FRS_WCSLWR(Node->PartnerDn);

        //
        // Add the Inbound cxtion to the cxtion table.
        //
        ConflictingNodeEntry = GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);
        GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

        if (ConflictingNodeEntry) {
            ConflictingNode = ConflictingNodeEntry->Data;
            FrsDsResolveCxtionConflict(ConflictingNode, Node, &Winner, &Loser);
            if (WSTR_EQ(Winner->Dn, Node->Dn)) {
                //
                // The new one is the winner. Remove old one and insert new one.
                //
                GTabDelete(CxtionTable,ConflictingNodeEntry->Key1,ConflictingNodeEntry->Key2, NULL);
                GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);

                GTabDelete(AllCxtionsTable,ConflictingNode->PartnerDn, (PVOID)&ConflictingNode->Inbound, NULL);
                GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

                FrsFreeType(ConflictingNode);
            } else {
                //
                // The old one is the winner. Leave it in the table.
                //
                FrsFreeType(Node);
                continue;
            }
        } else {

            //
            // If there is no conflict then we need to add this Member to the MemberSearchFilter
            // if it is not already there. It could have been added while processing the oubound connections.
            //
            Inbound = FALSE;
            if (GTabLookupTableString(CxtionTable, Node->PartnerDn, (PWCHAR)&Inbound) == NULL) {
                PartnerCn = FrsDsMakeRdn(Node->PartnerDn);
                if (MemberSearchFilter != NULL) {
                    TempFilter = FrsAlloc((wcslen(MemberSearchFilter) + wcslen(L"(=)" ATTR_CN) +
                                           wcslen(PartnerCn) + 1 ) * sizeof(WCHAR));
                    wcscpy(TempFilter, MemberSearchFilter);
                    wcscat(TempFilter, L"("  ATTR_CN  L"=" );
                    wcscat(TempFilter, PartnerCn);
                    wcscat(TempFilter, L")");
                    FrsFree(MemberSearchFilter);
                    MemberSearchFilter = TempFilter;
                    TempFilter = NULL;
                } else {
                    MemberSearchFilter = FrsAlloc((wcslen(L"(|(=)" ATTR_CN) +
                                                   wcslen(PartnerCn) + 1 ) * sizeof(WCHAR));
                    wcscpy(MemberSearchFilter, L"(|("  ATTR_CN  L"=" );
                    wcscat(MemberSearchFilter, PartnerCn);
                    wcscat(MemberSearchFilter, L")");
                }
                FrsFree(PartnerCn);
            }
        }

    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    return ERROR_SUCCESS;
}


ULONG
FrsDsGetNonSysvolOutboundCxtions(
    IN PLDAP        Ldap,
    IN PWCHAR       SetDn,
    IN PWCHAR       MemberRef
    )
/*++
Routine Description:
    Fetch the non-sysvol outbound connections and add them
    to the CxtionTable. Check for multiple connections between the
    same partners and resolve the conflict.

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection.
    SetDn       - Dn of the set being processed.
    MemberRef   - Member reference from the subscriber object.

Return Value:
    ERROR_SUCCESS - config fetched successfully
    Otherwise     - couldn't get the DS config
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetNonSysvolOutboundCxtions:"
    PWCHAR          Attrs[8];
    PLDAPMessage    Entry;                       // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;                        // generic node for the tree
    PWCHAR          SearchFilter         = NULL;
    PWCHAR          TempFilter           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PWCHAR          PartnerCn            = NULL;
    PGEN_ENTRY      ConflictingNodeEntry = NULL;
    PCONFIG_NODE    ConflictingNode      = NULL;
    PCONFIG_NODE    Winner               = NULL;
    PCONFIG_NODE    Loser                = NULL;
    PWCHAR          Options              = NULL;

    //
    // Look for all the connections that have our member as the from server.
    // Filter will look like (&(objectCategory=nTDSConnection)(fromServer=cn=member1,cn=set1,...))
    //

    MK_ATTRS_7(Attrs, ATTR_DN, ATTR_SCHEDULE, ATTR_FROM_SERVER, ATTR_OBJECT_GUID,
                      ATTR_USN_CHANGED, ATTR_ENABLED_CXTION, ATTR_OPTIONS);

    SearchFilter = FrsAlloc((wcslen(L"(&(=))"  CATEGORY_CXTION  ATTR_FROM_SERVER) +
                             wcslen(MemberRef) + 1) * sizeof(WCHAR));
    wcscpy(SearchFilter,L"(&"  CATEGORY_CXTION  L"("  ATTR_FROM_SERVER  L"=" );
    wcscat(SearchFilter,MemberRef);
    wcscat(SearchFilter,L"))");

    if (!FrsDsLdapSearchInit(Ldap, SetDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                         Attrs, 0, &FrsSearchContext)) {
        SearchFilter = FrsFree(SearchFilter);
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No outbound connections found for member %ws!\n", MemberRef);
    }

    SearchFilter = FrsFree(SearchFilter);

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL;
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_IN_CXTION);
        if (!Node) {
            DPRINT(4, ":DS: Cxtion lacks basic info; skipping\n");
            continue;
        }
        Node->EnabledCxtion = FrsDsFindValue(Ldap, Entry, ATTR_ENABLED_CXTION);
        if (Node->EnabledCxtion && WSTR_EQ(Node->EnabledCxtion, ATTR_FALSE)) {
            DPRINT2(1, ":DS: WARN - enabledConnection set to %ws; Ignoring %ws\n",
                    Node->EnabledCxtion, Node->Name->Name);
            Node = FrsFreeType(Node);
            continue;
        }

        //
        // Read the options value on the connection object.
        // We are only intersted in the NTDSCONN_OPT_TWOWAY_SYNC flag.
        //
        Options = FrsDsFindValue(Ldap, Entry, ATTR_OPTIONS);
        if (Options != NULL) {
            Node->CxtionOptions = _wtoi(Options);
            Options = FrsFree(Options);
        } else {
            Node->CxtionOptions = 0;
        }
        //
        // These are outbound connections.
        //
        Node->Inbound = FALSE;

        //
        // Node's partner's name. This is an outbound connection. Get the
        // partners Dn by going one level up from the connection to the
        // member Dn.
        //
        Node->PartnerDn = FrsWcsDup(wcsstr(Node->Dn + 3, L"cn="));
        FRS_WCSLWR(Node->PartnerDn);

        //
        // Add the outbound cxtion to the cxtion table.
        //
        ConflictingNodeEntry = GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);
        GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

        if (ConflictingNodeEntry) {
            ConflictingNode = ConflictingNodeEntry->Data;
            FrsDsResolveCxtionConflict(ConflictingNode, Node, &Winner, &Loser);
            if (WSTR_EQ(Winner->Dn, Node->Dn)) {
                //
                // The new one is the winner. Remove old one and insert new one.
                //
                GTabDelete(CxtionTable,ConflictingNodeEntry->Key1,ConflictingNodeEntry->Key2, NULL);
                GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);

                GTabDelete(AllCxtionsTable,ConflictingNode->PartnerDn, (PVOID)&ConflictingNode->Inbound, NULL);
                GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

                FrsFreeType(ConflictingNode);
            } else {
                //
                // The old one is the winner. Leave it in the table.
                //
                FrsFreeType(Node);
                continue;
            }
        } else {
            //
            // If there is no conflict then we need to add this Member to the MemberSearchFilter.
            //
            PartnerCn = FrsDsMakeRdn(Node->PartnerDn);
            if (MemberSearchFilter != NULL) {
                TempFilter = FrsAlloc((wcslen(MemberSearchFilter) + wcslen(L"(=)"  ATTR_CN) +
                                       wcslen(PartnerCn) + 1 ) * sizeof(WCHAR));
                wcscpy(TempFilter, MemberSearchFilter);
                wcscat(TempFilter, L"("  ATTR_CN  L"=");
                wcscat(TempFilter, PartnerCn);
                wcscat(TempFilter, L")");
                FrsFree(MemberSearchFilter);
                MemberSearchFilter = TempFilter;
                TempFilter = NULL;
            } else {
                MemberSearchFilter = FrsAlloc((wcslen(L"(|(=)"  ATTR_CN) +
                                               wcslen(PartnerCn) + 1 ) * sizeof(WCHAR));
                wcscpy(MemberSearchFilter, L"(|("  ATTR_CN  L"=");
                wcscat(MemberSearchFilter, PartnerCn);
                wcscat(MemberSearchFilter, L")");
            }
            FrsFree(PartnerCn);
        }

    }

    FrsDsLdapSearchClose(&FrsSearchContext);

    return ERROR_SUCCESS;
}


ULONG
FrsDsGetSysvolInboundCxtions(
    IN PLDAP        Ldap,
    IN PWCHAR       SettingsDn
    )
/*++
Routine Description:
    Fetch the sysvol inbound connections and add them
    to the CxtionTable. Check for multiple connections between the
    same partners and resolve the conflict.

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection.
    SettingsDn  - server reference from the member object.

Return Value:
    ERROR_SUCCESS - config fetched successfully
    Otherwise     - couldn't get the DS config
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSysvolInboundCxtions:"
    PWCHAR          Attrs[7];
    PLDAPMessage    Entry;                       // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;                        // generic node for the tree
    PWCHAR          TempFilter           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PGEN_ENTRY      ConflictingNodeEntry = NULL;
    PCONFIG_NODE    ConflictingNode      = NULL;
    PCONFIG_NODE    Winner               = NULL;
    PCONFIG_NODE    Loser                = NULL;
    BOOL            Inbound;

    //
    // Look for all the connections under our member object.
    //
    MK_ATTRS_6(Attrs, ATTR_DN, ATTR_SCHEDULE, ATTR_FROM_SERVER, ATTR_OBJECT_GUID,
                      ATTR_USN_CHANGED, ATTR_ENABLED_CXTION);

    if (!FrsDsLdapSearchInit(Ldap, SettingsDn, LDAP_SCOPE_ONELEVEL, CATEGORY_CXTION,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No sysvol inbound connections found for object %ws!\n", SettingsDn);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL;
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_IN_CXTION);
        if (!Node) {
            DPRINT(4, ":DS: Cxtion lacks basic info; skipping\n");
            continue;
        }
        Node->EnabledCxtion = FrsDsFindValue(Ldap, Entry, ATTR_ENABLED_CXTION);
        if (Node->EnabledCxtion && WSTR_EQ(Node->EnabledCxtion, ATTR_FALSE)) {
            DPRINT2(1, ":DS: WARN - enabledConnection set to %ws; Ignoring %ws\n",
                    Node->EnabledCxtion, Node->Name->Name);
            Node = FrsFreeType(Node);
            continue;
        }

        //
        // These are inbound connections.
        //
        Node->Inbound = TRUE;

        //
        // Node's partner's name.
        //
        Node->PartnerDn = FrsDsFindValue(Ldap, Entry, ATTR_FROM_SERVER);
        FRS_WCSLWR(Node->PartnerDn);

        //
        // Add the Inbound cxtion to the cxtion table.
        //
        ConflictingNodeEntry = GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);
        GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

        if (ConflictingNodeEntry) {
            ConflictingNode = ConflictingNodeEntry->Data;
            FrsDsResolveCxtionConflict(ConflictingNode, Node, &Winner, &Loser);
            if (WSTR_EQ(Winner->Dn, Node->Dn)) {
                //
                // The new one is the winner. Remove old one and insert new one.
                //
                GTabDelete(CxtionTable,ConflictingNodeEntry->Key1,ConflictingNodeEntry->Key2, NULL);
                GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);

                GTabDelete(AllCxtionsTable,ConflictingNode->PartnerDn, (PVOID)&ConflictingNode->Inbound, NULL);
                GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

                FrsFreeType(ConflictingNode);
            } else {
                //
                // The old one is the winner. Leave it in the table.
                //
                FrsFreeType(Node);
                continue;
            }
        } else {

            //
            // If there is no conflict then we need to add this Member to the MemberSearchFilter
            // if it is not already there. It could have been added while processing the oubound connections.
            //
            Inbound = FALSE;
            if (GTabLookupTableString(CxtionTable, Node->PartnerDn, (PWCHAR)&Inbound) == NULL) {
                if (MemberSearchFilter != NULL) {
                    TempFilter = FrsAlloc((wcslen(MemberSearchFilter) + wcslen(L"(=)"  ATTR_SERVER_REF) +
                                           wcslen(Node->PartnerDn) + 1 ) * sizeof(WCHAR));
                    wcscpy(TempFilter, MemberSearchFilter);
                    wcscat(TempFilter, L"("  ATTR_SERVER_REF  L"=");
                    wcscat(TempFilter, Node->PartnerDn);
                    wcscat(TempFilter, L")");
                    FrsFree(MemberSearchFilter);
                    MemberSearchFilter = TempFilter;
                    TempFilter = NULL;
                } else {
                    MemberSearchFilter = FrsAlloc((wcslen(L"(|(=)"  ATTR_SERVER_REF) +
                                                   wcslen(Node->PartnerDn) + 1 ) * sizeof(WCHAR));
                    wcscpy(MemberSearchFilter, L"(|("  ATTR_SERVER_REF  L"=");
                    wcscat(MemberSearchFilter, Node->PartnerDn);
                    wcscat(MemberSearchFilter, L")");
                }
            }
        }

        //
        // If sysvol, always on within a site
        // Trigger schedule otherwise.
        //
        Node->SameSite = FrsDsSameSite(SettingsDn, Node->PartnerDn);
        if (Node->SameSite) {
            Node->Schedule = FrsFree(Node->Schedule);
        }

    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    return ERROR_SUCCESS;
}


ULONG
FrsDsGetSysvolOutboundCxtions(
    IN PLDAP        Ldap,
    IN PWCHAR       SettingsDn
    )
/*++
Routine Description:
    Fetch the sysvol outbound connections and add them
    to the CxtionTable. Check for multiple connections between the
    same partners and resolve the conflict.

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection.
    SettingsDn  - server reference from the member object.

Return Value:
    ERROR_SUCCESS - config fetched successfully
    Otherwise     - couldn't get the DS config
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSysvolOutboundCxtions:"
    PWCHAR          Attrs[7];
    PLDAPMessage    Entry;                       // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;                        // generic node for the tree
    PWCHAR          SearchFilter         = NULL;
    PWCHAR          TempFilter           = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PGEN_ENTRY      ConflictingNodeEntry = NULL;
    PCONFIG_NODE    ConflictingNode      = NULL;
    PCONFIG_NODE    Winner               = NULL;
    PCONFIG_NODE    Loser                = NULL;

    //
    // Look for all the connections that have our member as the from server.
    // Filter will look like (&(objectCategory=nTDSConnection)(fromServer=cn=member1,cn=set1,...))
    //
    MK_ATTRS_6(Attrs, ATTR_DN, ATTR_SCHEDULE, ATTR_FROM_SERVER, ATTR_OBJECT_GUID,
                      ATTR_USN_CHANGED, ATTR_ENABLED_CXTION);

    SearchFilter = FrsAlloc((wcslen(L"(&(=))"  CATEGORY_CXTION  ATTR_FROM_SERVER) +
                             wcslen(SettingsDn) + 1) * sizeof(WCHAR));
    wcscpy(SearchFilter,L"(&"  CATEGORY_CXTION  L"("  ATTR_FROM_SERVER  L"=");
    wcscat(SearchFilter,SettingsDn);
    wcscat(SearchFilter,L"))");


    if (!FrsDsLdapSearchInit(Ldap, SitesDn, LDAP_SCOPE_SUBTREE, SearchFilter,
                         Attrs, 0, &FrsSearchContext)) {
        SearchFilter = FrsFree(SearchFilter);
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No sysvol outbound connections found for member %ws!\n", SettingsDn);
    }

    SearchFilter = FrsFree(SearchFilter);

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL;
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_IN_CXTION);
        if (!Node) {
            DPRINT(4, ":DS: Cxtion lacks basic info; skipping\n");
            continue;
        }
        Node->EnabledCxtion = FrsDsFindValue(Ldap, Entry, ATTR_ENABLED_CXTION);
        if (Node->EnabledCxtion && WSTR_EQ(Node->EnabledCxtion, ATTR_FALSE)) {
            DPRINT2(1, ":DS: WARN - enabledConnection set to %ws; Ignoring %ws\n",
                    Node->EnabledCxtion, Node->Name->Name);
            Node = FrsFreeType(Node);
            continue;
        }

        //
        // These are outbound connections.
        //
        Node->Inbound = FALSE;

        //
        // Node's partner's name. This is an outbound connection. Get the
        // partners Dn by going one level up from the connection to the
        // member Dn.
        //
        Node->PartnerDn = FrsWcsDup(wcsstr(Node->Dn + 3, L"cn="));
        FRS_WCSLWR(Node->PartnerDn);

        //
        // Add the outbound cxtion to the cxtion table.
        //
        ConflictingNodeEntry = GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);
        GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

        if (ConflictingNodeEntry) {
            ConflictingNode = ConflictingNodeEntry->Data;
            FrsDsResolveCxtionConflict(ConflictingNode, Node, &Winner, &Loser);
            if (WSTR_EQ(Winner->Dn, Node->Dn)) {
                //
                // The new one is the winner. Remove old one and insert new one.
                //
                GTabDelete(CxtionTable,ConflictingNodeEntry->Key1,ConflictingNodeEntry->Key2, NULL);
                GTabInsertUniqueEntry(CxtionTable, Node, Node->PartnerDn, &Node->Inbound);

                GTabDelete(AllCxtionsTable,ConflictingNode->PartnerDn, (PVOID)&ConflictingNode->Inbound, NULL);
                GTabInsertUniqueEntry(AllCxtionsTable, Node, Node->PartnerDn, &Node->Inbound);

                FrsFreeType(ConflictingNode);
            } else {
                //
                // The old one is the winner. Leave it in the table.
                //
                FrsFreeType(Node);
                continue;
            }
        } else {
            //
            // If there is no conflict then we need to add this Member to the MemberSearchFilter.
            //
            if (MemberSearchFilter != NULL) {
                TempFilter = FrsAlloc((wcslen(MemberSearchFilter) + wcslen(L"(=)"  ATTR_SERVER_REF) +
                                       wcslen(Node->PartnerDn) + 1 ) * sizeof(WCHAR));
                wcscpy(TempFilter, MemberSearchFilter);
                wcscat(TempFilter, L"("  ATTR_SERVER_REF  L"=");
                wcscat(TempFilter, Node->PartnerDn);
                wcscat(TempFilter, L")");
                FrsFree(MemberSearchFilter);
                MemberSearchFilter = TempFilter;
                TempFilter = NULL;
            } else {
                MemberSearchFilter = FrsAlloc((wcslen(L"(|(=)"  ATTR_SERVER_REF) +
                                               wcslen(Node->PartnerDn) + 1 ) * sizeof(WCHAR));
                wcscpy(MemberSearchFilter, L"(|("  ATTR_SERVER_REF  L"=");
                wcscat(MemberSearchFilter, Node->PartnerDn);
                wcscat(MemberSearchFilter, L")");
            }
        }

        //
        // If sysvol, always on within a site
        //
        Node->SameSite = FrsDsSameSite(SettingsDn, Node->PartnerDn);
        if (Node->SameSite) {
            Node->Schedule = FrsFree(Node->Schedule);
        }

    }

    FrsDsLdapSearchClose(&FrsSearchContext);

    return ERROR_SUCCESS;
}


VOID
FrsDsMergeTwoWaySchedules(
    IN PSCHEDULE     *pISchedule,
    IN DWORD         *pIScheduleLen,
    IN OUT PSCHEDULE *pOSchedule,
    IN OUT DWORD     *pOScheduleLen,
    IN PSCHEDULE     *pRSchedule
    )
/*++
Routine Description:
    Set the output schedule by merging the input schedule with the.
    output schedule.
    Schedules are merged to support NTDSCONN_OPT_TWOWAY_SYNC flag
    on the connection object.

    This function only merges the interval schedule (SCHEDULE_INTERVAL).
    Other schedules are ignored and may be overwritten during merging.


    Input Output Replica Resultant output schedule.
    ----- ------ ----------------------------------
    0     0      0       Schedule is absent. Considered to be always on.
    0     0      1       Schedule is absent. Use replica sets schedule.
    0     1      0       Schedule is absent. Considered to be always on.
    0     1      1       Schedule is present.Merge replica set schedule with the schedule on the output.
    1     0      0       Schedule is present.Same as the one on input.
    1     0      1       Schedule is present.Merge replica set schedule with the schedule on the input.
    1     1      0       Schedule is present.Merge the input and output schedule.
    1     1      1       Schedule is present.Merge the input and output schedule.

Arguments:

    pISchedule    - Input schedule.
    pIScheduleLen - Input schedule length.
    pOSchedule    - Resultant schedule.
    pOScheduleLen - Resultant schedule length.
    pRSchedule    - Default replica set schedule.

Return Value:
    NONE
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsMergeTwoWaySchedules:"

    UINT   i;
    PUCHAR IScheduleData = NULL;
    PUCHAR OScheduleData = NULL;

    //
    // Set the location of the data in the schedule structures that are
    // non-null.
    //
    if (*pISchedule != NULL){
        for (i=0; i< (*pISchedule)->NumberOfSchedules ; ++i) {
            if ((*pISchedule)->Schedules[i].Type == SCHEDULE_INTERVAL) {

                IScheduleData = ((PUCHAR)*pISchedule) + (*pISchedule)->Schedules[i].Offset;
                break;
            }
        }
    }

    if (*pOSchedule != NULL){
        for (i=0; i< (*pOSchedule)->NumberOfSchedules ; ++i) {
            if ((*pOSchedule)->Schedules[i].Type == SCHEDULE_INTERVAL) {

                OScheduleData = ((PUCHAR)*pOSchedule) + (*pOSchedule)->Schedules[i].Offset;
                break;
            }
        }
    }

    //
    // If there is no output schedule then copy the schedule
    // from input to output if there is one on input. Now if there
    // is a schedule on the replica set merge it with the new ouput
    // schedule.
    //
    if (*pOSchedule == NULL || OScheduleData == NULL) {

        if (*pISchedule == NULL) {
            return;
        }

        *pOScheduleLen = *pIScheduleLen;
        *pOSchedule = FrsAlloc(*pOScheduleLen);
        CopyMemory(*pOSchedule, *pISchedule, *pOScheduleLen);

        if (*pRSchedule == NULL) {
            return;
        }

        //
        // Update the location of output schedule data.
        //
        for (i=0; i< (*pOSchedule)->NumberOfSchedules ; ++i) {
            if ((*pOSchedule)->Schedules[i].Type == SCHEDULE_INTERVAL) {
                OScheduleData = ((PUCHAR)*pOSchedule) + (*pOSchedule)->Schedules[i].Offset;
                break;
            }
        }

        //
        // Update the location of input schedule data.
        //
        for (i=0; i< (*pRSchedule)->NumberOfSchedules ; ++i) {
            if ((*pRSchedule)->Schedules[i].Type == SCHEDULE_INTERVAL) {
                IScheduleData = ((PUCHAR)*pRSchedule) + (*pRSchedule)->Schedules[i].Offset;
                break;
            }
        }

    }

    //
    // If there is no input schedule then check if there is a schedule
    // on the replica set. If there is then merge that with the output schedule.
    //
    if ((*pISchedule == NULL || IScheduleData == NULL)) {

        //
        // Update the location of input schedule data. Pick it from replica set.
        //
        if (*pRSchedule != NULL) {
            for (i=0; i< (*pRSchedule)->NumberOfSchedules ; ++i) {
                if ((*pRSchedule)->Schedules[i].Type == SCHEDULE_INTERVAL) {
                    IScheduleData = ((PUCHAR)*pRSchedule) + (*pRSchedule)->Schedules[i].Offset;
                    break;
                }
            }
        } else {

            *pOSchedule = FrsFree(*pOSchedule);
            *pOScheduleLen = 0;
            return;
        }

    }


    for (i=0 ; i<7*24 ; ++i) {
        *(OScheduleData + i) = *(OScheduleData + i) | *(IScheduleData + i);
    }

    return;
}


DWORD
FrsDsGetSysvolCxtions(
    IN PLDAP        Ldap,
    IN PWCHAR       SetDn,
    IN PWCHAR       MemberRef,
    IN PCONFIG_NODE Parent,
    IN PCONFIG_NODE Computer
    )
/*++
Routine Description:
    Fetch the members for the replica set identified by Base.

    Part of NewDs poll APIs.

Arguments:
    ldap       : Handle to DS.
    SetDn      : Dn of the set being processed.
    MemberRef  : MemberRef from the subscriber object.
    Parent     : Pointer to the set node in the config tree that is being built,

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSysvolCxtions:"
    PWCHAR          Attrs[7];
    PLDAPMessage    Entry;                          // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node           = NULL;          // generic node for the tree
    PCONFIG_NODE    Subscriber;
    PCONFIG_NODE    PartnerNode    = NULL;
    PCONFIG_NODE    MemberNode     = NULL;
    PCONFIG_NODE    Cxtion         = NULL;
    DWORD           WStatus        = ERROR_SUCCESS;
    PVOID           Key            = NULL;
    PWCHAR          TempFilter     = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PWCHAR          SettingsDn     = NULL;

    MK_ATTRS_6(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED,
                      ATTR_SERVER_REF, ATTR_COMPUTER_REF);

    //
    // Initialize the CxtionTable. We discard the table once we have
    // loaded the replica set. We use the same variables for
    // every replica set.
    //
    if (CxtionTable != NULL) {
        CxtionTable = GTabFreeTable(CxtionTable, NULL);
    }

    CxtionTable = GTabAllocStringAndBoolTable();


    //
    // Initialize the MemberTable. We discard the table once we have
    // loaded the replica set. We use the same variables for
    // every replica set.
    //
    if (MemberTable != NULL) {
        MemberTable = GTabFreeTable(MemberTable, NULL);
    }

    MemberTable = GTabAllocStringTable();

    //
    // We will form the MemberSearchFilter for this replica set.
    //
    if (MemberSearchFilter != NULL) {
        MemberSearchFilter = FrsFree(MemberSearchFilter);
    }

    //
    // We have to first get our member object to get the serverreference to
    // know where to go to get the connections.
    //
    if (!FrsDsLdapSearchInit(Ldap, MemberRef, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No member object found for member %ws!\n", MemberRef);
    }
    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL && WIN_SUCCESS(WStatus);
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_MEMBER);
        if (!Node) {
            DPRINT(0, ":DS: Member lacks basic info; skipping\n");
            continue;
        }

        //
        // NTDS Settings (DSA) Reference.
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, Entry, ATTR_SERVER_REF);
        if (Node->SettingsDn == NULL) {
            DPRINT1(0, ":DS: WARN - Member (%ws) of sysvol replica set lacks server reference; skipping\n", Node->Dn);
            Node->Consistent = FALSE;

            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_MEMBER,
                                     Node->Dn, ATTR_SERVER_REF);

            Node = FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->SettingsDn);
        FrsFree(SettingsDn);
        SettingsDn = FrsWcsDup(Node->SettingsDn);
        //
        // Computer Reference
        //
        Node->ComputerDn = FrsDsFindValue(Ldap, Entry, ATTR_COMPUTER_REF);
        if (Node->ComputerDn == NULL) {
            DPRINT1(0, ":DS: WARN - Member (%ws) of sysvol replica set lacks computer reference; skipping\n", Node->Dn);
            Node->Consistent = FALSE;

            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_MEMBER,
                                     Node->Dn, ATTR_COMPUTER_REF);

            Node = FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->ComputerDn);

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);

        //
        // Insert the new member in the member table only if it is not there already.
        // For sysvols insert the members with their settingsdn as the primary key
        // because that is what is stored in the cxtion->PartnerDn structure at this time.
        //
        GTabInsertUniqueEntry(MemberTable, Node, Node->SettingsDn, NULL);

        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeMember", Node);

    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    //
    // We can't do any further processing if the Node is not consistent.
    //
    if (Node == NULL || !Node->Consistent) {
        FrsFree(SettingsDn);
        return ERROR_INVALID_DATA;
    }

    //
    // Get the outbound connections.
    //
    WStatus = FrsDsGetSysvolOutboundCxtions(Ldap, SettingsDn);
    if (!WIN_SUCCESS(WStatus)) {
        FrsFree(SettingsDn);
        return WStatus;
    }

    //
    // Get the inbound connections.
    //
    WStatus = FrsDsGetSysvolInboundCxtions(Ldap, SettingsDn);
    if (!WIN_SUCCESS(WStatus)) {
        FrsFree(SettingsDn);
        return WStatus;
    }

    //
    // The above two calls build the MemberFilter.
    // MemberFilter is used to search the DS for all the member objects of
    // interest. If there are no connections from or to this member then
    // the filter will be NULL.
    //
    if (MemberSearchFilter == NULL) {
        //
        // Is this member linked to this computer
        //
        MemberNode = Node;

        Subscriber = GTabLookupTableString(SubscriberTable, MemberNode->Dn, NULL);
        //
        // Yep; have a suscriber
        //
        if (Subscriber != NULL) {
            MemberNode->ThisComputer = TRUE;
            MemberNode->Root = FrsWcsDup(Subscriber->Root);
            MemberNode->Stage = FrsWcsDup(Subscriber->Stage);
            FRS_WCSLWR(MemberNode->Root);
            FRS_WCSLWR(MemberNode->Stage);
            MemberNode->DnsName = FrsWcsDup(Computer->DnsName);

        }
        FrsFree(SettingsDn);
        return ERROR_SUCCESS;
    } else {
        //
        // Add the closing ')' to the MemberSearchFilter.
        //
        TempFilter = FrsAlloc((wcslen(MemberSearchFilter) + wcslen(L")") + 1 ) * sizeof(WCHAR));
        wcscpy(TempFilter, MemberSearchFilter);
        wcscat(TempFilter, L")");
        FrsFree(MemberSearchFilter);
        MemberSearchFilter = TempFilter;
        TempFilter = NULL;
    }

    if (!FrsDsLdapSearchInit(Ldap, SetDn, LDAP_SCOPE_ONELEVEL, MemberSearchFilter,
                         Attrs, 0, &FrsSearchContext)) {
        FrsFree(SettingsDn);
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No member objects of interest found under %ws!\n", SetDn);
    }
    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL && WIN_SUCCESS(WStatus);
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_MEMBER);
        if (!Node) {
            DPRINT(0, ":DS: Member lacks basic info; skipping\n");
            continue;
        }

        //
        // NTDS Settings (DSA) Reference.
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, Entry, ATTR_SERVER_REF);
        if (Node->SettingsDn == NULL) {
            DPRINT1(0, ":DS: WARN - Member (%ws) of sysvol replica set lacks server reference; skipping\n", Node->Dn);
            Node->Consistent = FALSE;
            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_MEMBER,
                                     Node->Dn, ATTR_SERVER_REF);

            Node = FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->SettingsDn);

        //
        // Computer Reference
        //
        Node->ComputerDn = FrsDsFindValue(Ldap, Entry, ATTR_COMPUTER_REF);
        if (Node->ComputerDn == NULL) {
            DPRINT1(0, ":DS: WARN - Member (%ws) of sysvol replica set lacks computer reference; skipping\n", Node->Dn);
            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_MEMBER,
                                     Node->Dn, ATTR_COMPUTER_REF);

            Node = FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->ComputerDn);

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);

        //
        // Insert the new member in the member table only if it is not there already.
        // For sysvols insert the members with their settingsdn as the primary key
        // because that is what is stored in the cxtion->PartnerDn structure at this time.
        //
        GTabInsertUniqueEntry(MemberTable, Node, Node->SettingsDn, NULL);

        //
        // Make a table of computers of interest to us so we can search for all
        // the computers of interest at one time after we have polled all
        // replica sets. Put empty entries in the table at this point.
        // Do not add our computer in this table as we already have info about
        // our computer.
        //
        if (WSTR_NE(Node->ComputerDn, Computer->Dn)) {
            //
            // This is not our computer. Add it to the table if it isn't already in the table.
            //
            PartnerNode = GTabLookupTableString(PartnerComputerTable, Node->ComputerDn, NULL);
            if (PartnerNode == NULL) {
                //
                // There are no duplicates so enter this computer name in the table.
                //
                PartnerNode = FrsDsAllocBasicNode(Ldap, NULL, CONFIG_TYPE_COMPUTER);
                PartnerNode->Dn = FrsWcsDup(Node->ComputerDn);
                PartnerNode->MemberDn = FrsWcsDup(Node->Dn);
                GTabInsertUniqueEntry(PartnerComputerTable, PartnerNode, PartnerNode->Dn, NULL);
            }
        }

        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeMember", Node);

    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    //
    // Link the inbound and outbound connections to our member node.
    //
    MemberNode = GTabLookupTableString(MemberTable, SettingsDn, NULL);
    if (MemberNode != NULL) {
        //
        // Is this member linked to this computer
        //
        Subscriber = GTabLookupTableString(SubscriberTable, MemberNode->Dn, NULL);
        //
        // Yep; have a suscriber
        //
        if (Subscriber != NULL) {
            MemberNode->ThisComputer = TRUE;
            MemberNode->Root = FrsWcsDup(Subscriber->Root);
            MemberNode->Stage = FrsWcsDup(Subscriber->Stage);
            FRS_WCSLWR(MemberNode->Root);
            FRS_WCSLWR(MemberNode->Stage);
            MemberNode->DnsName = FrsWcsDup(Computer->DnsName);

            //
            // This is us. Link all the cxtions to this Member.
            //
            if (CxtionTable != NULL) {
                Key = NULL;
                while ((Cxtion = GTabNextDatum(CxtionTable, &Key)) != NULL) {
                    //
                    // Get our Partners Node from the member table.
                    //
                    PartnerNode = GTabLookupTableString(MemberTable, Cxtion->PartnerDn, NULL);
                    if (PartnerNode != NULL) {
                        Cxtion->PartnerName = FrsDupGName(PartnerNode->Name);
                        Cxtion->PartnerCoDn = FrsWcsDup(PartnerNode->ComputerDn);
                    } else {
                        //
                        // This Cxtion does not have a valid member object for its
                        // partner. E.g. A sysvol topology that has connections under
                        // the NTDSSettings objects but there are no corresponding
                        // member objects.
                        //
                        DPRINT1(0, ":DS: Marking connection inconsistent.(%ws)\n",Cxtion->Dn);
                        Cxtion->Consistent = FALSE;
                    }
                    FrsDsTreeLink(MemberNode, Cxtion);
                }
                CxtionTable = GTabFreeTable(CxtionTable,NULL);
            }
        }
    }

    FrsFree(SettingsDn);
    return WStatus;
}


DWORD
FrsDsGetNonSysvolCxtions(
    IN PLDAP        Ldap,
    IN PWCHAR       SetDn,
    IN PWCHAR       MemberRef,
    IN PCONFIG_NODE Parent,
    IN PCONFIG_NODE Computer
    )
/*++
Routine Description:
    Fetch the members and connections for the replica set identified by Base.

    Part of NewDs poll APIs.

Arguments:
    ldap       : Handle to DS.
    SetDn      : Dn of the set being processed.
    MemberRef  : MemberRef from the subscriber object.
    Parent     : Pointer to the set node in the config tree that is being built,

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetNonSysvolCxtions:"
    PWCHAR          Attrs[7];
    PLDAPMessage    Entry;                          // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;                           // generic node for the tree
    PCONFIG_NODE    Subscriber;
    PCONFIG_NODE    PartnerNode    = NULL;
    PCONFIG_NODE    MemberNode     = NULL;
    PCONFIG_NODE    Cxtion         = NULL;
    DWORD           WStatus        = ERROR_SUCCESS;
    PVOID           Key            = NULL;
    PWCHAR          MemberCn       = NULL;
    PWCHAR          TempFilter     = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;

    //
    // MemberRef must be non-NULL.
    //
    if(MemberRef == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the CxtionTable. We discard the table once we have
    // loaded the replica set. We use the same variables for
    // every replica set.
    //
    if (CxtionTable != NULL) {
        CxtionTable = GTabFreeTable(CxtionTable, NULL);
    }

    CxtionTable = GTabAllocStringAndBoolTable();


    //
    // Initialize the MemberTable. We discard the table once we have
    // loaded the replica set. We use the same variables for
    // every replica set.
    //
    if (MemberTable != NULL) {
        MemberTable = GTabFreeTable(MemberTable, NULL);
    }

    MemberTable = GTabAllocStringTable();

    //
    // We will form the MemberSearchFilter for this replica set.
    //
    if (MemberSearchFilter != NULL) {
        MemberSearchFilter = FrsFree(MemberSearchFilter);
    }

    //
    // Add this members name to the member search filter.
    //

    MemberCn = FrsDsMakeRdn(MemberRef);
    MemberSearchFilter = FrsAlloc((wcslen(L"(|(=)"  ATTR_CN) +
                                   wcslen(MemberCn) + 1 ) * sizeof(WCHAR));
    wcscpy(MemberSearchFilter, L"(|("  ATTR_CN  L"=");
    wcscat(MemberSearchFilter, MemberCn);
    wcscat(MemberSearchFilter, L")");

    MemberCn = FrsFree(MemberCn);


    //
    // Get the outbound connections.
    //
    WStatus = FrsDsGetNonSysvolOutboundCxtions(Ldap, SetDn, MemberRef);
    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    //
    // Get the inbound connections.
    //
    WStatus = FrsDsGetNonSysvolInboundCxtions(Ldap, SetDn, MemberRef);
    if (!WIN_SUCCESS(WStatus)) {
        return WStatus;
    }

    //
    // The above twp calls build the MemberFilter.
    // MemberFilter is used to search the DS for all the member objects of
    // interest.  If there are no connections from or to this member then
    // the filter will will just have 1 entry.
    //
    //
    // Add the closing ')' to the MemberSearchFilter.
    //
    TempFilter = FrsAlloc((wcslen(MemberSearchFilter) + wcslen(L")") + 1 ) * sizeof(WCHAR));
    wcscpy(TempFilter, MemberSearchFilter);
    wcscat(TempFilter, L")");
    FrsFree(MemberSearchFilter);
    MemberSearchFilter = TempFilter;
    TempFilter = NULL;

    MK_ATTRS_6(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED,
                      ATTR_SERVER_REF, ATTR_COMPUTER_REF);

    if (!FrsDsLdapSearchInit(Ldap, SetDn, LDAP_SCOPE_ONELEVEL, MemberSearchFilter,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No member objects of interest found under %ws!\n", SetDn);
    }
    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL && WIN_SUCCESS(WStatus);
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_MEMBER);
        if (!Node) {
            DPRINT(4, ":DS: Member lacks basic info; skipping\n");
            continue;
        }

        //
        // Computer Reference
        //
        Node->ComputerDn = FrsDsFindValue(Ldap, Entry, ATTR_COMPUTER_REF);
        if (Node->ComputerDn == NULL) {
            DPRINT1(4, ":DS: WARN - Member (%ws) lacks computer reference; skipping\n", Node->Dn);
            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_MEMBER,
                                     Node->Dn, ATTR_COMPUTER_REF);

            Node = FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->ComputerDn);

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);

        //
        // Insert the new member in the member table only if it is not there already.
        //
        GTabInsertUniqueEntry(MemberTable, Node, Node->Dn, NULL);

        //
        // Make a table of computers of interest to us so we can search for all
        // the computers of interest at one time after we have polled all
        // replica sets. Put empty entries in the table at this point.
        // Do not add our computer in this table as we already have info about
        // our computer.
        //
        if (WSTR_NE(Node->ComputerDn, Computer->Dn)) {
            //
            // This is not our computer. Add it to the table if it isn't already in the table.
            //
            PartnerNode = GTabLookupTableString(PartnerComputerTable, Node->ComputerDn, NULL);
            if (PartnerNode == NULL) {
                //
                // There are no duplicates so enter this computer name in the table.
                //
                PartnerNode = FrsDsAllocBasicNode(Ldap, NULL, CONFIG_TYPE_COMPUTER);
                PartnerNode->Dn = FrsWcsDup(Node->ComputerDn);
                PartnerNode->MemberDn = FrsWcsDup(Node->Dn);
                GTabInsertUniqueEntry(PartnerComputerTable, PartnerNode, PartnerNode->Dn, NULL);
            }
        }

        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeMember", Node);

    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    //
    // Link the inbound and outbound connections to our member node.
    //
    MemberNode = GTabLookupTableString(MemberTable, MemberRef, NULL);
    if (MemberNode != NULL) {
        //
        // Is this member linked to this computer
        //
        Subscriber = GTabLookupTableString(SubscriberTable, MemberNode->Dn, NULL);
        //
        // Yep; have a suscriber
        //
        if (Subscriber != NULL) {
            MemberNode->ThisComputer = TRUE;
            MemberNode->Root = FrsWcsDup(Subscriber->Root);
            MemberNode->Stage = FrsWcsDup(Subscriber->Stage);
            FRS_WCSLWR(MemberNode->Root);
            FRS_WCSLWR(MemberNode->Stage);
            MemberNode->DnsName = FrsWcsDup(Computer->DnsName);

            //
            // This is us. Link all the cxtions to this Member.
            //
            if (CxtionTable != NULL) {
                Key = NULL;
                while ((Cxtion = GTabNextDatum(CxtionTable, &Key)) != NULL) {
                    //
                    // Get our Partners Node from the member table.
                    //
                    PartnerNode = GTabLookupTableString(MemberTable, Cxtion->PartnerDn, NULL);
                    if (PartnerNode != NULL) {
                        Cxtion->PartnerName = FrsDupGName(PartnerNode->Name);
                        Cxtion->PartnerCoDn = FrsWcsDup(PartnerNode->ComputerDn);
                    } else {
                        //
                        // This Cxtion does not have a valid member object for its
                        // partner. E.g. A sysvol topology that has connections under
                        // the NTDSSettings objects but there are no corresponding
                        // member objects.
                        //
                        DPRINT1(0, ":DS: Marking connection inconsistent.(%ws)\n",Cxtion->Dn);
                        Cxtion->Consistent = FALSE;
                    }
                    FrsDsTreeLink(MemberNode, Cxtion);
                }
                CxtionTable = GTabFreeTable(CxtionTable,NULL);
            }
        }
    }

    return WStatus;
}


DWORD
FrsDsGetSets(
    IN PLDAP        Ldap,
    IN PWCHAR       SetDnAddr,
    IN PWCHAR       MemberRef,
    IN PCONFIG_NODE Parent,
    IN PCONFIG_NODE Computer
    )
/*++
Routine Description:
    Recursively scan the DS tree beginning at
    configuration\sites\settings\sets.

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection
    SetDnAddr   - From member reference from subscriber
    Parent      - Container which contains Base
    Computer    - for member back links

Return Value:
    ERROR_SUCCESS - config fetched successfully
    Otherwise     - couldn't get the DS config
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSets:"
    PLDAPMessage    Entry;      // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;       // generic node for the tree
    DWORD           i;
    DWORD           WStatus = ERROR_SUCCESS;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;

    PWCHAR          FlagsWStr = NULL;
    PWCHAR          Attrs[10];

    //
    // Have we processed this set before? If we have then don't process
    // it again. This check prevents two subscribers to point to
    // different member objects that are members of the same set.
    //
    Node = GTabLookupTableString(SetTable, SetDnAddr, NULL);

    if (Node) {
        return ERROR_SUCCESS;
    }

    //
    // Search the DS beginning at Base for sets (objectCategory=nTFRSReplicaSet)
    //
    MK_ATTRS_9(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED, ATTR_FRS_FLAGS,
                      ATTR_SET_TYPE, ATTR_PRIMARY_MEMBER, ATTR_FILE_FILTER, ATTR_DIRECTORY_FILTER);

    if (!FrsDsLdapSearchInit(Ldap, SetDnAddr, LDAP_SCOPE_BASE, CATEGORY_REPLICA_SET,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No replica set objects found under %ws!\n", SetDnAddr);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL && WIN_SUCCESS(WStatus);
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_REPLICA_SET);
        if (!Node) {
            DPRINT(4, ":DS: Set lacks basic info; skipping\n");
            continue;
        }

        //
        // Replica set type
        //
        Node->SetType = FrsDsFindValue(Ldap, Entry, ATTR_SET_TYPE);

        //
        // Check the set type. It has to be one that we recognize.
        //
        if ((Node->SetType == NULL)                           ||
           (WSTR_NE(Node->SetType, FRS_RSTYPE_OTHERW)         &&
            WSTR_NE(Node->SetType, FRS_RSTYPE_DFSW)           &&
            WSTR_NE(Node->SetType, FRS_RSTYPE_DOMAIN_SYSVOLW) &&
            WSTR_NE(Node->SetType, FRS_RSTYPE_ENTERPRISE_SYSVOLW))){

            DPRINT1(4, ":DS: ERROR - Invalid Set type for (%ws)\n", Node->Dn);

            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_REPLICA_SET,
                                     Node->Dn, ATTR_SET_TYPE);

            Node = FrsFreeType(Node);
            continue;
        }

        //
        // Primary member
        //
        Node->MemberDn = FrsDsFindValue(Ldap, Entry, ATTR_PRIMARY_MEMBER);

        //
        // File filter
        //
        Node->FileFilterList = FrsDsFindValue(Ldap, Entry, ATTR_FILE_FILTER);

        //
        // Directory filter
        //
        Node->DirFilterList = FrsDsFindValue(Ldap, Entry, ATTR_DIRECTORY_FILTER);

        //
        // Read the FRS Flags value.
        //
        FlagsWStr = FrsDsFindValue(Ldap, Entry, ATTR_FRS_FLAGS);
        if (FlagsWStr != NULL) {
            Node->FrsRsoFlags = _wtoi(FlagsWStr);
            FlagsWStr = FrsFree(FlagsWStr);
        } else {
            Node->FrsRsoFlags = 0;
        }

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);

        //
        // Insert into the table of sets. We checked for duplicates above with
        // GTabLookupTableString so there should not be any duplicates.
        //
        FRS_ASSERT(GTabInsertUniqueEntry(SetTable, Node, Node->Dn, NULL) == NULL);

        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeSet", Node);

        //
        // Get the replica set topology. We have to look at different places
        // in the DS depending on the type of replica set. The cxtions for sysvol
        // replica set are generated by KCC and they reside under the server object
        // for the DC. We use the serverReference from the member object to get
        // there.
        //
        if (FRS_RSTYPE_IS_SYSVOLW(Node->SetType)) {
            WStatus = FrsDsGetSysvolCxtions(Ldap, SetDnAddr, MemberRef, Node, Computer);
        } else {
            WStatus = FrsDsGetNonSysvolCxtions(Ldap, SetDnAddr, MemberRef, Node, Computer);
        }

    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    return WStatus;
}


DWORD
FrsDsGetSettings(
    IN PLDAP        Ldap,
    IN PWCHAR       MemberRef,
    IN PCONFIG_NODE Parent,
    IN PCONFIG_NODE Computer
    )
/*++
Routine Description:
    Scan the DS tree for NTFRS-Settings objects and their servers

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection
    MemberRef   - From the subscriber member reference
    Parent      - Container which contains Base
    Computer

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSettings:"
    PWCHAR          Attrs[5];
    PLDAPMessage    Entry;      // Opaque stuff from ldap subsystem
    PCONFIG_NODE    Node;       // generic node for the tree
    PWCHAR          MemberDnAddr;
    PWCHAR          SetDnAddr;
    PWCHAR          SettingsDnAddr;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           WStatus = ERROR_SUCCESS;

    //
    // Find the member component
    //
    MemberDnAddr = wcsstr(MemberRef, L"cn=");
    if (!MemberDnAddr) {
        DPRINT1(0, ":DS: ERROR - Missing member component in %ws\n", MemberRef);
        return ERROR_ACCESS_DENIED;
    }
    //
    // Find the set component
    //
    SetDnAddr = wcsstr(MemberDnAddr + 3, L"cn=");
    if (!SetDnAddr) {
        DPRINT1(0, ":DS: ERROR - Missing set component in %ws\n", MemberRef);
        return ERROR_ACCESS_DENIED;
    }
    //
    // Find the settings component
    //
    SettingsDnAddr = wcsstr(SetDnAddr + 3, L"cn=");
    if (!SettingsDnAddr) {
        DPRINT1(0, ":DS: ERROR - Missing settings component in %ws\n", MemberRef);
        return ERROR_ACCESS_DENIED;
    }

    //
    // Have we processed this settings before?
    //
    for (Node = Parent->Children; Node; Node = Node->Peer) {
        if (WSTR_EQ(Node->Dn, SettingsDnAddr)) {
            DPRINT1(4, ":DS: Settings hit on %ws\n", MemberRef);
            break;
        }
    }
    //
    // Yep; get the sets
    //
    if (Node) {
        return FrsDsGetSets(Ldap, SetDnAddr, MemberRef, Node, Computer);
    }

    //
    // Search the DS beginning at Base for settings (objectCategory=nTFRSSettings)
    //
    MK_ATTRS_4(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED);

    if (!FrsDsLdapSearchInit(Ldap, SettingsDnAddr, LDAP_SCOPE_BASE, CATEGORY_NTFRS_SETTINGS,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(1, ":DS: WARN - No NTFRSSettings objects found under %ws!\n", SettingsDnAddr);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         Entry != NULL && WIN_SUCCESS(WStatus);
         Entry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, Entry, CONFIG_TYPE_NTFRS_SETTINGS);
        if (!Node) {
            DPRINT(4, ":DS: Frs Settings lacks basic info; skipping\n");
            continue;
        }

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);
        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeSettings", Node);

        //
        // Recurse to the next level in the DS hierarchy
        //
        WStatus = FrsDsGetSets(Ldap, SetDnAddr, MemberRef, Node, Computer);
    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    return WStatus;
}


DWORD
FrsDsGetServices(
    IN  PLDAP        Ldap,
    IN  PCONFIG_NODE Computer,
    OUT PCONFIG_NODE *Services
    )
/*++
Routine Description:
    Recursively scan the DS tree beginning at the settings from
    the subscriber nodes.

    The name is a misnomer because of evolution.

    Part of NewDs poll APIs.

Arguments:
    ldap        - opened and bound ldap connection
    Computer
    Services    - returned list of all Settings

Return Value:
    WIN32 Status
--*/
{

#undef DEBSUB
#define  DEBSUB  "FrsDsGetServices:"


    PCONFIG_NODE    Node;
    PCONFIG_NODE    Subscriptions;
    PCONFIG_NODE    Subscriber;
    PVOID           SubKey  = NULL;
    DWORD           WStatus = ERROR_SUCCESS;

    *Services = NULL;

    //
    // Initialize the SubscriberTable.
    //
    if (SetTable != NULL) {
        SetTable = GTabFreeTable(SetTable,NULL);
    }

    SetTable = GTabAllocStringTable();

    //
    // Initially, the node is assumed to be consistent
    //
    Node = FrsAllocType(CONFIG_NODE_TYPE);
    Node->DsObjectType = CONFIG_TYPE_SERVICES_ROOT;

    Node->Consistent = TRUE;

    //
    // Distinguished name
    //
    Node->Dn = FrsWcsDup(L"<<replica ds root>>");
    FRS_WCSLWR(Node->Dn);

    //
    // Name = RDN + Object Guid
    //
    Node->Name = FrsBuildGName(FrsAlloc(sizeof(GUID)),
                               FrsWcsDup(L"<<replica ds root>>"));

    FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeService", Node);

    SubKey = NULL;
    while ((Subscriber = GTabNextDatum(SubscriberTable, &SubKey)) != NULL) {
        //
        // Recurse to the next level in the DS hierarchy
        //
        WStatus = FrsDsGetSettings(Ldap, Subscriber->MemberDn, Node, Computer);

        DPRINT1_WS(2, ":DS: WARN - Error getting topology for replica root (%ws);", Subscriber->Root, WStatus);
    }

    *Services = Node;
    return WStatus;
}


PWCHAR
FrsDsGetDnsName(
    IN  PLDAP        Ldap,
    IN  PWCHAR       Dn
    )
/*++
Routine Description:
    Read the dNSHostName attribute from Dn

Arguments:
    Ldap    - opened and bound ldap connection
    Dn      - Base Dn for search

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetDnsName:"
    PLDAPMessage    LdapMsg = NULL;
    PLDAPMessage    LdapEntry;
    PWCHAR          DnsName = NULL;
    PWCHAR          Attrs[2];
    DWORD           WStatus = ERROR_SUCCESS;

    //
    // Search the DS beginning at Base for the entries of class (objectCategory=*)
    //

    MK_ATTRS_1(Attrs, ATTR_DNS_HOST_NAME);
    //
    // Note: Is it safe to turn off referrals re: back links?
    //       if so, use ldap_get/set_option in winldap.h
    //
    if (!FrsDsLdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         Attrs, 0, &LdapMsg)) {
        goto CLEANUP;
    }

    //
    // Scan the entries returned from ldap_search
    //
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (!LdapEntry) {
        goto CLEANUP;
    }

    //
    // DNS name
    //
    DnsName = FrsDsFindValue(Ldap, LdapEntry, ATTR_DNS_HOST_NAME);

CLEANUP:
    LDAP_FREE_MSG(LdapMsg);
    DPRINT2(4, ":DS: DN %ws -> DNS %ws\n", Dn, DnsName);
    return DnsName;
}


PWCHAR
FrsDsGuessPrincName(
    IN PWCHAR Dn
    )
/*++
Routine Description:
    Derive the NT4 account name for Dn. Dn should be the Dn
    of a computer object.

Arguments:
    Dn

Return Value:
    NT4 Account Name or NULL
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGuessPrincName:"
    DWORD   Len = 0;
    WCHAR   HackPrincName[MAX_PATH];
    PWCHAR  Rdn;
    PWCHAR  Dc;

    DPRINT1(4, ":DS: WARN: Guess NT4 Account Name for %ws\n", Dn);

    //
    // Computer's Dn not available
    //
    if (!Dn) {
        return NULL;
    }
    Dc = wcsstr(Dn, L"dc=");
    //
    // No DC=?
    //
    if (!Dc) {
        DPRINT1(4, ":DS: No DC= in %ws\n", Dn);
        return NULL;
    }
    //
    // DC= at eol?
    //
    Dc += 3;
    if (!*Dc) {
        DPRINT1(4, ":DS: No DC= at eol in %ws\n", Dn);
        return NULL;
    }
    while (*Dc && *Dc != L',') {
        HackPrincName[Len++] = *Dc++;
    }
    HackPrincName[Len++] = L'\\';
    HackPrincName[Len++] = L'\0';
    Rdn = FrsDsMakeRdn(Dn);
    wcscat(HackPrincName, Rdn);
    wcscat(HackPrincName, L"$");
    DPRINT1(4, ":DS: Guessing %ws\n", HackPrincName);
    FrsFree(Rdn);
    return FrsWcsDup(HackPrincName);
}


PWCHAR
FrsDsFormUPN(
    IN PWCHAR NT4AccountName,
    IN PWCHAR DomainDnsName
    )
/*++
Routine Description:
    Forms the User Principal Name by combining the
    Sam account name and the domain dns name in the form
    shown below.

    <SamAccountName>@<DnsDomainName>

    You can get <SamAccountName> from the string to the right of the "\"
    of the NT4AccountName.

Arguments:
    NT4AccountName - DS_NT4_ACCOUNT_NAME returned from DsCrackNames.
    DomainDnsName  - Dns name of the domain.

Return Value:
    Copy of name in desired format; free with FrsFree()
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFormUPN:"

    PWCHAR  SamBegin  = NULL;
    PWCHAR  FormedUPN = NULL;

    if ((NT4AccountName == NULL ) || (DomainDnsName == NULL)) {
        return NULL;
    }

    //
    // Find the sam account name.
    //
    for (SamBegin = NT4AccountName; *SamBegin && *SamBegin != L'\\'; ++SamBegin);

    if (*SamBegin && *(SamBegin+1)) {
        SamBegin++;
    } else {
        return NULL;
    }

    FormedUPN = FrsAlloc((wcslen(SamBegin) + wcslen(DomainDnsName) + 2) * sizeof(WCHAR));

    wcscpy(FormedUPN, SamBegin);
    wcscat(FormedUPN, L"@");
    wcscat(FormedUPN, DomainDnsName);

    DPRINT1(5, "UPN formed is %ws\n", FormedUPN);

    return FormedUPN;
}


PWCHAR
FrsDsConvertName(
    IN HANDLE Handle,
    IN PWCHAR InputName,
    IN DWORD  InputFormat,
    IN PWCHAR DomainDnsName,
    IN DWORD  DesiredFormat
    )
/*++
Routine Description:
    Translate the input name  into the desired format.

Arguments:
    Handle        - From DsBind
    InputName     - Supplied name.
    InputFormat   - Format of the supplied name.
    DomainDnsName - If !NULL, produce new local handle
    DesiredFormat - desired format. Eg. DS_USER_PRINCIPAL_NAME

Return Value:
    Copy of name in desired format; free with FrsFree()
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsConvertName:"

    DWORD           WStatus;
    DS_NAME_RESULT  *Cracked = NULL;
    HANDLE          LocalHandle = NULL;
    PWCHAR          CrackedName = NULL;
    PWCHAR          CrackedDomain = NULL;
    PWCHAR          CrackedUPN = NULL;
    DWORD           RequestedFormat = 0;

    DPRINT3(4, ":DS: Convert Name %ws From %08x To %08x\n", InputName, InputFormat, DesiredFormat);

    //
    // Input name not available.
    //
    if (!InputName) {
        return NULL;
    }

    //
    // Need something to go on!
    //
    if (!HANDLE_IS_VALID(Handle) && !DomainDnsName) {
        return NULL;
    }

    //
    // Bind to Ds
    //
    if (DomainDnsName) {
        DPRINT3(4, ":DS: Get %08x Name from %ws for %ws\n",
                DesiredFormat, DomainDnsName, InputName);

        WStatus = DsBind(NULL, DomainDnsName, &LocalHandle);
        CLEANUP2_WS(0, ":DS: ERROR - DsBind(%ws, %08x);",
                    DomainDnsName, DesiredFormat, WStatus, RETURN);

        Handle = LocalHandle;
    }

    //
    // Crack the computer's distinguished name into its NT4 Account Name
    //
    // If the Desired format is DS_USER_PRINCIPAL_NAME then we form it by
    // getting the name from DS_NT4_ACCOUNT_NAME and the dns domain name
    // from the "Cracked->rItems->pDomain"
    // We could ask for DS_USER_PRINCIPAL_NAME directly but we don't because.
    // Object can have implicit or explicit UPNs.  If the object has an explicit UPN,
    // the DsCrackNames will work.  If the object has an implicit UPN,
    // then you need to build it.
    //
    if (DesiredFormat == DS_USER_PRINCIPAL_NAME) {
        RequestedFormat = DS_NT4_ACCOUNT_NAME;
    } else {
        RequestedFormat = DesiredFormat;
    }

    WStatus = DsCrackNames(Handle,             // in   hDS,
                           DS_NAME_NO_FLAGS,   // in   flags,
                           InputFormat      ,  // in   formatOffered,
                           RequestedFormat,    // in   formatDesired,
                           1,                  // in   cNames,
                           &InputName,         // in   *rpNames,
                           &Cracked);          // out  *ppResult

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, ":DS: ERROR - DsCrackNames(%ws, %08x);", InputName, DesiredFormat, WStatus);

        //
        // Set DsBindingsAreValid  to FALSE if the handle has become invalid.
        // That will force us to rebind at the next poll. The guess below might still
        // work so continue processing.
        //
        if (WStatus == ERROR_INVALID_HANDLE) {
            DPRINT1(4, ":DS: Marking binding to %ws as invalid.\n",
                    (DsDomainControllerName) ? DsDomainControllerName : L"<null>");

            DsBindingsAreValid = FALSE;
        }

        //
        // What else can we do?
        //
        if (HANDLE_IS_VALID(LocalHandle)) {
            DsUnBind(&LocalHandle);
            LocalHandle = NULL;
        }

        if (DesiredFormat == DS_NT4_ACCOUNT_NAME) {
            return FrsDsGuessPrincName(InputName);
        } else {
            return NULL;
        }
    }

    //
    // Might have it
    //
    if (Cracked && Cracked->cItems && Cracked->rItems) {
        //
        // Got it!
        //
        if (Cracked->rItems->status == DS_NAME_NO_ERROR) {
            DPRINT1(4, ":DS: Cracked Domain : %ws\n", Cracked->rItems->pDomain);
            DPRINT2(4, ":DS: Cracked Name   : %08x %ws\n",
                    DesiredFormat, Cracked->rItems->pName);

            CrackedDomain = FrsWcsDup(Cracked->rItems->pDomain);
            CrackedName = FrsWcsDup(Cracked->rItems->pName);

        //
        // Only got the domain; rebind and try again
        //
        } else
        if (Cracked->rItems->status == DS_NAME_ERROR_DOMAIN_ONLY) {

            CrackedName = FrsDsConvertName(NULL, InputName, InputFormat, Cracked->rItems->pDomain, DesiredFormat);
        } else {
            DPRINT3(0, ":DS: ERROR - DsCrackNames(%ws, %08x); internal status %d\n",
                    InputName, DesiredFormat, Cracked->rItems->status);

            if (DesiredFormat == DS_NT4_ACCOUNT_NAME) {
                CrackedName = FrsDsGuessPrincName(InputName);
            }
        }


    } else {
        DPRINT2(0, ":DS: ERROR - DsCrackNames(%ws, %08x); no status\n",
                InputName, DesiredFormat);

        if (DesiredFormat == DS_NT4_ACCOUNT_NAME) {
            CrackedName = FrsDsGuessPrincName(InputName);
        }
    }

    if (Cracked) {
        DsFreeNameResult(Cracked);
        Cracked = NULL;
    }

    if (HANDLE_IS_VALID(LocalHandle)) {
        DsUnBind(&LocalHandle);
        LocalHandle = NULL;
    }

RETURN:
    if ((DesiredFormat == DS_USER_PRINCIPAL_NAME) && (CrackedName != NULL) && (CrackedDomain != NULL)) {
        CrackedUPN = FrsDsFormUPN(CrackedName, CrackedDomain);
        FrsFree(CrackedName);
        FrsFree(CrackedDomain);
        return CrackedUPN;

    } else {

        FrsFree(CrackedDomain);
        return CrackedName;
    }
}


PWCHAR
FrsDsGetName(
    IN PWCHAR Dn,
    IN HANDLE Handle,
    IN PWCHAR DomainDnsName,
    IN DWORD  DesiredFormat
    )
/*++
Routine Description:
    Translate the Dn into the desired format. Dn should be the Dn
    of a computer object.

Arguments:
    Dn            - Of computer object
    Handle        - From DsBind
    DomainDnsName - If !NULL, produce new local handle
    DesiredFormat - DS_NT4_ACCOUNT_NAME or DS_STRING_SID_NAME

Return Value:
    Copy of name in desired format; free with FrsFree()
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetName:"

    DWORD           WStatus;
    DS_NAME_RESULT  *Cracked = NULL;
    HANDLE          LocalHandle = NULL;
    PWCHAR          CrackedName = NULL;
    PWCHAR          CrackedDomain = NULL;
    PWCHAR          CrackedUPN = NULL;
    DWORD           RequestedFormat = 0;

    DPRINT2(4, ":DS: Get %08x Name for %ws\n", DesiredFormat, Dn);

    //
    // Computer's Dn not available
    //
    if (!Dn) {
        return NULL;
    }

    //
    // Need something to go on!
    //
    if (!HANDLE_IS_VALID(Handle) && !DomainDnsName) {
        return NULL;
    }

    //
    // Bind to Ds
    //
    if (DomainDnsName) {
        DPRINT3(4, ":DS: Get %08x Name from %ws for %ws\n",
                DesiredFormat, DomainDnsName, Dn);

        WStatus = DsBind(NULL, DomainDnsName, &LocalHandle);
        CLEANUP2_WS(0, ":DS: ERROR - DsBind(%ws, %08x);",
                    DomainDnsName, DesiredFormat, WStatus, RETURN);

        Handle = LocalHandle;
    }

    //
    // Crack the computer's distinguished name into its NT4 Account Name
    //
    // If the Desired format is DS_USER_PRINCIPAL_NAME then we form it by
    // getting the name from DS_NT4_ACCOUNT_NAME and the dns domain name
    // from the "Cracked->rItems->pDomain"
    // We could ask for DS_USER_PRINCIPAL_NAME directly but we don't because.
    // Object can have implicit or explicit UPNs.  If the object has an explicit UPN,
    // the DsCrackNames will work.  If the object has an implicit UPN,
    // then you need to build it.
    //
    if (DesiredFormat == DS_USER_PRINCIPAL_NAME) {
        RequestedFormat = DS_NT4_ACCOUNT_NAME;
    } else {
        RequestedFormat = DesiredFormat;
    }

    WStatus = DsCrackNames(Handle,             // in   hDS,
                           DS_NAME_NO_FLAGS,   // in   flags,
                           DS_FQDN_1779_NAME,  // in   formatOffered,
                           RequestedFormat,    // in   formatDesired,
                           1,                  // in   cNames,
                           &Dn,                // in   *rpNames,
                           &Cracked);          // out  *ppResult

    if (!WIN_SUCCESS(WStatus)) {
        DPRINT2_WS(0, ":DS: ERROR - DsCrackNames(%ws, %08x);", Dn, DesiredFormat, WStatus);

        //
        // Set DsBindingsAreValid  to FALSE if the handle has become invalid.
        // That will force us to rebind at the next poll. The guess below might still
        // work so continue processing.
        //
        if (WStatus == ERROR_INVALID_HANDLE) {
            DPRINT1(4, ":DS: Marking binding to %ws as invalid.\n",
                    (DsDomainControllerName) ? DsDomainControllerName : L"<null>");

            DsBindingsAreValid = FALSE;
        }

        //
        // What else can we do?
        //
        if (HANDLE_IS_VALID(LocalHandle)) {
            DsUnBind(&LocalHandle);
            LocalHandle = NULL;
        }

        if (DesiredFormat == DS_NT4_ACCOUNT_NAME) {
            return FrsDsGuessPrincName(Dn);
        } else {
            return NULL;
        }
    }

    //
    // Might have it
    //
    if (Cracked && Cracked->cItems && Cracked->rItems) {
        //
        // Got it!
        //
        if (Cracked->rItems->status == DS_NAME_NO_ERROR) {
            DPRINT1(4, ":DS: Cracked Domain : %ws\n", Cracked->rItems->pDomain);
            DPRINT2(4, ":DS: Cracked Name   : %08x %ws\n",
                    DesiredFormat, Cracked->rItems->pName);

            CrackedDomain = FrsWcsDup(Cracked->rItems->pDomain);
            CrackedName = FrsWcsDup(Cracked->rItems->pName);

        //
        // Only got the domain; rebind and try again
        //
        } else
        if (Cracked->rItems->status == DS_NAME_ERROR_DOMAIN_ONLY) {

            CrackedName = FrsDsGetName(Dn, NULL, Cracked->rItems->pDomain, DesiredFormat);
        } else {
            DPRINT3(0, ":DS: ERROR - DsCrackNames(%ws, %08x); internal status %d\n",
                    Dn, DesiredFormat, Cracked->rItems->status);

            if (DesiredFormat == DS_NT4_ACCOUNT_NAME) {
                CrackedName = FrsDsGuessPrincName(Dn);
            }
        }


    } else {
        DPRINT2(0, ":DS: ERROR - DsCrackNames(%ws, %08x); no status\n",
                Dn, DesiredFormat);

        if (DesiredFormat == DS_NT4_ACCOUNT_NAME) {
            CrackedName = FrsDsGuessPrincName(Dn);
        }
    }

    if (Cracked) {
        DsFreeNameResult(Cracked);
        Cracked = NULL;
    }

    if (HANDLE_IS_VALID(LocalHandle)) {
        DsUnBind(&LocalHandle);
        LocalHandle = NULL;
    }

RETURN:
    if ((DesiredFormat == DS_USER_PRINCIPAL_NAME) && (CrackedName != NULL) && (CrackedDomain != NULL)) {
        CrackedUPN = FrsDsFormUPN(CrackedName, CrackedDomain);
        FrsFree(CrackedName);
        FrsFree(CrackedDomain);
        return CrackedUPN;

    } else {

        FrsFree(CrackedDomain);
        return CrackedName;
    }
}


VOID
FrsDsCreatePartnerPrincName(
    IN PCONFIG_NODE Sites
    )
/*++
Routine Description:
    Construct the server principal names for our partners.

    Part of NewDs poll APIs.

Arguments:
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCreatePartnerPrincName:"
    PCONFIG_NODE    Cxtion;
    PCONFIG_NODE    Partner;
    PCONFIG_NODE    Site;
    PCONFIG_NODE    Settings;
    PCONFIG_NODE    Set;
    PCONFIG_NODE    Server;
    PVOID           Key;

    //
    // Get all the required information for every computer in the PartnerComputerTable.
    //

    Key = NULL;
    while ((Partner = GTabNextDatum(PartnerComputerTable, &Key)) != NULL) {

        //
        // Get the Server Principal Name.
        //
        if ((Partner->PrincName == NULL) ||
            (*Partner->PrincName == UNICODE_NULL)) {

            Partner->PrincName = FrsDsGetName(Partner->Dn, DsHandle, NULL, DS_NT4_ACCOUNT_NAME);

            if ((Partner->PrincName == NULL) ||
                (*Partner->PrincName == UNICODE_NULL)) {
                //
                // Setting active change to 0 will cause this code to be
                // repeated at the next ds polling cycle.  We do this because
                // the partner's principal name may appear later.
                //
                ActiveChange = 0;
                Partner->Consistent = FALSE;
                continue;
            }
        }

        //
        // Get the partners dnsHostName.
        //
        if (!Partner->DnsName) {
            Partner->DnsName = FrsDsGetDnsName(gLdap, Partner->Dn);
        }

        //
        // Get the partners SID.
        //
        if (!Partner->Sid) {
            Partner->Sid = FrsDsGetName(Partner->Dn, DsHandle, NULL, DS_STRING_SID_NAME);
        }
    }

    //
    // For every cxtion in every replica set.
    //
    Key = NULL;
    while((Cxtion = GTabNextDatum(AllCxtionsTable, &Key)) != NULL) {

        //
        // Ignore inconsistent cxtions
        //
        if (!Cxtion->Consistent) {
            continue;
        }

        //
        // Look for the Cxtion's partner using the PartnerCoDn.
        //

        //
        // Mark this connection inconsistent if it lacks a PartnerCoDn.
        //
        if (Cxtion->PartnerCoDn == NULL) {
            Cxtion->Consistent = FALSE;
            continue;
        }

        Partner = GTabLookupTableString(PartnerComputerTable, Cxtion->PartnerCoDn, NULL);

        //
        // Inconsistent partner; continue
        //
        if (Partner == NULL || !Partner->Consistent) {
            Cxtion->Consistent = FALSE;
            continue;
        }

        //
        // Get out partner's server principal name
        //
        if (!Cxtion->PrincName) {
            Cxtion->PrincName = FrsWcsDup(Partner->PrincName);
        }

        //
        // Get our partner's dns name
        //
        if (!Cxtion->PartnerDnsName) {
            //
            // The partner's DNS name is not critical; we can fall
            // back on our partner's NetBios name.
            //
            if (Partner->DnsName) {
                Cxtion->PartnerDnsName = FrsWcsDup(Partner->DnsName);
            }
        }

        //
        // Get our partner's Sid
        //
        if (!Cxtion->PartnerSid) {
            //
            // The partner's DNS name is not critical; we can fall
            // back on our partner's NetBios name.
            //
            if (Partner->Sid) {
                Cxtion->PartnerSid = FrsWcsDup(Partner->Sid);
            }
        }

    } // cxtion scan

}


ULONG
FrsHashCalcString (
    PVOID Buffer,
    PULONGLONG QKey
    )
{
#undef DEBSUB
#define  DEBSUB  "FrsHashCalcString:"

    PWCHAR Name = (PWCHAR) Buffer;
    ULONG NameLength = 0;
    PWCHAR p = NULL;
    ULONG NameHashUL = 0;
    ULONGLONG NameHashULL = QUADZERO;
    ULONG Shift = 0;

    FRS_ASSERT( Buffer != NULL );
    FRS_ASSERT( QKey != NULL );

    NameLength = wcslen(Name);

    FRS_ASSERT( NameLength != 0 );

    DPRINT1(0, "Name = %ws\n", Name);

    //
    // Combine each unicode character into the hash value, shifting 4 bits
    // each time.  Start at the end of the name so file names with different
    // type codes will hash to different table offsets.
    //
    for( p = &Name[NameLength-1];
         p >= Name;
         p-- ) {

    NameHashUL = NameHashUL ^ (((ULONG)towupper(*p)) << Shift);
        NameHashULL = NameHashULL ^ (((ULONGLONG)towupper(*p)) << Shift);

        Shift = (Shift < 16) ? Shift + 4 : 0;
    }

    *QKey = NameHashULL;

    return NameHashUL;
}

ULONG
PrintPartnerTableEntry (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    )
{
#undef DEBSUB
#define  DEBSUB  "PrintPartnerTableEntry: "

    DPRINT1(0, "PartnerTableEntry: %ws\n", (PWCHAR)(TargetNode->Flags));
    return FrsErrorSuccess;
}

BOOL
StringKeyMatch(
    PVOID Buf,
    PVOID QKey
)
{
#undef DEBSUB
#define  DEBSUB  "StringKeyMatch: "

    PWCHAR String1 = (PWCHAR)Buf;
    PWCHAR String2 = (PWCHAR)QKey;

    return(_wcsicmp(String1, String2)?FALSE:TRUE);
}



VOID
FrsDsCreateNewValidPartnerTableStruct(
    VOID
    )
/*++
Routine Description:
    Uses the AllCxtionsTable to build a new FRS_VALID_PARTNER_TABLE_STRUCT.
    Swaps the new struct with the current one pointed to by the global var
    pValidPartnerTableStruct.
    The old struct gets put on the OldValidPartnerTableStructListHead list.
    Items on the list are cleaned up by calling
    FrsDsCleanupOldValidPartnerTableStructList.

Arguments
    NONE

Return Value:
    NONE

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCreateNewValidPartnerTableStruct:"

    PCXTION         Cxtion = NULL;
    PVOID           Key = NULL;
    PQHASH_TABLE    pNewPartnerTable = NULL;
    PQHASH_TABLE    pNewPartnerConnectionTable = NULL;
    PWCHAR          PartnerSid = NULL;
    PGNAME          pGName = NULL;
    GUID            *pCxtionGuid = NULL;
    PWCHAR          NameEntry = NULL;
    PFRS_VALID_PARTNER_TABLE_STRUCT pNewValidPartnerTableStruct = NULL;
    PFRS_VALID_PARTNER_TABLE_STRUCT pOldValidPartnerTableStruct = NULL;
    GHT_STATUS Status;
    CHAR GuidStr[GUID_CHAR_LEN];

    pNewPartnerTable = FrsAllocTypeSize(QHASH_TABLE_TYPE, PARTNER_NAME_TABLE_SIZE);
    SET_QHASH_TABLE_FLAG(pNewPartnerTable, QHASH_FLAG_LARGE_KEY);
    SET_QHASH_TABLE_HASH_CALC2(pNewPartnerTable, FrsHashCalcString);
    SET_QHASH_TABLE_KEY_MATCH(pNewPartnerTable, StringKeyMatch);
    SET_QHASH_TABLE_FREE(pNewPartnerTable, FrsFree);


    pNewPartnerConnectionTable = FrsAllocTypeSize(QHASH_TABLE_TYPE, PARTNER_CONNECTION_TABLE_SIZE);
    SET_QHASH_TABLE_FLAG(pNewPartnerConnectionTable, QHASH_FLAG_LARGE_KEY);
    SET_QHASH_TABLE_HASH_CALC2(pNewPartnerConnectionTable, ActiveChildrenHashCalc);
    SET_QHASH_TABLE_KEY_MATCH(pNewPartnerConnectionTable, ActiveChildrenKeyMatch);
    SET_QHASH_TABLE_FREE(pNewPartnerConnectionTable, FrsFree);


    //
    // Check each active replica
    //
    ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
        // Loop iterator pE is type PREPLICA.

        //
        // Need to lock Cxtion Table for enumeration.
        // Don't need to hold replica lock - that only protects the filter list
        //
        LOCK_CXTION_TABLE(pE);

        Key = NULL;
        while((Cxtion = GTabNextDatumNoLock(pE->Cxtions, &Key)) != NULL) {

            //
            // Ignore the (local) journal connection.
            //
            if (Cxtion->JrnlCxtion) {
                continue;
            }

            //
            // Create an entry using partner's sid
            //
            PartnerSid = FrsWcsDup(Cxtion->PartnerSid);
            QHashInsertLock(pNewPartnerTable,
                            PartnerSid,
                            NULL,
                            (ULONG_PTR)PartnerSid);

            PartnerSid = FrsWcsDup(Cxtion->PartnerSid);
            pCxtionGuid = FrsDupGuid(Cxtion->Name->Guid);

            QHashInsertLock(pNewPartnerConnectionTable,
                            pCxtionGuid,
                            (PULONGLONG)&PartnerSid,
                            (ULONG_PTR)pCxtionGuid );
        } // cxtion scan

        UNLOCK_CXTION_TABLE(pE);
    );

    //
    // also need to check replicas in error states
    //
    ForEachListEntry( &ReplicaFaultListHead, REPLICA, ReplicaList,
        // Loop iterator pE is type PREPLICA.

        //
        // Need to lock Cxtion Table for enumeration.
        // Don't need to hold replica lock - that only protects the filter list
        //
        LOCK_CXTION_TABLE(pE);

            Key = NULL;
            while((Cxtion = GTabNextDatumNoLock(pE->Cxtions, &Key)) != NULL) {

            //
            // Ignore the (local) journal connection.
            //
            if (Cxtion->JrnlCxtion) {
                continue;
            }

            //
            // Create an entry using partner's sid
            //
            PartnerSid = FrsWcsDup(Cxtion->PartnerSid);
            QHashInsertLock(pNewPartnerTable,
                            PartnerSid,
                            NULL,
                            (ULONG_PTR)PartnerSid);

            PartnerSid = FrsWcsDup(Cxtion->PartnerSid);
            pCxtionGuid = FrsDupGuid(Cxtion->Name->Guid);

            QHashInsertLock(pNewPartnerConnectionTable,
                            pCxtionGuid,
                            (PULONGLONG)&PartnerSid,
                            (ULONG_PTR)pCxtionGuid);
        } // cxtion scan

        UNLOCK_CXTION_TABLE(pE);
    );

    //
    // Don't use stopped replicas. They have probably been deleted.
    //


    pNewValidPartnerTableStruct = FrsAlloc(sizeof(FRS_VALID_PARTNER_TABLE_STRUCT));
    pNewValidPartnerTableStruct->pPartnerConnectionTable = pNewPartnerConnectionTable;
    pNewValidPartnerTableStruct->pPartnerTable = pNewPartnerTable;
    pNewValidPartnerTableStruct->ReferenceCount = 0;
    pNewValidPartnerTableStruct->Next = NULL;

    SWAP_VALID_PARTNER_TABLE_POINTER(pNewValidPartnerTableStruct,
                                     &pOldValidPartnerTableStruct);



    if (pOldValidPartnerTableStruct) {
        EnterCriticalSection(&OldValidPartnerTableStructListHeadLock);
        pOldValidPartnerTableStruct->Next = OldValidPartnerTableStructListHead;
        OldValidPartnerTableStructListHead = pOldValidPartnerTableStruct;
        LeaveCriticalSection(&OldValidPartnerTableStructListHeadLock);
    }

}

VOID
FrsDsCleanupOldValidPartnerTableStructList(
    VOID
    )
/*++
Routine Description:
    Cleanup items on the OldValidPartnerTableStructListHead list.
    Items on the list are freed only if their reference count is at zero.

Arguments
    NONE

Return Value:
    NONE

--*/
{
    PFRS_VALID_PARTNER_TABLE_STRUCT pListItem = NULL;
    PFRS_VALID_PARTNER_TABLE_STRUCT pPreviousItem = NULL;
    PFRS_VALID_PARTNER_TABLE_STRUCT pNextItem = NULL;

    EnterCriticalSection(&OldValidPartnerTableStructListHeadLock);
    pListItem = OldValidPartnerTableStructListHead;

    while (pListItem != NULL) {
        pNextItem = pListItem->Next;
        if (pListItem->ReferenceCount == 0) {
            // remove from list
            if (pPreviousItem != NULL) {
                pPreviousItem->Next = pNextItem;
            } else {
                OldValidPartnerTableStructListHead = pNextItem;
            }

            // cleanup
            FREE_VALID_PARTNER_TABLE_STRUCT(pListItem);
        } else {
            pPreviousItem = pListItem;
        }
        pListItem = pNextItem;

    }
    LeaveCriticalSection(&OldValidPartnerTableStructListHeadLock);
}


BOOL
FrsDsDoesUserWantReplication(
    IN PCONFIG_NODE Computer
    )
/*++
Routine Description:
    Does the topology imply that the user wants this server to replicate?

    Part of NewDs poll APIs.

Arguments
    Computer

Return Value:
    TRUE    - server may be replicating
    FALSE   - server is not replicating
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsDoesUserWantReplication:"
    DWORD           WStatus;
    PCONFIG_NODE    Subscriptions;
    PCONFIG_NODE    Subscriber;

    //
    // Ds polling thread is shutting down
    //
    if (DsIsShuttingDown) {
        DPRINT(0, ":DS: Ds polling thread is shutting down\n");
        return FALSE;
    }

    //
    // Can't find our computer; something is wrong. Don't start
    //
    if (!Computer) {
        DPRINT(0, ":DS: no computer\n");
        return FALSE;
    } else {
        DPRINT(4, ":DS: have a computer\n");
    }

    //
    // We need to process the topology further if there is at least
    // 1 valid subscriber.
    //
    if (SubscriberTable != NULL) {
        return TRUE;
    }

    //
    // Database exists; once was a member of a replica set
    //
    WStatus = FrsDoesFileExist(JetFile);
    if (WIN_SUCCESS(WStatus)) {
        DPRINT(4, ":DS: database exists\n");
        return TRUE;
    } else {
        DPRINT(4, ":DS: database does not exists\n");
    }
    DPRINT1(4, ":DS: Not starting on %ws; nothing to do\n", ComputerName);
    return FALSE;
}


BOOL
FrsDsVerifyPath(
    IN PWCHAR Path
    )
/*++
Routine Description:
    Verify the path syntax.

Arguments:
    Path - Syntax is *<Drive Letter>:\*

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsVerifyPath:"
    PWCHAR  Colon;

    //
    // Null path is obviously invalid
    //
    if (!Path) {
        return FALSE;
    }

    //
    // Find the :
    //
    for (Colon = Path; (*Colon != L':') && *Colon; ++Colon);

    //
    // No :
    //
    if (!*Colon) {
        return FALSE;
    }

    //
    // No drive letter
    //
    if (Colon == Path) {
        return FALSE;
    }

    //
    // No :\
    //
    if (*(Colon + 1) != L'\\') {
        return FALSE;
    }

    //
    // Path exists and is valid
    //
    return TRUE;
}


VOID
FrsDsCheckServerPaths(
    IN PCONFIG_NODE Sites
    )
/*++
Routine Description:
    Look for nested paths and invalid path syntax.

    Correct syntax is "*<drive letter>:\*".

Arguments:
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCheckServerPaths:"
    DWORD           WStatus;
    PCONFIG_NODE    Site;
    PCONFIG_NODE    Settings;
    PCONFIG_NODE    Set;
    PCONFIG_NODE    Server;
    PCONFIG_NODE    NSite;
    PCONFIG_NODE    NSettings;
    PCONFIG_NODE    NSet;
    PCONFIG_NODE    NServer;
    DWORD           FileAttributes = 0xFFFFFFFF;

    for (Site = Sites; Site; Site = Site->Peer) {
    for (Settings = Site->Children; Settings; Settings = Settings->Peer) {
    for (Set = Settings->Children; Set; Set = Set->Peer) {
    for (Server = Set->Children; Server; Server = Server->Peer) {

        //
        // Not this computer; continue
        //
        if (!Server->ThisComputer) {
            continue;
        }

        //
        // Mark this server as processed. This forces the inner loop
        // to skip this server node so that we don't end up comparing
        // this node against itself. Also, this forces this node
        // to be skipped in the inner loop to avoid unnecessary checks.
        //
        // In other words, set this field here, not later in the loop
        // or in any other function.
        //
        Server->VerifiedOverlap = TRUE;

        //
        // Server is very inconsistent, ignore
        //
        if (!Server->Root || !Server->Stage) {
            Server->Consistent = FALSE;
            continue;
        }

        //
        // Syntax of root path is invalid; continue
        //
        if (!FrsDsVerifyPath(Server->Root)) {
            DPRINT2(3, ":DS: Invalid root %ws for %ws\n",
                    Server->Root, Set->Name->Name);
            EPRINT1(EVENT_FRS_ROOT_NOT_VALID, Server->Root);
            Server->Consistent = FALSE;
            continue;
        }

        //
        // Root does not exist or is inaccessable; continue
        //
        WStatus = FrsDoesDirectoryExist(Server->Root, &FileAttributes);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Root path (%ws) for %ws does not exist;",
                       Server->Root, Set->Name->Name, WStatus);
            EPRINT1(EVENT_FRS_ROOT_NOT_VALID, Server->Root);
            Server->Consistent = FALSE;
            continue;
        }

        //
        // Does the volume exist and is it NTFS?
        //
        WStatus = FrsVerifyVolume(Server->Root,
                                  Set->Name->Name,
                                  FILE_PERSISTENT_ACLS | FILE_SUPPORTS_OBJECT_IDS);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Root path Volume (%ws) for %ws does not exist or"
                    " does not support ACLs and Object IDs;",
                    Server->Root, Set->Name->Name, WStatus);
            Server->Consistent = FALSE;
            continue;
        }

        //
        // Syntax of staging path is invalid; continue
        //
        if (!FrsDsVerifyPath(Server->Stage)) {
            DPRINT2(3, ":DS: Invalid stage %ws for %ws\n",
                    Server->Stage, Set->Name->Name);
            EPRINT2(EVENT_FRS_STAGE_NOT_VALID, Server->Root, Server->Stage);
            Server->Consistent = FALSE;
            continue;
        }

        //
        // Stage does not exist or is inaccessable; continue
        //
        WStatus = FrsDoesDirectoryExist(Server->Stage, &FileAttributes);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Stage path (%ws) for %ws does not exist;",
                       Server->Stage, Set->Name->Name, WStatus);
            EPRINT2(EVENT_FRS_STAGE_NOT_VALID, Server->Root, Server->Stage);
            Server->Consistent = FALSE;
            continue;
        }

        //
        // Does the staging volume exist and does it support ACLs?
        // ACLs are required to protect against data theft/corruption
        // in the staging dir.
        //
        WStatus = FrsVerifyVolume(Server->Stage,
                                  Set->Name->Name,
                                  FILE_PERSISTENT_ACLS);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Stage path Volume (%ws) for %ws does not exist or does not support ACLs;",
                    Server->Stage, Set->Name->Name, WStatus);
            Server->Consistent = FALSE;
            continue;
        }
    //
    // End of outer loop
    //
    } } } }

}


DWORD
FrsDsStartPromotionSeeding(
    IN  BOOL        Inbound,
    IN  PWCHAR      ReplicaSetName,
    IN  PWCHAR      ReplicaSetType,
    IN  PWCHAR      CxtionName,
    IN  PWCHAR      PartnerName,
    IN  PWCHAR      PartnerPrincName,
    IN  PWCHAR      PartnerSid,
    IN  ULONG       PartnerAuthLevel,
    IN  ULONG       GuidSize,
    IN  UCHAR       *CxtionGuid,
    IN  UCHAR       *PartnerGuid,
    OUT UCHAR       *ParentGuid
    )
/*++
Routine Description:
    Start the promotion process by seeding the indicated sysvol.

Arguments:
    Inbound             - Inbound cxtion?
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Replica set type
    CxtionName          - printable name for cxtion
    PartnerName         - RPC bindable name
    PartnerPrincName    - Server principal name for kerberos
    PartnerAuthLevel    - Authentication type and level
    GuidSize            - sizeof array addressed by Guid
    CxtionGuid          - temporary: used for volatile cxtion
    PartnerGuid         - temporary: used to find set on partner
    ParentGuid          - Used as partner guid on inbound cxtion

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsStartPromotionSeeding:"
    DWORD       WStatus;
    PREPLICA    DbReplica;
    PCXTION     Cxtion = NULL;

    //
    // The caller has verified that the replica set exists, the
    // active replication subsystem is active, and that some of
    // the parameters are okay. Verify the rest.
    //

    if (!CxtionName       ||
        !PartnerName      ||
        !PartnerPrincName ||
        !CxtionGuid       ||
        !PartnerGuid      ||
        !ParentGuid       ||
        (PartnerAuthLevel != CXTION_AUTH_KERBEROS_FULL &&
         PartnerAuthLevel != CXTION_AUTH_NONE)) {
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }

    //
    // Find the sysvol
    //
    DbReplica = RcsFindSysVolByName(ReplicaSetName);
    if (!DbReplica) {
        DPRINT1(4, ":DS: Promotion failed; could not find %ws\n", ReplicaSetName);
        WStatus = ERROR_INVALID_PARAMETER;
        goto CLEANUP;
    }

    //
    // To be used in the caller's cxtion
    //
    COPY_GUID(ParentGuid, DbReplica->ReplicaName->Guid);

    //
    // PRETEND WE ARE THE DS POLLING THREAD AND ARE ADDING A
    // A CXTION TO AN EXISTING REPLICA.

    //
    // Create the volatile cxtion
    //      Set the state to "promoting" at this time because the
    //      seeding operation may finish and the state set to
    //      NTFRSAPI_SERVICE_DONE before the return of the
    //      call to RcsSubmitReplicaSync().
    //
    DbReplica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_PROMOTING;
    Cxtion = FrsAllocType(CXTION_TYPE);
    Cxtion->Inbound = Inbound;

    SetCxtionFlag(Cxtion, CXTION_FLAGS_CONSISTENT | CXTION_FLAGS_VOLATILE);

    Cxtion->Name = FrsBuildGName(FrsDupGuid((GUID *)CxtionGuid),
                                 FrsWcsDup(CxtionName));

    Cxtion->Partner = FrsBuildGName(FrsDupGuid((GUID *)PartnerGuid),
                                    FrsWcsDup(PartnerName));


    Cxtion->PartnerSid = FrsWcsDup(PartnerSid);
    Cxtion->PartSrvName = FrsWcsDup(PartnerPrincName);
    Cxtion->PartnerDnsName = FrsWcsDup(PartnerName);
    Cxtion->PartnerAuthLevel = PartnerAuthLevel;
    Cxtion->PartnerPrincName = FrsWcsDup(PartnerPrincName);

    SetCxtionState(Cxtion, CxtionStateUnjoined);

    WStatus = RcsSubmitReplicaSync(DbReplica, NULL, Cxtion, CMD_START);
    //
    // The active replication subsystem owns the cxtion, now
    //
    Cxtion = NULL;
    CLEANUP1_WS(0, ":DS: ERROR - Creating cxtion for %ws;",
                ReplicaSetName, WStatus, SYNC_FAIL);

    //
    // Submit a command to periodically check the promotion activity.
    // If nothing has happened in awhile, stop the promotion process.
    //
    if (Inbound) {
        DbReplica->NtFrsApi_HackCount++; // != 0
        RcsSubmitReplica(DbReplica, NULL, CMD_CHECK_PROMOTION);
    }

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;
    goto CLEANUP;

SYNC_FAIL:
    DbReplica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_STATE_IS_UNKNOWN;

    //
    // CLEANUP
    //
CLEANUP:
    FrsFreeType(Cxtion);
    return WStatus;
}

DWORD
FrsDsVerifyPromotionParent(
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType
    )
/*++
Routine Description:
    Start the promotion process by seeding the indicated sysvol.

Arguments:
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Type of set (Enterprise or Domain)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsVerifyPromotionParent:"
    DWORD       WStatus;
    PREPLICA    DbReplica;

    //
    // This parent must be a Dc
    //
    FrsDsGetRole();
    if (!IsADc) {
        DPRINT1(0, ":S: Promotion aborted: %ws is not a dc.\n", ComputerName);
        WStatus = ERROR_SERVICE_SPECIFIC_ERROR;
        goto CLEANUP;
    }

    //
    // WAIT FOR THE ACTIVE REPLICATION SUBSYSTEM TO START
    //
    MainInit();
    if (!MainInitHasRun) {
        WStatus = ERROR_SERVICE_NOT_ACTIVE;
        goto CLEANUP;
    }
    //
    // Let dcpromo determine the timeout
    //
    DPRINT(4, ":S: Waiting for replica command server to start.\n");
    WStatus = WaitForSingleObject(ReplicaEvent, 10 * 60 * 1000);
    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Is the service shutting down?
    //
    if (FrsIsShuttingDown) {
        WStatus = ERROR_SERVICE_NOT_ACTIVE;
        goto CLEANUP;
    }

    //
    // Verify the existence of the set
    //
    DbReplica = RcsFindSysVolByName(ReplicaSetName);
    if (DbReplica && IS_TIME_ZERO(DbReplica->MembershipExpires)) {
        //
        // Sysvol exists; make sure it is the right type
        //
        if (_wcsicmp(ReplicaSetType, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE)) {
            if (DbReplica->ReplicaSetType != FRS_RSTYPE_DOMAIN_SYSVOL) {
                DPRINT3(0, ":S: ERROR - %ws's type is %d; not %d\n",
                        ReplicaSetName, DbReplica->ReplicaSetType,
                        FRS_RSTYPE_DOMAIN_SYSVOL);
                WStatus = ERROR_NOT_FOUND;
                goto CLEANUP;
            }
        } else if (DbReplica->ReplicaSetType != FRS_RSTYPE_ENTERPRISE_SYSVOL) {
            DPRINT3(0, ":S: ERROR - %ws's type is %d; not %d\n",
                    ReplicaSetName, DbReplica->ReplicaSetType,
                    FRS_RSTYPE_ENTERPRISE_SYSVOL);
            WStatus = ERROR_NOT_FOUND;
            goto CLEANUP;
        }
    } else {
        DPRINT2(0, ":S: ERROR - %ws does not exist on %ws!\n",
                ReplicaSetName, ComputerName);
        WStatus = ERROR_NOT_FOUND;
        goto CLEANUP;
    }
    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

    //
    // CLEANUP
    //
CLEANUP:
    return WStatus;
}

VOID
FrsDsVerifySchedule(
    IN PCONFIG_NODE Node
    )
/*++
Routine Description:
    Check the schedule for consistency

Arguments:
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsVerifySchedule:"
    ULONG       i;
    ULONG       Num;
    ULONG       Len;
    ULONG       NumType;
    PSCHEDULE   Schedule = Node->Schedule;

    if (!Schedule) {
        return;
    }

    //
    //  Too many schedules
    //
    Num = Schedule->NumberOfSchedules;
    if (Num > 3) {
        DPRINT2(4, ":DS: %ws has %d schedules\n", Node->Name->Name, Num);
        Node->Consistent = FALSE;
        return;
    }

    //
    //  Too few schedules
    //
    if (Num < 1) {
        DPRINT2(4, ":DS: %ws has %d schedules\n", Node->Name->Name, Num);
        Node->Consistent = FALSE;
        return;
    }

    //
    //  Not enough memory
    //
    Len = sizeof(SCHEDULE) +
          (sizeof(SCHEDULE_HEADER) * (Num - 1)) +
          (SCHEDULE_DATA_BYTES * Num);

    if (Node->ScheduleLength < Len) {
        DPRINT2(4, ":DS: %ws is short (ds) by %d bytes\n",
                Node->Name->Name, Len - Node->ScheduleLength);
        Node->Consistent = FALSE;
        return;
    }

    if (Node->Schedule->Size < Len) {
        DPRINT2(4, ":DS: %ws is short (size) by %d bytes\n",
                Node->Name->Name, Len - Node->Schedule->Size);
        Node->Consistent = FALSE;
        return;
    }
    Node->Schedule->Size = Len;

    //
    //  Invalid type
    //
    for (i = 0; i < Num; ++i) {
        switch (Schedule->Schedules[i].Type) {
            case SCHEDULE_INTERVAL:
                break;
            case SCHEDULE_BANDWIDTH:
                DPRINT1(4, ":DS: WARN Bandwidth schedule is not supported for %ws\n",
                        Node->Name->Name);
                break;
            case SCHEDULE_PRIORITY:
                DPRINT1(4, ":DS: WARN Priority schedule is not supported for %ws\n",
                        Node->Name->Name);
                break;
            default:
                DPRINT2(4, ":DS: %ws has an invalid schedule type (%d)\n",
                        Node->Name->Name, Schedule->Schedules[i].Type);
                Node->Consistent = FALSE;
                return;
        }
    }

    //
    // Only 0 or 1 interval
    //
    for (NumType = i = 0; i < Num; ++i) {
        if (Schedule->Schedules[i].Type == SCHEDULE_INTERVAL)
            ++NumType;
    }
    if (NumType > 1) {
        DPRINT2(4, ":DS: %ws has %d interval schedules\n",
                Node->Name->Name, NumType);
        Node->Consistent = FALSE;
    }

    //
    // Only 0 or 1 bandwidth
    //
    for (NumType = i = 0; i < Num; ++i) {
        if (Schedule->Schedules[i].Type == SCHEDULE_BANDWIDTH)
            ++NumType;
    }
    if (NumType > 1) {
        DPRINT2(4, ":DS: %ws has %d bandwidth schedules\n",
                Node->Name->Name, NumType);
        Node->Consistent = FALSE;
    }

    //
    // Only 0 or 1 priority
    //
    for (NumType = i = 0; i < Num; ++i) {
        if (Schedule->Schedules[i].Type == SCHEDULE_PRIORITY)
            ++NumType;
    }
    if (NumType > 1) {
        DPRINT2(4, ":DS: %ws has %d priority schedules\n",
                Node->Name->Name, NumType);
        Node->Consistent = FALSE;
    }

    //
    //  Invalid offset
    //
    for (i = 0; i < Num; ++i) {
        if (Schedule->Schedules[i].Offset >
            Node->ScheduleLength - SCHEDULE_DATA_BYTES) {
            DPRINT2(4, ":DS: %ws has an invalid offset (%d)\n",
                    Node->Name->Name, Schedule->Schedules[i].Offset);
            Node->Consistent = FALSE;
            return;
        }
    }
}


VOID
FrsDsCheckSchedules(
    IN PCONFIG_NODE Root
    )
/*++
Routine Description:
    Check all of the schedules for consistency

Arguments:
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCheckSchedules:"
    PCONFIG_NODE    Node;

    for (Node = Root; Node; Node = Node->Peer) {
        FrsDsVerifySchedule(Node);
        FrsDsCheckSchedules(Node->Children);
    }
}


VOID
FrsDsPushInConsistenciesDown(
    IN PCONFIG_NODE Sites
    )
/*++
Routine Description:
    Mark the children of inconsistent parents as inconsistent

Arguments:
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsPushInConsistenciesDown:"
    PCONFIG_NODE    Site;
    PCONFIG_NODE    Settings;
    PCONFIG_NODE    Set;
    PCONFIG_NODE    Server;
    PCONFIG_NODE    Cxtion;

    //
    // Push a parent's inconsistency to its children
    //
    for (Site = Sites; Site; Site = Site->Peer) {
        for (Settings = Site->Children; Settings; Settings = Settings->Peer) {
            if (!Site->Consistent)
                Settings->Consistent = FALSE;
            for (Set = Settings->Children; Set; Set = Set->Peer) {
                if (!Settings->Consistent)
                    Set->Consistent = FALSE;
                for (Server = Set->Children; Server; Server = Server->Peer) {
                    if (!Set->Consistent)
                        Server->Consistent = FALSE;
                    for (Cxtion = Server->Children; Cxtion; Cxtion = Cxtion->Peer) {
                        if (!Server->Consistent)
                            Cxtion->Consistent = FALSE;
                    }
                }
            }
        }
    }
}


#if DBG
#define CHECK_NODE_LINKAGE(_Nodes_) FrsDsCheckNodeLinkage(_Nodes)
BOOL
FrsDsCheckNodeLinkage(
    PCONFIG_NODE    Nodes
    )
/*++
Routine Description:
    Recursively check a configuration's site and table linkage
    for incore consistency.

Arguments:
    Nodes   - linked list of nodes

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCheckNodeLinkage:"
    PCONFIG_NODE    Node;           // scan nodes list
    PCONFIG_NODE    Child;          // scan children list
    DWORD           NumChildren;    // Count children

    for (Node = Nodes; Node; Node = Node->Peer) {
        //
        // Make sure the number of children matches the actual number
        //
        NumChildren = 0;
        for (Child = Node->Children; Child; Child = Child->Peer) {
            ++NumChildren;
        }
        FRS_ASSERT(NumChildren == Node->NumChildren);
        if (!FrsDsCheckNodeLinkage(Node->Children))
            return FALSE;
    }
    return TRUE;    // for Assert(DbgCheckLinkage);
}
#else DBG
#define CHECK_NODE_LINKAGE(_Nodes_)
#endif  DBG


#define UF_IS_A_DC  (UF_SERVER_TRUST_ACCOUNT)

BOOL
FrsDsIsPartnerADc(
    IN  PWCHAR      PartnerName
    )
/*++
Routine Description:
    Check if the PartnerName's comptuer object indicates that it is a DC.

Arguments:
    PartnerName         - RPC bindable name

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsIsPartnerADc:"
    DWORD           WStatus;
    DWORD           LStatus;
    DWORD           UserAccountFlags;
    PLDAP           LocalLdap = NULL;
    PLDAPMessage    LdapEntry = NULL;
    PLDAPMessage    LdapMsg = NULL;
    PWCHAR          *Values = NULL;
    PWCHAR          DefaultNamingContext = NULL;
    BOOL            PartnerIsADc = FALSE;
    PWCHAR          UserAccountControl = NULL;
    PWCHAR          Attrs[2];
    WCHAR           Filter[MAX_PATH + 1];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    PWCHAR          SamAccountName = NULL;
    ULONG           ulOptions;

    //
    // Convert the passed in name to sam account name.
    // passed in name is of the form FRS1\FRSTEST23$
    // The sam account name is everything after the first '\'
    //
    SamAccountName = wcschr(PartnerName,L'\\');
    if (SamAccountName == NULL) {
        DPRINT1(0, "PartnerName name supplied is in invalid format; %ws\n", PartnerName);
        goto CLEANUP;
    }
    SamAccountName++;

    DPRINT2(4, ":DS: Converted %ws to %ws\n", PartnerName, SamAccountName);

    //
    // Bind to the DS on this DC
    //
    //
    // if ldap_open is called with a server name the api will call DsGetDcName
    // passing the server name as the domainname parm...bad, because
    // DsGetDcName will make a load of DNS queries based on the server name,
    // it is designed to construct these queries from a domain name...so all
    // these queries will be bogus, meaning they will waste network bandwidth,
    // time to fail, and worst case cause expensive on demand links to come up
    // as referrals/forwarders are contacted to attempt to resolve the bogus
    // names.  By setting LDAP_OPT_AREC_EXCLUSIVE to on using ldap_set_option
    // after the ldap_init but before any other operation using the ldap
    // handle from ldap_init, the delayed connection setup will not call
    // DsGetDcName, just gethostbyname, or if an IP is passed, the ldap client
    // will detect that and use the address directly.
    //
//    LocalLdap = ldap_open(ComputerName, LDAP_PORT);
    LocalLdap = ldap_init(ComputerName, LDAP_PORT);
    if (LocalLdap == NULL) {
        DPRINT1_WS(4, ":DS: WARN - Coult not open DS on %ws;", ComputerName, GetLastError());
        goto CLEANUP;
    }

    ulOptions = PtrToUlong(LDAP_OPT_ON);
    ldap_set_option(LocalLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

    LStatus = ldap_bind_s(LocalLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    CLEANUP1_LS(0, ":DS: WARN - Could not bind to the DS on %ws :",
                ComputerName, LStatus, CLEANUP);

    DPRINT1(4, ":DS: Bound to the DS on %ws\n", ComputerName);

    //
    // Find the default naming context (objectCategory=*)
    //
    MK_ATTRS_1(Attrs, ATTR_DEFAULT_NAMING_CONTEXT);

    if (!FrsDsLdapSearch(LocalLdap, CN_ROOT, LDAP_SCOPE_BASE, CATEGORY_ANY,
                         Attrs, 0, &LdapMsg)) {
        goto CLEANUP;
    }
    LdapEntry = ldap_first_entry(LocalLdap, LdapMsg);
    if (!LdapEntry) {
        goto CLEANUP;
    }
    Values = (PWCHAR *)FrsDsFindValues(LocalLdap,
                                       LdapEntry,
                                       ATTR_DEFAULT_NAMING_CONTEXT,
                                       FALSE);
    if (!Values) {
        goto CLEANUP;
    }
    DefaultNamingContext = FrsWcsDup(Values[0]);
    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);

    DPRINT2(4, ":DS: Default naming context for %ws is %ws\n",
            ComputerName, DefaultNamingContext);

    //
    // Find the account object for PartnerName
    //
    swprintf(Filter, L"(sAMAccountName=%s)", SamAccountName);

    MK_ATTRS_1(Attrs, ATTR_USER_ACCOUNT_CONTROL);

    if (!FrsDsLdapSearchInit(LocalLdap, DefaultNamingContext, LDAP_SCOPE_SUBTREE, Filter,
                         Attrs, 0, &FrsSearchContext)) {
        goto CLEANUP;
    }

    //
    // Scan the returned account objects for a valid DC
    //
    for (LdapEntry = FrsDsLdapSearchNext(LocalLdap, &FrsSearchContext);
         LdapEntry != NULL;
         LdapEntry = FrsDsLdapSearchNext(LocalLdap, &FrsSearchContext)) {

        //
        // No user account control flags
        //
        UserAccountControl = FrsDsFindValue(LocalLdap, LdapEntry, ATTR_USER_ACCOUNT_CONTROL);
        if (!UserAccountControl) {
            continue;
        }
        UserAccountFlags = wcstoul(UserAccountControl, NULL, 10);
        DPRINT2(4, ":DS: UserAccountControl for %ws is 0x%08x\n",
                 SamAccountName, UserAccountFlags);
        //
        // IS A DC!
        //
        if (UserAccountFlags & UF_IS_A_DC) {
            DPRINT1(4, ":DS: Partner %ws is really a DC!\n", SamAccountName);
            PartnerIsADc = TRUE;
            goto CLEANUP;
        }
        FrsFree(UserAccountControl);
    }
    FrsDsLdapSearchClose(&FrsSearchContext);
    DPRINT1(0, ":DS: ERROR - Partner %ws is NOT a DC!\n", SamAccountName);

CLEANUP:
    LDAP_FREE_VALUES(Values);
    LDAP_FREE_MSG(LdapMsg);
    FrsFree(DefaultNamingContext);
    FrsFree(UserAccountControl);
    if (LocalLdap) {
        ldap_unbind_s(LocalLdap);
    }
    DPRINT2(4, ":DS: Partner %ws is %s a DC\n",
            PartnerName, (PartnerIsADc) ? "assumed to be" : "NOT");
    return PartnerIsADc;
}



DWORD
FrsDsGetRole(
    VOID
    )
/*++
Routine Description:
    Get this computer's role in the domain.

Arguments:

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetRole:"
    DWORD   WStatus;
    DWORD   SysvolReady;
    CHAR    GuidStr[GUID_CHAR_LEN];
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *DsRole;

    //
    // We already know our role; carry on
    //
    if (IsAMember) {
        return ERROR_SUCCESS;
    }

    DPRINT(4, ":DS: Finding this computer's role in the domain.\n");

#if DBG
    //
    // Emulating multiple machines
    //
    if (ServerGuid) {
        DPRINT(4, ":DS: Always a member with hardwired config\n");
        IsAMember = TRUE;
        return ERROR_SUCCESS;
    }
#endif DBG

    //
    // Is this a domain controller?
    //
    WStatus = DsRoleGetPrimaryDomainInformation(NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE *)&DsRole);
    CLEANUP_WS(4, ":DS: Can't get Ds role info;", WStatus, RETURN);

    DPRINT1(4, ":DS: Ds Role               : %ws\n", Roles[DsRole->MachineRole]);
    DPRINT1(4, ":DS: Ds Role Flags         : %08x\n", DsRole->Flags);
    if (DsRole->Flags & DSROLE_PRIMARY_DS_RUNNING) {
        DPRINT(4, ":DS: Ds Role Flag          : DSROLE_PRIMARY_DS_RUNNING\n");
    }
    if (DsRole->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT) {
        DPRINT(4, ":DS: Ds Role Flag          : DSROLE_PRIMARY_DOMAIN_GUID_PRESENT\n");
    }
    DPRINT1(4, ":DS: Ds Role DomainNameFlat: %ws\n", DsRole->DomainNameFlat);
    DPRINT1(4, ":DS: Ds Role DomainNameDns : %ws\n", DsRole->DomainNameDns);
    // DPRINT1(4, ":DS: Ds Role DomainForestName: %ws\n", DsRole->DomainForestName);
    GuidToStr(&DsRole->DomainGuid, GuidStr);
    DPRINT1(4, ":DS: Ds Role DomainGuid    : %s\n", GuidStr);

    //
    // Backup Domain Controller (DC)
    //
    if (DsRole->MachineRole == DsRole_RoleBackupDomainController) {
        DPRINT(4, ":DS: Computer is a backup DC; sysvol support is enabled.\n");
        IsAMember = TRUE;
        IsADc = TRUE;
    //
    // Primary Domain Controller (DC)
    //
    } else if (DsRole->MachineRole == DsRole_RolePrimaryDomainController) {
        DPRINT(4, ":DS: Computer is a DC; sysvol support is enabled.\n");
        IsAMember = TRUE;
        IsADc = TRUE;
        IsAPrimaryDc = TRUE;
    //
    // Member Server
    //
    } else if (DsRole->MachineRole == DsRole_RoleMemberServer) {
        DPRINT(4, ":DS: Computer is just a member server.\n");
        IsAMember = TRUE;

#ifdef DS_FREE

    } else if ((DsRole->MachineRole == DsRole_RoleStandaloneServer) && (NoDs == TRUE)) {
        DPRINT(4, ":DS: Computer is running in DS free environment.\n");
        IsAMember = TRUE;

    } else if ((DsRole->MachineRole == DsRole_RoleStandaloneWorkstation) && (NoDs == TRUE)) {
        DPRINT(4, ":DS: Computer is running in DS free environment on non-server.\n");
        IsAMember = TRUE;

    } else if ((DsRole->MachineRole == DsRole_RoleMemberWorkstation) && (NoDs == TRUE)) {
        DPRINT(4, ":DS: Computer is running in DS free environment on non-server.\n");
        IsAMember = TRUE;

#endif DS_FREE
    //
    // Not in a server in a domain; stop the service
    //
    } else {
        DPRINT(1, ":DS: Computer is not a server in a domain.\n");
    }
    DsRoleFreeMemory(DsRole);

    //
    // Has the sysvol been seeded?
    //
    if (IsADc) {
        //
        // Access the netlogon\parameters key to get the sysvol share status
        //
        WStatus = CfgRegReadDWord(FKC_SYSVOL_READY, NULL, 0, &SysvolReady);

        if (WIN_SUCCESS(WStatus)) {
            if (!SysvolReady) {
                EPRINT1((IsAPrimaryDc) ? EVENT_FRS_SYSVOL_NOT_READY_PRIMARY_2 :
                                         EVENT_FRS_SYSVOL_NOT_READY_2,
                        ComputerName);
            }
        } else {
            DPRINT2_WS(0, "ERROR - reading %ws\\%ws :",
                       NETLOGON_SECTION, SYSVOL_READY, WStatus);
        }
    }

    WStatus = ERROR_SUCCESS;

RETURN:
    return WStatus;
}


DWORD
FrsDsCommitDemotion(
    VOID
    )
/*++
Routine Description:
    Commit the demotion process by marking the tombstoned
    sysvols as "do not animate".

Arguments:
    None.

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCommitDemotion:"
    DWORD       WStatus;
    DWORD       i;
    PREPLICA    DbReplica;
    PVOID       Key;
    DWORD       SaveWStatus;
    DWORD       SysvolPathLen;
    PWCHAR      SysvolPath = NULL;
    HANDLE      FileHandle  = INVALID_HANDLE_VALUE;

    //
    // SHUTDOWN THE DS POLLING THREAD
    //      Demotion can run in parallel with the Ds polling thread iff
    //      the polling thread never tries to merge the info in the Ds
    //      with the active replicas. This could result in the sysvol
    //      replica being animated. So, we tell the Ds polling thead to
    //      shut down, wake it up if it is asleep so it can see the shutdown
    //      request, and then synchronize with the merging code in the
    //      Ds polling thread. We don't want to wait for the polling
    //      thread to simply die because it may be stuck talking to the
    //      Ds. Alternatively, we could use async ldap but that would
    //      take too long and is overkill at this time.
    //
    //      In any case, the service will be restarted after dcpromo/demote
    //      by a reboot or a restart-service by the ntfrsapi.
    //
    //
    // PERF: should use async ldap in polling thread.
    //
    DsIsShuttingDown = TRUE;
    SetEvent(DsPollEvent);
    EnterCriticalSection(&MergingReplicasWithDs);
    LeaveCriticalSection(&MergingReplicasWithDs);

    //
    // Is the service shutting down?
    //
    if (FrsIsShuttingDown) {
        WStatus = ERROR_SERVICE_NOT_ACTIVE;
        goto CLEANUP;
    }
    //
    // WAIT FOR THE ACTIVE REPLICATION SUBSYSTEM TO START
    //
    MainInit();
    if (!MainInitHasRun) {
        WStatus = ERROR_SERVICE_NOT_ACTIVE;
        goto CLEANUP;
    }
    //
    // Let dcpromo determine the timeout
    //
    DPRINT(4, ":S: Waiting for replica command server to start.\n");
    WStatus = WaitForSingleObject(ReplicaEvent, 30 * 60 * 1000);
    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // Unshare the sysvol
    //
    RcsSetSysvolReady(0);

    //
    // Mark the tombstoned replica sets for sysvols as "do not animate".
    //
    SaveWStatus = ERROR_SUCCESS;
    Key = NULL;
    while (DbReplica = RcsFindNextReplica(&Key)) {
        //
        // Not a sysvol
        //
        if (!FRS_RSTYPE_IS_SYSVOL(DbReplica->ReplicaSetType)) {
            continue;
        }
        //
        // Not tombstoned
        //
        if (IS_TIME_ZERO(DbReplica->MembershipExpires)) {
            continue;
        }
        //
        // Mark as "do not animate"
        //
        WStatus = RcsSubmitReplicaSync(DbReplica, NULL, NULL, CMD_DELETE_NOW);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, ":S: ERROR - Could not delete %ws now;",
                       DbReplica->ReplicaName->Name, WStatus);
            SaveWStatus = WStatus;
            continue;
        }
        DPRINT1(4, ":S: Deleted %ws in DB", DbReplica->ReplicaName->Name);
        //
        // Reset loop enum key because CMD_DELTE_NOW has removed the entry from
        // the ReplicasByGuid table.
        //
        Key = NULL;

        //
        // Delete ALL OF THE SYSVOL DIRECTORY
        //
        // WARNING:  makes assumptions about tree built by dcpromo.
        //
        if (DbReplica->Root) {
            SysvolPath = FrsFree(SysvolPath);
            SysvolPath = FrsWcsDup(DbReplica->Root);
            SysvolPathLen = wcslen(SysvolPath);
            if (SysvolPathLen) {
                for (i = SysvolPathLen - 1; i; --i) {
                    if (*(SysvolPath + i) == L'\\') {
                        *(SysvolPath + i) = L'\0';
                        DPRINT1(4, ":S: Deleting sysvol path %ws\n", SysvolPath);
                        WStatus = FrsDeletePath(SysvolPath,
                                                ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE);
                        if (!WIN_SUCCESS(WStatus)) {
                            DPRINT1_WS(3, ":S: Warn - FrsDeletePath(%ws); (IGNORED)",
                                    SysvolPath, WStatus);
                            WStatus = ERROR_SUCCESS;
                        }
                        break;
                    }
                }
            }
        }

        //
        // The original code deleted the root and staging directories, not
        // the entire sysvol tree. Allow the original code to execute in
        // case the new code above runs into problems.
        //

        //
        // Why wouldn't a replica set have a root path? But, BSTS.
        //
        if (!DbReplica->Root) {
            continue;
        }

        //
        // DELETE THE CONTENTS OF THE ROOT DIRECTORY
        // Always open the replica root by masking off the FILE_OPEN_REPARSE_POINT flag
        // because we want to open the destination dir not the junction if the root
        // happens to be a mount point.
        //
        WStatus = FrsOpenSourceFileW(&FileHandle,
                                     DbReplica->Root,
//                                     WRITE_ACCESS | READ_ACCESS,
                                     DELETE | READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                     OPEN_OPTIONS & ~FILE_OPEN_REPARSE_POINT);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, ":S: ERROR - Cannot open root of replica tree %ws;",
                       DbReplica->Root, WStatus);
            continue;
        }
        //
        // Remove object id
        //
        WStatus = FrsDeleteFileObjectId(FileHandle, DbReplica->Root);
        DPRINT1_WS(0, ":S: ERROR - Cannot remove object id from root "
                      "of replica tree %ws; Continue with delete",
                      DbReplica->Root, WStatus);
        //
        // Delete files/subdirs
        //
        FrsEnumerateDirectory(FileHandle,
                              DbReplica->Root,
                              0,
                              ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                              NULL,
                              FrsEnumerateDirectoryDeleteWorker);
        DPRINT1(4, ":S: Deleted files/subdirs for %ws\n", DbReplica->Root);

        FRS_CLOSE(FileHandle);

        //
        // Why wouldn't a replica set have a stage path? But, BSTS.
        //
        if (!DbReplica->Stage) {
            continue;
        }

        //
        // DELETE THE CONTENTS OF THE STAGE DIRECTORY
        //
        WStatus = FrsOpenSourceFileW(&FileHandle,
                                     DbReplica->Stage,
//                                     WRITE_ACCESS | READ_ACCESS,
                                     DELETE | READ_ATTRIB_ACCESS | WRITE_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                     OPEN_OPTIONS);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1_WS(0, ":S: ERROR - Cannot open stage of replica tree %ws;",
                       DbReplica->Root, WStatus);
            continue;
        }
        //
        // Delete files/subdirs
        //
        FrsEnumerateDirectory(FileHandle,
                              DbReplica->Stage,
                              0,
                              ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE,
                              NULL,
                              FrsEnumerateDirectoryDeleteWorker);
        DPRINT1(4, ":S: Deleted files/subdirs for %ws\n", DbReplica->Stage);
        FRS_CLOSE(FileHandle);
    }
    WStatus = SaveWStatus;
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;
    DPRINT(4, ":S: Successfully marked tombstoned sysvols as do not animate.\n");

    //
    // CLEANUP
    //
CLEANUP:
    FRS_CLOSE(FileHandle);
    SysvolPath = FrsFree(SysvolPath);
    return WStatus;
}


DWORD
FrsDsStartDemotion(
    IN PWCHAR   ReplicaSetName
    )
/*++
Routine Description:
    Start the demotion process by tombstoning the sysvol.

Arguments:
    ReplicaSetName      - Replica set name

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsStartDemotion:"
    DWORD       WStatus;
    DWORD       FStatus;
    DWORD       DbReplicaSetType;
    PREPLICA    DbReplica;

    //
    // SHUTDOWN THE DS POLLING THREAD
    //      Demotion can run in parallel with the Ds polling thread iff
    //      the polling thread never tries to merge the info in the Ds
    //      with the active replicas. This could result in the sysvol
    //      replica being animated. So, we tell the Ds polling thead to
    //      shut down, wake it up if it is asleep so it can see the shutdown
    //      request, and then synchronize with the merging code in the
    //      Ds polling thread. We don't want to wait for the polling
    //      thread to simply die because it may be stuck talking to the
    //      Ds. Alternatively, we could use async ldap but that would
    //      take too long and is overkill at this time.
    //
    //      In any case, the service will be restarted after dcpromo/demote
    //      by a reboot or a restart-service by the ntfrsapi.
    //
    //
    // PERF: should use async ldap in polling thread.
    //
    DsIsShuttingDown = TRUE;
    SetEvent(DsPollEvent);
    EnterCriticalSection(&MergingReplicasWithDs);
    LeaveCriticalSection(&MergingReplicasWithDs);

    //
    // Is the service shutting down?
    //
    if (FrsIsShuttingDown) {
        WStatus = ERROR_SERVICE_NOT_ACTIVE;
        goto cleanup;
    }
    //
    // WAIT FOR THE ACTIVE REPLICATION SUBSYSTEM TO START
    //
    MainInit();
    if (!MainInitHasRun) {
        WStatus = ERROR_SERVICE_NOT_ACTIVE;
        goto cleanup;
    }
    //
    // Let dcpromo determine the timeout
    //
    DPRINT(4, ":S: Waiting for replica command server to start.\n");
    WStatus = WaitForSingleObject(ReplicaEvent, 30 * 60 * 1000);
    CHECK_WAIT_ERRORS(3, WStatus, 1, ACTION_RETURN);

    //
    // TOMBSTONE THE REPLICA SET IN THE ACTIVE REPLICATION SUBSYSTEM
    //

    //
    // Find the sysvol replica and tombstone it.
    //
    DbReplica = RcsFindSysVolByName(ReplicaSetName);
    //
    // Can't find by name, not the enterprise sysvol, and not the
    // special call during promotion. See if the name of the domain
    // sysvol was mapped into CN_DOMAIN_SYSVOL. (B3 naming)
    //
    if (!DbReplica &&
        WSTR_NE(ReplicaSetName, L"enterprise") &&
        WSTR_NE(ReplicaSetName, L"")) {
        //
        // domain name may have been mapped into CN_DOMAIN_SYSVOL (new B3 naming)
        //
        DbReplica = RcsFindSysVolByName(CN_DOMAIN_SYSVOL);
    }
    if (DbReplica) {
            //
            // Tombstone the replica set.  The set won't actually be deleted
            // until the tombstone expires.  If dcdemote fails the replica set
            // will be reanimated when the service restarts.
            //
            // If dcdemote succeeds, the tombstone expiration will be set to
            // yesterday so the replica set will never be animated.  See
            // FrsDsCommitDemotion.
            //
            WStatus = RcsSubmitReplicaSync(DbReplica, NULL, NULL, CMD_DELETE);
            CLEANUP2_WS(0, ":S: ERROR - can't delete %ws on %ws;",
                        DbReplica->ReplicaName->Name, ComputerName, WStatus, cleanup);

            DPRINT2(0, ":S: Deleted %ws on %ws\n", ReplicaSetName, ComputerName);
    } else if (!wcscmp(ReplicaSetName, L"")) {
        //
        // Special case called during promotion. Delete existing sysvols
        // that may exist from a previous full install or stale database.
        //
        // Make sure the sysvol doesn't already exist. If it does but is
        // tombstoned, set the tombstone to "do not animate". Otherwise,
        // error off.
        //
        DbReplicaSetType = FRS_RSTYPE_ENTERPRISE_SYSVOL;
again:
        DbReplica = RcsFindSysVolByType(DbReplicaSetType);
        if (!DbReplica) {
            if (DbReplicaSetType == FRS_RSTYPE_ENTERPRISE_SYSVOL) {
                DbReplicaSetType = FRS_RSTYPE_DOMAIN_SYSVOL;
                goto again;
            }
        }
        if (DbReplica) {
            DPRINT2(4, ":S: WARN - Sysvol %ws exists for %ws; deleting!\n",
                    DbReplica->ReplicaName->Name, ComputerName);
            //
            // Find our role. If we aren't a DC or the sysvol has been
            // tombstoned, delete it now.
            //
            FrsDsGetRole();
            if (!IS_TIME_ZERO(DbReplica->MembershipExpires) || !IsADc) {
                //
                // Once the MembershipExpires has been set to a time less
                // than Now the replica set will never appear again. The
                // replica sticks around for now since the RPC server
                // may be putting command packets on this replica's queue.
                // The packets will be ignored. The replica will be deleted
                // from the database the next time the service starts. Even
                // if the deletion fails, the rest of the service will
                // not see the replica because the replica struct is not
                // put in the table of active replicas. The deletion is
                // retried at startup.
                //
                WStatus = RcsSubmitReplicaSync(DbReplica, NULL, NULL, CMD_DELETE_NOW);
                CLEANUP1_WS(0, ":S: ERROR - can't delete %ws;",
                            DbReplica->ReplicaName->Name, WStatus, cleanup);
                goto again;
            } else {
                DPRINT2(0, ":S: ERROR - Cannot delete %ws for %ws!\n",
                        DbReplica->ReplicaName->Name, ComputerName);
                WStatus = ERROR_DUP_NAME;
                goto cleanup;
            }
        }
    } else {
        DPRINT1(0, ":S: Sysvol %ws not found; declaring victory\n", ReplicaSetName);
    }

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

    //
    // CLEANUP
    //
cleanup:
    return WStatus;
}


VOID
FrsDsFreeTree(
    PCONFIG_NODE    Root
    )
/*++
Routine Description:
    Free every node in a tree

Arguments:
    Root

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFreeTree:"
    PCONFIG_NODE    Node;

    while (Root != NULL) {
        Node = Root;
        Root = Root->Peer;
        FrsDsFreeTree(Node->Children);
        FrsFreeType(Node);
    }
}







VOID
FrsDsSwapPtrs(
    PVOID *P1,
    PVOID *P2
    )
/*++
Routine Description:
    Swap two pointers.

Arguments:
    P1      - address of a pointer
    P2      - address of a pointer

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsSwapPtrs:"
    PVOID   Tmp;

    Tmp = *P2;
    *P2 = *P1;
    *P1 = Tmp;
}


#if DBG
//
// Hardwired configuration for testing w/o the DS
//

#define HW_MACHINES 8
#define THIS_COMPUTER   L"[This Computer]"

typedef struct _HardWired{
    PWCHAR  Machine;
    PWCHAR  Server;
    PWCHAR  Replica;
    BOOL    IsPrimary;
    PWCHAR  FileFilterList;
    PWCHAR  DirFilterList;
    PWCHAR  InNames[HW_MACHINES];
    PWCHAR  InMachines[HW_MACHINES];
    PWCHAR  InServers[HW_MACHINES];
    PWCHAR  OutNames[HW_MACHINES];
    PWCHAR  OutMachines[HW_MACHINES];
    PWCHAR  OutServers[HW_MACHINES];
    PWCHAR  Stage;
    PWCHAR  Root;
    PWCHAR  JetPath;
} HARDWIRED, *PHARDWIRED;


//
// This hard wired configuration is loaded if a path
// to a ini file is provided at command line.
//
PHARDWIRED LoadedWired;

HARDWIRED DavidWired[] = {
/*
t:
cd \
md \staging
md \Replica-A\SERVO1
md \jet
md \jet\serv01
md \jet\serv01\sys
md \jet\serv01\temp
md \jet\serv01\log

u:
cd \
md \staging
md \Replica-A\SERVO2
md \jet
md \jet\serv02
md \jet\serv02\sys
md \jet\serv02\temp
md \jet\serv02\log

s:
cd \
md \staging
md \Replica-A\SERVO3
md \jet
md \jet\serv03
md \jet\serv03\sys
md \jet\serv03\temp
md \jet\serv03\log

*/



#define RSA               L"Replica-A"

#define TEST_MACHINE_NAME  THIS_COMPUTER


#define SERVER_1          L"SERV01"
#define MACHINE_1         TEST_MACHINE_NAME

#define SERVER_2          L"SERV02"
#define MACHINE_2         TEST_MACHINE_NAME

#define SERVER_3          L"SERV03"
#define MACHINE_3         TEST_MACHINE_NAME

#define SERVER_4          L"SERV04"
#define MACHINE_4         TEST_MACHINE_NAME

#define SERVER_5          L"SERV05"
#define MACHINE_5         TEST_MACHINE_NAME

#define SERVER_6          L"SERV06"
#define MACHINE_6         TEST_MACHINE_NAME

#define SERVER_7          L"SERV07"
#define MACHINE_7         TEST_MACHINE_NAME

#define SERVER_8          L"SERV08"
#define MACHINE_8         TEST_MACHINE_NAME

/*
    // These are the old vol assignments
#define SERVER_1_VOL      L"t:"
#define SERVER_2_VOL      L"u:"
#define SERVER_3_VOL      L"s:"
#define SERVER_4_VOL      L"v:"
#define SERVER_5_VOL      L"w:"
#define SERVER_6_VOL      L"x:"
#define SERVER_7_VOL      L"y:"
#define SERVER_8_VOL      L"z:"
*/

// /*
    // These are the new vol assignments
#define SERVER_1_VOL      L"d:"
#define SERVER_2_VOL      L"e:"
#define SERVER_3_VOL      L"f:"
#define SERVER_4_VOL      L"g:"
#define SERVER_5_VOL      L"h:"
#define SERVER_6_VOL      L"i:"
#define SERVER_7_VOL      L"j:"
#define SERVER_8_VOL      L"k:"
// */


/*
//
// NOTE:  The following was generated from an excel spreadsheet
// \nt\private\net\svcimgs\ntrepl\topology.xls
// Hand generation is a bit tedious and error prone so use the spreadsheet.
//

    //
    // David's 8-way fully connected
    //
 TEST_MACHINE_NAME, // machine
 SERVER_1,  // server name
 RSA,   // replica
 TRUE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT2_1", L"CXT3_1",  L"CXT4_1",  L"CXT5_1",  L"CXT6_1",  L"CXT7_1",  L"CXT8_1",  NULL},  // inbound cxtions
{MACHINE_2, MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // inbound machines
{SERVER_2,  SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // inbound servers
{L"CXT1_2", L"CXT1_3",  L"CXT1_4",  L"CXT1_5",  L"CXT1_6",  L"CXT1_7",  L"CXT1_8",  NULL},  // outbound cxtions
{MACHINE_2, MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // outbound machines
{SERVER_2,  SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // outbound servers
 SERVER_1_VOL  L"\\staging",                        // stage
 SERVER_1_VOL  L"\\" RSA L"\\" SERVER_1,                        // root
 SERVER_1_VOL  L"\\jet\\" SERVER_1,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_2,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_2", L"CXT3_2",  L"CXT4_2",  L"CXT5_2",  L"CXT6_2",  L"CXT7_2",  L"CXT8_2",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // inbound machines
{SERVER_1,  SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // inbound servers
{L"CXT2_1", L"CXT2_3",  L"CXT2_4",  L"CXT2_5",  L"CXT2_6",  L"CXT2_7",  L"CXT2_8",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // outbound machines
{SERVER_1,  SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // outbound servers
 SERVER_2_VOL  L"\\staging",                        // stage
 SERVER_2_VOL  L"\\" RSA L"\\" SERVER_2,                        // root
 SERVER_2_VOL  L"\\jet\\" SERVER_2,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_3,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_3", L"CXT2_3",  L"CXT4_3",  L"CXT5_3",  L"CXT6_3",  L"CXT7_3",  L"CXT8_3",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // inbound machines
{SERVER_1,  SERVER_2,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // inbound servers
{L"CXT3_1", L"CXT3_2",  L"CXT3_4",  L"CXT3_5",  L"CXT3_6",  L"CXT3_7",  L"CXT3_8",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // outbound machines
{SERVER_1,  SERVER_2,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // outbound servers
 SERVER_3_VOL  L"\\staging",                        // stage
 SERVER_3_VOL  L"\\" RSA L"\\" SERVER_3,                        // root
 SERVER_3_VOL  L"\\jet\\" SERVER_3,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_4,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_4", L"CXT2_4",  L"CXT3_4",  L"CXT5_4",  L"CXT6_4",  L"CXT7_4",  L"CXT8_4",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // inbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // inbound servers
{L"CXT4_1", L"CXT4_2",  L"CXT4_3",  L"CXT4_5",  L"CXT4_6",  L"CXT4_7",  L"CXT4_8",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_5,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // outbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_5,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // outbound servers
 SERVER_4_VOL  L"\\staging",                        // stage
 SERVER_4_VOL  L"\\" RSA L"\\" SERVER_4,                        // root
 SERVER_4_VOL  L"\\jet\\" SERVER_4,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_5,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_5", L"CXT2_5",  L"CXT3_5",  L"CXT4_5",  L"CXT6_5",  L"CXT7_5",  L"CXT8_5",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // inbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // inbound servers
{L"CXT5_1", L"CXT5_2",  L"CXT5_3",  L"CXT5_4",  L"CXT5_6",  L"CXT5_7",  L"CXT5_8",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_6,  MACHINE_7,  MACHINE_8,  NULL},  // outbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_6,   SERVER_7,   SERVER_8,   NULL},  // outbound servers
 SERVER_5_VOL  L"\\staging",                        // stage
 SERVER_5_VOL  L"\\" RSA L"\\" SERVER_5,                        // root
 SERVER_5_VOL  L"\\jet\\" SERVER_5,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_6,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_6", L"CXT2_6",  L"CXT3_6",  L"CXT4_6",  L"CXT5_6",  L"CXT7_6",  L"CXT8_6",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_7,  MACHINE_8,  NULL},  // inbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_5,   SERVER_7,   SERVER_8,   NULL},  // inbound servers
{L"CXT6_1", L"CXT6_2",  L"CXT6_3",  L"CXT6_4",  L"CXT6_5",  L"CXT6_7",  L"CXT6_8",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_7,  MACHINE_8,  NULL},  // outbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_5,   SERVER_7,   SERVER_8,   NULL},  // outbound servers
 SERVER_6_VOL  L"\\staging",                        // stage
 SERVER_6_VOL  L"\\" RSA L"\\" SERVER_6,                        // root
 SERVER_6_VOL  L"\\jet\\" SERVER_6,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_7,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_7", L"CXT2_7",  L"CXT3_7",  L"CXT4_7",  L"CXT5_7",  L"CXT6_7",  L"CXT8_7",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_8,  NULL},  // inbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_8,   NULL},  // inbound servers
{L"CXT7_1", L"CXT7_2",  L"CXT7_3",  L"CXT7_4",  L"CXT7_5",  L"CXT7_6",  L"CXT7_8",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_8,  NULL},  // outbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_8,   NULL},  // outbound servers
 SERVER_7_VOL  L"\\staging",                        // stage
 SERVER_7_VOL  L"\\" RSA L"\\" SERVER_7,                        // root
 SERVER_7_VOL  L"\\jet\\" SERVER_7,                     // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_8,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_8", L"CXT2_8",  L"CXT3_8",  L"CXT4_8",  L"CXT5_8",  L"CXT6_8",  L"CXT7_8",  NULL},  // inbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  NULL},  // inbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   NULL},  // inbound servers
{L"CXT8_1", L"CXT8_2",  L"CXT8_3",  L"CXT8_4",  L"CXT8_5",  L"CXT8_6",  L"CXT8_7",  NULL},  // outbound cxtions
{MACHINE_1, MACHINE_2,  MACHINE_3,  MACHINE_4,  MACHINE_5,  MACHINE_6,  MACHINE_7,  NULL},  // outbound machines
{SERVER_1,  SERVER_2,   SERVER_3,   SERVER_4,   SERVER_5,   SERVER_6,   SERVER_7,   NULL},  // outbound servers
    SERVER_8_VOL  L"\\staging",                     // stage
    SERVER_8_VOL  L"\\" RSA L"\\" SERVER_8,                     // root
    SERVER_8_VOL  L"\\jet\\" SERVER_8,                      // Jet Path

*/

///*
 //
 // 8 way ring
 //

 TEST_MACHINE_NAME, // machine
 SERVER_1,  // server name
 RSA,   // replica
 TRUE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT2_1", L"CXT8_1",  NULL    },  // inbound cxtions
{MACHINE_2, MACHINE_8,  NULL    },  // inbound machines
{SERVER_2,  SERVER_8,   NULL    },  // inbound servers
{L"CXT1_2", L"CXT1_8",  NULL    },  // outbound cxtions
{MACHINE_2, MACHINE_8,  NULL    },  // outbound machines
{SERVER_2,  SERVER_8,   NULL    },  // outbound servers
 SERVER_1_VOL   L"\\staging",   // stage
 SERVER_1_VOL   L"\\" RSA L"\\" SERVER_1,   // root
 SERVER_1_VOL   L"\\jet\\" SERVER_1,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_2,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT3_2", L"CXT1_2",  NULL    },  // inbound cxtions
{MACHINE_3, MACHINE_1,  NULL    },  // inbound machines
{SERVER_3,  SERVER_1,   NULL    },  // inbound servers
{L"CXT2_3", L"CXT2_1",  NULL    },  // outbound cxtions
{MACHINE_3, MACHINE_1,  NULL    },  // outbound machines
{SERVER_3,  SERVER_1,   NULL    },  // outbound servers
 SERVER_2_VOL   L"\\staging",   // stage
 SERVER_2_VOL   L"\\" RSA L"\\" SERVER_2,   // root
 SERVER_2_VOL   L"\\jet\\" SERVER_2,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_3,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT4_3", L"CXT2_3",  NULL    },  // inbound cxtions
{MACHINE_4, MACHINE_2,  NULL    },  // inbound machines
{SERVER_4,  SERVER_2,   NULL    },  // inbound servers
{L"CXT3_4", L"CXT3_2",  NULL    },  // outbound cxtions
{MACHINE_4, MACHINE_2,  NULL    },  // outbound machines
{SERVER_4,  SERVER_2,   NULL    },  // outbound servers
 SERVER_3_VOL   L"\\staging",   // stage
 SERVER_3_VOL   L"\\" RSA L"\\" SERVER_3,   // root
 SERVER_3_VOL   L"\\jet\\" SERVER_3,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_4,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT5_4", L"CXT3_4",  NULL    },  // inbound cxtions
{MACHINE_5, MACHINE_3,  NULL    },  // inbound machines
{SERVER_5,  SERVER_3,   NULL    },  // inbound servers
{L"CXT4_5", L"CXT4_3",  NULL    },  // outbound cxtions
{MACHINE_5, MACHINE_3,  NULL    },  // outbound machines
{SERVER_5,  SERVER_3,   NULL    },  // outbound servers
 SERVER_4_VOL   L"\\staging",   // stage
 SERVER_4_VOL   L"\\" RSA L"\\" SERVER_4,   // root
 SERVER_4_VOL   L"\\jet\\" SERVER_4,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_5,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT6_5", L"CXT4_5",  NULL    },  // inbound cxtions
{MACHINE_6, MACHINE_4,  NULL    },  // inbound machines
{SERVER_6,  SERVER_4,   NULL    },  // inbound servers
{L"CXT5_6", L"CXT5_4",  NULL    },  // outbound cxtions
{MACHINE_6, MACHINE_4,  NULL    },  // outbound machines
{SERVER_6,  SERVER_4,   NULL    },  // outbound servers
 SERVER_5_VOL   L"\\staging",   // stage
 SERVER_5_VOL   L"\\" RSA L"\\" SERVER_5,   // root
 SERVER_5_VOL   L"\\jet\\" SERVER_5,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_6,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT7_6", L"CXT5_6",  NULL    },  // inbound cxtions
{MACHINE_7, MACHINE_5,  NULL    },  // inbound machines
{SERVER_7,  SERVER_5,   NULL    },  // inbound servers
{L"CXT6_7", L"CXT6_5",  NULL    },  // outbound cxtions
{MACHINE_7, MACHINE_5,  NULL    },  // outbound machines
{SERVER_7,  SERVER_5,   NULL    },  // outbound servers
 SERVER_6_VOL   L"\\staging",   // stage
 SERVER_6_VOL   L"\\" RSA L"\\" SERVER_6,   // root
 SERVER_6_VOL   L"\\jet\\" SERVER_6,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_7,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT8_7", L"CXT6_7",  NULL    },  // inbound cxtions
{MACHINE_8, MACHINE_6,  NULL    },  // inbound machines
{SERVER_8,  SERVER_6,   NULL    },  // inbound servers
{L"CXT7_8", L"CXT7_6",  NULL    },  // outbound cxtions
{MACHINE_8, MACHINE_6,  NULL    },  // outbound machines
{SERVER_8,  SERVER_6,   NULL    },  // outbound servers
 SERVER_7_VOL   L"\\staging",   // stage
 SERVER_7_VOL   L"\\" RSA L"\\" SERVER_7,   // root
 SERVER_7_VOL   L"\\jet\\" SERVER_7,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_8,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_8", L"CXT7_8",  NULL    },  // inbound cxtions
{MACHINE_1, MACHINE_7,  NULL    },  // inbound machines
{SERVER_1,  SERVER_7,   NULL    },  // inbound servers
{L"CXT8_1", L"CXT8_7",  NULL    },  // outbound cxtions
{MACHINE_1, MACHINE_7,  NULL    },  // outbound machines
{SERVER_1,  SERVER_7,   NULL    },  // outbound servers
 SERVER_8_VOL   L"\\staging",   // stage
 SERVER_8_VOL   L"\\" RSA L"\\" SERVER_8,   // root
 SERVER_8_VOL   L"\\jet\\" SERVER_8,    // Jet Path


//*/


#define CXT_2_FM_1        L"CXT1_2"
#define CXT_3_FM_1        L"CXT1_3"
#define CXT_4_FM_1        L"CXT1_4"
#define CXT_1_FM_2        L"CXT2_1"
#define CXT_3_FM_2        L"CXT2_3"
#define CXT_4_FM_2        L"CXT2_4"
#define CXT_1_FM_3        L"CXT3_1"
#define CXT_2_FM_3        L"CXT3_2"
#define CXT_4_FM_3        L"CXT3_4"
#define CXT_1_FM_4        L"CXT4_1"
#define CXT_2_FM_4        L"CXT4_2"
#define CXT_3_FM_4        L"CXT4_3"

#define CXT_1_TO_2        L"CXT1_2"
#define CXT_1_TO_3        L"CXT1_3"
#define CXT_1_TO_4        L"CXT1_4"
#define CXT_2_TO_1        L"CXT2_1"
#define CXT_2_TO_3        L"CXT2_3"
#define CXT_2_TO_4        L"CXT2_4"
#define CXT_3_TO_1        L"CXT3_1"
#define CXT_3_TO_2        L"CXT3_2"
#define CXT_3_TO_4        L"CXT3_4"
#define CXT_4_TO_1        L"CXT4_1"
#define CXT_4_TO_2        L"CXT4_2"
#define CXT_4_TO_3        L"CXT4_3"


/*
    //
    // David's 4-way
    //
    TEST_MACHINE_NAME,                                                  // machine
    SERVER_1,                                                           // server name
        RSA,                                                            // replica
        TRUE,                                                           // IsPrimary
        NULL, NULL,                                                     // File/Dir Filter
        { CXT_1_FM_2,        CXT_1_FM_3,   CXT_1_FM_4,       NULL },    // inbound cxtions
        { MACHINE_2,         MACHINE_3,    MACHINE_4,        NULL },    // inbound machines
        { SERVER_2,          SERVER_3,     SERVER_4,         NULL },    // inbound servers
        { CXT_1_TO_2,        CXT_1_TO_3,   CXT_1_TO_4,       NULL },    // outbound cxtions
        { MACHINE_2,         MACHINE_3,    MACHINE_4,        NULL },    // outbound machines
        { SERVER_2,          SERVER_3,     SERVER_4,         NULL },    // outbound servers
        SERVER_1_VOL L"\\staging",                                      // stage
        SERVER_1_VOL L"\\" RSA L"\\" SERVER_1,                          // root
        SERVER_1_VOL L"\\jet\\" SERVER_1,                               // Jet Path

    TEST_MACHINE_NAME,                                                  // machine
    SERVER_2,                                                           // server name
        RSA,                                                            // replica
        FALSE,                                                          // IsPrimary
        NULL, NULL,                                                     // File/Dir Filter
        { CXT_2_FM_1,        CXT_2_FM_3,   CXT_2_FM_4,       NULL },    // inbound cxtions
        { MACHINE_1,         MACHINE_3,    MACHINE_4,        NULL },    // inbound machines
        { SERVER_1,          SERVER_3,     SERVER_4,         NULL },    // inbound servers
        { CXT_2_TO_1,        CXT_2_TO_3,   CXT_2_TO_4,       NULL },    // outbound cxtions
        { MACHINE_1,         MACHINE_3,    MACHINE_4,        NULL },    // outbound machines
        { SERVER_1,          SERVER_3,     SERVER_4,         NULL },    // outbound servers
        SERVER_2_VOL L"\\staging",                                      // stage
        SERVER_2_VOL L"\\" RSA L"\\" SERVER_2,                          // root
        SERVER_2_VOL L"\\jet\\" SERVER_2,                               // Jet Path

    TEST_MACHINE_NAME,                                                  // machine
    SERVER_3,                                                           // server name
        RSA,                                                            // replica
        FALSE,                                                          // IsPrimary
        NULL, NULL,                                                     // File/Dir Filter
        { CXT_3_FM_1,        CXT_3_FM_2,   CXT_3_FM_4,       NULL },    // inbound cxtions
        { MACHINE_1,         MACHINE_2,    MACHINE_4,        NULL },    // inbound machines
        { SERVER_1,          SERVER_2,     SERVER_4,         NULL },    // inbound servers
        { CXT_3_TO_1,        CXT_3_TO_2,   CXT_3_TO_4,       NULL },    // outbound cxtions
        { MACHINE_1,         MACHINE_2,    MACHINE_4,        NULL },    // outbound machines
        { SERVER_1,          SERVER_2,     SERVER_4,         NULL },    // outbound servers
        SERVER_3_VOL L"\\staging",                                      // stage
        SERVER_3_VOL L"\\" RSA L"\\" SERVER_3,                          // root
        SERVER_3_VOL L"\\jet\\" SERVER_3,                               // Jet Path

    TEST_MACHINE_NAME,                                                  // machine
    SERVER_4,                                                           // server name
        RSA,                                                            // replica
        FALSE,                                                          // IsPrimary
        NULL, NULL,                                                     // File/Dir Filter
        { CXT_4_FM_1,        CXT_4_FM_2,   CXT_4_FM_3,       NULL },    // inbound cxtions
        { MACHINE_1,         MACHINE_2,    MACHINE_3,        NULL },    // inbound machines
        { SERVER_1,          SERVER_2,     SERVER_3,         NULL },    // inbound servers
        { CXT_4_TO_1,        CXT_4_TO_2,   CXT_4_TO_3,       NULL },    // outbound cxtions
        { MACHINE_1,         MACHINE_2,    MACHINE_3,        NULL },    // outbound machines
        { SERVER_1,          SERVER_2,     SERVER_3,         NULL },    // outbound servers
        SERVER_4_VOL L"\\staging",                                      // stage
        SERVER_4_VOL L"\\" RSA L"\\" SERVER_4,                          // root
        SERVER_4_VOL L"\\jet\\" SERVER_4,                               // Jet Path
*/


/*
    //
    // David's 3-way
    //
    TEST_MACHINE_NAME,                                     // machine
    SERVER_1,                                              // server name
        RSA,                                               // replica
        TRUE,                                              // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { CXT_1_FM_2,        CXT_1_FM_3,        NULL },    // inbound cxtions
        { MACHINE_2,         MACHINE_3,         NULL },    // inbound machines
        { SERVER_2,          SERVER_3,          NULL },    // inbound servers
        { CXT_1_TO_2,        CXT_1_TO_3,        NULL },    // outbound cxtions
        { MACHINE_2,         MACHINE_3,         NULL },    // outbound machines
        { SERVER_2,          SERVER_3,          NULL },    // outbound servers
        SERVER_1_VOL L"\\staging",                         // stage
        SERVER_1_VOL L"\\" RSA L"\\" SERVER_1,             // root
        SERVER_1_VOL L"\\jet\\" SERVER_1,                  // Jet Path

    TEST_MACHINE_NAME,                                     // machine
    SERVER_2,                                              // server name
        RSA,                                               // replica
        FALSE,                                             // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { CXT_2_FM_1,        CXT_2_FM_3,        NULL },    // inbound cxtions
        { MACHINE_1,         MACHINE_3,         NULL },    // inbound machines
        { SERVER_1,          SERVER_3,          NULL },    // inbound servers
        { CXT_2_TO_1,        CXT_2_TO_3,        NULL },    // outbound cxtions
        { MACHINE_1,         MACHINE_3,         NULL },    // outbound machines
        { SERVER_1,          SERVER_3,          NULL },    // outbound servers
        SERVER_2_VOL L"\\staging",                         // stage
        SERVER_2_VOL L"\\" RSA L"\\" SERVER_2,             // root
        SERVER_2_VOL L"\\jet\\" SERVER_2,                  // Jet Path

    TEST_MACHINE_NAME,                                     // machine
    SERVER_3,                                              // server name
        RSA,                                               // replica
        FALSE,                                             // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { CXT_3_FM_1,        CXT_3_FM_2,        NULL },    // inbound cxtions
        { MACHINE_1,         MACHINE_2,         NULL },    // inbound machines
        { SERVER_1,          SERVER_2,          NULL },    // inbound servers
        { CXT_3_TO_1,        CXT_3_TO_2,        NULL },    // outbound cxtions
        { MACHINE_1,         MACHINE_2,         NULL },    // outbound machines
        { SERVER_1,          SERVER_2,          NULL },    // outbound servers
        SERVER_3_VOL L"\\staging",                         // stage
        SERVER_3_VOL L"\\" RSA L"\\" SERVER_3,             // root
        SERVER_3_VOL L"\\jet\\" SERVER_3,                  // Jet Path
*/


/*
    //
    // David's 1-way
    //

    TEST_MACHINE_NAME,                                     // machine
    SERVER_1,                                              // server name
        RSA,                                               // replica
        TRUE,                                              // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { NULL,              NULL },                       // inbound cxtions
        { NULL,              NULL },                       // inbound machines
        { NULL,              NULL },                       // inbound servers
        { CXT_1_TO_2,        NULL },                       // outbound cxtions
        { MACHINE_2,         NULL },                       // outbound machines
        { SERVER_2,          NULL },                       // outbound servers
        SERVER_1_VOL L"\\staging",                         // stage
        SERVER_1_VOL L"\\" RSA L"\\" SERVER_1,             // root
        SERVER_1_VOL L"\\jet\\" SERVER_1,                  // Jet Path

    TEST_MACHINE_NAME,                                     // machine
    SERVER_2,                                              // server name
        RSA,                                               // replica
        FALSE,                                             // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { CXT_2_FM_1,        NULL },                       // inbound cxtions
        { MACHINE_1,         NULL },                       // inbound machines
        { SERVER_1,          NULL },                       // inbound servers
        { NULL,              NULL },                       // outbound cxtions
        { NULL,              NULL },                       // outbound machines
        { NULL,              NULL },                       // outbound servers
        SERVER_2_VOL L"\\staging",                         // stage
        SERVER_2_VOL L"\\" RSA L"\\" SERVER_2,             // root
        SERVER_2_VOL L"\\jet\\" SERVER_2,                  // Jet Path
*/



/*
    //
    // David's 2-way
    //

    TEST_MACHINE_NAME,                                     // machine
    SERVER_1,                                              // server name
        RSA,                                               // replica
        TRUE,                                              // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { CXT_1_FM_2,        NULL },                       // inbound cxtions
        { MACHINE_2,         NULL },                       // inbound machines
        { SERVER_2,          NULL },                       // inbound servers
        { CXT_1_TO_2,        NULL },                       // outbound cxtions
        { MACHINE_2,         NULL },                       // outbound machines
        { SERVER_2,          NULL },                       // outbound servers
        SERVER_1_VOL L"\\staging",                         // stage
        SERVER_1_VOL L"\\" RSA L"\\" SERVER_1,             // root
        SERVER_1_VOL L"\\jet\\" SERVER_1,                  // Jet Path

    TEST_MACHINE_NAME,                                     // machine
    SERVER_2,                                              // server name
        RSA,                                               // replica
        FALSE,                                             // IsPrimary
        NULL, NULL,                                        // File/Dir Filter
        { CXT_2_FM_1,        NULL },                       // inbound cxtions
        { MACHINE_1,         NULL },                       // inbound machines
        { SERVER_1,          NULL },                       // inbound servers
        { CXT_2_TO_1,        NULL },                       // outbound cxtions
        { MACHINE_1,         NULL },                       // outbound machines
        { SERVER_1,          NULL },                       // outbound servers
        SERVER_2_VOL L"\\staging",                         // stage
        SERVER_2_VOL L"\\" RSA L"\\" SERVER_2,             // root
        SERVER_2_VOL L"\\jet\\" SERVER_2,                  // Jet Path

*/
    //
    // End of Config
    //
    NULL, NULL
};




HARDWIRED DavidWired2[] = {



///*
 //
 // 8 way ring Without Server2
 //

 TEST_MACHINE_NAME, // machine
 SERVER_1,  // server name
 RSA,   // replica
 TRUE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT2_1", L"CXT8_1",  NULL    },  // inbound cxtions
{MACHINE_2, MACHINE_8,  NULL    },  // inbound machines
{SERVER_2,  SERVER_8,   NULL    },  // inbound servers
{L"CXT1_2", L"CXT1_8",  NULL    },  // outbound cxtions
{MACHINE_2, MACHINE_8,  NULL    },  // outbound machines
{SERVER_2,  SERVER_8,   NULL    },  // outbound servers
 SERVER_1_VOL   L"\\staging",   // stage
 SERVER_1_VOL   L"\\" RSA L"\\" SERVER_1,   // root
 SERVER_1_VOL   L"\\jet\\" SERVER_1,    // Jet Path

#if 0
 TEST_MACHINE_NAME, // machine
 SERVER_2,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT3_2", L"CXT1_2",  NULL    },  // inbound cxtions
{MACHINE_3, MACHINE_1,  NULL    },  // inbound machines
{SERVER_3,  SERVER_1,   NULL    },  // inbound servers
{L"CXT2_3", L"CXT2_1",  NULL    },  // outbound cxtions
{MACHINE_3, MACHINE_1,  NULL    },  // outbound machines
{SERVER_3,  SERVER_1,   NULL    },  // outbound servers
 SERVER_2_VOL   L"\\staging",   // stage
 SERVER_2_VOL   L"\\" RSA L"\\" SERVER_2,   // root
 SERVER_2_VOL   L"\\jet\\" SERVER_2,    // Jet Path
#endif

 TEST_MACHINE_NAME, // machine
 SERVER_3,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT4_3", L"CXT2_3",  NULL    },  // inbound cxtions
{MACHINE_4, MACHINE_2,  NULL    },  // inbound machines
{SERVER_4,  SERVER_2,   NULL    },  // inbound servers
{L"CXT3_4", L"CXT3_2",  NULL    },  // outbound cxtions
{MACHINE_4, MACHINE_2,  NULL    },  // outbound machines
{SERVER_4,  SERVER_2,   NULL    },  // outbound servers
 SERVER_3_VOL   L"\\staging",   // stage
 SERVER_3_VOL   L"\\" RSA L"\\" SERVER_3,   // root
 SERVER_3_VOL   L"\\jet\\" SERVER_3,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_4,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT5_4", L"CXT3_4",  NULL    },  // inbound cxtions
{MACHINE_5, MACHINE_3,  NULL    },  // inbound machines
{SERVER_5,  SERVER_3,   NULL    },  // inbound servers
{L"CXT4_5", L"CXT4_3",  NULL    },  // outbound cxtions
{MACHINE_5, MACHINE_3,  NULL    },  // outbound machines
{SERVER_5,  SERVER_3,   NULL    },  // outbound servers
 SERVER_4_VOL   L"\\staging",   // stage
 SERVER_4_VOL   L"\\" RSA L"\\" SERVER_4,   // root
 SERVER_4_VOL   L"\\jet\\" SERVER_4,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_5,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT6_5", L"CXT4_5",  NULL    },  // inbound cxtions
{MACHINE_6, MACHINE_4,  NULL    },  // inbound machines
{SERVER_6,  SERVER_4,   NULL    },  // inbound servers
{L"CXT5_6", L"CXT5_4",  NULL    },  // outbound cxtions
{MACHINE_6, MACHINE_4,  NULL    },  // outbound machines
{SERVER_6,  SERVER_4,   NULL    },  // outbound servers
 SERVER_5_VOL   L"\\staging",   // stage
 SERVER_5_VOL   L"\\" RSA L"\\" SERVER_5,   // root
 SERVER_5_VOL   L"\\jet\\" SERVER_5,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_6,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT7_6", L"CXT5_6",  NULL    },  // inbound cxtions
{MACHINE_7, MACHINE_5,  NULL    },  // inbound machines
{SERVER_7,  SERVER_5,   NULL    },  // inbound servers
{L"CXT6_7", L"CXT6_5",  NULL    },  // outbound cxtions
{MACHINE_7, MACHINE_5,  NULL    },  // outbound machines
{SERVER_7,  SERVER_5,   NULL    },  // outbound servers
 SERVER_6_VOL   L"\\staging",   // stage
 SERVER_6_VOL   L"\\" RSA L"\\" SERVER_6,   // root
 SERVER_6_VOL   L"\\jet\\" SERVER_6,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_7,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT8_7", L"CXT6_7",  NULL    },  // inbound cxtions
{MACHINE_8, MACHINE_6,  NULL    },  // inbound machines
{SERVER_8,  SERVER_6,   NULL    },  // inbound servers
{L"CXT7_8", L"CXT7_6",  NULL    },  // outbound cxtions
{MACHINE_8, MACHINE_6,  NULL    },  // outbound machines
{SERVER_8,  SERVER_6,   NULL    },  // outbound servers
 SERVER_7_VOL   L"\\staging",   // stage
 SERVER_7_VOL   L"\\" RSA L"\\" SERVER_7,   // root
 SERVER_7_VOL   L"\\jet\\" SERVER_7,    // Jet Path

 TEST_MACHINE_NAME, // machine
 SERVER_8,  // server name
 RSA,   // replica
 FALSE, // IsPrimary
 NULL, NULL, // File/Dir Filter
{L"CXT1_8", L"CXT7_8",  NULL    },  // inbound cxtions
{MACHINE_1, MACHINE_7,  NULL    },  // inbound machines
{SERVER_1,  SERVER_7,   NULL    },  // inbound servers
{L"CXT8_1", L"CXT8_7",  NULL    },  // outbound cxtions
{MACHINE_1, MACHINE_7,  NULL    },  // outbound machines
{SERVER_1,  SERVER_7,   NULL    },  // outbound servers
 SERVER_8_VOL   L"\\staging",   // stage
 SERVER_8_VOL   L"\\" RSA L"\\" SERVER_8,   // root
 SERVER_8_VOL   L"\\jet\\" SERVER_8,    // Jet Path


    //
    // End of Config
    //
    NULL, NULL
};


#endif  DBG


#if DBG
GUID *
FrsDsBuildGuidFromName(
    IN PWCHAR OrigName
    )
/*++
Routine Description:
    Build a guid from a character string

Arguments:
    Name

Return Value:
    Guid
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsBuildGuidFromName:"
    PULONG  Guid;
    ULONG   Len;
    ULONG   *Sum;
    ULONG   *SumOfSum;
    PWCHAR  Name = OrigName;

    Guid = FrsAlloc(sizeof(GUID));

    //
    // First four bytes are the sum of the chars in Name; the
    // second four bytes are the sum of sums. The last 8 bytes
    // are 0.
    //
    Len = wcslen(Name);
    Sum = Guid;
    SumOfSum = Guid + 1;
    while (Len--) {
        *Sum += *Name++ + 1;
        *SumOfSum += *Sum;
    }
    return (GUID *)Guid;
}
#endif  DBG


#if DBG
VOID
FrsDsInitializeHardWiredStructs(
    IN PHARDWIRED   Wired
    )
/*++
Routine Description:
    Initialize the hardwired config stuff. Must happen before any
    of the command servers start.

Arguments:
    Wired   - struct to initialize

Return Value:
    None
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsInitializeHardWiredStructs:"
    ULONG       i;
    ULONG       j;

    //
    // NULL entries for "machine name" fields are assigned
    // this machine's name
    //
    for (i = 0; Wired[i].Replica; ++i) {
        if (ServerName && WSTR_EQ(ServerName, Wired[i].Server)) {
            //
            // Adjust the default jet parameters. Also, reset the
            // ServerName to match the server name in the hard
            // wired config so that the phoney guids match.
            //
            FrsFree(ServerName);
            FrsFree(JetPath);
            ServerName = FrsWcsDup(Wired[i].Server);
            JetPath = FrsWcsDup(Wired[i].JetPath);
        }
        //
        // Assign this machine's name if the machine entry is NULL
        //
        if (!Wired[i].Machine ||
            WSTR_EQ(Wired[i].Machine, THIS_COMPUTER)) {
            Wired[i].Machine = ComputerName;
        }
        for (j = 0; Wired[i].InNames[j]; ++j) {
            //
            // Assign this machine's name if the machine entry is NULL
            //
            if (WSTR_NE(Wired[i].InMachines[j], THIS_COMPUTER)) {
                continue;
            }
            Wired[i].InMachines[j] = ComputerName;
        }
        for (j = 0; Wired[i].OutNames[j]; ++j) {
            //
            // Assign this machine's name if the machine entry is NULL
            //
            if (WSTR_NE(Wired[i].OutMachines[j], THIS_COMPUTER)) {
                continue;
            }
            Wired[i].OutMachines[j] = ComputerName;
        }
    }
}


BOOL
FrsDsLoadHardWiredFromFile(
    PHARDWIRED   *pMemberList,
    PWCHAR       pIniFileName
    )
/*++
Routine Description:

   Fills the hardwired structure array from data in a file.  The file format
   has the form of:

                [MEMBER0]
                MACHINE=[This Computer]
                SERVER=SERV01
                REPLICA=Replica-A
                ISPRIMARY=TRUE
                FILEFILTERLIST=*.tmp;*.bak
                DIRFILTERLIST=obj
                INNAME=CXT2_1, CXT3_1
                INMACHINE=[This Computer], [This Computer]
                INSERVER=SERV02, SERV03
                OUTNAME=CXT1_2, CXT1_3
                OUTMACHINE=[This Computer], [This Computer]
                OUTSERVER=SERV02, SERV03
                STAGE=d:\staging
                ROOT=d:\Replica-A\SERV01
                JETPATH=d:\jet

                [MEMBER1]
                MACHINE=[This Computer]
                SERVER=SERV02
                REPLICA=Replica-A
                ISPRIMARY=FALSE
                FILEFILTERLIST=*.tmp;*.bak
                DIRFILTERLIST=obj
                INNAME=CXT1_2, CXT3_2
                INMACHINE=[This Computer], [This Computer]
                INSERVER=SERV01, SERV03
                OUTNAME=CXT2_1, CXT2_3
                OUTMACHINE=[This Computer], [This Computer]
                OUTSERVER=SERV01, SERV03
                STAGE=e:\staging
                ROOT=e:\Replica-A\SERV02
                JETPATH=e:\jet

                [MEMBER2]
                MACHINE=[This Computer]
                SERVER=SERV03
                REPLICA=Replica-A
                ISPRIMARY=FALSE
                FILEFILTERLIST=*.tmp;*.bak
                DIRFILTERLIST=obj
                INNAME=CXT1_3, CXT2_3
                INMACHINE=[This Computer], [This Computer]
                INSERVER=SERV01, SERV02
                OUTNAME=CXT3_1, CXT3_2
                OUTMACHINE=[This Computer], [This Computer]
                OUTSERVER=SERV01, SERV02
                STAGE=f:\staging
                ROOT=f:\Replica-A\SERV03
                JETPATH=f:\jet

The string "[This Computer]" has a special meaning in that it refers to the
computer on which the server is running.  You can substitute a specific
computer name.

The entries for INNAME, INMACHINE and INSERVER are lists in which the
corresponding entries in each list form a related triple that speicfy
the given inbound connection.

Ditto for OUTNAME, OUTMACHINE, and OUTSERVER.

The configuration above is for a fully connected mesh with three members.
It works only when three copies of NTFRS are run on the same machine since
all the IN and OUTMACHINE entries specify "[This Computer]".  The SERVER names
distinguish each of the three copies of NTFRS for the purpose of providing RPC
endpoints.

If the members were actually run on separate physical machines then the
INMACHINES and the OUTMACHINES would need to specify the particular machine
names.



Arguments:
    MemberList     - Pointer to the pointer to the array of HardWired structures..
    IniFileName    - Name of the ini file to load from.

Return Value:
    TRUE if data read ok.

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsLoadHardWiredFromFile:"

    ULONG           TotalMembers;
    ULONG           WStatus, Flag;
    ULONG           Len, RecordLen;
    PWCHAR          szIndex;
    UINT            i, k;
    PHARDWIRED      HwMember;
    UNICODE_STRING  UStr, ListArg;
    PWCHAR          pequal;
    PWCHAR          *ListArray;
    WCHAR           SectionNumber[16];
    WCHAR           SectionName[32];
    WCHAR           SectionBuffer[5000];

    //
    //Check if the ini file exists.
    //

    if (GetFileAttributes(pIniFileName) == 0xffffffff) {
        DPRINT1(0, ":DS: Could not find ini file... %ws\n", IniFileName);
        return FALSE;
    }

    //
    // Find the number of members in the replica set.
    //
    TotalMembers = 0;
    while(TRUE) {
        wcscpy(SectionName, L"MEMBER");
        wcscpy(SectionNumber, _itow(TotalMembers, SectionNumber, 10));
        wcscat(SectionName, SectionNumber);

        //
        //Read this section from the ini file.
        //
        Flag = GetPrivateProfileSection(SectionName,
                                        SectionBuffer,
                                        sizeof(SectionBuffer)/sizeof(WCHAR),
                                        pIniFileName);
        if (Flag == 0) {
            WStatus = GetLastError();
            break;
        }
        TotalMembers++;
    }

    if (TotalMembers == 0) {
        DPRINT_WS(0, ":DS: No members found in inifile.", WStatus);
        return FALSE;
    }

    //
    //  Allocate memory.  Then loop thru each member def in the ini file.
    //
    *pMemberList = (PHARDWIRED) FrsAlloc((TotalMembers + 1) * sizeof(HARDWIRED));

    for ( i = 0 ; i < TotalMembers; ++i) {

        wcscpy(SectionName, L"MEMBER");
        wcscpy(SectionNumber, _itow(i, SectionNumber, 10));
        wcscat(SectionName, SectionNumber);

        WStatus = GetPrivateProfileSection(SectionName,
                                           SectionBuffer,
                                           sizeof(SectionBuffer)/sizeof(WCHAR),
                                           pIniFileName);
        HwMember = &(*pMemberList)[i];

        for (szIndex = SectionBuffer; *szIndex != L'\0'; szIndex += RecordLen+1) {

            RecordLen = wcslen(szIndex);

            DPRINT3(5, ":DS:  member %d: %ws [%d]\n", i, szIndex, RecordLen);

            //
            // Look for an arg of the form foo=bar.
            //
            pequal = wcschr(szIndex, L'=');

            if (pequal == NULL) {
                DPRINT1(0, ":DS: ERROR - Malformed parameter: %ws\n", szIndex);
                continue;
            }

            //
            // Null terminate and uppercase lefthand side.
            //
            *pequal = UNICODE_NULL;
            _wcsupr(szIndex);

            ++pequal;
            Len = wcslen(pequal);
            if (Len == 0) {
                DPRINT1(0, ":DS: ERROR - Malformed parameter: %ws\n", szIndex);
                continue;
            }

            Len = (Len + 1) * sizeof(WCHAR);
            FrsSetUnicodeStringFromRawString(&UStr,
                                             Len,
                                             FrsWcsDup(pequal),
                                             Len - sizeof(WCHAR));

            if(!wcsncmp(szIndex, L"MACHINE",7)){
                HwMember->Machine = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"SERVER",6)){
                HwMember->Server = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"REPLICA",7)){
                HwMember->Replica = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"ISPRIMARY",9)){
                if (!wcscmp(UStr.Buffer, L"TRUE")) {
                    HwMember->IsPrimary = TRUE;
                }
                continue;
            }

            if(!wcsncmp(szIndex, L"FILEFILTERLIST",14)){
                HwMember->FileFilterList = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"DIRFILTERLIST",13)){
                HwMember->DirFilterList = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"STAGE",5)){
                HwMember->Stage = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"ROOT",4)){
                HwMember->Root = UStr.Buffer;
                continue;
            }

            if(!wcsncmp(szIndex, L"JETPATH",7)) {
                HwMember->JetPath = UStr.Buffer;
                continue;
            }

            if (!wcsncmp(szIndex, L"INNAME", 6)) {
                ListArray = HwMember->InNames;
                goto PARSE_COMMA_LIST;
            }

            if (!wcsncmp(szIndex, L"INMACHINE", 9)) {
                ListArray = HwMember->InMachines;
                goto PARSE_COMMA_LIST;
            }

            if (!wcsncmp(szIndex, L"INSERVER", 8)) {
                ListArray = HwMember->InServers;
                goto PARSE_COMMA_LIST;
            }

            if (!wcsncmp(szIndex, L"OUTNAME", 7)) {
                ListArray = HwMember->OutNames;
                goto PARSE_COMMA_LIST;
            }

            if (!wcsncmp(szIndex, L"OUTMACHINE", 10)) {
                ListArray = HwMember->OutMachines;
                goto PARSE_COMMA_LIST;
            }

            if (!wcsncmp(szIndex, L"OUTSERVER", 9)) {
                ListArray = HwMember->OutServers;
                goto PARSE_COMMA_LIST;
            }

PARSE_COMMA_LIST:

            //
            // Parse the right hand side of args like
            // INSERVER=machine1, machine2, machine3
            // Code above determined what the left hand side was.
            //
            k = 0;
            while (FrsDissectCommaList(UStr, &ListArg, &UStr) &&
                   (k < HW_MACHINES)) {

                ListArray[k] = NULL;

                if (ListArg.Length > 0) {
                    DPRINT2(5, ":DS: ListArg string: %ws {%d)\n",
                        (ListArg.Buffer != NULL) ? ListArg.Buffer : L"<NULL>",
                        ListArg.Length);

                    ListArray[k] = ListArg.Buffer;

                    // Replace the comma (or white space with a null)
                    ListArg.Buffer[ListArg.Length/sizeof(WCHAR)] = UNICODE_NULL;
                }

                k += 1;
            }
        }
    }

    return TRUE;
}


VOID
FrsDsInitializeHardWired(
    VOID
    )
/*++
Routine Description:
    Initialize the hardwired config stuff. Must happen before any
    of the command servers start.

Arguments:
    Jet - change the default jet directory from the registry

Return Value:
    New jet directory
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsInitializeHardWired:"

    //
    // Using Ds, not the hard wired config
    //
    if (!NoDs) {
        return;
    }


    //
    // NULL entries for "machine name" fields are assigned
    // this machine's name
    //
    if (IniFileName){
        DPRINT1(0, ":DS: Reading hardwired config from ini file... %ws\n", IniFileName);
        if (FrsDsLoadHardWiredFromFile(&LoadedWired, IniFileName)) {
            DPRINT1(0, ":DS: Using hardwired config from ini file... %ws\n", IniFileName);
            FrsDsInitializeHardWiredStructs(LoadedWired);
        } else {
            FrsFree(IniFileName);
            IniFileName = NULL;
            DPRINT(0, ":DS: Could not load topology from ini file\n");
            DPRINT(0, ":DS: Using David's hardwired...\n");
            FrsDsInitializeHardWiredStructs(DavidWired2);
            FrsDsInitializeHardWiredStructs(DavidWired);
        }
    } else {
        DPRINT(0, ":DS: Using David's hardwired...\n");
        FrsDsInitializeHardWiredStructs(DavidWired2);
        FrsDsInitializeHardWiredStructs(DavidWired);
    }

    //
    // The ServerGuid is used as part of the rpc endpoint
    //
    if (ServerName) {
        ServerGuid = FrsDsBuildGuidFromName(ServerName);
    }
}
#endif DBG


#if DBG
VOID
FrsDsUseHardWired(
    IN PHARDWIRED Wired
    )
/*++
Routine Description:
    Use the hardwired config instead of the DS config.

Arguments:
    Wired   - hand crafted config

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsUseHardWired:"
    ULONG       i, j;
    ULONG       WStatus;
    PREPLICA    Replica;
    PCXTION     Cxtion;
    PSCHEDULE   Schedule;
    ULONG       ScheduleLength;
    PBYTE       ScheduleData;
    PHARDWIRED  W;
    DWORD       FileAttributes = 0xFFFFFFFF;

    DPRINT(1, ":DS: ------------ USING HARD WIRED CONFIG\n");
    for (i = 0; Wired && Wired[i].Replica; ++i) {
        if (i) {
            DPRINT(1, ":DS: \n");
        }
        W = &Wired[i];

        DPRINT1(1, ":DS: \tServer: %ws\n", W->Server);
        DPRINT1(1, ":DS: \t   Machine: %ws\n", W->Machine);
        DPRINT1(1, ":DS: \t\tReplica    : %ws\n", W->Replica);

        DPRINT(1, ":DS: \n");
        for (j=0; (j<HW_MACHINES) && W->InNames[j]; j++ ) {
            DPRINT4(1, ":DS: \t\tInNames,machine,server  [%d] : %ws, %ws, %ws\n", j,
                   (W->InNames[j])    ? W->InNames[j]    : L"",
                   (W->InMachines[j]) ? W->InMachines[j] : L"",
                   (W->InServers[j])  ? W->InServers[j]  : L"");
        }

        DPRINT(1, ":DS: \n");
        for (j=0; (j<HW_MACHINES) && W->OutNames[j]; j++ ) {
            DPRINT4(1, ":DS: \t\tOutNames,machine,server  [%d] : %ws, %ws, %ws\n", j,
                   (W->OutNames[j])    ? W->OutNames[j]    : L"",
                   (W->OutMachines[j]) ? W->OutMachines[j] : L"",
                   (W->OutServers[j])  ? W->OutServers[j]  : L"");
        }

        DPRINT(1, ":DS: \n");
        DPRINT1(1, ":DS: \t\tStage      : %ws\n", W->Stage);
        DPRINT1(1, ":DS: \t\tRoot       : %ws\n", W->Root);
        DPRINT1(1, ":DS: \t\tJetPath    : %ws\n", W->JetPath);
    }

    //
    // Coordinate with replica command server
    //
    RcsBeginMergeWithDs();

    //
    // Construct a replica for each hardwired configuration
    //
    for (i = 0; Wired && Wired[i].Replica; ++i) {
        W = &Wired[i];
        //
        // This server does not match this machine's name; continue
        //
        if (ServerName) {
            if (WSTR_NE(ServerName, W->Server)) {
                continue;
            }
        } else if (WSTR_NE(ComputerName, W->Machine)) {
            continue;
        }

        Replica = FrsAllocType(REPLICA_TYPE);
        Replica->Consistent = TRUE;

        //
        // MATCH
        //

        //
        // Construct a phoney schedule; always "on"
        //
        ScheduleLength = sizeof(SCHEDULE) +
                         (2 * sizeof(SCHEDULE_HEADER)) +
                         (3 * SCHEDULE_DATA_BYTES);

        Schedule = FrsAlloc(ScheduleLength);
        Schedule->NumberOfSchedules = 3;
        Schedule->Schedules[0].Type = SCHEDULE_BANDWIDTH;
        Schedule->Schedules[0].Offset = sizeof(SCHEDULE) +
                                        (2 * sizeof(SCHEDULE_HEADER)) +
                                        (0 * SCHEDULE_DATA_BYTES);
        Schedule->Schedules[1].Type = SCHEDULE_PRIORITY;
        Schedule->Schedules[1].Offset = sizeof(SCHEDULE) +
                                        (2 * sizeof(SCHEDULE_HEADER)) +
                                        (1 * SCHEDULE_DATA_BYTES);
        Schedule->Schedules[2].Type = SCHEDULE_INTERVAL;
        Schedule->Schedules[2].Offset = sizeof(SCHEDULE) +
                                        (2 * sizeof(SCHEDULE_HEADER)) +
                                        (2 * SCHEDULE_DATA_BYTES);
        ScheduleData = ((PBYTE)Schedule);
        FRS_ASSERT((ScheduleData +
                    Schedule->Schedules[2].Offset + SCHEDULE_DATA_BYTES)
                    ==
                   (((PBYTE)Schedule) + ScheduleLength));

        for (j = 0; j < (SCHEDULE_DATA_BYTES * 3); ++j) {
            *(ScheduleData + Schedule->Schedules[0].Offset + j) = 0x0f;
        }

        Schedule->Size = ScheduleLength;

        Replica->Schedule = Schedule;

        //
        // Construct the guid/names from the name
        //
        Replica->MemberName = FrsBuildGName(FrsDsBuildGuidFromName(W->Server),
                                            FrsWcsDup(W->Server));

        Replica->ReplicaName = FrsBuildGName(FrsDupGuid(Replica->MemberName->Guid),
                                             FrsWcsDup(W->Replica));

        Replica->SetName = FrsBuildGName(FrsDsBuildGuidFromName(W->Replica),
                                         FrsWcsDup(W->Replica));
        //
        // Temporary; a new guid is assigned if this is a new set
        //
        Replica->ReplicaRootGuid = FrsDupGuid(Replica->SetName->Guid);

        //
        // Fill in the rest of the fields
        //
        Replica->Root = FrsWcsDup(W->Root);
        Replica->Stage = FrsWcsDup(W->Stage);
        FRS_WCSLWR(Replica->Root);
        FRS_WCSLWR(Replica->Stage);
        Replica->Volume = FrsWcsVolume(W->Root);

        //
        // Syntax of root path is invalid?
        //
        if (!FrsDsVerifyPath(Replica->Root)) {
            DPRINT2(3, ":DS: Invalid root %ws for %ws\n",
                    Replica->Root, Replica->SetName->Name);
            EPRINT1(EVENT_FRS_ROOT_NOT_VALID, Replica->Root);
            Replica->Consistent = FALSE;
        }

        //
        // Does the volume exist and is it NTFS?
        //
        WStatus = FrsVerifyVolume(Replica->Root,
                                  Replica->SetName->Name,
                                  FILE_PERSISTENT_ACLS | FILE_SUPPORTS_OBJECT_IDS);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Root path Volume (%ws) for %ws does not exist or does not support ACLs and Object IDs;",
                       Replica->Root, Replica->SetName->Name, WStatus);
            Replica->Consistent = FALSE;
        }

        //
        // Root does not exist or is inaccessable; continue
        //
        WStatus = FrsDoesDirectoryExist(Replica->Root, &FileAttributes);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Root path (%ws) for %ws does not exist;",
                      Replica->Root, Replica->SetName->Name, WStatus);
            EPRINT1(EVENT_FRS_ROOT_NOT_VALID, Replica->Root);
            Replica->Consistent = FALSE;
        }

        //
        // Syntax of staging path is invalid; continue
        //
        if (!FrsDsVerifyPath(Replica->Stage)) {
            DPRINT2(3, ":DS: Invalid stage %ws for %ws\n",
                    Replica->Stage, Replica->SetName->Name);
            EPRINT2(EVENT_FRS_STAGE_NOT_VALID, Replica->Root, Replica->Stage);
            Replica->Consistent = FALSE;
        }

        //
        // Does the staging volume exist and does it support ACLs?
        // ACLs are required to protect against data theft/corruption
        // in the staging dir.
        //
        WStatus = FrsVerifyVolume(Replica->Stage,
                                  Replica->SetName->Name,
                                  FILE_PERSISTENT_ACLS);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Stage path Volume (%ws) for %ws does not exist or does not support ACLs;",
                       Replica->Stage, Replica->SetName->Name, WStatus);
            Replica->Consistent = FALSE;
        }

        //
        // Stage does not exist or is inaccessable; continue
        //
        WStatus = FrsDoesDirectoryExist(Replica->Stage, &FileAttributes);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(3, ":DS: Stage path (%ws) for %ws does not exist;",
                       Replica->Stage, Replica->SetName->Name, WStatus);
            EPRINT2(EVENT_FRS_STAGE_NOT_VALID, Replica->Root, Replica->Stage);
            Replica->Consistent = FALSE;
        }

        if (W->IsPrimary) {
            SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
        }

        //
        // File Filter
        //
        Replica->FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                       W->FileFilterList,
                                       RegistryFileExclFilterList,
                                       DEFAULT_FILE_FILTER_LIST);
        Replica->FileInclFilterList =  FrsWcsDup(RegistryFileInclFilterList);

        //
        // Directory Filter
        //
        Replica->DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                      W->DirFilterList,
                                      RegistryDirExclFilterList,
                                      DEFAULT_DIR_FILTER_LIST);
        Replica->DirInclFilterList =  FrsWcsDup(RegistryDirInclFilterList);

        //
        // Build Inbound cxtions
        //
        Schedule = FrsAlloc(ScheduleLength);
        CopyMemory(Schedule, Replica->Schedule, ScheduleLength);
        Schedule->Schedules[0].Type = SCHEDULE_INTERVAL;
        Schedule->Schedules[2].Type = SCHEDULE_BANDWIDTH;

        for (j = 0; W->InNames[j]; ++j) {
            Cxtion = FrsAllocType(CXTION_TYPE);
            //
            // Construct the guid/names from the name
            //
            Cxtion->Name = FrsBuildGName(FrsDsBuildGuidFromName(W->InNames[j]),
                                         FrsWcsDup(W->InNames[j]));

            Cxtion->Partner = FrsBuildGName(FrsDsBuildGuidFromName(W->InServers[j]),
                                            FrsWcsDup(W->InMachines[j]));

            Cxtion->PartnerDnsName = FrsWcsDup(W->InMachines[j]);
            Cxtion->PartnerSid = FrsWcsDup(W->InMachines[j]);
            Cxtion->PartSrvName = FrsWcsDup(W->InServers[j]);
            DPRINT1(1, ":DS: Hardwired cxtion "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));

            Cxtion->PartnerPrincName = FrsWcsDup(Cxtion->PartSrvName);
            //
            // Fill in the rest of the fields
            //
            Cxtion->Inbound = TRUE;
            SetCxtionFlag(Cxtion, CXTION_FLAGS_CONSISTENT);
            Cxtion->Schedule = Schedule;
            Schedule = NULL;
            SetCxtionState(Cxtion, CxtionStateUnjoined);
            GTabInsertEntry(Replica->Cxtions, Cxtion, Cxtion->Name->Guid, NULL);
        }

        //
        // Build Outbound cxtions
        //
        Schedule = FrsAlloc(ScheduleLength);
        CopyMemory(Schedule, Replica->Schedule, ScheduleLength);
        Schedule->Schedules[0].Type = SCHEDULE_INTERVAL;
        Schedule->Schedules[2].Type = SCHEDULE_BANDWIDTH;

        for (j = 0; W->OutNames[j]; ++j) {
            Cxtion = FrsAllocType(CXTION_TYPE);
            //
            // Construct the guid/names from the name
            //
            Cxtion->Name = FrsBuildGName(FrsDsBuildGuidFromName(W->OutNames[j]),
                                         FrsWcsDup(W->OutNames[j]));

            Cxtion->Partner = FrsBuildGName(FrsDsBuildGuidFromName(W->OutServers[j]),
                                            FrsWcsDup(W->OutMachines[j]));

            Cxtion->PartnerDnsName = FrsWcsDup(W->OutMachines[j]);
            Cxtion->PartnerSid = FrsWcsDup(W->OutMachines[j]);
            Cxtion->PartSrvName = FrsWcsDup(W->OutServers[j]);
            DPRINT1(1, ":DS: Hardwired cxtion "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));

            Cxtion->PartnerPrincName = FrsWcsDup(Cxtion->PartSrvName);

            //
            // Fill in the rest of the fields
            //
            Cxtion->Inbound = FALSE;
            SetCxtionFlag(Cxtion, CXTION_FLAGS_CONSISTENT);
            Cxtion->Schedule = Schedule;
            Schedule = NULL;
            SetCxtionState(Cxtion, CxtionStateUnjoined);
            GTabInsertEntry(Replica->Cxtions, Cxtion, Cxtion->Name->Guid, NULL);
        }
        if (Schedule) {
            FrsFree(Schedule);
        }
        //
        // Merge the replica with the active replicas
        //
        RcsMergeReplicaFromDs(Replica);
    }
    RcsEndMergeWithDs();
}
#endif  DBG


DWORD
FrsDsGetSubscribers(
    IN PLDAP        Ldap,
    IN PWCHAR       SubscriptionDn,
    IN PCONFIG_NODE Parent
    )
/*++
Routine Description:
    Recursively scan the DS tree beginning at computer

    Part of NewDs poll APIs.

Arguments:
    Ldap            - opened and bound ldap connection
    SubscriptionDn  - distininguished name of subscriptions object
    Parent          - parent node

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSubscribers:"
    PWCHAR          Attrs[8];
    PLDAPMessage    LdapEntry;
    PCONFIG_NODE    Node;
    DWORD           WStatus              = ERROR_SUCCESS;
    DWORD           Status               = ERROR_SUCCESS;
    PGEN_ENTRY      ConflictingNodeEntry = NULL;
    PCONFIG_NODE    ConflictingNode      = NULL;
    PCONFIG_NODE    Winner               = NULL;
    PCONFIG_NODE    Loser                = NULL;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    HANDLE          StageHandle          = INVALID_HANDLE_VALUE;
    DWORD           FileAttributes       = 0xFFFFFFFF;
    DWORD           CreateStatus         = ERROR_SUCCESS;

    //
    // Search the DS beginning at Base for entries of (objectCategory=nTFRSSubscriber)
    //
    MK_ATTRS_7(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED,
                      ATTR_REPLICA_ROOT, ATTR_REPLICA_STAGE, ATTR_MEMBER_REF);

    if (!FrsDsLdapSearchInit(Ldap, SubscriptionDn, LDAP_SCOPE_ONELEVEL, CATEGORY_SUBSCRIBER,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(0, ":DS: No NTFRSSubscriber object found under %ws!\n", SubscriptionDn);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         LdapEntry != NULL && WIN_SUCCESS(WStatus);
         LdapEntry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, LdapEntry, CONFIG_TYPE_SUBSCRIBER);
        if (!Node) {
            DPRINT(0, ":DS: Subscriber lacks basic info; skipping\n");
            continue;
        }

        //
        // Member reference
        //
        Node->MemberDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_MEMBER_REF);
        if (Node->MemberDn == NULL) {
            DPRINT1(0, ":DS: ERROR - No Member Reference found on subscriber (%ws). Skipping\n", Node->Dn);

            //
            // Add to the poll summary event log.
            //
            FrsDsAddToPollSummary3ws(IDS_POLL_SUM_INVALID_ATTRIBUTE, ATTR_SUBSCRIBER,
                                     Node->Dn, ATTR_MEMBER_REF);

            FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->MemberDn);

        //
        // Root pathname
        //
        Node->Root = FrsDsFindValue(Ldap, LdapEntry, ATTR_REPLICA_ROOT);
        if (Node->Root == NULL) {
            DPRINT1(0, ":DS: ERROR - No Root path found on subscriber (%ws). Skipping\n", Node->Dn);
            FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->Root);


        //
        // Staging pathname. No need to traverse reparse points on the staging dir.
        //
        Node->Stage = FrsDsFindValue(Ldap, LdapEntry, ATTR_REPLICA_STAGE);
        if (Node->Stage == NULL) {
            DPRINT1(0, ":DS: ERROR - No Staging path found on subscriber (%ws). Skipping\n", Node->Dn);
            FrsFreeType(Node);
            continue;
        }

        FRS_WCSLWR(Node->Stage);

        //
        // Create the staging directory if it does not exist.
        //
        Status = FrsDoesDirectoryExist(Node->Stage, &FileAttributes);
        if (!WIN_SUCCESS(Status)) {
            CreateStatus = FrsCreateDirectory(Node->Stage);
            DPRINT1_WS(0, ":DS: ERROR - Can't create staging dir %ws;", Node->Stage, CreateStatus);
        }

        //
        // If the staging dir was just created successfully or if it does not have the
        // hidden attribute set then set the security on it.
        //
        if ((!WIN_SUCCESS(Status) && WIN_SUCCESS(CreateStatus)) ||
            (WIN_SUCCESS(Status) && !BooleanFlagOn(FileAttributes, FILE_ATTRIBUTE_HIDDEN))) {
            //
            // Open the staging directory.
            //
            StageHandle = CreateFile(Node->Stage,
                                     GENERIC_WRITE | WRITE_DAC | FILE_READ_ATTRIBUTES | FILE_TRAVERSE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_FLAG_BACKUP_SEMANTICS,
                                     NULL);

            if (!HANDLE_IS_VALID(StageHandle)) {
                Status = GetLastError();
                DPRINT1_WS(0, ":DS: WARN - CreateFile(%ws);", Node->Stage, Status);
            } else {
                Status = FrsRestrictAccessToFileOrDirectory(Node->Stage, StageHandle,
                                                            FALSE, // do not inherit acls from parent.
                                                            FALSE);// do not push acls to children.
                DPRINT1_WS(0, ":DS: WARN - FrsRestrictAccessToFileOrDirectory(%ws) (IGNORED)", Node->Stage, Status);
                FRS_CLOSE(StageHandle);

                //
                // Mark the staging dir hidden.
                //
                if (!SetFileAttributes(Node->Stage,
                                       FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_HIDDEN)) {
                    Status = GetLastError();
                    DPRINT1_WS(0, ":DS: ERROR - Can't set attrs on staging dir %ws;", Node->Stage, Status);
                }
            }
        }

        //
        // Add the subscriber to the subscriber table.
        //
//        ConflictingNodeEntry = GTabInsertUniqueEntry(SubscriberTable, Node, Node->MemberDn, Node->Root);
        ConflictingNodeEntry = GTabInsertUniqueEntry(SubscriberTable, Node, Node->MemberDn, NULL);

        if (ConflictingNodeEntry) {
            ConflictingNode = ConflictingNodeEntry->Data;
            FrsDsResolveSubscriberConflict(ConflictingNode, Node, &Winner, &Loser);
            if (WSTR_EQ(Winner->Dn, Node->Dn)) {
                //
                // The new one is the winner. Remove old one and insert new one.
                //
                GTabDelete(SubscriberTable,ConflictingNodeEntry->Key1,ConflictingNodeEntry->Key2,NULL);
                GTabInsertUniqueEntry(SubscriberTable, Node, Node->MemberDn, Node->Root);
                FrsFreeType(ConflictingNode);
            } else {
                //
                // The old one is the winner. Leave it in the table.
                //
                FrsFreeType(Node);
                continue;
            }
        }

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);
        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeSubscriber", Node);
    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    return WStatus;
}


DWORD
FrsDsGetSubscriptions(
    IN PLDAP        Ldap,
    IN PWCHAR       ComputerDn,
    IN PCONFIG_NODE Parent
    )
/*++
Routine Description:
    Recursively scan the DS tree beginning at computer

    Part of NewDs poll APIs.

Arguments:
    Ldap        - opened and bound ldap connection
    DefaultNc   - default naming context
    Parent      - parent node

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetSubscriptions:"
    PWCHAR          Attrs[6];
    PLDAPMessage    LdapMsg = NULL;
    PLDAPMessage    LdapEntry;
    PCONFIG_NODE    Node;
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           WStatus = ERROR_SUCCESS;

    //
    // Search the DS beginning at Base for entries of (objectCategory=nTFRSSubscriptions)
    //
    MK_ATTRS_5(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED, ATTR_WORKING);

    if (!FrsDsLdapSearchInit(Ldap, ComputerDn, LDAP_SCOPE_SUBTREE, CATEGORY_SUBSCRIPTIONS,
                         Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(0, ":DS: No NTFRSSubscriptions object found under %ws!.\n", ComputerDn);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         LdapEntry != NULL && WIN_SUCCESS(WStatus);
         LdapEntry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, LdapEntry, CONFIG_TYPE_SUBSCRIPTIONS);
        if (!Node) {
            DPRINT(4, ":DS: Subscriptions lacks basic info; skipping\n");
            continue;
        }

        //
        // Working Directory
        //
        Node->Working = FrsDsFindValue(Ldap, LdapEntry, ATTR_WORKING);

        //
        // Link into config and add to the running checksum
        //
        FrsDsTreeLink(Parent, Node);
        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeSubscription", Node);

        //
        // Recurse to the next level in the DS hierarchy
        //
        WStatus = FrsDsGetSubscribers(Ldap, Node->Dn, Node);
    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    return WStatus;
}


VOID
FrsDsAddLdapMod(
    IN PWCHAR AttrType,
    IN PWCHAR AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add_s() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FrsDsFreeLdapMod().

Arguments:
    AttrType    - The object class of the object.
    AttrValue   - The value of the attribute.
    pppMod      - Address of an array of pointers to "attributes". Don't
                  give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FrsDsFreeLdapMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)FrsAlloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)FrsRealloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR *)FrsAlloc(sizeof (PWCHAR) * 2);
    Values[0] = FrsWcsDup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)FrsAlloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = FrsWcsDup(AttrType);
    Attr->mod_op = LDAP_MOD_ADD;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}


VOID
FrsDsAddLdapBerMod(
    IN PWCHAR AttrType,
    IN PCHAR AttrValue,
    IN DWORD AttrValueLen,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FrsDsFreeLdapMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    AttrValueLen    - length of the attribute
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FrsDsFreeLdapMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PLDAP_BERVAL    Berval;
    PLDAP_BERVAL    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)FrsAlloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)FrsRealloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PLDAP_BERVAL)FrsAlloc(sizeof(LDAP_BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)FrsAlloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PLDAP_BERVAL *)FrsAlloc(sizeof (PLDAP_BERVAL) * 2);
    Values[0] = Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)FrsAlloc(sizeof (*Attr));
    Attr->mod_bvalues = Values;
    Attr->mod_type = FrsWcsDup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}


VOID
FrsDsFreeLdapMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to FrsDsAddLdapMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    //
    // For each attibute
    //
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            //
            // Free the value
            //
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                FrsFree(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            FrsFree((ppMod[i])->mod_values[j]);
        }
        FrsFree((ppMod[i])->mod_values);   // Free the array of pointers to values
        FrsFree((ppMod[i])->mod_type);     // Free the string identifying the attribute
        FrsFree(ppMod[i]);                 // Free the attribute
    }
    FrsFree(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to FrsDsAddLdapMod()
}


PWCHAR
FrsDsConvertToSettingsDn(
    IN PWCHAR   Dn
    )
/*++
Routine Description:
    Insure this Dn is for the server's settings and not the server and
    that the Dn is in lower case for any call to wcsstr().

Arguments:
    Dn  - Server or settings dn

Return Value:
    Settings Dn
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsConvertToSettingsDn:"
    PWCHAR  SettingsDn;

    DPRINT1(4, ":DS: Begin settings Dn: %ws\n", Dn);

    //
    // No settings; done
    //
    if (!Dn) {
        return Dn;
    }

    //
    // Lower case for wcsstr
    //
    FRS_WCSLWR(Dn);
    if (wcsstr(Dn, CN_NTDS_SETTINGS)) {
        DPRINT1(4, ":DS: End   settings Dn: %ws\n", Dn);
        return Dn;
    }
    SettingsDn = FrsDsExtendDn(Dn, CN_NTDS_SETTINGS);
    FRS_WCSLWR(SettingsDn);
    FrsFree(Dn);
    DPRINT1(4, ":DS: End   settings Dn: %ws\n", SettingsDn);
    return SettingsDn;
}


DWORD
FrsDsFindComputer(
    IN  PLDAP        Ldap,
    IN  PWCHAR       FindDn,
    IN  PWCHAR       ObjectCategory,
    IN  ULONG        Scope,
    OUT PCONFIG_NODE *Computer
    )
/*++
Routine Description:

    Find *one* computer object for this computer.
    Then look for a subscriptons object and subscriber objects.  A
    DS configuration node is allocated for each object found.  They are linked
    together and the root of the "computer tree" is returned in Computer.

    Part of NewDs poll APIs.

Arguments:
    Ldap           - opened and bound ldap connection
    FindDn         - Base Dn for search
    ObjectCategory - Object class (computer or user)
                     A user object serves the same purpose as the computer
                     object *sometimes* following a NT4 to NT5 upgrade.
    Scope          - Scope of search (currently BASE or SUBTREE)
    Computer       - returned computer subtree

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsFindComputer:"
    PLDAPMessage    LdapEntry;
    PCONFIG_NODE    Node;
    PWCHAR          Attrs[8];
    WCHAR           Filter[MAX_PATH + 1];
    FRS_LDAP_SEARCH_CONTEXT FrsSearchContext;
    DWORD           WStatus = ERROR_SUCCESS;


    *Computer = NULL;

    //
    // Initialize the SubscriberTable.
    //
    if (SubscriberTable != NULL) {
        SubscriberTable = GTabFreeTable(SubscriberTable,NULL);
    }

    SubscriberTable = GTabAllocStringTable();

    //
    // Filter that locates our computer object
    //
    swprintf(Filter, L"(&%s(sAMAccountName=%s$))", ObjectCategory, ComputerName);

    //
    // Search the DS beginning at Base for the entries of class "Filter"
    //
    MK_ATTRS_7(Attrs, ATTR_OBJECT_GUID, ATTR_DN, ATTR_SCHEDULE, ATTR_USN_CHANGED,
                      ATTR_SERVER_REF, ATTR_SERVER_REF_BL, ATTR_DNS_HOST_NAME);
    //
    // Note: Is it safe to turn off referrals re: back links?
    //       if so, use ldap_get/set_option in winldap.h
    //

    if (!FrsDsLdapSearchInit(Ldap, FindDn, Scope, Filter, Attrs, 0, &FrsSearchContext)) {
        return ERROR_ACCESS_DENIED;
    }
    if (FrsSearchContext.EntriesInPage == 0) {
        DPRINT1(0, ":DS: WARN - There is no computer object in %ws!\n", FindDn);
    }

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext);
         LdapEntry != NULL && WIN_SUCCESS(WStatus);
         LdapEntry = FrsDsLdapSearchNext(Ldap, &FrsSearchContext)) {

        //
        // Basic node info (guid, name, dn, schedule, and usnchanged)
        //
        Node = FrsDsAllocBasicNode(Ldap, LdapEntry, CONFIG_TYPE_COMPUTER);
        if (!Node) {
            DPRINT(0, ":DS: Computer lacks basic info; skipping\n");
            continue;
        }
        DPRINT1(2, ":DS: Computer FQDN is %ws\n", Node->Dn);

        //
        // DNS name
        //
        Node->DnsName = FrsDsFindValue(Ldap, LdapEntry, ATTR_DNS_HOST_NAME);
        DPRINT1(2, ":DS: Computer's dns name is %ws\n", Node->DnsName);

        //
        // Server reference
        //
        Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF_BL);
        if (!Node->SettingsDn) {
            Node->SettingsDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_SERVER_REF);
        }
        //
        // Make sure it references the settings; not the server
        //
        Node->SettingsDn = FrsDsConvertToSettingsDn(Node->SettingsDn);

        DPRINT1(2, ":DS: Settings reference is %ws\n", Node->SettingsDn);

        //
        // Link into config
        //
        Node->Peer = *Computer;
        *Computer = Node;
        FRS_PRINT_TYPE_DEBSUB(5, ":DS: NodeComputer", Node);

        //
        // Recurse to the next level in the DS hierarchy iff this
        // computer is a member of some replica set
        //
        WStatus = FrsDsGetSubscriptions(Ldap, Node->Dn, Node);
    }
    FrsDsLdapSearchClose(&FrsSearchContext);

    //
    // There should only be one computer object with the indicated
    // SAM account name. Otherwise, we are unable to authenticate
    // properly. And it goes against the DS architecture.
    //
    if (WIN_SUCCESS(WStatus) && *Computer && (*Computer)->Peer) {
        DPRINT(0, ":DS: ERROR - There is more than one computer object!\n");
        WStatus = ERROR_INVALID_PARAMETER;
    }
    //
    // Must have a computer
    //
    if (WIN_SUCCESS(WStatus) && !*Computer) {
        DPRINT1(0, ":DS: WARN - There is no computer object in %ws!\n", FindDn);
        WStatus = ERROR_INVALID_PARAMETER;
    }

    return WStatus;
}


DWORD
FrsDsGetComputer(
    IN  PLDAP        Ldap,
    OUT PCONFIG_NODE *Computer
    )
/*++
Routine Description:


    Look in the Domain naming Context for our computer object.
    Historically we did a deep search for an object with the sam account
    name of our computer (SAM Account name is the netbios name with a $ appended).
    That was expensive so before doing that we first look in the Domain
    Controller container followed by a search of the Computer Container.
    Then the DS guys came up with an API for the preferred way of doing this.
    First call GetComputerObjectName() to get the Fully Qualified Distinguished
    Name (FQDN) for the computer then use that in an LDAP search query (via
    FrsDsFindComputer()).  We only fall back on the full search when the
    call to GetComputerObjectName() fails.

    Part of NewDs poll APIs.

Arguments:
    Ldap        - opened and bound ldap connection
    Computer    - returned computer subtree

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetComputer:"

    WCHAR           CompFqdn[MAX_PATH + 1];
    DWORD           CompFqdnLen;
    DWORD           WStatus = ERROR_SUCCESS;


    //
    // Initialize return value
    //
    *Computer = NULL;

    //
    // Assume success
    //
    WStatus = ERROR_SUCCESS;

    //
    // Use computer's cached fully qualified Dn.  This avoids repeated calls
    // to GetComputerObjectName() which wants to rebind to the DS on each call.
    // (it should have taken a binding handle as an arg).
    //
    if (ComputerCachedFqdn) {
        DPRINT1(5, ":DS: ComputerCachedFqdn is %ws\n", ComputerCachedFqdn);

        WStatus = FrsDsFindComputer(Ldap, ComputerCachedFqdn, CATEGORY_ANY,
                                    LDAP_SCOPE_BASE, Computer);
        if (*Computer) {
            goto CLEANUP;
        }
        DPRINT2(1, ":DS: WARN - Could not find computer in Cachedfqdn %ws; WStatus %s\n",
                ComputerCachedFqdn, ErrLabelW32(WStatus));
        ComputerCachedFqdn = FrsFree(ComputerCachedFqdn);
    }

    //
    // Retrieve the computer's fully qualified Dn
    //
    // NTRAID#70731-2000/03/29-sudarc (Call GetComputerObjectName() from a
    //                                 separate thread so that it does not hang the
    //                                 DS polling thread.)
    //
    // *Note*:
    // The following call to GetComputerObjectName() can hang if the DS
    // hangs.  See bug 351139 for an example caused by a bug in another
    // component.  One way to protect ourself is to issue this call
    // in its own thread.  Then after a timeout period call RpcCancelThread()
    // on the thread.
    //

    CompFqdnLen = MAX_PATH;
    if (GetComputerObjectName(NameFullyQualifiedDN, CompFqdn, &CompFqdnLen)) {

        DPRINT1(4, ":DS: ComputerFqdn is %ws\n", CompFqdn);
        //
        // Use CATEGORY_ANY in the search below because an NT4 to NT5 upgrade
        // could result in the object type for the "computer object" to really
        // be a USER object.  So the FQDN above could resolve to a Computer
        // or a User object.
        //
        WStatus = FrsDsFindComputer(Ldap, CompFqdn, CATEGORY_ANY,
                                    LDAP_SCOPE_BASE, Computer);
        if (*Computer == NULL) {
            DPRINT2(1, ":DS: WARN - Could not find computer in fqdn %ws; WStatus %s\n",
                    CompFqdn, ErrLabelW32(WStatus));
        } else {
            //
            // Found our computer object; refresh the cached fqdn.
            //
            FrsFree(ComputerCachedFqdn);
            ComputerCachedFqdn = FrsWcsDup(CompFqdn);
        }

        //
        // We got the fully qualified Dn so we are done.  It should have
        // given us a computer object but even if it didn't we won't find it
        // anywhere else.
        //
        goto CLEANUP;
    }

    DPRINT3(1, ":DS: WARN - GetComputerObjectName(%ws); Len %d, WStatus %s\n",
             ComputerName, CompFqdnLen, ErrLabelW32(GetLastError()));

    //
    // FQDN lookup failed so fall back on search of well known containers.
    // First Look in domain controllers container.
    //
    if (DomainControllersDn) {
        WStatus = FrsDsFindComputer(Ldap, DomainControllersDn, CATEGORY_COMPUTER,
                                    LDAP_SCOPE_SUBTREE, Computer);
        if (*Computer != NULL) {
            goto CLEANUP;
        }
        DPRINT2(1, ":DS: WARN - Could not find computer in dc's %ws; WStatus %s\n",
                DomainControllersDn, ErrLabelW32(WStatus));
    }

    //
    // Look in computer container
    //
    if (ComputersDn) {
        WStatus = FrsDsFindComputer(Ldap, ComputersDn, CATEGORY_COMPUTER,
                                    LDAP_SCOPE_SUBTREE, Computer);
        if (*Computer != NULL) {
            goto CLEANUP;
        }
        DPRINT2(1, ":DS: WARN - Could not find computer in computers %ws; WStatus %s\n",
                ComputersDn, ErrLabelW32(WStatus));
    }

    //
    // Do a deep search of the default naming context (EXPENSIVE!)
    //
    if (DefaultNcDn) {
        WStatus = FrsDsFindComputer(Ldap, DefaultNcDn, CATEGORY_COMPUTER,
                                    LDAP_SCOPE_SUBTREE, Computer);
        if (*Computer != NULL) {
            goto CLEANUP;
        }
        DPRINT2(1, ":DS: WARN - Could not find computer in defaultnc %ws; WStatus %s\n",
                DefaultNcDn, ErrLabelW32(WStatus));
    }

    //
    // Getting desperate. Try looking for a user object because an
    // NT4 to NT5 upgrade will sometimes leave the objectCategory
    // as user on the computer object.
    //
    if (DefaultNcDn) {
        WStatus = FrsDsFindComputer(Ldap, DefaultNcDn, CATEGORY_USER,
                                    LDAP_SCOPE_SUBTREE, Computer);
        if (*Computer != NULL) {
            goto CLEANUP;
        }
        DPRINT2(1, ":DS: WARN - Could not find computer in defaultnc USER %ws; WStatus %s\n",
                DefaultNcDn, ErrLabelW32(WStatus));
    }


CLEANUP:

    return WStatus;
}


DWORD
FrsDsDeleteSubTree(
    IN PLDAP    Ldap,
    IN PWCHAR   Dn
    )
/*++
Routine Description:
    Delete a DS subtree, including Dn

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsDeleteSubTree:"
    DWORD           LStatus;
    PWCHAR          Attrs[2];
    PWCHAR          NextDn;
    PLDAPMessage    LdapMsg     = NULL;
    PLDAPMessage    LdapEntry   = NULL;

    MK_ATTRS_1(Attrs, ATTR_DN);

    LStatus = ldap_search_ext_s(Ldap,
                                Dn,
                                LDAP_SCOPE_ONELEVEL,
                                CATEGORY_ANY,
                                Attrs,
                                0,
                                NULL,
                                NULL,
                                &LdapTimeout,
                                0,
                                &LdapMsg);

    if (LStatus != LDAP_NO_SUCH_OBJECT) {
        CLEANUP1_LS(4, ":DS: Can't search %ws;", Dn, LStatus, CLEANUP);
    }
    LStatus = LDAP_SUCCESS;

    //
    // Scan the entries returned from ldap_search
    //
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && LStatus == LDAP_SUCCESS;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        NextDn = FrsDsFindValue(Ldap, LdapEntry, ATTR_DN);
        LStatus = FrsDsDeleteSubTree(Ldap, NextDn);
        FrsFree(NextDn);
    }

    if (LStatus != LDAP_SUCCESS) {
        goto CLEANUP;
    }

    LStatus = ldap_delete_s(Ldap, Dn);
    if (LStatus != LDAP_NO_SUCH_OBJECT) {
        CLEANUP1_LS(4, ":DS: Can't delete %ws;", Dn, LStatus, CLEANUP);
    }

    //
    // SUCCESS
    //
    LStatus = LDAP_SUCCESS;
CLEANUP:
    LDAP_FREE_MSG(LdapMsg);
    return LStatus;
}


BOOL
FrsDsDeleteIfEmpty(
    IN PLDAP    Ldap,
    IN PWCHAR   Dn
    )
/*++
Routine Description:
    Delete the Dn if it is an empty container

Arguments:
    Ldap
    Dn

Return Value:
    TRUE    - Not empty or empty and deleted
    FALSE   - Can't search or can't delete
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsDeleteIfEmpty:"
    DWORD           LStatus;
    PWCHAR          Attrs[2];
    PLDAPMessage    LdapMsg     = NULL;

    MK_ATTRS_1(Attrs, ATTR_DN);

    LStatus = ldap_search_ext_s(Ldap,
                                Dn,
                                LDAP_SCOPE_ONELEVEL,
                                CATEGORY_ANY,
                                Attrs,
                                0,
                                NULL,
                                NULL,
                                &LdapTimeout,
                                0,
                                &LdapMsg);

    if (LStatus == LDAP_SUCCESS) {

        //
        // If there are any entries under this Dn then we don't want to
        // delete it.
        //
        if (ldap_count_entries(Ldap, LdapMsg) > 0) {
            LDAP_FREE_MSG(LdapMsg);
            return TRUE;
        }

        LDAP_FREE_MSG(LdapMsg);
        LStatus = ldap_delete_s(Ldap, Dn);

        if (LStatus != LDAP_NO_SUCH_OBJECT) {
            CLEANUP1_LS(4, ":DS: Can't delete %ws;", Dn, LStatus, CLEANUP);
        }
    } else if (LStatus != LDAP_NO_SUCH_OBJECT) {
        DPRINT1_LS(4, ":DS: Can't search %ws;", Dn, LStatus);
        LDAP_FREE_MSG(LdapMsg);
        return FALSE;
    } else {
        //
        // ldap_search can return failure but still allocated the LdapMsg buffer.
        //
        LDAP_FREE_MSG(LdapMsg);
    }
    return TRUE;

CLEANUP:
    return FALSE;
}


BOOL
FrsDsEnumerateSysVolKeys(
    IN PLDAP        Ldap,
    IN DWORD        Command,
    IN PWCHAR       ServicesDn,
    IN PWCHAR       SystemDn,
    IN PCONFIG_NODE Computer,
    OUT BOOL        *RefetchComputer
    )
/*++
Routine Description:

    Scan the sysvol registry keys and process them according to Command.

    REGCMD_CREATE_PRIMARY_DOMAIN       - Create domain wide objects
    REGCMD_CREATE_MEMBERS              - Create members + subscribers
    REGCMD_DELETE_MEMBERS              - delete members + subscribers
    REGCMD_DELETE_KEYS                 - Done; delete all keys


Arguments:
    Ldap
    HKey
    Command
    ServicesDn
    SystemDn
    Computer
    RefetchComputer - Objects were altered in the DS, refetch DS info

Return Value:
    TRUE    - No problems
    FALSE   - Stop processing the registry keys
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsEnumerateSysVolKeys:"


    GUID    Guid;

    DWORD   WStatus;
    DWORD   LStatus;
    ULONG   Index;

    BOOL    OldNaming;
    BOOL    RetStatus;
    HKEY    HSeedingsKey            = INVALID_HANDLE_VALUE;
    HKEY    HKey                    = INVALID_HANDLE_VALUE;

    LDAPMod **LdapMod               = NULL;
    PWCHAR  SettingsDn              = NULL;
    PWCHAR  SystemSettingsDn        = NULL;
    PWCHAR  SetDn                   = NULL;
    PWCHAR  SystemSetDn             = NULL;
    PWCHAR  SubsDn                  = NULL;
    PWCHAR  SubDn                   = NULL;
    PWCHAR  SystemSubDn             = NULL;
    PWCHAR  MemberDn                = NULL;
    PWCHAR  SystemMemberDn          = NULL;
    PWCHAR  FileFilterList          = NULL;
    PWCHAR  DirFilterList           = NULL;

    PWCHAR  ReplicaSetCommand       = NULL;
    PWCHAR  ReplicaSetName          = NULL;
    PWCHAR  ReplicaSetParent        = NULL;
    PWCHAR  ReplicaSetType          = NULL;
    PWCHAR  ReplicationRootPath     = NULL;
    PWCHAR  PrintableRealRoot       = NULL;
    PWCHAR  SubstituteRealRoot      = NULL;
    PWCHAR  ReplicationStagePath    = NULL;
    PWCHAR  PrintableRealStage      = NULL;
    PWCHAR  SubstituteRealStage     = NULL;
    DWORD   ReplicaSetPrimary;

    WCHAR   RegBuf[MAX_PATH + 1];


    //
    // Open the system volume replica sets key.
    //    FRS_CONFIG_SECTION\SysVol
    //
    WStatus = CfgRegOpenKey(FKC_SYSVOL_SECTION_KEY, NULL, 0, &HKey);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(4, ":DS: WARN - Cannot open sysvol key.", WStatus);
        return FALSE;
    }

    //
    // ENUMERATE SYSVOL SUBKEYS
    //
    RetStatus = TRUE;
    Index = 0;

    while (RetStatus) {

        WStatus = RegEnumKey(HKey, Index, RegBuf, MAX_PATH + 1);

        if (WStatus == ERROR_NO_MORE_ITEMS) {
            break;
        }
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, ":DS: ERROR - enumerating sysvol keys;", WStatus);
            RetStatus = FALSE;
            break;
        }

        //
        // Delete the registry key
        //
        if (Command == REGCMD_DELETE_KEYS) {
            WStatus = RegDeleteKey(HKey, RegBuf);
            if (!WIN_SUCCESS(WStatus)) {
                DPRINT1_WS(0, ":DS: ERROR - Cannot delete registry key %ws;",
                           RegBuf, WStatus);
                RetStatus = FALSE;
                break;
            }
            continue;
        }

        //
        // Open the subkey
        //
        DPRINT1(4, ":DS: Processing SysVol Key: %ws\n", RegBuf);

        //
        // The registry will be updated with the LDAP error code
        //
        LStatus = LDAP_OTHER;

        //
        // READ THE VALUES FROM THE SUBKEY
        //
        //     SysVol\<RegBuf>\Replica Set Command
        //
        CfgRegReadString(FKC_SET_N_SYSVOL_COMMAND, RegBuf, 0, &ReplicaSetCommand);

        if (!ReplicaSetCommand) {
            DPRINT(0, ":DS: ERROR - no command; cannot process sysvol\n");
            goto CONTINUE;
        }

        //     SysVol\<Guid>\Replica Set Name
        CfgRegReadString(FKC_SET_N_SYSVOL_NAME, RegBuf, 0, &ReplicaSetName);

        if (!ReplicaSetName) {
            DPRINT(4, ":DS: WARN - no name; using subkey name\n");
            ReplicaSetName = FrsWcsDup(RegBuf);
        }

        //
        // Construct Settings, Set, Member, Subscriptions, and Subscriber names
        // (both old and new values)
        //
        SettingsDn = FrsDsExtendDn(ServicesDn, CN_SYSVOLS);
        SystemSettingsDn = FrsDsExtendDn(SystemDn, CN_NTFRS_SETTINGS);

        SetDn = FrsDsExtendDn(SettingsDn, ReplicaSetName);
        SystemSetDn = FrsDsExtendDn(SystemSettingsDn, CN_DOMAIN_SYSVOL);

        MemberDn = FrsDsExtendDn(SetDn, ComputerName);
        SystemMemberDn = FrsDsExtendDn(SystemSetDn, ComputerName);

        SubsDn = FrsDsExtendDn(Computer->Dn, CN_SUBSCRIPTIONS);
        SubDn = FrsDsExtendDn(SubsDn, ReplicaSetName);
        SystemSubDn = FrsDsExtendDn(SubsDn, CN_DOMAIN_SYSVOL);


        //
        // DELETE REPLICA SET
        //
        if (WSTR_EQ(ReplicaSetCommand, L"Delete")) {
            //
            // But only if we are processing deletes during this enumeration
            //
            // Delete what we can; ignore errors
            //
            //
            // All the deletes are done in ntfrsapi.c when we commit demotion.
            // This function is never called with Command = REGCMD_DELETE_MEMBERS
            //
            /*
            if (Command == REGCMD_DELETE_MEMBERS) {
                //
                // DELETE MEMBER
                //
                //
                // Old member name under services in enterprise wide partition
                //
                LStatus = FrsDsDeleteSubTree(Ldap, MemberDn);
                if (LStatus == LDAP_SUCCESS) {*RefetchComputer = TRUE;}
                DPRINT1_LS(4, ":DS: WARN - Can't delete sysvol %ws;", MemberDn, LStatus);

                //
                // New member name under System in domain wide partition
                //
                LStatus = FrsDsDeleteSubTree(Ldap, SystemMemberDn);
                if (LStatus == LDAP_SUCCESS) {*RefetchComputer = TRUE;}
                DPRINT1_LS(4, ":DS: WARN - Can't delete sysvol %ws;", SystemMemberDn, LStatus);

                //
                // DELETE SET
                //
                //
                // Ignore errors; no real harm leaving the set
                // and settings around.
                //
                if (!FrsDsDeleteIfEmpty(Ldap, SetDn)) {
                    DPRINT1(4, ":DS: WARN - Can't delete sysvol %ws\n", SetDn);
                }
                if (!FrsDsDeleteIfEmpty(Ldap, SystemSetDn)) {
                    DPRINT1(4, ":DS: WARN - Can't delete sysvol %ws\n", SystemSetDn);
                }
                //
                // DELETE SETTINGS (don't delete new settings, there
                // may be other settings beneath it (such as DFS settings))
                //
                if (!FrsDsDeleteIfEmpty(Ldap, SettingsDn)) {
                    DPRINT1(4, ":DS: WARN - Can't delete sysvol %ws\n", SettingsDn);
                }

                LStatus = FrsDsDeleteSubTree(Ldap, SubDn);
                if (LStatus == LDAP_SUCCESS) {*RefetchComputer = TRUE;}
                DPRINT1_LS(4, ":DS: WARN - Can't delete sysvol %ws;", SubDn, LStatus);

                LStatus = FrsDsDeleteSubTree(Ldap, SystemSubDn);
                if (LStatus == LDAP_SUCCESS) {*RefetchComputer = TRUE;}
                DPRINT1_LS(4, ":DS: WARN - Can't delete sysvol %ws;", SystemSubDn, LStatus);

                //
                // Ignore errors; no real harm leaving the subscriptions
                //
                if (!FrsDsDeleteIfEmpty(Ldap, SubsDn)) {
                    DPRINT1(4, ":DS: WARN - Can't delete sysvol %ws\n", SubsDn);
                }
            }
            */
            LStatus = LDAP_SUCCESS;
            goto CONTINUE;
        }
        //
        // UNKNOWN COMMAND
        //
        else if (WSTR_NE(ReplicaSetCommand, L"Create")) {
            DPRINT1(0, ":DS: ERROR - Don't understand sysvol command %ws; cannot process sysvol\n",
                   ReplicaSetCommand);
            goto CONTINUE;
        }


        //
        // CREATE
        //

        //
        // Not processing creates this scan
        //
        if (Command != REGCMD_CREATE_PRIMARY_DOMAIN && Command != REGCMD_CREATE_MEMBERS) {
            LStatus = LDAP_SUCCESS;
            goto CONTINUE;
        }

        //
        // Finish gathering the registry values for a Create
        //
        WStatus = CfgRegReadString(FKC_SET_N_SYSVOL_TYPE, RegBuf, 0, &ReplicaSetType);
        CLEANUP_WS(0, ":DS: ERROR - no type; cannot process sysvol.", WStatus, CONTINUE);

        WStatus = CfgRegReadDWord(FKC_SET_N_SYSVOL_PRIMARY, RegBuf, 0, &ReplicaSetPrimary);
        CLEANUP_WS(0, ":DS: ERROR - no primary; cannot process sysvol.", WStatus, CONTINUE);

        WStatus = CfgRegReadString(FKC_SET_N_SYSVOL_ROOT, RegBuf, 0, &ReplicationRootPath);
        CLEANUP_WS(0, ":DS: ERROR - no root; cannot process sysvol.", WStatus, CONTINUE);

        WStatus = CfgRegReadString(FKC_SET_N_SYSVOL_STAGE, RegBuf, 0, &ReplicationStagePath);
        CLEANUP_WS(0, ":DS: ERROR - no stage; cannot process sysvol.", WStatus, CONTINUE);

        WStatus = CfgRegReadString(FKC_SET_N_SYSVOL_PARENT, RegBuf, 0, &ReplicaSetParent);
        DPRINT_WS(0, ":DS: WARN - no parent; cannot process seeding sysvol", WStatus);

        if (Command == REGCMD_CREATE_PRIMARY_DOMAIN) {
            //
            // Not the primary domain sysvol
            //
            if (!ReplicaSetPrimary ||
                WSTR_NE(ReplicaSetType, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
                LStatus = LDAP_SUCCESS;
                goto CONTINUE;
            }

            //
            // Domain wide Settings -- may already exist
            //
            FrsDsAddLdapMod(ATTR_CLASS, ATTR_NTFRS_SETTINGS, &LdapMod);
            DPRINT1(4, ":DS: Creating Sysvol System Settings %ws\n", CN_NTFRS_SETTINGS);
            LStatus = ldap_add_s(Ldap, SystemSettingsDn, LdapMod);
            FrsDsFreeLdapMod(&LdapMod);

            if (LStatus == LDAP_SUCCESS) {
                *RefetchComputer = TRUE;
            }

            if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
                DPRINT1_LS(0, ":DS: ERROR - Can't create %ws:", SystemSettingsDn, LStatus);
                //
                // May be an error like "Access Denied". As long as we
                // can create objects under it; ignore errors. It should
                // have been pre-created by default, anyway.
                //
                // goto CONTINUE;
            }

            //
            // Domain wide Set -- may already exist
            //
            WStatus = UuidCreateNil(&Guid);
            CLEANUP_WS(0, ":DS: ERROR - no UUID Created; cannot process sysvol.", WStatus, CONTINUE);

            FrsDsAddLdapMod(ATTR_CLASS, ATTR_REPLICA_SET, &LdapMod);
            FrsDsAddLdapMod(ATTR_SET_TYPE, FRS_RSTYPE_DOMAIN_SYSVOLW, &LdapMod);

            //
            // Create the replica set object with the default file
            // and dir filter lists only if current default is non-null.
            //
            FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(NULL,
                                                         RegistryFileExclFilterList,
                                                         DEFAULT_FILE_FILTER_LIST);
            if (wcslen(FileFilterList) > 0) {
                FrsDsAddLdapMod(ATTR_FILE_FILTER, FileFilterList, &LdapMod);
            }

            DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(NULL,
                                                        RegistryDirExclFilterList,
                                                        DEFAULT_DIR_FILTER_LIST);
            if (wcslen(DirFilterList) > 0) {
                FrsDsAddLdapMod(ATTR_DIRECTORY_FILTER, DirFilterList, &LdapMod);
            }


            FrsDsAddLdapBerMod(ATTR_NEW_SET_GUID, (PCHAR)&Guid, sizeof(GUID), &LdapMod);

            FrsDsAddLdapBerMod(ATTR_NEW_VERSION_GUID, (PCHAR)&Guid, sizeof(GUID), &LdapMod);

            DPRINT1(4, ":DS: Creating Domain Set %ws\n", ReplicaSetName);

            LStatus = ldap_add_s(Ldap, SystemSetDn, LdapMod);
            FrsDsFreeLdapMod(&LdapMod);

            if (LStatus == LDAP_SUCCESS) {
                *RefetchComputer = TRUE;
            }

            if (LStatus != LDAP_ALREADY_EXISTS) {
                CLEANUP1_LS(0, ":DS: ERROR - Can't create %ws:",
                            SystemSetDn, LStatus, CONTINUE);
            }

            LStatus = LDAP_SUCCESS;
            goto CONTINUE;
        }

        if (Command != REGCMD_CREATE_MEMBERS) {
            DPRINT1(0, ":DS: ERROR - Don't understand %d; can't process sysvols\n",
                    Command);
            goto CONTINUE;
        }


        //
        // CREATE MEMBER
        //
        // Member -- may already exist
        //      Delete old member in case it was left lying around after
        //      a demotion. This can happen because the service doesn't
        //      have permissions to alter the DS after a promotion.
        //      Leaving the old objects lying around after the demotion
        //      is confusing but doesn't cause replication to behave
        //      incorrectly.
        //
        DPRINT1(4, ":DS: Creating Member %ws\n", ComputerName);
        OldNaming = FALSE;
        //
        // Delete old member
        //
        LStatus = FrsDsDeleteSubTree(Ldap, MemberDn);
        CLEANUP1_LS(0, ":DS: ERROR - Can't free member %ws:",
                    ComputerName, LStatus, CONTINUE);

        LStatus = FrsDsDeleteSubTree(Ldap, SystemMemberDn);
        CLEANUP1_LS(0, ":DS: ERROR - Can't free system member %ws:",
                    ComputerName, LStatus, CONTINUE);

        //
        // Create new member
        //
        FrsDsAddLdapMod(ATTR_CLASS, ATTR_MEMBER, &LdapMod);
        FrsDsAddLdapMod(ATTR_COMPUTER_REF, Computer->Dn, &LdapMod);
        if (Computer->SettingsDn) {
            FrsDsAddLdapMod(ATTR_SERVER_REF, Computer->SettingsDn, &LdapMod);
        }

        LStatus = ldap_add_s(Ldap, SystemMemberDn, LdapMod);
        FrsDsFreeLdapMod(&LdapMod);
        if (LStatus == LDAP_SUCCESS) {
            *RefetchComputer = TRUE;
        }

        if (LStatus != LDAP_ALREADY_EXISTS && LStatus != LDAP_SUCCESS) {
            //
            // Try old B2 naming conventions
            //
            DPRINT1_LS(4, ":DS: WARN - Can't create system member ws:",
                       ComputerName, LStatus);
            FrsDsAddLdapMod(ATTR_CLASS, ATTR_MEMBER, &LdapMod);
            FrsDsAddLdapMod(ATTR_COMPUTER_REF, Computer->Dn, &LdapMod);
            if (Computer->SettingsDn) {
                FrsDsAddLdapMod(ATTR_SERVER_REF, Computer->SettingsDn, &LdapMod);
            }

            LStatus = ldap_add_s(Ldap, MemberDn, LdapMod);
            FrsDsFreeLdapMod(&LdapMod);
            if (LStatus == LDAP_SUCCESS) {
                *RefetchComputer = TRUE;
            }

            if (LStatus != LDAP_ALREADY_EXISTS) {
                CLEANUP1_LS(0, ":DS: ERROR - Can't create old member %ws:",
                            ComputerName, LStatus, CONTINUE);
            }

            OldNaming = TRUE;
        }

        //
        // CREATE PRIMARY MEMBER REFERENCE
        //
        if (ReplicaSetPrimary) {
            FrsDsAddLdapMod(ATTR_PRIMARY_MEMBER,
                           (OldNaming) ? MemberDn : SystemMemberDn,
                            &LdapMod);

            DPRINT2(4, ":DS: Creating Member Reference %ws for %ws\n",
                    ComputerName, ReplicaSetName);

            LdapMod[0]->mod_op = LDAP_MOD_REPLACE;
            LStatus = ldap_modify_s(Ldap, (OldNaming) ? SetDn : SystemSetDn, LdapMod);

            FrsDsFreeLdapMod(&LdapMod);

            if (LStatus == LDAP_SUCCESS) {
                *RefetchComputer = TRUE;
            }

            if (LStatus != LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                CLEANUP2_LS(0, ":DS: ERROR - Can't create priamry reference %ws\\%ws:",
                            ReplicaSetName, ComputerName, LStatus, CONTINUE);
            }
        }


        //
        // Translate the symlinks. NtFrs requires true pathname to
        // its directories (<drive letter>:\...)
        // FrsChaseSymbolicLink returns both the PrintName and the SubstituteName.
        // We use the PrintName as it is the Dos Type name of the destination.
        // Substitute Name is ignored.
        //
        WStatus = FrsChaseSymbolicLink(ReplicationRootPath, &PrintableRealRoot, &SubstituteRealRoot);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, ":DS: ERROR - Accessing %ws; cannot process sysvol: WStatus = %d",
                        ReplicationRootPath, WStatus);
            RetStatus = FALSE;
            goto CONTINUE;
        }

        WStatus = FrsChaseSymbolicLink(ReplicationStagePath, &PrintableRealStage, &SubstituteRealStage);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2(0, ":DS: ERROR - Accessing %ws; cannot process sysvol: WStatus = %d",
                        ReplicationRootPath, WStatus);
            RetStatus = FALSE;
            goto CONTINUE;
        }

        //
        // Subscriptions (if needed)
        //
        DPRINT1(4, ":DS: Creating Subscriptions for %ws\n", ComputerName);
        FrsDsAddLdapMod(ATTR_CLASS, ATTR_SUBSCRIPTIONS, &LdapMod);
        FrsDsAddLdapMod(ATTR_WORKING, WorkingPath,  &LdapMod);
        LStatus = ldap_add_s(Ldap, SubsDn, LdapMod);
        FrsDsFreeLdapMod(&LdapMod);
        if (LStatus == LDAP_SUCCESS) {
            *RefetchComputer = TRUE;
        }

        if (LStatus != LDAP_ALREADY_EXISTS) {
            CLEANUP1_LS(0, ":DS: ERROR - Can't create %ws:",
                        SubsDn, LStatus, CONTINUE);
        }

        //
        // Subscriber -- may alread exist
        //      Delete old subscriber in case it was left lying around
        //      after a demotion. This can happen because the service
        //      doesn't have permissions to alter the DS after a promotion.
        //      Leaving the old objects lying around after the demotion
        //      is confusing but doesn't cause replication to behave
        //      incorrectly; any sysvol in the DS without a corresponding
        //      sysvol in the DB is ignored by the Ds polling thread.
        //
        DPRINT1(4, ":DS: Creating Subscriber for %ws\n", ComputerName);
        LStatus = FrsDsDeleteSubTree(Ldap, SubDn);
        CLEANUP1_LS(4, ":DS: WARN - Can't delete %ws:", SubDn, LStatus, CONTINUE);

        LStatus = FrsDsDeleteSubTree(Ldap, SystemSubDn);
        CLEANUP1_LS(4, ":DS: WARN - Can't delete %ws:", SystemSubDn, LStatus, CONTINUE);

        FrsDsAddLdapMod(ATTR_CLASS, ATTR_SUBSCRIBER, &LdapMod);
        FrsDsAddLdapMod(ATTR_REPLICA_ROOT, PrintableRealRoot, &LdapMod);
        FrsDsAddLdapMod(ATTR_REPLICA_STAGE, PrintableRealStage, &LdapMod);
        FrsDsAddLdapMod(ATTR_MEMBER_REF,
                        (OldNaming) ? MemberDn : SystemMemberDn,
                         &LdapMod);
        LStatus = ldap_add_s(Ldap, SystemSubDn, LdapMod);

        FrsDsFreeLdapMod(&LdapMod);
        if (LStatus == LDAP_SUCCESS) {
            *RefetchComputer = TRUE;
        }

        if (LStatus != LDAP_ALREADY_EXISTS) {
            CLEANUP1_LS(4, ":DS: ERROR - Can't create %ws:",
                         SystemSubDn, LStatus, CONTINUE);
        }


        //
        // Seeding information
        //

        //
        // Create the key for all seeding sysvols
        //

        WStatus = CfgRegOpenKey(FKC_SYSVOL_SEEDING_SECTION_KEY,
                                NULL,
                                FRS_RKF_CREATE_KEY,
                                &HSeedingsKey);
        CLEANUP1_WS(0, ":DS: ERROR - Cannot create seedings key for %ws;",
                    ReplicaSetName, WStatus, SKIP_SEEDING);

        //
        // Create the seeding subkey for this sysvol
        //
        RegDeleteKey(HSeedingsKey, ReplicaSetName);
        RegDeleteKey(HSeedingsKey, CN_DOMAIN_SYSVOL);
        if (ReplicaSetParent) {

            //
            // Save the Replica Set Parent for this replica set under the
            // "Sysvol Seeding\<rep set name>\Replica Set Parent"
            //
            WStatus = CfgRegWriteString(FKC_SYSVOL_SEEDING_N_PARENT,
                                        (OldNaming) ? ReplicaSetName : CN_DOMAIN_SYSVOL,
                                        FRS_RKF_CREATE_KEY,
                                        ReplicaSetParent);
            DPRINT1_WS(0, "WARN - Cannot create parent value for %ws;",
                      (OldNaming) ? ReplicaSetName : CN_DOMAIN_SYSVOL, WStatus);
        }


        //
        // Save the Replica Set name for this replica set under the
        // "Sysvol Seeding\<rep set name>\Replica Set Name"
        //
        WStatus = CfgRegWriteString(FKC_SYSVOL_SEEDING_N_RSNAME,
                                    (OldNaming) ? ReplicaSetName : CN_DOMAIN_SYSVOL,
                                    FRS_RKF_CREATE_KEY,
                                    ReplicaSetName);
        DPRINT1_WS(0, "WARN - Cannot create name value for %ws;",
               (OldNaming) ? ReplicaSetName : CN_DOMAIN_SYSVOL, WStatus);

SKIP_SEEDING:
        LStatus = LDAP_SUCCESS;

CONTINUE:
        FRS_REG_CLOSE(HSeedingsKey);

        //
        // Something went wrong. Put the LDAP error status into the
        // registry key for this replica set and move on to the next.
        //
        if (LStatus != LDAP_SUCCESS) {

            CfgRegWriteDWord(FKC_SET_N_SYSVOL_STATUS, RegBuf, 0, LStatus);
            RetStatus = FALSE;
        }

        //
        // CLEANUP
        //
        ReplicaSetCommand    = FrsFree(ReplicaSetCommand);
        ReplicaSetName       = FrsFree(ReplicaSetName);
        ReplicaSetParent     = FrsFree(ReplicaSetParent);
        ReplicaSetType       = FrsFree(ReplicaSetType);
        ReplicationRootPath  = FrsFree(ReplicationRootPath);
        PrintableRealRoot    = FrsFree(PrintableRealRoot);
        SubstituteRealRoot   = FrsFree(SubstituteRealRoot);
        ReplicationStagePath = FrsFree(ReplicationStagePath);
        PrintableRealStage   = FrsFree(PrintableRealStage);
        SubstituteRealStage  = FrsFree(SubstituteRealStage);

        SettingsDn           = FrsFree(SettingsDn);
        SystemSettingsDn     = FrsFree(SystemSettingsDn);
        SetDn                = FrsFree(SetDn);
        SystemSetDn          = FrsFree(SystemSetDn);
        SubsDn               = FrsFree(SubsDn);
        SubDn                = FrsFree(SubDn);
        SystemSubDn          = FrsFree(SystemSubDn);
        MemberDn             = FrsFree(MemberDn);
        SystemMemberDn       = FrsFree(SystemMemberDn);
        FileFilterList       = FrsFree(FileFilterList);
        DirFilterList        = FrsFree(DirFilterList);

        //
        // Next SubKey
        //
        ++Index;
    }   // End while (RetStatus)


    if (HANDLE_IS_VALID(HKey)) {
        //
        // The flush here will make sure that the key is written to the disk.
        // These are critical registry operations and we don't want the lazy flusher
        // to delay the writes.
        //
        RegFlushKey(HKey);
        FRS_REG_CLOSE(HKey);
    }

    return RetStatus;
}


DWORD
FrsDsCreateSysVols(
    IN PLDAP        Ldap,
    IN PWCHAR       ServicesDn,
    IN PCONFIG_NODE Computer,
    OUT BOOL        *RefetchComputer
    )
/*++
Routine Description:
    Process the commands left in the Sysvol registry key by dcpromo.

    Ignore the sysvol registry key if this machine is not a DC!

    NOTE: this means the registry keys for a "delete sysvol"
    after a demotion are pretty much ignored. So why have them?
    Its historical and there is too little time before B3 to make
    such a dramatic change. Besides, we may find a use for them.
    And, to make matters worse, the "delete sysvol" keys could
    not be processed because the ldap_delete() returned insufficient
    rights errors since this computer is no longer a DC.

    REGCMD_DELETE_MEMBERS is no longer used as all deletion is done
    in ntfrsapi.c when demotion is committed.

Arguments:
    Ldap
    ServicesDn
    Computer
    RefetchComputer - Objects were altered in the DS, refetch DS info

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsCreateSysVols:"
    DWORD   WStatus;
    DWORD   SysVolInfoIsCommitted;
    HKEY    HKey = INVALID_HANDLE_VALUE;

    //
    // Refetch the computer subtree iff the contents of the DS
    // are altered by this function
    //
    *RefetchComputer = FALSE;

    //
    // Already checked the registry or not a DC; done
    //
    if (DsCreateSysVolsHasRun || !IsADc) {
        return ERROR_SUCCESS;
    }

    DPRINT(5, ":DS: Checking for SysVols commands\n");

    //
    // Open the system volume replica sets key.
    //    FRS_CONFIG_SECTION\SysVol
    //
    WStatus = CfgRegOpenKey(FKC_SYSVOL_SECTION_KEY, NULL, 0, &HKey);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(4, ":DS: WARN - Cannot open sysvol key.", WStatus);
        DPRINT(4, ":DS: ERROR - Can't check for sysvols\n");
        return WStatus;
    }


    WStatus = CfgRegReadDWord(FKC_SYSVOL_INFO_COMMITTED, NULL, 0, &SysVolInfoIsCommitted);
    CLEANUP_WS(4, ":DS: Sysvol info is not committed.", WStatus, done);

    DPRINT1(4, ":DS: Sysvol info is committed (%d)\n", SysVolInfoIsCommitted);

    //
    // Must have a computer; try again later
    //
    if (!Computer) {
        DPRINT(4, ":DS: No computer; retry sysvols later\n");
        WStatus = ERROR_RETRY;
        goto cleanup;
    }

    //
    // Must have a server reference; try again later
    //
    if (!Computer->SettingsDn && RunningAsAService) {
        DPRINT1(4, ":DS: %ws does not have a server reference; retry sysvols later\n",
               Computer->Name->Name);
        WStatus = ERROR_RETRY;
        goto cleanup;
    }

    //
    // assume failure
    //
    WIN_SET_FAIL(WStatus);

    //
    // Don't create the settings or set if this computer is not a DC
    //
    if (IsADc &&
        !FrsDsEnumerateSysVolKeys(Ldap, REGCMD_CREATE_PRIMARY_DOMAIN,
                               ServicesDn, SystemDn, Computer, RefetchComputer)) {
        goto cleanup;
    }
    //
    // Don't create the member if this computer is not a DC
    //
    if (IsADc &&
        !FrsDsEnumerateSysVolKeys(Ldap, REGCMD_CREATE_MEMBERS,
                               ServicesDn, SystemDn, Computer, RefetchComputer)) {
        goto cleanup;
    }
    //
    // Don't delete the sysvol if this computer is a DC.
    //
    // The following code is never executed because if we are not a DC then
    // the function returns after the first check.
    //
    /*
    if (!IsADc &&
        !FrsDsEnumerateSysVolKeys(Ldap, REGCMD_DELETE_MEMBERS,
                               ServicesDn, SystemDn, Computer, RefetchComputer)) {
        goto cleanup;
    }
    */

    //
    // Discard the dcpromo keys
    //
    if (!FrsDsEnumerateSysVolKeys(Ldap, REGCMD_DELETE_KEYS,
                               ServicesDn, SystemDn, Computer, RefetchComputer)) {
        goto cleanup;
    }

    //
    // sysvol info has been processed; don't process again
    //
    RegDeleteValue(HKey, SYSVOL_INFO_IS_COMMITTED);

done:
    DsCreateSysVolsHasRun = TRUE;
    WStatus = ERROR_SUCCESS;

cleanup:
    //
    // Cleanup
    //
    if (HANDLE_IS_VALID(HKey)) {
        //
        // The flush here will make sure that the key is written to the disk.
        // These are critical registry operations and we don't want the lazy flusher
        // to delay the writes.
        //
        RegFlushKey(HKey);
        FRS_REG_CLOSE(HKey);
    }
    return WStatus;
}


PWCHAR
FrsDsPrincNameToBiosName(
    IN PWCHAR   PrincName
    )
/*++
Routine Description:
    Convert the principal name (domain.dns.name\SamAccountName) into
    its equivalent NetBios name (SamAccountName - $).

Arguments:
    PrincName   - Domain Dns Name \ Sam Account Name

Return Value:
    Sam Account Name - trailing $
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsPrincNameToBiosName:"
    DWORD   Len;
    PWCHAR  c;
    PWCHAR  BiosName = NULL;

    if (!PrincName || !*PrincName) {
        goto CLEANUP;
    }

    //
    // Find the first char past the first whack
    //
    for (c = PrincName; *c && *c != L'\\'; ++c);
    if (!*c) {
        //
        // No whack; use the entire principal name
        //
        c = PrincName;
    } else {
        //
        // Skip the whack
        //
        ++c;
    }
    //
    // Elide the trailing $
    //
    Len = wcslen(c);
    if (c[Len - 1] == L'$') {
        --Len;
    }

    //
    // Copy the chars between the whack and the dollar (append trailing null)
    //
    BiosName = FrsAlloc((Len + 1) * sizeof(WCHAR));
    CopyMemory(BiosName, c, Len * sizeof(WCHAR));
    BiosName[Len] = L'\0';

CLEANUP:
    DPRINT2(4, ":DS: PrincName %ws to BiosName %ws\n", PrincName, BiosName);

    return BiosName;
}


VOID
FrsDsMergeConfigWithReplicas(
    IN PLDAP        Ldap,
    IN PCONFIG_NODE Sites
    )
/*++
Routine Description:
    Convert the portions of the DS tree that define the topology
    and state for this machine into replicas and merge them with
    the active replicas.

Arguments:
    Sites

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsMergeConfigWithReplicas:"
    PCONFIG_NODE    Site;
    PCONFIG_NODE    Settings;
    PCONFIG_NODE    Set;
    PCONFIG_NODE    Server;
    PCONFIG_NODE    Node;
    PCONFIG_NODE    RevNode;
    BOOL            Inbound;
    BOOL            IsSysvol;
    PCXTION         Cxtion;
    PREPLICA        Replica;
    PREPLICA        DbReplica;

    //
    // Coordinate with replica command server
    //
    RcsBeginMergeWithDs();

    //
    // For every server
    //
    for (Site = Sites; Site; Site = Site->Peer) {
    for (Settings = Site->Children; Settings; Settings = Settings->Peer) {
    for (Set = Settings->Children; Set; Set = Set->Peer) {
    for (Server = Set->Children; Server && !DsIsShuttingDown; Server = Server->Peer) {
        //
        // This server does not match this machine's name; continue
        //
        if (!Server->ThisComputer) {
            continue;
        }

        //
        // MATCH
        //

        //
        // CHECK FOR SYSVOL CONSISTENCY
        // Leave the current DB state alone if a sysvol
        // appears from the DS and the sysvol registry
        // keys were not processed or the computer is not
        // a dc.
        //
        if (FRS_RSTYPE_IS_SYSVOLW(Set->SetType)) {
            //
            // Not a DC or sysvol registry keys not processed
            //      Tombstone existing sysvols
            //      Ignore new sysvols
            //
            if (!IsADc || !DsCreateSysVolsHasRun) {
                continue;
            }
        }

        //
        // Create a replica set
        //
        Replica = FrsAllocType(REPLICA_TYPE);
        //
        // Replica name (Set Name + Member Guid)
        Replica->ReplicaName = FrsBuildGName(FrsDupGuid(Server->Name->Guid),
                                             FrsWcsDup(Set->Name->Name));
        //
        // Member name + guid
        //
        Replica->MemberName = FrsDupGName(Server->Name);
        //
        // Set name + guid
        //
        Replica->SetName = FrsDupGName(Set->Name);
        //
        // Root guid (hammered onto the root directory)
        // Temporary; a new guid is assigned if this is a new
        // set.
        //
        Replica->ReplicaRootGuid = FrsDupGuid(Replica->SetName->Guid);

        //
        // File Filter
        //
        Replica->FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                       Set->FileFilterList,
                                       RegistryFileExclFilterList,
                                       DEFAULT_FILE_FILTER_LIST);
        Replica->FileInclFilterList =  FrsWcsDup(RegistryFileInclFilterList);

        //
        // Directory Filter
        //
        Replica->DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                      Set->DirFilterList,
                                      RegistryDirExclFilterList,
                                      DEFAULT_DIR_FILTER_LIST);
        Replica->DirInclFilterList =  FrsWcsDup(RegistryDirInclFilterList);

        //
        // Root and stage
        //
        Replica->Root = FrsWcsDup(Server->Root);
        Replica->Stage = FrsWcsDup(Server->Stage);
        FRS_WCSLWR(Replica->Root);     // for wcsstr()
        FRS_WCSLWR(Replica->Stage);    // for wcsstr()
        //
        // Volume.
        //
//        Replica->Volume = FrsWcsVolume(Server->Root);

        //
        // Does the Set's primary member link match this
        // member's Dn? Is this the primary member?
        //
        if (Set->MemberDn) {
	    ClearFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY_UNDEFINED);
	    if(WSTR_EQ(Server->Dn, Set->MemberDn)) {
		SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY);
	    }
	} else {
	    SetFlag(Replica->CnfFlags, CONFIG_FLAG_PRIMARY_UNDEFINED);

	    //
	    // DFS is not currently (Sept 2002) using the primary
	    // member, so it is okay if there is none.
	    // For now, don't spam the event log with this warning.
	    //
	    
//	    FrsDsAddToPollSummary1ws(IDS_POLL_SUM_PRIMARY_UNDEFINED, 
//				     Replica->ReplicaName->Name
//				     );

	}

        //
        // Consistent
        //
        Replica->Consistent = Server->Consistent;
        //
        // Replica Set Type
        //
        if (Set->SetType) {
            Replica->ReplicaSetType = wcstoul(Set->SetType, NULL, 10);
        } else {
            Replica->ReplicaSetType = FRS_RSTYPE_OTHER;
        }

        //
        // FRS replica set object Flags
        //
        Replica->FrsRsoFlags = Set->FrsRsoFlags;

        //
        // Set default Schedule for replica set.  Priority order is:
        //  1. Server  (sysvols only)
        //  2. ReplicaSet object
        //  3. Settings object
        //  4. Site object.
        //
        Node = (Server->Schedule) ? Server :
                   (Set->Schedule) ? Set :
                       (Settings->Schedule) ? Settings :
                           (Site->Schedule) ? Site : NULL;
        if (Node) {
            Replica->Schedule = FrsAlloc(Node->ScheduleLength);
            CopyMemory(Replica->Schedule, Node->Schedule, Node->ScheduleLength);
        }

        //
        // Sysvol needs seeding
        //
        // The CnfFlags are ignored if the set already exists.
        // Hence, only newly created sysvols are seeded.
        //
        IsSysvol = FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType);
        if (IsSysvol &&
            !BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
            SetFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
        }

        //
        // Go through the connections and fix the schedule for
        // two way replication.
        //
        for (Node = Server->Children; Node; Node = Node->Peer) {
            if (!Node->Consistent) {
                continue;
            }
            //
            // If the NTDSCONN_OPT_TWOWAY_SYNC flag is set on the connection then
            // merge the schedule on this connection with the schedule on the connection
            // that is in the opposite direction and use the resultant schedule on the
            // connection in the opposite direction.
            //
            if (Node->CxtionOptions & NTDSCONN_OPT_TWOWAY_SYNC) {
                Inbound = !Node->Inbound;
                //
                // Loop through the connections and find the connection in
                // the opposite direction.
                //
                for (RevNode = Server->Children; RevNode; RevNode = RevNode->Peer) {
                    if ((RevNode->Inbound == Inbound) &&
                        !_wcsicmp(Node->PartnerDn, RevNode->PartnerDn)) {

                        DPRINT1(4,"Two-way replication: Setting merged schedule on %ws\n",RevNode->Dn);
                        FrsDsMergeTwoWaySchedules(&Node->Schedule,
                                            &Node->ScheduleLength,
                                            &RevNode->Schedule,
                                            &RevNode->ScheduleLength,
                                            &Replica->Schedule);
                        break;

                    }
                }
            }
        }

        //
        // Copy over the cxtions
        //
        for (Node = Server->Children; Node; Node = Node->Peer) {

            if (!Node->Consistent) {
                continue;
            }

            Cxtion = FrsAllocType(CXTION_TYPE);

            Cxtion->Inbound = Node->Inbound;
            if (Node->Consistent) {
                SetCxtionFlag(Cxtion, CXTION_FLAGS_CONSISTENT);
            }
            Cxtion->Name = FrsDupGName(Node->Name);
            Cxtion->Partner = FrsBuildGName(
                                  FrsDupGuid(Node->PartnerName->Guid),
                                  FrsDsPrincNameToBiosName(Node->PrincName));
            //
            // Partner's DNS name from ATTR_DNS_HOST_NAME on the computer
            // object. Register an event if the attribute is missing
            // or unavailable and try using the netbios name.
            //
            if (Node->PartnerDnsName) {
                Cxtion->PartnerDnsName = FrsWcsDup(Node->PartnerDnsName);
            } else {
                if (Cxtion->Partner->Name && Cxtion->Partner->Name[0]) {
                    EPRINT3(EVENT_FRS_NO_DNS_ATTRIBUTE,
                            Cxtion->Partner->Name,
                            ATTR_DNS_HOST_NAME,
                            (Node->PartnerCoDn) ? Node->PartnerCoDn :
                                                  Cxtion->Partner->Name);
                    Cxtion->PartnerDnsName = FrsWcsDup(Cxtion->Partner->Name);
                } else {
                    Cxtion->PartnerDnsName = FrsWcsDup(L"<unknown>");
                }
            }
            //
            // Partner's SID name from DsCrackNames() on the computer
            // object. Register an event if the SID is unavailable.
            //
            if (Node->PartnerSid) {
                Cxtion->PartnerSid = FrsWcsDup(Node->PartnerSid);
            } else {
                //
                // Print the eventlog message only if DsBindingsAreValid is TRUE.
                // If it is FALSE it means that the handle is invalid and we are
                // scheduled to rebind at the next poll. In that case the rebind will
                // probably fix the problem silently.
                //
                if (Cxtion->Partner->Name && Cxtion->Partner->Name[0] && DsBindingsAreValid) {
                    EPRINT3(EVENT_FRS_NO_SID,
                            Replica->Root,
                            Cxtion->Partner->Name,
                            (Node->PartnerCoDn) ? Node->PartnerCoDn :
                                                  Cxtion->Partner->Name);
                }
                Cxtion->PartnerSid = FrsWcsDup(L"<unknown>");
            }
            Cxtion->PartnerPrincName = FrsWcsDup(Node->PrincName);
            Cxtion->PartSrvName = FrsWcsDup(Node->PrincName);

            //
            // Use the schedule on the cxtion object if provided.
            // Otherwise it will default to the schedule on the replica struct
            // that was set above.
            //
            if (Node->Schedule) {
                Cxtion->Schedule = FrsAlloc(Node->ScheduleLength);
                CopyMemory(Cxtion->Schedule, Node->Schedule, Node->ScheduleLength);
            }
            //
            // Treat the schedule as a trigger schedule if the partner
            // is in another site, if this is a sysvol, and if the node
            // has a schedule.
            //
            // A missing schedule means, "always on" for both
            // stop/start and trigger schedules.
            //
            if (IsSysvol && !Node->SameSite && Node->Schedule) {
                SetCxtionFlag(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE);
            }

            SetCxtionState(Cxtion, CxtionStateUnjoined);
            GTabInsertEntry(Replica->Cxtions, Cxtion, Cxtion->Name->Guid, NULL);

            //
            // Copy over the value of options attribute of the connection object.
            //
            Cxtion->Options = Node->CxtionOptions;
            Cxtion->Priority = FRSCONN_GET_PRIORITY(Cxtion->Options);
        }


        //
        // Merge the replica with the active replicas
        //
        RcsMergeReplicaFromDs(Replica);
    } } } }

    RcsEndMergeWithDs();

    //
    // The above code is only executed when the DS changes. This should
    // be an infrequent occurance. Any code we loaded to process the merge
    // can now be discarded without undue impact on active replication.
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
}


VOID
FrsDsPollDs(
    VOID
    )
/*++
Routine Description:
    New way to get the current configuration from the DS and merge it with
    the active replicas.

    Part of NewDs poll APIs.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsPollDs:"
    BOOL            RefetchComputer;
    DWORD           WStatus     = ERROR_SUCCESS;
    PCONFIG_NODE    Services    = NULL;
    PCONFIG_NODE    Computer    = NULL;
    PVOID           Key         = NULL;
    PGEN_ENTRY      Entry       = NULL;

    //
    // Increment the DS Polls Counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, DSPolls, 1);

    //
    // Empty the VolSerialNumberToDriveTable before every poll so we have
    // fresh information every time. The table is built as needed.
    //
    if (VolSerialNumberToDriveTable != NULL) {
        GTabEmptyTable(VolSerialNumberToDriveTable, FrsFree);
    }

#if DBG
    //
    // For test purposes, you can run without a DS
    //
    if (NoDs) {
        //
        // kick off the rest of the service
        //
        MainInit();
        if (!MainInitHasRun) {
            FRS_ASSERT(MainInitHasRun == TRUE);
        }
        //
        // Use the hardwired config
        //
        if (IniFileName) {
            DPRINT(0, ":DS: Hard wired config from ini file.\n");
            FrsDsUseHardWired(LoadedWired);
        } else {
            DPRINT(0, ":DS: David's hard wired config.\n");
            //
            // Complete config
            //
            FrsDsUseHardWired(DavidWired);
#if 0
            Sleep(60 * 1000);

            //
            // Take out the server 2 (E:)
            //
            FrsDsUseHardWired(DavidWired2);
            Sleep(60 * 1000);

            //
            // Put back in E and but take out all cxtions
            //
            //FrsDsUseHardWired();
            //Sleep(5 * 1000);

            //
            // Put everything back in
            //
            FrsDsUseHardWired(DavidWired);
            Sleep(60 * 1000);
#endif

            //
            // Repeat in 30 seconds
            //
            DsPollingShortInterval = 30 * 1000;
            DsPollingLongInterval = 30 * 1000;
            DsPollingInterval = 30 * 1000;
        }

        //
        // Periodically check the local resources like disk space etc.
        //
        FrsCheckLocalResources();

        return;
    }
#endif DBG

    //
    // Backup/Restore
    //
    WStatus = FrsProcessBackupRestore();
    if (!WIN_SUCCESS(WStatus)) {
        goto CLEANUP;
    }

    //
    // Open and bind an ldap connection to the DS
    //
    if (!FrsDsOpenDs()) {
        if (DsIsShuttingDown) {
            goto CLEANUP;
        }
        DPRINT(4, ":DS: Wait 5 seconds and retry DS open.\n");
        WaitForSingleObject(ShutDownEvent, 5 * 1000);
        if (!FrsDsOpenDs()) {
            if (DsIsShuttingDown) {
                goto CLEANUP;
            }
            DPRINT(4, ":DS: Wait 30 seconds and retry DS open.\n");
            WaitForSingleObject(ShutDownEvent, 30 * 1000);
            if (!FrsDsOpenDs()) {
                if (DsIsShuttingDown) {
                    goto CLEANUP;
                }
                DPRINT(4, ":DS: Wait 180 seconds and retry DS open.\n");
                WaitForSingleObject(ShutDownEvent, 3 * 60 * 1000);
                if (!FrsDsOpenDs()) {
                    //
                    // Add to the poll summary event log.
                    //
                    FrsDsAddToPollSummary(IDS_POLL_SUM_DSBIND_FAIL);

                    goto CLEANUP;
                }
            }
        }
    }

    //
    // Keep a running checksum of the change usns for this polling cycle
    // Ignore configurations whose checksum is not the same for two
    // polling intervals (DS is in flux).
    //
    ThisChange = 0;
    NextChange = 0;

    //
    // User side of the configuration. This function will build two table of subscribers.
    // SubscribersByRootPath and SubscribersByMemberRef. It will resolve any duplicate
    // conflicts.
    //
    //
    // Initialize the PartnerComputerTable.
    //
    if (PartnerComputerTable != NULL) {
        //
        // Members of the PartnerComputerTable need to be freed seperately
        // as they are not part of the tree. So call FrsFreeType for
        // each node.
        //
        PartnerComputerTable = GTabFreeTable(PartnerComputerTable, FrsFreeType);
    }

    PartnerComputerTable = GTabAllocStringTable();

    //
    // Initialize the AllCxtionsTable.
    //
    if (AllCxtionsTable != NULL) {
        AllCxtionsTable = GTabFreeTable(AllCxtionsTable, NULL);
    }

    AllCxtionsTable = GTabAllocStringAndBoolTable();

    WStatus = FrsDsGetComputer(gLdap, &Computer);
    if (!WIN_SUCCESS(WStatus)) {
        //
        // Add to the poll summary event log.
        //
        FrsDsAddToPollSummary(IDS_POLL_SUM_NO_COMPUTER);

        goto CLEANUP;
    }

    if (!Computer) {
        DPRINT(4, ":DS: NO COMPUTER OBJECT!\n");
        //
        // Add to the poll summary event log.
        //
        FrsDsAddToPollSummary(IDS_POLL_SUM_NO_COMPUTER);

    }

    //
    // Register (once) our SPN using the global ds binding handle.
    //
    if (Computer) {
        FrsDsRegisterSpn(gLdap, Computer);
    }

    //
    // Create the sysvols, if any
    //
    if (IsADc && !DsCreateSysVolsHasRun) {
        WStatus = FrsDsCreateSysVols(gLdap, ServicesDn, Computer, &RefetchComputer);

        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1(4, ":DS: IGNORE Can't process sysvols; WStatus %s!\n", ErrLabelW32(WStatus));
            WStatus = ERROR_SUCCESS;
        } else if (RefetchComputer) {
            //
            // FrsDsCreateSysVols() may add/del objects from the user
            // side of the configuration; refetch just in case.
            //
            ThisChange = 0;
            NextChange = 0;
            SubscriberTable = GTabFreeTable(SubscriberTable, NULL);
            FrsDsFreeTree(Computer);
            WStatus = FrsDsGetComputer(gLdap, &Computer);
            if (!WIN_SUCCESS(WStatus)) {
                goto CLEANUP;
            }
        }
    }

    //
    // Is there any possibility that a replica set exists or that
    // an old replica set should be deleted?
    //
    if (!FrsDsDoesUserWantReplication(Computer)) {
        //
        // Nope, no new, existing, or deleted sets
        //
        DPRINT(4, ":DS: Nothing to do; don't start the rest of the system.\n");

        //
        // Add to the poll summary event log.
        //
        FrsDsAddToPollSummary(IDS_POLL_SUM_NO_REPLICASETS);

        WStatus = ERROR_RETRY;
        goto CLEANUP;
    }
    //
    // kick off the rest of the service
    //
    MainInit();

    if (!MainInitHasRun) {
        FRS_ASSERT(MainInitHasRun == TRUE);
    }

    //
    // Admin side of the configuration
    //
    WStatus = FrsDsGetServices(gLdap, Computer, &Services);

    if (Services == NULL) {
        goto CLEANUP;
    }

    //
    // Increment the DS Polls with and without changes Counters
    //
    if ((LastChange == 0)|| (ThisChange != LastChange)) {
        PM_INC_CTR_SERVICE(PMTotalInst, DSPollsWChanges, 1);
    }
    else {
        PM_INC_CTR_SERVICE(PMTotalInst, DSPollsWOChanges, 1);
    }


    //
    // Don't use the config if the DS is in flux unless
    // this is the first successful polling cycle.
    //
    if (DsPollingInterval != DsPollingShortInterval &&
        LastChange && ThisChange != LastChange) {
        DPRINT(4, ":DS: Skipping noisy topology\n");
        LastChange = ThisChange;
        //
        // Check for a stable DS configuration after a short interval
        //
        DsPollingInterval = DsPollingShortInterval;
        goto CLEANUP;
    } else {
        LastChange = ThisChange;
    }

    //
    // No reason to continue polling the DS quickly; we have all
    // of the stable information currently in the DS.
    //
    // DsPollingInterval = DsPollingLongInterval;

    //
    // Don't process the same topology repeatedly
    //
    // NTRAID#23652-2000/03/29-sudarc (Perf - FRS merges the DS configuration
    //                                 with its interval DB everytime it polls.)
    //
    // *Note*: Disable ActiveChange for now; too unreliable and too
    //         many error conditions in replica.c, createdb.c, ...
    //         besides, configs are so small that cpu savings are minimal
    //         plus; rejoins not issued every startreplica()
    //
    ActiveChange = 0;
    if (ActiveChange && NextChange == ActiveChange) {
        DPRINT(4, ":DS: Skipping previously processed topology\n");
        goto CLEANUP;
    }
    //
    // *Note*: Inconsistencies detected below should reset ActiveChange
    //         to 0 if the inconsistencies may clear up with time and
    //         don't require a DS change to clear up or fix
    //
    ActiveChange = NextChange;

    //
    // Check for valid paths
    //
    FrsDsCheckServerPaths(Services);

    //
    // Create the server principal name for each cxtion
    //
    FrsDsCreatePartnerPrincName(Services);

    //
    // Check the schedules
    //
    FrsDsCheckSchedules(Services);
    FrsDsCheckSchedules(Computer);

    //
    // Now comes the tricky part. The above checks were made without
    // regard to a nodes consistency. Now is the time to propagate
    // inconsistencies throughout the tree to avoid inconsistencies
    // caused by inconsistencies. E.g., a valid cxtion with an
    // inconsistent partner.
    //

    //
    // Push the parent's inconsistent state to its children
    //
    FrsDsPushInConsistenciesDown(Services);

    //
    // Merge the new config with the active replicas
    //
    DPRINT(4, ":DS: Begin merging Ds with Db\n");
    FrsDsMergeConfigWithReplicas(gLdap, Services);
    DPRINT(4, ":DS: End merging Ds with Db\n");

    //
    // Periodically check the local resources like disk space etc.
    //
    FrsCheckLocalResources();

    if(NeedNewPartnerTable) {
    //
    // Clear the flag
    //
    NeedNewPartnerTable = FALSE;
    FrsDsCreateNewValidPartnerTableStruct();
    }

    FrsDsCleanupOldValidPartnerTableStructList();

CLEANUP:
    //
    // Free the tables that were pointing into the tree.
    // This just frees the entries in the table not the nodes.
    // but the nodes can not be freed before freeing the
    // tables as the compare functions are needed while.
    // emptying the table.
    //

    SubscriberTable = GTabFreeTable(SubscriberTable, NULL);

    SetTable = GTabFreeTable(SetTable, NULL);

    CxtionTable = GTabFreeTable(CxtionTable, NULL);

    AllCxtionsTable = GTabFreeTable(AllCxtionsTable, NULL);

    //
    // Members of the PartnerComputerTable need to be freed seperately
    // as they are not part of the tree. So call FrsFreeType for
    // each node.
    //
    PartnerComputerTable = GTabFreeTable(PartnerComputerTable, FrsFreeType);

    MemberTable = GTabFreeTable(MemberTable, NULL);

    if (MemberSearchFilter != NULL) {
        MemberSearchFilter = FrsFree(MemberSearchFilter);
    }

    //
    // Free the incore resources of the config retrieved from the DS
    //
    FrsDsFreeTree(Services);
    FrsDsFreeTree(Computer);


    if (!WIN_SUCCESS(WStatus)) {
        FrsDsCloseDs();
    }

    //
    // If there were any errors or warnings generated during this poll then
    // write the summary to the eventlog.
    //
    if ((DsPollSummaryBuf != NULL) && (DsPollSummaryBufLen > 0)) {
        EPRINT2(EVENT_FRS_DS_POLL_ERROR_SUMMARY,
                (IsADc) ?  ComputerDnsName :
                    (DsDomainControllerName ? DsDomainControllerName : L"<null>"),
                DsPollSummaryBuf);

        DsPollSummaryBuf = FrsFree(DsPollSummaryBuf);
        DsPollSummaryBufLen = 0;
        DsPollSummaryMaxBufLen = 0;
    }
}


DWORD
FrsDsSetDsPollingInterval(
    IN ULONG    UseShortInterval,
    IN ULONG    LongInterval,
    IN ULONG    ShortInterval
    )
/*++
Routine Description:
    Set the long and short polling intervals and kick of a new
    polling cycle. If both intervals are set, then the new polling
    cycle uses the short interval (short takes precedence over
    long). A value of -1 sets the interval to its current value.

    No new polling cycle is initiated if a polling cycle is in progress.

Arguments:
    UseShortInterval    - if non-zero, switch to short. Otherwise, long.
    LongInterval        - Long interval in minutes
    ShortInterval       - Short interval in minutes

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsSetDsPollingInterval:"
    DWORD   WStatus;

    DPRINT3(4, ":DS: Setting the polling intervals to %d/%d (use %s)\n",
            LongInterval, ShortInterval, (UseShortInterval) ? "Short" : "Long");
    //
    // Don't change the polling intervals; simply kick off a new cycle
    //
    if (!LongInterval && !ShortInterval) {
        DsPollingInterval = (UseShortInterval) ? DsPollingShortInterval :
                                                 DsPollingLongInterval;
        SetEvent(DsPollEvent);
        return ERROR_SUCCESS;
    }

    //
    // ADJUST LONG INTERVAL
    //
    if (LongInterval) {

        // FRS_CONFIG_SECTION\DS Polling Long Interval in Minutes
        WStatus = CfgRegWriteDWord(FKC_DS_POLLING_LONG_INTERVAL,
                                   NULL,
                                   FRS_RKF_RANGE_SATURATE,
                                   LongInterval);
        CLEANUP_WS(4, ":DS: DS Polling Long Interval not written.", WStatus, RETURN);

        //
        // Adjust the long polling rate
        //
        DsPollingLongInterval = LongInterval * (60 * 1000);
    }
    //
    // ADJUST SHORT INTERVAL
    //
    if (ShortInterval) {
        //
        // Sanity check
        //
        if (LongInterval && (ShortInterval > LongInterval)) {
            ShortInterval = LongInterval;
        }

        // FRS_CONFIG_SECTION\DS Polling Short Interval in Minutes
        WStatus = CfgRegWriteDWord(FKC_DS_POLLING_SHORT_INTERVAL,
                                   NULL,
                                   FRS_RKF_RANGE_SATURATE,
                                   ShortInterval);
        CLEANUP_WS(4, ":DS: DS Polling Short Interval not written.", WStatus, RETURN);

        //
        // Adjust the Short polling rate
        //
        DsPollingShortInterval = ShortInterval * (60 * 1000);
    }
    //
    // Initiate a polling cycle
    //
    DsPollingInterval = (UseShortInterval) ? DsPollingShortInterval :
                                             DsPollingLongInterval;
    SetEvent(DsPollEvent);

    return ERROR_SUCCESS;

RETURN:
    return WStatus;
}


DWORD
FrsDsGetDsPollingInterval(
    OUT ULONG    *Interval,
    OUT ULONG    *LongInterval,
    OUT ULONG    *ShortInterval
    )
/*++
Routine Description:
    Return the current polling intervals.

Arguments:
    Interval        - Current interval in minutes
    LongInterval    - Long interval in minutes
    ShortInterval   - Short interval in minutes

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsGetDsPollingInterval:"

    *Interval = DsPollingInterval / (60 * 1000);
    *LongInterval = DsPollingLongInterval / (60 * 1000);
    *ShortInterval = DsPollingShortInterval / (60 * 1000);
    return ERROR_SUCCESS;
}


#define DS_POLLING_MAX_SHORTS   (8)
DWORD
FrsDsMainDsCs(
    IN PVOID Ignored
    )
/*++
Routine Description:
    Entry point for a DS poller thread

Arguments:
    Ignored

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsMainDsCs:"
    DWORD   WStatus;
    DWORD   DsPollingShorts = 0;
    HANDLE  WaitHandles[2];

    DPRINT(0, ":DS: DsCs is starting.\n");

    //
    //   DsPollingLongInterval
    //
    CfgRegReadDWord(FKC_DS_POLLING_LONG_INTERVAL, NULL, 0, &DsPollingLongInterval);

    //
    // Registry is specified in minutes; convert to milliseconds
    //
    DsPollingLongInterval *= (60 * 1000);

    //
    //   DsPollingShortInterval
    //
    CfgRegReadDWord(FKC_DS_POLLING_SHORT_INTERVAL, NULL, 0, &DsPollingShortInterval);

    //
    // Registry is specified in minutes; convert to milliseconds
    //
    DsPollingShortInterval *= (60 * 1000);


    DPRINT2(4, ":DS: DS long/short polling interval is %d/%d minutes\n",
            (DsPollingLongInterval / 1000) / 60,
            (DsPollingShortInterval / 1000) / 60);

    DsPollingInterval = DsPollingShortInterval;

    //
    // Initialize the client side ldap search timeout value.
    //

    LdapTimeout.tv_sec = LdapSearchTimeoutInMinutes * 60;

    //
    // Handles to wait on
    //
    WaitHandles[0] = DsPollEvent;
    WaitHandles[1] = ShutDownEvent;

    //
    // Set the registry keys and values necessary for the functioning of
    // PERFMON and load the counter values into the registry
    //
    // Moved from main.c because this function invokes another exe that
    // may cause frs to exceed its service startup time limit; resulting
    // in incorrect "service cannot start" messages during intensive
    // cpu activity (although frs does eventually start).
    //
    // NTRAID#70743-2000/03/29-sudarc (Retry initialization of perfmon registry keys
    //                                 if it fails during startup.)
    //
    DPRINT(0, "Init Perfmon registry keys (PmInitPerfmonRegistryKeys()).\n");
    WStatus = PmInitPerfmonRegistryKeys();

    DPRINT_WS(0, "ERROR - PmInitPerfmonRegistryKeys();", WStatus);

    DPRINT(0, ":DS: FrsDs has started.\n");

    try {
        try {
            //
            // While the service is not shutting down
            //
            while (!FrsIsShuttingDown && !DsIsShuttingDown) {
                //
                // Reload registry parameters that can change while service is
                // running.
                //
                DbgQueryDynamicConfigParams();

                //
                // What is this computer's role in the domain?
                //
                WStatus = FrsDsGetRole();
                if (WIN_SUCCESS(WStatus) && !IsAMember) {
                    //
                    // Nothing to do
                    // BUT dcpromo may have started us so we
                    // must at least keep the service running.
                    //
                    // Perhaps we could die after running awhile
                    // if we still aren't a member?
                    //
                    // DPRINT(4, "Not a member, shutting down\n");
                    // FrsIsShuttingDown = TRUE;
                    // SetEvent(ShutDownEvent);
                    // break;
                }

                //
                // Retrieve info from the DS and merge it with the
                // acitve replicas
                //
                DPRINT(4, ":DS: Polling the DS\n");
                if (IsAMember) {
                    FrsDsPollDs();
                }

                //
                // No reason to hold memory if there isn't anything
                // to do but wait for another ds polling cycle.
                //
                if (!MainInitHasRun) {
                    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
                }
                //
                // Poll often if a dc
                //
                if (IsADc) {
                    DsPollingInterval = DsPollingShortInterval;
                }

                //
                // Wait for a bit or until the service is shutdown
                //
                DPRINT1(4, ":DS: Poll the DS in %d minutes\n",
                        DsPollingInterval / (60 * 1000));
                ResetEvent(DsPollEvent);
                if (!FrsIsShuttingDown && !DsIsShuttingDown) {
                    WaitForMultipleObjects(2, WaitHandles, FALSE, DsPollingInterval);
                }
                //
                // The long interval can be reset to insure a high
                // poll rate. The short interval is temporary; go
                // back to long intervals after a few short intervals.
                //
                if (DsPollingInterval == DsPollingShortInterval) {
                    if (++DsPollingShorts > DS_POLLING_MAX_SHORTS) {
                        DsPollingInterval = DsPollingLongInterval;
                        DsPollingShorts = 0;
                    }
                } else {
                    DsPollingShorts = 0;
                }

            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
            DPRINT_WS(0, ":DS: DsCs exception.", WStatus);
        }
    } finally {
        //
        // Shutdown
        //
        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, ":DS: DsCs finally.", WStatus);
        FrsDsCloseDs();
        SetEvent(DsShutDownComplete);
        DPRINT(0, ":DS: DsCs is exiting.\n");
    }
    return WStatus;
}


VOID
FrsDsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the thread that polls the DS

Arguments:
    None.

Return Value:
    TRUE    - DS Poller has started
    FALSE   - Can't poll the DS
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDsInitialize:"

    //
    // Synchronizes with sysvol seeding
    //
    INITIALIZE_CRITICAL_SECTION(&MergingReplicasWithDs);

    //
    // Kick off the thread that polls the DS
    //
    ThSupCreateThread(L"FrsDs", NULL, FrsDsMainDsCs, ThSupExitWithTombstone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frscomm.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frscomm.c

Abstract:
    Routines for the comm layer to convert to and from communication packets.

Author:
    Billy J. Fuller 29-May-1997

    David Orbits 21-Mar-2000
        Restructured to use table and provide extensible elements.

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <tablefcn.h>



PCO_RECORD_EXTENSION_WIN2K
DbsDataConvertCocExtensionToWin2K(
    IN PCHANGE_ORDER_RECORD_EXTENSION CocExt
);



extern PGEN_TABLE   CompressionTable;

//
// Types for the common comm subsystem
//
// WARNING: The order of these entries can never change.  This ensures that
// packets can be exchanged between uplevel and downlevel members.
//
typedef enum _COMMTYPE {
    COMM_NONE = 0,

    COMM_BOP,               // beginning of packet

    COMM_COMMAND,           // command packet stuff
    COMM_TO,
    COMM_FROM,
    COMM_REPLICA,
    COMM_JOIN_GUID,
    COMM_VVECTOR,
    COMM_CXTION,

    COMM_BLOCK,             // file data
    COMM_BLOCK_SIZE,
    COMM_FILE_SIZE,
    COMM_FILE_OFFSET,

    COMM_REMOTE_CO,         // remote change order command

    COMM_GVSN,              // version (guid, vsn)

    COMM_CO_GUID,           // change order guid

    COMM_CO_SEQUENCE_NUMBER,// CO Seq number for ack.

    COMM_JOIN_TIME,         // machine's can't join if there times or badly out of sync

    COMM_LAST_JOIN_TIME,    // The Last time this connection was joined.
                            // Used to detect Database mismatch.

    COMM_EOP,               // end of packet

    COMM_REPLICA_VERSION_GUID, // replica version guid (originator guid)

    COMM_MD5_DIGEST,        // md5 digest
    //
    // Change Order Record Extension.  If not supplied the the ptr for
    // what was Spare1Bin (now Extension) is left as Null.  So comm packets
    // sent from down level members still work.
    //
    COMM_CO_EXT_WIN2K,      // in down level code this was called COMM_CO_EXTENSION.
    //
    // See comment in schema.h for why we need to seperate the var len
    // COMM_CO_EXTENSION_2 from COMM_CO_EXT_WIN2K above.
    //
    COMM_CO_EXTENSION_2,

    COMM_COMPRESSION_GUID,  // Guid for a supported compression algorithm.
    //
    // WARNING: To ensure that down level members can read Comm packets
    // from uplevel clients always add net data type codes here.
    //
    COMM_MAX
} COMM_TYPE, *PCOMM_TYPE;
#define COMM_NULL_DATA  (-1)

//
// The decode data types are defined below.  They are used in the CommPacketTable
// to aid in decode dispatching and comm packet construction
// They DO NOT get sent in the actual packet.
//
typedef enum _COMM_PACKET_DECODE_TYPE {
    COMM_DECODE_NONE = 0,
    COMM_DECODE_ULONG,
    COMM_DECODE_ULONG_TO_USHORT,
    COMM_DECODE_GNAME,
    COMM_DECODE_BLOB,
    COMM_DECODE_ULONGLONG,
    COMM_DECODE_VVECTOR,
    COMM_DECODE_VAR_LEN_BLOB,
    COMM_DECODE_REMOTE_CO,
    COMM_DECODE_GUID,
    COMM_DECODE_MAX
} COMM_PACKET_DECODE_TYPE, *PCOMM_PACKET_DECODE_TYPE;

//
// The COMM_PACKET_ELEMENT struct is used in a table to describe the data
// elements in a Comm packet.
//
typedef struct _COMM_PACKET_ELEMENT_ {
    COMM_TYPE    CommType;
    PCHAR        CommTag;
    ULONG        DataSize;
    ULONG        DecodeType;
    ULONG        NativeOffset;
} COMM_PACKET_ELEMENT, *PCOMM_PACKET_ELEMENT;



#define COMM_MEM_SIZE               (128)

//
// Size of the required Beginning-of-packet and End-of-Packet fields
//
#define MIN_COMM_PACKET_SIZE    (2 * (sizeof(USHORT) + sizeof(ULONG) + sizeof(ULONG)))

#define  COMM_SZ_UL        sizeof(ULONG)
#define  COMM_SZ_ULL       sizeof(ULONGLONG)
#define  COMM_SZ_GUID      sizeof(GUID)
#define  COMM_SZ_GUL       sizeof(GUID) + sizeof(ULONG)
#define  COMM_SZ_GVSN      sizeof(GVSN) + sizeof(ULONG)
#define  COMM_SZ_NULL      0
#define  COMM_SZ_COC       sizeof(CHANGE_ORDER_COMMAND) + sizeof(ULONG)
//#define  COMM_SZ_COC       CO_PART1_SIZE + CO_PART2_SIZE + CO_PART3_SIZE + sizeof(ULONG)
#define  COMM_SZ_COEXT_W2K sizeof(CO_RECORD_EXTENSION_WIN2K) + sizeof(ULONG)
#define  COMM_SZ_MD5       MD5DIGESTLEN + sizeof(ULONG)
#define  COMM_SZ_JTIME     sizeof(ULONGLONG) + sizeof(ULONG)
//
// Note:  When using COMM_DECODE_VAR_LEN_BLOB you must also use COMM_SZ_NULL
// in the table below so that no length check is made when the field is decoded.
// This allows the field size to grow.  Down level members must be able to
// handle this by ignoring var len field components they do not understand.
//

//
// The Communication packet element table below is used to construct and
// decode comm packet data sent between members.
// *** WARNING *** - the order of the rows in the table must match the
// the order of the elements in the COMM_TYPE enum.  See comments for COMM_TYPE
// enum for restrictions on adding new elements to the table.
//
//   Data Element Type       DisplayText             Size              Decode Type         Offset to Native Cmd Packet
//
COMM_PACKET_ELEMENT CommPacketTable[COMM_MAX] = {
{COMM_NONE,                 "NONE"               , COMM_SZ_NULL,   COMM_DECODE_NONE,      0                           },

{COMM_BOP,                  "BOP"                , COMM_SZ_UL,     COMM_DECODE_ULONG,     RsOffsetSkip                },
{COMM_COMMAND,              "COMMAND"            , COMM_SZ_UL,     COMM_DECODE_ULONG_TO_USHORT, OFFSET(COMMAND_PACKET, Command)},
{COMM_TO,                   "TO"                 , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(To)                },
{COMM_FROM,                 "FROM"               , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(From)              },
{COMM_REPLICA,              "REPLICA"            , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(ReplicaName)       },
{COMM_JOIN_GUID,            "JOIN_GUID"          , COMM_SZ_GUL,    COMM_DECODE_BLOB,      RsOffset(JoinGuid)          },
{COMM_VVECTOR,              "VVECTOR"            , COMM_SZ_GVSN,   COMM_DECODE_VVECTOR,   RsOffset(VVector)           },
{COMM_CXTION,               "CXTION"             , COMM_SZ_NULL,   COMM_DECODE_GNAME,     RsOffset(Cxtion)            },

{COMM_BLOCK,                "BLOCK"              , COMM_SZ_NULL,   COMM_DECODE_BLOB,      RsOffset(Block)             },
{COMM_BLOCK_SIZE,           "BLOCK_SIZE"         , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(BlockSize)         },
{COMM_FILE_SIZE,            "FILE_SIZE"          , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(FileSize)          },
{COMM_FILE_OFFSET,          "FILE_OFFSET"        , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(FileOffset)        },

{COMM_REMOTE_CO,            "REMOTE_CO"          , COMM_SZ_COC,    COMM_DECODE_REMOTE_CO, RsOffset(PartnerChangeOrderCommand)},
{COMM_GVSN,                 "GVSN"               , COMM_SZ_GVSN,   COMM_DECODE_BLOB,      RsOffset(GVsn)              },

{COMM_CO_GUID,              "CO_GUID"            , COMM_SZ_GUL,    COMM_DECODE_BLOB,      RsOffset(ChangeOrderGuid)   },
{COMM_CO_SEQUENCE_NUMBER,   "CO_SEQUENCE_NUMBER" , COMM_SZ_UL,     COMM_DECODE_ULONG,     RsOffset(ChangeOrderSequenceNumber)},
{COMM_JOIN_TIME,            "JOIN_TIME"          , COMM_SZ_JTIME,  COMM_DECODE_BLOB,      RsOffset(JoinTime)          },
{COMM_LAST_JOIN_TIME,       "LAST_JOIN_TIME"     , COMM_SZ_ULL,    COMM_DECODE_ULONGLONG, RsOffset(LastJoinTime)      },
{COMM_EOP,                  "EOP"                , COMM_SZ_UL,     COMM_DECODE_ULONG,     RsOffsetSkip                },
{COMM_REPLICA_VERSION_GUID, "REPLICA_VERSION_GUID", COMM_SZ_GUL,   COMM_DECODE_BLOB,      RsOffset(ReplicaVersionGuid)},
{COMM_MD5_DIGEST,           "MD5_DIGEST"         , COMM_SZ_MD5,    COMM_DECODE_BLOB,      RsOffset(Md5Digest)         },
{COMM_CO_EXT_WIN2K,         "CO_EXT_WIN2K"       , COMM_SZ_COEXT_W2K,COMM_DECODE_BLOB,    RsOffset(PartnerChangeOrderCommandExt)},
{COMM_CO_EXTENSION_2,       "CO_EXTENSION_2"     , COMM_SZ_NULL,   COMM_DECODE_VAR_LEN_BLOB, RsOffset(PartnerChangeOrderCommandExt)},

{COMM_COMPRESSION_GUID,     "COMPRESSION_GUID"   , COMM_SZ_GUID,   COMM_DECODE_GUID,      RsOffset(CompressionTable)}

};


BOOL
CommGetNextElement(
    IN PCOMM_PACKET CommPkt,
    OUT COMM_TYPE   *CommType,
    OUT ULONG       *CommTypeSize
    );



VOID
CommInitializeCommSubsystem(
    VOID
    )
/*++
Routine Description:
    Initialize the generic comm subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommInitializeCommSubsystem:"
    //
    // type must fit into a short
    //
    FRS_ASSERT(COMM_MAX <= 0xFFFF);
}



VOID
CommCopyMemory(
    IN PCOMM_PACKET CommPkt,
    IN PUCHAR       Src,
    IN ULONG        Len
    )
/*++
Routine Description:
    Copy memory into a comm packet, extending as necessary

Arguments:
    CommPkt
    Src
    Len

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommCopyMemory:"
    ULONG   MemLeft;
    PUCHAR  NewPkt;

    //
    // Adjust size of comm packet if necessary
    //
    // PERF:  How many allocs get done to send a CO???   This looks expensive.

    MemLeft = CommPkt->MemLen - CommPkt->PktLen;
    if (Len > MemLeft) {
        //
        // Just filling memory; extend memory, tacking on a little extra
        //
        CommPkt->MemLen = (((CommPkt->MemLen + Len) + (COMM_MEM_SIZE - 1))
                           / COMM_MEM_SIZE)
                           * COMM_MEM_SIZE;
        NewPkt = FrsAlloc(CommPkt->MemLen);
        CopyMemory(NewPkt, CommPkt->Pkt, CommPkt->PktLen);
        FrsFree(CommPkt->Pkt);
        CommPkt->Pkt = NewPkt;
    }

    //
    // Copy into the packet
    //
    if (Src != NULL) {
        CopyMemory(CommPkt->Pkt + CommPkt->PktLen, Src, Len);
    } else {
        ZeroMemory(CommPkt->Pkt + CommPkt->PktLen, Len);
    }
    CommPkt->PktLen += Len;
}


BOOL
CommFetchMemory(
    IN PCOMM_PACKET CommPkt,
    IN PUCHAR       Dst,
    IN ULONG        Len
    )
/*++
Routine Description:
    Fetch memory from a comm packet, reading as necessary

Arguments:
    CommPkt
    Dst
    Len

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommFetchMemory:"
    PUCHAR  Src;



    if ((CommPkt->UpkLen > (CommPkt->PktLen - Len)) || 
	(Len > CommPkt->PktLen))  {
        return FALSE;
    }

    Src = CommPkt->Pkt + CommPkt->UpkLen;
    CommPkt->UpkLen += Len;
    //
    // Copy into the packet
    //
    CopyMemory(Dst, Src, Len);
    return TRUE;
}


VOID
CommCompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    Completion routine for comm command servers. Free the
    comm packet and then call the generic completion routine
    to free the command packet.

Arguments:
    Cmd - command packet
    Arg - Cmd->CompletionArg

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommCompletionRoutine:"

    PCOMM_PACKET CommPkt = SRCommPkt(Cmd);
    PCXTION      Cxtion = SRCxtion(Cmd);

    COMMAND_SND_COMM_TRACE(4, Cmd, Cmd->ErrorStatus, "SndComplete");

    //
    // The SndCs and the ReplicaCs cooperate to limit the number of
    // active join "pings" so that the Snd threads are not hung
    // waiting for pings to dead servers to time out.
    //
    if ((CommPkt != NULL) &&
        (Cxtion != NULL) &&
        (CommPkt == Cxtion->ActiveJoinCommPkt)) {
        Cxtion->ActiveJoinCommPkt = NULL;
    }

    //
    // Free the comm packet and the attached return response command packet if
    // it's still attached.  The Replica Cmd Server uses the CMD_JOINING_AFTER_FLUSH
    // command in this way.
    //
    if (CommPkt != NULL) {
        FrsFree(CommPkt->Pkt);
        FrsFree(CommPkt);
    }

    if (SRCmd(Cmd)) {
        FrsCompleteCommand(SRCmd(Cmd), Cmd->ErrorStatus);
        SRCmd(Cmd) = NULL;
    }

    //
    // Free the name/guid and Principal name params.
    //
    FrsFreeGName(SRTo(Cmd));
    FrsFree(SRPrincName(Cmd));

    //
    // Move the packet to the generic "done" routine
    //
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
}


PUCHAR
CommGetHdr(
    IN PUCHAR   Pnext,
    IN PUSHORT  PCommType,
    IN PULONG   PLen
    )
/*++
Routine Description:
    Get and skip a field header

Arguments:
    Pnext
    PCommType
    PLen

Return Value:
    Address of the field's data
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommGetHdr:"
    CopyMemory(PCommType, Pnext, sizeof(USHORT));
    Pnext += sizeof(USHORT);

    CopyMemory(PLen, Pnext, sizeof(ULONG));
    Pnext += sizeof(ULONG);

    return Pnext;
}



BOOL
CommValidatePkt(
    IN PCOMM_PACKET CommPkt
    )
/*++
Routine Description:
    Check the packet for basic validity (i.e., make sure it is well formed.) 
    
    - Confirm that types and sizes of individual elements match with data in 
      the CommPacketTable. 
    - Check the value of CommPkt->Major
    - Ensure Pkt starts with BOP and ends with EOP
    - Check that internal offsets won't exceed the buffer  
    
    May modify CommPkt->UpkLen.

Arguments:
    CommPkt - pointer to the Comm Packet to validate.
    
Assumptions:

    CommPkt was built either by a call to CommStartCommPkt or via an RPC call 
    going to SERVER_FrsRpcSendCommPkt. Thus we assume that CommPkt is at least
    sizeof(COMM_PACKET) bytes long and that CommPkt->Pkt is CommPkt->PktLen 
    bytes long. 

Return Value:
    TRUE      - valid pkt (NOTE: this does not necessarily mean the data is
                                 meaningful, just well formed.)
    FALSE     - invalid
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommValidatePkt:"

    BOOL Result = FALSE;
    ULONG OriginalUpkLen = CommPkt->UpkLen;
    COMM_TYPE CommType = COMM_NONE;
    ULONG CommTypeSize = 0;
    ULONG DataSize = 0;
    ULONG DecodeType = COMM_DECODE_MAX;
    ULONG Size = 0;

    //
    // CommCheckPkt will:
    //  - Check the value of CommPkt->Major 
    //  - Ensure Pkt starts with BOP and ends with EOP
    //	- Check that PktLen does not exceed  MemLen
    //  
    if(!CommCheckPkt(CommPkt)) {
	Result = FALSE;
	DPRINT(4, "++ CommCheckPkt failed. [Invalid CommPkt]\n"); 
	goto exit;
    }

    //
    // At this point we have checked the basic COMM_PACKET structure. Now we 
    // need to check CommPkt->Pkt.
    // 
    //
    // Set CommPkt->UpkLen to zero so we read from the start of the Pkt.
    //
    CommPkt->UpkLen = 0;

    // 
    // Loop through the data elements of the Pkt.
    // We have already assured above that the last element is an EOP.
    // It is possible that there is another EOP item before that. We don't
    // need to check past that item since nobody should read any of the 
    // data beyond it.
    //
    while (CommGetNextElement(CommPkt, &CommType, &CommTypeSize) &&
	   (CommType != COMM_EOP)) {
    
	//
	// Uplevel members could send us comm packet data elements we 
	// don't handle.
	//
	if ((CommType >= COMM_MAX) || (CommType == COMM_NONE)) {

	    if((CommTypeSize > CommPkt->PktLen) ||
	       (CommPkt->UpkLen > (CommPkt->PktLen - CommTypeSize))) {
		
		//
		// This item is claiming to be larger than the remaining
		// space in the pkt. 
		//

		Result = FALSE;
		DPRINT3(4, 
			"++ CommTypeSize too large. CommType = %d, CommTypeSize = %d, UpkLen = %d [Invalid CommPkt]\n",
			CommType, CommTypeSize, CommPkt->UpkLen);
		goto exit;
	    }

	    CommPkt->UpkLen += CommTypeSize;
	    
	    continue;
	}

	//
	// Table index MUST match table CommType Field or table is 
	// fouled up. This is not an error in the Pkt, rather a problem
	// with our internal structs so we assert.
	//
	FRS_ASSERT(CommType == CommPacketTable[CommType].CommType);

	//
	// This is the size we expect for this type.
	// COMM_SZ_NULL indicates that the size is not predetermined.
	//
	DataSize = CommPacketTable[CommType].DataSize;
	DecodeType = CommPacketTable[CommType].DecodeType;


	if((DataSize != COMM_SZ_NULL) && (CommTypeSize != DataSize)) {
	    DPRINT2(4, "++ Invalid packet element size.  CommType = %d,  DataSize = %d [Invalid CommPkt]\n",
		    CommType, CommTypeSize);
	    Result = FALSE;
	    goto exit;
	}

	//
	// If we made it this far then we know the type and size are 
	// consistent. Now we need to check the internals of this element.
	// 
	 
	//
	// Only certain types have internal structure to check. Everything
	// else is defined completely by the type and size.
	//
	switch(DecodeType) {
	    case COMM_DECODE_GNAME:
		// GUID_SIZE, GUID, STRING_SIZE, STRING

		// GUID_SIZE
		if(!CommFetchMemory(CommPkt, (PUCHAR)&Size, sizeof(ULONG))){
		    DPRINT3(4, "++ COMM_DECODE_GNAME: Cannot read GuidSize.  CommType = %d,  CommTypeSize = %d UpkLen = %d [Invalid CommPkt]\n",
			    CommType, CommTypeSize, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}
		
		// Must really be size of a guid
		if(Size != sizeof(GUID)) {
		    DPRINT2(4, "++ COMM_DECODE_GNAME: GuidSize (%d) does not match sizeof GUID (%d) [Invalid CommPkt]\n", Size, sizeof(GUID));
		    Result = FALSE;
		    goto exit;
		}
		
		//
		// Don't need to check the guid data, just increment
		// the unpacked length.
		//

		if((Size > CommPkt->PktLen) ||
		   (CommPkt->UpkLen > (CommPkt->PktLen - Size))) {
		    //
		    // This item is claiming to be larger than the remaining
		    // space in the pkt. 
		    //

		    DPRINT3(4, 
			    "++ COMM_DECODE_GNAME GuidSize too large. CommType = %d, GuidSize = %d, UpkLen = %d [Invalid CommPkt]\n",
			    CommType, Size, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		CommPkt->UpkLen += Size;


		// STRING_SIZE
		if(!CommFetchMemory(CommPkt, (PUCHAR)&Size, sizeof(ULONG))){
		    DPRINT3(4, "++ COMM_DECODE_GNAME: Cannot read StringSize.  CommType = %d,  CommTypeSize = %d UpkLen = %d [Invalid CommPkt]\n",
			    CommType, CommTypeSize, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}


		// check for a valid size
		if((Size > CommPkt->PktLen) ||
		   (CommPkt->UpkLen > (CommPkt->PktLen - Size))) {
		    //
		    // This item is claiming to be larger than the remaining
		    // space in the pkt. 
		    //

		    DPRINT3(4, 
			    "++ COMM_DECODE_GNAME StringSize too large. CommType = %d, StringSize = %d, UpkLen = %d [Invalid CommPkt]\n",
			    CommType, Size, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		CommPkt->UpkLen += Size;

		// 
		// We're all good.
		// On to the next element.
		//
		break;
	    case COMM_DECODE_BLOB:
		// BLOB_SIZE, BLOB

		// BLOB_SIZE
		if(!CommFetchMemory(CommPkt, (PUCHAR)&Size, sizeof(ULONG))){
		    DPRINT3(4, "++ COMM_DECODE_BLOB: Cannot read BlobSize.  CommType = %d,  CommTypeSize = %d UpkLen = %d [Invalid CommPkt]\n",
			    CommType, CommTypeSize, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		// check for a valid size
		if((Size > CommPkt->PktLen) ||
		   (CommPkt->UpkLen > (CommPkt->PktLen - Size))) {
		    //
		    // This item is claiming to be larger than the remaining
		    // space in the pkt. 
		    //

		    DPRINT3(4, 
			    "++ COMM_DECODE_BLOB BlobSize too large. CommType = %d, BlobSize = %d, UpkLen = %d [Invalid CommPkt]\n",
			    CommType, Size, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		CommPkt->UpkLen += Size;

		// 
		// We're all good.
		// On to the next element.
		//

		break;
	    case COMM_DECODE_VAR_LEN_BLOB:
		// BLOB_SIZE, REST_OF_BLOB
		// the difference between this and a regular blob is that here
		// the size is part of the total blob.

		// BLOB_SIZE
		if(!CommFetchMemory(CommPkt, (PUCHAR)&Size, sizeof(ULONG))){
		    DPRINT3(4, "++ COMM_DECODE_VAR_LEN_BLOB: Cannot read BlobSize.  CommType = %d,  CommTypeSize = %d UpkLen = %d [Invalid CommPkt]\n",
			    CommType, CommTypeSize, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		//
		// Since the blob size includes the space used to store the 
		// size itself, it must be at least as big as a ULONG.
		//
		if(Size < sizeof(ULONG)) {
		    DPRINT1(4, "++ COMM_DECODE_VAR_LEN_BLOB: BlobSize (%d) too small. [Invalid CommPkt]\n", Size);
		    Result = FALSE;
		    goto exit;
		}
		//
		// Size includes the space taken up by BLOB_SIZE
		// We already successfully read that, so lets just check that
		// the rest of it fits.
		//
		Size -= sizeof(ULONG);

		// check for a valid size
		if((Size > CommPkt->PktLen) ||
		   (CommPkt->UpkLen > (CommPkt->PktLen - Size))) {
		    //
		    // This item is claiming to be larger than the remaining
		    // space in the pkt. 
		    //

		    DPRINT3(4, 
			    "++ COMM_DECODE_VAR_LEN_BLOB BlobSize too large. CommType = %d, BlobSize = %d, UpkLen = %d [Invalid CommPkt]\n",
			    CommType, Size, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		CommPkt->UpkLen += Size;

		// 
		// We're all good.
		// On to the next element.
		//

		break;
	    case COMM_DECODE_NONE:
		// We really shouldn't be getting this, but newer versions 
		// might have a reason for sending it, so fall through to 
		// the default case.
	    default:
		// Everything else is just data with no special decoding

		if(CommPkt->UpkLen > (CommPkt->PktLen - CommTypeSize)) {
		    //
		    // This item is claiming to be larger than the remaining
		    // space in the pkt. 
		    //

		    DPRINT4(4, 
			    "++ CommDecodeType = %d, Size too large. CommType = %d, CommTypeSize = %d, UpkLen = %d [Invalid CommPkt]\n",
			    DecodeType, CommType, CommTypeSize, CommPkt->UpkLen);
		    Result = FALSE;
		    goto exit;
		}

		CommPkt->UpkLen += CommTypeSize;

		break;
	}

    }

    if(CommType != COMM_EOP){
	//
	// We ended on something other than EOP
	//

	DPRINT1(4, "++ CommPkt does not end with EOP. Ends with CommType = %d [Invalid CommPkt]\n", CommType);
	Result = FALSE;
	goto exit;
    }

    Result = TRUE;


exit:

    //
    // Set the UpkLen back to the original value.
    //
    CommPkt->UpkLen = OriginalUpkLen;

    return Result;
}


BOOL
CommCheckPkt(
    IN PCOMM_PACKET CommPkt
    )
/*++
Routine Description:
    Check the packet for consistency

Arguments:
    CommPkt

Return Value:
    TRUE      - consistent
    Otherwise - Assert failure
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommCheckPkt:"
    ULONG       Len;
    ULONG       Data;
    PUCHAR      Pfirst;
    PUCHAR      Pnext;
    PUCHAR      Pend;
    USHORT      CommType;

    if (!CommPkt) {
        return FALSE;
    }

    //
    // Check major. Mismatched majors cannot be handled.
    //
    if (CommPkt->Major != NtFrsMajor) {
        DPRINT2(3, "WARN - RpcCommPkt: MAJOR MISMATCH %d major does not match %d; ignoring\n",
                CommPkt->Major, NtFrsMajor);
        return FALSE;
    }
    //
    // Check minor. This service can process packets with mismatched
    // minors, although some functionality may be lost.
    //
    if (CommPkt->Minor != NtFrsCommMinor) {
        DPRINT2(5, "RpcCommPkt: MINOR MISMATCH %d minor does not match %d\n",
                CommPkt->Minor, NtFrsCommMinor);
    }

    //
    // Compare the length of the packet with its memory allocation
    //
    if (CommPkt->PktLen > CommPkt->MemLen) {
        DPRINT2(4, "RpcCommPkt: Packet size (%d) > Alloced Memory (%d)\n",
                CommPkt->PktLen, CommPkt->MemLen);
        return FALSE;
    }
    //
    // Must have at least a beginning-of-packet and end-of-packet field
    //
    if (CommPkt->PktLen < MIN_COMM_PACKET_SIZE) {
        DPRINT2(4, "RpcCommPkt: Packet size (%d) < Minimum size (%d)\n",
                CommPkt->PktLen, MIN_COMM_PACKET_SIZE);
        return FALSE;
    }

    //
    // packets begin with a beginning-of-packet
    //
    Pfirst = CommPkt->Pkt;
    Pnext = CommGetHdr(Pfirst, &CommType, &Len);

    if (CommType != COMM_BOP || Len != sizeof(ULONG)) {
        return FALSE;
    }

    CopyMemory(&Data, Pnext, sizeof(ULONG));
    if (Data != 0) {
        return FALSE;
    }

    //
    // packets end with an end-of-packet
    //
    Pend = Pfirst + CommPkt->PktLen;
    if (Pend <= Pfirst) {
        return FALSE;
    }
    Pnext = ((Pend - sizeof(USHORT)) - sizeof(ULONG)) - sizeof(ULONG);
    Pnext = CommGetHdr(Pnext, &CommType, &Len);

    if (CommType != COMM_EOP || Len != sizeof(ULONG)) {
        return FALSE;
    }

    CopyMemory(&Data, Pnext, sizeof(ULONG));

    if (Data != COMM_NULL_DATA) {
        return FALSE;
    }

    return TRUE;
}


VOID
CommDumpCommPkt(
    IN PCOMM_PACKET CommPkt,
    IN DWORD        NumDump
    )
/*++
Routine Description:
    Dump some of the comm packet

Arguments:
    CommPkt
    NumDump

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommDumpCommPkt:"
    ULONG       Len;
    PUCHAR      Pnext;
    USHORT      CommType;
    DWORD       i;

    DPRINT1(0, "%x:\n", CommPkt);
    DPRINT1(0, "\tMajor: %d\n", CommPkt->Major);
    DPRINT1(0, "\tMinor: %d\n", CommPkt->Minor);
    DPRINT1(0, "\tMemLen: %d\n", CommPkt->MemLen);
    DPRINT1(0, "\tPktLen: %d\n", CommPkt->PktLen);
    DPRINT1(0, "\tPkt: 0x%x\n", CommPkt->Pkt);

    //
    // packets begin with a beginning-of-packet
    //
    Pnext = CommPkt->Pkt;
    for (i = 0; i < NumDump; ++i) {
        Pnext = CommGetHdr(Pnext, &CommType, &Len);
        DPRINT4(0, "Dumping %d for %x: %d %d\n", i, CommPkt, CommType, Len);
        Pnext += Len;
    }
}


VOID
CommPackULong(
    IN PCOMM_PACKET CommPkt,
    IN COMM_TYPE    Type,
    IN ULONG        Data
    )
/*++
Routine Description:
    Copy a header and a ulong into the comm packet.

Arguments:
    CommPkt
    Type
    Data

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommPackULong:"
    ULONG   Len         = sizeof(ULONG);
    USHORT  CommType    = (USHORT)Type;

    CommCopyMemory(CommPkt, (PUCHAR)&CommType, sizeof(USHORT));
    CommCopyMemory(CommPkt, (PUCHAR)&Len,      sizeof(ULONG));
    CommCopyMemory(CommPkt, (PUCHAR)&Data,     sizeof(ULONG));
}



PCOMM_PACKET
CommStartCommPkt(
    IN PWCHAR       Name
    )
/*++
Routine Description:
    Allocate a comm packet.

Arguments:
    Name

Return Value:
    Address of a comm packet.
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommStartCommPkt:"
    ULONG           Size;
    PCOMM_PACKET    CommPkt;

    //
    // We can create a comm packet in a file or in memory
    //
    CommPkt = FrsAlloc(sizeof(COMM_PACKET));
    Size = COMM_MEM_SIZE;
    CommPkt->Pkt = FrsAlloc(Size);
    CommPkt->MemLen = Size;
    CommPkt->Major = NtFrsMajor;
    CommPkt->Minor = NtFrsCommMinor;

    //
    // Pack the beginning-of-packet
    //
    CommPackULong(CommPkt, COMM_BOP, 0);
    return CommPkt;
}

BOOL
CommUnpackBlob(
    IN PCOMM_PACKET CommPkt,
    OUT ULONG       *OutBlobSize,
    OUT PVOID       *OutBlob
    )
/*++
Routine Description:
    Unpack a blob (length + data)

Arguments:
    CommPkt
    OutBlobSize - size of blob from comm packet
    OutBlob     - data from comm packet

Return Value:
    TRUE  - Blob retrieved from comm packet
    FALSE - Blob was not retrieved from comm packet; bad comm packet
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommUnpackBlob:"
    ULONG   BlobSize;

    //
    // Initialize return params
    //
    *OutBlob = NULL;

    //
    // Unpack the length of the blob
    //
    if (!CommFetchMemory(CommPkt, (PUCHAR)OutBlobSize, sizeof(ULONG))) {
        return FALSE;
    }
    BlobSize = *OutBlobSize;

    //
    // Empty blob, return NULL
    //
    if (BlobSize == 0) {
        return TRUE;
    }

    //
    // Allocate memory for the blob
    //
    *OutBlob = FrsAlloc(BlobSize);

    //
    // Unpack the blob
    //
    return CommFetchMemory(CommPkt, (PUCHAR)*OutBlob, BlobSize);
}


BOOL
CommUnpackVariableLengthBlob(
    IN PCOMM_PACKET CommPkt,
    OUT ULONG       *OutBlobSize,
    OUT PVOID       *OutBlob
    )
/*++
Routine Description:
    Unpack a blob (length + data)

Arguments:
    CommPkt
    OutBlobSize - size of blob from comm packet
    OutBlob     - data from comm packet

Return Value:
    TRUE  - Blob retrieved from comm packet
    FALSE - Blob was not retrieved from comm packet; bad comm packet
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommUnpackVariableLengthBlob:"
    ULONG   BlobSize;

    //
    // Initialize return params
    //
    *OutBlob = NULL;

    //
    // Unpack the length of the blob
    //

    if ((CommPkt->UpkLen + sizeof(ULONG)) > CommPkt->PktLen) {
        return FALSE;
    }


    *OutBlobSize =  *((ULONG UNALIGNED *)(CommPkt->Pkt + CommPkt->UpkLen));
    BlobSize = *OutBlobSize;

    //
    // Empty blob, return NULL
    //
    if (BlobSize == 0) {
        return TRUE;
    }

    //
    // Allocate memory for the blob
    //
    *OutBlob = FrsAlloc(BlobSize);

    //
    // Unpack the blob
    //
    return CommFetchMemory(CommPkt, (PUCHAR)*OutBlob, BlobSize);
}


BOOL
CommUnpackGName(
    IN PCOMM_PACKET CommPkt,
    OUT PGNAME      *OutGName
    )
/*++
Routine Description:
    Unpack the guid and wide char string that make up a gstring

Arguments:
    CommPkt
    OutGName    - From comm packet

Return Value:
    TRUE  - GName fetched from comm packet successfully
    FALSE - GName was not fetched from comm packet; bad comm packet
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommUnpackGName:"
    ULONG   BlobSize;
    PGNAME  GName;

    //
    // Allocate a gstring (caller cleans up on error)
    //
    *OutGName = GName = FrsAlloc(sizeof(GNAME));

    if (!CommUnpackBlob(CommPkt, &BlobSize, &GName->Guid) ||
        BlobSize != sizeof(GUID)) {
        return FALSE;
    }

    if (!CommUnpackBlob(CommPkt, &BlobSize, &GName->Name) ||
        GName->Name[(BlobSize / sizeof(WCHAR)) - 1] != L'\0') {
        return FALSE;
    }

    return TRUE;
}




BOOL
CommGetNextElement(
    IN PCOMM_PACKET CommPkt,
    OUT COMM_TYPE   *CommType,
    OUT ULONG       *CommTypeSize
    )
/*++
Routine Description:
    Advance to the next field in the comm packet

Arguments:
    CommPkt
    CommType     - type of packed field
    CommTypeSize - size of packed field (excluding type and size)

Return Value:
    TRUE  - CommType and CommTypeSize were unpacked
    FALSE - Could not unpack; bad comm packet
--*/
{
#undef DEBSUB
#define  DEBSUB  "CommGetNextElement:"
    USHORT  Ushort;

    //
    // Find the type and length of this entry
    //
    if (CommFetchMemory(CommPkt, (PUCHAR)&Ushort, sizeof(USHORT)) &&
        CommFetchMemory(CommPkt, (PUCHAR)CommTypeSize, sizeof(ULONG))) {
        *CommType = Ushort;
        return TRUE;
    }
    return FALSE;
}


VOID
CommInsertDataElement(
    IN PCOMM_PACKET CommPkt,
    IN COMM_TYPE    CommType,
    IN PVOID        CommData,
    IN ULONG        CommDataLen
)
/*++
Routine Description:
    Insert the data supplied using the CommType specific format into the
    Comm packet.

Arguments:
    CommPkt   - The Comm packet structure.
    CommType  - The data type for this element.
    CommData  - The address of the data.
    CommDataLen - The size for var len elements.

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "CommInsertDataElement:"

    ULONG   Len;
    PGNAME  GName;
    ULONG   LenGuid;
    ULONG   LenName;
    ULONG   DataSize;
    ULONG   DecodeType;
    PCHAR   CommTag;

    if (CommData == NULL) {
        return;
    }

    FRS_ASSERT((CommType < COMM_MAX) && (CommType != COMM_NONE));

    //
    // Table index MUST match table CommType Field or table is fouled up.
    //
    FRS_ASSERT(CommType == CommPacketTable[CommType].CommType);

    //
    // Length check from table for fixed length fields.
    //
    //DataSize = CommPacketTable[CommType].DataSize;
    //FRS_ASSERT((DataSize == COMM_SZ_NULL) || (CommDataLen == DataSize));

    //
    // Insert the data using the data type encoding.
    //
    DecodeType = CommPacketTable[CommType].DecodeType;
    CommTag = CommPacketTable[CommType].CommTag;

    switch (DecodeType) {

    //
    // Insert a ULONG size piece of data.
    //
    case COMM_DECODE_ULONG:
    case COMM_DECODE_ULONG_TO_USHORT:

        Len = sizeof(ULONG);
        DPRINT2(5, ":SR: Dec_long: type: %s, len: %d\n", CommTag, Len);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType, sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,      sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)CommData,  sizeof(ULONG));
        break;

    //
    // Insert a Guid and Name string (GNAME).
    //
    case COMM_DECODE_GNAME:

        GName = (PGNAME)CommData;
        LenGuid = sizeof(GUID);
        LenName = (wcslen(GName->Name) + 1) * sizeof(WCHAR);
        Len = LenGuid + LenName + (2 * sizeof(ULONG));
        DPRINT3(5, ":SR: Dec_gname: type: %s, len: %d - %ws\n", CommTag, Len, GName->Name);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType,    sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,         sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)&LenGuid,     sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)GName->Guid,  LenGuid);
        CommCopyMemory(CommPkt, (PUCHAR)&LenName,     sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)GName->Name,  LenName);
        break;

    //
    // Insert a ULONGLONG.
    //
    case COMM_DECODE_ULONGLONG:

        Len = sizeof(ULONGLONG);
        DPRINT2(5, ":SR: Dec_longlong: type: %s, len: %d\n", CommTag, Len);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType, sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,      sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)CommData,  sizeof(ULONGLONG));
        break;

    //
    // Insert a Guid.
    //
    case COMM_DECODE_GUID:
        Len = sizeof(GUID);
        DPRINT2(5, ":SR: Dec_Guid: type: %s, len: %d\n", CommTag, Len);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType, sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,      sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)CommData,  sizeof(GUID));
        break;

    case COMM_DECODE_VVECTOR:
    //
    // Version Vector data gets inserted into Comm packet as blobs.
    //
        NOTHING;
        /* FALL THRU INTENDED */

    //
    // Insert a variable length BLOB.  The problem with blobs as currently
    // shipped in win2k is that the code on the unpack side checks for a
    // match on a constant length based on the COMM Data Type.  This means
    // that a var len datatype like CHANGE_ORDER_EXTENSION can't change because
    // the 40 byte size is wired into the code of down level members.  Sigh.
    //
    case COMM_DECODE_BLOB:

        Len = CommDataLen + sizeof(ULONG);
        DPRINT2(5, ":SR: Dec_blob: type: %s, len: %d\n", CommTag, Len);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType,    sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,         sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)&CommDataLen, sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)CommData,     CommDataLen);
        break;

    //
    // Insert a true variable length data struct that is extensible.
    // The actual length comes from the first DWORD of the data.
    //
    case COMM_DECODE_VAR_LEN_BLOB:

        Len = *(PULONG)CommData;
        DPRINT2(5, ":SR: Dec_var_len_blob: type: %s, len: %d\n", CommTag, Len);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType,    sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,         sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)CommData,     Len);
        break;

    //
    // The CO contains four pointers occupying 16 bytes on 32 bit architectures and
    // 32 bytes on 64 bit architectures (PART2).  When the CO is sent in a comm packet
    // the contents of these pointers are irrelevant so in comm packets these
    // ptrs are always sent as 16 bytes of zeros, regardless of architecture.
    // Note - In 32 bit Win2k this was sent as a BLOB so it matches BLOB format.
    //
    case COMM_DECODE_REMOTE_CO:

        Len = COMM_SZ_COC;
        CommDataLen = Len - sizeof(ULONG);
        DPRINT2(4, ":SR: Dec_remote_co: type: %s, len: %d\n", CommTag, Len);
        CommCopyMemory(CommPkt, (PUCHAR)&CommType,    sizeof(USHORT));
        CommCopyMemory(CommPkt, (PUCHAR)&Len,         sizeof(ULONG));
        CommCopyMemory(CommPkt, (PUCHAR)&CommDataLen, sizeof(ULONG));

        CommCopyMemory(CommPkt, (PUCHAR)CommData, sizeof(CHANGE_ORDER_COMMAND));

        //CommCopyMemory(CommPkt, ((PUCHAR)CommData)+CO_PART1_OFFSET, CO_PART1_SIZE);
        //CommCopyMemory(CommPkt,                               NULL, CO_PART2_SIZE);
        //CommCopyMemory(CommPkt, ((PUCHAR)CommData)+CO_PART3_OFFSET, CO_PART3_SIZE);
        break;

    default:
        //
        // Table must be fouled up.
        //
        FRS_ASSERT((DecodeType > COMM_DECODE_NONE) && (DecodeType < COMM_DECODE_MAX));

        break;
    }


    return;
}


PCOMM_PACKET
CommBuildCommPkt(
    IN PREPLICA                 Replica,
    IN PCXTION                  Cxtion,
    IN ULONG                    Command,
    IN PGEN_TABLE               VVector,
    IN PCOMMAND_PACKET          Cmd,
    IN PCHANGE_ORDER_COMMAND    Coc
    )
/*++
Routine Description:
    Generate a comm packet with the info needed to execute the
    command on the remote machine identified by Cxtion.

Arguments:
    Replica - Sender
    Cxtion  - identifies the remote machine
    Command - command to execute on the remote machine
    VVector - some commands require the version vector
    Cmd     - original command packet
    Coc     - change order command
    RemoteGVsn  - guid/vsn pair

Return Value:
    Address of a comm packet.
--*/
{
#undef DEBSUB
#define DEBSUB  "CommBuildCommPkt:"

    ULONGLONG       FileTime;
    GNAME           GName;
    PVOID           Key;
    PCOMM_PACKET    CommPkt;
    PGVSN           GVsn;
    PGEN_ENTRY      Entry;

    //
    // Allocate and initialize a comm packet
    //
    CommPkt = CommStartCommPkt(NULL);
    CommPkt->CsId = CS_RS;

    CommInsertDataElement(CommPkt, COMM_COMMAND,        &Command, 0);
    CommInsertDataElement(CommPkt, COMM_TO,             Cxtion->Partner, 0);
    CommInsertDataElement(CommPkt, COMM_FROM,           Replica->MemberName, 0);

    GName.Guid = Cxtion->Partner->Guid;
    GName.Name = Replica->ReplicaName->Name;
    CommInsertDataElement(CommPkt, COMM_REPLICA,        &GName, 0);

    CommInsertDataElement(CommPkt, COMM_CXTION,         Cxtion->Name, 0);
    CommInsertDataElement(CommPkt, COMM_JOIN_GUID,      &Cxtion->JoinGuid, sizeof(GUID));
    CommInsertDataElement(CommPkt, COMM_LAST_JOIN_TIME, &Cxtion->LastJoinTime, 0);

    //
    // Version vector (if supplied)
    //
    //
    // The caller is building a comm packet for join operation,
    // automatically include the current time and the originator guid.
    //
    if (VVector) {
        Key = NULL;
        while (GVsn = GTabNextDatum(VVector, &Key)) {
            CommInsertDataElement(CommPkt, COMM_VVECTOR, GVsn, sizeof(GVSN));
        }
        GetSystemTimeAsFileTime((FILETIME *)&FileTime);
        CommInsertDataElement(CommPkt, COMM_JOIN_TIME, &FileTime, sizeof(ULONGLONG));
        DPRINT1(4, ":X: Comm join time is %08x %08x\n", PRINTQUAD(FileTime));
        CommInsertDataElement(CommPkt, COMM_REPLICA_VERSION_GUID,
                             &Replica->ReplicaVersionGuid, sizeof(GUID));
        //
        // Insert the list of Guids for compression algorithms that we understand.
        //

        GTabLockTable(CompressionTable);
        Key = NULL;
        while (Entry = GTabNextEntryNoLock(CompressionTable, &Key)) {
            CommInsertDataElement(CommPkt, COMM_COMPRESSION_GUID, Entry->Key1, 0);
        }
        GTabUnLockTable(CompressionTable);

    }

    if (Cmd) {
        CommInsertDataElement(CommPkt, COMM_BLOCK,        RsBlock(Cmd), (ULONG)RsBlockSize(Cmd));
        CommInsertDataElement(CommPkt, COMM_BLOCK_SIZE,  &RsBlockSize(Cmd), 0);
        CommInsertDataElement(CommPkt, COMM_FILE_SIZE,   &RsFileSize(Cmd).QuadPart, 0);
        CommInsertDataElement(CommPkt, COMM_FILE_OFFSET, &RsFileOffset(Cmd).QuadPart, 0);
        CommInsertDataElement(CommPkt, COMM_GVSN,         RsGVsn(Cmd), sizeof(GVSN));
        CommInsertDataElement(CommPkt, COMM_CO_GUID,      RsCoGuid(Cmd), sizeof(GUID));
        CommInsertDataElement(CommPkt, COMM_CO_SEQUENCE_NUMBER, &RsCoSn(Cmd), 0);
        CommInsertDataElement(CommPkt, COMM_MD5_DIGEST,   RsMd5Digest(Cmd), MD5DIGESTLEN);
    }

    //
    // Change Order Command
    //
    if (Coc) {
        CommInsertDataElement(CommPkt, COMM_REMOTE_CO, Coc, 0);

        if (Cxtion->PartnerMinor <= NTFRS_COMM_MINOR_4) {
            //
            // Convert the CHANGE_ORDER_RECORD_EXTENSION struct to a
            // CO_RECORD_EXTENSION_WIN2K struct that downlevel members will
            // understand.  This is necessary because downlevel members want to
            // check the size of the comm data element which makes it
            // impossible to change the size of the CO_RECORD_EXTENSION_WIN2K
            // structure.  So the CHANGE_ORDER_RECORD_EXTENSION data element
            // was added for post win2k members that is extensible.  see
            // comments in schema.h.  see additional comments in frs.h re:
            // NTFRS_COMM_MINOR rev levels.
            //
            if (Coc->Extension->Major != CO_RECORD_EXTENSION_VERSION_WIN2K) {
                PCO_RECORD_EXTENSION_WIN2K   CocExtW2K;

                CocExtW2K = DbsDataConvertCocExtensionToWin2K(Coc->Extension);
                CommInsertDataElement(CommPkt, COMM_CO_EXT_WIN2K, CocExtW2K,
                                      sizeof(CO_RECORD_EXTENSION_WIN2K));
                FrsFree(CocExtW2K);
            } else {
                CommInsertDataElement(CommPkt, COMM_CO_EXT_WIN2K, Coc->Extension,
                                      sizeof(CO_RECORD_EXTENSION_WIN2K));
            }
        } else {
            DWORD OldCount;
            PDATA_EXTENSION_RETRY_TIMEOUT CoCmdRetryTimeout;

            //
            // For post win2k level members the CO extension info should be sent
            // as follows since the length comes from the first dword of the data.
            //
            CoCmdRetryTimeout = DbsDataExtensionFind(Coc->Extension, DataExtend_Retry_Timeout);

            //
            // Zero out the count so that we start fresh on the next machine.
            // But we don't want to overwrite the current count on this machine!
            //
            if(CoCmdRetryTimeout != NULL) {
                OldCount = CoCmdRetryTimeout->Count;
                CoCmdRetryTimeout->Count = 0;
            }

            CommInsertDataElement(CommPkt, COMM_CO_EXTENSION_2, Coc->Extension, 0);

            if(CoCmdRetryTimeout != NULL) {
                 CoCmdRetryTimeout->Count = OldCount;
            }
        }
    }

    //
    // Terminate the packet with EOP Ulong.
    //
    CommPackULong(CommPkt, COMM_EOP, COMM_NULL_DATA);

    return CommPkt;
}



PCOMMAND_PACKET
CommPktToCmd(
    IN PCOMM_PACKET CommPkt
    )
/*++
Routine Description:
    Unpack the data in a Comm packet and store it into a command struct.

Arguments:
    CommPkt

Return Value:
    Address of a command packet or NULL if unpack failed.
--*/
{
#undef DEBSUB
#define DEBSUB  "CommPktToCmd:"
    GUID            *pTempGuid;
    PCOMMAND_PACKET Cmd = NULL;
    ULONG           BlobSize;
    PVOID           Blob;
    ULONG           CommTypeSize;
    COMM_TYPE       CommType;
    ULONG           DataSize;
    ULONG           DecodeType;
    ULONG           NativeOffset;
    PUCHAR          DataDest;
    ULONG           TempUlong;
    BOOL            b;
    GNAME           GName;
    PCHAR           CommTag;
    PUCHAR          CommData;
    PGEN_TABLE      GTable;

    //
    // Create the command packet
    //
    Cmd = FrsAllocCommand(&ReplicaCmdServer.Queue, CMD_UNKNOWN);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Scan the comm packet from the beginning
    //
    CommPkt->UpkLen = 0;
    b = TRUE;
    while (CommGetNextElement(CommPkt, &CommType, &CommTypeSize) &&
           CommType != COMM_EOP) {

        //
        // Uplevel members could send us comm packet data elements we don't handle.
        //
        if ((CommType >= COMM_MAX) || (CommType == COMM_NONE)) {
            DPRINT2(0, "++ WARN - Skipping invalid comm packet element type.  CommType = %d, From %ws\n",
                    CommType, RsFrom(Cmd) ? RsFrom(Cmd)->Name : L"<unknown>");
            CommPkt->UpkLen += CommTypeSize;
            b = !(CommPkt->UpkLen > CommPkt->PktLen || CommTypeSize > CommPkt->PktLen);
            goto NEXT_ELEMENT;
        }

        //
        // Table index MUST match table CommType Field or table is fouled up.
        //
        FRS_ASSERT(CommType == CommPacketTable[CommType].CommType);

        DataSize = CommPacketTable[CommType].DataSize;

        if ((DataSize != COMM_SZ_NULL) && (CommTypeSize != DataSize)) {
            DPRINT3(0, "++ WARN - Invalid comm packet size.  CommType = %d,  DataSize = %d, From %ws\n",
                    CommType, CommTypeSize,
                    RsFrom(Cmd) ? RsFrom(Cmd)->Name : L"<unknown>");
            goto CLEANUP_ON_ERROR;
        }

        //
        // Calc the data offset in the Cmd struct to store the data.
        //
        NativeOffset = CommPacketTable[CommType].NativeOffset;
        if (NativeOffset == RsOffsetSkip) {
            CommPkt->UpkLen += CommTypeSize;
            b = !(CommPkt->UpkLen > CommPkt->PktLen || CommTypeSize > CommPkt->PktLen);
            goto NEXT_ELEMENT;
        }
        DataDest = (PUCHAR) Cmd + NativeOffset;


        //
        // Decode the data element and store it in Cmd at the NativeOffset.
        //
        DecodeType = CommPacketTable[CommType].DecodeType;
        CommTag = CommPacketTable[CommType].CommTag;

        //DPRINT6(5, ":SR: CommType: %s,  Size: %d, Cmd offset: %d, data dest: %08x, Pkt->UpkLen = %d, Pkt->PktLen = %d\n",
        //        CommTag, CommTypeSize, NativeOffset,
        //        DataDest, CommPkt->UpkLen, CommPkt->PktLen);

        switch (DecodeType) {

        case COMM_DECODE_ULONG:

            b = CommFetchMemory(CommPkt, DataDest, sizeof(ULONG));

            DPRINT2(5, ":SR: rcv Dec_long: %s  data: %d\n", CommTag, *(PULONG)DataDest);
            break;

        case COMM_DECODE_ULONG_TO_USHORT:

            b = CommFetchMemory(CommPkt, (PUCHAR)&TempUlong, sizeof(ULONG));
            * ((PUSHORT) DataDest) = (USHORT)TempUlong;
            DPRINT2(5, ":SR: rcv Dec_ulong_to_ushort: %s  data: %d\n", CommTag, TempUlong);
            break;

        case COMM_DECODE_GNAME:


            *(PVOID *)DataDest = FrsFreeGName(*(PVOID *)DataDest);
            b = CommUnpackGName(CommPkt, (PGNAME *) DataDest);
            GName.Guid = (*(PGNAME *)DataDest)->Guid;
            GName.Name = (*(PGNAME *)DataDest)->Name;
            DPRINT2(5, ":SR: rcv Dec_Gname: %s  name: %ws\n", CommTag, GName.Name);
            break;

        case COMM_DECODE_BLOB:

            *(PVOID *)DataDest = FrsFree(*(PVOID *)DataDest);
            b = CommUnpackBlob(CommPkt, &BlobSize, (PVOID *) DataDest);
            DPRINT2(5, ":SR: rcv Dec_blob: BlobSize: %08x data: %08x\n", BlobSize, *(PULONG)DataDest);
            break;

        case COMM_DECODE_VAR_LEN_BLOB:

            *(PVOID *)DataDest = FrsFree(*(PVOID *)DataDest);
            b = CommUnpackVariableLengthBlob(CommPkt, &BlobSize, (PVOID *) DataDest);
            DPRINT2(5, ":SR: rcv Dec_blob: BlobSize: %08x data: %08x\n", BlobSize, *(PULONG)DataDest);
            break;

        case COMM_DECODE_ULONGLONG:

            b = CommFetchMemory(CommPkt, DataDest, sizeof(ULONGLONG));
            DPRINT2(5, ":SR: rcv Dec_long_long: %s  data: %08x %08x\n", CommTag,
                    PRINTQUAD(*(PULONGLONG)DataDest));
            break;


        //
        // Version Vector data gets unpacked and inserted into Table.
        //
        case COMM_DECODE_VVECTOR:
            GTable = *(PGEN_TABLE *)(DataDest);
            if (GTable == NULL) {
                GTable = GTabAllocTable();
                *(PGEN_TABLE *)(DataDest) = GTable;
            }

            b = CommUnpackBlob(CommPkt, &BlobSize, &Blob);
            DPRINT2(5, ":SR: rcv Dec_VV: %s  bloblen: %d\n", CommTag, BlobSize);
            if (b) {
                VVInsertOutbound(GTable, Blob);
            }
            break;

        //
        // Compression Guid data gets unpacked and inserted into table.
        //
        case COMM_DECODE_GUID:
            if (CommType == COMM_COMPRESSION_GUID) {
                GTable = *(PGEN_TABLE *)(DataDest);
                if (GTable == NULL) {
                    GTable = GTabAllocTable();
                    *(PGEN_TABLE *)(DataDest) = GTable;
                }

                pTempGuid = FrsAlloc(sizeof(GUID));

                b = CommFetchMemory(CommPkt, (PUCHAR)pTempGuid, sizeof(GUID));
                DPRINT2(5, ":SR: rcv Comp_Guid: %s  bloblen: %d\n", CommTag, BlobSize);
                if (b) {
                    GTabInsertEntry(GTable, NULL, pTempGuid, NULL);
                }

            } else {
                //
                // Else the guid gets stashed in the data dest.
                //
                b = CommFetchMemory(CommPkt, DataDest, sizeof(GUID));
                DPRINT1(5, ":SR: rcv Guid: %s \n", CommTag);
            }
            break;

        //
        // The CO contains four pointers occupying 16 bytes on 32 bit architectures
        // and 32 bytes on 64 bit architectures (PART2).  When the CO is sent
        // in a comm packet the contents of these pointers are irrelevant so in
        // comm packets these ptrs are always sent as 16 bytes of zeros,
        // regardless of architecture.
        // Note - In 32 bit Win2k this was sent as a BLOB so it matches BLOB format.
        //
        case COMM_DECODE_REMOTE_CO:

            *(PVOID *)DataDest = FrsFree(*(PVOID *)DataDest);
            //
            // Unpack the length of the CO and then unpack the CO data.
            //
            b = CommFetchMemory(CommPkt, (PUCHAR)&BlobSize, sizeof(ULONG));
            if (!b || (BlobSize == 0)) {
                break;
            }

            CommData = FrsAlloc(sizeof(CHANGE_ORDER_COMMAND));

            CommFetchMemory(CommPkt, (PUCHAR)CommData, sizeof(CHANGE_ORDER_COMMAND));

            //CommFetchMemory(CommPkt, ((PUCHAR)CommData)+CO_PART1_OFFSET, CO_PART1_SIZE);
            //CommFetchMemory(CommPkt, ((PUCHAR)CommData)+CO_PART2_OFFSET, CO_PART2_SIZE);
            //CommFetchMemory(CommPkt, ((PUCHAR)CommData)+CO_PART3_OFFSET, CO_PART3_SIZE);

            DPRINT2(4, ":SR: rcv remote_co: type: %s, len: %d\n", CommTag, BlobSize);

            *(PVOID *) DataDest = CommData;
            break;


        default:
            //
            // Decode data type from an uplevel client.  Although we should
            // not really get here because uplevel clients should only be using
            // new decode data types with new decode data elements which got
            // filtered out above.
            //
            DPRINT3(0, "++ WARN - Skipping invalid comm packet decode data type.  CommType = %d, DecodeType = %d, From %ws\n",
                    CommType, DecodeType, RsFrom(Cmd) ? RsFrom(Cmd)->Name : L"<unknown>");
            CommPkt->UpkLen += CommTypeSize;
            b = !(CommPkt->UpkLen > CommPkt->PktLen || CommTypeSize > CommPkt->PktLen);

            break;
        }

NEXT_ELEMENT:


        if (!b) {
            DPRINT4(0, ":SR: PKT ERROR -- CommType = %s,  DataSize = %d, CommPkt->UpkLen = %d, CommPkt->PktLen = %d\n",
                    CommTag, CommTypeSize, CommPkt->UpkLen, CommPkt->PktLen);
            goto CLEANUP_ON_ERROR;
        }
    }

    //
    // SUCCESS
    //
    return Cmd;


    //
    // FAILURE
    //
CLEANUP_ON_ERROR:
    if (Cmd) {
        FrsCompleteCommand(Cmd, ERROR_OPERATION_ABORTED);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsdelcs.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    frsdelcs.c

Abstract:
    This command server delays a command packet

Author:
    Billy J. Fuller 01-Jun-1997

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSDELCS:"

#include <frs.h>

//
// Struct for the Delayed Command Server
//      Contains info about the queues and the threads
//
#define DELCS_MAXTHREADS (1) // MUST BE 1; there are no locks on globals.
COMMAND_SERVER  DelCs;
HANDLE          DelCsEvent;

//
// List of delayed commands
//
LIST_ENTRY TimeoutList;


VOID
FrsDelCsInsertCmd(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Insert the new command packet into the sorted, timeout list

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelCsInsertCmd:"
    PLIST_ENTRY         Entry;
    PCOMMAND_PACKET     OldCmd;

    if (Cmd == NULL) {
        return;
    }

    //
    // Insert into empty list
    //
    if (IsListEmpty(&TimeoutList)) {
        InsertHeadList(&TimeoutList, &Cmd->ListEntry);
        return;
    }
    //
    // Insert at tail
    //
    Entry = GetListTail(&TimeoutList);
    OldCmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
    if (DsTimeout(OldCmd) <= DsTimeout(Cmd)) {
        InsertTailList(&TimeoutList, &Cmd->ListEntry);
        return;
    }
    //
    // Insert into list
    //
    for (Entry = GetListHead(&TimeoutList);
         Entry != &TimeoutList;
         Entry = GetListNext(Entry)) {
        OldCmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if (DsTimeout(Cmd) <= DsTimeout(OldCmd)) {
            InsertTailList(Entry, &Cmd->ListEntry);
            return;
        }
    }
    FRS_ASSERT(!"FrsDelCsInsertCmd failed.");
}


VOID
ProcessCmd(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Process the expired command packet

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "ProcessCmd:"
    ULONG   WStatus = ERROR_SUCCESS;

    switch (Cmd->Command) {
        //
        // Submit a command to a command server
        //
        case CMD_DELAYED_SUBMIT:
            DPRINT3(5, "Del: submit Cmd %08x DsCmd %08x DsCs %08x\n",
                    Cmd, DsCmd(Cmd), DsCs(Cmd));
            FrsSubmitCommandServer(DsCs(Cmd), DsCmd(Cmd));
            DsCmd(Cmd) = NULL;
            break;

        //
        // Submit a command to an FRS queue.
        //
        case CMD_DELAYED_QUEUE_SUBMIT:
            DPRINT2(5, "DelQueue: submit Cmd %08x DsCmd %08x\n", Cmd, DsCmd(Cmd));
            FrsSubmitCommand(DsCmd(Cmd), FALSE);
            DsCmd(Cmd) = NULL;
            break;

        //
        // UnIdle a queue and kick its command server
        //
        case CMD_DELAYED_UNIDLED:
            DPRINT2(5, "Del: unidle Cmd %08x DsQueue %08x\n", Cmd, DsQueue(Cmd));
            FrsRtlUnIdledQueue(DsQueue(Cmd));
            FrsKickCommandServer(DsCs(Cmd));
            DsQueue(Cmd) = NULL;
            break;

        //
        // Kick a command server
        //
        case CMD_DELAYED_KICK:
            DPRINT2(5, "Del: kick Cmd %08x DsCs %08x\n", Cmd, DsCs(Cmd));
            FrsKickCommandServer(DsCs(Cmd));
            break;
        //
        // Complete the command (work is done in the completion routine)
        // Command may be resubmitted to this delayed command server.
        //
        case CMD_DELAYED_COMPLETE:
            DPRINT2(5, "Del: Complete Cmd %08x DsCmd %08x\n", Cmd, DsCmd(Cmd));
            FrsCompleteCommand(DsCmd(Cmd), ERROR_SUCCESS);
            DsCmd(Cmd) = NULL;
            break;
        //
        // Unknown command
        //
        default:
            DPRINT1(0, "Delayed: unknown command 0x%x\n", Cmd->Command);
            WStatus = ERROR_INVALID_FUNCTION;
            break;
    }
    //
    // All done
    //
    FrsCompleteCommand(Cmd, WStatus);
}


VOID
ExpelCmds(
    IN ULONGLONG    CurrentTime
    )
/*++
Routine Description:
    Expel the commands whose timeouts have passed.

Arguments:
    CurrentTime

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "ExpelCmds:"
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    //
    // Expel expired commands
    //
    while (!IsListEmpty(&TimeoutList)) {
        Entry = GetListHead(&TimeoutList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        //
        // Hasn't expired; stop
        //
        if (DsTimeout(Cmd) > CurrentTime) {
            break;
        }
        FrsRemoveEntryList(Entry);
        ProcessCmd(Cmd);
    }
}


VOID
RunDownCmds(
    VOID
    )
/*++
Routine Description:
    Error off the commands in the timeout list

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "RunDownCmds:"
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    //
    // Expel expired commands
    //
    while (!IsListEmpty(&TimeoutList)) {
        Entry = RemoveHeadList(&TimeoutList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        FrsCompleteCommand(Cmd, ERROR_ACCESS_DENIED);
    }
}


DWORD
MainDelCs(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for a thread serving the Delayed command Command Server.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "MainDelCs:"
    ULONGLONG           CurrentTime;
    ULONG               WStatus = ERROR_SUCCESS;
    BOOL                IsRunDown;
    PCOMMAND_PACKET     Cmd;
    PLIST_ENTRY         Entry;
    ULONG               Timeout = INFINITE;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)Arg;

    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &DelCs);

    DPRINT(0, "Delayed command server has started.\n");


    //
    // Try-Finally
    //
    try {

        //
        // Capture exception.
        //
        try {
            while(TRUE) {
                //
                // Pull entries off the "delayed" queue and put them on the timeout list
                //
                Cmd = FrsGetCommandServerTimeout(&DelCs, Timeout, &IsRunDown);

                //
                // Nothing to do; exit
                //
                if (Cmd == NULL && !IsRunDown && IsListEmpty(&TimeoutList)) {
                    DPRINT(0, "Delayed command server is exiting.\n");
                    FrsExitCommandServer(&DelCs, FrsThread);
                }

                //
                // Rundown the timeout list and exit the thread
                //
                if (IsRunDown) {
                    RunDownCmds();
                    DPRINT(0, "Delayed command server is exiting.\n");
                    FrsExitCommandServer(&DelCs, FrsThread);
                }

                //
                // Insert the new command, if any
                //
                FrsDelCsInsertCmd(Cmd);

                //
                // Expel expired commands
                //
                GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
                CurrentTime /= (ULONGLONG)(10 * 1000);

                ExpelCmds(CurrentTime);

                //
                // Reset our timeout
                //
                if (IsListEmpty(&TimeoutList)) {
                    Timeout = INFINITE;
                } else {
                    Entry = GetListHead(&TimeoutList);
                    Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
                    Timeout = (ULONG)(DsTimeout(Cmd) - CurrentTime);
                }
            }

        //
        // Get exception status.
        //
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "DelCs finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_PROCESS_ABORTED)) {
            DPRINT(0, "DelCs terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}


VOID
FrsDelCsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the delayed command server subsystem.

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelCsInitialize:"
    //
    // Must be 1 because there are no locks on delayed-cmd lists
    // Also, there is no benefit to having more than 1.
    //
    FRS_ASSERT(DELCS_MAXTHREADS == 1);
    InitializeListHead(&TimeoutList);
    FrsInitializeCommandServer(&DelCs, DELCS_MAXTHREADS, L"DelCs", MainDelCs);
    DelCsEvent = FrsCreateEvent(FALSE, FALSE);
    //DelCsEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}


VOID
DelCsCompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    Completion routine for delayed command server

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "DelCsCompletionRoutine:"
    DPRINT1(5, "DelRs: completion 0x%x\n", Cmd);

    if (DsCmd(Cmd)) {
        FrsCompleteCommand(DsCmd(Cmd), DsCmd(Cmd)->ErrorStatus);
        DsCmd(Cmd) = NULL;
    }
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
}


ULONGLONG
ComputeTimeout(
    IN ULONG    TimeoutInMilliSeconds
    )
/*++
Routine Description:
    Compute the absolute timeout in milliseconds.

Arguments:
    TimeoutInMilliSeconds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "ComputeTimeout:"
    ULONGLONG   CurrentTime;

    //
    // 100-nanoseconds to milliseconds
    //
    GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
    CurrentTime /= (ULONGLONG)(10 * 1000);
    CurrentTime += (ULONGLONG)(TimeoutInMilliSeconds);

    return CurrentTime;
}


VOID
FrsDelCsSubmitSubmit(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  DelCmd,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Submit a delayed command to a command server

Arguments:
    Cs
    DelCmd
    Timeout - in milliseconds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelCsSubmitSubmit:"
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocCommand(&DelCs.Queue, CMD_DELAYED_SUBMIT);
    FrsSetCompletionRoutine(Cmd, DelCsCompletionRoutine, NULL);

    DsCs(Cmd) = Cs;
    DsCmd(Cmd) = DelCmd;
    DsTimeout(Cmd) = ComputeTimeout(Timeout);
    DPRINT3(5, "Del: submit Cmd %x DelCmd %x Cs %x\n", Cmd, DsCmd(Cmd), DsCs(Cmd));
    FrsSubmitCommandServer(&DelCs, Cmd);
}


VOID
FrsDelQueueSubmit(
    IN PCOMMAND_PACKET  DelCmd,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Submit a delayed command to an Frs Queue.

Arguments:
    DelCmd
    Timeout - in milliseconds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelQueueSubmit:"
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocCommand(&DelCs.Queue, CMD_DELAYED_QUEUE_SUBMIT);
    FrsSetCompletionRoutine(Cmd, DelCsCompletionRoutine, NULL);

    DsCs(Cmd) = NULL;
    DsCmd(Cmd) = DelCmd;
    DsTimeout(Cmd) = ComputeTimeout(Timeout);
    DPRINT2(5, "DelQueue: submit Cmd %x DelCmd %x\n", Cmd, DsCmd(Cmd));
    FrsSubmitCommandServer(&DelCs, Cmd);
}


VOID
FrsDelCsCompleteSubmit(
    IN PCOMMAND_PACKET  DelCmd,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Submit a delayed complete-command to the DelCs

Arguments:
    DelCmd
    Timeout - in milliseconds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelCsCompleteSubmit:"
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocCommand(&DelCs.Queue, CMD_DELAYED_COMPLETE);
    FrsSetCompletionRoutine(Cmd, DelCsCompletionRoutine, NULL);

    DsCs(Cmd) = NULL;
    DsCmd(Cmd) = DelCmd;
    DsTimeout(Cmd) = ComputeTimeout(Timeout);
    COMMAND_TRACE(4, Cmd, "Del Complete");
    COMMAND_TRACE(4, DelCmd, "Del Complete Cmd");
    FrsSubmitCommandServer(&DelCs, Cmd);
}


VOID
FrsDelCsSubmitUnIdled(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       IdledQueue,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Submit a delayed "FrsRtlUnIdledQueue" command.

Arguments:
    Cs
    IdledQueue
    Timeout - In milliSeconds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelCsSubmitUnIdled:"
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocCommand(&DelCs.Queue, CMD_DELAYED_UNIDLED);
    FrsSetCompletionRoutine(Cmd, DelCsCompletionRoutine, NULL);

    DsCs(Cmd) = Cs;
    DsQueue(Cmd) = IdledQueue;
    DsTimeout(Cmd) = ComputeTimeout(Timeout);
    DPRINT2(5, "Del: submit Cmd 0x%x IdledQueue 0x%x\n", Cmd, DsQueue(Cmd));
    FrsSubmitCommandServer(&DelCs, Cmd);
}


VOID
FrsDelCsSubmitKick(
    IN PCOMMAND_SERVER  Cs,
    IN PFRS_QUEUE       Queue,
    IN ULONG            Timeout
    )
/*++
Routine Description:
    Submit a delayed "FrsKickCommandServer" command.

Arguments:
    Cs
    Queue
    Timeout - In milliSeconds

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsDelCsSubmitKick:"
    PCOMMAND_PACKET Cmd;

    Cmd = FrsAllocCommand(&DelCs.Queue, CMD_DELAYED_KICK);
    FrsSetCompletionRoutine(Cmd, DelCsCompletionRoutine, NULL);

    DsCs(Cmd) = Cs;
    DsQueue(Cmd) = Queue;
    DsTimeout(Cmd) = ComputeTimeout(Timeout);
    DPRINT2(5, "Del: submit Cmd 0x%x kick 0x%x\n", Cmd, DsCs(Cmd));
    FrsSubmitCommandServer(&DelCs, Cmd);
}


VOID
ShutDownDelCs(
    VOID
    )
/*++
Routine Description:
    Shutdown the send command server

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "ShutDownDelCs:"
    INT i;

    FrsRunDownCommandServer(&DelCs, &DelCs.Queue);
    for (i = 0; i < DELCS_MAXTHREADS; ++i) {
        SetEvent(DelCsEvent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frserror.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frserror.c

Abstract:

    FRS Error description tables.  Contains tables for FRS Errors,
    Win32 Errors, Jet Errors and NT Status Codes.

Author:
    Billy J. Fuller 01-Apr-1997    Temporary

    David A. Orbits 11-Jul-1999
        Rewritten to integrate FrsError Codes with Billy's error codes and
        handle the problem in a more general way.
        Never enuf time to do it right, always enuf time to do it over.

Environment

    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>

//
//  FRS Format Descriptors.
//
#define  FFD_NONE        NULL

#define  FFD_S           "s"
#define  FFD_SS          "ss"
#define  FFD_SSS         "sss"
#define  FFD_SSSS        "ssss"
#define  FFD_SSSSS       "sssss"

#define  FFD_W           "w"
#define  FFD_WW          "ww"
#define  FFD_WWW         "www"
#define  FFD_WWWW        "wwww"
#define  FFD_WWWWW       "wwwww"
#define  FFD_WWWWWW      "wwwwww"

#define  FFD_D           "d"
#define  FFD_DD          "dd"
#define  FFD_DDD         "ddd"

#define  FFD_DW          "dw"
#define  FFD_WD          "wd"
#define  FFD_WWD         "wwd"


typedef struct _FRS_ERROR_MSG_TABLE {
    ULONG           ErrorCode;       // Error code number for message lookup.

    //FRS_ERROR_SEVERITY  FrsErrorSeverity;

    PCHAR           ErrorMsg;         // Error Message Code.
    PCHAR           LongMsg;          // Error Message String.

    //DWORD           EventCode;       // Event log error code
    //ULONG           Flags;           // See below.

} FRS_ERROR_MSG_TABLE, *PFRS_ERROR_MSG_TABLE;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **        F R S   E R R O R   D E S C R I P T I O N   T A B L E              **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

FRS_ERROR_MSG_TABLE FrsErrorMsgTable[] = {

    {FrsErrorAccess,                "FrsErrorAccess"               ,  "couldn't access a file or the db"},
    {FrsErrorBadOutLogPartnerData,  "FrsErrorBadOutLogPartnerData" ,  "Either the data was corrupt, unavail or was wrong"},
    {FrsErrorBadParam,              "FrsErrorBadParam"             ,  "Bad parameter to a function"},
    {FrsErrorBadPathname,           "FrsErrorBadPathname"          ,  "Invalid path name"      },
    {FrsErrorBufferOverflow,        "FrsErrorBufferOverflow"       ,  "Buffer overflow NTSTATUS"},
    {FrsErrorCantMoveOut,           "FrsErrorCantMoveOut"          ,  "Request for a Moveout of a non-empty directory failed"},
    {FrsErrorChgOrderAbort,         "FrsErrorChgOrderAbort"        ,  "Change order processing has been aborted"},
    {FrsErrorCmdPktTimeOut,         "FrsErrorCmdPktTimeOut"        ,  "Command packet timeout"},
    {FrsErrorCmdSrvFailed,          "FrsErrorCmdSrvFailed"         ,  "A command server request failed to get submitted"},
    {FrsErrorConflict,              "FrsErrorConflict"             ,  "Record or table create conflict"},
    {FrsErrorDampened,              "FrsErrorDampened"             ,  "This request is suppressed because it has already been seen"},
    {FrsErrorDatabaseCorrupted,     "FrsErrorDatabaseCorrupted"    ,  "not a db or a scrambled db"},
    {FrsErrorDatabaseNotFound,      "FrsErrorDatabaseNotFound"     ,  "no db or path to db is in error"},
    {FrsErrorDbWriteConflict,       "FrsErrorDbWriteConflict"      ,  "DB update conflict if two sessions try to update the same record"},
    {FrsErrorDeleteRequested,       "FrsErrorDeleteRequested"      ,  "Enum function status return to delete entry"},
    {FrsErrorDirCreateFailed,       "FrsErrorDirCreateFailed"      ,  "We failed to create a new DIR.  This stops repl"},
    {FrsErrorDirNotEmpty,           "FrsErrorDirNotEmpty"          ,  "Directory not empty"    },
    {FrsErrorDiskSpace,             "FrsErrorDiskSpace"            ,  "out of disk space"},
    {FrsErrorEndOfTable,            "FrsErrorEndOfTable"           ,  "No next record, end of table hit"},
    {FrsErrorFileExists,            "FrsErrorFileExists"           ,  "File already Eeists"    },
    {FrsErrorFoundKey,              "FrsErrorFoundKey"             ,  "The Key being searched by QHashEnumerateTable was found"},
    {FrsErrorIdtFileIsDeleted,      "FrsErrorIdtFileIsDeleted"     ,  "File is marked deleted in IDTable"},
    {FrsErrorInfo,                  "FrsErrorInfo"                 ,  "informational error, e.g. JET_errObjectNotFound"},
    {FrsErrorInternalError,         "FrsErrorInternalError"        ,  "unexpected error occurred - catchall"},
    {FrsErrorInvalidChangeOrder,    "FrsErrorInvalidChangeOrder"   ,  "Invalid change order"},
    {FrsErrorInvalidGuid,           "FrsErrorInvalidGuid"          ,  "The generated Guid is missing the net address"},
    {FrsErrorInvalidHandle,         "FrsErrorInvalidHandle"        ,  "Invalid File Handle"},
    {FrsErrorInvalidOperation,      "FrsErrorInvalidOperation"     ,  "Invalid operation requested"},
    {FrsErrorInvalidRegistryParam,  "FrsErrorInvalidRegistryParam" ,  "Invalid registry parameter"},
    {FrsErrorJetSecIndexCorrupted,  "FrsErrorJetSecIndexCorrupted" ,  "Jet (upgrade, collating, jet err -1414)"},
    {FrsErrorJournalInitFailed,     "FrsErrorJournalInitFailed"    ,  "The NTFS journal failed to initialize"},
    {FrsErrorJournalPauseFailed,    "FrsErrorJournalPauseFailed"   ,  "The NTFS journal failed to Pause, could be timeout"},
    {FrsErrorJournalReplicaStop,    "FrsErrorJournalReplicaStop"   ,  "Failed to detatch the replica from The journal"},
    {FrsErrorJournalStartFailed,    "FrsErrorJournalStartFailed"   ,  "The NTFS journal failed to start"},
    {FrsErrorJournalStateWrong,     "FrsErrorJournalStateWrong"    ,  "The NTFS journal is in an unexpected state"},
    {FrsErrorJournalWrapError,      "FrsErrorJournalWrapError"     ,  "Initial NTFS journal record not present.  Journal has wrapped"},
    {FrsErrorKeyDuplicate,          "FrsErrorKeyDuplicate"         ,  "An attempt to insert a record with a duplicate key"},
    {FrsErrorMoreWork,              "FrsErrorMoreWork"             ,  "There is more work to do on this command / operation"},
    {FrsErrorNameMorphConflict,     "FrsErrorNameMorphConflict"    ,  "File name morph conflict was detected"},
    {FrsErrorNoOpenJournals,        "FrsErrorNoOpenJournals"       ,  "Can't start replication because no journals were opened"},
    {FrsErrorNoPrivileges,          "FrsErrorNoPrivileges"         ,  "Couldn't get the necessary privileges to run"},
    {FrsErrorNotFound,              "FrsErrorNotFound"             ,  "Record or table not found"},
    {FrsErrorNotInitialized,        "FrsErrorNotInitialized"       ,  "Function called without proper initialization"},
    {FrsErrorOplockNotGranted,      "FrsErrorOplockNotGranted"     ,  "Op lock not granted"    },
    {FrsErrorPartnerActivateFailed, "FrsErrorPartnerActivateFailed",  "Failed to activate an outbound partner"},
    {FrsErrorPreInstallDirectory,   "FrsErrorPreInstallDirectory"  ,  "creating preinstall directory"},
    {FrsErrorPreinstallCreFail,     "FrsErrorPreinstallCreFail"    ,  "Failed to create the pre-install dir"},
    {FrsErrorPrepareRoot,           "FrsErrorPrepareRoot"          ,  "Could not prepare the root dir for replication, bad path? share viol?"},
    {FrsErrorQueueIsRundown,        "FrsErrorQueueIsRundown"       ,  "The request queue has been rundown"},
    {FrsErrorRecordLocked,          "FrsErrorRecordLocked"         ,  "The record being accessed is locked"},
    {FrsErrorReplicaPhase1Failed,   "FrsErrorReplicaPhase1Failed"  ,  "Phase 1 of replica set init failed"},
    {FrsErrorReplicaPhase2Failed,   "FrsErrorReplicaPhase2Failed"  ,  "Phase 2 of replica set init failed"},
    {FrsErrorReplicaRootDirOpenFail,"FrsErrorReplicaRootDirOpenFail", "Failed to open the replica tree root dir"},
    {FrsErrorReplicaSetTombstoned,  "FrsErrorReplicaSetTombstoned" ,  "Replica set is marked for deletion"},
    {FrsErrorRequestCancelled,      "FrsErrorRequestCancelled"     ,  "Request Cancelled"      },
    {FrsErrorResource,              "FrsErrorResource"             ,  "Resource limit e.g. handles or memory hit"},
    {FrsErrorResourceInUse,         "FrsErrorResourceInUse"        ,  "A resource required by this operation is in use"},
    {FrsErrorRetry,                 "FrsErrorRetry"                ,  "Error Retry"            },
    {FrsErrorSessionNotClosed,      "FrsErrorSessionNotClosed"     ,  "Failed to close all RtCtx's in replica set"},
    {FrsErrorSharingViolation,      "FrsErrorSharingViolation"     ,  "File sharing violation" },
    {FrsErrorShuttingDown,          "FrsErrorShuttingDown"         ,  "Service shutdown in progress"},
    {FrsErrorStageDirOpenFail,      "FrsErrorStageDirOpenFail"     ,  "Failed to open the staging dir"},
    {FrsErrorStageFileDelFailed,    "FrsErrorStageFileDelFailed"   ,  "An attempt to delete the staging file failed"},
    {FrsErrorSuccess,               "FrsErrorSuccess"              ,  "Success"},
    {FrsErrorTerminateEnum,         "FrsErrorTerminateEnum"        ,  "Enum function status return to end enumeration"},
    {FrsErrorTunnelConflict,        "FrsErrorTunnelConflict"       ,  "oid conflict with id table entry (resolved)"},
    {FrsErrorTunnelConflictRejectCO,"FrsErrorTunnelConflictRejectCO",  "oid conflict with id table entry (CO rejected)"},
    {FrsErrorUnjoining,             "FrsErrorUnjoining"            ,  "cxtion is still unjoining"},
    {FrsErrorUnsupportedFileSystem, "FrsErrorUnsupportedFileSystem",  "The file system on this volume does provide the features required by FRS"},
    {FrsErrorVVSlotNotFound,        "FrsErrorVVSlotNotFound"       ,  "VVSlot not found on VVretire of Out of Order CO"},
    {FrsErrorVolumeRootDirOpenFail, "FrsErrorVolumeRootDirOpenFail",  "Failed to open the volume root directory for this replica set"},
    {FrsErrorVvChecksum,            "FrsErrorVvChecksum"           ,  "version vector checksum mismatch"},
    {FrsErrorVvLength,              "FrsErrorVvLength"             ,  "vers vector length mismatch"},
    {FrsErrorVvRevision,            "FrsErrorVvRevision"           ,  "Vers Vector revision mismatch"},

    {FRS_ERROR_LISTEN                    ,  "FrsErrorListen"                , "FrsErrorListen"                },
    {FRS_ERROR_REGISTEREP                ,  "FrsErrorRegisterP"             , "FrsErrorRegisterP"             },
    {FRS_ERROR_REGISTERIF                ,  "FrsErrorRegisterIF"            , "FrsErrorRegisterIF"            },
    {FRS_ERROR_INQ_BINDINGS              ,  "FrsErrorIngBindings"           , "FrsErrorIngBindings"           },
    {FRS_ERROR_PROTSEQ                   ,  "FrsErrorProtSeq"               , "FrsErrorProtSeq"               },

    //
    // New error codes that trigger a non_auth restore.
    //
    {FrsErrorMismatchedVolumeSerialNumber , "FrsErrorMismatchedVolumeSerialNumber" , "The Volume serial number from DB does not match the one from FileSystem."    },
    {FrsErrorMismatchedReplicaRootObjectId, "FrsErrorMismatchedReplicaRootObjectId", "The Replica root's ObjectID from DB does not match the one from FileSystem." },
    {FrsErrorMismatchedReplicaRootFileId  , "FrsErrorMismatchedReplicaRootFileId"  , "The Replica root's FID from DB does not match the one from FileSystem."      },
    {FrsErrorMismatchedJournalId          , "FrsErrorMismatchedJournalId"          , "The Journal ID from DB does not match the one from FileSystem."              },


    {MAXULONG,                                  NULL,     NULL}
};


//
// If code does not appear in above list it gets added to this list.
//
#define SIZE_OF_FRS_EXTENDED_MSG_TABLE  20
FRS_ERROR_MSG_TABLE FrsErrorMsgTableExt[SIZE_OF_FRS_EXTENDED_MSG_TABLE];
ULONG  FrsErrorMsgTableExtUsed = 0;



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **        W I N 3 2   E R R O R   D E S C R I P T I O N   T A B L E          **
 **            (Internal Short Version for Trace Log Only)                    **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

typedef struct _FRS_WIN32_ERROR_MSG_TABLE {
    ULONG   ErrorCode;       // Error code number for message lookup.
    PCHAR   ErrorMsg;        // Error Message String.

} FRS_WIN32_ERROR_MSG_TABLE, *PFRS_WIN32_ERROR_MSG_TABLE;

//
// Some names for the Win32 Error codes.
//

FRS_WIN32_ERROR_MSG_TABLE FrsWin32ErrorMsgTable[] = {

    {E_UNEXPECTED                             ,"E_UNEXPECTED"},
    {EPT_S_NOT_REGISTERED                     ,"EPT_S_NOT_REGISTERED"},
    {ERROR_ACCESS_DENIED                      ,"ERROR_ACCESS_DENIED"},
    {ERROR_ALREADY_EXISTS                     ,"ERROR_ALREADY_EXISTS"},
    {ERROR_BAD_COMMAND                        ,"ERROR_BAD_COMMAND"},
    {ERROR_BADKEY                             ,"ERROR_BADKEY"},
    {ERROR_BAD_PATHNAME                       ,"ERROR_BAD_PATHNAME"},
    {ERROR_BUSY                               ,"ERROR_BUSY"},
    {ERROR_CALL_NOT_IMPLEMENTED               ,"ERROR_CALL_NOT_IMPLEMENTED"},
    {ERROR_CANCELLED                          ,"ERROR_CANCELLED"},
    {ERROR_CANNOT_MAKE                        ,"ERROR_CANNOT_MAKE"},
    {ERROR_CANTREAD                           ,"ERROR_CANTREAD"},
    {ERROR_CANT_ACCESS_FILE                   ,"ERROR_CANT_ACCESS_FILE"},    //  0xc0000279 STATUS_IO_REPARSE_TAG_NOT_HANDLED
    {ERROR_CAN_NOT_COMPLETE                   ,"ERROR_CAN_NOT_COMPLETE"},
    {ERROR_COMMITMENT_LIMIT                   ,"ERROR_COMMITMENT_LIMIT"},
    {ERROR_CRC                                ,"ERROR_CRC"},                 //  STATUS_DATA_ERROR from journal read
    {ERROR_CURRENT_DIRECTORY                  ,"ERROR_CURRENT_DIRECTORY"},
    {ERROR_DIRECTORY                          ,"ERROR_DIRECTORY"},
    {ERROR_DIR_NOT_EMPTY                      ,"ERROR_DIR_NOT_EMPTY"},
    {ERROR_DISK_FULL                          ,"ERROR_DISK_FULL"},
    {ERROR_DUP_NAME                           ,"ERROR_DUP_NAME"},
    {ERROR_ENVVAR_NOT_FOUND                   ,"ERROR_ENVVAR_NOT_FOUND"},
    {ERROR_FILE_EXISTS                        ,"ERROR_FILE_EXISTS"},
    {ERROR_FILE_NOT_FOUND                     ,"ERROR_FILE_NOT_FOUND"},
    {ERROR_FILENAME_EXCED_RANGE               ,"ERROR_FILENAME_EXCED_RANGE"},
    {ERROR_GEN_FAILURE                        ,"ERROR_GEN_FAILURE"},
    {ERROR_HANDLE_DISK_FULL                   ,"ERROR_HANDLE_DISK_FULL"},
    {ERROR_HANDLE_EOF                         ,"ERROR_HANDLE_EOF"},
    {ERROR_INSUFFICIENT_BUFFER                ,"ERROR_INSUFFICIENT_BUFFER"},
    {ERROR_INVALID_ACCESS                     ,"ERROR_INVALID_ACCESS"},
    {ERROR_INVALID_ACCOUNT_NAME               ,"ERROR_INVALID_ACCOUNT_NAME"},
    {ERROR_INVALID_ADDRESS                    ,"ERROR_INVALID_ADDRESS"},
    {ERROR_INVALID_BLOCK                      ,"ERROR_INVALID_BLOCK"},
    {ERROR_INVALID_COMPUTERNAME               ,"ERROR_INVALID_COMPUTERNAME"},
    {ERROR_INVALID_DATA                       ,"ERROR_INVALID_DATA"},
    {ERROR_INVALID_FUNCTION                   ,"ERROR_INVALID_FUNCTION"},
    {ERROR_INVALID_HANDLE                     ,"ERROR_INVALID_HANDLE"},
    {ERROR_INVALID_NAME                       ,"ERROR_INVALID_NAME"},
    {ERROR_INVALID_OPERATION                  ,"ERROR_INVALID_OPERATION"},
    {ERROR_INVALID_PARAMETER                  ,"ERROR_INVALID_PARAMETER"},
    {ERROR_INVALID_STATE                      ,"ERROR_INVALID_STATE"},
    {ERROR_INVALID_USER_BUFFER                ,"ERROR_INVALID_USER_BUFFER"},
    {ERROR_IO_DEVICE                          ,"ERROR_IO_DEVICE"},
    {ERROR_IO_PENDING                         ,"ERROR_IO_PENDING"},
    {ERROR_JOURNAL_DELETE_IN_PROGRESS         ,"ERROR_JOURNAL_DELETE_IN_PROGRESS"},
    {ERROR_JOURNAL_ENTRY_DELETED              ,"ERROR_JOURNAL_ENTRY_DELETED"},
    {ERROR_JOURNAL_NOT_ACTIVE                 ,"ERROR_JOURNAL_NOT_ACTIVE"},
    {ERROR_LOCK_VIOLATION                     ,"ERROR_LOCK_VIOLATION"},
    {ERROR_LOGON_FAILURE                      ,"ERROR_LOGON_FAILURE"},
    {ERROR_MOD_NOT_FOUND                      ,"ERROR_MOD_NOT_FOUND"},
    {ERROR_MORE_DATA                          ,"ERROR_MORE_DATA"},
    {ERROR_NETWORK_BUSY                       ,"ERROR_NETWORK_BUSY"},
    {ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT  ,"ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT"},
    {ERROR_NONE_MAPPED                        ,"ERROR_NONE_MAPPED"},
    {ERROR_NOT_AUTHENTICATED                  ,"ERROR_NOT_AUTHENTICATED"},
    {ERROR_NOT_ENOUGH_MEMORY                  ,"ERROR_NOT_ENOUGH_MEMORY"},
    {ERROR_NOT_FOUND                          ,"ERROR_NOT_FOUND"},
    {ERROR_NOT_READY                          ,"ERROR_NOT_READY"},
    {ERROR_NOT_SUPPORTED                      ,"ERROR_NOT_SUPPORTED"},
    {ERROR_NOACCESS                           ,"ERROR_NOACCESS (AccessViolation)"},
    {ERROR_NO_DATA                            ,"ERROR_NO_DATA"},
    {ERROR_NO_MORE_FILES                      ,"ERROR_NO_MORE_FILES"},
    {ERROR_NO_MORE_ITEMS                      ,"ERROR_NO_MORE_ITEMS"},
    {ERROR_NO_SECURITY_ON_OBJECT              ,"ERROR_NO_SECURITY_ON_OBJECT"},
    {ERROR_NO_SUCH_DOMAIN                     ,"ERROR_NO_SUCH_DOMAIN"},
    {ERROR_NO_SUCH_USER                       ,"ERROR_NO_SUCH_USER"},
    {ERROR_NO_SYSTEM_RESOURCES                ,"ERROR_NO_SYSTEM_RESOURCES"},
    {ERROR_NO_TOKEN                           ,"ERROR_NO_TOKEN"},
    {ERROR_OPEN_FAILED                        ,"ERROR_OPEN_FAILED"},
    {ERROR_OPERATION_ABORTED                  ,"ERROR_OPERATION_ABORTED"},
    {ERROR_OPLOCK_NOT_GRANTED                 ,"ERROR_OPLOCK_NOT_GRANTED"},
    {ERROR_OUTOFMEMORY                        ,"ERROR_OUTOFMEMORY"},
    {ERROR_PARTIAL_COPY                       ,"ERROR_PARTIAL_COPY"},
    {ERROR_PATH_NOT_FOUND                     ,"ERROR_PATH_NOT_FOUND"},
    {ERROR_PIPE_CONNECTED                     ,"ERROR_PIPE_CONNECTED"},
    {ERROR_PROCESS_ABORTED                    ,"ERROR_PROCESS_ABORTED"},
    {ERROR_REQUEST_ABORTED                    ,"ERROR_REQUEST_ABORTED"},
    {ERROR_RETRY                              ,"ERROR_RETRY"},
    {ERROR_REVISION_MISMATCH                  ,"ERROR_REVISION_MISMATCH"},
    {ERROR_SEEK                               ,"ERROR_SEEK"},
    {ERROR_SEM_OWNER_DIED                     ,"ERROR_SEM_OWNER_DIED"},
    {ERROR_SEM_TIMEOUT                        ,"ERROR_SEM_TIMEOUT"},
    {ERROR_SERVICE_ALREADY_RUNNING            ,"ERROR_SERVICE_ALREADY_RUNNING"},
    {ERROR_SERVICE_DOES_NOT_EXIST             ,"ERROR_SERVICE_DOES_NOT_EXIST"},
    {ERROR_SERVICE_EXISTS                     ,"ERROR_SERVICE_EXISTS"},
    {ERROR_SERVICE_MARKED_FOR_DELETE          ,"ERROR_SERVICE_MARKED_FOR_DELETE"},
    {ERROR_SERVICE_NOT_ACTIVE                 ,"ERROR_SERVICE_NOT_ACTIVE"},
    {ERROR_SERVICE_REQUEST_TIMEOUT            ,"ERROR_SERVICE_REQUEST_TIMEOUT"},
    {ERROR_SERVICE_SPECIFIC_ERROR             ,"ERROR_SERVICE_SPECIFIC_ERROR"},
    {ERROR_SHARING_VIOLATION                  ,"ERROR_SHARING_VIOLATION"},
    {ERROR_SUCCESS                            ,"ERROR_SUCCESS"},
    {ERROR_TIMEOUT                            ,"ERROR_TIMEOUT"},
    {ERROR_TOO_MANY_OPEN_FILES                ,"ERROR_TOO_MANY_OPEN_FILES"},
    {ERROR_TRUSTED_DOMAIN_FAILURE             ,"ERROR_TRUSTED_DOMAIN_FAILURE"},
    {ERROR_UNEXP_NET_ERR                      ,"ERROR_UNEXP_NET_ERR"},


    {FRS_ERR_INVALID_API_SEQUENCE             ,"FRS_ERR_INVALID_API_SEQUENCE"},
    {FRS_ERR_STARTING_SERVICE                 ,"FRS_ERR_STARTING_SERVICE"},
    {FRS_ERR_STOPPING_SERVICE                 ,"FRS_ERR_STOPPING_SERVICE"},
    {FRS_ERR_INTERNAL_API                     ,"FRS_ERR_INTERNAL_API"},
    {FRS_ERR_INTERNAL                         ,"FRS_ERR_INTERNAL"},
    {FRS_ERR_SERVICE_COMM                     ,"FRS_ERR_SERVICE_COMM"},
    {FRS_ERR_INSUFFICIENT_PRIV                ,"FRS_ERR_INSUFFICIENT_PRIV"},
    {FRS_ERR_AUTHENTICATION                   ,"FRS_ERR_AUTHENTICATION"},
    {FRS_ERR_PARENT_INSUFFICIENT_PRIV         ,"FRS_ERR_PARENT_INSUFFICIENT_PRIV"},
    {FRS_ERR_PARENT_AUTHENTICATION            ,"FRS_ERR_PARENT_AUTHENTICATION"},
    {FRS_ERR_CHILD_TO_PARENT_COMM             ,"FRS_ERR_CHILD_TO_PARENT_COMM"},
    {FRS_ERR_PARENT_TO_CHILD_COMM             ,"FRS_ERR_PARENT_TO_CHILD_COMM"},
    {FRS_ERR_SYSVOL_POPULATE                  ,"FRS_ERR_SYSVOL_POPULATE"},
    {FRS_ERR_SYSVOL_POPULATE_TIMEOUT          ,"FRS_ERR_SYSVOL_POPULATE_TIMEOUT"},
    {FRS_ERR_SYSVOL_IS_BUSY                   ,"FRS_ERR_SYSVOL_IS_BUSY"},
    {FRS_ERR_SYSVOL_DEMOTE                    ,"FRS_ERR_SYSVOL_DEMOTE"},
    {FRS_ERR_INVALID_SERVICE_PARAMETER        ,"FRS_ERR_INVALID_SERVICE_PARAMETER"},

    {RPC_S_CALL_CANCELLED                     ,"RPC_S_CALL_CANCELLED"},
    {RPC_S_CALL_FAILED                        ,"RPC_S_CALL_FAILED"},
    {RPC_S_CALL_FAILED_DNE                    ,"RPC_S_CALL_FAILED_DNE"},
    {RPC_S_CANNOT_SUPPORT                     ,"RPC_S_CANNOT_SUPPORT"},
    {RPC_S_SEC_PKG_ERROR                      ,"RPC_S_SEC_PKG_ERROR"},
    {RPC_S_SERVER_TOO_BUSY                    ,"RPC_S_SERVER_TOO_BUSY"},
    {RPC_S_SERVER_UNAVAILABLE                 ,"RPC_S_SERVER_UNAVAILABLE"},
    {RPC_S_UNKNOWN_IF                         ,"RPC_S_UNKNOWN_IF"},


    {EXCEPTION_ACCESS_VIOLATION               ,"EXCEPTION_ACCESS_VIOLATION"},
    {EXCEPTION_DATATYPE_MISALIGNMENT          ,"EXCEPTION_DATATYPE_MISALIGNMENT"},
    {EXCEPTION_BREAKPOINT                     ,"EXCEPTION_BREAKPOINT"},
    {EXCEPTION_SINGLE_STEP                    ,"EXCEPTION_SINGLE_STEP"},
    {EXCEPTION_ARRAY_BOUNDS_EXCEEDED          ,"EXCEPTION_ARRAY_BOUNDS_EXCEEDED"},
    {EXCEPTION_FLT_DENORMAL_OPERAND           ,"EXCEPTION_FLT_DENORMAL_OPERAND"},
    {EXCEPTION_FLT_DIVIDE_BY_ZERO             ,"EXCEPTION_FLT_DIVIDE_BY_ZERO"},
    {EXCEPTION_FLT_INEXACT_RESULT             ,"EXCEPTION_FLT_INEXACT_RESULT"},
    {EXCEPTION_FLT_INVALID_OPERATION          ,"EXCEPTION_FLT_INVALID_OPERATION"},
    {EXCEPTION_FLT_OVERFLOW                   ,"EXCEPTION_FLT_OVERFLOW"},
    {EXCEPTION_FLT_STACK_CHECK                ,"EXCEPTION_FLT_STACK_CHECK"},
    {EXCEPTION_FLT_UNDERFLOW                  ,"EXCEPTION_FLT_UNDERFLOW"},
    {EXCEPTION_INT_DIVIDE_BY_ZERO             ,"EXCEPTION_INT_DIVIDE_BY_ZERO"},
    {EXCEPTION_INT_OVERFLOW                   ,"EXCEPTION_INT_OVERFLOW"},
    {EXCEPTION_PRIV_INSTRUCTION               ,"EXCEPTION_PRIV_INSTRUCTION"},
    {EXCEPTION_IN_PAGE_ERROR                  ,"EXCEPTION_IN_PAGE_ERROR"},
    {EXCEPTION_ILLEGAL_INSTRUCTION            ,"EXCEPTION_ILLEGAL_INSTRUCTION"},
    {EXCEPTION_NONCONTINUABLE_EXCEPTION       ,"EXCEPTION_NONCONTINUABLE_EXCEPTION"},
    {EXCEPTION_STACK_OVERFLOW                 ,"EXCEPTION_STACK_OVERFLOW"},
    {EXCEPTION_INVALID_DISPOSITION            ,"EXCEPTION_INVALID_DISPOSITION"},
    {EXCEPTION_GUARD_PAGE                     ,"EXCEPTION_GUARD_PAGE"},
    {EXCEPTION_INVALID_HANDLE                 ,"EXCEPTION_INVALID_HANDLE"},
    {CONTROL_C_EXIT                           ,"CONTROL_C_EXIT"},

    {WAIT_OBJECT_0                            ,"WAIT_OBJECT_0"},
    {WAIT_FAILED                              ,"WAIT_FAILED"},
    {WAIT_ABANDONED                           ,"WAIT_ABANDONED"},
    {WAIT_TIMEOUT                             ,"WAIT_TIMEOUT"},

    {MAXULONG                                 , NULL}
};

//
// If code does not appear in above list it gets added to this list.
//
#define SIZE_OF_FRSWIN32_EXTENDED_MSG_TABLE  50
FRS_WIN32_ERROR_MSG_TABLE FrsWin32ErrorMsgTableExt[SIZE_OF_FRSWIN32_EXTENDED_MSG_TABLE];
ULONG  FrsWin32ErrorMsgTableExtUsed = 0;



typedef struct _FRS_NT_ERROR_MSG_TABLE {
    NTSTATUS            Status;
    FRS_ERROR_CODE      FrsErrorCode;
    FRS_ERROR_SEVERITY  FrsErrorSeverity;
    PCHAR               ErrorMsg;
} FRS_NT_ERROR_MSG_TABLE, *PFRS_NT_ERROR_MSG_TABLE;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **        N T   E R R O R   D E S C R I P T I O N   T A B L E                **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// This error table translates NT Status codes to an FRS_ERROR_CODE class and an
// associated severity level.  It also has a message string.  See frserror.h
//
//    NT Status code                 FRS Error Code              FRS Severity            NT Error message
//
FRS_NT_ERROR_MSG_TABLE FrsNtErrorMsgTable[] = {
    {STATUS_ACCESS_DENIED             ,FrsErrorAccess          ,FrsSeverityServiceFatal, "STATUS_ACCESS_DENIED"},
    {STATUS_BAD_WORKING_SET_LIMIT     ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_BAD_WORKING_SET_LIMIT"},
    {STATUS_BUFFER_OVERFLOW           ,FrsErrorBufferOverflow  ,FrsSeverityServiceFatal, "STATUS_BUFFER_OVERFLOW"},
    {STATUS_CANCELLED                 ,FrsErrorRequestCancelled,FrsSeverityInfo,         "STATUS_CANCELLED"},
    {STATUS_DATA_ERROR                ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_DATA_ERROR"},
    {STATUS_DELETE_PENDING            ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_DELETE_PENDING"},
    {STATUS_FILE_DELETED              ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_FILE_DELETED"},
    {STATUS_DEVICE_CONFIGURATION_ERROR,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_DEVICE_CONFIGURATION_ERROR"},
    {STATUS_DIRECTORY_NOT_EMPTY       ,FrsErrorConflict        ,FrsSeverityInfo,         "STATUS_DIRECTORY_NOT_EMPTY"},
    {STATUS_DUPLICATE_NAME            ,FrsErrorConflict        ,FrsSeverityServiceFatal, "STATUS_DUPLICATE_NAME"},
    {STATUS_FILE_IS_A_DIRECTORY       ,FrsErrorConflict        ,FrsSeverityServiceFatal, "STATUS_FILE_IS_A_DIRECTORY"},
    {STATUS_INCOMPATIBLE_FILE_MAP     ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INCOMPATIBLE_FILE_MAP"},
    {STATUS_INVALID_ADDRESS           ,FrsErrorInternalError   ,FrsSeverityServiceFatal, "STATUS_INVALID_ADDRESS"},
    {STATUS_INVALID_INFO_CLASS        ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_INFO_CLASS"},
    {STATUS_INVALID_DEVICE_REQUEST    ,FrsErrorBadParam        ,FrsSeverityInfo,         "STATUS_INVALID_DEVICE_REQUEST"},
    {STATUS_INVALID_CID               ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_CID"},
    {STATUS_INVALID_PARAMETER         ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER"},
    {STATUS_INVALID_PARAMETER_1       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_1"},
    {STATUS_INVALID_PARAMETER_2       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_2"},
    {STATUS_INVALID_PARAMETER_3       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_3"},
    {STATUS_INVALID_PARAMETER_4       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_4"},
    {STATUS_INVALID_PARAMETER_5       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_5"},
    {STATUS_INVALID_PARAMETER_6       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_6"},
    {STATUS_INVALID_PARAMETER_7       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_7"},
    {STATUS_INVALID_PARAMETER_8       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_8"},
    {STATUS_INVALID_PARAMETER_9       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_9"},
    {STATUS_INVALID_PARAMETER_10      ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_10"},
    {STATUS_INVALID_PARAMETER_11      ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_11"},
    {STATUS_INVALID_PARAMETER_12      ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_12"},
    {STATUS_INVALID_PARAMETER_MIX     ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PARAMETER_MIX"},
    {STATUS_INVALID_PAGE_PROTECTION   ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_PAGE_PROTECTION"},
    {STATUS_IO_REPARSE_TAG_INVALID    ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_IO_REPARSE_TAG_INVALID"},
    {STATUS_IO_REPARSE_TAG_MISMATCH   ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_IO_REPARSE_TAG_MISMATCH"},
    {STATUS_IO_REPARSE_TAG_NOT_HANDLED,FrsErrorAccess          ,FrsSeverityInfo,         "STATUS_IO_REPARSE_TAG_NOT_HANDLED"},
    {STATUS_IO_REPARSE_DATA_INVALID   ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_IO_REPARSE_DATA_INVALID"},
    {STATUS_JOURNAL_DELETE_IN_PROGRESS,FrsErrorInvalidOperation,FrsSeverityInfo,         "STATUS_JOURNAL_DELETE_IN_PROGRESS"},
    {STATUS_JOURNAL_NOT_ACTIVE        ,FrsErrorInvalidOperation,FrsSeverityServiceFatal, "STATUS_JOURNAL_NOT_ACTIVE"},
    {STATUS_JOURNAL_ENTRY_DELETED     ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_JOURNAL_ENTRY_DELETED"},
    {STATUS_NO_MORE_FILES             ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_NO_MORE_FILES"},
    {STATUS_NOT_IMPLEMENTED           ,FrsErrorInvalidOperation,FrsSeverityServiceFatal, "STATUS_NOT_IMPLEMENTED"},
    {STATUS_NOT_LOCKED                ,FrsErrorInvalidOperation,FrsSeverityServiceFatal, "STATUS_NOT_LOCKED"},
    {STATUS_OBJECT_NAME_COLLISION     ,FrsErrorConflict        ,FrsSeverityServiceFatal, "STATUS_OBJECT_NAME_COLLISION"},
    {STATUS_OBJECT_NAME_INVALID       ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_OBJECT_NAME_INVALID"},
    {STATUS_OBJECT_NAME_NOT_FOUND     ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_OBJECT_NAME_NOT_FOUND"},
    {STATUS_OBJECT_PATH_NOT_FOUND     ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_OBJECT_PATH_NOT_FOUND"},
    {STATUS_OBJECT_PATH_SYNTAX_BAD    ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_INVALID_ADDRESS"},
    {STATUS_OBJECT_TYPE_MISMATCH      ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_OBJECT_TYPE_MISMATCH"},
    {STATUS_OBJECTID_EXISTS           ,FrsErrorConflict        ,FrsSeverityInfo,         "STATUS_OBJECTID_EXISTS"},
    {STATUS_OBJECTID_NOT_FOUND        ,FrsErrorNotFound        ,FrsSeverityInfo,         "STATUS_OBJECTID_NOT_FOUND"},
    {STATUS_OPLOCK_NOT_GRANTED        ,FrsErrorAccess          ,FrsSeverityInfo,         "STATUS_OPLOCK_NOT_GRANTED"},
    {STATUS_PORT_ALREADY_SET          ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_PORT_ALREADY_SET"},
    {STATUS_PRIVILEGE_NOT_HELD        ,FrsErrorNoPrivileges    ,FrsSeverityServiceFatal, "STATUS_OBJECT_PATH_SYNTAX_BAD"},
    {STATUS_SECTION_NOT_IMAGE         ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_SECTION_NOT_IMAGE"},
    {STATUS_SECTION_PROTECTION        ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_SECTION_PROTECTION"},
    {STATUS_SHARING_VIOLATION         ,FrsErrorAccess          ,FrsSeverityInfo,         "STATUS_SHARING_VIOLATION"},
    {STATUS_UNABLE_TO_FREE_VM         ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_UNABLE_TO_FREE_VM"},
    {STATUS_UNABLE_TO_DELETE_SECTION  ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_UNABLE_TO_DELETE_SECTION"},
    {STATUS_WORKING_SET_LIMIT_RANGE   ,FrsErrorBadParam        ,FrsSeverityServiceFatal, "STATUS_WORKING_SET_LIMIT_RA"},

    {STATUS_SUCCESS                   ,FrsErrorSuccess         ,FrsSeverityIgnore      , "STATUS_SUCCESS"}  // MUST BE LAST.
};


//
// If code does not appear in above list it gets added to this list.
//
#define SIZE_OF_NT_EXTENDED_MSG_TABLE  20
FRS_NT_ERROR_MSG_TABLE FrsNtErrorMsgTableExt[SIZE_OF_NT_EXTENDED_MSG_TABLE];
ULONG  FrsNtErrorMsgTableExtUsed = 0;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **        J E T   E R R O R   D E S C R I P T I O N   T A B L E              **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// This error table translates Jet Errors to an FRS_ERROR_CODE class and an
// associated severity level.  It also has a message string.  See frserror.h
//

typedef struct _FRS_JET_ERROR_MSG_TABLE {
    LONG                JetErrorCode;
    PCHAR               JetErrorMsgTag;
    FRS_ERROR_CODE      FrsErrorCode;
    FRS_ERROR_SEVERITY  FrsErrorSeverity;
    PCHAR               JetErrorMsg;
} FRS_JET_ERROR_MSG_TABLE, *PFRS_JET_ERROR_MSG_TABLE;

//
//    JET error code                    Error Msg Tag                 FRS Error Code             FRS Severity            JET Error message
//
FRS_JET_ERROR_MSG_TABLE FrsJetErrorMsgTable[] = {
    { JET_errAccessDenied             ,"AccessDenied"              ,FrsErrorAccess           , FrsSeverityServiceFatal, "Cannot access file, the file is locked or in use"},
    { JET_errBadDbSignature           ,"BadDbSignature"            ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Bad signature for a db file"},
    { JET_errBadLogSignature          ,"BadLogSignature"           ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Bad signature for a log file"},
    { JET_errBadLogVersion            ,"BadLogVersion"             ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Version of log file is not compatible with Jet version"},
    { JET_errCannotDisableVersioning  ,"CannotDisableVersioning"   ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Cannot disable versioning for this database"},
    { JET_errColumnNotFound           ,"ColumnNotFound"            ,FrsErrorInternalError    , FrsSeverityServiceFatal, "No such column"},
    { JET_errDatabaseCorrupted        ,"DatabaseCorrupted"         ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Non-db file or corrupted db"},
    { JET_errDatabaseDuplicate        ,"DatabaseDuplicate"         ,FrsErrorAccess           , FrsSeverityServiceFatal, "Database already exists"},
    { JET_errDatabaseFileReadOnly     ,"DatabaseFileReadOnly"      ,FrsErrorAccess           , FrsSeverityServiceFatal, "Attach a readonly database file for read/write operations"},
    { JET_errDatabaseInUse            ,"DatabaseInUse"             ,FrsErrorAccess           , FrsSeverityServiceFatal, "Database in use"},
    { JET_errDatabaseInconsistent     ,"DatabaseInconsistent"      ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Database is in inconsistent state"},
    { JET_errDatabaseInvalidName      ,"DatabaseInvalidName"       ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Invalid database name"},
    { JET_errDatabaseInvalidPages     ,"DatabaseInvalidPages"      ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Invalid number of pages"},
    { JET_errDatabaseLocked           ,"DatabaseLocked"            ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Database exclusively locked"},
    { JET_errDatabaseNotFound         ,"DatabaseNotFound"          ,FrsErrorDatabaseNotFound , FrsSeverityServiceFatal, "No such database"},
    { JET_errFileNotFound             ,"FileNotFound"              ,FrsErrorDatabaseNotFound , FrsSeverityWarning,      "Database File not found"},
    { JET_errDiskFull                 ,"DiskFull"                  ,FrsErrorDiskSpace        , FrsSeverityServiceFatal, "No space left on disk"},
    { JET_errDiskIO                   ,"DiskIO"                    ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Disk IO error"},
    { JET_errKeyDuplicate             ,"KeyDuplicate"              ,FrsErrorKeyDuplicate     , FrsSeverityWarning,      "Illegal duplicate key"},
    { JET_errFileAccessDenied         ,"FileAccessDenied"          ,FrsErrorAccess           , FrsSeverityServiceFatal, "Cannot access file"},
    { JET_errIllegalOperation         ,"IllegalOperation"          ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Operation not supported on table"},
    { JET_errIndexInvalidDef          ,"IndexInvalidDef"           ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Illegal/invalid index definition"},
    { JET_errInvalidBufferSize        ,"InvalidBufferSize"         ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Data buffer doesn't match column size"},
    { JET_errInvalidColumnType        ,"InvalidColumnType"         ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Invalid column data type"},
    { JET_errInvalidDatabase          ,"InvalidDatabase"           ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Not a database file"},
    { JET_errInvalidFilename          ,"InvalidFilename"           ,FrsErrorAccess           , FrsSeverityServiceFatal, "Filename is invalid"},
    { JET_errInvalidName              ,"InvalidName"               ,FrsErrorAccess           , FrsSeverityServiceFatal, "Invalid name"},
    { JET_errInvalidObject            ,"InvalidObject"             ,FrsErrorAccess           , FrsSeverityWarning,      "Object is invalid for operation"},
    { JET_errInvalidParameter         ,"InvalidParameter"          ,FrsErrorBadParam         , FrsSeverityReplicaFatal, "Invalid API parameter"},
    { JET_errInvalidPath              ,"InvalidPath"               ,FrsErrorAccess           , FrsSeverityServiceFatal, "Invalid file path"},
    { JET_errInvalidSesid             ,"InvalidSesid"              ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "System parameters were set improperly"},
    { JET_errInvalidSettings          ,"InvalidSettings"           ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "Invalid session handle"},
    { JET_errInvalidTableId           ,"InvalidTableId"            ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "Invalid table id"},
    { JET_errLogCorrupted             ,"LogCorrupted"              ,FrsErrorDatabaseCorrupted, FrsSeverityServiceFatal, "Logs could not be interpreted"},
    { JET_errLogDiskFull              ,"LogDiskFull"               ,FrsErrorDiskSpace        , FrsSeverityServiceFatal, "Log disk full"},
    { JET_errLogWriteFail             ,"LogWriteFail"              ,FrsErrorDiskSpace        , FrsSeverityServiceFatal, "Fail when writing to log file"},
    { JET_errMissingLogFile           ,"MissingLogFile"            ,FrsErrorDatabaseNotFound , FrsSeverityServiceFatal, "current log file missing"},
    { JET_errNoCurrentRecord          ,"NoCurrentRecord"           ,FrsErrorInternalError    , FrsSeverityWarning,      "Currency not on a record"},
    { JET_errNotInitialized           ,"NotInitialized"            ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "JetInit not yet called"},
    { JET_errObjectNotFound           ,"ObjectNotFound"            ,FrsErrorNotFound         , FrsSeverityInfo        , "No such table or object"},
    { JET_errOutOfCursors             ,"OutOfCursors"              ,FrsErrorResource         , FrsSeverityServiceFatal, "Out of table cursors"},
    { JET_errOutOfDatabaseSpace       ,"OutOfDatabaseSpace"        ,FrsErrorDiskSpace        , FrsSeverityServiceFatal, "Maximum database size reached"},
    { JET_errOutOfFileHandles         ,"OutOfFileHandles"          ,FrsErrorResource         , FrsSeverityServiceFatal, "Out of file handles"},
    { JET_errOutOfMemory              ,"OutOfMemory"               ,FrsErrorResource         , FrsSeverityServiceFatal, "Out of Memory"},
    { JET_errOutOfSessions            ,"OutOfSessions"             ,FrsErrorResource         , FrsSeverityServiceFatal, "Out of sessions"},
    { JET_errPermissionDenied         ,"PermissionDenied"          ,FrsErrorAccess           , FrsSeverityServiceFatal, "Permission denied"},
    { JET_errReadVerifyFailure        ,"ReadVerifyFailure"         ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Read verification error"},
    { JET_errRecordDeleted            ,"RecordDeleted"             ,FrsErrorNotFound         , FrsSeverityInfo        , "Record has been deleted"},
    { JET_errRecordPrimaryChanged     ,"RecordPrimaryChanged"      ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Primary key may not change"},
    { JET_errRecordNotFound           ,"RecordNotFound"            ,FrsErrorNotFound         , FrsSeverityInfo        , "The key was not found"},
    { JET_errRecordTooBig             ,"RecordTooBig"              ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "Record larger than maximum size"},
    { JET_errSecondaryIndexCorrupted  ,"SecondaryIndexCorrupted"   ,FrsErrorJetSecIndexCorrupted, FrsSeverityWarning     , "Jet non-error (upgrade/collating thing)"},
    { JET_errTableLocked              ,"TableLocked"               ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "Table is exclusively locked"},
    { JET_errTableDuplicate           ,"TableDuplicate"            ,FrsErrorConflict         , FrsSeverityInfo        , "Table already exists"},
    { JET_errTableInUse               ,"TableInUse"                ,FrsErrorInternalError    , FrsSeverityIgnore      , "Table is in use, cannot lock"},
    { JET_errTempFileOpenError        ,"TempFileOpenError"         ,FrsErrorAccess           , FrsSeverityReplicaFatal, "Temp file could not be opened"},
    { JET_errTermInProgress           ,"TermInProgress"            ,FrsErrorShuttingDown     , FrsSeverityReplicaFatal, "Termination in progress"},
    { JET_errTooManyAttachedDatabases ,"TooManyAttachedDatabases"  ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Too many attached databases"},
    { JET_errTooManyOpenDatabases     ,"TooManyOpenDatabases"      ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Too many open databases"},
    { JET_errTooManyOpenTables        ,"TooManyOpenTables"         ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Cannot open any more tables"},
    { JET_errVersionStoreOutOfMemory  ,"VersionStoreOutOfMemory"   ,FrsErrorInternalError    , FrsSeverityServiceFatal, "Version store out of memory"},
    { JET_errWriteConflict            ,"WriteConflict"             ,FrsErrorDbWriteConflict  , FrsSeverityInfo        , "Write lock failed due to outstanding write lock"},
    { JET_wrnBufferTruncated          ,"BufferTruncated"           ,FrsErrorInfo             , FrsSeverityInfo        , "Buffer too small for data"},
    { JET_wrnColumnNull               ,"ColumnNull"                ,FrsErrorNotFound         , FrsSeverityInfo        , "Column is NULL-valued"},
    { JET_wrnDatabaseAttached         ,"DatabaseAttached"          ,FrsErrorInternalError    , FrsSeverityReplicaFatal, "Database is already attached"},
    { JET_wrnFileOpenReadOnly         ,"FileOpenReadOnly"          ,FrsErrorAccess           , FrsSeverityServiceFatal, "Database file is read only"},
    { JET_wrnSeekNotEqual             ,"SeekNotEqual"              ,FrsErrorInfo             , FrsSeverityInfo        , "SeekLE or SeekGE didn't find exact match"},
    { JET_wrnTableEmpty               ,"TableEmpty"                ,FrsErrorAccess           , FrsSeverityIgnore      , "Open an empty table"},

    { JET_errSuccess                  ,"Success"                   ,FrsErrorSuccess          , FrsSeverityIgnore      , "Success"}  // MUST BE LAST.
};


//
// If code does not appear in above list it gets added to this list.
//
#define SIZE_OF_JET_EXTENDED_MSG_TABLE  20
FRS_JET_ERROR_MSG_TABLE FrsJetErrorMsgTableExt[SIZE_OF_JET_EXTENDED_MSG_TABLE];
ULONG  FrsJetErrorMsgTableExtUsed = 0;


//
// Win32 to FRS error code translation table.
//
typedef struct _FRS_WIN32_ERROR_MAP {
    DWORD               Win32ErrorCode;
    FRS_ERROR_CODE      FrsErrorCode;
} FRS_WIN32_ERROR_MAP, *PFRS_WIN32_ERROR_MAP;

FRS_WIN32_ERROR_MAP FrsWin32ErrorMap[] = {

    { ERROR_ACCESS_DENIED          ,FrsErrorAccess            },
    { ERROR_BAD_PATHNAME           ,FrsErrorBadPathname       },
    { ERROR_DIR_NOT_EMPTY          ,FrsErrorDirNotEmpty       },
    { ERROR_DISK_FULL              ,FrsErrorDiskSpace         },
    { ERROR_FILE_EXISTS            ,FrsErrorFileExists        },
    { ERROR_FILE_NOT_FOUND         ,FrsErrorNotFound          },
    { ERROR_GEN_FAILURE            ,FrsErrorInternalError     },
    { ERROR_HANDLE_DISK_FULL       ,FrsErrorDiskSpace         },
    { ERROR_INSUFFICIENT_BUFFER    ,FrsErrorBufferOverflow    },
    { ERROR_INVALID_FUNCTION       ,FrsErrorInvalidOperation  },
    { ERROR_INVALID_PARAMETER      ,FrsErrorBadParam          },
    { ERROR_MORE_DATA              ,FrsErrorBufferOverflow    },
    { ERROR_OPERATION_ABORTED      ,FrsErrorRequestCancelled  },
    { ERROR_OPLOCK_NOT_GRANTED     ,FrsErrorOplockNotGranted  },
    { ERROR_RETRY                  ,FrsErrorRetry             },
    { ERROR_SHARING_VIOLATION      ,FrsErrorSharingViolation  },

    { ERROR_SUCCESS                ,FrsErrorSuccess   }  // MUST BE LAST.
};



FRS_ERROR_CODE
FrsTranslateWin32Error(
    IN DWORD WStatus
    )
/*++

Routine Description:

    This routine translates a Win32 error code to an FRS error code.
    It returns the FRS error code.

Arguments:

    WStatus - The Win32 error code.

Return Value:

    FRS error code.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsTranslateWin32Error:"

    PFRS_WIN32_ERROR_MAP FrsErrTable = FrsWin32ErrorMap;

    //
    // skip lookup if called with success status.
    //
    if (WIN_SUCCESS(WStatus)) {
        return FrsErrorSuccess;
    }

    //
    // Look thru the table for a match on the Win32 error code.
    // The table ends with a ERROR_SUCCESS entry in the Win32ErrorCode field.
    //
    while (FrsErrTable->Win32ErrorCode != ERROR_SUCCESS) {
        if (FrsErrTable->Win32ErrorCode == WStatus) {
            break;
        }
        FrsErrTable += 1;
    }

    if (FrsErrTable->Win32ErrorCode != ERROR_SUCCESS) {
        return FrsErrTable->FrsErrorCode;
    }

    //
    // Win32 error code not in the table.
    //
    DPRINT1(1, "Win32 Error code, %08x, Not present in FrsWin32ErrorMap.\n", WStatus);

    return FrsErrorInternalError;
}


FRS_ERROR_CODE
FrsTranslateNtError(
    IN NTSTATUS Status,
    IN BOOL     BPrint
    )
/*++

Routine Description:

    This routine translates NT error codes to a smaller set of FRS error codes
    and optionally prints a message.  It returns the FRS error code.

Arguments:

    Status - The NT error code.

    BPrint - If true print the error message.

Return Value:

    FRS error code.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsTranslateNtError:"

    USHORT Severity;

    USHORT Level[FRS_MAX_ERROR_SEVERITY];

    PFRS_NT_ERROR_MSG_TABLE FrsErrTable = FrsNtErrorMsgTable;
    //
    // skip lookup if called with success status.
    //
    if (NT_SUCCESS(Status)) {
        return FrsErrorSuccess;
    }

    //
    // Look thru the table for a match on the NT error code.
    // The table ends with a STATUS_SUCCESS entry in the Status field.
    //
    while (FrsErrTable->Status != STATUS_SUCCESS) {
        if (FrsErrTable->Status == Status) {
            break;
        }
        FrsErrTable += 1;
    }

    if (FrsErrTable->Status != STATUS_SUCCESS) {
        //
        // Found a match.
        //
        if (BPrint) {
            //
            // Translate the FRS severity to a DPRINT serverity level
            //
            Level[FrsSeverityServiceFatal] = 0;
            Level[FrsSeverityReplicaFatal] = 0;
            Level[FrsSeverityException]    = 1;
            Level[FrsSeverityWarning]      = 3;
            Level[FrsSeverityInfo]         = 5;
            Level[FrsSeverityIgnore]       = 5;

            Severity = Level[FrsErrTable->FrsErrorSeverity];


            DPRINT2(Severity, "NTStatus %08x -- %s\n", Status, FrsErrTable->ErrorMsg);
        }

        return FrsErrTable->FrsErrorCode;
    }

    //
    // NT error code not in the table so be happy.
    //

    DPRINT1(1, "NT Error: %08x, Not present in FrsNtErrorMsgTable. \n", Status);

    return FrsErrorInternalError;
}


ULONG
DisplayNTStatusSev(
    IN ULONG    Sev,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine translates NT error codes to a smaller set of FRS error codes
    and prints a message describing the NT status.  It returns the FRS error code.

    Nothing is printed if NT_SUCCESS(Status) is true.

    If NT_SUCCESS(Status) is not TRUE then GetLastError is called and the
    Win32 message is printed.

    The message is printed at the indicated severity level.

Arguments:

    Sev    - dprint severity
    Status - The NT error code.

Return Value:

    FRS error code.

--*/
{
#undef DEBSUB
#define DEBSUB "DisplayNTStatusSev:"

    ULONG WStatus;
    ULONG FStatus;

    FStatus = FrsTranslateNtError(Status, TRUE);

    if (FStatus != FrsErrorSuccess) {
        //
        // Check for a win32 error.
        //
        WStatus = GetLastError();
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1(Sev, "GetLastError returned (dec): %d\n", WStatus );
            DisplayErrorMsg(Sev, WStatus);
        }

        return FStatus;
    }

    return FrsErrorSuccess;
}


ULONG
DisplayNTStatus(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine translates NT error codes to a smaller set of FRS error codes
    and prints a message describing the NT status.  It returns the FRS error code.

    Nothing is printed if NT_SUCCESS(Status) is true.

    If NT_SUCCESS(Status) is not TRUE then GetLastError is called and the
    Win32 message is printed.

Arguments:

    Status - The NT error code.

Return Value:

    FRS error code.

--*/
{
#undef DEBSUB
#define DEBSUB "DisplayNTStatus:"
    return (DisplayNTStatusSev(0, Status));
}



ULONG
FrsSetLastNTError(
    NTSTATUS Status
    )
/*++

Routine Description:

    Translate NT status codes to WIN32 status codes for those functions that
    make NT calls.  Map a few status values differently.

Arguments:

    Status - the NTstatus to map.

Return Value:

    The WIN32 status.  Also puts this into LastError.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetLastNTError:"

    ULONG WStatus;

    //
    // Do the standard system mapping first.
    //
    WStatus = RtlNtStatusToDosError( Status );

    //
    // If we try to generate a staging file and get the NT status that delete
    // is pending or the file is deleted then treat it as file not found
    // rather than Access Denied.  The later is a hard failure that will stop
    // file replication if it happens on a directory.  FileNotFound just means
    // the user deleted the file before we could do the propagation.
    //
    // Currently (March, 98) the following NT errors map into ERROR_ACCESS_DENIED.
    //     STATUS_INVALID_LOCK_SEQUENCE        STATUS_THREAD_IS_TERMINATING
    //     STATUS_INVALID_VIEW_SIZE            STATUS_DELETE_PENDING
    //     STATUS_ALREADY_COMMITTED            STATUS_FILE_IS_A_DIRECTORY
    //     STATUS_ACCESS_DENIED                STATUS_PROCESS_IS_TERMINATING
    //     STATUS_PORT_CONNECTION_REFUSED      STATUS_CANNOT_DELETE
    //                                         STATUS_FILE_DELETED
    // Update: Currently (Feb, 2001) STATUS_DELETE_PENDING maps to
    // ERROR_DELETE_PENDING. This change has broken some code. We need to
    // handle it here. The macro WIN_NOT_FOUND was updated too.
    //
    if (WStatus == ERROR_ACCESS_DENIED) {
       if (Status == STATUS_FILE_DELETED) {
           WStatus = ERROR_FILE_NOT_FOUND;
       } else if (Status == STATUS_DELETE_PENDING) {
           WStatus = ERROR_DELETE_PENDING;
       }
    }

    SetLastError( WStatus );
    return WStatus;
}



//
// Dump out the windows error message string.
//
VOID
DisplayErrorMsg(
    IN ULONG    Severity,
    IN ULONG    WindowsErrorCode
    )
{
#undef DEBSUB
#define DEBSUB "DisplayErrorMsg:"

    LPVOID lpMsgBuf;

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        WindowsErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR) &lpMsgBuf,
        0,
        NULL
        );

    DPRINT1(Severity, "Msg: %S\n", lpMsgBuf);
    LocalFree( lpMsgBuf );
}



PCHAR
ErrLabelW32(
    ULONG WStatus
    )
/*++

Routine Description:

    Return a ptr to the Win32 error code label.

Arguments:

    WStatus - a win32 error status.

Return Value:

    Ptr to the win 32 error status label string.

--*/
{
#undef DEBSUB
#define DEBSUB "ErrLabelW32:"

    PFRS_WIN32_ERROR_MSG_TABLE  Entry;
    ULONG i;

    Entry = FrsWin32ErrorMsgTable;
    //
    // Scan table looking for match.  Null msg ends table.
    //
    while (Entry->ErrorMsg != NULL) {

        if (Entry->ErrorCode == WStatus) {
            return Entry->ErrorMsg;
        }
        Entry++;
    }


    //
    // Scan the extended error table where new entries are put.
    //
    Entry = FrsWin32ErrorMsgTableExt;
    for (i = 0; i < FrsWin32ErrorMsgTableExtUsed; i++) {

        if (Entry->ErrorCode == WStatus) {
            return Entry->ErrorMsg;
        }
        Entry++;
    }

    //
    // Out of space?
    //
    if (FrsWin32ErrorMsgTableExtUsed >= SIZE_OF_FRSWIN32_EXTENDED_MSG_TABLE) {
        return "???";
    }

    i = InterlockedIncrement(&FrsWin32ErrorMsgTableExtUsed) - 1;

    if (i >= SIZE_OF_FRSWIN32_EXTENDED_MSG_TABLE) {
        return "???";
    }

    //
    // Create new entry.
    //
    Entry = &FrsWin32ErrorMsgTableExt[i];

    Entry->ErrorCode = WStatus;
    Entry->ErrorMsg = FrsAlloc(16);
    _snprintf(Entry->ErrorMsg, 16, "%d-???", WStatus);
    Entry->ErrorMsg[15] = '\0';

    return Entry->ErrorMsg;
}


PCHAR
ErrLabelNT(
    NTSTATUS Status
    )
/*++

Routine Description:

    Return a ptr to the NT error code label.

Arguments:

    Status - an NTStatus error status.

Return Value:

    Ptr to the NT error status label string.

--*/
{
#undef DEBSUB
#define DEBSUB "ErrLabelNT:"

    PFRS_NT_ERROR_MSG_TABLE  Entry;
    ULONG i;

    Entry = FrsNtErrorMsgTable;
    //
    // skip lookup if called with success status.
    //
    if (Status == STATUS_SUCCESS) {
        return "Success";
    }

    //
    // Look thru the table for a match on the NT error code.
    // The table ends with a STATUS_SUCCESS entry.
    //
    while (Entry->Status != STATUS_SUCCESS) {
        if (Entry->Status == Status) {
            return Entry->ErrorMsg;
        }
        Entry += 1;
    }

    //
    // Scan the extended error table where new entries are put.
    //
    Entry = FrsNtErrorMsgTableExt;
    for (i = 0; i < FrsNtErrorMsgTableExtUsed; i++) {

        if (Entry->Status == Status) {
            return Entry->ErrorMsg;
        }
        Entry += 1;
    }

    //
    // Out of space?
    //
    if (FrsNtErrorMsgTableExtUsed >= SIZE_OF_NT_EXTENDED_MSG_TABLE) {
        return "???";
    }

    i = InterlockedIncrement(&FrsNtErrorMsgTableExtUsed) - 1;

    if (i >= SIZE_OF_NT_EXTENDED_MSG_TABLE) {
        return "???";
    }

    //
    // Create new entry.
    //
    Entry = &FrsNtErrorMsgTableExt[i];

    Entry->Status = Status;
    Entry->ErrorMsg = FrsAlloc(16);
    _snprintf(Entry->ErrorMsg, 16, "%08x-???", Status);
    Entry->ErrorMsg[15] = '\0';

    return Entry->ErrorMsg;
}


PCHAR
ErrLabelFrs(
    ULONG FStatus
    )
/*++

Routine Description:

    Return a ptr to the Frs error code label.

Arguments:

    FStatus - an FRS error status.

Return Value:

    Ptr to the Frs error status label string.

--*/
{
#undef DEBSUB
#define DEBSUB "ErrLabelFrs:"

    PFRS_ERROR_MSG_TABLE  Entry;
    ULONG i;

    Entry = FrsErrorMsgTable;
    //
    // Scan table looking for match.  Null msg ends table.
    //
    while (Entry->ErrorMsg != NULL) {

        if (Entry->ErrorCode == FStatus) {
            return Entry->ErrorMsg;
        }
        Entry++;
    }


    //
    // Scan the extended error table where new entries are put.
    //
    Entry = FrsErrorMsgTableExt;
    for (i = 0; i < FrsErrorMsgTableExtUsed; i++) {

        if (Entry->ErrorCode == FStatus) {
            return Entry->ErrorMsg;
        }
        Entry++;
    }

    //
    // Out of space?
    //
    if (FrsErrorMsgTableExtUsed >= SIZE_OF_FRS_EXTENDED_MSG_TABLE) {
        return "???";
    }

    i = InterlockedIncrement(&FrsErrorMsgTableExtUsed) - 1;

    if (i >= SIZE_OF_FRS_EXTENDED_MSG_TABLE) {
        return "???";
    }

    //
    // Create new entry.
    //
    Entry = &FrsErrorMsgTableExt[i];

    Entry->ErrorCode = FStatus;
    Entry->ErrorMsg = FrsAlloc(16);
    _snprintf(Entry->ErrorMsg, 16, "%d-???", FStatus);
    Entry->ErrorMsg[15] = '\0';

    return Entry->ErrorMsg;
}



PCHAR
ErrLabelJet(
    LONG jerr
    )
/*++

Routine Description:

    Return a ptr to the Jet error code label.

Arguments:

    jerr - the jet error status.

Return Value:

    Ptr to the jet error status label string.

--*/
{
#undef DEBSUB
#define DEBSUB "ErrLabelJet:"

    PFRS_JET_ERROR_MSG_TABLE Entry = FrsJetErrorMsgTable;
    ULONG i;
    //
    // skip lookup if called with success status.
    //
    if (JET_SUCCESS(jerr)) {
        return "Success";
    }

    //
    // Look thru the table for a match on the jet error code.
    // The table ends with a JER_errSuccess entry in the JetErrorCode field.
    //
    while (!JET_SUCCESS(Entry->JetErrorCode)) {
        if (Entry->JetErrorCode == jerr) {
            return Entry->JetErrorMsgTag;
        }
        Entry += 1;
    }

    //
    // Scan the extended error table where new entries are put.
    //
    Entry = FrsJetErrorMsgTableExt;
    for (i = 0; i < FrsJetErrorMsgTableExtUsed; i++) {

        if (Entry->JetErrorCode == jerr) {
            return Entry->JetErrorMsgTag;
        }
        Entry += 1;
    }

    //
    // Out of space?
    //
    if (FrsJetErrorMsgTableExtUsed >= SIZE_OF_JET_EXTENDED_MSG_TABLE) {
        return "???";
    }

    i = InterlockedIncrement(&FrsJetErrorMsgTableExtUsed) - 1;

    if (i >= SIZE_OF_JET_EXTENDED_MSG_TABLE) {
        return "???";
    }

    //
    // Create new entry.
    //
    Entry = &FrsJetErrorMsgTableExt[i];

    Entry->JetErrorCode = jerr;
    Entry->JetErrorMsgTag = FrsAlloc(16);
    _snprintf(Entry->JetErrorMsgTag, 16, "%d-???", jerr);
    Entry->JetErrorMsgTag[15] = '\0';

    return Entry->JetErrorMsgTag;
}


FRS_ERROR_CODE
DbsTranslateJetError0(
    IN JET_ERR jerr,
    IN BOOL    BPrint
    )
/*++

Routine Description:

    This routine translates jet error codes to a smaller set of FRS error codes
    and optionally prints a message.  It returns the FRS error code.

Arguments:

    jerr - The jet error code.

    BPrint - If true print the error message.

Return Value:

    FRS error code.

--*/
{
#undef DEBSUB
#define DEBSUB "DbsTranslateJetError0:"

    USHORT Severity;

    USHORT Level[FRS_MAX_ERROR_SEVERITY];

    PFRS_JET_ERROR_MSG_TABLE FrsErrTable = FrsJetErrorMsgTable;
    //
    // skip lookup if called with success status.
    //
    if (JET_SUCCESS(jerr)) {
        return FrsErrorSuccess;
    }

    //
    // Look thru the table for a match on the jet error code.
    // The table ends with a JER_errSuccess entry in the JetErrorCode field.
    //
    while (FrsErrTable->JetErrorCode != JET_errSuccess) {
        if (FrsErrTable->JetErrorCode == jerr) {
            break;
        }
        FrsErrTable += 1;
    }

    if (!JET_SUCCESS(FrsErrTable->JetErrorCode)) {
        //
        // Found a match.
        //
        if (BPrint) {
            //
            // Translate the FRS severity to a DPRINT serverity level
            //
            Level[FrsSeverityServiceFatal] = 0;
            Level[FrsSeverityReplicaFatal] = 0;
            Level[FrsSeverityException]    = 1;
            Level[FrsSeverityWarning]      = 3;
            Level[FrsSeverityInfo]         = 5;
            Level[FrsSeverityIgnore]       = 5;

            Severity = Level[FrsErrTable->FrsErrorSeverity];

            DPRINT2(Severity, "Jet related FRS error: %d - %s\n",
                    jerr, FrsErrTable->JetErrorMsg);
        }

        return FrsErrTable->FrsErrorCode;
    }

    //
    // Jet error code not in the table so be happy.
    //

    DPRINT1(0, "Jet Error: %d, Not present in FrsJetErrorMsgTable. Treated as service fatal.\n", jerr);

    return FrsErrorInternalError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsrpc_c_stub.c ===
#include "frsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsevent.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
        frsevent.c

Abstract:
        Provide an interface to the event logging stuff. Currently, these are just
        dummy routines.

Author:
        Billy J. Fuller 20-Mar-1997 (From Jim McNelis)

Environment
        User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSEVENT:"

#include <frs.h>

VOID
LogFrsException(
        FRS_ERROR_CODE Code,
        ULONG_PTR Err,
        PWCHAR ErrMsg
        )
/*++
Routine Description:
        Dummy routine

Arguments:
        Code - FRS exception code
        Err  - ExceptionInformation[0]
        ErrMsg - Text describing Err

Return Value:
        None.
--*/
{
        if (Err != 0) {
                DPRINT3(1, "Exception %d: %ws %d\n", Code, ErrMsg, Err);
        } else {
                DPRINT2(1, "Exception %d: %ws\n", Code, ErrMsg);
        }
}

VOID
LogException(
        ULONG Code,
        PWCHAR Msg
        )
/*++
Routine Description:
        Dummy routine

Arguments:
        Code - FRS exception code
        Msg - Text describing Code

Return Value:
        None.
--*/
{
        DPRINT2(1, "Exception %d: %ws\n", Code, Msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsexcpt.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
        frsexcpt.c

Abstract:
        Temporary -- This routine will be replaced with the standard
        exception handling functions.

Author:
        Billy J. Fuller 25-Mar-1997

Environment
        User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop

#define DEBSUB  "FRSEXCPT:"

#include <frs.h>

static DWORD     LastCode = 0;
static ULONG_PTR LastInfo = 0;
static BOOL             Quiet = FALSE;

DWORD
FrsExceptionLastCode(
        VOID
        )
/*++
Routine Description:
        For testing, return the exception code from the last exception

Arguments:
        None.

Return Value:
        The exception code from the last exception, if any.
--*/
{
        return LastCode;
}

ULONG_PTR
FrsExceptionLastInfo(
        VOID
        )
/*++
Routine Description:
        For testing, return the information word from the last exception

Arguments:
        None.

Return Value:
        The information word from the last exception, if any.
--*/
{
        return LastInfo;
}

VOID
FrsExceptionQuiet(
        BOOL Desired
        )
/*++
Routine Description:
        For testing, disable/enable printing exception messages

Arguments:
        Desired - TRUE disables messages; FALSE enables

Return Value:
        None.
--*/
{
        Quiet = Desired;
}

#define FRS_NUM_EXCEPTION_INFO  (1)
VOID
FrsRaiseException(
        FRS_ERROR_CODE FrsError,
        ULONG_PTR Err
        )
/*++
Routine Description:
        Fill in the exception info and raise the specified exception

Arguments:
        FrsError        - enum specifying the exception number
        Err                     - Additional info about the exception

Return Value:
        None.
--*/
{
        ULONG_PTR ExceptInfo[FRS_NUM_EXCEPTION_INFO];

        ExceptInfo[0] = Err;
        RaiseException(FrsError, 0, FRS_NUM_EXCEPTION_INFO, ExceptInfo);
}

ULONG
FrsException(
        EXCEPTION_POINTERS *ExceptionPointers
        )
/*++
Routine Description:
        This is an expression in an except command. Handle the specified exception.
        If the exception is catastrophic (e.g., access violation), kick the problem
        upstream to the next exception handler.

Arguments:
        ExceptionPointers       - returned by GetExceptionInformation

Return Value:
        EXCEPTION_CONTIUE_SEARCH        - catastrophic exception; kick it upstairs
        EXCEPTION_EXECUTE_HANDLER       - frs will handle this exception
--*/
{
        ULONG                           ExceptionCode;
        ULONG_PTR                       ExceptionInfo;
        EXCEPTION_RECORD        *ExceptionRecord;

        //
        // Pull the exception code and the additional error code (if any)
        //
        ExceptionRecord = ExceptionPointers->ExceptionRecord;
        ExceptionCode = ExceptionRecord->ExceptionCode;
        ExceptionInfo = ExceptionRecord->ExceptionInformation[0];

        //
        // For testing
        //
        LastCode = ExceptionCode;
        LastInfo = ExceptionInfo;

        //
        // Don't log exceptions
        //
        if (Quiet) {
                switch (ExceptionCode) {

                case EXCEPTION_ACCESS_VIOLATION:                // these exceptions are not handled
                case EXCEPTION_BREAKPOINT:
                case EXCEPTION_SINGLE_STEP:
                case EXCEPTION_DATATYPE_MISALIGNMENT:   // (added to trap JET problems)
                        return EXCEPTION_CONTINUE_SEARCH;
                default:
                        return EXCEPTION_EXECUTE_HANDLER;
                }
        }

        switch (ExceptionCode) {

        case EXCEPTION_ACCESS_VIOLATION:                // these exceptions are not handled
        case EXCEPTION_BREAKPOINT:
        case EXCEPTION_SINGLE_STEP:
        case EXCEPTION_DATATYPE_MISALIGNMENT:   // (added to trap JET problems)
                LogException(ExceptionCode, L"Hardware Exception is not handled");
                return EXCEPTION_CONTINUE_SEARCH;

//      case FRS_ERROR_MALLOC:
//              LogFrsException(FRS_ERROR_MALLOC, 0, L"Out of Memory");
//              return EXCEPTION_EXECUTE_HANDLER;

        case FRS_ERROR_PROTSEQ:
                LogFrsException(FRS_ERROR_PROTSEQ, ExceptionInfo, L"Can't use RPC ncacn_ip_tcp (TCP/IP); error");
                return EXCEPTION_EXECUTE_HANDLER;

        case FRS_ERROR_REGISTERIF:
                LogFrsException(FRS_ERROR_REGISTERIF, ExceptionInfo, L"Can't register RPC interface; error");
                return EXCEPTION_EXECUTE_HANDLER;

        case FRS_ERROR_INQ_BINDINGS:
                LogFrsException(FRS_ERROR_INQ_BINDINGS, ExceptionInfo, L"Can't get RPC interface bindings; error");
                return EXCEPTION_EXECUTE_HANDLER;

        case FRS_ERROR_REGISTEREP:
                LogFrsException(FRS_ERROR_REGISTEREP, ExceptionInfo, L"Can't register dynamic RPC endpoints; error");
                return EXCEPTION_EXECUTE_HANDLER;

        case FRS_ERROR_LISTEN:
                LogFrsException(FRS_ERROR_LISTEN, ExceptionInfo, L"Can't listen for RPC clients; error");
                return EXCEPTION_EXECUTE_HANDLER;


        default:
                LogException(ExceptionCode, L"Hardware Exception is handled");
                return EXCEPTION_EXECUTE_HANDLER;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsrpc.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frsrpc.c

Abstract:
    Setup the server and client side of authenticated RPC.

Author:
    Billy J. Fuller 20-Mar-1997 (From Jim McNelis)

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <ntfrsapi.h>
#include <dsrole.h>
#include <info.h>
#include <perffrs.h>
#include <perrepsr.h>

extern HANDLE PerfmonProcessSemaphore;
extern BOOL MutualAuthenticationIsEnabled;
extern BOOL MutualAuthenticationIsEnabledAndRequired;

extern CRITICAL_SECTION CritSec_pValidPartnerTableStruct;
extern PFRS_VALID_PARTNER_TABLE_STRUCT pValidPartnerTableStruct;
extern BOOL NeedNewPartnerTable;

//
// KERBEROS is not available on a server that isn't a member of
// a domain. It is possible for the non-member server to be a
// client of a KERBEROS RPC server but that doesn't help NtFrs;
// NtFrs requires server-to-server RPC.
//
BOOL    KerberosIsNotAvailable;

ULONG   MaxRpcServerThreads;   // Maximum number of concurrent server RPC calls
ULONG   RpcPortAssignment;     // User specified port assignment for FRS.

//
// Binding Stats
//
ULONG   RpcBinds;
ULONG   RpcUnBinds;
ULONG   RpcAgedBinds;
LONG    RpcMaxBinds;

//
// Table of sysvols being created
//
PGEN_TABLE  SysVolsBeingCreated;


//
// This table translates the FRS API access check code number to registry key table
// code for the enable/disable registry key check and the rights registry key check.
// The FRS_API_ACCESS_CHECKS enum in config.h defines the indices for the
// this table.  The order of the entries here must match the order of the entries
// in the ENUM.
//
typedef struct _RPC_API_KEYS_ {
    FRS_REG_KEY_CODE  Enable;     // FRS Registry Key Code for the Access Check enable string
    FRS_REG_KEY_CODE  Rights;     // FRS Registry Key Code for the Access Check rights string
    PWCHAR            KeyName;    // Key name for the API.
} RPC_API_KEYS, *PRPC_API_KEYS;

RPC_API_KEYS RpcApiKeys[ACX_MAX] = {

    {FKC_ACCCHK_STARTDS_POLL_ENABLE, FKC_ACCCHK_STARTDS_POLL_RIGHTS, ACK_START_DS_POLL},
    {FKC_ACCCHK_SETDS_POLL_ENABLE,   FKC_ACCCHK_SETDS_POLL_RIGHTS,   ACK_SET_DS_POLL},
    {FKC_ACCCHK_GETDS_POLL_ENABLE,   FKC_ACCCHK_GETDS_POLL_RIGHTS,   ACK_GET_DS_POLL},
    {FKC_ACCCHK_GET_INFO_ENABLE,     FKC_ACCCHK_GET_INFO_RIGHTS,     ACK_INTERNAL_INFO},
    {FKC_ACCCHK_PERFMON_ENABLE,      FKC_ACCCHK_PERFMON_RIGHTS,      ACK_COLLECT_PERFMON_DATA},
    {FKC_ACCESS_CHK_DCPROMO_ENABLE,  FKC_ACCESS_CHK_DCPROMO_RIGHTS,  ACK_DCPROMO},
    {FKC_ACCESS_CHK_IS_PATH_REPLICATED_ENABLE, FKC_ACCESS_CHK_IS_PATH_REPLICATED_RIGHTS, ACK_IS_PATH_REPLICATED},
    {FKC_ACCESS_CHK_WRITER_COMMANDS_ENABLE, FKC_ACCESS_CHK_WRITER_COMMANDS_RIGHTS, ACK_WRITER_COMMANDS}

};



DWORD
UtilRpcServerHandleToAuthSidString(
    IN  handle_t    ServerHandle,
    IN  PWCHAR      AuthClient,
    OUT PWCHAR      *ClientSid
    );

DWORD
FrsRpcCheckAuthIfEnabled(
  IN HANDLE   ServerHandle,
  IN DWORD RpcApiIndex
  );

DWORD
FrsRpcCheckAuthIfEnabledForCommitDemotion(
  IN HANDLE   ServerHandle,
  IN DWORD RpcApiIndex
  );


//
// Used by all calls to RpcBindingSetAuthInfoEx()
//
//  Version set to value indicated by docs
//  Mutual authentication
//  Client doesn't change credentials
//  Impersonation but not delegation
//
RPC_SECURITY_QOS RpcSecurityQos = {
    RPC_C_SECURITY_QOS_VERSION,             // static version
    RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH,     // requires mutual auth
    RPC_C_QOS_IDENTITY_STATIC,              // client credentials don't change
    RPC_C_IMP_LEVEL_IMPERSONATE             // server cannot delegate
    };

#define DPRINT_USER_NAME(Sev)    DPrintUserName(Sev)

ULONG
RcsSubmitCmdPktToRcsQueue(
    IN PCOMMAND_PACKET Cmd,
    IN PCOMM_PACKET    CommPkt,
    IN PWCHAR       AuthClient,
    IN PWCHAR       AuthName,
    IN PWCHAR       AuthSid,
    IN DWORD        AuthLevel,
    IN DWORD        AuthN,
    IN DWORD        AuthZ
    );



PCOMMAND_PACKET
CommPktToCmd(
    IN PCOMM_PACKET CommPkt
    );


DWORD
FrsDsIsPartnerADc(
    IN  PWCHAR      PartnerName
    );

VOID
FrsDsCreateNewValidPartnerTableStruct(
    VOID
    );

DWORD
FrsDsVerifyPromotionParent(
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType
    );

DWORD
FrsDsStartPromotionSeeding(
    IN  BOOL        Inbound,
    IN  PWCHAR      ReplicaSetName,
    IN  PWCHAR      ReplicaSetType,
    IN  PWCHAR      CxtionName,
    IN  PWCHAR      PartnerName,
    IN  PWCHAR      PartnerPrincName,
    IN  PWCHAR      PartnerSid,
    IN  ULONG       PartnerAuthLevel,
    IN  ULONG       GuidSize,
    IN  UCHAR       *CxtionGuid,
    IN  UCHAR       *PartnerGuid,
    OUT UCHAR       *ParentGuid
    );

DWORD
FrsIsPathReplicated(
    IN PWCHAR Path,
    IN ULONG ReplicaSetTypeOfInterest,
    OUT ULONG *Replicated,
    OUT ULONG *Primary,
    OUT ULONG *Root,
    OUT GUID *ReplicaSetGuid
    );


VOID
FrsPrintRpcStats(
    IN ULONG            Severity,
    IN PNTFRSAPI_INFO   Info,        OPTIONAL
    IN DWORD            Tabs
    )
/*++
Routine Description:
    Print the rpc stats into the info buffer or using DPRINT (Info == NULL).

Arguments:
    Severity    - for DPRINT
    Info        - for IPRINT (use DPRINT if NULL)
    Tabs        - indentation for prettyprint

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "FrsPrintRpcStats:"
    WCHAR TabW[MAX_TAB_WCHARS + 1];

    InfoTabs(Tabs, TabW);

    IDPRINT0(Severity, Info, "\n");
    IDPRINT1(Severity, Info, ":S: %wsNTFRS RPC BINDS:\n", TabW);
    IDPRINT2(Severity, Info, ":S: %ws   Binds     : %6d\n", TabW, RpcBinds);
    IDPRINT3(Severity, Info, ":S: %ws   UnBinds   : %6d (%d aged)\n",
             TabW, RpcUnBinds, RpcAgedBinds);
    IDPRINT2(Severity, Info, ":S: %ws   Max Binds : %6d\n", TabW, RpcMaxBinds);
    IDPRINT0(Severity, Info, "\n");
}



PVOID
MIDL_user_allocate(
    IN size_t Bytes
    )
/*++
Routine Description:
    Allocate memory for RPC.
    XXX This should be using davidor's routines.

Arguments:
    Bytes   - Number of bytes to allocate.

Return Value:
    NULL    - memory could not be allocated.
    !NULL   - address of allocated memory.
--*/
{
#undef DEBSUB
#define  DEBSUB  "MIDL_user_allocate:"
    PVOID   VA;

    //
    // Need to check if Bytes == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
    //

    if (Bytes == 0) {
        return NULL;
    }

    VA = FrsAlloc(Bytes);
    return VA;
}


VOID
MIDL_user_free(
    IN PVOID Buffer
    )
/*++
Routine Description:
    Free memory for RPC.
    XXX This should be using davidor's routines.

Arguments:
    Buffer  - Address of memory allocated with MIDL_user_allocate().

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "MIDL_user_free:"
    FrsFree(Buffer);
}





VOID
DPrintUserName(
    IN DWORD Sev
    )
/*++
Routine Description:
    Print our user name

Arguments:
    Sev

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "DPrintUserName:"
    WCHAR   Uname[MAX_PATH + 1];
    ULONG   Unamesize = MAX_PATH + 1;

    if (GetUserName(Uname, &Unamesize)) {
        DPRINT1(Sev, "++ User name is %ws\n", Uname);
    } else {
        DPRINT_WS(0, "++ ERROR - Getting user name;",  GetLastError());
    }
}


RPC_STATUS
DummyRpcCallback (
    IN RPC_IF_ID *Interface,
    IN PVOID Context
    )
/*++
Routine Description:
    Dummy callback routine. By registering this routine, RPC will automatically
    refuse requests from clients that don't include authentication info.

    WARN: Disabled for now because frs needs to run in dcpromo environments
    that do not have any form of authentication.

Arguments:
    Ignored

Return Value:
    RPC_S_OK
--*/
{
#undef DEBSUB
#define  DEBSUB  "DummyRpcCallback:"
    return RPC_S_OK;
}





DWORD
SERVER_FrsNOP(
    handle_t Handle
    )
/*++
Routine Description:
    The frsrpc interface includes a NOP function for pinging
    the server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsNOP:"
    return ERROR_SUCCESS;
}


DWORD
SERVER_FrsRpcSendCommPkt(
    handle_t        Handle,
    PCOMM_PACKET    CommPkt
    )
/*++
Routine Description:
    Receiving a command packet

Arguments:
    None.

Return Value:
    ERROR_SUCCESS - everything was okay
    Anything else - the error code says it all
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsRpcSendCommPkt:"
    DWORD   WStatus = 0;
    DWORD   AuthLevel   = 0;
    DWORD   AuthN       = 0;
    DWORD   AuthZ       = 0;
    PWCHAR  AuthName    = NULL;
    PWCHAR  AuthClient  = NULL;
    PWCHAR  AuthSid     = NULL;
    PCOMMAND_PACKET Cmd = NULL;
    PFRS_VALID_PARTNER_TABLE_STRUCT pVptStruct = NULL;
    PWCHAR CxtionPartnerName = NULL;
    PQHASH_ENTRY pQHashEntry = NULL;

    //
    // Don't send or receive during shutdown
    //
    if (FrsIsShuttingDown) {
        return ERROR_SUCCESS;
    }

    try {
        if (!CommValidatePkt(CommPkt)) {
            WStatus = ERROR_NOT_SUPPORTED;
            DPRINT1(0, ":SR: Comm %08x, [RcvFailAuth - bad packet]", PtrToUlong(CommPkt));
            //
            // Increment the Packets Received in Error Counter
            //
            PM_INC_CTR_SERVICE(PMTotalInst, PacketsRcvdError, 1);
            goto CLEANUP;
        }
#ifndef DS_FREE
        if (!ServerGuid) {
            WStatus = RpcBindingInqAuthClient(Handle,
                                              &AuthClient,
                                              &AuthName,
                                              &AuthLevel,
                                              &AuthN,
                                              &AuthZ);
            DPRINT_WS(4, "++ IGNORED - RpcBindingInqAuthClient;", WStatus);

            COMMAND_RCV_AUTH_TRACE(4, CommPkt, WStatus, AuthLevel, AuthN,
                                   AuthClient, AuthName, "RcvAuth");

            if (!WIN_SUCCESS(WStatus)) {
                WStatus = ERROR_ACCESS_DENIED;
                goto CLEANUP;
            }

            WStatus = UtilRpcServerHandleToAuthSidString(Handle, AuthClient, &AuthSid );

            if (!WIN_SUCCESS(WStatus)) {
                WStatus = ERROR_ACCESS_DENIED;
                goto CLEANUP;
            }

            ACQUIRE_VALID_PARTNER_TABLE_POINTER(&pVptStruct);

            if ((pVptStruct == NULL) ||
                (NULL == QHashLookupLock(pVptStruct->pPartnerTable, AuthSid))) {
                // invalid partner.
                DPRINT2(0, "++ ERROR - Invalid Partner: AuthClient:%ws, AuthSid:%ws\n", AuthClient,AuthSid);
                WStatus = ERROR_ACCESS_DENIED;
                goto CLEANUP;
            }
        } else {
            //
            // For hardwired -- Eventually DS Free configs.
            //
            DPRINT1(4, ":SR: Comm %08x, [RcvAuth - hardwired]", PtrToUlong(CommPkt));
        }
#endif DS_FREE



        //
        // Increment the Packets Received and
        // Packets Received in bytes counters
        //
        PM_INC_CTR_SERVICE(PMTotalInst, PacketsRcvd, 1);
        PM_INC_CTR_SERVICE(PMTotalInst, PacketsRcvdBytes, CommPkt->PktLen);

        switch(CommPkt->CsId) {

        case CS_RS:

            //
            // Convert the comm packet into a command packet
            //
            Cmd = CommPktToCmd(CommPkt);
            if (Cmd == NULL) {
                COMMAND_RCV_TRACE(3, Cmd, NULL, ERROR_INVALID_DATA, "RcvFail - no cmd");
                WStatus =  ERROR_INVALID_DATA;
                goto CLEANUP;
            }

        //
        // Only allow certian cmd types through.  Reject anything else.
        //
        switch (Cmd->Command) {

        case CMD_REMOTE_CO:
        case CMD_RECEIVING_STAGE:
        case CMD_REMOTE_CO_DONE:
        case CMD_ABORT_FETCH:
        case CMD_RETRY_FETCH:
        case CMD_NEED_JOIN:
        case CMD_START_JOIN:
        case CMD_JOINING_AFTER_FLUSH:
        case CMD_JOINING:
        case CMD_JOINED:
        case CMD_UNJOIN_REMOTE:
        case CMD_VVJOIN_DONE:
        case CMD_SEND_STAGE:
            if (!RsCxtion(Cmd)) {
                DPRINT(0, "++ ERROR - No Cxtion");
                WStatus = ERROR_INVALID_DATA;
                goto CLEANUP;
            }
#ifndef DS_FREE
            pQHashEntry = QHashLookupLock(pVptStruct->pPartnerConnectionTable,
                                          RsCxtion(Cmd)->Guid);

            if((pQHashEntry == NULL) ||
               (0 != _wcsicmp((PWCHAR)(pQHashEntry->QData), AuthSid))) {
            // invalid cxtion.
            CHAR        Guid[GUID_CHAR_LEN + 1];
            GuidToStr(RsCxtion(Cmd)->Guid, Guid);

            if (pQHashEntry == NULL) {
                DPRINT2(4, "++ Cxtion %s not found. Partner SID is %ws\n", Guid, AuthSid);
            }else {
                DPRINT3(0, "++ ERROR - Partner SID mismatch for Cxtion %s. Received %ws instead of %ws\n", Guid, AuthSid, (PWCHAR)(pQHashEntry->QData));
            }

            WStatus = ERROR_INVALID_DATA;
            goto CLEANUP;
            }

#endif DS_FREE
            break;

        default:
            DPRINT1(0, "Invalid remote command 0x%x\n", Cmd->Command);
            WStatus = ERROR_INVALID_DATA;
            FrsCompleteCommand(Cmd, ERROR_INVALID_DATA);
            goto CLEANUP;
        }

            WStatus = RcsSubmitCmdPktToRcsQueue(Cmd,
                                                CommPkt,
                                                AuthClient,
                                                AuthName,
                                                AuthSid,
                                                AuthLevel,
                                                AuthN,
                                                AuthZ);
        break;
        default:
            WStatus = ERROR_INVALID_OPERATION;
        COMMAND_RCV_AUTH_TRACE(0, CommPkt, WStatus, AuthLevel, AuthN,
               AuthClient, AuthName, "RcvFailAuth - bad csid");
        }

CLEANUP:;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT2(0, ":SR: Comm %08x, WStatus 0x%08x [RcvFailAuth - exception]", PtrToUlong(CommPkt), WStatus);
    }
    try {
        if (AuthName) {
            RpcStringFree(&AuthName);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

        GET_EXCEPTION_CODE(WStatus);
        DPRINT2(0, ":SR: Comm %08x, WStatus 0x%08x [RcvFailAuth - cleanup exception]", PtrToUlong(CommPkt), WStatus);
    }
#ifndef DS_FREE
    if (pVptStruct) {
        RELEASE_VALID_PARTNER_TABLE_POINTER(pVptStruct);
    }
#endif DS_FREE
    if (AuthSid) {
        FrsFree(AuthSid);
    }

    return WStatus;
}


DWORD
SERVER_FrsEnumerateReplicaPathnames(
    handle_t Handle
    )
/*++
Routine Description:
    NOT IMPLEMENTED - Enumerate the replica sets

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsEnumerateReplicaPathnames:"
    return ERROR_CALL_NOT_IMPLEMENTED;
}





DWORD
SERVER_FrsFreeReplicaPathnames(
    handle_t Handle
    )
/*++
Routine Description:
    NOT IMPLEMENTED - Just a placeholder, it won't really be part of
    the RPC interface but rather a function in the client-side dll.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsFreeReplicaPathnames:"
    return ERROR_CALL_NOT_IMPLEMENTED;
}





DWORD
SERVER_FrsPrepareForBackup(
    handle_t Handle
    )
/*++
Routine Description:
    NOT IMPLEMENTED - Prepare for backup

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsPrepareForBackup:"
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
SERVER_FrsBackupComplete(
    handle_t Handle
    )
/*++
Routine Description:
    NOT IMPLEMENTED - backup is complete; reset state

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsBackupComplete:"
    return ERROR_CALL_NOT_IMPLEMENTED;
}





DWORD
SERVER_FrsPrepareForRestore(
    handle_t Handle
    )
/*++
Routine Description:
    NOT IMPLEMENTED - Prepare for restore

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsPrepareForRestore:"
    return ERROR_CALL_NOT_IMPLEMENTED;
}





DWORD
SERVER_FrsRestoreComplete(
    handle_t Handle
    )
/*++
Routine Description:
    NOT IMPLEMENTED - restore is complete; reset state

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsRestoreComplete:"
    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
FrsRpcAccessChecks(
    IN HANDLE   ServerHandle,
    IN DWORD    RpcApiIndex
    )
/*++
Routine Description:

    Check if the caller has access to this rpc api call.

Arguments:

    ServerHandle - From the rpc runtime

    RpcApiIndex - identifies key in registry

Return Value:

    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcAccessChecks:"
    DWORD   WStatus;
    PWCHAR  WStr = NULL, TrimStr;
    FRS_REG_KEY_CODE   EnableKey, RightsKey;

    DWORD   ValueSize;
    BOOL    RequireRead;
    BOOL    Impersonated = FALSE;
    HKEY    HRpcApiKey = INVALID_HANDLE_VALUE;
    PWCHAR  ApiName;
    WCHAR   ValueBuf[MAX_PATH + 1];



    if (RpcApiIndex >= ACX_MAX) {
        DPRINT1(0, "++ ERROR - ApiIndex out of range.  (%d)\n", RpcApiIndex);
        FRS_ASSERT(!"RpcApiIndexout of range");

        return ERROR_INVALID_PARAMETER;
    }


    EnableKey = RpcApiKeys[RpcApiIndex].Enable;
    RightsKey = RpcApiKeys[RpcApiIndex].Rights;
    ApiName   = RpcApiKeys[RpcApiIndex].KeyName;

    //
    // First go fetch the enable/disable string.
    //
    WStatus = CfgRegReadString(EnableKey, NULL, 0, &WStr);
    if (WStr == NULL) {
        DPRINT1_WS(0, "++ ERROR - API Access enable check for API (%ws) failed.", ApiName, WStatus);
        WStatus = ERROR_NO_TOKEN;
        goto CLEANUP;
    }

    //
    // If access checks are disabled then we're done.
    //
    TrimStr = FrsWcsTrim(WStr, L' ');
    if (WSTR_EQ(TrimStr, ACCESS_CHECKS_ARE_DISABLED) ||
        WSTR_EQ(TrimStr, ACCESS_CHECKS_ARE_DEFAULT_DISABLED)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    if (WSTR_NE(TrimStr, ACCESS_CHECKS_ARE_ENABLED) &&
        WSTR_NE(TrimStr, ACCESS_CHECKS_ARE_DEFAULT_ENABLED)) {
        DPRINT2(0, "++ ERROR - Invalid parameter API Access enable check for API (%ws) :%ws\n",
                ApiName, TrimStr );
        WStatus = ERROR_CANTREAD;
        goto CLEANUP;
    }

    //
    // Fetch the access rights string that tells us if we need to check for
    // read or write access.
    //
    WStr = FrsFree(WStr);
    WStatus = CfgRegReadString(RightsKey, NULL, 0, &WStr);
    if (WStr == NULL) {
        DPRINT1_WS(0, "++ ERROR - API Access rights check for API (%ws) failed.", ApiName, WStatus);
        WStatus = ERROR_NO_TOKEN;
        goto CLEANUP;
    }


    TrimStr = FrsWcsTrim(WStr, L' ');
    if (WSTR_EQ(TrimStr, ACCESS_CHECKS_REQUIRE_READ) ||
        WSTR_EQ(TrimStr, ACCESS_CHECKS_REQUIRE_DEFAULT_READ)) {
        RequireRead = TRUE;
    } else
    if (WSTR_EQ(TrimStr, ACCESS_CHECKS_REQUIRE_WRITE) ||
        WSTR_EQ(TrimStr, ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE)) {
        RequireRead = FALSE;
    } else {
        DPRINT2(0, "++ ERROR - Invalid parameter API Access rights check for API (%ws) :%ws\n",
                ApiName, TrimStr );
        WStatus = ERROR_CANTREAD;
        goto CLEANUP;
    }

    //
    // Impersonate the caller
    //
    if (ServerHandle != NULL) {
        WStatus = RpcImpersonateClient(ServerHandle);
        CLEANUP1_WS(0, "++ ERROR - Can't impersonate caller for API Access check for API (%ws).",
                    ApiName, WStatus, CLEANUP);
        Impersonated = TRUE;
    }

    //
    // Open the key, with the selected access so the system can check if the
    // ACL on the key (presumably set by the admin) gives this user sufficient
    // rights.  If the test succeeds then we allow API call to proceed.
    //
    WStatus = CfgRegOpenKey(RightsKey,
                            NULL,
                            (RequireRead) ? FRS_RKF_KEY_ACCCHK_READ :
                                            FRS_RKF_KEY_ACCCHK_WRITE,
                            &HRpcApiKey);

    CLEANUP2_WS(0, "++ ERROR - API Access check failed for API (%ws) :%ws",
                ApiName, TrimStr, WStatus, CLEANUP);

    //
    // Access is allowed.
    //
    DPRINT2(4, "++ Access Check Okay: %s access for API (%ws)\n",
            (RequireRead) ? "read" : "write", ApiName);
    WStatus = ERROR_SUCCESS;


CLEANUP:

    FRS_REG_CLOSE(HRpcApiKey);
    //
    // Access checks failed, register event
    //
    if (!WIN_SUCCESS(WStatus)) {
        WStatus = FRS_ERR_INSUFFICIENT_PRIV;
        //
        // Include user name if impersonation succeeded
        //
        if (Impersonated) {

            ValueSize = MAX_PATH;
            if (GetUserName(ValueBuf, &ValueSize)) {
                EPRINT3(EVENT_FRS_ACCESS_CHECKS_FAILED_USER,
                        ApiName, ACCESS_CHECKS_ARE, ValueBuf);
            } else {
                EPRINT2(EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN,
                        ApiName, ACCESS_CHECKS_ARE);
            }
        } else {
            EPRINT2(EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN,
                    ApiName, ACCESS_CHECKS_ARE);
        }
    }

    if (Impersonated) {
        RpcRevertToSelf();
    }

    FrsFree(WStr);

    return WStatus;
}


DWORD
CheckAuth(
    IN HANDLE   ServerHandle
    )
/*++
Routine Description:
    Check if the caller has the correct authentication

Arguments:
    ServerHandle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "CheckAuth:"
    DWORD   WStatus;
    DWORD   AuthLevel;
    DWORD   AuthN;

    WStatus = RpcBindingInqAuthClient(ServerHandle, NULL, NULL, &AuthLevel,
                                      &AuthN, NULL);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "++ ERROR - RpcBindingInqAuthClient", WStatus);
        return WStatus;
    }
    //
    // Encrypted packet
    //
    if (AuthLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) {
        DPRINT1(4, "++ Authlevel is %d; not RPC_C_AUTHN_LEVEL_PKT_PRIVACE\n", AuthLevel);
        return ERROR_NOT_AUTHENTICATED;
    }

#ifdef DS_FREE

    DPRINT1(4, "++ AuthN is %d; Allowed in DS_FREE mode.\n", AuthN);

#else DS_FREE
    //
    // KERBEROS
    //
    if (AuthN != RPC_C_AUTHN_GSS_KERBEROS &&
        AuthN != RPC_C_AUTHN_GSS_NEGOTIATE) {
        DPRINT1(4, "++ AuthN is %d; not RPC_C_AUTHN_GSS_KERBEROS/NEGOTIATE\n", AuthN);
        return ERROR_NOT_AUTHENTICATED;
    }

#endif DS_FREE
    //
    // SUCCESS; RPC is authenticated, encrypted kerberos
    //
    return ERROR_SUCCESS;
}

DWORD
CheckAuthForLocalRpc(
    IN HANDLE   ServerHandle
    )
/*++
Routine Description:
    Check if the caller has the correct authentication.
    Make sure the caller is coming over local RPC.
    Allow NTLM since Local RPCs use NTLM.

Arguments:
    ServerHandle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "CheckAuthForLocalRpc:"
    DWORD   WStatus;
    DWORD   AuthLevel;
    DWORD   AuthN;
    PWCHAR  BindingString    = NULL;
    PWCHAR  ProtocolSequence = NULL;

    //
    // Make sure that the caller is calling over LRPC. We do this by
    // determining the protocol sequence used from the string binding.
    //

    WStatus = RpcBindingToStringBinding(ServerHandle, &BindingString);

    CLEANUP_WS(0, "++ ERROR - RpcBindingToStringBinding", WStatus, CLEANUP);

    WStatus = RpcStringBindingParse(BindingString,
                                    NULL,
                                    &ProtocolSequence,
                                    NULL,
                                    NULL,
                                    NULL);

    CLEANUP_WS(0, "++ ERROR - RpcStringBindingParse", WStatus, CLEANUP);

    if ((ProtocolSequence == NULL) || (_wcsicmp(ProtocolSequence, L"ncalrpc") != 0)) {
        WStatus = ERROR_NOT_AUTHENTICATED;
        CLEANUP_WS(0, "++ ERROR - Illegal protocol sequence.", WStatus, CLEANUP);
    }

    WStatus = RpcBindingInqAuthClient(ServerHandle, NULL, NULL, &AuthLevel,
                                      &AuthN, NULL);

    CLEANUP_WS(0, "++ ERROR - RpcBindingInqAuthClient", WStatus, CLEANUP);

    //
    // Encrypted packet
    //
    if (AuthLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) {
        WStatus = ERROR_NOT_AUTHENTICATED;
        CLEANUP1_WS(4, "++ Authlevel is %d; not RPC_C_AUTHN_LEVEL_PKT_PRIVACE", AuthLevel, WStatus, CLEANUP);
    }

#ifdef DS_FREE

    DPRINT1(4, "++ AuthN is %d; Allowed in DS_FREE mode.\n", AuthN);

#else DS_FREE
    //
    // KERBEROS or NTLM
    //
    if ((AuthN != RPC_C_AUTHN_GSS_KERBEROS) &&
        (AuthN != RPC_C_AUTHN_GSS_NEGOTIATE) &&
        (AuthN != RPC_C_AUTHN_WINNT)) {
        WStatus = ERROR_NOT_AUTHENTICATED;
        CLEANUP1_WS(4, "++ AuthN is %d; not RPC_C_AUTHN_GSS_KERBEROS/NEGOTIATE/NTLM", AuthN, WStatus, CLEANUP);
    }

#endif DS_FREE
    //
    // SUCCESS; RPC is local, authenticated, encrypted kerberos or NTLM
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:

    if (BindingString) {
        RpcStringFree(&BindingString);
    }

    if (ProtocolSequence) {
        RpcStringFree(&ProtocolSequence);
    }

    return WStatus;
}

DWORD
CheckAuthForInfoAPIs(
    IN HANDLE   ServerHandle
    )
/*++
Routine Description:
    Check if the caller has the correct authentication.
    Allow NTLM.

Arguments:
    ServerHandle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "CheckAuthForInfoAPIs:"
    DWORD   WStatus;
    DWORD   AuthLevel;
    DWORD   AuthN;

    WStatus = RpcBindingInqAuthClient(ServerHandle, NULL, NULL, &AuthLevel,
                                      &AuthN, NULL);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, "++ ERROR - RpcBindingInqAuthClient", WStatus);
        return WStatus;
    }
    //
    // Encrypted packet
    //
    if (AuthLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) {
        DPRINT1(4, "++ Authlevel is %d; not RPC_C_AUTHN_LEVEL_PKT_PRIVACE\n", AuthLevel);
        return ERROR_NOT_AUTHENTICATED;
    }

#ifdef DS_FREE

    DPRINT1(4, "++ AuthN is %d; Allowed in DS_FREE mode.\n", AuthN);

#else DS_FREE
    //
    // KERBEROS or NTLM
    //
    if ((AuthN != RPC_C_AUTHN_GSS_KERBEROS) &&
        (AuthN != RPC_C_AUTHN_GSS_NEGOTIATE) &&
        (AuthN != RPC_C_AUTHN_WINNT)) {
        DPRINT1(4, "++ AuthN is %d; not RPC_C_AUTHN_GSS_KERBEROS/NEGOTIATE/NTLM\n", AuthN);
        return ERROR_NOT_AUTHENTICATED;
    }

#endif DS_FREE
    //
    // SUCCESS; RPC is authenticated, encrypted kerberos
    //
    return ERROR_SUCCESS;
}

DWORD
NtFrsApi_Rpc_Bind(
    IN  PWCHAR      MachineName,
    OUT PWCHAR      *OutPrincName,
    OUT handle_t    *OutHandle,
    OUT ULONG       *OutParentAuthLevel
    )
/*++
Routine Description:
    Bind to the NtFrs service on MachineName (this machine if NULL)
    using an unauthencated, un-encrypted binding.

Arguments:
    MachineName      - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    OutPrincName     - Principle name for MachineName

    OutHandle        - Bound, resolved, authenticated handle

    OutParentAuthLevel  - Authentication type and level
                          (Always CXTION_AUTH_NONE)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_Bind:"
    DWORD       WStatus, WStatus1;
    handle_t    Handle          = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        //
        // Return value
        //
        *OutHandle = NULL;
        *OutPrincName = NULL;
        *OutParentAuthLevel = CXTION_AUTH_NONE;

        //
        // Create a binding string to NtFrs on some machine.  Trim leading \\
        //
        FRS_TRIM_LEADING_2SLASH(MachineName);

        WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, MachineName,
                                          NULL, NULL, &BindingString);
        CLEANUP1_WS(0, "++ ERROR - Composing binding to %ws;",
                    MachineName, WStatus, CLEANUP);

        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        CLEANUP1_WS(0, "++ ERROR - From binding for %ws;", MachineName, WStatus, CLEANUP);
        //
        // Resolve the binding to the dynamic endpoint
        //
        WStatus = RpcEpResolveBinding(Handle, frsrpc_ClientIfHandle);
        CLEANUP1_WS(0, "++ ERROR - Resolving binding for %ws;",
                    MachineName, WStatus, CLEANUP);

        //
        // SUCCESS
        //
        *OutHandle = Handle;
        *OutPrincName = FrsWcsDup(MachineName);
        Handle = NULL;
        WStatus = ERROR_SUCCESS;
        DPRINT3(4, "++ NtFrsApi Bound to %ws (PrincName: %ws) Auth %d\n",
                MachineName, *OutPrincName, *OutParentAuthLevel);
CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception -", WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
            DPRINT_WS(0, "++ WARN - RpcStringFreeW;",  WStatus1);
        }
        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
            DPRINT_WS(0, "++ WARN - RpcBindingFree;",  WStatus1);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Cleanup Exception.", WStatus);
    }
    return WStatus;
}


DWORD
NtFrsApi_Rpc_BindEx(
    IN  PWCHAR      MachineName,
    OUT PWCHAR      *OutPrincName,
    OUT handle_t    *OutHandle,
    OUT ULONG       *OutParentAuthLevel
    )
/*++
Routine Description:
    Bind to the NtFrs service on MachineName (this machine if NULL)
    using an authenticated, encrypted binding.

Arguments:
    MachineName      - Bind to the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    OutPrincName     - Principle name for MachineName

    OutHandle        - Bound, resolved, authenticated handle

    OutParentAuthLevel  - Authentication type and level
                          (Always CXTION_AUTH_KERBEROS_FULL)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_BindEx:"
    DWORD       WStatus, WStatus1;
    PWCHAR      InqPrincName    = NULL;
    handle_t    Handle          = NULL;
    PWCHAR      PrincName       = NULL;
    PWCHAR      BindingString   = NULL;

    try {
        //
        // Return value
        //
        *OutHandle = NULL;
        *OutPrincName = NULL;
        *OutParentAuthLevel = CXTION_AUTH_KERBEROS_FULL;

        //
        // Create a binding string to NtFrs on some machine.  Trim leading \\
        //
        FRS_TRIM_LEADING_2SLASH(MachineName);

        WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, MachineName,
                                          NULL, NULL, &BindingString);
        CLEANUP1_WS(0, "++ ERROR - Composing binding to %ws;",
                    MachineName, WStatus, CLEANUP);

        //
        // Store the binding in the handle
        //
        WStatus = RpcBindingFromStringBinding(BindingString, &Handle);
        CLEANUP1_WS(0, "++ ERROR - From binding for %ws;", MachineName, WStatus, CLEANUP);
        //
        // Resolve the binding to the dynamic endpoint
        //
        WStatus = RpcEpResolveBinding(Handle, frsrpc_ClientIfHandle);
        CLEANUP1_WS(0, "++ ERROR - Resolving binding for %ws;",
                    MachineName, WStatus, CLEANUP);

        //
        // Find the principle name
        //
        WStatus = RpcMgmtInqServerPrincName(Handle,
                                            RPC_C_AUTHN_GSS_NEGOTIATE,
                                            &InqPrincName);
        CLEANUP1_WS(0, "++ ERROR - Inq PrincName for %ws;", MachineName, WStatus, CLEANUP);

        PrincName = FrsWcsDup(InqPrincName);
        RpcStringFree(&InqPrincName);
        InqPrincName = NULL;
        //
        // Set authentication info
        //
        if (MutualAuthenticationIsEnabled || MutualAuthenticationIsEnabledAndRequired) {
            WStatus = RpcBindingSetAuthInfoEx(Handle,
                                              PrincName,
                                              RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                              RPC_C_AUTHN_GSS_NEGOTIATE,
                                              NULL,
                                              RPC_C_AUTHZ_NONE,
                                              &RpcSecurityQos);
            DPRINT2_WS(1, "++ WARN - RpcBindingSetAuthInfoEx(%ws, %ws);",
                       MachineName, PrincName, WStatus);
        } else {
            WStatus = ERROR_NOT_SUPPORTED;
        }
        //
        // Fall back to manual mutual authentication
        //
        if (!MutualAuthenticationIsEnabledAndRequired && !WIN_SUCCESS(WStatus)) {
            WStatus = RpcBindingSetAuthInfo(Handle,
                                            PrincName,
                                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                            RPC_C_AUTHN_GSS_NEGOTIATE,
                                            NULL,
                                            RPC_C_AUTHZ_NONE);
        }

        CLEANUP1_WS(0, "++ ERROR - RpcBindingSetAuthInfo(%ws);",
                    MachineName, WStatus, CLEANUP);

        //
        // SUCCESS
        //
        *OutHandle = Handle;
        *OutPrincName = PrincName;
        Handle = NULL;
        PrincName = NULL;
        WStatus = ERROR_SUCCESS;
        DPRINT3(4, "++ NtFrsApi Bound to %ws (PrincName: %ws) Auth %d\n",
                MachineName, *OutPrincName, *OutParentAuthLevel);

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ Error - Exception.", WStatus);
    }

    //
    // Clean up any handles, events, memory, ...
    //
    try {
        if (BindingString) {
            WStatus1 = RpcStringFreeW(&BindingString);
            DPRINT_WS(0, "++ WARN - RpcStringFreeW;",  WStatus1);
        }
        if (PrincName) {
            PrincName = FrsFree(PrincName);
        }
        if (Handle) {
            WStatus1 = RpcBindingFree(&Handle);
            DPRINT_WS(0, "++ WARN - RpcBindingFree;",  WStatus1);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ Error - Cleanup Exception.", WStatus);
    }
    return WStatus;
}


GUID    DummyGuid;
BOOL    CommitDemotionInProgress;
DWORD
NtFrsApi_Rpc_StartDemotionW(
    IN handle_t Handle,
    IN PWCHAR   ReplicaSetName
    )
/*++
Routine Description:
    Start demoting the sysvol. Basically, tombstone the replica set.

Arguments:
    Handle
    ReplicaSetName      - Replica set name

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_StartDemotionW:"
    DWORD   WStatus;
    PWCHAR  SysVolName;
    BOOL    UnLockGenTable = FALSE;
    BOOL    DeleteFromGenTable = FALSE;

    try {
        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabled(Handle, ACX_DCPROMO);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        //
        // Check if the caller has access.
        //
        WStatus = FrsRpcAccessChecks(Handle, ACX_DCPROMO);
        CLEANUP_WS(0, "++ ERROR - FrsRpcAccessChecks failed;",
                    WStatus, CLEANUP);

        //
        // Check parameters
        //
        if (ReplicaSetName == NULL) {
            DPRINT(0, "++ ERROR - Parameter is NULL\n");
            WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
            goto CLEANUP;
        }

        //
        // Display params
        //
        DPRINT1(0, ":S: Start Demotion: %ws\n", ReplicaSetName);

        //
        // Can't promote/demote the same sysvol at the same time!
        //
        UnLockGenTable = TRUE;
        GTabLockTable(SysVolsBeingCreated);
        SysVolName = GTabLookupNoLock(SysVolsBeingCreated, &DummyGuid, ReplicaSetName);

        if (SysVolName) {
            DPRINT1(0, "++ ERROR - Promoting/Demoting %ws twice\n", ReplicaSetName);
            WStatus = FRS_ERR_SYSVOL_IS_BUSY;
            goto CLEANUP;
        }

        if (CommitDemotionInProgress) {
            DPRINT(0, "++ ERROR - Commit demotion in progress.\n");
            WStatus = FRS_ERR_SYSVOL_IS_BUSY;
            goto CLEANUP;
        }

        DeleteFromGenTable = TRUE;
        GTabInsertEntryNoLock(SysVolsBeingCreated,
                              ReplicaSetName,
                              &DummyGuid,
                              ReplicaSetName);
        UnLockGenTable = FALSE;
        GTabUnLockTable(SysVolsBeingCreated);

        //
        // Delete the replica set
        //
        WStatus = FrsDsStartDemotion(ReplicaSetName);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "++ ERROR - demoting;", WStatus);
            WStatus = FRS_ERR_SYSVOL_DEMOTE;
            goto CLEANUP;
        }
        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;
        DPRINT2(0, ":S: Success demoting %ws from %ws\n", ReplicaSetName, ComputerName);
CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }
    try {
        if (UnLockGenTable) {
            GTabUnLockTable(SysVolsBeingCreated);
        }
        if (DeleteFromGenTable) {
            GTabDelete(SysVolsBeingCreated, &DummyGuid, ReplicaSetName, NULL);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Cleanup Exception.", WStatus);
    }
    return WStatus;
}


DWORD
NtFrsApi_Rpc_CommitDemotionW(
    IN handle_t Handle
    )
/*++
Routine Description:
    The sysvols have been demoted. Mark them as "do not animate."

Arguments:
    Handle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_CommitDemotionW:"
    DWORD   WStatus;
    PWCHAR  SysVolName;
    PVOID   Key;
    BOOL    UnLockGenTable = FALSE;

    try {
        //
        // Display params
        //
        DPRINT(0, ":S: Commit Demotion:\n");

        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabledForCommitDemotion(Handle, ACX_DCPROMO);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        WStatus = FrsRpcAccessChecks(Handle, ACX_DCPROMO);
        CLEANUP_WS(0, "++ ERROR - FrsRpcAccessChecks();", WStatus, CLEANUP);

        //
        // Can't promote/demote the same sysvol at the same time!
        //
        Key = NULL;
        UnLockGenTable = TRUE;
        GTabLockTable(SysVolsBeingCreated);
        SysVolName = GTabNextDatumNoLock(SysVolsBeingCreated, &Key);
        if (SysVolName) {
            DPRINT(0, "++ ERROR - Promoting/Demoting during commit\n");
            WStatus = FRS_ERR_SYSVOL_IS_BUSY;
            goto CLEANUP;
        }
        CommitDemotionInProgress = TRUE;
        UnLockGenTable = FALSE;
        GTabUnLockTable(SysVolsBeingCreated);

        //
        // Create the replica set
        //
        WStatus = FrsDsCommitDemotion();
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "++ ERROR - Commit demotion;", WStatus);
            WStatus = FRS_ERR_SYSVOL_DEMOTE;
            goto CLEANUP;
        }
        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;
        DPRINT1(0, ":S: Success commit demotion on %ws.\n", ComputerName);
CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }
    try {
        CommitDemotionInProgress = FALSE;
        if (UnLockGenTable) {
            GTabUnLockTable(SysVolsBeingCreated);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Cleanup Exception.", WStatus);
    }
    return WStatus;
}


DWORD
SERVER_FrsRpcVerifyPromotionParent(
    IN handle_t     Handle,
    IN PWCHAR       ParentAccount,
    IN PWCHAR       ParentPassword,
    IN PWCHAR       ReplicaSetName,
    IN PWCHAR       ReplicaSetType,
    IN ULONG        ParentAuthLevel,
    IN ULONG        GuidSize
    )
/*++
Routine Description:
    OBSOLETE API

    Verify the account on the parent computer. The parent computer
    supplies the initial copy of the indicated sysvol.

Arguments:
    Handle
    ParentAccount       - Valid account on ParentComputer
    ParentPassword      - Valid password for ParentAccount
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Replica set type
    ParentAuthLevel     - Authentication type and level
    GuidSize            - sizeof(GUID)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsRpcVerifyPromotionParent:"

    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
SERVER_FrsRpcVerifyPromotionParentEx(
    IN  handle_t    Handle,
    IN  PWCHAR      ParentAccount,
    IN  PWCHAR      ParentPassword,
    IN  PWCHAR      ReplicaSetName,
    IN  PWCHAR      ReplicaSetType,
    IN  PWCHAR      CxtionName,
    IN  PWCHAR      PartnerName,
    IN  PWCHAR      PartnerPrincName,
    IN  PWCHAR      ParentPrincName,
    IN  ULONG       PartnerAuthLevel,
    IN  ULONG       GuidSize
    )
/*++
Routine Description:

    OBSOLETE API

    Verify as much of the comm paths and parameters as possible so
    that dcpromo fails early.

Arguments:
    Handle
    ParentAccount       - Valid account on ParentComputer
    ParentPassword      - Valid password for ParentAccount
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Replica set type
    CxtionName          - printable name for cxtion
    PartnerName         - RPC bindable name
    PartnerPrincName    - Server principle name for kerberos
    ParentPrincName     - Principle name used to bind to this computer
    PartnerAuthLevel    - Authentication type and level
    GuidSize            - sizeof array addressed by Guid

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsRpcVerifyPromotionParentEx:"

    return ERROR_CALL_NOT_IMPLEMENTED;
}


DWORD
LOCAL_FrsRpcVerifyPromotionParent(
    IN PWCHAR       ReplicaSetName,
    IN PWCHAR       ReplicaSetType,
    IN ULONG        GuidSize
    )
/*++
Routine Description:
    Verify the account on the parent computer. The parent computer
    supplies the initial copy of the indicated sysvol.

Arguments:
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Replica set type
    GuidSize            - sizeof(GUID)

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "LOCAL_FrsRpcVerifyPromotionParent:"
    DWORD   WStatus;

    try {
        //
        // Display params
        //
        DPRINT(0, ":S: SERVER Verify Promotion Parent:\n");
        DPRINT1(0, ":S: \tSetName  : %ws\n", ReplicaSetName);
        DPRINT1(0, ":S: \tSetType  : %ws\n", ReplicaSetType);

        //
        // Guid
        //
        if (GuidSize != sizeof(GUID)) {
            DPRINT3(0, "++ ERROR - %ws: GuidSize is %d, not %d\n",
                    ReplicaSetName, GuidSize, sizeof(GUID));
            goto ERR_INVALID_SERVICE_PARAMETER;
        }

        //
        // Check parameters
        //
        if (!ReplicaSetName || !ReplicaSetType) {
            DPRINT(0, "++ ERROR - Parameter is NULL\n");
            goto ERR_INVALID_SERVICE_PARAMETER;
        }
        if (_wcsicmp(ReplicaSetType, NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE) &&
            _wcsicmp(ReplicaSetType, NTFRSAPI_REPLICA_SET_TYPE_DOMAIN)) {
            DPRINT1(0, "++ ERROR - ReplicaSetType is %ws\n", ReplicaSetType);
            goto ERR_INVALID_SERVICE_PARAMETER;
        }

        //
        // Verify the replica set
        //
        WStatus = FrsDsVerifyPromotionParent(ReplicaSetName, ReplicaSetType);
        CLEANUP2_WS(0, "++ ERROR - verifying set %ws on parent %ws;",
                    ReplicaSetName, ComputerName, WStatus, ERR_SYSVOL_POPULATE);

        //
        // SUCCESS
        //
        DPRINT2(0, ":S: Success Verifying promotion parent %ws %ws\n",
                ReplicaSetName, ReplicaSetType);
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;


ERR_INVALID_SERVICE_PARAMETER:
        WStatus = FRS_ERR_INVALID_SERVICE_PARAMETER;
        goto CLEANUP;

ERR_SYSVOL_POPULATE:
        WStatus = FRS_ERR_SYSVOL_POPULATE;


CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }

    return WStatus;
}


DWORD
SERVER_FrsRpcStartPromotionParent(
    IN  handle_t    Handle,
    IN  PWCHAR      ParentAccount,
    IN  PWCHAR      ParentPassword,
    IN  PWCHAR      ReplicaSetName,
    IN  PWCHAR      ReplicaSetType,
    IN  PWCHAR      CxtionName,
    IN  PWCHAR      PartnerName,
    IN  PWCHAR      PartnerPrincName,
    IN  ULONG       PartnerAuthLevel,
    IN  ULONG       GuidSize,
    IN  UCHAR       *CxtionGuid,
    IN  UCHAR       *PartnerGuid,
    OUT UCHAR       *ParentGuid
    )
/*++
Routine Description:

    Setup a volatile cxtion on the parent for seeding the indicated
    sysvol on the caller.

Arguments:
    Handle
    ParentAccount       - Valid account on ParentComputer
    ParentPassword      - Valid password for ParentAccount
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Replica set type
    CxtionName          - printable name for cxtion
    PartnerName         - RPC bindable name
    PartnerPrincName    - Server principle name for kerberos
    PartnerAuthLevel    - Authentication type and level
    GuidSize            - sizeof array addressed by Guid
    CxtionGuid          - temporary: used for volatile cxtion
    PartnerGuid         - temporary: used to find set on partner
    ParentGuid          - Used as partner guid on inbound cxtion

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "SERVER_FrsRpcStartPromotionParent:"
    DWORD   WStatus;
    PWCHAR  AuthClient  = NULL;
    PWCHAR  AuthSid     = NULL;

    try {
        //
        // Parent must be a DC
        //
        if (!IsADc) {
            DPRINT(0, "++ ERROR - Parent is not a DC\n");
            WStatus = ERROR_NO_SUCH_DOMAIN;
            goto CLEANUP;
        }

        WStatus = RpcBindingInqAuthClient(Handle,
                                          &AuthClient,
                                          NULL,NULL,NULL,NULL);
        CLEANUP_WS(0, "++ ERROR - RpcBindingInqAuthClient;",
                    WStatus, CLEANUP);

    if(0 != _wcsicmp(AuthClient, PartnerPrincName)) {
        // This is not a error as we no longer use the PartnerPrincName 
        // as security check.
        DPRINT2(2, "++ WARN (can be ignored) - AuthClient (%ws) does not match PartnerPrincName (%ws)\n",
            AuthClient,
            PartnerPrincName
            );
    }

    WStatus = UtilRpcServerHandleToAuthSidString(Handle,
                             AuthClient,
                             &AuthSid
                             );

        CLEANUP_WS(0, "++ ERROR - UtilRpcServerHandleToAuthSidString;",
                    WStatus, CLEANUP);



        //
        // Our partner's computer object (or user object) should
        // have the "I am a DC" flag set.
        //

        if (!FrsDsIsPartnerADc(AuthClient)) {
            DPRINT(0, "++ ERROR - Partner is not a DC\n");
            WStatus = ERROR_TRUSTED_DOMAIN_FAILURE;
            goto CLEANUP;
        }

        //
        // Display params
        //
        DPRINT(0, ":S: SERVER Start Promotion Parent:\n");
        DPRINT1(0, ":S: \tPartner      : %ws\n", PartnerName);
        DPRINT1(0, ":S: \tPartnerPrinc : %ws\n", PartnerPrincName);
        DPRINT1(0, ":S: \tAuthLevel    : %d\n",  PartnerAuthLevel);
        DPRINT1(0, ":S: \tAccount      : %ws\n", ParentAccount);
        DPRINT1(0, ":S: \tSetName      : %ws\n", ReplicaSetName);
        DPRINT1(0, ":S: \tSetType      : %ws\n", ReplicaSetType);
        DPRINT1(0, ":S: \tCxtionName   : %ws\n", CxtionName);

        //
        // Verify parameters
        //
        WStatus = LOCAL_FrsRpcVerifyPromotionParent(ReplicaSetName,
                                                    ReplicaSetType,
                                                    GuidSize);
        CLEANUP_WS(0, "++ ERROR - verify;", WStatus, CLEANUP);


        //
        // Setup the outbound cxtion
        //
        WStatus = FrsDsStartPromotionSeeding(FALSE,
                                             ReplicaSetName,
                                             ReplicaSetType,
                                             CxtionName,
                                             PartnerName,
                                             AuthClient,
                         AuthSid,
                                             PartnerAuthLevel,
                                             GuidSize,
                                             CxtionGuid,
                                             PartnerGuid,
                                             ParentGuid);
        CLEANUP_WS(0, "++ ERROR - ds start;", WStatus, CLEANUP);

        //
        // SUCCESS
        //
        DPRINT3(0, ":S: Success starting promotion parent %ws %ws %ws\n",
                ParentAccount, ReplicaSetName, ReplicaSetType);



    if(NeedNewPartnerTable) {

        NeedNewPartnerTable = FALSE;
        FrsDsCreateNewValidPartnerTableStruct();
    }

        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // Exception (may be RPC)
        //
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }

    if(AuthSid) {
    FrsFree(AuthSid);
    }

    return WStatus;

}


BOOL
IsFacilityFrs(
    IN DWORD    WStatus
    )
/*++
Routine Description:
    Is this an FRS specific error status

Arguments:
    WStatus - Win32 Error Status

Return Value:
    TRUE    - Is an FRS specific error status
    FALSE   -
--*/
{
#undef DEBSUB
#define  DEBSUB  "IsFacilityFrs:"
    // TODO: replace these constants with symbollic values from winerror.h
    return ( (WStatus >= 8000) && (WStatus < 8200) );
}


DWORD
NtFrsApi_Rpc_StartPromotionW(
    IN handle_t Handle,
    IN PWCHAR   ParentComputer,
    IN PWCHAR   ParentAccount,
    IN PWCHAR   ParentPassword,
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN ULONG    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    )
/*++
Routine Description:
    OBSOLETE API

    Start the promotion process by seeding the indicated sysvol.

Arguments:
    Handle
    ParentComputer      - DNS or NetBIOS name of the parent supplying the sysvol
    ParentAccount       - Valid account on ParentComputer
    ParentPassword      - Valid password for ParentAccount
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Type of set (Enterprise or Domain)
    ReplicaSetPrimary   - 1=Primary; 0=not
    ReplicaSetStage     - Staging path
    ReplicaSetRoot      - Root path

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_StartPromotionW:"

    return ERROR_CALL_NOT_IMPLEMENTED;

}


DWORD
NtFrsApi_Rpc_VerifyPromotionW(
    IN handle_t Handle,
    IN PWCHAR   ParentComputer,
    IN PWCHAR   ParentAccount,
    IN PWCHAR   ParentPassword,
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN ULONG    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    )
/*++
Routine Description:
    OBSOLETE API

    Verify that sysvol promotion is likely.

Arguments:
    Handle
    ParentComputer      - DNS or NetBIOS name of the parent supplying the sysvol
    ParentAccount       - Valid account on ParentComputer
    ParentPassword      - Valid password for ParentAccount
    ReplicaSetName      - Replica set name
    ReplicaSetType      - Type of set (Enterprise or Domain)
    ReplicaSetPrimary   - 1=Primary; 0=not
    ReplicaSetStage     - Staging path
    ReplicaSetRoot      - Root path

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_VerifyPromotionW:"

    return ERROR_CALL_NOT_IMPLEMENTED;

}


DWORD
NtFrsApi_Rpc_PromotionStatusW(
    IN handle_t Handle,
    IN PWCHAR   ReplicaSetName,
    OUT ULONG   *ServiceState,
    OUT ULONG   *ServiceWStatus,
    OUT PWCHAR  *ServiceDisplay     OPTIONAL
    )
/*++
Routine Description:
    OBSOLETE API

    Status of the seeding of the indicated sysvol

Arguments:
    Handle
    ReplicaSetName      - Replica set name
    ServiceState        - State of the service
    ServiceWStatus      - Win32 Status if state is NTFRSAPI_SERVICE_ERROR
    ServiceDisplay      - Display string if state is NTFRSAPI_SERVICE_PROMOTING

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_PromotionStatusW:"

    return ERROR_CALL_NOT_IMPLEMENTED;

}


DWORD
NtFrsApi_Rpc_Get_DsPollingIntervalW(
    IN handle_t  Handle,
    OUT ULONG    *Interval,
    OUT ULONG    *LongInterval,
    OUT ULONG    *ShortInterval
    )
/*++
Routine Description:
    Get the current polling intervals in minutes.

Arguments:
    Handle
    Interval        - Current interval in minutes
    LongInterval    - Long interval in minutes
    ShortInterval   - Short interval in minutes

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_Get_DsPollingIntervalW"
    DWORD   WStatus;

    try {
        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabled(Handle, ACX_GET_DS_POLL);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        WStatus = FrsRpcAccessChecks(Handle, ACX_GET_DS_POLL);

        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        if ((Interval == NULL) || (LongInterval == NULL) || (ShortInterval == NULL)) {
            goto CLEANUP;
        }

        WStatus = FrsDsGetDsPollingInterval(Interval, LongInterval, ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }
    return WStatus;
}


DWORD
NtFrsApi_Rpc_Set_DsPollingIntervalW(
    IN handle_t Handle,
    IN ULONG    UseShortInterval,
    IN ULONG    LongInterval,
    IN ULONG    ShortInterval
    )
/*++
Routine Description:
    Adjust the polling interval and kick off a new polling cycle.
    The kick is ignored if a polling cycle is in progress.
    The intervals are given in minutes.

Arguments:
    Handle
    UseShortInterval    - If non-zero, use short interval. Otherwise, long.
    LongInterval        - Long interval in minutes
    ShortInterval       - Short interval in minutes

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_Set_DsPollingIntervalW"
    DWORD   WStatus;

    try {
        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabled(Handle,
                                           (!LongInterval && !ShortInterval) ?
                                              ACX_START_DS_POLL:
                                              ACX_SET_DS_POLL);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        WStatus = FrsRpcAccessChecks(Handle,
                                     (!LongInterval && !ShortInterval) ?
                                          ACX_START_DS_POLL:
                                          ACX_SET_DS_POLL);

        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        WStatus = FrsDsSetDsPollingInterval(UseShortInterval,
                                            LongInterval,
                                            ShortInterval);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }
    return WStatus;
}

DWORD
NtFrsApi_Rpc_WriterCommand(
    IN handle_t Handle,
    IN ULONG    Command
    )
/*++
Routine Description:

Arguments:
    Handle
    Command - freeze or thaw

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_WriterCommand"
    DWORD   WStatus;

    try {
        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabled(Handle,
                                           ACX_DCPROMO);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        WStatus = FrsRpcAccessChecks(Handle,
                                     ACX_DCPROMO);

        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        switch (Command) {
        case NTFRSAPI_WRITER_COMMAND_FREEZE :
            WStatus = FrsFreezeForBackup();
            CLEANUP_WS(0, "++ ERROR - FrsFreezeForBackup failed;",
                        WStatus, CLEANUP);
            break;

        case NTFRSAPI_WRITER_COMMAND_THAW :
            WStatus = FrsThawAfterBackup();
            CLEANUP_WS(0, "++ ERROR - FrsThawAfterBackup failed;",
                        WStatus, CLEANUP);
            break;

        default:
            DPRINT1(2, "++ WARN - Unknown writer command %d\n", Command);
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }
    return WStatus;
}


DWORD
NtFrsApi_Rpc_InfoW(
    IN     handle_t Handle,
    IN     ULONG    BlobSize,
    IN OUT PBYTE    Blob
    )
/*++
Routine Description:
    Return internal info (see private\net\inc\ntfrsapi.h).

Arguments:
    Handle
    BlobSize    - total bytes of Blob
    Blob        - details desired info and provides buffer for info

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_InfoW:"
    DWORD   WStatus;

    try {
        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabled(Handle, ACX_INTERNAL_INFO);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        WStatus = FrsRpcAccessChecks(Handle, ACX_INTERNAL_INFO);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        WStatus = Info(BlobSize, Blob);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }
    return WStatus;
}


VOID
RegisterRpcProtseqs(
    )
/*++
Routine Description:
    Register the RPC protocol sequences and the authentication
    that FRS supports. Currently, this is only TCP/IP authenticated
    with kerberos.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "RegisterRpcProtseqs:"
    DWORD       WStatus;
    RPC_STATUS  Status;
    PWCHAR      InqPrincName = NULL;
    RPC_POLICY  RpcPolicy;
    WCHAR       PortStr[40];


    RpcPolicy.Length = sizeof(RPC_POLICY);
    RpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    RpcPolicy.NICFlags = 0;

    //
    // Register TCP/IP Protocol Sequence
    //
    if (RpcPortAssignment != 0) {
        //
        // Use customer specified port.
        //
        _ultow(RpcPortAssignment, PortStr, 10);
        Status = RpcServerUseProtseqEpEx(PROTSEQ_TCP_IP, MaxRpcServerThreads, PortStr, NULL, &RpcPolicy );
        DPRINT1_WS(0, "++ ERROR - RpcServerUseProtSeqEpEx(%ws);", PROTSEQ_TCP_IP, Status);
    } else {
        //
        // Use dynamic RPC port assignment.
        //
        Status = RpcServerUseProtseqEx(PROTSEQ_TCP_IP, MaxRpcServerThreads, NULL, &RpcPolicy );
        DPRINT1_WS(0, "++ ERROR - RpcServerUseProtSeqEx(%ws);", PROTSEQ_TCP_IP, Status);
    }

    if (!RPC_SUCCESS(Status)) {
        FrsRaiseException(FRS_ERROR_PROTSEQ, Status);
    }

    //
    // Perfmon APIs come over the local rpc.
    //
    Status = RpcServerUseProtseq(PROTSEQ_LRPC, MaxRpcServerThreads, NULL);
    DPRINT1_WS(0, "++ ERROR - RpcServerUseProtSeq(%ws);", PROTSEQ_LRPC, Status);

    if (!RPC_SUCCESS(Status)) {
        FrsRaiseException(FRS_ERROR_PROTSEQ, Status);
    }


    //
    // For hardwired -- Eventually DS Free configs.
    // Don't bother with kerberos if emulating multiple machines
    //
    if (ServerGuid) {
        return;
    }

    //
    // Get our principle name
    //
    if (ServerPrincName) {
        ServerPrincName = FrsFree(ServerPrincName);
    }
    Status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &InqPrincName);
    DPRINT1_WS(4, ":S: RpcServerInqDefaultPrincname(%d);", RPC_C_AUTHN_GSS_NEGOTIATE, Status);

    //
    // No principle name; KERBEROS may not be available
    //
    if (!RPC_SUCCESS(Status)) {
        //
        // Don't use any authentication if this server is not part of a domain.
        //
        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *DsRole;

        //
        // Is this a member server?
        //
        WStatus = DsRoleGetPrimaryDomainInformation(NULL,
                                                    DsRolePrimaryDomainInfoBasic,
                                                    (PBYTE *)&DsRole);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, "++ ERROR - Can't get Ds role info;", WStatus);
            FrsRaiseException(FRS_ERROR_PROTSEQ, Status);
            return;
        }

        //
        // Standalone server; ignore authentication for now
        //      Hmmm, it seems we become a member server early
        //      in the dcpromo process. Oh, well...
        //
        //      Hmmm, it seems that a NT4 to NT5 PDC doesn't
        //      have kerberos during dcpromo. This is getting
        //      old...
        //
        // if (DsRole->MachineRole == DsRole_RoleStandaloneServer ||
            // DsRole->MachineRole == DsRole_RoleMemberServer) {
            DsRoleFreeMemory(DsRole);
            ServerPrincName = FrsWcsDup(ComputerName);
            KerberosIsNotAvailable = TRUE;
            DPRINT(0, ":S: WARN - KERBEROS IS NOT ENABLED!\n");
            DPRINT1(4, ":S: Server Principal Name (no kerberos) is %ws\n",
                    ServerPrincName);
            return;
        // }
        DsRoleFreeMemory(DsRole);
        DPRINT1_WS(0, ":S: ERROR - RpcServerInqDefaultPrincName(%ws) failed;", ComputerName, Status);
        FrsRaiseException(FRS_ERROR_PROTSEQ, Status);
    } else {
        DPRINT2(4, ":S: RpcServerInqDefaultPrincname(%d, %ws) success\n",
                RPC_C_AUTHN_GSS_NEGOTIATE, InqPrincName);

        ServerPrincName = FrsWcsDup(InqPrincName);
        RpcStringFree(&InqPrincName);
        InqPrincName = NULL;
    }

#ifdef DS_FREE

    KerberosIsNotAvailable = TRUE;

#else DS_FREE

    //
    // Register with the KERBEROS authentication service
    //
    //
    // Enable GSS_KERBEROS for pre-Beta3 compatability.  When can we remove??
    //
    KerberosIsNotAvailable = FALSE;
    DPRINT1(4, ":S: Server Principal Name is %ws\n", ServerPrincName);
    Status = RpcServerRegisterAuthInfo(ServerPrincName,
                                       RPC_C_AUTHN_GSS_KERBEROS,
                                       NULL,
                                       NULL);
    if (!RPC_SUCCESS(Status)) {
        DPRINT1_WS(0, "++ ERROR - RpcServerRegisterAuthInfo(KERBEROS, %ws) failed;",
                   ComputerName, Status);
        FrsRaiseException(FRS_ERROR_PROTSEQ, Status);
    } else {
        DPRINT2(4, ":S: RpcServerRegisterAuthInfo(%ws, %d) success\n",
                ServerPrincName, RPC_C_AUTHN_GSS_KERBEROS);
    }

#endif DS_FREE


    //
    // Enable GSS_NEGOTIATE for future usage
    //
    Status = RpcServerRegisterAuthInfo(ServerPrincName,
                                       RPC_C_AUTHN_GSS_NEGOTIATE,
                                       NULL,
                                       NULL);
    DPRINT2_WS(4, ":S: RpcServerRegisterAuthInfo(%ws, %d);",
               ServerPrincName, RPC_C_AUTHN_GSS_NEGOTIATE, Status);

    DPRINT1_WS(0, "++ WARN - RpcServerRegisterAuthInfo(NEGOTIATE, %ws) failed;",
               ComputerName, Status);
}

RPC_STATUS
FrsRpcSecurityCallback(
  IN RPC_IF_HANDLE *Interface,
  IN void *Context
  )
/*++
Routine Description:
    Security callback function for RPC.

    When a server application specifies a security-callback function for its
    interface(s), the RPC run time automatically rejects unauthenticated calls
    to that interface. In addition, the run-time records the interfaces that
    each client has used. When a client makes an RPC to an interface that it
    has not used during the current communication session, the RPC run-time
    library will call the interface's security-callback function.

    In some cases, the RPC run time may call the security-callback function
    more than once per client-per interface.

Arguments:
    Interface - UUID and version of the interface.
    Context - Pointer to an RPC_IF_ID server binding handle representing the
              client. In the function declaration, this must be of type
          RPC_IF_HANDLE, but it is an RPC_IF_ID and can be safely cast to it.

Return Value:
    RPC_S_OK if we will allow the call to go through..
    RPC_S_ACCESS_DENIED otherwise.

--*/
{
    DWORD      WStatus   = ERROR_ACCESS_DENIED;
    RPC_STATUS RpcStatus = RPC_S_ACCESS_DENIED;

    WStatus = CheckAuth(Context);

    if(WStatus == ERROR_SUCCESS) {
    RpcStatus = RPC_S_OK;
    } else {
    RpcStatus = RPC_S_ACCESS_DENIED;
    }

    return RpcStatus;
}

RPC_STATUS
FrsRpcSecurityCallbackForPerfmonAPIs(
  IN RPC_IF_HANDLE *Interface,
  IN void *Context
  )
/*++
Routine Description:
    Security callback function for the perfmon calls RPC.

    When a server application specifies a security-callback function for its
    interface(s), the RPC run time automatically rejects unauthenticated calls
    to that interface. In addition, the run-time records the interfaces that
    each client has used. When a client makes an RPC to an interface that it
    has not used during the current communication session, the RPC run-time
    library will call the interface's security-callback function.

    In some cases, the RPC run time may call the security-callback function
    more than once per client-per interface.

Arguments:
    Interface - UUID and version of the interface.
    Context - Pointer to an RPC_IF_ID server binding handle representing the
              client. In the function declaration, this must be of type
          RPC_IF_HANDLE, but it is an RPC_IF_ID and can be safely cast to it.

Return Value:
    RPC_S_OK if we will allow the call to go through..
    RPC_S_ACCESS_DENIED otherwise.

--*/
{
    DWORD      WStatus   = ERROR_ACCESS_DENIED;

    //
    // Check authentication based on the registry key value
    // for perfmon APIs. Check the FrsRpcCheckAuthIfEnabled
    // function header for more info.
    //
    WStatus = FrsRpcCheckAuthIfEnabled(Context, ACX_COLLECT_PERFMON_DATA);

    if(WIN_SUCCESS(WStatus)) {
        return RPC_S_OK;
    } else {
        return RPC_S_ACCESS_DENIED;
    }

}

DWORD
FrsRpcCheckAuthIfEnabled(
  IN HANDLE   ServerHandle,
  IN DWORD    RpcApiIndex
  )
/*++
Routine Description:

Arguments:

    First check if the access checks are disabled. If they are
    disabled then skip authentication.
    Access checks are controlled by a registry key.
    This implies that if the server has the registry set to
    disable access checks then it will accept unauthenticated
    calls.

    There is a seperate key for each API. The input parameter
    RpcApiIndex determines which key to check.

    E.g.
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
    Services\ntfrs\Parameters\Access Checks\Get Perfmon Data
    Access checks are [Enabled or Disabled]

    Interface - UUID and version of the interface.

    RpcApiIndex - identifies key in registry


Return Value:
    ERROR_SUCCESS if we will allow the call to go through..
    ERROR_ACCESS_DENIED if authentication fails.

--*/
{
    FRS_REG_KEY_CODE   EnableKey;
    PWCHAR  ApiName;
    PWCHAR  WStr = NULL, TrimStr;
    DWORD WStatus = ERROR_ACCESS_DENIED;

    // Check if RpcApiIndex is within range.
    if (RpcApiIndex >= ACX_MAX) {
        goto CHECK_AUTH;
    }
    //
    // Get the key and the api name for this index from
    // the global table.
    //
    EnableKey = RpcApiKeys[RpcApiIndex].Enable;
    ApiName   = RpcApiKeys[RpcApiIndex].KeyName;

    WStatus = CfgRegReadString(EnableKey, NULL, 0, &WStr);
    if (WStr == NULL) {
        DPRINT1_WS(0, "++ ERROR - API Access enable check for API (%ws) failed.", ApiName, WStatus);
        if (WIN_SUCCESS(WStatus)) {
            WStatus = ERROR_GEN_FAILURE;
        }
        goto CLEANUP;
    }

    //
    // If access checks are disabled then we're done.
    //
    TrimStr = FrsWcsTrim(WStr, L' ');
    if (WSTR_EQ(TrimStr, ACCESS_CHECKS_ARE_DISABLED) ||
        WSTR_EQ(TrimStr, ACCESS_CHECKS_ARE_DEFAULT_DISABLED)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

CHECK_AUTH:
    if (RpcApiIndex == ACX_COLLECT_PERFMON_DATA) {
        //
        // Access checks are not disabled. Check authentication.
        // Perfmon APIs can only be called over local RPC and
        // they allow NTLM so call a different API for them.
        //
        WStatus = CheckAuthForLocalRpc(ServerHandle);
    } else if ((RpcApiIndex == ACX_START_DS_POLL) ||
               (RpcApiIndex == ACX_SET_DS_POLL) ||
               (RpcApiIndex == ACX_GET_DS_POLL) ||
               (RpcApiIndex == ACX_INTERNAL_INFO)) {
        //
        // Access checks are not disabled. Check authentication.
        // When info APIs are called from local machine they
        // use NTLM so allow NTLM for info APIs.
        //
        WStatus = CheckAuthForInfoAPIs(ServerHandle);
    } else {
        WStatus = CheckAuth(ServerHandle);
    }

CLEANUP:

    return WStatus;
}

DWORD
FrsRpcCheckAuthIfEnabledForCommitDemotion(
  IN HANDLE   ServerHandle,
  IN DWORD    RpcApiIndex
  )
/*++
Routine Description:

Arguments:

    First check if the access checks are disabled. If they are
    disabled then skip authentication.
    Access checks are controlled by a registry key.
    This implies that if the server has the registry set to
    disable access checks then it will accept unauthenticated
    calls.

    There is a seperate key for each API. The input parameter
    RpcApiIndex determines which key to check.

    E.g.
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
    Services\ntfrs\Parameters\Access Checks\Get Perfmon Data
    Access checks are [Enabled or Disabled]

    Interface - UUID and version of the interface.

    RpcApiIndex - identifies key in registry


Return Value:
    ERROR_SUCCESS if we will allow the call to go through..
    ERROR_ACCESS_DENIED if authentication fails.

--*/
{
    FRS_REG_KEY_CODE   EnableKey;
    PWCHAR  ApiName;
    PWCHAR  WStr = NULL, TrimStr;
    DWORD WStatus = ERROR_ACCESS_DENIED;

    // Check if RpcApiIndex is within range.
    if (RpcApiIndex >= ACX_MAX) {
        goto CHECK_AUTH;
    }
    //
    // Get the key and the api name for this index from
    // the global table.
    //
    EnableKey = RpcApiKeys[RpcApiIndex].Enable;
    ApiName   = RpcApiKeys[RpcApiIndex].KeyName;

    WStatus = CfgRegReadString(EnableKey, NULL, 0, &WStr);
    if (WStr == NULL) {
        DPRINT1_WS(0, "++ ERROR - API Access enable check for API (%ws) failed.", ApiName, WStatus);
        if (WIN_SUCCESS(WStatus)) {
            WStatus = ERROR_GEN_FAILURE;
        }
        goto CLEANUP;
    }

    //
    // If access checks are disabled then we're done.
    //
    TrimStr = FrsWcsTrim(WStr, L' ');
    if (WSTR_EQ(TrimStr, ACCESS_CHECKS_ARE_DISABLED) ||
        WSTR_EQ(TrimStr, ACCESS_CHECKS_ARE_DEFAULT_DISABLED)) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

CHECK_AUTH:
    //
    // Access checks are not disabled. Check authentication.
    // Commit of DC demotion can only be called over local RPC 
    // using NTLM.
    //
    WStatus = CheckAuthForLocalRpc(ServerHandle);

CLEANUP:

    return WStatus;
}


VOID
RegisterRpcInterface(
    )
/*++
Routine Description:
    Register the frsrpc interface for the RPC protocol sequences
    previously registered.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "RegisterRpcInterface:"
    RPC_STATUS  Status;

    //
    // Service RPC
    //

#ifdef DS_FREE
    //
    // In ds_free mode we bind without authentication so we
    // don't want a security callback.
    //
    Status = RpcServerRegisterIfEx(SERVER_frsrpc_ServerIfHandle,
                                   NULL,
                                   NULL,
                                   0,
                                   MaxRpcServerThreads,
                                   NULL);
#else
    Status = RpcServerRegisterIfEx(SERVER_frsrpc_ServerIfHandle,
                                   NULL,
                                   NULL,
                                   RPC_IF_ALLOW_SECURE_ONLY,
                                   MaxRpcServerThreads,
                                   FrsRpcSecurityCallback);
#endif DS_FREE
    if (!RPC_SUCCESS(Status)) {
        DPRINT_WS(0, "++ ERROR - Can't register NtFrs Service;", Status);
        FrsRaiseException(FRS_ERROR_REGISTERIF, Status);
    }

    //
    // API RPC
    //
    Status = RpcServerRegisterIfEx(NtFrsApi_ServerIfHandle,
                                   NULL,
                                   NULL,
                                   0,
                                   MaxRpcServerThreads,
                                   NULL);
    if (!RPC_SUCCESS(Status)) {
        DPRINT_WS(0, "++ ERROR - Can't register NtFrs API;", Status);
        FrsRaiseException(FRS_ERROR_REGISTERIF, Status);
    }

    if (HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
        //
        // PERFMON RPC
        //
#ifdef DS_FREE
        //
        // The FrsRpcSecurityCallbackForPerfmonAPIs checks the registry
        // setting before granting access so we can leave that on in
        // ds_free environments.
        //
        Status = RpcServerRegisterIfEx(PerfFrs_ServerIfHandle,
                                       NULL,
                                       NULL,
                                       0,
                                       MaxRpcServerThreads,
                                       FrsRpcSecurityCallbackForPerfmonAPIs);
#else
        Status = RpcServerRegisterIfEx(PerfFrs_ServerIfHandle,
                                       NULL,
                                       NULL,
                                       RPC_IF_ALLOW_SECURE_ONLY,
                                       MaxRpcServerThreads,
                                       FrsRpcSecurityCallbackForPerfmonAPIs);
#endif DS_FREE
        if (!RPC_SUCCESS(Status)) {
            DPRINT_WS(0, "++ ERROR - Can't register PERFMON SERVICE;", Status);
            FrsRaiseException(FRS_ERROR_REGISTERIF, Status);
        }
    }
}


VOID
StartServerRpc(
    )
/*++
Routine Description:
    Register the endpoints for each of the protocol sequences that
    the frsrpc interface supports and then listen for client requests.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "StartServerRpc:"
    RPC_STATUS          Status, Status1;
    UUID_VECTOR         Uuids;
    UUID_VECTOR         *pUuids         = NULL;
    RPC_BINDING_VECTOR  *BindingVector  = NULL;

    //
    // The protocol sequences that frsrpc is registered for
    //
    Status = RpcServerInqBindings(&BindingVector);
    if (!RPC_SUCCESS(Status)) {
        DPRINT_WS(0, "++ ERROR - Can't get binding vector;", Status);
        FrsRaiseException(FRS_ERROR_INQ_BINDINGS, Status);
    }

    //
    // Register endpoints with the endpoint mapper (RPCSS)
    //
    if (ServerGuid) {
        //
        // For hardwired -- Eventually DS Free configs.
        //
        Uuids.Count = 1;
        Uuids.Uuid[0] = ServerGuid;
        pUuids = &Uuids;
    }

    //
    // Service RPC
    //
    Status = RpcEpRegister(SERVER_frsrpc_ServerIfHandle,
                           BindingVector,
                           pUuids,
                           L"NtFrs Service");
    if (!RPC_SUCCESS(Status)) {
        DPRINT_WS(0, "++ ERROR - Can't register NtFrs Service Ep;", Status);
        FrsRaiseException(FRS_ERROR_REGISTEREP, Status);
    }

    //
    // API RPC
    //
    Status = RpcEpRegister(NtFrsApi_ServerIfHandle,
                           BindingVector,
                           NULL,
                           L"NtFrs API");
    if (!RPC_SUCCESS(Status)) {
        DPRINT_WS(0, "++ ERROR - Can't register NtFrs API Ep;", Status);
        FrsRaiseException(FRS_ERROR_REGISTEREP, Status);
    }

    if (HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
        //
        // PERFMON RPC
        //
        Status = RpcEpRegister(PerfFrs_ServerIfHandle,
                               BindingVector,
                               NULL,
                               L"PERFMON SERVICE");
        if (!RPC_SUCCESS(Status)) {
            DPRINT1(0, "++ ERROR - Can't register PERFMON SERVICE Ep; RStatus %d\n",
                    Status);
            FrsRaiseException(FRS_ERROR_REGISTEREP, Status);
        }
    }

    //
    // Listen for client requests
    //
    Status = RpcServerListen(1, MaxRpcServerThreads, TRUE);
    if (!RPC_SUCCESS(Status)) {
        DPRINT_WS(0, "++ ERROR - Can't listen;", Status);
        FrsRaiseException(FRS_ERROR_LISTEN, Status);
    }

    Status1 = RpcBindingVectorFree(&BindingVector);
    DPRINT_WS(0, "++ WARN - RpcBindingVectorFree;",  Status1);
}


PWCHAR
FrsRpcDns2Machine(
    IN  PWCHAR  DnsName
    )
/*++
Routine Description:
    Convert a DNS name(machine....) into a computer name.

Arguments:
    DnsName

Return Value:
    Computer name
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcDns2Machine:"
    PWCHAR  Machine;
    ULONG   Period;

    //
    // Find the period
    //
    if (DnsName) {
        Period = wcscspn(DnsName, L".");
    } else {
        return FrsWcsDup(DnsName);
    }
    if (DnsName[Period] != L'.') {
        return FrsWcsDup(DnsName);
    }

    Machine = FrsAlloc((Period + 1) * sizeof(WCHAR));
    CopyMemory(Machine, DnsName, Period * sizeof(WCHAR));
    Machine[Period] = L'\0';

    DPRINT2(4, ":S: Dns %ws to Machine %ws\n", DnsName, Machine);

    return Machine;
}


DWORD
FrsRpcBindToServerGuid(
    IN  PGNAME   Name,
    OUT handle_t *Handle
    )
/*++
Routine Description:
    Set up the bindings to our inbound/outbound partner.

Arguments:
    Name
    Handle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcBindToServerGuid:"
    DWORD   WStatus;
    LONG    DeltaBinds;
    PWCHAR  GuidStr         = NULL;
    PWCHAR  BindingString   = NULL;
    PWCHAR  MachineName;

    FRS_ASSERT(RPC_S_OK == ERROR_SUCCESS);
    FRS_ASSERT(ServerGuid);

    //
    // Emulating multiple machines with hardwired config
    //
    if (Name->Guid != NULL) {
        WStatus = UuidToString(Name->Guid, &GuidStr);
        CLEANUP_WS(0, "++ ERROR - Translating Guid to string;", WStatus, CLEANUP);
    }
    //
    // Basically, bind to the server's RPC name on this machine. Trim leading \\
    //
    MachineName = Name->Name;
    FRS_TRIM_LEADING_2SLASH(MachineName);

    WStatus = RpcStringBindingCompose(GuidStr, PROTSEQ_TCP_IP, MachineName,
                                      NULL, NULL, &BindingString);
    CLEANUP1_WS(0, "++ ERROR - Composing for %ws;", Name->Name, WStatus, CLEANUP);

    //
    // Store the binding in the handle
    //
    WStatus = RpcBindingFromStringBinding(BindingString, Handle);
    CLEANUP1_WS(0, "++ ERROR - Storing binding for %ws;", Name->Name, WStatus, CLEANUP);

    DPRINT1(4, ":S: Bound to %ws\n", Name->Name);

    //
    // Some simple stats for debugging
    //
    DeltaBinds = ++RpcBinds - RpcUnBinds;
    if (DeltaBinds > RpcMaxBinds) {
        RpcMaxBinds = DeltaBinds;
    }
    // Fall through

CLEANUP:
    if (BindingString) {
        RpcStringFreeW(&BindingString);
    }
    if (GuidStr) {
        RpcStringFree(&GuidStr);
    }
    //
    // We are now ready to talk to the server using the frsrpc interfaces
    //
    return WStatus;
}


DWORD
FrsRpcBindToServerNotService(
    IN  PGNAME   Name,
    IN  PWCHAR   PrincName,
    IN  ULONG    AuthLevel,
    OUT handle_t *Handle
    )
/*++
Routine Description:
    Set up the bindings to our inbound/outbound partner.

Arguments:
    Name
    PrincName
    AuthLevel
    Handle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcBindToServerNotSevice:"
    DWORD   WStatus;
    LONG    DeltaBinds;
    PWCHAR  InqPrincName    = NULL;
    PWCHAR  BindingString   = NULL;
    PWCHAR  MachineName;

    //
    // Basically, bind to the server's RPC name on this machine.  Trim leading \\
    //
    MachineName = Name->Name;
    FRS_TRIM_LEADING_2SLASH(MachineName);

    WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, MachineName,
                                      NULL, NULL, &BindingString);
    CLEANUP1_WS(0, "++ ERROR - Composing for %ws;", Name->Name, WStatus, CLEANUP);

    //
    // Store the binding in the handle
    //
    WStatus = RpcBindingFromStringBinding(BindingString, Handle);
    CLEANUP1_WS(0, "++ ERROR - Storing binding for %ws;", Name->Name, WStatus, CLEANUP);

    //
    // Not authenticating
    //
    if (KerberosIsNotAvailable ||
        AuthLevel == CXTION_AUTH_NONE) {
        goto done;
    }

    //
    // When not running as a service, we can't predict our
    // principle name so simply resolve the binding.
    //
    WStatus = RpcEpResolveBinding(*Handle, frsrpc_ClientIfHandle);
    CLEANUP_WS(4, "++ ERROR: resolving binding;", WStatus, CLEANUP);

    WStatus = RpcMgmtInqServerPrincName(*Handle,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        &InqPrincName);
    CLEANUP_WS(0, "++ ERROR: resolving PrincName;", WStatus, CLEANUP);

    DPRINT1(4, ":S: Inq PrincName is %ws\n", InqPrincName);

    //
    // Put our authentication info into the handle
    //
    if (MutualAuthenticationIsEnabled || MutualAuthenticationIsEnabledAndRequired) {
        WStatus = RpcBindingSetAuthInfoEx(*Handle,
                                          InqPrincName,
                                          RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                          RPC_C_AUTHN_GSS_NEGOTIATE,
                                          NULL,
                                          RPC_C_AUTHZ_NONE,
                                          &RpcSecurityQos);
        DPRINT2_WS(1, "++ WARN - RpcBindingSetAuthInfoEx(%ws, %ws);",
                   Name->Name, InqPrincName, WStatus);
    } else {
        WStatus = ERROR_NOT_SUPPORTED;
    }
    //
    // Fall back to manual mutual authentication
    //
    if (!MutualAuthenticationIsEnabledAndRequired && !WIN_SUCCESS(WStatus)) {
        WStatus = RpcBindingSetAuthInfo(*Handle,
                                        InqPrincName,
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        NULL,
                                        RPC_C_AUTHZ_NONE);
    }
    CLEANUP2_WS(0, "++ ERROR - RpcBindingSetAuthInfo(%ws, %ws);",
                Name->Name, InqPrincName, WStatus, CLEANUP);

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

done:
    DPRINT1(4, ":S: Bound to %ws\n", Name->Name);

    //
    // Some simple stats for debugging
    //
    DeltaBinds = ++RpcBinds - RpcUnBinds;
    if (DeltaBinds > RpcMaxBinds) {
        RpcMaxBinds = DeltaBinds;
    }
    // Fall through

CLEANUP:
    if (BindingString) {
        RpcStringFreeW(&BindingString);
    }
    if (InqPrincName) {
        RpcStringFree(&InqPrincName);
    }
    //
    // We are now ready to talk to the server using the frsrpc interfaces
    //
    return WStatus;
}


DWORD
FrsRpcBindToServer(
    IN  PGNAME   Name,
    IN  PWCHAR   PrincName,
    IN  ULONG    AuthLevel,
    OUT handle_t *Handle
    )
/*++
Routine Description:
    Set up the bindings to our inbound/outbound partner.

Arguments:
    Name
    PrincName
    AuthLevel
    Handle

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcBindToServer:"
    DWORD   WStatus;
    LONG    DeltaBinds;
    PWCHAR  BindingString   = NULL;
    PWCHAR  MachineName;

    FRS_ASSERT(RPC_S_OK == ERROR_SUCCESS);

    //
    // Emulating multiple machines with hardwired config
    // For hardwired -- Eventually DS Free configs.
    //
    if (ServerGuid) {
        return (FrsRpcBindToServerGuid(Name, Handle));
    }

    //
    // Not running as a service; relax binding constraints
    //
    if (!RunningAsAService) {
        return (FrsRpcBindToServerNotService(Name, PrincName, AuthLevel, Handle));
    }
    //
    // Basically, bind to the NtFrs running on Name.  Trim leading \\
    //
    MachineName = Name->Name;
    FRS_TRIM_LEADING_2SLASH(MachineName);

    WStatus = RpcStringBindingCompose(NULL, PROTSEQ_TCP_IP, MachineName,
                                      NULL, NULL, &BindingString);
    CLEANUP1_WS(0, "++ ERROR - Composing for %ws;", Name->Name, WStatus, CLEANUP);

    //
    // Store the binding in the handle
    //
    WStatus = RpcBindingFromStringBinding(BindingString, Handle);
    CLEANUP1_WS(0, "++ ERROR - Storing binding for %ws;", Name->Name, WStatus, CLEANUP);

    //
    // Not authenticating
    //
    if (KerberosIsNotAvailable ||
        AuthLevel == CXTION_AUTH_NONE) {
        DPRINT1(4, ":S: Not authenticating %ws\n", Name->Name);
        goto done;
    }

    //
    // Put our authentication info into the handle
    //
    if (MutualAuthenticationIsEnabled || MutualAuthenticationIsEnabledAndRequired) {
        WStatus = RpcBindingSetAuthInfoEx(*Handle,
                                          PrincName,
                                          RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                          RPC_C_AUTHN_GSS_NEGOTIATE,
                                          NULL,
                                          RPC_C_AUTHZ_NONE,
                                          &RpcSecurityQos);
        DPRINT2_WS(1, "++ WARN - RpcBindingSetAuthInfoEx(%ws, %ws);",
                   Name->Name, PrincName, WStatus);
    } else {
        WStatus = ERROR_NOT_SUPPORTED;
    }
    //
    // Fall back to manual mutual authentication
    //
    if (!MutualAuthenticationIsEnabledAndRequired && !WIN_SUCCESS(WStatus)) {
        WStatus = RpcBindingSetAuthInfo(*Handle,
                                        PrincName,
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        NULL,
                                        RPC_C_AUTHZ_NONE);
    }
    CLEANUP2_WS(0, "++ ERROR - RpcBindingSetAuthInfo(%ws, %ws);",
                Name->Name, PrincName, WStatus, CLEANUP);

    //
    // SUCCESS
    //
    WStatus = ERROR_SUCCESS;

done:
    DPRINT1(4, ":S: Bound to %ws\n", Name->Name);

    //
    // Some simple stats for debugging
    //
    DeltaBinds = ++RpcBinds - RpcUnBinds;
    if (DeltaBinds > RpcMaxBinds) {
        RpcMaxBinds = DeltaBinds;
    }
    // Fall through

CLEANUP:
    if (BindingString) {
        RpcStringFreeW(&BindingString);
    }
    //
    // We are now ready to talk to the server using the frsrpc interfaces
    //
    return WStatus;
}


VOID
FrsRpcUnBindFromServer(
        handle_t    *Handle
    )
/*++
Routine Description:
    Unbind from the server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcUnBindFromServer:"
    DWORD  WStatus;
    //
    // Simple stats for debugging
    //
    ++RpcUnBinds;
    try {
        if (Handle) {
            WStatus = RpcBindingFree(Handle);
            DPRINT_WS(0, "++ WARN - RpcBindingFree;",  WStatus);
            *Handle = NULL;
        }
    } except (FrsException(GetExceptionInformation())) {
    }
}


VOID
FrsRpcInitializeAccessChecks(
    VOID
    )
/*++

Routine Description:
    Create the registry keys that are used to check for access to
    the RPC calls that are exported for applications. The access checks
    have no affect on the RPC calls used for replication.

    The access checks for a given RPC call can be enabled or disabled
    by setting a registry value. If enabled, the RPC call impersonates
    the caller and attempts to open the registry key with the access
    required for that RPC call. The required access is a registry value.
    For example, the following registry hierarchy shows that the
    "Set Ds Polling Interval" has access checks enabled and requires
    write access while "Get Ds Polling Interval" has no access checks.
        NtFrs\Parameters\Access Checks\Set Ds Polling Interval
            Access checks are [enabled | disabled] REG_SZ enabled
            Access checks require [read | write] REG_SZ write

        NtFrs\Parameters\Access Checks\Get Ds Polling Interval
            Access checks are [enabled | disabled] REG_SZ disabled


    The initial set of RPC calls are:  (see key context entries in config.c)
        dcpromo                  - enabled, write
        Set Ds Polling Interval  - enabled, write
        Start Ds Polling         - enabled, read
        Get Ds Polling Interval  - enabled, read
        Get Internal Information - enabled, write
        Get Perfmon Data         - enabled, read

Arguments:
    None.

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsRpcInitializeAccessChecks:"
    DWORD   WStatus;
    DWORD   i;
    PWCHAR  AccessChecksAre = NULL;
    PWCHAR  AccessChecksRequire = NULL;
    FRS_REG_KEY_CODE FrsRkc;
    PWCHAR  ApiName;



    for (i = 0; i < ACX_MAX; ++i) {

        FrsRkc = RpcApiKeys[i].Enable;
        ApiName = RpcApiKeys[i].KeyName;

        //
        // Read the current string Access Check Enable string.
        //
        CfgRegReadString(FrsRkc, NULL, 0, &AccessChecksAre);
        if ((AccessChecksAre == NULL) ||
            WSTR_EQ(AccessChecksAre, ACCESS_CHECKS_ARE_DEFAULT_DISABLED)||
            WSTR_EQ(AccessChecksAre, ACCESS_CHECKS_ARE_DEFAULT_ENABLED)) {
            //
            // The key is in the default state so we can clobber it with a
            // new default.
            //
            WStatus = CfgRegWriteString(FrsRkc, NULL, FRS_RKF_FORCE_DEFAULT_VALUE, NULL);
            DPRINT1_WS(0, "++ WARN - Cannot create Enable key for %ws;", ApiName, WStatus);

            AccessChecksAre = FrsFree(AccessChecksAre);

            //
            // Now reread the key for the new default.
            //
            WStatus = CfgRegReadString(FrsRkc, NULL, 0, &AccessChecksAre);
        }

        DPRINT4(4, ":S: AccessChecks: ...\\%ws\\%ws\\%ws = %ws\n",
                ACCESS_CHECKS_KEY, ApiName, ACCESS_CHECKS_ARE, AccessChecksAre);

        if (AccessChecksAre &&
            (WSTR_EQ(AccessChecksAre, ACCESS_CHECKS_ARE_DEFAULT_DISABLED) ||
             WSTR_EQ(AccessChecksAre, ACCESS_CHECKS_ARE_DISABLED))) {
            //
            // Put a notice in the event log that the access check is disabled.
            //
            EPRINT2(EVENT_FRS_ACCESS_CHECKS_DISABLED, ApiName, ACCESS_CHECKS_ARE);
        }
        AccessChecksAre = FrsFree(AccessChecksAre);


        //
        // Create the Access Rights value.  This determines what rights the caller
        // must have in order to use the API.  These rights are used when we
        // open the API key after impersonating the RPC caller.  If the key
        // open works then the API call can proceed else we return insufficient
        // privilege status (FRS_ERR_INSUFFICENT_PRIV).
        //

        FrsRkc = RpcApiKeys[i].Rights;

        CfgRegReadString(FrsRkc, NULL, 0, &AccessChecksRequire);

        if ((AccessChecksRequire == NULL)||
            WSTR_EQ(AccessChecksRequire, ACCESS_CHECKS_REQUIRE_DEFAULT_READ)||
            WSTR_EQ(AccessChecksRequire, ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE)) {

            //
            // The key is in the default state so we can clobber it with a
            // new default.
            //
            WStatus = CfgRegWriteString(FrsRkc, NULL, FRS_RKF_FORCE_DEFAULT_VALUE, NULL);
            DPRINT1_WS(0, "++ WARN - Cannot set access rights key for %ws;", ApiName, WStatus);

            AccessChecksRequire = FrsFree(AccessChecksRequire);

            //
            // Now reread the key for the new default.
            //
            CfgRegReadString(FrsRkc, NULL, 0, &AccessChecksRequire);
        }

        DPRINT4(4, ":S: AccessChecks: ...\\%ws\\%ws\\%ws = %ws\n",
                ACCESS_CHECKS_KEY, ApiName, ACCESS_CHECKS_REQUIRE, AccessChecksRequire);

        AccessChecksRequire = FrsFree(AccessChecksRequire);

    }  // end for


    FrsFree(AccessChecksAre);
    FrsFree(AccessChecksRequire);
}


VOID
ShutDownRpc(
    )
/*++
Routine Description:
    Shutdown the client and server side of RPC.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "ShutDownRpc:"
    RPC_STATUS              WStatus;
    RPC_BINDING_VECTOR      *BindingVector = NULL;

    //
    // Server side
    //
    // Stop listening for new calls
    //
    try {
        WStatus = RpcMgmtStopServerListening(0) ;
        DPRINT_WS(0, "++ WARN - RpcMgmtStopServerListening;",  WStatus);

    } except (FrsException(GetExceptionInformation())) {
    }

    try {
        //
        // Get our registered interfaces
        //
        WStatus = RpcServerInqBindings(&BindingVector);
        DPRINT_WS(0, "++ WARN - RpcServerInqBindings;",  WStatus);
        if (RPC_SUCCESS(WStatus)) {
            //
            // And unexport the interfaces together with their dynamic endpoints
            //
            WStatus = RpcEpUnregister(SERVER_frsrpc_ServerIfHandle, BindingVector, 0);
            DPRINT_WS(0, "++ WARN - RpcEpUnregister SERVER_frsrpc_ServerIfHandle;",  WStatus);

            WStatus = RpcEpUnregister(NtFrsApi_ServerIfHandle, BindingVector, 0);
            DPRINT_WS(0, "++ WARN - RpcEpUnregister NtFrsApi_ServerIfHandle;",  WStatus);

            if (HANDLE_IS_VALID(PerfmonProcessSemaphore)) {
                //
                // PERFMON RPC
                //
                WStatus = RpcEpUnregister(PerfFrs_ServerIfHandle, BindingVector, 0);
                DPRINT_WS(0, "++ WARN - RpcEpUnregister PerfFrs_ServerIfHandle;",  WStatus);
            }

            WStatus = RpcBindingVectorFree(&BindingVector);
            DPRINT_WS(0, "++ WARN - RpcBindingVectorFree;",  WStatus);
        }
        //
        // Wait for any outstanding RPCs to finish.
        //
        WStatus = RpcMgmtWaitServerListen();
        DPRINT_WS(0, "++ WARN - RpcMgmtWaitServerListen;",  WStatus);

    } except (FrsException(GetExceptionInformation())) {
    }
}


VOID
FrsRpcUnInitialize(
    VOID
    )
/*++
Routine Description:
    Free up memory once all of the threads in the system have been
    shut down.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcUnInitialize:"
    DPRINT(4, ":S: Free sysvol name table.\n");
    DEBUG_FLUSH();
    SysVolsBeingCreated = GTabFreeTable(SysVolsBeingCreated, NULL);
    if (ServerPrincName) {
        if (KerberosIsNotAvailable) {

            DPRINT(4, ":S: Free ServerPrincName (no kerberos).\n");
            DEBUG_FLUSH();
            ServerPrincName = FrsFree(ServerPrincName);

        } else {

            DPRINT(4, ":S: Free ServerPrincName (kerberos).\n");
            DEBUG_FLUSH();
            ServerPrincName = FrsFree(ServerPrincName);
        }
    }
    DPRINT(4, ":S: Done uninitializing RPC.\n");
    DEBUG_FLUSH();
}


BOOL
FrsRpcInitialize(
    VOID
    )
/*++
Routine Description:
    Initializting This thread is kicked off by the main thread. This thread sets up
    the server and client side of RPC for the frsrpc interface.

Arguments:
    Arg - Needed to set status for our parent.

Return Value:
    TRUE    - RPC has started
    FALSE   - RPC could not be started
--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsRpcInitialize:"
    BOOL    StartedOK = FALSE;

    try {


        //
        // Get the maximum number of concurrent RPC calls out of registry.
        //
        CfgRegReadDWord(FKC_MAX_RPC_SERVER_THREADS, NULL, 0, &MaxRpcServerThreads);
        DPRINT1(0,":S: Max RPC threads is %d\n", MaxRpcServerThreads);

        //
        // Get user specified port assignment for RPC.
        //
        CfgRegReadDWord(FKC_RPC_PORT_ASSIGNMENT, NULL, 0, &RpcPortAssignment);
        DPRINT1(0,":S: RPC port assignment is %d\n", RpcPortAssignment);

        //
        // Register protocol sequences
        //
        RegisterRpcProtseqs();
        DPRINT(0, ":S: FRS RPC protocol sequences registered\n");

        //
        // Register frsrpc interface
        //
        RegisterRpcInterface();
        DPRINT(0, ":S: FRS RPC interface registered\n");

        //
        // Start listening for clients
        //
        StartServerRpc();
        DPRINT(0, ":S: FRS RPC server interface installed\n");

        //
        // Table of sysvols being created
        //
        if (!SysVolsBeingCreated) {
            SysVolsBeingCreated = GTabAllocTable();
        }

        StartedOK = TRUE;

    } except (FrsException(GetExceptionInformation())) {
        DPRINT(0, ":S: Can't start RPC\n");
    }
    //
    // Cleanup
    //
    try {
        if (!StartedOK) {
            ShutDownRpc();
        }
    } except (FrsException(GetExceptionInformation())) {
        DPRINT(0, ":S: Can't shutdown RPC\n");
    }

    //
    // DONE
    //

    //
    // Free up the rpc initialization memory
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
    return StartedOK;
}

DWORD
FrsIsPathInReplica(
    IN PWCHAR Path,
    IN PREPLICA Replica,
    OUT BOOL *Replicated
    )
{
#undef DEBSUB
#define  DEBSUB  "FrsIsPathInReplica:"

    DWORD WStatus = ERROR_SUCCESS;
    PWCHAR ReplicaRoot = NULL;
    PWCHAR TraversedPath = NULL;

    if(Replicated == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    *Replicated = FALSE;

    WStatus = FrsTraverseReparsePoints(Replica->Root, &ReplicaRoot);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", Replica->Root, WStatus);
        goto Exit;
    }

    WStatus = FrsTraverseReparsePoints(Path, &TraversedPath);
    if ( !WIN_SUCCESS(WStatus) ) {
        DPRINT2(0,"ERROR - FrsTraverseReparsePoints for %ws, WStatus = %d\n", Path, WStatus);
        goto Exit;
    }

    if (ReplicaRoot && TraversedPath && (-1 == FrsIsParent(ReplicaRoot, TraversedPath))) {
        *Replicated = TRUE;
    }

Exit:
    FrsFree(ReplicaRoot);
    FrsFree(TraversedPath);

    return WStatus;

}

DWORD
NtFrsApi_Rpc_IsPathReplicated(
    IN handle_t Handle,
    IN PWCHAR Path,
    IN ULONG ReplicaSetTypeOfInterest,
    OUT ULONG *Replicated,
    OUT ULONG *Primary,
    OUT ULONG *Root,
    OUT GUID *ReplicaSetGuid
    )
/*++
Routine Description:

    Checks if the Path given is part of a replica set of type
    ReplicaSetTypeOfInterest. If ReplicaSetTypeOfInterest is 0, will match for
    any replica set type.On successful execution the OUT parameters are set as
    follows:

        Replicated == TRUE iff Path is part of a replica set of type
                               ReplicaSetTypeOfInterest

        Primary == 0 if this machine is not the primary for the replica set
                   1 if this machine is the primary for the replica set
                   2 if there is no primary for the replica set

        Root == TRUE iff Path is the root path for the replica

Arguments:

    Handle -

    Path - the local path to check

    ReplicaSetTypeOfInterest - The type of replica set to match against. Set to
                               0 to match any replica set.

    Replicated - set TRUE iff Path is part of a replica set of type
                 ReplicaSetTypeOfInterest.
                 If Replicated is FALSE, the other OUT parameters are not set.

    Primary - set to 0 if this machine is not the primary for the replica set
                     1 if this machine is the primary for the replica set
                     2 if there is no primary for the replica set

    Root - set TRUE iff Path is the root path for the replica.

    ReplicaGuid - GUID for the matching replica set.

    GuidSize - MUST be sizeof(GUID)

Return Value:

      Win32 Status

--*/
{
#undef DEBSUB
#define  DEBSUB  "NtFrsApi_Rpc_IsPathReplicated"
    DWORD   WStatus;


    try {
        //
        // Checkauthentication if the auth check is not disabled
        // by setting the registry value:
        // Access checks are [Enabled or Disabled]
        // Each API has a different registry location so this
        // can not be put in the rpc callback function.
        //
        WStatus = FrsRpcCheckAuthIfEnabled(Handle, ACX_IS_PATH_REPLICATED);
        CLEANUP_WS(0, "++ ERROR - FrsRpcCheckAuthIfEnabled failed;",
                    WStatus, CLEANUP);

        WStatus = FrsRpcAccessChecks(Handle, ACX_IS_PATH_REPLICATED);

        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // Validate parameters
        //

        if((Replicated == NULL) ||
           (Primary == NULL) ||
           (Root == NULL) ||
           (Path == NULL) ||
           (ReplicaSetGuid == NULL)) {

        return FRS_ERR_INVALID_SERVICE_PARAMETER;
        }

        WStatus = FrsIsPathReplicated(Path, ReplicaSetTypeOfInterest, Replicated, Primary, Root, ReplicaSetGuid);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }

        //
        // SUCCESS
        //
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "++ ERROR - Exception.", WStatus);
    }

    return WStatus;
}

DWORD
FrsIsPathReplicated(
    IN PWCHAR Path,
    IN ULONG ReplicaSetTypeOfInterest,
    OUT ULONG *Replicated,
    OUT ULONG *Primary,
    OUT ULONG *Root,
    OUT GUID  *ReplicaSetGuid
    )
/*++
Routine Description:

    Checks if the Path given is part of a replica set of type
    ReplicaSetTypeOfInterest. If ReplicaSetTypeOfInterest is 0, will match for
    any replica set type.On successful execution the OUT parameters are set as
    follows:

        Replicated == TRUE iff Path is part of a replica set of type
                               ReplicaSetTypeOfInterest

        Primary == 0 if this machine is not the primary for the replica set
                   1 if this machine is the primary for the replica set
                   2 if there is no primary for the replica set

        Root == TRUE iff Path is the root path for the replica

Arguments:

    Path - the local path to check

    ReplicaSetTypeOfInterest - The type of replica set to match against. Set to
                               0 to match any replica set.

    Replicated - set TRUE iff Path is part of a replica set of type
                 ReplicaSetTypeOfInterest.
                 If Replicated is FALSE, the other OUT parameters are not set.

    Primary - set to 0 if this machine is not the primary for the replica set
                     1 if this machine is the primary for the replica set
                     2 if there is no primary for the replica set

    Root - set TRUE iff Path is the root path for the replica.

    ReplicaSetGuid - GUID of the matching replica set

Return Value:

      Win32 Status

--*/
{
#undef DEBSUB
#define  DEBSUB  "FrsIsPathReplicated:"

    DWORD WStatus = ERROR_SUCCESS;


    *Replicated = FALSE;

    //
    // Check active each replica
    //
    ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
        // Loop iterator pE is type PREPLICA.
        if(((ReplicaSetTypeOfInterest == 0) ||
            (ReplicaSetTypeOfInterest == pE->ReplicaSetType))) {
            //
            // Ignoring return code.
            // Even if this check gives an error we still go on to the next
            //
            FrsIsPathInReplica(Path, pE, Replicated);
            if(Replicated) {
                *Primary = (BooleanFlagOn(pE->CnfFlags, CONFIG_FLAG_PRIMARY)?1:0);
                *Root = !_wcsicmp(Path, pE->Root);
                *ReplicaSetGuid = *(pE->SetName->Guid);
                goto Exit;
            }
         }
    );

    //
    // also need to check replicas in error states
    //
    ForEachListEntry( &ReplicaFaultListHead, REPLICA, ReplicaList,
        // Loop iterator pE is type PREPLICA.
        if(((ReplicaSetTypeOfInterest == 0) ||
            (ReplicaSetTypeOfInterest == pE->ReplicaSetType))) {
            //
            // Ignoring return code.
            // Even if this check gives an error we still go on to the next
            //
            FrsIsPathInReplica(Path, pE, Replicated);
            if(Replicated) {
                *Primary = (BooleanFlagOn(pE->CnfFlags, CONFIG_FLAG_PRIMARY)?1:0);
                *Root = !_wcsicmp(Path, pE->Root);
                *ReplicaSetGuid = *(pE->SetName->Guid);
                goto Exit;
            }
        }
    );

    //
    // Don't check stopped replicas. They have probably been deleted.
    //


Exit:
     return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsrpc_s_stub.c ===
#include "frsrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\install.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    install.c

Abstract:
    Staging File Install Command Server.

Author:
    Billy J. Fuller 09-Jun-1997

Environment
    User mode winnt

--*/
#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>


//
// Struct for the Staging File Generator Command Server
//      Contains info about the queues and the threads
//
COMMAND_SERVER InstallCs;

ULONG  MaxInstallCsThreads;

//
// Count the number of files currently being installed.
//
LONG   FrsFilesInInstall = -1;


#if 0
//
// Currently unused.
//
//
// Retry times
//
#define INSTALLCS_RETRY_MIN (1 * 1000)  // 1 second
#define INSTALLCS_RETRY_MAX (10 * 1000) // 10 seconds

BOOL
InstallCsDelCsSubmit(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Set the timer and kick off a delayed staging file command

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InstallCsDelCsSubmit:"
    //
    // Extend the retry time (but not too long)
    //
    RsTimeout(Cmd) <<= 1;
    if (RsTimeout(Cmd) > INSTALLCS_RETRY_MAX)
        return FALSE;
    //
    // or too short
    //
    if (RsTimeout(Cmd) < INSTALLCS_RETRY_MIN)
        RsTimeout(Cmd) = INSTALLCS_RETRY_MIN;
    //
    // This command will come back to us in a bit
    //
    FrsDelCsSubmitSubmit(&InstallCs, Cmd, RsTimeout(Cmd));
    return TRUE;
}
#endif 0


VOID
InstallCsInstallStage(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:

    Install the staging file into the target file.  If successfull then
    send the CO to the retire code.  If not and the condition is retryable then
    send the CO to the retry code.  Otherwise abort the CO.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InstallCsInstallStage:"
    ULONG   WStatus;
    PCHANGE_ORDER_ENTRY Coe;

    //
    // Install the staging file
    //
    Coe = RsCoe(Cmd);

    WStatus = StuInstallStage(Coe);
    if (!WIN_SUCCESS(WStatus)) {

        if (DOES_CO_DELETE_FILE_NAME(RsCoc(Cmd))) {

            //
            // All delete and moveout change orders go thru retire.  At this
            // point they are done except possibly for the final on-disk
            // delete.  If the on-disk delete failed then the
            // COE_FLAG_NEED_DELETE is set in the
            // change order which sets IDREC_FLAGS_DELETE_DEFERRED in the
            // IDTable record for the file.
            //
            FRS_ASSERT(COE_FLAG_ON(Coe, COE_FLAG_NEED_DELETE));

            SET_CHANGE_ORDER_STATE(Coe, IBCO_INSTALL_DEL_RETRY);
            PM_INC_CTR_REPSET(Coe->NewReplica, FInstalled, 1);

            //
            // Retire this change order
            //
            ChgOrdInboundRetired(Coe);
            //
            // non-NULL change order entries kick the completion function
            // to start retry/unjoin. No need since we have retired this co.
            //
            RsCoe(Cmd) = NULL;
            goto out;
        }

        //
        // Something is wrong; try again later
        //
        // If it is retryable then retry.
        // Note that an ERROR_FILE_NOT_FOUND return from StuExecuteInstall means that the
        // pre-exisitng target file was not found.  Most likely because it was
        // deleted out from under us.  We should be getting a Local change order
        // that will update the IDTable entry so when this CO is retried later
        // it will get rejected.
        //
        if (WIN_RETRY_INSTALL(WStatus) ||
            (WStatus == ERROR_FILE_NOT_FOUND)) {

            CHANGE_ORDER_TRACEW(3, Coe, "Retrying install", WStatus);
            //
            // Retry this single change order if the namespace isn't
            // being altered (not a create or rename). Otherwise,
            // unjoin the cxtion and force all change orders through
            // retry so they will be retried in order at join; just
            // in case this change order affects later ones.
            //
            // Unjoining is sort of extreme; need less expensive recovery.
            // But if we don't unjoin (say for a rename) and a
            // create CO arrives next then we will have a name conflict
            // that should not have occurred just because a sharing violation
            // prevented us from doing the rename.
            //
            if ((!CoCmdIsDirectory(RsCoc(Cmd))) ||
                (!FrsDoesCoAlterNameSpace(RsCoc(Cmd)))) {
                CHANGE_ORDER_TRACE(3, Coe, "Submit CO to install retry");

                ChgOrdInboundRetry(Coe, IBCO_INSTALL_RETRY);
                //
                // non-NULL change order entries kick the completion
                // function to start a retry/unjoin. No need since we have
                // retired this co.
                //
                RsCoe(Cmd) = NULL;
            }
            goto out;

        } else {
            //
            // Not retryable.
            //
            // Note: If it's not a problem with the staging file we should send
            // it on even if we can't install it.  Not clear what non-retryable
            // errors this would apply to though.  For now just abort it.
            //
            SET_COE_FLAG(Coe, COE_FLAG_STAGE_ABORTED);
            CHANGE_ORDER_TRACEW(3, Coe, "Install failed; co aborted", WStatus);
            //
            // Increment the Files Installed Counter
            //
            PM_INC_CTR_REPSET(Coe->NewReplica, FInstalledError, 1);
        }
    } else {
        //
        // Install succeeded.  Increment the Files Installed Counter.
        //
        CHANGE_ORDER_TRACE(3, Coe, "Install success");
        PM_INC_CTR_REPSET(Coe->NewReplica, FInstalled, 1);
        //
        // If this CO created a preinstall file then tell the retire path to
        // perform the final rename.  Updates to existing files don't create
        // preinstall files.
        //
        if (COE_FLAG_ON(Coe, COE_FLAG_PREINSTALL_CRE)) {
            SET_COE_FLAG(Coe, COE_FLAG_NEED_RENAME);
        }
    }

    //
    // Installing the fetched staging file
    //
    SET_CHANGE_ORDER_STATE(Coe, IBCO_INSTALL_COMPLETE);

    //
    // Retire this change order
    //
    ChgOrdInboundRetired(Coe);
    //
    // non-NULL change order entries kick the completion function
    // to start retry/unjoin. No need since we have retired this co.
    //
    RsCoe(Cmd) = NULL;

out:
    //
    // ERROR_SUCCESS just means we have handled all of the conditions
    // that arose; no need for the cleanup function to intervene.
    //
    // Unless RsCoe(Cmd) is non-NULL; in which case the completion
    // function will initiate a retry/unjoin.
    //
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


DWORD
MainInstallCs(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for a thread serving the Staging File Install Command Server.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "MainInstallCs:"
    ULONG               WStatus = ERROR_SUCCESS;
    PCOMMAND_PACKET     Cmd;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)Arg;
    HANDLE              WaitHandles[2];

    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &InstallCs);
    FrsThread->Exit = ThSupExitWithTombstone;

    //
    // Try-Finally
    //
    try {

        //
        // Capture exception.
        //
        try {
            //
            // Pull entries off the queue and process them
            //

            //
            // Handles to wait on
            //
            WaitHandles[0] = FrsThawEvent;
            WaitHandles[1] = ShutDownEvent;

cant_exit_yet:
            while (Cmd = FrsGetCommandServer(&InstallCs)) {

                InterlockedIncrement(&FrsFilesInInstall);
                DPRINT2(4,"Inc FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);

                if (FrsFrozenForBackup) {
                    if ((InterlockedDecrement(&FrsFilesInInstall) < 0) &&
                        FrsFrozenForBackup) {
                        SetEvent(FrsNoInstallsInProgressEvent);
                    }
                    DPRINT2(4,"Dec FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
                    WaitForMultipleObjects(2, WaitHandles, FALSE, INFINITE);
                    InterlockedIncrement(&FrsFilesInInstall);
                    DPRINT2(4,"Inc FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
                }

                switch (Cmd->Command) {

                    case CMD_INSTALL_STAGE:
                        DPRINT1(3, "Install: command install stage 0x%x\n", Cmd);
                        InstallCsInstallStage(Cmd);
                        break;

                    default:
                        DPRINT1(0, "Staging File Install: unknown command 0x%x\n", Cmd->Command);
                        FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
                        break;
                }

                if ((InterlockedDecrement(&FrsFilesInInstall) < 0) &&
                    FrsFrozenForBackup) {
                    SetEvent(FrsNoInstallsInProgressEvent);
                }
                DPRINT2(4,"Dec FrsFrozen = %d, FrsFilesInInstall = %d\n", FrsFrozenForBackup,FrsFilesInInstall);
            }
            //
            // Exit
            //
            FrsExitCommandServer(&InstallCs, FrsThread);
            goto cant_exit_yet;

        //
        // Get exception status.
        //
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "InstallCs finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "InstallCs terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}



VOID
FrsInstallCsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the staging file installer

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsInstallCsInitialize:"
    //
    // Initialize the command servers
    //


    CfgRegReadDWord(FKC_MAX_INSTALLCS_THREADS, NULL, 0, &MaxInstallCsThreads);

    FrsInitializeCommandServer(&InstallCs, MaxInstallCsThreads, L"InstallCs", MainInstallCs);
}



VOID
ShutDownInstallCs(
    VOID
    )
/*++
Routine Description:
    Shutdown the staging file installer command server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownInstallCs:"
    FrsRunDownCommandServer(&InstallCs, &InstallCs.Queue);
}



VOID
FrsInstallCsSubmitTransfer(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command
    )
/*++
Routine Description:
    Transfer a request to the staging file generator

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsInstallCsSubmitTransfer:"
    //
    // Submit a request to allocate staging area
    //
    Cmd->TargetQueue = &InstallCs.Queue;
    Cmd->Command = Command;
    RsTimeout(Cmd) = 0;
    DPRINT1(5, "Install: submit %x\n", Cmd);
    FrsSubmitCommandServer(&InstallCs, Cmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frstest.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frstest.c

Abstract:
    Test some internals.

Author:

    Billy J. Fuller 20-Mar-1997

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <test.h>

#if DBG

#define FID_BEGIN                       (  0)
#define FID_CONFLICT_FILE               (  1)
#define FID_DONE_CONFLICT_FILE          (  2)
#define FID_DONE                        (128)

ULONG   FidStep = FID_BEGIN;

//
// DBS RENAME FID
//
VOID
TestDbsRenameFidTop(
    IN PCHANGE_ORDER_ENTRY Coe
    )
/*++
Routine Description:
    Test dbs rename fid. Called before DbsRenameFid()

Arguments:
    Coe - change order entry containing the final name.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "TestDbsRenameFidTop:"
    DWORD   WStatus;
    HANDLE  Handle;
    PWCHAR  MorphName;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    if (!DebugInfo.TestFid)
        return;

    switch (FidStep) {
    case FID_DONE_CONFLICT_FILE:
    case FID_DONE:
        break;

    case FID_BEGIN:
        DPRINT(0, "TEST: FID BEGIN\n");
        FidStep = FID_CONFLICT_FILE;
        /* FALL THROUGH */

    case FID_CONFLICT_FILE:
        DPRINT(0, "TEST: FID CONFLICT BEGIN\n");
        //
        // Open the conflicting file
        //
        WStatus = FrsCreateFileRelativeById(&Handle,
                                            Coe->NewReplica->pVme->VolumeHandle,
                                            &Coe->NewParentFid,
                                            FILE_ID_LENGTH,
                                            0,
                                            Coc->FileName,
                                            Coc->FileNameLength,
                                            NULL,
                                            FILE_CREATE,
                                            READ_ACCESS | DELETE);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1(0, "TEST FID CONFLICT ERROR; could not create file %ws\n",
                    Coc->FileName);
            FidStep = FID_DONE;
            break;
        }
        CloseHandle(Handle);
        FidStep = FID_DONE_CONFLICT_FILE;
        break;

    default:
        DPRINT1(0, "TEST: FID ERROR; unknown step %d\n", FidStep);
        return;
    }
}


VOID
TestDbsRenameFidBottom(
    IN PCHANGE_ORDER_ENTRY Coe,
    IN DWORD               WStatus
    )
/*++
Routine Description:
    Test dbs rename fid. Called after DbsRenameFid()

Arguments:
    Coe - change order entry containing the final name.
    Ret

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "TestDbsRenameFidBottom:"

    if (!DebugInfo.TestFid)
        return;

    switch (FidStep) {

    case FID_DONE:
    case FID_CONFLICT_FILE:
        break;

    case FID_DONE_CONFLICT_FILE:
        DPRINT_WS(0, "TEST: NO FID CONFLICT ERROR;", WStatus);
        FidStep = FID_DONE;
        DPRINT(0, "TEST: FID CONFLICT DONE\n");
        break;

    default:
        DPRINT1(0, "TEST: FID ERROR; unknown step %d\n", FidStep);
        return;
    }
}


//
// BEGIN QUEUE TEST SUBROUTINES
//
DWORD   DesiredStatus;
BOOL    CompletionRet = TRUE;

VOID
CompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
{
#undef  DEBSUB
#define DEBSUB "CompletionRoutine:"
    if (Cmd->ErrorStatus != DesiredStatus) {
        DPRINT2(0, "ERROR -- ErrorStatus is %x; not %x\n", Cmd->ErrorStatus, DesiredStatus);
        CompletionRet = FALSE;
    }
    //
    // move on to the next queue
    //
    FrsRtlInsertTailQueue(Arg, &Cmd->ListEntry);
}
#define NUMPKTS     (97)
#define NUMQUEUES   (17)


BOOL
TestEmptyQueues(
    PWCHAR      Str,
    PFRS_QUEUE  Queues,
    PFRS_QUEUE  Control,
    DWORD       ExpectedErr
    )
/*++
Routine Description:
    Check that the queues are empty

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestEmptyQueues:"
    BOOL    Ret = TRUE;
    DWORD   Err;
    INT     i;

    //
    // Make sure the queues are empty
    //
    for (i = 0; i < NUMQUEUES; ++i, ++Queues) {
        if (FrsRtlRemoveHeadQueueTimeout(Queues, 0)) {
            DPRINT2(0, "ERROR -- %ws -- Queue %d is not empty\n", Str, i);
            Ret = FALSE;
        } else {
            Err = GetLastError();
            if (Err != ExpectedErr) {
                DPRINT3(0, "ERROR -- %ws -- Error is %d; not %d\n",
                        Str, Err, ExpectedErr);
                Ret = FALSE;
            }
        }
    }
    if (FrsRtlRemoveHeadQueueTimeout(Control, 0)) {
        DPRINT1(0, "ERROR -- %ws -- control is not empty\n", Str);
        Ret = FALSE;
    }
    return Ret;
}


VOID
TestInitQueues(
    PWCHAR      Str,
    PFRS_QUEUE  Queues,
    PFRS_QUEUE  Control,
    BOOL        Controlled
    )
/*++
Routine Description:
    Initialize queues

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestInitQueues:"
    DWORD   Err;
    INT     i;

    //
    // Create queues
    //
    FrsInitializeQueue(Control, Control);
    for (i = 0; i < NUMQUEUES; ++i, ++Queues) {
        if (Controlled)
            FrsInitializeQueue(Queues, Control);
        else
            FrsInitializeQueue(Queues, Queues);
    }
}


VOID
TestPopQueues(
    PFRS_QUEUE  Queues,
    PLIST_ENTRY Entries,
    BOOL        Tailwise
    )
/*++
Routine Description:
    Populate a queue

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestPopQueues:"
    INT         EntryIdx, i, j;
    PLIST_ENTRY Entry;
    PFRS_QUEUE  Queue;
    PFRS_QUEUE  IdledQueue;

    //
    // Idle the last queue
    //
    Queue = Queues + (NUMQUEUES - 1);

    if (Tailwise)
        FrsRtlInsertTailQueue(Queue, Entries);
    else
        FrsRtlInsertHeadQueue(Queue, Entries);

    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Queue, 0, &IdledQueue);

    FRS_ASSERT(Entry == Entries);

    if (Tailwise)
        FrsRtlInsertTailQueue(Queue, Entries);
    else
        FrsRtlInsertHeadQueue(Queue, Entries);
    //
    // Make sure we can extract an entry from an idled queue
    //
    FrsRtlAcquireQueueLock(Queue);
    FrsRtlRemoveEntryQueueLock(Queue, Entry);
    FrsRtlReleaseQueueLock(Queue);

    FRS_ASSERT(Queue->Count == 0);
    FRS_ASSERT(Queue->Control->ControlCount == 0);

    //
    // Populate the queues
    //
    EntryIdx = 0;
    for (i = 0; i < NUMQUEUES; ++i)
        for (j = 0; j < NUMPKTS; ++j, ++EntryIdx) {
            if (Tailwise)
                FrsRtlInsertTailQueue(Queues + i, Entries + EntryIdx);
            else
                FrsRtlInsertHeadQueue(Queues + i, Entries + EntryIdx);
        }

    //
    // Unidle the last queue
    //
    FrsRtlUnIdledQueue(Queue);
}


BOOL
TestCheckQueues(
    PWCHAR      Str,
    PFRS_QUEUE  Queues,
    PFRS_QUEUE  Control,
    PLIST_ENTRY Entries,
    BOOL        Tailwise,
    BOOL        Controlled,
    BOOL        DoRundown,
    BOOL        PullControl,
    PFRS_QUEUE  *IdledQueue
    )
/*++
Routine Description:
    test populating a queue

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestCheckQueues:"
    LIST_ENTRY  Rundown;
    PLIST_ENTRY Entry;
    INT         EntryIdx, i, j;
    BOOL        Ret = TRUE;

    //
    // Create queues
    //
    TestInitQueues(Str, Queues, Control, Controlled);

    //
    // Populate the queues
    //
    TestPopQueues(Queues, Entries, Tailwise);

    //
    // Check the population
    //
    InitializeListHead(&Rundown);
    if (Controlled && !DoRundown) {
        for (j = 0; j < NUMPKTS; ++j) {
            for (i = 0; i < NUMQUEUES; ++i) {
                if (PullControl)
                    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Control, 0, IdledQueue);
                else
                    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Queues + i, 0, IdledQueue);
                if (Tailwise)
                    EntryIdx = (i * NUMPKTS) + j;
                else
                    EntryIdx = (i * NUMPKTS) + ((NUMPKTS - 1) - j);

                //
                // WRONG ENTRY
                //
                if (Entry != Entries + EntryIdx) {
                        DPRINT4(0, "ERROR -- %ws -- entry is %x; not %x (Queue %d)\n",
                            Str, Entry, Entries + EntryIdx, i);
                        Ret = FALSE;
                }

            }
            if (IdledQueue) {
                //
                // Make sure the queues are "empty"
                //
                if (!TestEmptyQueues(Str, Queues, Control, WAIT_TIMEOUT))
                    Ret = FALSE;
                //
                // Unidle the queues
                //
                for (i = 0; i < NUMQUEUES; ++i)
                    FrsRtlUnIdledQueue(Queues + i);
            }
        }
    } else for (i = 0; i < NUMQUEUES; ++i) {
        //
        // For rundown, we simply fetch the whole queue at one shot
        //
        if (DoRundown)
            FrsRtlRunDownQueue(Queues + i, &Rundown);

        for (j = 0; j < NUMPKTS; ++j) {
            //
            // For rundown, the entry comes from the list we populated
            // above. Otherwise, pull the entry from the queue
            //
            if (DoRundown) {
                Entry = RemoveHeadList(&Rundown);
            } else
                //
                // Pulling from the control queue should get the same
                // results as pulling from any of the controlled queues
                //
                if (PullControl)
                    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Control, 0, IdledQueue);
                else
                    Entry = FrsRtlRemoveHeadQueueTimeoutIdled(Queues + i, 0, IdledQueue);
            //
            // Entries come out of the queue differently depending on
            // how they were inserted (tailwise or headwise)
            //
            if (Tailwise)
                EntryIdx = (i * NUMPKTS) + j;
            else
                EntryIdx = (i * NUMPKTS) + ((NUMPKTS - 1) - j);

            //
            // WRONG ENTRY
            //
            if (Entry != Entries + EntryIdx) {
                    DPRINT4(0, "ERROR -- %ws -- entry is %x; not %x (Queue %d)\n",
                        Str, Entry, Entries + EntryIdx, i);
                    Ret = FALSE;
            }

            //
            // Unidle the queue
            //
            if (IdledQueue && *IdledQueue && !DoRundown)
                FrsRtlUnIdledQueue(*IdledQueue);
        }
    }
    //
    // Make sure the rundown list is empty
    //
    if (!IsListEmpty(&Rundown)) {
        DPRINT1(0, "ERROR -- %ws -- Rundown is not empty\n", Str);
        Ret = FALSE;
    }
    //
    // Make sure the queues are empty
    //
    if (!TestEmptyQueues(Str, Queues, Control,
                         (DoRundown) ? ERROR_INVALID_HANDLE : WAIT_TIMEOUT))
        Ret = FALSE;

    return Ret;
}


#define NUMCOMMANDS (16)
#define NUMSERVERS  (16)
COMMAND_SERVER  Css[NUMSERVERS];

BOOL    TestCommandsRet = TRUE;
DWORD   TestCommandsAborted = 0;

VOID
TestCommandsCheckCmd(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Check the consistency of the command packet

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB "TestCommandsCheckCmd:"
    DWORD           CsIdx;
    PFRS_QUEUE      Control;
    PCOMMAND_SERVER CmdCs;

    //
    // Check the command
    //
    if (Cmd->Command != CMD_INIT_SUBSYSTEM) {
        DPRINT2(0, "ERROR -- Command is %d; not %d\n",
               Cmd->Command, CMD_INIT_SUBSYSTEM);
        TestCommandsRet = FALSE;
    }
    Control = Cmd->TargetQueue->Control;
    CmdCs = CONTAINING_RECORD(Control, COMMAND_SERVER, Control);
    if (Cs && CmdCs != Cs) {
        DPRINT2(0, "ERROR -- Command Cs is %x; not %x\n", CmdCs, Cs);
        TestCommandsRet = FALSE;
    }
    //
    // Check the completion argument
    //
    if (CmdCs != Cmd->CompletionArg) {
        DPRINT2(0, "ERROR -- Completion Cs is %x; not %x\n",
                Cmd->CompletionArg, CmdCs);
        TestCommandsRet = FALSE;
    }
    //
    // Check our argument
    //
    CsIdx = TestIndex(Cmd);
    if (CmdCs != &Css[CsIdx]) {
        DPRINT2(0, "ERROR -- Server index is %d; not %d\n",
               CsIdx, (CmdCs - &Css[0]) / sizeof(COMMAND_SERVER));
        TestCommandsRet = FALSE;
    }
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)           // Not all control paths return (due to infinite loop)
#endif
DWORD
TestCommandsMain(
    IN PVOID    Arg
    )
/*++
Routine Description:
    Test command server subsystem completion routine. Move the command
    on to the next command server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB "TestCommandsMain:"
    PFRS_THREAD     FrsThread = Arg;
    PCOMMAND_PACKET Cmd;
    PCOMMAND_SERVER Cs;
    DWORD           CsIdx;
    DWORD           Status;

    Cs = FrsThread->Data;
cant_exit_yet:
    while (Cmd = FrsGetCommandServer(Cs)) {
        TestCommandsCheckCmd(Cs, Cmd);
        //
        // Make sure the command server is not idle
        //
        Status = FrsWaitForCommandServer(Cs, 0);
        if (Status != WAIT_TIMEOUT) {
            DPRINT(0, "ERROR -- command server is idle\n");
            TestCommandsRet = FALSE;
        }
        //
        // Propagate to next command server
        //
        CsIdx = TestIndex(Cmd) + 1;
        if (CsIdx >= NUMSERVERS) {
            DPRINT(0, "ERROR -- Last server index\n");
            TestCommandsRet = FALSE;
        } else {
            TestIndex(Cmd) = CsIdx;
            Cmd->TargetQueue = &Css[CsIdx].Queue;
            Cmd->CompletionArg = &Css[CsIdx];
            FrsSubmitCommandServer(&Css[CsIdx], Cmd);
        }
    }
    FrsExitCommandServer(Cs, FrsThread);
    goto cant_exit_yet;
    return ERROR_SUCCESS;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


VOID
TestCommandsCompletion(
    IN PCOMMAND_PACKET  Cmd,
    IN PVOID            Arg
    )
/*++
Routine Description:
    Test command server subsystem completion routine. Move the command
    on to the next command server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB "TestCommandsCompletion:"
    if (Cmd->ErrorStatus == ERROR_ACCESS_DENIED) {
        ++TestCommandsAborted;
        if (!WIN_SUCCESS(Cmd->ErrorStatus)) {
            DPRINT2(0, "ERROR -- ErrorStatus is %d; not %d\n",
                   Cmd->ErrorStatus, ERROR_SUCCESS);
        }
    }
    TestCommandsCheckCmd(NULL, Cmd);
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}

BOOL
TestCommands(
    VOID
    )
/*++
Routine Description:
    Test command server subsystem

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestCommands:"
    DWORD           i;
    DWORD           Status;
    PCOMMAND_PACKET Cmd;
    PCOMMAND_PACKET Cmds[NUMCOMMANDS];

    FRS_ASSERT(NUMSERVERS > 1);
    FRS_ASSERT(NUMCOMMANDS > 1);

    //
    // Initialize the servers. The last server disables automatic
    // thread management so that this thread can manage the last
    // command queue itself.
    //
    for (i = 0; i < NUMSERVERS - 1; ++i)
        FrsInitializeCommandServer(&Css[i], 4, L"TestCs", TestCommandsMain);
    FrsInitializeCommandServer(&Css[i], 0, L"TestCs", NULL);

    //
    // Submit commands to the first server. These commands will
    // propagate thru the command servers until they end up on the
    // last command queue where we will extract them.
    //
    for (i = 0; i < NUMCOMMANDS; ++i) {
        Cmds[i] = FrsAllocCommand(&Css[0].Queue, CMD_INIT_SUBSYSTEM);
        FrsSetCompletionRoutine(Cmds[i], TestCommandsCompletion, &Css[0]);
        FrsSubmitCommandServer(&Css[0], Cmds[i]);
    }

    //
    // Extract all but the last command from the last queue. We
    // will allow the abort code to clean up the last command.
    //
    for (i = 0; i < NUMCOMMANDS - 1; ++i) {
        Cmd = FrsGetCommandServer(&Css[NUMSERVERS - 1]);
        if (Cmd != Cmds[i]) {
            DPRINT2(0, "ERROR -- Cmd is %x; not %x\n", Cmd, Cmds[i]);
            TestCommandsRet = FALSE;
        }
        //
        // Probably timed out
        //
        if (Cmd == NULL) {
            DPRINT(0, "ERROR -- Cmd is NULL; probably timed out\n");
            TestCommandsRet = FALSE;
            break;
        }
        TestCommandsCheckCmd(NULL, Cmd);
        FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }

    //
    // All but the last command server should be idle
    //
    for (i = 0; i < NUMSERVERS - 1; ++i) {
        Status = FrsWaitForCommandServer(&Css[i], 0);
        if (Status != WAIT_OBJECT_0) {
            DPRINT(0, "ERROR -- command server is not idle\n");
            TestCommandsRet = FALSE;
        }
    }
    //
    // Last command server should always be idle
    //
    Status = FrsWaitForCommandServer(&Css[NUMSERVERS - 1], 0);
    if (Status != WAIT_OBJECT_0) {
        DPRINT(0, "ERROR -- last command server is not idle (w/command)\n");
        TestCommandsRet = FALSE;
    }

    //
    // Abort the command servers
    //
    for (i = 0; i < NUMSERVERS; ++i)
        FrsRunDownCommandServer(&Css[i], &Css[i].Queue);

    //
    // Wait for the threads to exit
    //
    ThSupExitThreadGroup(TestCommandsMain);

    //
    // We should have aborted one command
    //
    if (TestCommandsAborted != 1) {
        DPRINT1(0, "ERROR -- Aborted is %d; not 1\n", TestCommandsAborted);
        TestCommandsRet = FALSE;
    }

    //
    // Last command server should be idle
    //
    Status = FrsWaitForCommandServer(&Css[NUMSERVERS - 1], 0);
    if (Status != WAIT_OBJECT_0) {
        DPRINT(0, "ERROR -- last command server is not idle\n");
        TestCommandsRet = FALSE;
    }

    return TestCommandsRet;
}


BOOL
TestQueues(
    VOID
    )
/*++
Routine Description:
    Test queue subsystem

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestQueues:"
    BOOL            Ret = TRUE;
    LONG            Err;
    INT             i, j;
    INT             EntryIdx;
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET ECmdPkt;
    FRS_QUEUE       Control;
    PFRS_QUEUE      IdledQueue;
    FRS_QUEUE       Queues[NUMQUEUES];
    PCOMMAND_PACKET CmdPkt[NUMPKTS];
    LIST_ENTRY      Entries[NUMPKTS * NUMQUEUES];

    FRS_ASSERT(NUMQUEUES > 1);

    DPRINT(0, "scheduled queue is not implemented!!!\n");
    Ret = FALSE;

    //
    // +++++ NORMAL QUEUES
    //

    if (!TestCheckQueues(L"Tailwise", &Queues[0], &Control, &Entries[0],
                         TRUE, FALSE, FALSE, FALSE, NULL)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Tailwise Rundown", &Queues[0], &Control, &Entries[0],
                           TRUE, FALSE, TRUE, FALSE, NULL)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Headwise", &Queues[0], &Control, &Entries[0],
                         FALSE, FALSE, FALSE, FALSE, NULL)) {
        Ret = FALSE;
    }
    if (!TestCheckQueues(L"Headwise Rundown", &Queues[0], &Control, &Entries[0],
                           FALSE, FALSE, TRUE, FALSE, NULL)) {
        Ret = FALSE;
    }

    //
    // +++++ CONTROLLED QUEUES
    //

    if (!TestCheckQueues(L"Tailwise Controlled", &Queues[0], &Control, &Entries[0],
                         TRUE, TRUE, FALSE, FALSE, NULL)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Tailwise Rundown Controlled", &Queues[0], &Control, &Entries[0],
                           TRUE, TRUE, TRUE, FALSE, NULL)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Headwise Controlled", &Queues[0], &Control, &Entries[0],
                         FALSE, TRUE, FALSE, FALSE, NULL)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Headwise Rundown Controlled", &Queues[0], &Control, &Entries[0],
                           FALSE, TRUE, TRUE, FALSE, NULL)) {
        Ret = FALSE;
    }

    //
    // PULL THE ENTRIES OFF THE CONTROLING QUEUE
    //
    if (!TestCheckQueues(L"Tailwise Controlled Pull", &Queues[0], &Control, &Entries[0],
                         TRUE, TRUE, FALSE, TRUE, NULL)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Headwise Controlled Pull", &Queues[0], &Control, &Entries[0],
                         FALSE, TRUE, FALSE, TRUE, NULL)) {
        Ret = FALSE;
    }

    //
    // +++++ NORMAL QUEUES W/IDLED
    //

    if (!TestCheckQueues(L"Tailwise Idled", &Queues[0], &Control, &Entries[0],
                         TRUE, FALSE, FALSE, FALSE, &IdledQueue)) {
        Ret = FALSE;
    }

    //
    // +++++ CONTROLLED QUEUES W/IDLED
    //
    if (!TestCheckQueues(L"Tailwise Controlled Idled", &Queues[0], &Control, &Entries[0],
                         TRUE, TRUE, FALSE, FALSE, &IdledQueue)) {
        Ret = FALSE;
    }

    if (!TestCheckQueues(L"Tailwise Rundown Controlled Idled", &Queues[0], &Control, &Entries[0],
                           TRUE, TRUE, TRUE, FALSE, &IdledQueue)) {
        Ret = FALSE;
    }

    //
    // PULL THE ENTRIES OFF THE CONTROLING QUEUE
    //
    if (!TestCheckQueues(L"Tailwise Controlled Pull Idled", &Queues[0], &Control, &Entries[0],
                         TRUE, TRUE, FALSE, TRUE, &IdledQueue)) {
        Ret = FALSE;
    }

    //
    // COMMAND QUEUES
    //

    //
    // Check the command subsystem; assumes that queues[0 and 1] are
    // initialized and empty
    //
    //
    // Create queues
    //
    TestInitQueues(L"Start command", &Queues[0], &Control, FALSE);

    //
    // Put an entry on the queue in a bit
    //
    for (i = 0; i < NUMPKTS; ++i) {
        CmdPkt[i] = FrsAllocCommand(&Queues[0], CMD_INIT_SUBSYSTEM);
        FrsSetCompletionRoutine(CmdPkt[i], CompletionRoutine, &Queues[1]);
        FrsSubmitCommand(CmdPkt[i], FALSE);
    }
    //
    // Remove them from the first queue
    //
    for (i = 0; i < NUMPKTS; ++i) {
        Entry = FrsRtlRemoveHeadQueueTimeout(&Queues[0], 0);
        if (Entry == NULL) {
            DPRINT(0, "ERROR -- Entry is not on command queue\n");
            Ret = FALSE;
            continue;
        }
        ECmdPkt = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if (CmdPkt[i] != ECmdPkt) {
            DPRINT2(0, "ERROR -- Cmd is %x; not %x\n", ECmdPkt, CmdPkt[i]);
            Ret = FALSE;
        }
        if (CmdPkt[i]->ErrorStatus != 0) {
            DPRINT1(0, "ERROR -- ErrorStatus is %d, not 0\n", CmdPkt[i]->ErrorStatus);
            Ret = FALSE;
        }

        //
        // Move CmdPkt to next queue (calling CompletionRoutine() first)
        //
        DesiredStatus = -5;
        FrsCompleteCommand(CmdPkt[i], -5);
        if (Ret)
            Ret = CompletionRet;
    }

    //
    // Remove entry from second queue
    //
    for (i = 0; i < NUMPKTS; ++i) {
        Entry = FrsRtlRemoveHeadQueueTimeout(&Queues[1], 0);
        if (Entry == NULL) {
            DPRINT(0, "ERROR -- Entry is not on command queue 2\n");
            Ret = FALSE;
            continue;
        }
        ECmdPkt = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if (CmdPkt[i] != ECmdPkt) {
            DPRINT2(0, "ERROR -- Cmd 2 is %x; not %x\n", ECmdPkt, CmdPkt[i]);
            Ret = FALSE;
        }
        if (CmdPkt[i]->ErrorStatus != -5) {
            DPRINT1(0, "ERROR -- ErrorStatus 2 is %d, not -5\n", CmdPkt[i]->ErrorStatus);
            Ret = FALSE;
        }
        FrsSetCompletionRoutine(CmdPkt[i], FrsFreeCommand, NULL);
        FrsCompleteCommand(CmdPkt[i], ERROR_SUCCESS);
    }

    //
    // Delete the queues
    //
    for (i = 0; i < NUMQUEUES; ++i)
        FrsRtlDeleteQueue(&Queues[i]);
    FrsRtlDeleteQueue(&Control);
    return Ret;
}


BOOL
TestExceptions(
    VOID
    )
/*++
Routine Description:
    Test exception handler.

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestExceptions:"
    DWORD       i;
    ULONG_PTR   Err;
    BOOL        Ret = TRUE;
    PWCHAR      Msg = TEXT("Testing Exceptions");

    //
    // Test the exceptions
    //
    FrsExceptionQuiet(TRUE);
    for (i = 0; i < FRS_MAX_ERROR_CODE; ++i) {
        try {
            Err = i;
            if (i == FRS_ERROR_LISTEN) {
                Err = (ULONG_PTR)Msg;
            }
            FrsRaiseException(i, Err);
        } except (FrsException(GetExceptionInformation())) {
            if (i != FrsExceptionLastCode() || Err != FrsExceptionLastInfo()) {
                DPRINT1(0, "\t\tException %d is not working\n", i);
                Ret = FALSE;
            }
        }
    }
    FrsExceptionQuiet(FALSE);
    return Ret;
}


//
// Test concurrency and threads subsystem
//
#define NUMBER_OF_HANDLES       (16)
handle_t FrsRpcHandle[NUMBER_OF_HANDLES];
static NTSTATUS
FrsRpcThread(
    PVOID Arg
    )
/*++
Routine Description:
    Bind to the server, call the FRS NOP RPC function, and unbind.

Arguments:
    Arg     - Address of this thread's context

Return Value:
    ERROR_OPERATION_ABORTED or the status returned by the RPC call.
--*/
{
#undef  DEBSUB
#define DEBSUB "FrsRpcThread:"
    NTSTATUS    Status;
    handle_t    *Handle;
    PGNAME      Name;

    Status = ERROR_OPERATION_ABORTED;
    try {
        try {
            Handle = (handle_t *)ThSupGetThreadData((PFRS_THREAD)Arg);
            Name = FrsBuildGName(FrsDupGuid(ServerGuid), FrsWcsDup(ComputerName));
            FrsRpcBindToServer(Name, NULL, CXTION_AUTH_NONE, Handle);
            FrsFreeGName(Name);
            Status = FrsNOP(*Handle);
            FrsRpcUnBindFromServer(Handle);
        } except (FrsException(GetExceptionInformation())) {
            Status = FrsExceptionLastCode();
        }
    } finally {
    }
    return Status;
}


BOOL
TestRpc(
    VOID
    )
/*++
Routine Description:
    Test RPC

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestRpc:"
    DWORD       i;
    DWORD       Err;
    PFRS_THREAD FrsThread;
    BOOL        Ret = TRUE;
    handle_t    Handle;
    PGNAME      Name;

    //
    // Testing RPC
    //

    //
    // Wait for the comm subsystem to be initialized
    //
    WaitForSingleObject(CommEvent, INFINITE);

    //
    // Test RPC concurrency
    //
    for (i = 0; i < NUMBER_OF_HANDLES; ++i) {
        if (!ThSupCreateThread(L"TestThread", (PVOID)&FrsRpcHandle[i], FrsRpcThread, NULL)) {
            DPRINT1(0, "\t\tCould not create RPC thread %d\n", i);
            Ret = FALSE;
        }
    }
    for (i = 0; i < NUMBER_OF_HANDLES; ++i) {
        FrsThread = ThSupGetThread(FrsRpcThread);
        if (FrsThread) {
            Err = ThSupWaitThread(FrsThread, INFINITE);
            if (!WIN_SUCCESS(Err)) {
                DPRINT1(0, "\t\tRPC thread returned %d\n", Err);
                Ret = FALSE;
            }
            ThSupReleaseRef(FrsThread);
        } else {
            DPRINT1(0, "\t\tCould not find RPC thread %d\n", i);
            Ret = FALSE;
        }
    }
    //
    // quick check of the threads subsystem
    //
    for (i = 0; i < NUMBER_OF_HANDLES; ++i) {
        FrsThread = ThSupGetThread(FrsRpcThread);
        if (FrsThread) {
            DPRINT1(0, "\t\tRPC thread %d still exists!\n", i);
            Ret = FALSE;
            ThSupReleaseRef(FrsThread);
        }
    }
    Name = FrsBuildGName(FrsDupGuid(ServerGuid), FrsWcsDup(ComputerName));
    FrsRpcBindToServer(Name, NULL, CXTION_AUTH_NONE, &Handle);
    FrsFreeGName(Name);
    Err = FrsEnumerateReplicaPathnames(Handle);
    if (Err != ERROR_CALL_NOT_IMPLEMENTED) {
        DPRINT1(0, "\t\tFrsEnumerateReplicaPathnames returned %d\n", Err);
        Ret = FALSE;
    }

    Err = FrsFreeReplicaPathnames(Handle);
    if (Err != ERROR_CALL_NOT_IMPLEMENTED) {
        DPRINT1(0, "\t\tFrsFreeReplicaPathnames returned %d\n", Err);
        Ret = FALSE;
    }

    Err = FrsPrepareForBackup(Handle);
    if (Err != ERROR_CALL_NOT_IMPLEMENTED) {
        DPRINT1(0, "\t\tFrsPrepareForBackup returned %d\n", Err);
        Ret = FALSE;
    }

    Err = FrsBackupComplete(Handle);
    if (Err != ERROR_CALL_NOT_IMPLEMENTED) {
        DPRINT1(0, "\t\tFrsBackupComplete returned %d\n", Err);
        Ret = FALSE;
    }

    Err = FrsPrepareForRestore(Handle);
    if (Err != ERROR_CALL_NOT_IMPLEMENTED) {
        DPRINT1(0, "\t\tFrsPrepareForRestore returned %d\n", Err);
        Ret = FALSE;
    }

    Err = FrsRestoreComplete(Handle);
    if (Err != ERROR_CALL_NOT_IMPLEMENTED) {
        DPRINT1(0, "\t\tFrsRestoreComplete returned %d\n", Err);
        Ret = FALSE;
    }
    FrsRpcUnBindFromServer(&Handle);

    return Ret;
}


#define TEST_OPLOCK_FILE    L"C:\\TEMP\\OPLOCK.TMP"

ULONG
TestOpLockThread(
    PVOID Arg
    )
/*++
Routine Description:
    Test oplock support

Arguments:
    Arg.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestOpLockThread:"
    PFRS_THREAD Thread  = Arg;
    PVOID       DoWrite = Thread->Data;
    HANDLE      Handle  = INVALID_HANDLE_VALUE;

    //
    // Trigger the oplock filter
    //
    FrsOpenSourceFileW(&Handle,
                      TEST_OPLOCK_FILE,
                      (DoWrite) ? GENERIC_WRITE | SYNCHRONIZE :
                                  GENERIC_READ  | GENERIC_EXECUTE | SYNCHRONIZE,
                      OPEN_OPTIONS);
    if (!HANDLE_IS_VALID(Handle)) {
        return ERROR_FILE_NOT_FOUND;
    }
    CloseHandle(Handle);
    return ERROR_SUCCESS;
}


BOOL
TestOpLocks(
    VOID
    )
/*++
Routine Description:
    Test oplock support

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestOpLocks:"

    OVERLAPPED  OverLap;
    DWORD       BytesReturned;
    HANDLE      Handle;
    PFRS_THREAD Thread;
    DWORD       Status;


    //
    // Initialize for later cleanup
    //
    Handle = INVALID_HANDLE_VALUE;
    Thread = NULL;
    OverLap.hEvent = INVALID_HANDLE_VALUE;

    //
    // Create the temp file
    //
    Status = StuCreateFile(TEST_OPLOCK_FILE, &Handle);
    if (!HANDLE_IS_VALID(Handle) || !WIN_SUCCESS(Status)) {
        DPRINT1(0, "Can't create %ws\n", TEST_OPLOCK_FILE);
        goto errout;
    }
    if (!CloseHandle(Handle))
        goto errout;

    //
    // Create the asynchronous oplock event
    //
    OverLap.Internal = 0;
    OverLap.InternalHigh = 0;
    OverLap.Offset = 0;
    OverLap.OffsetHigh = 0;
    OverLap.hEvent = FrsCreateEvent(TRUE, FALSE);

    //
    // Reserve an oplock filter
    //
    FrsOpenSourceFileW(&Handle, TEST_OPLOCK_FILE, OPLOCK_ACCESS, OPEN_OPLOCK_OPTIONS);
    if (!HANDLE_IS_VALID(Handle)) {
        DPRINT1(0, "Can't open %ws\n", TEST_OPLOCK_FILE);
        goto errout;
    }

    //
    // Pull the hammer back on the oplock trigger
    //
    if (!DeviceIoControl(Handle,
                         FSCTL_REQUEST_FILTER_OPLOCK,
                         NULL,
                         0,
                         NULL,
                         0,
                         &BytesReturned,
                         &OverLap)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            DPRINT1(0, "Could not cock the oplock; error %d\n", GetLastError());
            goto errout;
        }
    } else
        goto errout;

    //
    // READONLY OPEN BY ANOTHER THREAD
    //
    if (!ThSupCreateThread(L"TestOpLockThread", NULL, TestOpLockThread, NULL)) {
        DPRINT(0, "Can't create thread TestOpLockThread for read\n");
        goto errout;
    }

    if (WaitForSingleObject(OverLap.hEvent, (3 * 1000)) != WAIT_TIMEOUT) {
        DPRINT(0, "***** ERROR -- OPLOCK TRIGGERED ON RO OPEN\n");
        goto errout;
    }
    Thread = ThSupGetThread(TestOpLockThread);
    if (Thread == NULL) {
        DPRINT(0, "Can't find thread TestOpLockThread for read\n");
        goto errout;
    }
    Status = ThSupWaitThread(Thread, 10 * 1000);
    ThSupReleaseRef(Thread);
    Thread = NULL;
    CLEANUP_WS(0, "Read thread terminated with status", Status, errout);

    //
    // WRITE OPEN BY ANOTHER THREAD
    //
    if (!ThSupCreateThread(L"TestOpLockThread", (PVOID)OverLap.hEvent, TestOpLockThread, NULL)) {
        DPRINT(0, "Can't create thread TestOpLockThread for write\n");
        goto errout;
    }

    if (WaitForSingleObject(OverLap.hEvent, (3 * 1000)) != WAIT_OBJECT_0) {
        DPRINT(0, "***** ERROR -- OPLOCK DID NOT TRIGGER ON WRITE OPEN\n");
        goto errout;
    }
    //
    // Release the oplock
    //
    if (!CloseHandle(Handle))
        goto errout;
    Thread = ThSupGetThread(TestOpLockThread);
    if (Thread == NULL) {
        DPRINT(0, "Can't find thread TestOpLockThread for write\n");
        goto errout;
    }
    Status = ThSupWaitThread(Thread, 10 * 1000);
    ThSupReleaseRef(Thread);
    Thread = NULL;
    CLEANUP_WS(0, "Write thread terminated with status", Status, errout);

    FRS_CLOSE(OverLap.hEvent);

    return TRUE;

errout:
    FRS_CLOSE(Handle);
    FRS_CLOSE(OverLap.hEvent);

    if (Thread) {
        ThSupExitSingleThread(Thread);
        ThSupReleaseRef(Thread);
    }
    return FALSE;
}


PWCHAR   NestedDirs[] = {
    L"c:\\a\\b",            L"c:\\a\\b\\c",
    L"c:\\a\\b\\",          L"c:\\a\\b\\c",
    L"c:\\a\\b\\c",         L"c:\\a\\b\\c",
    L"c:\\\\a\\b\\c\\\\",   L"c:\\a\\\\b\\c",
    L"c:\\\\a\\b\\c",       L"c:\\a\\\\b\\c\\\\\\",
    L"\\c:\\\\a\\b\\c",     L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\\\a\\b\\c", L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\\\a\\b\\",  L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\\\a\\b",    L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\\\a\\",     L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\\\a",       L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\\\",        L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\",          L"\\c:\\a\\\\b\\c\\\\\\",
    L"\\\\\\c:\\",          L"\\c:\\a\\\\b\\c",
    NULL, NULL
    };
PWCHAR   NotNestedDirs[] = {
    L"c:\\a\\b\\c",         L"e:\\a\\b\\c",
    L"c:\\a\\b\\c",         L"c:\\a\\b\\cdef",
    L"c:\\\\a\\b\\c\\",     L"c:\\a\\b\\cdef",
    L"c:\\\\a\\b\\c\\\\",   L"c:\\a\\b\\cdef\\",
    L"c:\\\\a\\b\\cdef\\\\",L"c:\\a\\b\\c",
    NULL, NULL
    };
PWCHAR   DirsNested[] = {
    L"c:\\a\\b\\c\\d", L"c:\\a\\b\\c",
    L"c:\\a\\b\\c\\d", L"c:\\a\\b",
    L"c:\\a\\b\\c\\d", L"c:\\a",
    L"c:\\a\\b\\c\\d", L"c:\\",
    NULL, NULL
    };
BOOL
TestNestedDirs(
    VOID
    )
/*++
Routine Description:
    Test nested dirs

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestNestedDirs:"
    DWORD   i;
    LONG    Ret;
    BOOL    Passed = TRUE;
    BOOL    FinalPassed = TRUE;

    //
    // Nested dirs
    //
    for (i = 0, Ret = TRUE; NestedDirs[i]; i += 2) {
        Ret = FrsIsParent(NestedDirs[i], NestedDirs[i + 1]);
        if (Ret != -1) {
            DPRINT3(0, "ERROR - nested dirs %ws %d %ws\n",
                    NestedDirs[i], Ret, NestedDirs[i + 1]);
            Passed = FALSE;
        }
    }
    if (Passed) {
        DPRINT(0, "\t\tPassed nested dirs\n");
    } else {
        FinalPassed = Passed;
    }
    Passed = TRUE;

    //
    // Nested dirs
    //
    for (i = 0; NotNestedDirs[i]; i += 2) {
        Ret = FrsIsParent(NotNestedDirs[i], NotNestedDirs[i + 1]);
        if (Ret != 0) {
            DPRINT3(0, "ERROR - not nested dirs %ws %d %ws\n",
                    NotNestedDirs[i], Ret, NotNestedDirs[i + 1]);
            Passed = FALSE;
        }
    }
    if (Passed) {
        DPRINT(0, "\t\tPassed not nested dirs\n");
    } else {
        FinalPassed = Passed;
    }
    Passed = TRUE;

    //
    // Dirs Nested
    //
    for (i = 0; DirsNested[i]; i += 2) {
        Ret = FrsIsParent(DirsNested[i], DirsNested[i + 1]);
        if (Ret != 1) {
            DPRINT3(0, "ERROR - dirs nested %ws %d %ws\n",
                    DirsNested[i], Ret, DirsNested[i + 1]);
            Passed = FALSE;
        }
    }
    if (Passed) {
        DPRINT(0, "\t\tPassed dirs nested\n");
    } else {
        FinalPassed = Passed;
    }
    return FinalPassed;
}


LONGLONG    WaitableNow;
DWORD       WaitableProcessed;
#define WAITABLE_TIMER_CMDS          (8)                 // must be even
#define WAITABLE_TIMER_TIMEOUT       (3 * 1000)          // 3 seconds
#define WAITABLE_TIMER_TIMEOUT_PLUS  ((3 * 1000) + 500)  // 3.5 seconds
PCOMMAND_PACKET WTCmds[WAITABLE_TIMER_CMDS];
BOOL
TestWaitableTimerCompletion(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Ignore
    )
/*++
Routine Description:
    Test waitable timer

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestWaitableTimerCompletion:"
    DWORD       i;
    LONGLONG    Now;
    LONGLONG    Min;
    LONGLONG    Max;

    FrsNowAsFileTime(&Now);

    if (Cmd->Command == CMD_START_SUBSYSTEM) {
        Min = WaitableNow + ((WAITABLE_TIMER_TIMEOUT - 1) * 1000 * 10);
        Max = WaitableNow + ((WAITABLE_TIMER_TIMEOUT + 1) * 1000 * 10);
    } else {
        Min = WaitableNow + (((WAITABLE_TIMER_TIMEOUT - 1) * 1000 * 10) << 1);
        Max = WaitableNow + (((WAITABLE_TIMER_TIMEOUT + 1) * 1000 * 10) << 1);
    }
    if (Now < Min || Now > Max) {
        DPRINT1(0, "\t\tERROR - timer misfired in %d seconds\n",
                 (Now > Cmd->WaitFileTime) ?
                     (DWORD)((Now - Cmd->WaitFileTime) / (10 * 1000 * 1000)) :
                     (DWORD)((Cmd->WaitFileTime - Now) / (10 * 1000 * 1000)));
        FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
        FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
        return ERROR_SUCCESS;
    }
    DPRINT1(0, "\t\tSUCCESS hit at %d seconds\n",
           (WaitableNow > Cmd->WaitFileTime) ?
               (DWORD)((WaitableNow - Cmd->WaitFileTime) / (10 * 1000 * 1000)) :
               (DWORD)((Cmd->WaitFileTime - WaitableNow) / (10 * 1000 * 1000)));
    ++WaitableProcessed;
    if (Cmd->Command == CMD_STOP_SUBSYSTEM) {
        FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
        FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
        return ERROR_SUCCESS;
    }
    Cmd->Command = CMD_STOP_SUBSYSTEM;
    WaitSubmit(Cmd, WAITABLE_TIMER_TIMEOUT, CMD_DELAYED_COMPLETE);
    return ERROR_SUCCESS;
}


BOOL
TestWaitableTimer(
    VOID
    )
/*++
Routine Description:
    Test waitable timer

Arguments:
    None.

Return Value:
    TRUE    - test passed
    FALSE   - test failed; see listing
--*/
{
#undef  DEBSUB
#define DEBSUB "TestWaitableTimer:"
    DWORD   i;

    WaitableProcessed = 0;
    for (i = 0; i < WAITABLE_TIMER_CMDS; ++i) {
        WTCmds[i] = FrsAllocCommand(NULL, CMD_START_SUBSYSTEM);
        FrsSetCompletionRoutine(WTCmds[i], TestWaitableTimerCompletion, NULL);
    }
    FrsNowAsFileTime(&WaitableNow);
    for (i = 0; i < (WAITABLE_TIMER_CMDS >> 1); ++i) {
        WaitSubmit(WTCmds[i], WAITABLE_TIMER_TIMEOUT, CMD_DELAYED_COMPLETE);
    }
    for (i = (WAITABLE_TIMER_CMDS >> 1); i < WAITABLE_TIMER_CMDS; ++i) {
        WaitSubmit(WTCmds[i], WAITABLE_TIMER_TIMEOUT_PLUS, CMD_DELAYED_COMPLETE);
    }
    Sleep(WAITABLE_TIMER_TIMEOUT_PLUS  +
          WAITABLE_TIMER_TIMEOUT_PLUS  +
          WAITABLE_TIMER_TIMEOUT_PLUS);

    if (WaitableProcessed != (WAITABLE_TIMER_CMDS << 1)) {
        DPRINT2(0, "\t\tERROR - processed %d of %d waitable timer commands.\n",
                WaitableProcessed, WAITABLE_TIMER_CMDS << 1);
        return FALSE;
    }
    return TRUE;
}


BOOL
TestEventLog(
    VOID
    )
/*++
Routine Description:
    Generate all eventlog messages

Arguments:
    None.

Return Value:
    TRUE    - test passed
--*/
{
#undef  DEBSUB
#define DEBSUB "TestEventLog:"

    DWORD i;

    for (i = 0; i < 6; i++) {
        EPRINT0(EVENT_FRS_ERROR);
        Sleep(10000);
    }

    EPRINT0(EVENT_FRS_STARTING);

    EPRINT0(EVENT_FRS_STOPPING);

    EPRINT0(EVENT_FRS_STOPPED);

    EPRINT0(EVENT_FRS_STOPPED_FORCE);

    EPRINT0(EVENT_FRS_STOPPED_ASSERT);

    EPRINT3(EVENT_FRS_ASSERT, L"Module.c", L"456", L"test assertion");

    for (i = 0; i < 6; i++) {
        EPRINT4(EVENT_FRS_VOLUME_NOT_SUPPORTED, L"ReplicaSet", L"ThisComputer",
                L"d:a\\b\\c", L"a:\\");
        Sleep(10000);
    }

   EPRINT3(EVENT_FRS_LONG_JOIN, L"Source", L"Target", L"ThisComputer");

    EPRINT3(EVENT_FRS_LONG_JOIN_DONE, L"Source", L"Target", L"ThisComputer");

    EPRINT2(EVENT_FRS_CANNOT_COMMUNICATE, L"ThisComputer", L"OtherComputer");

    EPRINT2(EVENT_FRS_DATABASE_SPACE, L"ThisComputer", L"a:\\dir\\root");

    EPRINT2(EVENT_FRS_DISK_WRITE_CACHE_ENABLED, L"ThisComputer", L"a:\\dir\\root");

    EPRINT4(EVENT_FRS_JET_1414,
            L"ThisComputer",
            L"a:\\dir\\ntfrs\\jet\\ntfrs.jdb",
            L"a:\\dir\\ntfrs\\jet\\log",
            L"a:\\dir\\ntfrs\\jet\\sys");

    EPRINT1(EVENT_FRS_SYSVOL_NOT_READY, L"ThisComputer");

    EPRINT1(EVENT_FRS_SYSVOL_NOT_READY_PRIMARY, L"ThisComputer");

    EPRINT1(EVENT_FRS_SYSVOL_READY, L"ThisComputer");

    EPRINT1(EVENT_FRS_STAGING_AREA_FULL, L"100000");

    EPRINT2(EVENT_FRS_HUGE_FILE, L"10000", L"10000000");

    return TRUE;
}


BOOL
TestOneDnsToBios(
    IN PWCHAR   HostName,
    IN DWORD    HostLen,
    IN BOOL     ExpectError
    )
/*++
Routine Description:
    Test the conversion of one DNS computer name to a NetBIOS computer name.

Arguments:
    HostName    - DNS name
    ExpectError - conversion should fail

Return Value:
    TRUE    - test passed
--*/
{
#undef  DEBSUB
#define DEBSUB "TestOneDnsToBios:"
    BOOL    Ret = TRUE;
    DWORD   Len;
    WCHAR   NetBiosName[MAX_PATH + 1];

    //
    // Bios -> Bios
    //
    NetBiosName[0] = 0;
    Len = HostLen;
    Ret = DnsHostnameToComputerName(HostName, NetBiosName, &Len);
    if (Ret) {
        DPRINT5(0, "\t\t%sConverted %ws -> %ws (%d -> %d)\n",
                (ExpectError) ? "ERROR - " : "", HostName, NetBiosName, HostLen, Len);
        Ret = !ExpectError;
    } else {
        DPRINT4_WS(0, "\t\t%sCan't convert %ws (%d -> %d);",
                  (!ExpectError) ? "ERROR - " : "", HostName, HostLen, Len, GetLastError());
        Ret = ExpectError;
    }
    return Ret;
}


BOOL
TestDnsToBios(
    VOID
    )
/*++
Routine Description:
    Test the conversion of DNS computer names to NetBIOS computer names.

Arguments:
    None.

Return Value:
    TRUE    - test passed
--*/
{
#undef  DEBSUB
#define DEBSUB "TestDnsToBios:"
    BOOL    Ret = TRUE;
    DWORD   Len;
    WCHAR   NetBiosName[MAX_PATH + 1];

    //
    // Bios -> Bios
    //
    if (!TestOneDnsToBios(L"01234567", 9, FALSE)) {
        Ret = FALSE;
    }

    //
    // Bios -> Bios not enough space
    //
    if (!TestOneDnsToBios(L"01234567", 1, TRUE)) {
        Ret = FALSE;
    }

    //
    // Dns -> Bios
    //
    if (!TestOneDnsToBios(L"01234567.abc.dd.a.com", MAX_PATH, FALSE)) {
        Ret = FALSE;
    }
    if (!TestOneDnsToBios(L"01234567.abc.dd.a.com.", MAX_PATH, FALSE)) {
        Ret = FALSE;
    }
    if (!TestOneDnsToBios(L"01234567$.abc.d$@d.a.com.", MAX_PATH, FALSE)) {
        Ret = FALSE;
    }
    if (!TestOneDnsToBios(L"01234567$@abc.d$@d.a.com.", MAX_PATH, FALSE)) {
        Ret = FALSE;
    }
    return Ret;
}


DWORD
FrsTest(
    PVOID FrsThread
    )
/*++
Routine Description:
    Test:
        - queues
        - command servers
        - exception handling
        - test service interface
        - RPC
        - version vector
        - configuration handling
    Then die.

Arguments:
    None.

Return Value:
    ERROR_OPERATION_ABORTED
    ERROR_SUCCESS
--*/
{
#undef  DEBSUB
#define DEBSUB "FrsTest:"
//
// DISABLED
//
return ERROR_SUCCESS;

    DPRINT(0, "Testing in progress...\n");
    try {
        //
        // Test Dns to Bios
        //
        DPRINT(0, "\tTesting Dns to Bios...\n");
        if (TestDnsToBios()) {
            DPRINT(0, "\tPASS Testing Dns to Bios\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing Dns to Bios\n\n");
        }
        //
        // Test event log messages
        //
        DPRINT(0, "\tTesting event log messges...\n");
        if (TestEventLog()) {
            DPRINT(0, "\tPASS Testing event log messges\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing event log messges\n\n");
        }
        //
        // Test waitable timer
        //
        DPRINT(0, "\tTesting waitable timer...\n");
        if (TestWaitableTimer()) {
            DPRINT(0, "\tPASS Testing waitable timer \n\n");
        } else {
            DPRINT(0, "\tFAIL Testing waitable timer \n\n");
        }
        //
        // Test nested dirs
        //
        DPRINT(0, "\tTesting nested dirs...\n");
        if (TestNestedDirs()) {
            DPRINT(0, "\tPASS Testing nested dirs\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing nested dirs\n\n");
        }

        //
        // Test oplocks
        //
        DPRINT(0, "\tTesting oplocks...\n");
        if (TestOpLocks()) {
            DPRINT(0, "\tPASS Testing oplocks\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing oplocks\n\n");
        }
        //
        // Test queues
        //
        DPRINT(0, "\tTesting queues...\n");
        if (TestQueues()) {
            DPRINT(0, "\tPASS Testing queues\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing queues\n\n");
        }

        //
        // Test command servers
        //
        DPRINT(0, "\tTesting command servers...\n");
        if (TestCommands()) {
            DPRINT(0, "\tPASS Testing command servers\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing command servers\n\n");
        }

        //
        // Test the exceptions
        //
        DPRINT(0, "\tTesting exceptions...\n");
        if (TestExceptions()) {
            DPRINT(0, "\tPASS Testing exceptions\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing exceptions\n\n");
        }
        //
        // Testing RPC
        //
        DPRINT(0, "\tTesting RPC\n");
        if (TestRpc()) {
            DPRINT(0, "\tPASS Testing Rpc\n\n");
        } else {
            DPRINT(0, "\tFAIL Testing Rpc\n\n");
        }

    } finally {
        if (AbnormalTermination()) {
            DPRINT(0, "Test aborted\n");
        } else {
            DPRINT(0, "Test Done\n");
        }
        FrsIsShuttingDown = TRUE;
        SetEvent(ShutDownEvent);
    }

    return ERROR_SUCCESS;
}
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frssndcs.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frssndcs.c

Abstract:

    This command server sends packets over the comm layer.

 SndCsInitialize:        - Alloc handle table, read reg pars, Create/init SndCs,
                           Alloc comm queue array, attach comm queues to SndCs
                           control queue.
 SndCsUnInitialize:      - Free handle table, delete comm queues.
 SndCsShutDown:          - Run Down Comm queues, Run down SndCs.

 SndCsExit:              - Cancel all RPC calls on the FrsThread->Handle.

 SndCsAssignCommQueue:   - Assign a comm queue to cxtion.
 SndCsCreateCxtion:      - Create a join Guid for connection, assign comm queue
 SndCsDestroyCxtion:     - Invalidate cxtion join guid and umbind RPC handle
 SndCsUnBindHandles:     - Unbind all RPC handles associated with given target server

 SndCsCxtionTimeout:     - No activity on this connection, request an UNJOIN.
 SndCsCheckCxtion:       - Check that the join guid is still valid, set the timer if needed.
 SndCsDispatchCommError: - Transfer a comm packet to the appropriate command server
                           for error processing.

 SndCsCommTimeout:       - Cancel hung RPC send threads and age the RPC handle cache.

 SndCsSubmitCommPkt:     - Submit comm packet to the Send Cs comm queue for the
                           target Cxtion.
 SndCsSubmitCommPkt2:    - Ditto (with arg variation)
 SndCsSubmitCmd:         - Used for submitting a CMD_JOINING_AFTER_FLUSH to a Send Cs queue.

 SndCsMain:              - Send command server processing loop.  Dispatches requests
                           off the comm queues.

Author:
    Billy J. Fuller 28-May-1997

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>
#include <perrepsr.h>

//
// Struct for the Send Command Server
//      Contains info about the queues and the threads
//
COMMAND_SERVER  SndCs;

//
// Comm queues are attached to the SndCs command server above.
// A cxtion is assigned a comm queue when its creates or assigns a join guid
// (session).  The cxtion uses that comm queue for as long as the join guid is
// valid.  This insures packet order through the comm layer.
//
// Reserve comm queue 0 for join requests to partners whose previous rpc call
// took longer than MinJoinRetry to error off.
//
#define MAX_COMM_QUEUE_NUMBER (32)

FRS_QUEUE   CommQueues[MAX_COMM_QUEUE_NUMBER];

DWORD CommQueueRoundRobin = 1;

//
// Cxtion times out if partner response takes too long
//
DWORD       CommTimeoutInMilliSeconds;      // timeout in msec
ULONGLONG   CommTimeoutCheck;               // timeout in 100 nsec units

//
// Maximum time to wait for upstream partner to respond to fetch before unjoining
// connection. If the upstream partner is down (server or service) then the connection
// is unjoined after CommTimeoutInMilliSeconds. 10 hours.
//

#define FRS_MAX_FETCH_WAIT_TIME_IN_MINUTES 10 * 60

//
// rpc handle cache.
//
// Each entry contains a connection guid and a list of handles protected by
// a lock.  Each comm packet sent to a given connection first tries to get
// previously bound handle from the handle cache, creating a new one if necc.
//
// Note:  DAO, I don't understand why this is needed, Mario says RPC already
// allows multiple RPC calls on the same binding handle.  Ask Billy.
//
PGEN_TABLE  GHandleTable;



VOID
CommCompletionRoutine(
    PCOMMAND_PACKET,
    PVOID
    );

VOID
FrsCreateJoinGuid(
    OUT GUID *OutGuid
    );

VOID
FrsDelCsCompleteSubmit(
    IN PCOMMAND_PACKET  DelCmd,
    IN ULONG            Timeout
    );

PFRS_THREAD
ThSupEnumThreads(
    PFRS_THREAD     FrsThread
    );

DWORD
NtFrsApi_Rpc_Bind(
    IN  PWCHAR      MachineName,
    OUT PWCHAR      *OutPrincName,
    OUT handle_t    *OutHandle,
    OUT ULONG       *OutParentAuthLevel
    );


VOID
SndCsUnBindHandles(
    IN PGNAME To
    )
/*++
Routine Description:
    Unbind any handles associated with To in preparation for "join".

Arguments:
    To

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsUnBindHandles:"
    PGHANDLE            GHandle;
    PHANDLE_LIST        HandleList;

    DPRINT1(4, "Unbinding all handles for %ws\n", To->Name);

    //
    // Find the anchor for all of the bound, rpc handles to the server "To"
    //
    GHandle = GTabLookup(GHandleTable, To->Guid, NULL);
    if (GHandle == NULL) {
        return;
    }

    //
    // Unbind the handles
    //
    EnterCriticalSection(&GHandle->Lock);

    while (HandleList = GHandle->HandleList) {
        GHandle->HandleList = HandleList->Next;
        FrsRpcUnBindFromServer(&HandleList->RpcHandle);
        FrsFree(HandleList);
    }

    LeaveCriticalSection(&GHandle->Lock);
}




DWORD
SndCsAssignCommQueue(
    VOID
    )
/*++
Routine Description:

    A cxtion is assigned a comm queue when its creates or assigns a join guid
    (session).  The cxtion uses that comm queue for as long as the join guid is
    valid.  This insures packet order through the comm layer.  Old packets have
    an invalid join guid and are either not sent or ignored on the receiving side.

    Reserve comm queue 0 for join requests to partners whose previous rpc call
    took longer than MinJoinRetry to error off.

Arguments:
    None.

Return Value:
    Comm queue number (1 .. MAX_COMM_QUEUE_NUMBER - 1).
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsAssignCommQueue:"
    DWORD CommQueueIndex;

    //
    // Pseudo round robin. Avoid locks by checking bounds.
    //
    CommQueueIndex = CommQueueRoundRobin++;
    if (CommQueueRoundRobin >= MAX_COMM_QUEUE_NUMBER) {
        CommQueueRoundRobin = 1;
    }
    if (CommQueueIndex >= MAX_COMM_QUEUE_NUMBER) {
        CommQueueIndex = 1;
    }

    DPRINT1(4, "Assigned Comm Queue %d\n", CommQueueIndex);
    return CommQueueIndex;
}


VOID
SndCsCreateCxtion(
    IN OUT PCXTION  Cxtion
    )
/*++
Routine Description:
    Create a new join guid and comm queue for this cxtion.

    Assumes:  Caller has CXTION_TABLE lock.

Arguments:
    Cxtion

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsCreateCxtion:"

    DPRINT1(4, ":X: %ws: Creating join guid.\n", Cxtion->Name->Name);

    FrsCreateJoinGuid(&Cxtion->JoinGuid);

    SetCxtionFlag(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID |
                          CXTION_FLAGS_UNJOIN_GUID_VALID);

    //
    // Assign a comm queue.  A cxtion must use the same comm queue for a given
    // session (join guid) to maintain packet order.  Old packets have an
    // invalid join guid and are either not sent or ignored on the receiving side.
    //
    Cxtion->CommQueueIndex = SndCsAssignCommQueue();
}


VOID
SndCsDestroyCxtion(
    IN PCXTION  Cxtion,
    IN DWORD    CxtionFlags
    )
/*++
Routine Description:

    Destroy a cxtion's join guid and unbind handles.

    Assumes:  Caller has CXTION_TABLE lock.

Arguments:
    Cxtion      - Cxtion being destroyed.
    CxtionFlags - Caller specifies which state flags are cleared.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsDestroyCxtion:"

    //
    // Nothing to do
    //
    if (Cxtion == NULL) {
        return;
    }

    //
    // Invalidate the join guid. Packets to be sent to this connection are
    // errored off because of their invalid join guid.
    // Packets received are errored off for the same reason.
    //
    DPRINT2(4, ":X: %ws: Destroying join guid (%08x)\n", Cxtion->Name->Name, CxtionFlags);

    ClearCxtionFlag(Cxtion, CxtionFlags |
                            CXTION_FLAGS_JOIN_GUID_VALID |
                            CXTION_FLAGS_TIMEOUT_SET);

    //
    // Unbind the old handles.  They aren't very useful without a
    // valid join guid.  This function is called out of FrsFreeType() when
    // freeing a cxtion; hence the partner field may not be filled in.  Don't
    // unbind handles if there is no partner.
    //
    if ((Cxtion->Partner != NULL)       &&
        (Cxtion->Partner->Guid != NULL) &&
        !Cxtion->JrnlCxtion) {
        SndCsUnBindHandles(Cxtion->Partner);
    }
}


VOID
SndCsCxtionTimeout(
    IN PCOMMAND_PACKET  TimeoutCmd,
    IN PVOID            Ignore
    )
/*++

Routine Description:

    The cxtion has not received a reply from its partner for quite
    awhile. Unjoin the cxtion.

Arguments:

    TimeoutCmd  -- Timeout command packet
    Ignore

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsCxtionTimeout:"
    PREPLICA    Replica;
    PCXTION     Cxtion;

    PWCHAR      ParentPrincName = NULL;
    handle_t    ParentHandle = NULL;
    ULONG       ParentAuthLevel;
    DWORD       WStatus;
    CHAR        TimeStr[TIME_STRING_LENGTH];
    ULONGLONG   CurrentTime;
    LONGLONG    TimeDelta;

    //
    // Not a true timeout; just some error condition. Probably
    // shutdown. Ignore it.
    //
    if (!WIN_SUCCESS(TimeoutCmd->ErrorStatus)) {
        return;
    }

    //
    // Pull out params from command packet
    //
    Replica = SRReplica(TimeoutCmd);
    Cxtion = SRCxtion(TimeoutCmd);

    LOCK_CXTION_TABLE(Replica);

    //
    // The timeout is associated with a different join guid; ignore it
    //
    if (!CxtionFlagIs(Cxtion, CXTION_FLAGS_TIMEOUT_SET) ||
        !CxtionFlagIs(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
        !GUIDS_EQUAL(&SRJoinGuid(TimeoutCmd), &Cxtion->JoinGuid)) {
        ClearCxtionFlag(Cxtion, CXTION_FLAGS_TIMEOUT_SET);
        UNLOCK_CXTION_TABLE(Replica);
        return;
    }


    //
    // Check if the inbound partner is still up. If the partner is up then do not unjoin the
    // connection. The partner could be working on genenrating staging file for
    // a huge file and so we do not want to unjoin the connection but rather wait
    // for the partner to finish.
    //

//    FileTimeToString((PFILETIME)&SRLastJoinTime(TimeoutCmd), TimeStr);

//    DPRINT1(4, "SRLastJoinTime(TimeoutCmd) %s\n", TimeStr);

//    FileTimeToString((PFILETIME)&Cxtion->LastJoinTime, TimeStr);

//    DPRINT1(4, "Cxtion->LastJoinTime %s\n", TimeStr);

    if (Cxtion->Inbound == TRUE) {


        WStatus = NtFrsApi_Rpc_Bind(Cxtion->PartnerDnsName,
                                    &ParentPrincName,
                                    &ParentHandle,
                                    &ParentAuthLevel);

        FrsFree(ParentPrincName);

        if (ParentHandle) {
            RpcBindingFree(&ParentHandle);
        }

        if (WIN_SUCCESS(WStatus)) {


            FileTimeToString((PFILETIME)&SRTimeoutSetTime(TimeoutCmd), TimeStr);

            DPRINT1(4, "Timeout set time %s\n", TimeStr);

            GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

            FileTimeToString((PFILETIME)&CurrentTime, TimeStr);

            DPRINT1(4, "Current time %s\n", TimeStr);

            TimeDelta = CurrentTime - SRTimeoutSetTime(TimeoutCmd);
            TimeDelta = TimeDelta / CONVERT_FILETIME_TO_MINUTES;

            DPRINT1(4, "TimeDelta is %d minutes\n", TimeDelta);

            //
            // Setting an upper limit on how long to wait.
            // FRS_MAX_FETCH_WAIT_TIME_IN_MINUTES is set to 10 hours (10 * 60)
            //

            if (TimeDelta <= FRS_MAX_FETCH_WAIT_TIME_IN_MINUTES) {
                CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Extend timer");
                WaitSubmit(TimeoutCmd, CommTimeoutInMilliSeconds, CMD_DELAYED_COMPLETE);
                UNLOCK_CXTION_TABLE(Replica);
                return;
            }
        }

        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Timeout expired, Unjoin Cxtion");
    }

    //
    // Increment the Communication Timeouts counter for both the
    // replica set and the connection.
    //
    PM_INC_CTR_REPSET(Replica, CommTimeouts, 1);
    PM_INC_CTR_CXTION(Cxtion, CommTimeouts, 1);

    ClearCxtionFlag(Cxtion, CXTION_FLAGS_TIMEOUT_SET);
    UNLOCK_CXTION_TABLE(Replica);

    RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_UNJOIN);

    return;
}


BOOL
SndCsCheckCxtion(
    IN PCOMMAND_PACKET Cmd
    )
/*++
Routine Description:
    Check that the join guid is still valid, set the timer if needed.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsCheckCxtion:"
    PREPLICA    Replica;
    PCXTION     Cxtion;
    ULONG       WaitTime;

    Replica = SRReplica(Cmd);
    Cxtion = SRCxtion(Cmd);

    //
    // Nothing to check
    //
    if (!SRJoinGuidValid(Cmd) &&
        !SRSetTimeout(Cmd) &&
        !VOLATILE_OUTBOUND_CXTION(Cxtion)) {
        return TRUE;
    }

    LOCK_CXTION_TABLE(Replica);

    //
    // Check that our session id (join guid) is still valid
    //
    if (SRJoinGuidValid(Cmd)) {

        if (!CxtionFlagIs(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
            !GUIDS_EQUAL(&SRJoinGuid(Cmd), &Cxtion->JoinGuid)) {
            DPRINT1(4, "++ %ws: Join guid is INVALID.\n", Cxtion->Name->Name);
            UNLOCK_CXTION_TABLE(Replica);
            return FALSE;
        }
    }

    //
    // If our partner doesn't respond in time, unjoin the cxtion.
    //
    // *** NOTE *** Since the following is using state in the Cxtion struct
    // to record timeout info, only one fetch request can be active at a time.
    // Look at the timeout code to see what it will do.
    //
    // :SP1: Volatile connection cleanup.
    //
    // A volatile connection is used to seed sysvols after dcpromo.  If there
    // is inactivity on a volatile outbound connection for more than
    // FRS_VOLATILE_CONNECTION_MAX_IDLE_TIME then this connection is unjoined.
    // An unjoin on a volatile outbound connection triggers a delete on that
    // connection.  This is to prevent the case where staging files are kept
    // for ever on the parent for a volatile connection.
    //
    if (SRSetTimeout(Cmd) || VOLATILE_OUTBOUND_CXTION(Cxtion)) {

        if (!CxtionFlagIs(Cxtion, CXTION_FLAGS_TIMEOUT_SET)) {

            if (Cxtion->CommTimeoutCmd == NULL) {
                Cxtion->CommTimeoutCmd = FrsAllocCommand(NULL, CMD_UNKNOWN);
                FrsSetCompletionRoutine(Cxtion->CommTimeoutCmd, SndCsCxtionTimeout, NULL);

                SRCxtion(Cxtion->CommTimeoutCmd) = Cxtion;
                SRReplica(Cxtion->CommTimeoutCmd) = Replica;

            }

            //
            // Update join guid, cmd packet may be left over from previous join.
            //
            COPY_GUID(&SRJoinGuid(Cxtion->CommTimeoutCmd), &Cxtion->JoinGuid);

            GetSystemTimeAsFileTime((PFILETIME)&SRTimeoutSetTime(Cxtion->CommTimeoutCmd));

            SRLastJoinTime(Cxtion->CommTimeoutCmd) = Cxtion->LastJoinTime;

            WaitTime = (VOLATILE_OUTBOUND_CXTION(Cxtion) ?
                        FRS_VOLATILE_CONNECTION_MAX_IDLE_TIME : CommTimeoutInMilliSeconds);

            WaitSubmit(Cxtion->CommTimeoutCmd, WaitTime, CMD_DELAYED_COMPLETE);

            SetCxtionFlag(Cxtion, CXTION_FLAGS_TIMEOUT_SET);
        }
    }

    UNLOCK_CXTION_TABLE(Replica);
    return TRUE;
}


DWORD
SndCsDispatchCommError(
    PCOMM_PACKET    CommPkt
    )
/*++
Routine Description:
    Transfering a comm packet to the appropriate command server
    for error processing.

Arguments:
    CommPkt - comm packet that couldn't be sent

Return Value:
    WIN32 Status
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsDispatchCommError:"
    DWORD   WStatus;

    DPRINT1(4, "Comm pkt in error %08x\n", CommPkt);

    switch(CommPkt->CsId) {

        case CS_RS:
            WStatus = RcsSubmitCommPktWithErrorToRcs(CommPkt);
            break;

        default:
            DPRINT1(0, "Unknown command server id %d\n", CommPkt->CsId);
            WStatus = ERROR_INVALID_FUNCTION;
    }

    DPRINT1_WS(0, "Could not process comm pkt with error %08x;", CommPkt, WStatus);
    return WStatus;
}






DWORD
SndCsExit(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:

    Immediate cancel of all outstanding RPC calls for the thread
    identified by FrsThread. Set the tombstone to 5 seconds from
    now. If this thread does not exit within that time, any calls
    to ThSupWaitThread() will return a timeout error.

Arguments:
    FrsThread

Return Value:
    ERROR_SUCCESS
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsExit:"

    if (HANDLE_IS_VALID(FrsThread->Handle)) {
        DPRINT1(4, ":X: Canceling RPC requests for thread %ws\n", FrsThread->Name);
        RpcCancelThreadEx(FrsThread->Handle, 0);
    }

    return ThSupExitWithTombstone(FrsThread);
}


LONG
SndCsMainFilter(
    IN PEXCEPTION_POINTERS ExceptionPointer
    )
{
    NTSTATUS ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    
    return EXCEPTION_EXECUTE_HANDLER;
}


DWORD
SndCsMain(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for a thread serving the Send Command Server.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsMain:"
    DWORD               WStatus;
    PFRS_QUEUE          IdledQueue;
    PCOMMAND_PACKET     Cmd;
    PGHANDLE            GHandle;
    PHANDLE_LIST        HandleList;
    PCXTION             Cxtion;
    PREPLICA            Replica;
    ULARGE_INTEGER      Now;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)Arg;

    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &SndCs);

    //
    // Immediate cancel of outstanding RPC calls during shutdown
    //
    RpcMgmtSetCancelTimeout(0);
    FrsThread->Exit = SndCsExit;

    //
    // Try-Finally
    //
    try {

    //
    // Capture exception.
    //
    try {
        //
        // Pull entries off the "send" queue and send them on
        //
cant_exit_yet:
        while (Cmd = FrsGetCommandServerIdled(&SndCs, &IdledQueue)) {

            Cxtion = SRCxtion(Cmd);
            Replica = SRReplica(Cmd);

            COMMAND_SND_COMM_TRACE(4, Cmd, ERROR_SUCCESS, "SndDeQ");

            //
            // The RPC interface was initialized at this time but the
            // advent of the API RPC interfaces necessitated moving
            // the RPC initialization into MainMustInit. The event
            // and the CMD_INIT_SUBSYSTEM command are left intact
            // until such time as they are deemed completely unneeded.
            //
            if (Cmd->Command == CMD_INIT_SUBSYSTEM) {
                //
                // All done
                //
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                FrsRtlUnIdledQueue(IdledQueue);
                SetEvent(CommEvent);
                continue;
            }

            //
            // Send the Cmd to Cs
            //
            if (Cmd->Command == CMD_SND_CMD) {
                FrsSubmitCommandServer(SRCs(Cmd), SRCmd(Cmd));
                SRCmd(Cmd) = NULL;
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                FrsRtlUnIdledQueue(IdledQueue);
                continue;
            }

            FRS_ASSERT(SRCommPkt(Cmd));
            FRS_ASSERT(SRTo(Cmd));

            COMMAND_SND_COMM_TRACE(4, Cmd, ERROR_SUCCESS, "SndStart");

            if (FrsIsShuttingDown) {
                //
                // Complete w/error
                //
                WStatus = ERROR_PROCESS_ABORTED;
                COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndFail - shutting down");
                FrsCompleteCommand(Cmd, WStatus);
                FrsRtlUnIdledQueue(IdledQueue);
                continue;
            }

            //
            // Check that the join guid (if any) is still valid
            //
            if (!SndCsCheckCxtion(Cmd)) {
                COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndFail - stale join guid");
                //
                // Unjoin the replica\cxtion (if applicable)
                //
                SndCsDispatchCommError(SRCommPkt(Cmd));

                //
                // Complete w/error
                //
                FrsCompleteCommand(Cmd, ERROR_OPERATION_ABORTED);
                FrsRtlUnIdledQueue(IdledQueue);
                continue;
            }

            //
            // Grab a bound rpc handle for this connection target.
            //
            GTabLockTable(GHandleTable);
            GHandle = GTabLookupNoLock(GHandleTable, SRTo(Cmd)->Guid, NULL);
            if (GHandle == NULL) {
                GHandle = FrsAllocType(GHANDLE_TYPE);
                COPY_GUID(&GHandle->Guid, SRTo(Cmd)->Guid);
                GTabInsertEntryNoLock(GHandleTable, GHandle, &GHandle->Guid, NULL);
            }
            GTabUnLockTable(GHandleTable);

            //
            // Grab the first handle entry off the list
            //
            EnterCriticalSection(&GHandle->Lock);
            GHandle->Ref = TRUE;
            HandleList = GHandle->HandleList;
            if (HandleList != NULL) {
                GHandle->HandleList = HandleList->Next;
            }
            LeaveCriticalSection(&GHandle->Lock);

            WStatus = ERROR_SUCCESS;
            if (HandleList == NULL) {
                //
                // No free handles bound to the destination server available.
                // Allocate a new one.
                // Note:  Need to add a binding handle throttle.
                // Note:  Why don't we use the same handle for multiple calls?
                //
                HandleList = FrsAlloc(sizeof(HANDLE_LIST));
                if (FrsIsShuttingDown) {
                    WStatus = ERROR_PROCESS_ABORTED;
                    COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndFail - shutting down");
                } else {
                    //
                    // Rpc call is cancelled if it doesn't return from
                    // the rpc runtime in time. This is because TCP/IP
                    // doesn't timeout if the server reboots.
                    //
                    GetSystemTimeAsFileTime((FILETIME *)&FrsThread->StartTime);
                    WStatus = FrsRpcBindToServer(SRTo(Cmd),
                                                 SRPrincName(Cmd),
                                                 SRAuthLevel(Cmd),
                                                 &HandleList->RpcHandle);
                    //
                    // Associate a penalty with the cxtion based on the
                    // time needed to fail the rpc bind call. The penalty
                    // is applied against joins to prevent a dead machine
                    // from tying up Snd threads as they wait to timeout
                    // repeated joins.
                    //
                    if (Cxtion != NULL) {
                        if (!WIN_SUCCESS(WStatus)) {
                            GetSystemTimeAsFileTime((FILETIME *)&Now);
                            if (Now.QuadPart > FrsThread->StartTime.QuadPart) {
                                Cxtion->Penalty += (ULONG)(Now.QuadPart -
                                                   FrsThread->StartTime.QuadPart) /
                                                   (1000 * 10);
                                COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndFail - Binding Penalty");
                                DPRINT1(4, "++ SndFail - Binding Penalty - %d\n", Cxtion->Penalty);
                            }
                        }
                    }
                    //
                    // Reset RPC Cancel timeout for thread. No longer in rpc call.
                    //
                    FrsThread->StartTime.QuadPart = QUADZERO;
                }

                if (!WIN_SUCCESS(WStatus)) {
                    HandleList = FrsFree(HandleList);
                    COMMAND_SND_COMM_TRACE(0, Cmd, WStatus, "SndFail - binding");
                    //
                    // Increment the Bindings in error counter for both the
                    // replica set and the connection.
                    //
                    PM_INC_CTR_REPSET(Replica, BindingsError, 1);
                    PM_INC_CTR_CXTION(Cxtion, BindingsError, 1);

                } else {
                    //
                    // Increment the Bindings counter for both the
                    // replica set and the connection.
                    //
                    PM_INC_CTR_REPSET(Replica, Bindings, 1);
                    PM_INC_CTR_CXTION(Cxtion, Bindings, 1);
                }
            }

            if (WIN_SUCCESS(WStatus)) {
                //
                // Bind was successful and join guid is okay; send it on
                //
                try {
                    //
                    // Rpc call is cancelled if it doesn't return from
                    // the rpc runtime in time. This is because TCP/IP
                    // doesn't timeout if the server reboots.
                    //
                    GetSystemTimeAsFileTime((FILETIME *)&FrsThread->StartTime);
                    if (FrsIsShuttingDown) {
                        WStatus = ERROR_PROCESS_ABORTED;
                        COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndFail - shutting down");
                    } else {
                        WStatus = FrsRpcSendCommPkt(HandleList->RpcHandle, SRCommPkt(Cmd));
                        if (!WIN_SUCCESS(WStatus)) {
                            COMMAND_SND_COMM_TRACE(0, Cmd, WStatus, "SndFail - rpc call");
                        } else {
                            COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndSuccess");
                        }
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    GET_EXCEPTION_CODE(WStatus);
                    COMMAND_SND_COMM_TRACE(0, Cmd, WStatus, "SndFail - rpc exception");
                }
                //
                // Associate a penalty with the cxtion based on the time needed
                // to fail the rpc call.  The penalty is applied against joins
                // to prevent a dead machine from tying up Snd threads as they
                // wait to timeout repeated joins.
                //
                if (Cxtion != NULL) {
                    if (!WIN_SUCCESS(WStatus)) {
                        GetSystemTimeAsFileTime((FILETIME *)&Now);
                        if (Now.QuadPart > FrsThread->StartTime.QuadPart) {
                            Cxtion->Penalty += (ULONG)(Now.QuadPart -
                                               FrsThread->StartTime.QuadPart) /
                                               (1000 * 10);
                            COMMAND_SND_COMM_TRACE(0, Cmd, WStatus, "SndFail - Send Penalty");
                            DPRINT1(4, "++ SndFail - Send Penalty - %d\n", Cxtion->Penalty);
                        }
                    } else {
                        Cxtion->Penalty = 0;
                    }
                }
                //
                // Reset RPC Cancel timeout for thread. No longer in rpc call.
                //
                FrsThread->StartTime.QuadPart = QUADZERO;

                //
                // The binding may be out of date; discard it
                //
                if (!WIN_SUCCESS(WStatus)) {
                    //
                    // Increment the Packets sent with error counter for both the
                    // replica set and the connection.
                    //
                    PM_INC_CTR_REPSET(Replica, PacketsSentError, 1);
                    PM_INC_CTR_CXTION(Cxtion, PacketsSentError, 1);

                    if (!FrsIsShuttingDown) {
                        FrsRpcUnBindFromServer(&HandleList->RpcHandle);
                    }
                    HandleList = FrsFree(HandleList);
                } else {
                    //
                    // Increment the Packets sent and bytes sent counter for both the
                    // replica set and the connection.
                    //
                    PM_INC_CTR_REPSET(Replica, PacketsSent, 1);
                    PM_INC_CTR_CXTION(Cxtion, PacketsSent, 1);
                    PM_INC_CTR_REPSET(Replica, PacketsSentBytes, SRCommPkt(Cmd)->PktLen);
                    PM_INC_CTR_CXTION(Cxtion, PacketsSentBytes, SRCommPkt(Cmd)->PktLen);
                }
            }

            //
            // We are done with the rpc handle. Return it to the list for
            // another thread to use. This saves rebinding for every call.
            //
            if (HandleList) {
                EnterCriticalSection(&GHandle->Lock);
                GHandle->Ref = TRUE;
                HandleList->Next = GHandle->HandleList;
                GHandle->HandleList = HandleList;
                LeaveCriticalSection(&GHandle->Lock);
            }

            //
            // Don't retry.  The originator of the command packet is
            // responsible for retry.  We DO NOT want multiple layers of
            // retries because that can lead to frustratingly long timeouts.
            //
            if (!WIN_SUCCESS(WStatus)) {
                //
                // Discard future packets that depend on this join
                //
                LOCK_CXTION_TABLE(Replica);
                SndCsDestroyCxtion(Cxtion, 0);
                UNLOCK_CXTION_TABLE(Replica);
                //
                // Unjoin the replica\cxtion (if applicable)
                //
                SndCsDispatchCommError(SRCommPkt(Cmd));
            }

            FrsCompleteCommand(Cmd, WStatus);
            FrsRtlUnIdledQueue(IdledQueue);

        }  // end of while()

        //
        // Exit
        //
        FrsExitCommandServer(&SndCs, FrsThread);
        goto cant_exit_yet;

    //
    // Get exception status.
    //
    } except (SndCsMainFilter(GetExceptionInformation())) {
        GET_EXCEPTION_CODE(WStatus);
    }

    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "SndCsMain finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_PROCESS_ABORTED)) {
            DPRINT(0, "SndCsMain terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}


VOID
SndCsCommTimeout(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    Age the handle cache and cancel hung rpc requests every so often.
    Submit Cmd back onto the Delayed-Command-Server's queue.

Arguments:
    Cmd - delayed command packet
    Arg - Unused

Return Value:
    None. Cmd is submitted to DelCs.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsCommTimeout:"

    DWORD           WStatus;
    PFRS_THREAD     FrsThread;
    ULARGE_INTEGER  Now;
    PVOID           Key;
    PGHANDLE        GHandle;
    PHANDLE_LIST    HandleList;
    extern ULONG    RpcAgedBinds;

    COMMAND_SND_COMM_TRACE(4, Cmd, ERROR_SUCCESS, "SndChk - Age and Hung");

    //
    // Age the handle cache
    //
    GTabLockTable(GHandleTable);
    Key = NULL;

    while (GHandle = GTabNextDatumNoLock(GHandleTable, &Key)) {
        EnterCriticalSection(&GHandle->Lock);

        if (!GHandle->Ref) {

            while (HandleList = GHandle->HandleList) {
                GHandle->HandleList = HandleList->Next;
                ++RpcAgedBinds;
                FrsRpcUnBindFromServer(&HandleList->RpcHandle);
                FrsFree(HandleList);
                DPRINT(5, "++ FrsRpcUnBindFromServer\n");
            }
        }
        GHandle->Ref = FALSE;
        LeaveCriticalSection(&GHandle->Lock);
    }
    GTabUnLockTable(GHandleTable);

    //
    // Cancel hung rpc requests
    //
    GetSystemTimeAsFileTime((FILETIME *)&Now);

    FrsThread = NULL;
    while (FrsThread = ThSupEnumThreads(FrsThread)) {

        //
        // If frs is shutting down; skip it
        //
        if (FrsIsShuttingDown) {
            continue;
        }

        //
        // Some other thread; skip it
        //
        if (FrsThread->Main != SndCsMain) {
            continue;
        }

        //
        // SndCs thread; Is it in an rpc call?
        //
        if (FrsThread->StartTime.QuadPart == QUADZERO) {
            continue;
        }

        //
        // Is the thread running? If not, skip it
        //
        if (!FrsThread->Running ||
            !HANDLE_IS_VALID(FrsThread->Handle)) {
            continue;
        }

        //
        // Is it hung in an rpc call?
        //
        if ((FrsThread->StartTime.QuadPart < Now.QuadPart) &&
            ((Now.QuadPart - FrsThread->StartTime.QuadPart) >= CommTimeoutCheck)) {
            //
            // Yep, cancel the rpc call
            //
            WStatus = RpcCancelThreadEx(FrsThread->Handle, 0);
            DPRINT1_WS(4, "++ RpcCancelThread(%d);", FrsThread->Id, WStatus);
            COMMAND_SND_COMM_TRACE(4, Cmd, WStatus, "SndChk - Cancel");
        }
    }

    //
    // Re-submit the command packet to the delayed command server
    //
    if (!FrsIsShuttingDown) {
        FrsDelCsCompleteSubmit(Cmd, CommTimeoutInMilliSeconds << 1);
    } else {
        //
        // Send the packet on to the generic completion routine
        //
        FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
        FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
    }
}


VOID
SndCsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the send command server subsystem.

    Alloc handle table, read reg pars, Create/init SndCs Alloc comm queue
    array, attach comm queues to SndCs control queue.

Arguments:
    None.

Return Value:
    TRUE    - command server has been started
    FALSE   - Not
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsInitialize:"
    ULONG           Status;
    DWORD           i;
    PCOMMAND_PACKET Cmd;
    ULONG           MaxThreads;

    //
    // Get the timeout value and convert to 100 nsec units.
    //
    CfgRegReadDWord(FKC_COMM_TIMEOUT, NULL, 0, &CommTimeoutInMilliSeconds);

    DPRINT1(4, ":S: CommTimeout is %d msec\n", CommTimeoutInMilliSeconds);

    CommTimeoutCheck = ((ULONGLONG)CommTimeoutInMilliSeconds) * 1000 * 10;
    DPRINT1(4, ":S: CommTimeout is %08x %08x 100-nsec\n",
            PRINTQUAD(CommTimeoutCheck));

    //
    // Binding handle table
    //
    GHandleTable = GTabAllocTable();

    //
    // Comm layer command server
    //
    CfgRegReadDWord(FKC_SNDCS_MAXTHREADS_PAR, NULL, 0, &MaxThreads);
    FrsInitializeCommandServer(&SndCs, MaxThreads, L"SndCs", SndCsMain);
    //
    // A short array of comm queues to increase parallelism.  Each Comm queue
    // is attached to the Send cmd server control queue.  Each cxtion gets
    // assigned to a comm queue when it "JOINS" to preserve packet order.
    //
    for (i = 0; i < MAX_COMM_QUEUE_NUMBER; ++i) {
        FrsInitializeQueue(&CommQueues[i], &SndCs.Control);
    }

    //
    // Start the comm layer
    //
    Cmd = FrsAllocCommand(&SndCs.Queue, CMD_INIT_SUBSYSTEM);
    FrsSubmitCommandServer(&SndCs, Cmd);

    //
    // Age the handle cache and check for hung rpc calls
    //
    Cmd = FrsAllocCommand(&SndCs.Queue, CMD_VERIFY_SERVICE);
    FrsSetCompletionRoutine(Cmd, SndCsCommTimeout, NULL);

    FrsDelCsCompleteSubmit(Cmd, CommTimeoutInMilliSeconds << 1);
}


VOID
SndCsUnInitialize(
    VOID
    )
/*++
Routine Description:
    Uninitialize the send command server subsystem.

Arguments:
    None.

Return Value:
    TRUE    - command server has been started
    FALSE   - Not
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsUnInitialize:"
    DWORD   i;

    GTabFreeTable(GHandleTable, FrsFreeType);

    //
    // A short array of comm queues to increase parallelism.
    //
    for (i = 0; i < MAX_COMM_QUEUE_NUMBER; ++i) {
        FrsRtlDeleteQueue(&CommQueues[i]);
    }
}


VOID
SndCsSubmitCommPkt(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN GUID                 *JoinGuid,
    IN BOOL                 SetTimeout,
    IN PCOMM_PACKET         CommPkt,
    IN DWORD                CommQueueIndex
    )
/*++

Routine Description:
    Submit a comm packet to the "send" command server for the target Cxtion.

Arguments:
    Replica - Replica struct ptr

    Cxtion - Target connection for comm packet.

    Coe - Change order entry for related stage file fetch comm packet.
          This is used track the change orders that have a fetch request outstanding
          on a given inbound connection.  Used by Forced Unjoins to send the
          CO thru the Retry path.
          NOTE: When Coe is supplied then SetTimeout should also be TRUE.

    JoinGuid - Current join Guid from Cxtion or null if starting join seq.

    SetTimeout - TRUE if caller wants a timeout set on this send request.
                 It means that the caller is eventually expecting a response
                 back.  E.G. usually set on stage file fetch requests.

    CommPkt - Communication packet data to send.

    CommQueueIndex - Index of communication queue to use, generally allocated
                     for each Cxtion struct.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsSubmitCommPkt:"
    PCOMMAND_PACKET Cmd;

    FRS_ASSERT(CommQueueIndex < MAX_COMM_QUEUE_NUMBER);

    //
    // WARN: we assume that this function is called single-threaded per replica.
    // Davidor - Would be nice if the friggen comment above said why?  I
    // currently don't see the reason for this.
    // Maybe: its the time out code in SndCsCheckCxtion()?
    //
    if (Coe != NULL) {
        //
        // Anytime we are supplying a Coe argument we are expecting a response
        // so verify that SetTimeout was requested and put the Coe in the
        // Cxtion's Coe table so we can send it through the retry path at
        // unjoin (or timeout).
        //
        FRS_ASSERT(SetTimeout);
        LOCK_CXTION_COE_TABLE(Replica, Cxtion);
        FRS_ASSERT(GTabLookupNoLock(Cxtion->CoeTable, &Coe->Cmd.ChangeOrderGuid, NULL) == NULL);
        GTabInsertEntry(Cxtion->CoeTable, Coe, &Coe->Cmd.ChangeOrderGuid, NULL);
        UNLOCK_CXTION_COE_TABLE(Replica, Cxtion);
    }

    Cmd = FrsAllocCommand(&CommQueues[CommQueueIndex], CMD_SND_COMM_PACKET);

    SRTo(Cmd) = FrsBuildGName(FrsDupGuid(Cxtion->Partner->Guid),
                              FrsWcsDup(Cxtion->PartnerDnsName));
    SRReplica(Cmd) = Replica;
    SRCxtion(Cmd) = Cxtion;

    if (JoinGuid) {
        COPY_GUID(&SRJoinGuid(Cmd), JoinGuid);
        SRJoinGuidValid(Cmd) = TRUE;
    }

    //
    // Partner principal name and Authentication level.
    //
    SRPrincName(Cmd) = FrsWcsDup(Cxtion->PartnerPrincName);
    SRAuthLevel(Cmd) = Cxtion->PartnerAuthLevel;

    SRSetTimeout(Cmd) = SetTimeout;
    SRCommPkt(Cmd) = CommPkt;

    FrsSetCompletionRoutine(Cmd, CommCompletionRoutine, NULL);

    //
    // Check Comm packet consistency and put Send cmd on sent CS queue.
    //
    if (CommCheckPkt(CommPkt)) {
        COMMAND_SND_COMM_TRACE(4, Cmd, ERROR_SUCCESS, "SndEnQComm");
        FrsSubmitCommandServer(&SndCs, Cmd);
    } else {
        COMMAND_SND_COMM_TRACE(4, Cmd, ERROR_SUCCESS, "SndEnQERROR");
        FrsCompleteCommand(Cmd, ERROR_INVALID_BLOCK);
    }
}



VOID
SndCsSubmitCommPkt2(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN BOOL                 SetTimeout,
    IN PCOMM_PACKET         CommPkt
    )
/*++

Routine Description:
    Submit a comm packet to the "send" command server using the assigned
    comm queue for the target Cxtion.

    The Comm queue index and the join Guid come from the cxtion struct.

Arguments:
    See arg description for SndCsSubmitCommPkt.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsSubmitCommPkt2:"

    SndCsSubmitCommPkt(Replica,
                       Cxtion,
                       Coe,
                       &Cxtion->JoinGuid,
                       SetTimeout,
                       CommPkt,
                       Cxtion->CommQueueIndex);

}


VOID
SndCsSubmitCmd(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCOMMAND_SERVER      FlushCs,
    IN PCOMMAND_PACKET      FlushCmd,
    IN DWORD                CommQueueIndex
    )
/*++

Routine Description:
    Submit the FlushCmd packet to the "send" command server for the
    target Cxtion. The FlushCmd packet will be submitted to
    FlushCs once it bubbles to the top of the queue. I.e., once
    the queue has been flushed.

Arguments:
    Replica     - replica set
    Cxtion      - cxtion identifies send queue
    FlushCs     - Command server to receive Cmd
    FlushCmd    - Command packet to send to Cs
    CommQueueIndex - Identifies the comm queue

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsSubmitCmd:"
    PCOMMAND_PACKET Cmd;

    FRS_ASSERT(CommQueueIndex < MAX_COMM_QUEUE_NUMBER);

    //
    // Alloc the cmd packet and set the target queue and the command.
    //
    Cmd = FrsAllocCommand(&CommQueues[CommQueueIndex], CMD_SND_CMD);

    //
    // Destination Partner Guid / Dns Name
    //
    SRTo(Cmd) = FrsBuildGName(FrsDupGuid(Cxtion->Partner->Guid),
                              FrsWcsDup(Cxtion->PartnerDnsName));
    SRReplica(Cmd) = Replica;
    SRCxtion(Cmd) = Cxtion;
    SRCs(Cmd) = FlushCs;
    SRCmd(Cmd) = FlushCmd;
    SRPrincName(Cmd) = FrsWcsDup(Cxtion->PartnerPrincName);
    SRAuthLevel(Cmd) = Cxtion->PartnerAuthLevel;

    FrsSetCompletionRoutine(Cmd, CommCompletionRoutine, NULL);

    COMMAND_SND_COMM_TRACE(4, Cmd, ERROR_SUCCESS, "SndEnQCmd");
    FrsSubmitCommandServer(&SndCs, Cmd);
}


VOID
SndCsShutDown(
    VOID
    )
/*++
Routine Description:
    Shutdown the send command server

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define  DEBSUB  "SndCsShutDown:"
    DWORD   i;

    //
    // A short array of comm queues to increase parallelism.
    //
    for (i = 0; i < MAX_COMM_QUEUE_NUMBER; ++i) {
        FrsRunDownCommandServer(&SndCs, &CommQueues[i]);
    }

    FrsRunDownCommandServer(&SndCs, &SndCs.Queue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\frsthrd.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frsthrd.c

Abstract:
    Simple thread management in addition to the queue management.

Author:
    Billy J. Fuller 26-Mar-1997

Revised:
    David Orbits - May 2000 : Revised naming.

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <frs.h>
#include <perrepsr.h>

#define THSUP_THREAD_TOMBSTONE  (5 * 1000)

//
// Global list of threads
//
LIST_ENTRY  FrsThreadList;

//
// Protects FrsThreadList
//
CRITICAL_SECTION    FrsThreadCriticalSection;

//
// Exiting threads can queue a "wait" request
//
COMMAND_SERVER  ThCs;


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)       // Not all control paths return (due to infinite loop)
#endif

DWORD
ThSupMainCs(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for thread command server thread. This thread
    is needed for abort and exit processing; hence this command
    server is never aborted and the thread never exits!

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB  "ThSupMainCs:"
    PCOMMAND_PACKET Cmd;
    PCOMMAND_SERVER Cs;
    PFRS_THREAD     FrsThread = Arg;

    FRS_ASSERT(FrsThread);
    Cs = FrsThread->Data;
    FRS_ASSERT(Cs == &ThCs);

    //
    // Our exit routine sets Data to non-NULL as a exit flag
    //
    while (TRUE) {
        Cmd = FrsGetCommandServer(&ThCs);
        if (Cmd == NULL) {
            continue;
        }
        FRS_ASSERT(Cmd->Command == CMD_WAIT);
        FRS_ASSERT(ThThread(Cmd));

        //
        // Any thread using the CMD_WAIT must get a thread reference the thread
        // before enqueueing the command to protect against multiple waiters.
        //
        // Wait for the thread to terminate. The assumption is that the thread
        // associated with the FrsThread struct will soon be terminating, ending the wait.
        //
        FrsThread = ThThread(Cmd);
        ThSupWaitThread(FrsThread, INFINITE);
        //
        // When the last ref is dropped the FrsThread struct is freed.
        //
        ThSupReleaseRef(FrsThread);
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }

    return ERROR_SUCCESS;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



DWORD
ThSupExitWithTombstone(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:

    Mark the thread as tombstoned. If this thread does not exit within that
    time, any calls to ThSupWaitThread() return a timeout error.

Arguments:

    FrsThread

Return Value:
    ERROR_SUCCESS
--*/
{
#undef   DEBSUB
#define  DEBSUB  "ThSupExitWithTombstone:"
    //
    // If this thread does not exit within the THSUP_THREAD_TOMBSTONE interval then
    // don't wait on it and count it as an exit timeout.
    //
    FRS_ASSERT(FrsThread);

    FrsThread->ExitTombstone = GetTickCount();
    if (FrsThread->ExitTombstone == 0) {
        FrsThread->ExitTombstone = 1;
    }

    return ERROR_SUCCESS;
}


DWORD
ThSupExitThreadNOP(
    PVOID Arg
    )
/*++
Routine Description:
    Use this exit function when you don't want the cleanup code
    to kill the thread but you have no exit processing to do. E.g.,
    a command server.

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
--*/
{
#undef  DEBSUB
#define DEBSUB  "ThSupExitThreadNOP:"

    return ERROR_SUCCESS;
}






VOID
ThSupInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the FRS thread subsystem. Must be called before any other
    thread function and must be called only once.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB  "ThSupInitialize:"

    INITIALIZE_CRITICAL_SECTION(&FrsThreadCriticalSection);

    InitializeListHead(&FrsThreadList);

    FrsInitializeCommandServer(&ThCs, 1, L"ThCs", ThSupMainCs);
}





PVOID
ThSupGetThreadData(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:
    Return the thread specific data portion of the thread context.

Arguments:
    FrsThread   - thread context.

Return Value:
    Thread specific data
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupGetThreadData:"

    FRS_ASSERT(FrsThread);
    return (FrsThread->Data);
}



PFRS_THREAD
ThSupAllocThread(
    PWCHAR  Name,
    PVOID   Param,
    DWORD   (*Main)(PVOID),
    DWORD   (*Exit)(PVOID)
    )
/*++
Routine Description:
    Allocate a thread context and call its Init routine.

Arguments:
    Param   - parameter to the thread
    Main    - entry point
    Exit    - called to force thread to exit

Return Value:
    Thread context.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupAllocThread:"
    ULONG       Status;
    PFRS_THREAD FrsThread;

    //
    // Create a thread context for a soon-to-be-running thread
    //
    FrsThread = FrsAllocType(THREAD_TYPE);

    FrsThread->Name = Name;
    FrsThread->Running = TRUE;
    FrsThread->Ref = 1;
    FrsThread->Main = Main;
    FrsThread->Exit = Exit;
    FrsThread->Data = Param;

    InitializeListHead(&FrsThread->List);

    //
    // Add to global list of threads (Unless this is our command server)
    //
    if (Main != ThSupMainCs) {
        EnterCriticalSection(&FrsThreadCriticalSection);
        InsertTailList(&FrsThreadList, &FrsThread->List);
        LeaveCriticalSection(&FrsThreadCriticalSection);
    }

    return FrsThread;
}


VOID
ThSupReleaseRef(
    PFRS_THREAD     FrsThread
    )
/*++
Routine Description:
    Dec the thread's reference count. If the count goes to 0, free
    the thread context.

Arguments:
    FrsThread       - thread context

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupReleaseRef:"

    if (FrsThread == NULL) {
        return;
    }

    FRS_ASSERT(FrsThread->Main != ThSupMainCs || FrsThread->Running);

    //
    // If the ref count goes to 0 and the thread isn't running, free the context
    //
    EnterCriticalSection(&FrsThreadCriticalSection);
    FRS_ASSERT(FrsThread->Ref > 0);

    if (--FrsThread->Ref == 0 && !FrsThread->Running) {
        FrsRemoveEntryList(&FrsThread->List);
    } else {
        FrsThread = NULL;
    }

    LeaveCriticalSection(&FrsThreadCriticalSection);

    //
    // ref count is not 0 or the thread is still running
    //
    if (FrsThread == NULL) {
        return;
    }

    //
    // Ref count is 0; Close the thread's handle.
    //
    FRS_CLOSE(FrsThread->Handle);

    FrsThread = FrsFreeType(FrsThread);
}


PFRS_THREAD
ThSupEnumThreads(
    PFRS_THREAD     FrsThread
    )
/*++
Routine Description:

    This routine scans the list of threads. If FrsThread is NULL,
    the current head is returned. Otherwise, the next entry is returned.
    If FrsThead is non-Null its ref count is decremented.

Arguments:
    FrsThread       - thread context or NULL

Return Value:
    The next thread context or NULL if we hit the end of the list.
    A reference is taken on the returned thread.

--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupEnumThreads:"

    PLIST_ENTRY     Entry;
    PFRS_THREAD     NextFrsThread;

    //
    // Get the next thread context (the head of the list if FrsThread is NULL)
    //
    EnterCriticalSection(&FrsThreadCriticalSection);

    Entry = (FrsThread != NULL) ? GetListNext(&FrsThread->List)
                                : GetListNext(&FrsThreadList);

    if (Entry == &FrsThreadList) {
        //
        // back at the head of the list
        //
        NextFrsThread = NULL;
    } else {
        //
        // Increment the ref count
        //
        NextFrsThread = CONTAINING_RECORD(Entry, FRS_THREAD, List);
        NextFrsThread->Ref++;
    }

    LeaveCriticalSection(&FrsThreadCriticalSection);

    //
    // Release the reference on the old thread context.
    //
    if (FrsThread != NULL) {
        ThSupReleaseRef(FrsThread);
    }

    return NextFrsThread;
}


BOOL
ThSupCreateThread(
    PWCHAR  Name,
    PVOID   Param,
    DWORD   (*Main)(PVOID),
    DWORD   (*Exit)(PVOID)
    )
/*++
Routine Description:
    Kick off the thread and return its context.

    Note: The caller must release thread reference when done

Arguments:
    Param   - parameter to the thread
    Main    - entry point
    Exit    - called to force thread to exit

Return Value:
    Thread context. Caller must call ThSupReleaseRef() to release it.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupCreateThread:"
    PFRS_THREAD     FrsThread;

    //
    // Allocate a thread context
    //
    FrsThread = ThSupAllocThread(Name, Param, Main, Exit);
    if (FrsThread == NULL) {
        return FALSE;
    }
    //
    // Kick off the thread
    //
    FrsThread->Handle = (HANDLE) CreateThread(NULL,
                                              10000,
                                              Main,
                                              (PVOID)FrsThread,
                                              0,
                                              &FrsThread->Id);
    //
    // thread is not running. The following ThSupReleaseRef will clean up.
    //
    if (!HANDLE_IS_VALID(FrsThread->Handle)) {
        DPRINT_WS(0, "Can't start thread; ",GetLastError());
        FrsThread->Running = FALSE;
        ThSupReleaseRef(FrsThread);
        return FALSE;
    } else {
        //
        // Increment the Threads started counter
        //
        PM_INC_CTR_SERVICE(PMTotalInst, ThreadsStarted, 1);

        DPRINT3(4, ":S: Starting thread %ws: Id %d (%08x)\n",
                Name, FrsThread->Id, FrsThread->Id);

        ThSupReleaseRef(FrsThread);

        DbgCaptureThreadInfo2(Name, Main, FrsThread->Id);
        return TRUE;
    }
}


DWORD
ThSupWaitThread(
    PFRS_THREAD FrsThread,
    DWORD Millisec
    )
/*++
Routine Description:

    Wait at most MilliSeconds for the thread to exit.  If the thread has set
    a wait tombstone (i.e. it is terminating) then don't wait longer than the
    time remaining on the tombstone.

Arguments:
    FrsThread - thread context
    Millisec  - Time to wait.  Use INFINITE if no timeout desired.

Return Value:

    Status of the wait if timeout or the exit code of the thread.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupWaitThread:"

    ULONGLONG   CreateTime, ExitTime, KernelTime, UserTime;

    DWORD       WStatus, Status, ExitCode;
    DWORD       Beg, End, TimeSinceTombstone;

    //
    // No problems waiting for this one!
    //
    if (!FrsThread || !HANDLE_IS_VALID(FrsThread->Handle)) {
        return ERROR_SUCCESS;
    }

    //
    // Wait awhile for the thread to exit
    //
    DPRINT1(1, ":S: %ws: Waiting\n", FrsThread->Name);

    Beg = GetTickCount();
    if (FrsThread->ExitTombstone != 0) {
        //
        // The thread has registered an exit tombstone so don't wait past that
        // time.  Simply return a timeout error.  Note: GetTickCount has a
        // period of 49.7 days so the unsigned difference handles the wrap problem.
        //
        TimeSinceTombstone = Beg - FrsThread->ExitTombstone;
        if (TimeSinceTombstone >= THSUP_THREAD_TOMBSTONE) {
            //
            // Tombstone expired
            //
            DPRINT1(1, ":S: %ws: Tombstone expired\n", FrsThread->Name);
            Status = WAIT_TIMEOUT;
        } else {
            //
            // Tombstone has a ways to go; wait only up to the tombstone time.
            //
            DPRINT1(1, ":S: %ws: Tombstone expiring\n", FrsThread->Name);
            Status = WaitForSingleObject(FrsThread->Handle,
                                         THSUP_THREAD_TOMBSTONE - TimeSinceTombstone);
        }
    } else {
        //
        // no tombstone; wait the requested time
        //
        DPRINT1(1, ":S: %ws: normal wait\n", FrsThread->Name);
        Status = WaitForSingleObject(FrsThread->Handle, Millisec);
    }

    //
    // Adjust the error status based on the outcome
    //
    if ((Status == WAIT_OBJECT_0) || (Status == WAIT_ABANDONED)) {
        DPRINT1_WS(1, ":S: %ws: wait successful. ", FrsThread->Name, Status);
        WStatus = ERROR_SUCCESS;
    } else {
        if (Status == WAIT_FAILED) {
            WStatus = GetLastError();
            DPRINT1_WS(1, ":S: %ws: wait failed;", FrsThread->Name, WStatus);
        } else {
            DPRINT1_WS(1, ":S: %ws: wait timed out. ", FrsThread->Name, Status);
            WStatus = ERROR_TIMEOUT;
        }
    }

    //
    // Wait over
    //
    End = GetTickCount();
    DPRINT2_WS(1, ":S: Done waiting for thread %ws (%d ms); ", FrsThread->Name, End - Beg, WStatus);

    //
    // Thread has exited. Get exit status and set thread struct as "not running".
    //
    if (WIN_SUCCESS(WStatus)) {
        FrsThread->Running = FALSE;

        if (GetExitCodeThread(FrsThread->Handle, &ExitCode)) {
            WStatus = ExitCode;
            DPRINT1_WS(1, ":S: %ws: exit code - \n", FrsThread->Name, WStatus);
        }
    }

    if (GetThreadTimes(FrsThread->Handle,
                       (PFILETIME)&CreateTime,
                       (PFILETIME)&ExitTime,
                       (PFILETIME)&KernelTime,
                       (PFILETIME)&UserTime)) {
        //
        // Hasn't exited, yet
        //
        if (ExitTime < CreateTime) {
            ExitTime = CreateTime;
        }
        DPRINT4(4, ":S: %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                FrsThread->Name,
                (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
    }

    return WStatus;
}


DWORD
ThSupExitThreadGroup(
    IN DWORD    (*Main)(PVOID)
    )
/*++
Routine Description:

    Force the group of threads with the given Main function to exit by
    calling their exit routine. Wait for the threads to exit.

Arguments:
    Main    - Main function or NULL

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupExitThreadGroup:"
    DWORD           WStatus;
    DWORD           RetWStatus;
    PFRS_THREAD     FrsThread;
    ULONGLONG       CreateTime;
    ULONGLONG       ExitTime;
    ULONGLONG       KernelTime;
    ULONGLONG       UserTime;

    //
    // call the threads exit function (forcibly terminate if none)
    //
    FrsThread = NULL;
    while (FrsThread = ThSupEnumThreads(FrsThread)) {
        if (Main == NULL || Main == FrsThread->Main) {
            ThSupExitSingleThread(FrsThread);
        }
    }
    //
    // wait for the threads to exit
    //
    RetWStatus = ERROR_SUCCESS;
    FrsThread = NULL;
    while (FrsThread = ThSupEnumThreads(FrsThread)) {
        if (Main == NULL || Main == FrsThread->Main) {
            WStatus = ThSupWaitThread(FrsThread, INFINITE);
            if (!WIN_SUCCESS(WStatus)) {
                RetWStatus = WStatus;
            }
        }
    }
    if (GetThreadTimes(GetCurrentThread(),
                       (PFILETIME)&CreateTime,
                       (PFILETIME)&ExitTime,
                       (PFILETIME)&KernelTime,
                       (PFILETIME)&UserTime)) {
        //
        // Hasn't exited, yet
        //
        if (ExitTime < CreateTime) {
            ExitTime = CreateTime;
        }
        DPRINT4(4, ":S: %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                L"SHUTDOWN",
                (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
    }
    if (GetProcessTimes(ProcessHandle,
                       (PFILETIME)&CreateTime,
                       (PFILETIME)&ExitTime,
                       (PFILETIME)&KernelTime,
                       (PFILETIME)&UserTime)) {
        //
        // Hasn't exited, yet
        //
        if (ExitTime < CreateTime) {
            ExitTime = CreateTime;
        }
        DPRINT4(0, ":S: %-15ws: %8d CPU Seconds (%d kernel, %d elapsed)\n",
                L"PROCESS",
                (DWORD)((KernelTime + UserTime) / (10 * 1000 * 1000)),
                (DWORD)((KernelTime) / (10 * 1000 * 1000)),
                (DWORD)((ExitTime - CreateTime) / (10 * 1000 * 1000)));
    }

    return RetWStatus;
}


VOID
ThSupExitSingleThread(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:

    Force the thread to exit

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupExitSingleThread:"

    //
    // call the thread's exit function (forcibly terminate if none)
    //
    FRS_ASSERT(FrsThread);
    if (FrsThread->Exit != NULL) {
        (*FrsThread->Exit)(FrsThread);
    } else {
        //
        // No exit function; forcibly terminate
        //
        if (HANDLE_IS_VALID(FrsThread->Handle)) {
            TerminateThread(FrsThread->Handle, STATUS_UNSUCCESSFUL);
        }
    }

    //
    // Increment the Threads exited counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, ThreadsExited, 1);
}



PFRS_THREAD
ThSupGetThread(
    DWORD   (*Main)(PVOID)
    )
/*++
Routine Description:
    Locate a thread whose entry point is Main.

Arguments:
    Main    - entry point to search for.

Return Value:
    thread context
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupGetThread:"

    PFRS_THREAD     FrsThread;

    //
    // Scan the list of threads looking for one whose entry point is Main
    //
    FrsThread = NULL;
    while (FrsThread = ThSupEnumThreads(FrsThread)) {
        if (FrsThread->Main == Main) {
            return FrsThread;
        }
    }

    return NULL;
}




VOID
ThSupAcquireRef(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:
    Inc the thread's reference count.

Arguments:
    FrsThread   - thread context

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupAcquireRef:"

    FRS_ASSERT(FrsThread);
    FRS_ASSERT(FrsThread->Running);

    //
    // If the ref count goes to 0 and the thread isn't running, free the context
    //
    EnterCriticalSection(&FrsThreadCriticalSection);
    ++FrsThread->Ref;
    LeaveCriticalSection(&FrsThreadCriticalSection);
}




VOID
ThSupSubmitThreadExitCleanup(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:

    Submit a wait command for this thread to the thread command server.

    The thread command server (ThQs) will do an infinte wait on this thread's exit
    and drop the reference on its thread struct so it can be cleaned up.

    The assumption is that the thread associated with the FrsThread struct will
    soon be terminating.

Arguments:
    FrsThread   - thread context

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ThSupSubmitThreadExitCleanup:"

    PCOMMAND_PACKET Cmd;

    //
    // Reference the thread until after the wait has completed to guard
    // against the case of multiple waiters
    //
    ThSupAcquireRef(FrsThread);

    //
    // Allocate a command packet and send the command off to the
    // thread command server.
    //
    Cmd = FrsAllocCommand(&ThCs.Queue, CMD_WAIT);
    ThThread(Cmd) = FrsThread;
    FrsSubmitCommandServer(&ThCs, Cmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\initsync.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:
    initsync.c

Abstract:
    Initial Sync Controller Command Server. The initial sync controller command server
    controls the sequencing of vvjoins for a new member of the replica set.
    This command server is active only during the time the replica set is in seeding state.
    During this time the cxtions are paused and unpaused by this command server to make
    sure that only 1 vvjoin is in process at any given time. The priority on the cxtion
    is used to decide the order of vvjoins.

    Following flags are used by this command server.

    CXTION_FLAGS_INIT_SYNC      : Location = PCXTION->Flags
    ^^^^^^^^^^^^^^^^^^^^^^
    This flag is set on all inbound connections that are added to a replica set when
    it is in the seeding state. This flag is set when the connection is initialized
    in OutLogAddNewPartner() and it is reset when the cxtion completes vvjoin in
    InitSyncVvJoinDone. While this flag is set and the replica is in seeding state
    all decisions to join are made by the initsync command server. Once the cxtion
    completes vvjoin and this flag is cleared the cxtion is free to join at any time.
    This flag is persistent in the DB,

    CXTION_FLAGS_PAUSED         : Location = PCXTION->Flags
    ^^^^^^^^^^^^^^^^^^^
    If a connection has this flag set then it is not allowed to join with its
    inbound partner. The command server clears this flag in order. All cxtions
    that have the CXTION_FLAGS_INIT_SYNC set start off as paused. They get unpaused
    when its their turn to vvjoin.

    CXTION_FLAGS_HUNG_INIT_SYNC : Location = PCXTION->Flags
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    This flag is set on a cxtion to indicate that there has been no progress on this
    connection for a specified time (timeout) since a NEED_JOIN was sent. If the current
    working connection gets in this state the command server may decide to unpause
    the next cxtion on list.

    CONFIG_FLAG_ONLINE          : Location PREPLICA->CnfFlags
    ^^^^^^^^^^^^^^^^^^
    Presence of this flag on the replica indicates that this member has successfully
    completed one pass through the inbound connections and is ready to go online. Until
    a member is online it will not join with its outbound partners. For a sysvol replica
    set going online also means sysvolready is set to 1. A replica set may be in
    online state but it may still be seeding. This depends on the priorities set on
    the cxtions.

    CONFIG_FLAG_SEEDING         : Location PREPLICA->CnfFlags
    ^^^^^^^^^^^^^^^^^^^
    We don't get here unless the replica set is in seeding state. A new replica
    starts up in seeding state unless it is the primary member of the replica set.


    *******************************  CXTION OPTIONS  **********************************

    The options attribute on the "NTDS Connection" object is used to specify the
    priority for a given connection. Options is a 32 bit value. The highest bit is
    used to indicate if the schedule should be ignored while vvjoining. The next 3
    bits are used to spevify a priority from 0-7. The following two masks are used
    to get the values.

    #define FRSCONN_PRIORITY_MASK             0x70000000
    #define NTDSCONN_OPT_IGNORE_SCHEDULE_MASK 0x80000000

    The ignore scheduel bit is not checked while the connection is in INIT_SYNC state.

    The priorities are interpretted as shown in the table below.

    Priority : Behavior
    Class

    0        : Volatile connections have this priority.
               Highest priority class,
               Try every cxtion in this class,
               skip to next class on communication errors.

    1-2      : Do not proceed to next class until done with all connections
               of this class.

    3-4      : Do not proceed to next class until done with at least one
               connection of this class.

    5-7      : Try every cxtion in this class,
               Skip to next class on communication errors.

    8        : FRSCONN_MAX_PRIORITY - A priority of '0' in the DS corresponds
               to this priority. We need to do this to maintain old
               behavior for connections that do not have a priority set.
               Do not proceed to next class until done with at least one
               connection from this class or any of the other classes.


     The command server forms a sorted list of the connections based on their priorities
     and then starts vvjoins on these connections one at a time. After every vvjoin
     is done it checks if the current class is satisfied based on the table above. If
     it is then cxtions from the next class are picked up and so on. When the last
     class is satisfied the member goes into Online state and is free to join with its
     outbound partners. Remaining connections will continue to vvjoin serially and when
     all are done the member goes out of seeding state.

    **********************************************************************************

Author:
    Sudarshan Chitre - 27th April 2001

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <ntdsapi.h>
#include <frs.h>
#include <perrepsr.h>
#include <tablefcn.h>
//
// Struct for the Initial Sync Controller Command Server
//      Contains info about the queues and the threads
//
COMMAND_SERVER InitSyncCs;
ULONG  MaxInitSyncCsThreads;


extern PGEN_TABLE ReplicasByGuid;
//
// Replica Command server functions called from here.
//
VOID
RcsSubmitReplicaCxtionJoin(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN BOOL     Later
    );

VOID
RcsUpdateReplicaSetMember(
    IN PREPLICA Replica
    );

VOID
RcsJoinCxtion(
    IN PCOMMAND_PACKET  Cmd
    );

VOID
RcsEmptyPreExistingDir(
    IN PREPLICA Replica
    );

BOOL
RcsSetSysvolReady(
    IN DWORD    NewSysvolReady
    );

VOID
RcsReplicaSetRegistry(
    IN PREPLICA     Replica
    );


//
// Send Command server functions called from here.
//
VOID
SndCsSubmitCommPkt2(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN BOOL                 SetTimeout,
    IN PCOMM_PACKET         CommPkt
    );

PCOMM_PACKET
CommBuildCommPkt(
    IN PREPLICA                 Replica,
    IN PCXTION                  Cxtion,
    IN ULONG                    Command,
    IN PGEN_TABLE               VVector,
    IN PCOMMAND_PACKET          Cmd,
    IN PCHANGE_ORDER_COMMAND    Coc
    );


BOOL
InitSyncPriorityClassSemanticsA(
    IN PREPLICA     Replica,
    IN DWORD        PriorityClass
    )
/*++
Routine Description:
    This function determines if the current state of the cxtions satisfies
    Semantics 'A' for priority class 'PriorityClass'

    This class is satisfied if all cxtions from this class have completed
    the initial sync.

Arguments:
    Replica       - Replica in question.
    PriorityClass - Priority class to evaluate for.

Return Value:
    TRUE if ok to move to next class, FALSE otherwise.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncPriorityClassSemanticsA:"

    PCXTION     Cxtion;
    PVOID       Key;
    PGEN_ENTRY  Entry;
    DWORD       NumInClass     = 0;
    DWORD       NumComplete    = 0;
    DWORD       NumCommError   = 0;
    DWORD       NumNotComplete = 0;


    DPRINT1(5,":IS: InitSyncPriorityClassSemanticsA called with priority %d\n", PriorityClass);

    Key = NULL;
    GTabLockTable(Replica->InitSyncCxtionsMasterList);
    while (Entry = GTabNextEntryNoLock(Replica->InitSyncCxtionsMasterList, &Key)) {

        Cxtion = Entry->Data;

        if (Cxtion->Priority > PriorityClass) {
            //
            // We have done evaluating the class in question.
            //
            break;
        } else if (Cxtion->Priority < PriorityClass) {
            continue;
        }

        do {
            Cxtion = Entry->Data;

            DPRINT5(5, ":IS: Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                    Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                    (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                    L"Init sync done"));

            NumInClass++;

            if (!CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC)) {
                NumComplete++;
            } else if ((Cxtion->Penalty != 0) ||
                       (CxtionFlagIs(Cxtion,CXTION_FLAGS_HUNG_INIT_SYNC))){
                //
                // Either there was some comm error trying to talk to this
                // partner or this partner has not sent us packets in a while.
                //
                NumCommError++;
                NumNotComplete++;
            } else {
                NumNotComplete++;
            }

            Entry = Entry->Dups;
        } while ( Entry != NULL );
    }

    GTabUnLockTable(Replica->InitSyncCxtionsMasterList);

    //
    // This class is satisfied if all cxtions from this class have completed
    // the initial sync.
    //
    if (NumInClass == NumComplete) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
InitSyncPriorityClassSemanticsB(
    IN PREPLICA     Replica,
    IN DWORD        PriorityClass
    )
/*++
Routine Description:
    This function determines if the current state of the cxtions satisfies
    Semantics 'B' for priority class 'PriorityClass'

    This class is satisfied if atleast one cxtion from this class has completed
    the initial sync..

Arguments:
    Replica       - Replica in question.
    PriorityClass - Priority class to evaluate for.

Return Value:
    TRUE if ok to move to next class, FALSE otherwise.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncPriorityClassSemanticsB:"

    PCXTION     Cxtion;
    PVOID       Key;
    PGEN_ENTRY  Entry;
    DWORD       NumInClass     = 0;
    DWORD       NumComplete    = 0;
    DWORD       NumCommError   = 0;
    DWORD       NumNotComplete = 0;


    DPRINT1(5,":IS: InitSyncPriorityClassSemanticsB called with priority %d\n", PriorityClass);

    Key = NULL;
    GTabLockTable(Replica->InitSyncCxtionsMasterList);
    while (Entry = GTabNextEntryNoLock(Replica->InitSyncCxtionsMasterList, &Key)) {

        Cxtion = Entry->Data;

        if (Cxtion->Priority > PriorityClass) {
            //
            // We have done evaluating the class in question.
            //
            break;
        } else if (Cxtion->Priority < PriorityClass) {
            continue;
        }

        do {
            Cxtion = Entry->Data;

            DPRINT5(5, " :IS: Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                    Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                    (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                    L"Init sync done"));

            NumInClass++;

            if (!CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC)) {
                NumComplete++;
            } else if ((Cxtion->Penalty != 0) ||
                       (CxtionFlagIs(Cxtion,CXTION_FLAGS_HUNG_INIT_SYNC))){
                //
                // Either there was some comm error trying to talk to this
                // partner or this partner has not sent us packets in a while.
                //
                NumCommError++;
                NumNotComplete++;
            } else {
                NumNotComplete++;
            }

            Entry = Entry->Dups;
        } while ( Entry != NULL );
    }

    GTabUnLockTable(Replica->InitSyncCxtionsMasterList);

    //
    // This class is satisfied if atleast one cxtion from this class has completed
    // the initial sync..
    //
    if ((NumInClass == 0) || (NumComplete >= 1)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
InitSyncPriorityClassSemanticsC(
    IN PREPLICA     Replica,
    IN DWORD        PriorityClass
    )
/*++
Routine Description:
    This function determines if the current state of the cxtions satisfies
    Semantics 'C' for priority class 'PriorityClass'

    This class is satisfied when all cxtions in this class have been attempted.

Arguments:
    Replica       - Replica in question.
    PriorityClass - Priority class to evaluate for.

Return Value:
    TRUE if ok to move to next class, FALSE otherwise.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncPriorityClassSemanticsC:"

    PCXTION     Cxtion;
    PVOID       Key;
    PGEN_ENTRY  Entry;
    DWORD       NumInClass     = 0;
    DWORD       NumComplete    = 0;
    DWORD       NumCommError   = 0;
    DWORD       NumNotComplete = 0;


    DPRINT1(5,":IS: InitSyncPriorityClassSemanticsC called with priority %d\n", PriorityClass);

    Key = NULL;
    GTabLockTable(Replica->InitSyncCxtionsMasterList);
    while (Entry = GTabNextEntryNoLock(Replica->InitSyncCxtionsMasterList, &Key)) {

        Cxtion = Entry->Data;

        if (Cxtion->Priority > PriorityClass) {
            //
            // We have done evaluating the class in question.
            //
            break;
        } else if (Cxtion->Priority < PriorityClass) {
            continue;
        }

        do {
            Cxtion = Entry->Data;

            DPRINT5(5, "Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                    Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                    (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                    L"Init sync done"));

            NumInClass++;

            if (!CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC)) {
                NumComplete++;
            } else if ((Cxtion->Penalty != 0) ||
                       (CxtionFlagIs(Cxtion,CXTION_FLAGS_HUNG_INIT_SYNC))){
                //
                // Either there was some comm error trying to talk to this
                // partner or this partner has not sent us packets in a while.
                //
                NumCommError++;
                NumNotComplete++;
            } else {
                NumNotComplete++;
            }

            Entry = Entry->Dups;
        } while ( Entry != NULL );
    }

    GTabUnLockTable(Replica->InitSyncCxtionsMasterList);

    //
    // This class is satisfied when all cxtions in this class have been attempted.
    //
    if (NumInClass == (NumComplete + NumCommError)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
InitSyncPriorityClassSemanticsD(
    IN PREPLICA     Replica,
    IN DWORD        PriorityClass
    )
/*++
Routine Description:
    This function determines if the current state of the cxtions satisfies
    Semantics 'D' for priority class 'PriorityClass'


    This class is satisfied if atleast one cxtion has completed
    the initial sync..


Arguments:
    Replica       - Replica in question.
    PriorityClass - Priority class to evaluate for.

Return Value:
    TRUE if ok to move to next class, FALSE otherwise.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncPriorityClassSemanticsD:"

    PCXTION     Cxtion;
    PVOID       Key;
    PGEN_ENTRY  Entry;
    DWORD       NumTotal       = 0;
    DWORD       NumComplete    = 0;

    DPRINT1(5,":IS: InitSyncPriorityClassSemanticsB called with priority %d\n", PriorityClass);

    Key = NULL;
    GTabLockTable(Replica->InitSyncCxtionsMasterList);
    while (Entry = GTabNextEntryNoLock(Replica->InitSyncCxtionsMasterList, &Key)) {

        do {
            Cxtion = Entry->Data;

            DPRINT5(5, "Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                    Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                    (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                    L"Init sync done"));

            NumTotal++;

            if (!CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC)) {
                NumComplete++;
            }

            Entry = Entry->Dups;
        } while ( Entry != NULL );
    }

    GTabUnLockTable(Replica->InitSyncCxtionsMasterList);

    //
    // This class is satisfied if atleast one cxtion has completed
    // the initial sync..
    //
    if ((NumTotal == 0) || (NumComplete >= 1)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

//
// This is a static array of functions that determines what rules are applied to
// what priority class. The rules are in form of functions above that return
// true or false depending on whether the rule is satisfied or not.
//
BOOL (*InitSyncPriorityClassSemantic [])(PREPLICA,DWORD) = {
    InitSyncPriorityClassSemanticsC,    // Rules for priority class 0
    InitSyncPriorityClassSemanticsA,    // Rules for priority class 1
    InitSyncPriorityClassSemanticsA,    // Rules for priority class 2
    InitSyncPriorityClassSemanticsB,    // Rules for priority class 3
    InitSyncPriorityClassSemanticsB,    // Rules for priority class 4
    InitSyncPriorityClassSemanticsC,    // Rules for priority class 5
    InitSyncPriorityClassSemanticsC,    // Rules for priority class 6
    InitSyncPriorityClassSemanticsC,    // Rules for priority class 7
    InitSyncPriorityClassSemanticsD     // Rules for priority class 8
};


BOOL
InitSyncIsPriorityClassSatisfied(
    IN PREPLICA     Replica,
    IN DWORD        PriorityClass
    )
/*++
Routine Description:
    Use the priority class semantics to decide what is the max class we can work on,

Arguments:
    Replica       - Replica in question.
    PriorityClass - Priority class to evaluate for.

Return Value:
    TRUE if ok to move to next class, FALSE otherwise.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncGetMaxAllowedPriority:"

    BOOL    (* PrioritySemanticFunction)(PREPLICA,DWORD);

    PrioritySemanticFunction = InitSyncPriorityClassSemantic[PriorityClass];

    return (*PrioritySemanticFunction)(Replica,PriorityClass);
}


DWORD
InitSyncGetMaxAllowedPriority(
    IN PREPLICA     Replica
    )
/*++
Routine Description:
    Use the priority class semantics to decide what is the max class we can work on,

Arguments:
    Replica       - Replica in question.

Return Value:
    Maximum allowed priority class.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncGetMaxAllowedPriority:"

    DWORD       MaxAllowedPriorityClass = 0;

    //
    // Evaluate if each priority is satisfied or not.
    //

    while ((MaxAllowedPriorityClass <= FRSCONN_MAX_PRIORITY) &&
           InitSyncIsPriorityClassSatisfied(Replica,MaxAllowedPriorityClass)) {
        ++MaxAllowedPriorityClass;
    }

    DPRINT2(4,":IS: Replica %ws - MaxAllowedPriorityClass = %d\n",
            Replica->SetName->Name, MaxAllowedPriorityClass);

    return MaxAllowedPriorityClass;
}


DWORD
InitSyncGetWorkingPriority(
    IN PREPLICA     Replica
    )
/*++
Routine Description:
    Get the current priority class we are working on,

Arguments:
    Replica.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncGetWorkingPriority:"

    DWORD       WorkingPriority = 0;
    PVOID       Key;
    PCXTION     Cxtion;

    Key = NULL;
    while (Cxtion = GTabNextDatum(Replica->InitSyncCxtionsWorkingList, &Key)) {
        DPRINT5(5, ":IS: Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                L"Init sync done"));
        if (WorkingPriority < Cxtion->Priority) {
            WorkingPriority = Cxtion->Priority;
        }
    }

    DPRINT2(4,":IS: Replica %ws - CurrentWorkingPriorityClass = %d\n",
            Replica->SetName->Name, WorkingPriority);

    return WorkingPriority;
}

VOID
InitSyncCsSubmitTransfer(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command
    )
/*++
Routine Description:
    Transfer a request to the initial sync controller command server.

Arguments:
    Cmd       - Command packet.
    Command   - Command to convert to.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCsSubmitTransfer:"
    //
    // Submit a request to allocate staging area
    //
    Cmd->TargetQueue = RsReplica(Cmd)->InitSyncQueue;
    Cmd->Command = Command;
    RsTimeout(Cmd) = 0;
    DPRINT3(4,":IS: Transfer 0x%08x (0x%08x) to %ws\n",
            Command, Cmd, RsReplica(Cmd)->SetName->Name);
    FrsSubmitCommandServer(&InitSyncCs, Cmd);
}


VOID
InitSyncCmdPktCompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    Completion routine for InitSync command packets. Free some specific fields
    and send the command on to the generic command packet completion routine
    for freeing.

Arguments:
    Cmd       - Command packet.
    Arg       - Cmd->CompletionArg

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCmdPktCompletionRoutine:"

    DPRINT1(4, ":IS: InitSync completion 0x%08x\n", Cmd);

    FrsFreeGName(RsCxtion(Cmd));

    //
    // Send the packet on to the generic completion routine for freeing
    //
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);

}


VOID
InitSyncSubmitToInitSyncCs(
    IN PREPLICA Replica,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to a initial sync command server.

Arguments:
    Replica      - existing replica
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncSubmitToInitSyncCs:"
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(Replica->InitSyncQueue, Command);
    FrsSetCompletionRoutine(Cmd, InitSyncCmdPktCompletionRoutine, NULL);

    //
    // Address of replica set.
    //
    RsReplica(Cmd) = Replica;

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncSubmitToInitSyncCs cmd");
    FrsSubmitCommandServer(&InitSyncCs, Cmd);
}


VOID
InitSyncDelSubmitToInitSyncCs(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command,
    IN DWORD    TimeoutInMilliseconds
    )
/*++
Routine Description:
    Submit a new command to the delayed command server to be submitted to the
    initial sync controller command server after "TimeoutInMilliseconds" ms.

Arguments:
    Replica      - existing replica
    Cxtion       - existing connection
    Command
    TimeoutInMilliseconds - This command will be submitted to the Init Sync
                            Command server after these many ms.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncDelSubmitToInitSyncCs:"
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(Replica->InitSyncQueue, Command);
    FrsSetCompletionRoutine(Cmd, InitSyncCmdPktCompletionRoutine, NULL);

    //
    // Address of replica set.
    //
    RsReplica(Cmd) = Replica;

    Cmd->TargetQueue = Replica->InitSyncQueue;

    //
    // CommPkts are used to detect init sync hangs.
    //
    if (Cxtion != NULL) {
        RsCxtion(Cmd) = FrsDupGName(Cxtion->Name);
        RsCommPkts(Cmd) = Cxtion->CommPkts;
    }

    RsTimeout(Cmd) = TimeoutInMilliseconds;
    //
    // This command will come back to us in in a little bit.
    //
    DPRINT2(4,":IS: Submit Cmd (0x%08x), Command 0x%88x\n", Cmd, Cmd->Command);

    FrsDelCsSubmitSubmit(&InitSyncCs, Cmd, RsTimeout(Cmd));
}


BOOL
InitSyncCsDelCsSubmit(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command,
    IN DWORD            TimeoutInMilliseconds
    )
/*++
Routine Description:
    Submit this command to the delayed command server to be submitted to the
    initial sync controller command server after "TimeoutInMilliseconds" ms.

Arguments:
    Cmd
    Command
    TimeoutInMilliseconds - This command will be submitted to the Init Sync
                            Command server after these many ms.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCsDelCsSubmit:"

    //
    // Extend the retry time (but not too long)
    //

    Cmd->Command = Command;
    RsTimeout(Cmd) = TimeoutInMilliseconds;
    //
    // This command will come back to us in in a little bit.
    //
    DPRINT2(4,":IS: Submit Cmd (0x%08x), Command 0x%08x\n", Cmd, Cmd->Command);

    FrsDelCsSubmitSubmit(&InitSyncCs, Cmd, RsTimeout(Cmd));
    return (TRUE);
}



DWORD
InitSyncBuildMasterList(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Build the master list from the Replica->Cxtions table.

Arguments:
    Replica

Return Value:
    Number of entries in the table.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncBuildMasterList:"

    PCXTION     Cxtion  = NULL;
    PVOID       Key;
    DWORD       NumberOfEntries = 0;

    FRS_ASSERT(Replica->InitSyncCxtionsMasterList != NULL);
    //
    // If we already have a master list then empty it,
    //
    GTabEmptyTable(Replica->InitSyncCxtionsMasterList,NULL);

    LOCK_CXTION_TABLE(Replica);

    //
    // Take all inbound connections and put them in the master list.
    //
    Key = NULL;
    while (Cxtion = GTabNextDatum(Replica->Cxtions, &Key)) {

        //
        // Skip the journal conneciton.
        //
        if (Cxtion->JrnlCxtion) {
            continue;
        }

        //
        // We are interested in inbound connections only.
        //
        if (!Cxtion->Inbound) {
            continue;
        }

        //
        // We clear the paused bit on connections that have completed the initial sync.
        // These connections are free to join anytime. We still need them in the master
        // list as they are needed to verify if the priority class is satisfied.
        //
        if (!CxtionFlagIs(Cxtion, CXTION_FLAGS_INIT_SYNC)) {
            if (CxtionFlagIs(Cxtion,CXTION_FLAGS_PAUSED)) {
                ClearCxtionFlag(Cxtion, CXTION_FLAGS_PAUSED); // In case it is still set.
                CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, INITSYNC Unpaused");
            }
        } else {
            //
            // Initially all connections in INIT_SYNC state are paused.
            //
            SetCxtionFlag(Cxtion, CXTION_FLAGS_PAUSED);
            CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, INITSYNC Paused");
        }


        GTabInsertEntry(Replica->InitSyncCxtionsMasterList, Cxtion, &Cxtion->Priority, NULL);
    }

    NumberOfEntries = GTabNumberInTable(Replica->InitSyncCxtionsMasterList);

    UNLOCK_CXTION_TABLE(Replica);

    return NumberOfEntries;
}


VOID
InitSyncBuildWorkingList(
    IN PREPLICA Replica,
    IN DWORD    PriorityClass,
    IN BOOL     ResetList
    )
/*++
Routine Description:
    Build the working list from the Replica->InitSyncCxtionsMasterList table.

Arguments:
    Replica
    PriorityClass - Max Priority Class to pull from master list.
    ResetList - Rebuild the working list.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncBuildWorkingList:"

    PCXTION     Cxtion  = NULL;
    PVOID       Key;
    PGEN_ENTRY  Entry;


    LOCK_CXTION_TABLE(Replica);

    //
    // If we already have a working list then empty it and create a new one,
    //
    if ((Replica->InitSyncCxtionsWorkingList != NULL) && ResetList) {

        GTabEmptyTable(Replica->InitSyncCxtionsWorkingList,NULL);
    }


    Key = NULL;
    GTabLockTable(Replica->InitSyncCxtionsMasterList);


    //
    // Take all connections from the master list that are <= PriorityClass and
    // put them on the current working list.
    //
    while (Entry = GTabNextEntryNoLock(Replica->InitSyncCxtionsMasterList, &Key)) {

        Cxtion = Entry->Data;

        if (Cxtion->Priority <= PriorityClass) {
            do {
                Cxtion = Entry->Data;
                GTabInsertEntry(Replica->InitSyncCxtionsWorkingList, Cxtion, Cxtion->Name->Guid, NULL);
                Entry = Entry->Dups;
            } while ( Entry != NULL );
        }
    }

    GTabUnLockTable(Replica->InitSyncCxtionsMasterList);

    DPRINT1(4, ":IS: +++ Printing InitSyncCxtionsMasterList for Replica %ws\n", Replica->SetName->Name);
    Key = NULL;
    GTabLockTable(Replica->InitSyncCxtionsMasterList);
    while (Entry = GTabNextEntryNoLock(Replica->InitSyncCxtionsMasterList, &Key)) {
        do {
            Cxtion = Entry->Data;
            DPRINT5(4, ":IS: Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                    Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                    (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                    L"Init sync done"));
            Entry = Entry->Dups;
        } while ( Entry != NULL );
    }
    GTabUnLockTable(Replica->InitSyncCxtionsMasterList);

    DPRINT1(4, ":IS: +++ Printing InitSyncCxtionsWorkingList for Replica %ws\n", Replica->SetName->Name);

    Key = NULL;
    while (Cxtion = GTabNextDatum(Replica->InitSyncCxtionsWorkingList, &Key)) {
        DPRINT5(4, ":IS: Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                L"Init sync done"));
    }

    UNLOCK_CXTION_TABLE(Replica);

}


VOID
InitSyncStartSync(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Start the initial sync on this replica.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncStartSync:"
    PREPLICA            Replica;
    PCXTION             Cxtion;
    PVOID               Key;
    DWORD               CxtionPriority;
    PGEN_ENTRY          Entry;
    DWORD               MaxAllowedPriority;
    DWORD               NumberOfEntries = 0;

    Replica = RsReplica(Cmd);


    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncStartSync entry");
//    FRS_PRINT_TYPE(4, Replica);

    //
    // The replica has to be in SEEDING state to get this command.
    //

    FRS_ASSERT(BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING));

    //
    // If we have already started a initial sync on this replica then
    // nothing to do here.
    //
    if (Replica->InitSyncCxtionsMasterList != NULL) {
        return;
    }

    Replica->InitSyncCxtionsMasterList = GTabAllocNumberTable();
    Replica->InitSyncCxtionsWorkingList = GTabAllocTable();


    NumberOfEntries = InitSyncBuildMasterList(Replica);

    MaxAllowedPriority = InitSyncGetMaxAllowedPriority(Replica);

    InitSyncBuildWorkingList(Replica,MaxAllowedPriority,TRUE);

    InitSyncCsSubmitTransfer(Cmd, CMD_INITSYNC_JOIN_NEXT);

    InitSyncSubmitToInitSyncCs(Replica,CMD_INITSYNC_KEEP_ALIVE);

    return;

}


VOID
InitSyncKeepAlive(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    This command keeps coming back to us until all cxtions have completed the.
    initial sync. It is used to detect hangs.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncKeepAlive:"
    PREPLICA        Replica;
    PVOID           Key;
    PCXTION         Cxtion;
    PCXTION         ActiveCxtion;

    Replica = RsReplica(Cmd);


    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncKeepAlive entry");

    //
    // Stop calling keepalive once we are out of seeding state or if the replica set is stopped.
    //
    if (!BooleanFlagOn(Replica->CnfFlags,CONFIG_FLAG_SEEDING) ||
        (Replica->ServiceState == REPLICA_STATE_STOPPED)) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // Do not call JOIN_NEXT as long as there is one cxtion that is not paused and
    // not hung,
    //
    Key = NULL;
    while (Cxtion = GTabNextDatum(Replica->InitSyncCxtionsWorkingList, &Key)) {
        if (!CxtionFlagIs(Cxtion,CXTION_FLAGS_PAUSED) &&
            CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) &&
            !CxtionFlagIs(Cxtion,CXTION_FLAGS_HUNG_INIT_SYNC)) {

            //
            // Check if the connection is still a active connection.
            // This connection could have been deleted from the DS.
            //
            ActiveCxtion = GTabLookup(Replica->Cxtions, Cxtion->Name->Guid , NULL);

            if (ActiveCxtion != NULL) {
                DPRINT5(5, ":IS: Working on - Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                        Cxtion->Priority,Cxtion->Penalty, Cxtion->CommPkts, Cxtion->Name->Name,
                        (CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                        L"Init sync done"));
                goto RETURN;
            }
        }
    }

    InitSyncSubmitToInitSyncCs(Replica,CMD_INITSYNC_JOIN_NEXT);

RETURN:

    InitSyncCsDelCsSubmit(Cmd, CMD_INITSYNC_KEEP_ALIVE, 240 * 1000);

    return;
}


VOID
InitSyncCompletedOnePass(
    IN PREPLICA     Replica
    )
/*++
Routine Description:
    Initial sync completed one pass for this replica. Take the appropriate action.
    Share out the sysvols here.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCompletedOnePass:"


    DPRINT1(4,":IS: Replica %ws has successfully completed one pass of Seeding.\n",Replica->SetName->Name);

    SetFlag(Replica->CnfFlags, CONFIG_FLAG_ONLINE);
    Replica->NeedsUpdate = TRUE;
    RcsUpdateReplicaSetMember(Replica);

    //
    // Set sysvol ready to 1 if this is the sysvol replica set
    // and we haven't shared out the sysvol yet.
    //
    if (FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType) &&
        !Replica->IsSysvolReady) {
        RcsReplicaSetRegistry(Replica);
        Replica->IsSysvolReady = RcsSetSysvolReady(1);
    }

}


VOID
InitSyncCompleted(
    IN PREPLICA     Replica
    )
/*++
Routine Description:
    Initial sync completed for this replica. Take the appropriate action.
    Get out of seeding state.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCompleted:"


    ClearFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
    Replica->NeedsUpdate = TRUE;
    RcsUpdateReplicaSetMember(Replica);

    //
    // Half-hearted attempt to delete the empty directories from
    // the preexisting directory
    //
    RcsEmptyPreExistingDir(Replica);

    //
    // Cleanup the state associated with the InitSync state.
    //
    DPRINT1(4,":IS: Replica %ws has successfully completed Seeding.\n",Replica->SetName->Name);

    Replica->InitSyncCxtionsMasterList = GTabFreeTable(Replica->InitSyncCxtionsMasterList,NULL);
    Replica->InitSyncCxtionsWorkingList = GTabFreeTable(Replica->InitSyncCxtionsWorkingList,NULL);

}


VOID
InitSyncJoinNext(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Join the next in line.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncJoinNext:"
    PREPLICA            Replica;
    PCXTION             Cxtion;
//    PCXTION             NewCxtion;
    PVOID               Key;
    DWORD               CxtionPriority;
    PGEN_ENTRY          Entry;
    DWORD               NumUnPaused;
    DWORD               MasterMaxAllowedPriority;
    DWORD               CurrentWorkingPriority;
    DWORD               NumberOfEntries = 0;

    Replica = RsReplica(Cmd);

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncJoinNext entry");
//    FRS_PRINT_TYPE(4, Replica);

    //
    // If the replica has already seeded or if the replica is stopped
    // then we do not have anything to process.
    //
    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) ||
        (Replica->ServiceState == REPLICA_STATE_STOPPED)) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // Get the maximum allowed priority by scanning the master list.
    // We need to do this because new connections might have been added to
    // the master list that have higher priority than the current working priority
    // of the working list.
    //
    NumberOfEntries = InitSyncBuildMasterList(Replica);

    //
    // If there are no connections in the master list then there is
    // nothing to do yet. We don't was to get out of seeding state yet.
    // We will let the keep alive command send another join next.
    //
    if (NumberOfEntries == 0) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, No inbound connections");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    MasterMaxAllowedPriority = InitSyncGetMaxAllowedPriority(Replica);
    CurrentWorkingPriority = InitSyncGetWorkingPriority(Replica);

    InitSyncBuildWorkingList(Replica,MasterMaxAllowedPriority,TRUE);
/*
    if (MasterMaxAllowedPriority < CurrentWorkingPriority) {
        //
        // One or more new connections with lower priority might have been added.
        // reset the working list to reflect that.
        //
        InitSyncBuildWorkingList(Replica,MasterMaxAllowedPriority,TRUE);

    } else if (MasterMaxAllowedPriority > CurrentWorkingPriority) {
        //
        // Connections from next priority class can be added to the working list.
        //
        InitSyncBuildWorkingList(Replica,MasterMaxAllowedPriority,FALSE);
    }
*/
    if (MasterMaxAllowedPriority > FRSCONN_MAX_PRIORITY) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncJoinNext completed one pass");
        InitSyncCompletedOnePass(Replica);
    }

    LOCK_CXTION_TABLE(Replica);

    Key = NULL;
    NumUnPaused = 0;
    while (Cxtion = GTabNextDatum(Replica->InitSyncCxtionsWorkingList, &Key)) {

        //
        // If the cxtion has already completed the initial sync then skip it.
        //
        if (!CxtionFlagIs(Cxtion,CXTION_FLAGS_INIT_SYNC)) {
            continue;
        }

        ++NumUnPaused;

        if (CxtionFlagIs(Cxtion,CXTION_FLAGS_PAUSED)) {
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_PAUSED);
            CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, INITSYNC Unpaused");
        }

        if (CxtionFlagIs(Cxtion,CXTION_FLAGS_HUNG_INIT_SYNC)) {
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_HUNG_INIT_SYNC);
            CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, INITSYNC clear hung state");
        }

        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, INITSYNC sending NEED_JOIN");

        //
        // Submit a cmd with the replica command server to send need_join over this
        // cxtion,
        //
        RcsSubmitReplicaCxtionJoin(Replica, Cxtion, FALSE);
        //
        // Submit a cmd with the init sync command server to track the progress of this
        // cxtion. This cmd will look for hung init sync.
        //
        InitSyncDelSubmitToInitSyncCs(Replica,Cxtion,CMD_INITSYNC_CHECK_PROGRESS,300*1000);
    }

    UNLOCK_CXTION_TABLE(Replica);

    //
    // Done synching all connections. Reset seeding state.
    //
    if (NumUnPaused == 0) {

        InitSyncCompleted(Replica);
        RcsSubmitTransferToRcs(Cmd, CMD_VVJOIN_DONE_UNJOIN);

    } else {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }
}


VOID
InitSyncCheckProgress(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Check the progress of this connection. Put it in hung state if no packets have
    been received on this connection for some time.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCheckProgress:"
    PREPLICA            Replica;
    PCXTION             InCxtion;

    Replica = RsReplica(Cmd);

    //
    // Retire this command if we are out of seeding state or if the replica set is stopped.
    //
    if (!BooleanFlagOn(Replica->CnfFlags,CONFIG_FLAG_SEEDING) ||
        (Replica->ServiceState == REPLICA_STATE_STOPPED)) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    LOCK_CXTION_TABLE(Replica);

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncCheckProgress entry");

    //
    // Find and check the cxtion
    //
    InCxtion = GTabLookupNoLock(Replica->Cxtions, RsCxtion(Cmd)->Guid, NULL);

    if (InCxtion != NULL) {
        DPRINT5(5,":IS: Priority = %d, Penalty = %d, CommPkts = %d : %ws - %ws\n",
                InCxtion->Priority,InCxtion->Penalty, InCxtion->CommPkts, InCxtion->Name->Name,
                (CxtionFlagIs(InCxtion,CXTION_FLAGS_INIT_SYNC) ? L"Init sync pending" :
                L"Init sync done"));
    }

    //
    // Retire this command if the cxtion has been paused or if the connection is
    // out of seeding state.
    //
    if (!InCxtion || CxtionFlagIs(InCxtion,CXTION_FLAGS_PAUSED) ||
        !CxtionFlagIs(InCxtion,CXTION_FLAGS_INIT_SYNC)) {

        if ((InCxtion != NULL) && CxtionFlagIs(InCxtion,CXTION_FLAGS_HUNG_INIT_SYNC)) {
            ClearCxtionFlag(InCxtion,CXTION_FLAGS_HUNG_INIT_SYNC);
            CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, INITSYNC clear hung state");
        }

        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        goto RETURN;
    }

    //
    // Do not declare hung if the schedule is off and we are asked to follow schedule.
    //
    if (!NTDSCONN_IGNORE_SCHEDULE(InCxtion->Options) &&
        CxtionFlagIs(InCxtion,CXTION_FLAGS_SCHEDULE_OFF)){
        InitSyncCsDelCsSubmit(Cmd,CMD_INITSYNC_CHECK_PROGRESS,300*1000);
        goto RETURN;
    }

    if (RsCommPkts(Cmd) != InCxtion->CommPkts) {
        RsCommPkts(Cmd) = InCxtion->CommPkts;
        InitSyncCsDelCsSubmit(Cmd,CMD_INITSYNC_CHECK_PROGRESS,300*1000);
    } else {
        SetCxtionFlag(InCxtion,CXTION_FLAGS_HUNG_INIT_SYNC);
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, INITSYNC Hung");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }

RETURN:
    UNLOCK_CXTION_TABLE(Replica);
    return;
}


VOID
InitSyncStartJoin(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    We have received start join from a inbound partner. We send need joins to all the
    connections in the current class. When we get start_join from one of the partners
    we pick that one to vvjoin with first and put the remaining connections in the
    paused state.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncStartJoin:"
    PREPLICA            Replica;
    PCXTION             InCxtion;
    PCXTION             Cxtion;
    PCXTION             NewCxtion;
    PVOID               Key;

    Replica = RsReplica(Cmd);

    //
    // Trying to print the replica when you have the cxtion lock can lead to
    // a deadlock.
    //
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, InitSyncStartJoin entry");
//    FRS_PRINT_TYPE(4, Replica);

    LOCK_CXTION_TABLE(Replica);

    //
    // Find and check the cxtion
    //
    InCxtion = GTabLookupNoLock(Replica->Cxtions, RsCxtion(Cmd)->Guid, NULL);

    if (!InCxtion) {
        return;
    }

    //
    // Ignore the start join if this connection is paused.
    //
    if (CxtionFlagIs(InCxtion,CXTION_FLAGS_PAUSED)) {

        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, Paused - ignore start join");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        UNLOCK_CXTION_TABLE(Replica);

    } else {
        //
        // If we were waiting for our partner to respond or think we
        // have already joined then either start the join process or
        // resend our join info.
        //
        if (CxtionStateIs(InCxtion, CxtionStateUnjoined) ||
            CxtionStateIs(InCxtion, CxtionStateJoined)) {
            if (CxtionStateIs(InCxtion, CxtionStateUnjoined)) {
                SetCxtionState(InCxtion, CxtionStateStart);
            }
            //
            // Start the join process or resend the join info
            //
            // This is the first inbound partner that responded to the
            // NEED_JOIN. Start vvjoin with this inbound partner and
            // pause all other cxtions in the working list that are still in
            // INIT_SYNC state.
            //

            Key = NULL;
            while (Cxtion = GTabNextDatum(Replica->InitSyncCxtionsWorkingList, &Key)) {
                DPRINT2(4, "P - %d : %ws\n", Cxtion->Priority, Cxtion->Name->Name);
                FRS_PRINT_TYPE(4, Cxtion);

                NewCxtion = GTabLookup(Replica->Cxtions,Cxtion->Name->Guid,NULL);
                if (NewCxtion != NULL) {
                    if (!GUIDS_EQUAL(NewCxtion->Name->Guid,InCxtion->Name->Guid) &&
                        CxtionFlagIs(NewCxtion,CXTION_FLAGS_INIT_SYNC)) {
                        SetCxtionFlag(NewCxtion,CXTION_FLAGS_PAUSED);
                        CXTION_STATE_TRACE(3, NewCxtion, Replica, 0, "F, INITSYNC Paused");
                    }
                }
            }

            //
            // Clear the CXTION_FLAGS_HUNG_INIT_SYNC flag if it was set.
            //
            if (CxtionFlagIs(InCxtion,CXTION_FLAGS_HUNG_INIT_SYNC)) {
                ClearCxtionFlag(InCxtion, CXTION_FLAGS_HUNG_INIT_SYNC);
                CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, INITSYNC clear hung state");
            }


            UNLOCK_CXTION_TABLE(Replica);

            CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, RcsJoinCxtion call");
            RcsJoinCxtion(Cmd);
        } else {
            UNLOCK_CXTION_TABLE(Replica);

            CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, Cannot start join");
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        }
    }

}


VOID
InitSyncVvJoinDone(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    vvjoin is done join next one.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncVvJoinDone:"
    PREPLICA            Replica;
    PCXTION             InCxtion;
    PCOMM_PACKET        CPkt;

    Replica = RsReplica(Cmd);

    LOCK_CXTION_TABLE(Replica);

    //
    // Find and check the cxtion
    //
    InCxtion = GTabLookupNoLock(Replica->Cxtions, RsCxtion(Cmd)->Guid, NULL);

    if (!InCxtion) {
        return;
    }

    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, INITSYNC complete");

    //
    // This connection has completed initial sync.
    // It is OK to join this connection at will now.
    //
    if (CxtionFlagIs(InCxtion,CXTION_FLAGS_PAUSED)) {
        ClearCxtionFlag(InCxtion, CXTION_FLAGS_PAUSED);
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, INITSYNC Unpaused");
    }
    ClearCxtionFlag(InCxtion, CXTION_FLAGS_INIT_SYNC);

    //
    // If this is volatile connection unjoin our upstream partner.
    //
    //
    if (CxtionFlagIs(InCxtion, CXTION_FLAGS_VOLATILE)) {
        CPkt = CommBuildCommPkt(Replica, InCxtion, CMD_UNJOIN_REMOTE, NULL, NULL, NULL);
        SndCsSubmitCommPkt2(Replica, InCxtion, NULL, FALSE, CPkt);
    }

    UNLOCK_CXTION_TABLE(Replica);

    InitSyncCsSubmitTransfer(Cmd,CMD_INITSYNC_JOIN_NEXT);

}


DWORD
MainInitSyncCs(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for a thread serving the initial sync controller command server.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "MainInitSyncCs:"
    DWORD               WStatus = ERROR_SUCCESS;
    PCOMMAND_PACKET     Cmd;
    PFRS_QUEUE          IdledQueue;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)Arg;

    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &InitSyncCs);
    FrsThread->Exit = ThSupExitWithTombstone;

    DPRINT(4, "Initial Sync command server has started.\n");

    //
    // Try-Finally
    //
    try {

        //
        // Capture exception.
        //
        try {

            //
            // Pull entries off the queue and process them
            //
cant_exit_yet:
            while (Cmd = FrsGetCommandServerIdled(&InitSyncCs, &IdledQueue)) {

                switch (Cmd->Command) {

                case CMD_INITSYNC_START_SYNC:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    InitSyncStartSync(Cmd);
                    break;

                case CMD_INITSYNC_JOIN_NEXT:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    InitSyncJoinNext(Cmd);
                    break;

                case CMD_INITSYNC_START_JOIN:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    InitSyncStartJoin(Cmd);
                    break;

                case CMD_INITSYNC_VVJOIN_DONE:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    InitSyncVvJoinDone(Cmd);
                    break;

                case CMD_INITSYNC_KEEP_ALIVE:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    InitSyncKeepAlive(Cmd);
                    break;

                case CMD_INITSYNC_CHECK_PROGRESS:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    InitSyncCheckProgress(Cmd);
                    break;

                case CMD_INITSYNC_UNJOIN:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    REPLICA_STATE_TRACE(3, Cmd, RsReplica(Cmd), 0, "F, processing");
                    InitSyncCsDelCsSubmit(Cmd, CMD_INITSYNC_JOINED,10*1000);
                    break;

                case CMD_INITSYNC_JOINED:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    REPLICA_STATE_TRACE(3, Cmd, RsReplica(Cmd), 0, "F, processing");
                    InitSyncCsDelCsSubmit(Cmd, CMD_INITSYNC_COMM_TIMEOUT,10*1000);
                    break;

                case CMD_INITSYNC_COMM_TIMEOUT:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    REPLICA_STATE_TRACE(3, Cmd, RsReplica(Cmd), 0, "F, processing");
                    break;

                default:
                    DPRINT3(4, "InitSync: Received Cmd 0x%08x Command 0x%08x, TargetQueue 0x%08x\n", Cmd, Cmd->Command, Cmd->TargetQueue);
                    FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
                    break;
                }
                FrsRtlUnIdledQueue(IdledQueue);
            }
            //
            // Exit
            //
            FrsExitCommandServer(&InitSyncCs, FrsThread);
            goto cant_exit_yet;

        //
        // Get exception status.
        //
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(4, "MainInitSyncCs finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(4, "MainInitSyncCs terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        }
    }

    return (WStatus);
}


VOID
InitSyncCsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the Initial Sync Controller command server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "InitSyncCsInitialize:"
    //
    // Initialize the command server
    //

    CfgRegReadDWord(FKC_MAX_INITSYNCCS_THREADS, NULL, 0, &MaxInitSyncCsThreads);

    FrsInitializeCommandServer(&InitSyncCs, MaxInitSyncCsThreads, L"InitSyncCs", MainInitSyncCs);
}





VOID
ShutDownInitSyncCs(
    VOID
    )
/*++
Routine Description:
    Shutdown the Initial Sync Controller command server.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownInitSyncCs:"

    PVOID       Key;
    PREPLICA    Replica;

    //
    // Rundown all known queues. New queue entries will bounce.
    //
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Rundown InitSync cmd srv");
        if (Replica->InitSyncQueue != NULL) {
            FrsRunDownCommandServer(&InitSyncCs, Replica->InitSyncQueue);
        }
    }

    FrsRunDownCommandServer(&InitSyncCs, &InitSyncCs.Queue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\stage.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    stage.c

Abstract:
    Staging File Generator Command Server.

Author:
    Billy J. Fuller 05-Jun-1997

Environment
    User mode winnt

--*/



#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define DEBSUB  "STAGE:"

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>

//
// Retry times. The retry times must be coordinated with shutdown.
// The shutdown thread is waiting for the change orders to go
// through retry. Don't wait to long before pushing the change
// orders through retry.
//
#define STAGECS_RETRY_TIMEOUT   (5 * 1000)   // 5 seconds
//
// High and low water mark for staging area cleanup StageCsFreeStaging()
//
#define STAGECS_STAGE_LIMIT_HIGH (0.9)       // 90%
#define STAGECS_STAGE_LIMIT_LOW  (0.6)       // 60%

//
// Staging files are eligible to be replaced if they have not been accessed
// for the following number of milliseconds.
//
#define REPLACEMENT_ELIGIBILITY_TIME (5 * 60 * 1000)

//
// Struct for the Staging File Generator Command Server
//      Contains info about the queues and the threads
//
COMMAND_SERVER StageCs;
ULONG  MaxSTageCsThreads;

//
// Needed to manage the amount of disk space used for staging files
//
PGEN_TABLE  StagingAreaTable;
CRITICAL_SECTION StagingAreaCleanupLock;
DWORD       StagingAreaAllocated;

//
// Stage Management module.
//
PGEN_TABLE  NewStagingAreaTable;

//
// This indicates that the staging recovery is complete. Used to ignore any attempts
// to cleanup staging space during recovery.
//
BOOL StagingRecoveryComplete;

//
// Stage file state flags.
//
FLAG_NAME_TABLE StageFlagNameTable[] = {
    {STAGE_FLAG_RESERVE                  , "Reserve "          },
    {STAGE_FLAG_UNRESERVE                , "UnReserve "        },
    {STAGE_FLAG_FORCERESERVE             , "ForceResrv "       },
    {STAGE_FLAG_EXCLUSIVE                , "Exclusive "        },

    {STAGE_FLAG_RERESERVE                , "ReReserve "        },

    {STAGE_FLAG_STAGE_MANAGEMENT         , "StageManagement "  },

    {STAGE_FLAG_CREATING                 , "Creating "         },
    {STAGE_FLAG_DATA_PRESENT             , "DataPresent "      },
    {STAGE_FLAG_CREATED                  , "Created "          },
    {STAGE_FLAG_INSTALLING               , "Installing "       },

    {STAGE_FLAG_INSTALLED                , "Installed "        },
    {STAGE_FLAG_RECOVERING               , "Recovering "       },
    {STAGE_FLAG_RECOVERED                , "Recovered "        },

    {STAGE_FLAG_COMPRESSED               , "CompressedStage "  },
    {STAGE_FLAG_DECOMPRESSED             , "DecompressedStage "},
    {STAGE_FLAG_COMPRESSION_FORMAT_KNOWN , "KnownCompression " },

    {0, NULL}
};


//
// Variables used to maintain a moving average of suppressed COs over
// a 3 hour period.
//
ULONGLONG   SuppressedCOsInXHours;
ULONGLONG   LastSuppressedHour;
#define     SUPPRESSED_COS_AVERAGE_RANGE ((ULONGLONG)3L)
#define     SUPPRESSED_COS_AVERAGE_LIMIT ((ULONGLONG)15L)


DWORD
ChgOrdStealObjectId(
    IN     PWCHAR                   Name,
    IN     PVOID                    Fid,
    IN     PVOLUME_MONITOR_ENTRY    pVme,
    OUT    USN                      *Usn,
    IN OUT PFILE_OBJECTID_BUFFER    FileObjID
    );


DWORD
StuGenerateStage(
    IN PCHANGE_ORDER_COMMAND    Coc,
    IN PCHANGE_ORDER_ENTRY      Coe,
    IN BOOL                     FromPreExisting,
    IN MD5_CTX                  *Md5,
    OUT PULONGLONG              SizeGenerated,
    OUT GUID                    *CompressionFormatUsed
    );


DWORD
StageAcquire(
    IN     GUID         *CoGuid,
    IN     PWCHAR       Name,
    IN     ULONGLONG    FileSize,
    IN OUT PULONG       Flags,
    IN     DWORD        ReplicaNumber,
    OUT    GUID         *CompressionFormatUsed
    )
/*++
Routine Description:
    Acquire access to the staging file

Arguments:
    CoGuid
    Name
    FileSize
    Flags

Return Value:
    WIN32 STATUS
--*/
{
#undef DEBSUB
#define DEBSUB  "StageAcquire:"

    PSTAGE_ENTRY    SEntry;
    ULONG FileSizeInKb;
    WCHAR StageLimit[15];
    WCHAR HugeFileSize[15];
    //CHAR  TimeString[TIME_STRING_LENGTH];
    PCOMMAND_PACKET Cmd;

    //
    // Round the number of bytes to the next 8KB boundary
    //
    FileSizeInKb  = (ULONG)(((FileSize + ((8 * 1024) -1)) >> 13) << 3);

    STAGE_FILE_TRACE(3, CoGuid, Name, FileSize, Flags, "StageAcquire Entry");

    //
    // If the entry doesn't exist; done
    //
    GTabLockTable(StagingAreaTable);
    SEntry = GTabLookupNoLock(StagingAreaTable, CoGuid, NULL);
    //
    // No entry for file
    //
    if (!SEntry) {
        //
        // Permission to allocate an entry and reserve space
        //
        if (*Flags & STAGE_FLAG_RESERVE) {

            //
            // no space (ignore space check if recovering staging areas
            // at startup)
            //
            if (!(*Flags & STAGE_FLAG_FORCERESERVE) &&
                ((FileSizeInKb + StagingAreaAllocated) > StagingLimitInKb)) {

                GTabUnLockTable(StagingAreaTable);

                if (FileSizeInKb >= StagingLimitInKb) {
                    DPRINT3(0, "++ WARN - %ws is TOO LARGE for staging area (%d KB > %d KB)\n",
                            Name, FileSizeInKb, StagingLimitInKb);

                    //
                    // Convert DWORD to strings
                    //
                    _itow(StagingLimitInKb, StageLimit, 10);
                    _itow(FileSizeInKb, HugeFileSize, 10);

                    //
                    // Print the warning to the EventLog
                    //
                    EPRINT2(EVENT_FRS_HUGE_FILE, StageLimit, HugeFileSize);
                    STAGE_FILE_TRACE(0, CoGuid, Name, FileSize, Flags, "ERROR - HUGE FILE");

                    //
                    // Reset the StagingLimitInKb value by reading it
                    // from the registry. This is done under the assumption
                    // that the user after looking at the EventLog message
                    // (above) will increase the staging limit value in the
                    // registry
                    //
                    CfgRegReadDWord(FKC_STAGING_LIMIT, NULL, 0, &StagingLimitInKb);
                    DPRINT1(4, "++ Staging limit from registry: %d KB\n", StagingLimitInKb);

                } else {

                    //
                    // Submit a command to the stage command server to cleanup
                    // staging space by deleting old staging files if we are at high water mark.
                    // Do not do this if it is disabled by registry key.
                    //

                    if (DebugInfo.ReclaimStagingSpace && (StagingRecoveryComplete == TRUE)) {
                        Cmd = FrsAllocCommand(&StageCs.Queue, CMD_FREE_STAGING);
                        StSpaceRequested(Cmd) = FileSizeInKb;
                        FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
                        FrsStageCsSubmitTransfer(Cmd, CMD_FREE_STAGING);
                        DPRINT(4, "++ Trigerring cleanup of staging areas\n");
                    }

                    DPRINT2(0, "++ WARN - Staging area is too full for %ws (need %d KB)\n",
                            Name, (FileSizeInKb + StagingAreaAllocated) - StagingLimitInKb);
                    //
                    // Convert DWORD to strings
                    //
                    _itow(StagingLimitInKb, StageLimit, 10);
                    //
                    // Print the warning to the EventLog
                    //
                    EPRINT1(EVENT_FRS_STAGING_AREA_FULL, StageLimit);
                    STAGE_FILE_TRACE(0, CoGuid, Name, FileSize, Flags, "ERROR - STAGING AREA FULL");

                    //
                    // Reset the StagingLimitInKb value by reading it
                    // from the registry. This is done under the assumption
                    // that the user after looking at the EventLog message
                    // (above) will increase the staging limit value in the
                    // registry
                    //
                    CfgRegReadDWord(FKC_STAGING_LIMIT, NULL, 0, &StagingLimitInKb);
                    DPRINT1(4, "++ Staging limit from registry: %d KB\n", StagingLimitInKb);

                }
                STAGE_FILE_TRACE(0, CoGuid, Name, FileSize, Flags, "ERROR - DISK_FULL");
                return ERROR_DISK_FULL;
            }
            StagingAreaAllocated += FileSizeInKb;

            //
            // Submit a command to the stage command server to cleanup
            // staging space by deleting old staging files if we are at high water mark.
            // Do not do this if it is disabled by registry key.
            //

            if (DebugInfo.ReclaimStagingSpace && (StagingRecoveryComplete == TRUE) &&
                StagingAreaAllocated > STAGECS_STAGE_LIMIT_HIGH * StagingLimitInKb) {
                Cmd = FrsAllocCommand(&StageCs.Queue, CMD_FREE_STAGING);
                StSpaceRequested(Cmd) = 0;
                FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
                FrsStageCsSubmitTransfer(Cmd, CMD_FREE_STAGING);
                DPRINT(4, "++ Trigerring cleanup of staging areas\n");
            }

            //
            // Set the Staging space in use and free counters
            //
            PM_SET_CTR_SERVICE(PMTotalInst, SSInUseKB, StagingAreaAllocated);
            if (StagingAreaAllocated >= StagingLimitInKb) {
                PM_SET_CTR_SERVICE(PMTotalInst, SSFreeKB, 0);
            }
            else {
                PM_SET_CTR_SERVICE(PMTotalInst, SSFreeKB, (StagingLimitInKb - StagingAreaAllocated));
            }

            //
            // Insert new entry
            //
            SEntry = FrsAlloc(sizeof(STAGE_ENTRY));
            COPY_GUID(&SEntry->FileOrCoGuid, CoGuid);

            SEntry->FileSizeInKb = FileSizeInKb;

            //
            // Replica number is needed to get to the replica structure from
            // the stage entry.
            //
            SEntry->ReplicaNumber = ReplicaNumber;

            GTabInsertEntryNoLock(StagingAreaTable, SEntry, &SEntry->FileOrCoGuid, NULL);
        } else {
            GTabUnLockTable(StagingAreaTable);
            STAGE_FILE_TRACE(3, CoGuid, Name, FileSize, Flags, "FILE_NOT_FOUND");
            return ERROR_FILE_NOT_FOUND;
        }
    }
    //
    // Can't acquire file exclusively
    //
    if (*Flags & STAGE_FLAG_EXCLUSIVE) {
        if (SEntry->ReferenceCount) {
            GTabUnLockTable(StagingAreaTable);
            STAGE_FILE_TRACE(3, CoGuid, Name, FileSize, Flags, "Cannot acquire exclusive-1");
            return ERROR_SHARING_VIOLATION;
        }
    } else {
        if (SEntry->Flags & STAGE_FLAG_EXCLUSIVE) {
            GTabUnLockTable(StagingAreaTable);
            STAGE_FILE_TRACE(3, CoGuid, Name, FileSize, Flags, "Cannot acquire exclusive-2");
            return ERROR_SHARING_VIOLATION;
        }
    }

    //
    // Update the last access time for the entry.
    //
    if (!(*Flags & STAGE_FLAG_STAGE_MANAGEMENT)) {
        GetSystemTimeAsFileTime(&SEntry->LastAccessTime);
        //FileTimeToString(&SEntry->LastAccessTime, TimeString);
        STAGE_FILE_TRACE(3, CoGuid, Name, FileSize, Flags, "Last access time update");
    }

    //
    // Return the flags
    //
    ++SEntry->ReferenceCount;
    SEntry->Flags |= *Flags & STAGE_FLAG_EXCLUSIVE;
    *Flags = SEntry->Flags;

    //
    // Return the compression format.
    //
    if (CompressionFormatUsed != NULL) {
        COPY_GUID(CompressionFormatUsed, &SEntry->CompressionGuid);
    }

    GTabUnLockTable(StagingAreaTable);

    STAGE_FILE_TRACE(5, CoGuid, Name, FileSize, Flags, "Stage Acquired");

    return ERROR_SUCCESS;
}


VOID
StageRelease(
    IN GUID         *CoGuid,
    IN PWCHAR       Name,
    IN ULONG        Flags,
    IN PULONGLONG   FileSize,
    IN FILETIME     *LastAccessTime,
    IN GUID         *CompressionFormatUsed
    )
/*++
Routine Description:
    Release access to the staging file

Arguments:
    CoGuid
    Name
    Flags
    FileSize - For ReReserving

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StageRelease:"
    PSTAGE_ENTRY  SEntry;
    ULONGLONG SOFGInKB; // Size OF File Generated In Kilo Bytes
    ULONGLONG TFileSize;

    TFileSize = (FileSize == NULL) ? QUADZERO : *FileSize;

    //
    // If the entry doesn't exist; done
    //
    GTabLockTable(StagingAreaTable);
    SEntry = GTabLookupNoLock(StagingAreaTable, CoGuid, NULL);
    if (!SEntry) {
        GTabUnLockTable(StagingAreaTable);
        STAGE_FILE_TRACE(3, CoGuid, Name, TFileSize, &Flags, "No entry in stage table");
        return;
    }

    STAGE_FILE_TRACE(3, CoGuid, Name, TFileSize, &Flags, "Stage Release Entry");

    //
    // If the RERESERVE bit in the flags is set, reset the FileSize, Compression info
    // and Staging area allocated values
    //
    if (Flags & STAGE_FLAG_RERESERVE) {
        if (FileSize) {
            STAGE_FILE_TRACE(5, CoGuid, Name, TFileSize, &Flags, "Stage Release Re-reserve");

            //
            // Calculate the size of file generated in KB
            //
            SOFGInKB = (((*FileSize)+1023)/1024);
            //
            // Reset the StagingAreaAllocated value
            // Round it of to the next KB boundary
            //
            StagingAreaAllocated -= SEntry->FileSizeInKb;
            StagingAreaAllocated += (ULONG)SOFGInKB;
            //
            // Reset the SEntry->FileSizeInKb value
            // Round it of to the next KB boundary
            //
            SEntry->FileSizeInKb = (ULONG)SOFGInKB;

        }

        //
        // Update the last access time if provided.
        //
        if (LastAccessTime != NULL) {
            COPY_TIME(&SEntry->LastAccessTime, LastAccessTime);
        }
    }

    //
    // If the compression format is provided then copy it over.
    //
    if (CompressionFormatUsed != NULL) {
        COPY_GUID(&SEntry->CompressionGuid, CompressionFormatUsed);
    }

    //
    // No entry for file
    //
    FRS_ASSERT(SEntry->ReferenceCount > 0);
    --SEntry->ReferenceCount;
    SEntry->Flags |= Flags & ~(STAGE_FLAG_ATTRIBUTE_MASK);

    if (SEntry->ReferenceCount == 0) {
        ClearFlag(SEntry->Flags, STAGE_FLAG_EXCLUSIVE);
    }
    //
    // Remove the entry
    //
    if (Flags & STAGE_FLAG_UNRESERVE) {
        FRS_ASSERT(SEntry->FileSizeInKb <= StagingAreaAllocated);
        FRS_ASSERT(!SEntry->ReferenceCount);
        StagingAreaAllocated -= SEntry->FileSizeInKb;
        GTabDeleteNoLock(StagingAreaTable, CoGuid, NULL, FrsFree);
    }

    //
    // Set the Staging space in use and free counters
    //
    PM_SET_CTR_SERVICE(PMTotalInst, SSInUseKB, StagingAreaAllocated);
    if (StagingAreaAllocated >= StagingLimitInKb) {
        PM_SET_CTR_SERVICE(PMTotalInst, SSFreeKB, 0);
    }
    else {
        PM_SET_CTR_SERVICE(PMTotalInst, SSFreeKB, (StagingLimitInKb - StagingAreaAllocated));
    }

    GTabUnLockTable(StagingAreaTable);


    STAGE_FILE_TRACE(5, CoGuid, Name, TFileSize, &Flags, "Stage Release Done");

}


VOID
StageReleaseNotRecovered(
    )
/*++
Routine Description:
    Release all of the entries that are not recovered

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StageReleaseNotRecovered:"
    PVOID           Key;
    PSTAGE_ENTRY    SEntry;
    PSTAGE_ENTRY    NextSEntry;

    //
    // Unreserve the entries that weren't recovered at startup
    //
    GTabLockTable(StagingAreaTable);
    Key = NULL;
    for (SEntry = GTabNextDatumNoLock(StagingAreaTable, &Key);
         SEntry;
         SEntry = NextSEntry) {
        NextSEntry = GTabNextDatumNoLock(StagingAreaTable, &Key);
        if (SEntry->Flags & STAGE_FLAG_RECOVERED) {
            continue;
        }
        FRS_ASSERT(SEntry->FileSizeInKb <= StagingAreaAllocated);
        FRS_ASSERT(!SEntry->ReferenceCount);
        StagingAreaAllocated -= SEntry->FileSizeInKb;
        GTabDeleteNoLock(StagingAreaTable, &SEntry->FileOrCoGuid, NULL, FrsFree);
    }
    GTabUnLockTable(StagingAreaTable);
}



VOID
StageReleaseAll(
    )
/*++
Routine Description:
    Release all of the entries

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StageReleaseAll:"
    PVOID         Key;
    PSTAGE_ENTRY  SEntry;

    //
    // Unreserve the entries that weren't recovered at startup
    //
    GTabLockTable(StagingAreaTable);
    Key = NULL;
    while (SEntry = GTabNextDatumNoLock(StagingAreaTable, &Key)) {
        Key = NULL;
        GTabDeleteNoLock(StagingAreaTable, &SEntry->FileOrCoGuid, NULL, FrsFree);
    }
    StagingAreaAllocated = 0;
    GTabUnLockTable(StagingAreaTable);
}


BOOL
StageDeleteFile(
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PREPLICA Replica,
    IN BOOL Acquire
    )
/*++
Routine Description:
    Delete the staging file and unreserve space in the staging area.

Arguments:
    Coc
    Replica - Replica set that this staging file belongs to.
    Acquire - acquire access?

Return Value:
    TRUE    - files have been deleted
    FALSE   - Not
--*/
{
#undef DEBSUB
#define DEBSUB  "StageDeleteFile:"

    DWORD   WStatus1 = ERROR_GEN_FAILURE;
    DWORD   WStatus2 = ERROR_GEN_FAILURE;
    ULONG   Flags;
    DWORD   WStatus;
    PWCHAR  StagePath;
    PREPLICA NewReplica;
    GUID    *CoGuid = &Coc->ChangeOrderGuid;

    //
    // Acquire exclusive access to the staging file if requested
    //
    if (Acquire) {
        Flags = STAGE_FLAG_EXCLUSIVE;
        WStatus = StageAcquire(CoGuid, Coc->FileName, QUADZERO, &Flags, 0, NULL);
        //
        // Someone has deleted the staging file; no problem
        //
        if (WIN_NOT_FOUND(WStatus)) {
            CHANGE_ORDER_COMMAND_TRACE(5, Coc, "Deleted staging file space");
            Acquire = FALSE;
        } else if (!WIN_SUCCESS(WStatus)) {
            CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Can't acquire stage");
            Acquire = FALSE;
        }
    }

    //
    // If the replica is passed in then use that one else find it from the
    // list of replicas. A replica is passed in for stopped replicas or the ones
    // on fault list.
    //
    if (Replica != NULL) {
        NewReplica= Replica;
    } else {
        NewReplica = ReplicaIdToAddr(Coc->NewReplicaNum);
    }
    //
    // Delete the pre-staging file
    //
    if (NewReplica != NULL) {
        StagePath = StuCreStgPath(NewReplica->Stage, CoGuid, STAGE_GENERATE_PREFIX);

        WStatus1 = FrsDeleteFile(StagePath);
        DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus1);

        FrsFree(StagePath);

        //
        // There could be a compressed partial staging file too.
        //
        //if (Flags & STAGE_FLAG_COMPRESSED) {
            StagePath = StuCreStgPath(NewReplica->Stage, CoGuid, STAGE_GENERATE_COMPRESSED_PREFIX);

            WStatus1 = FrsDeleteFile(StagePath);
            DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus1);

            FrsFree(StagePath);
        //}

        //
        // Delete the final staging file
        //
        StagePath = StuCreStgPath(NewReplica->Stage, CoGuid, STAGE_FINAL_PREFIX);

        WStatus2 = FrsDeleteFile(StagePath);
        DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus2);

        FrsFree(StagePath);

        //
        // There could be a compressed staging file too.
        //
        //if (Flags & STAGE_FLAG_COMPRESSED) {
            StagePath = StuCreStgPath(NewReplica->Stage, CoGuid, STAGE_FINAL_COMPRESSED_PREFIX);

            WStatus2 = FrsDeleteFile(StagePath);
            DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus2);

            FrsFree(StagePath);

        //}

    }

    if (Acquire) {
        StageRelease(CoGuid, Coc->FileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
    }
    //
    // Done
    //
    if (WIN_SUCCESS(WStatus1) && WIN_SUCCESS(WStatus2)) {
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Deleted staging file");
        return TRUE;
    } else {
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Can't delete stage");
        return FALSE;
    }
}


BOOL
StageDeleteFileByGuid(
    IN GUID     *Guid,
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Delete the staging file and unreserve space in the staging area.

Arguments:
    Guid
    Replica - Replica set that this staging file belongs to.

Return Value:
    TRUE    - files have been deleted
    FALSE   - Not
--*/
{
#undef DEBSUB
#define DEBSUB  "StageDeleteFileByGuid:"

    DWORD   WStatus1 = ERROR_GEN_FAILURE;
    DWORD   WStatus2 = ERROR_GEN_FAILURE;
    ULONG   Flags;
    DWORD   WStatus;
    PWCHAR  StagePath;

    //
    // Acquire exclusive access to the staging file.
    // STAGE_FLAG_STAGE_MANAGEMENT ensures that we do not update
    // last access time when we acquire staging entry for deletion.
    //
    Flags = STAGE_FLAG_EXCLUSIVE | STAGE_FLAG_STAGE_MANAGEMENT;
    WStatus = StageAcquire(Guid, L"NTFRS_FakeName", QUADZERO, &Flags, 0, NULL);
    //
    // Someone has deleted the staging file; no problem
    //
    if (WIN_NOT_FOUND(WStatus)) {
        return FALSE;
    } else if (!WIN_SUCCESS(WStatus)) {
        DPRINT(5, "Can't acquire stage for deletion.\n");
        return FALSE;
    }

    //
    // Delete the pre-staging file
    //
    if (Replica != NULL) {
        StagePath = StuCreStgPath(Replica->Stage, Guid, STAGE_GENERATE_PREFIX);

        WStatus1 = FrsDeleteFile(StagePath);
        DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus1);

        FrsFree(StagePath);

        //
        // There could be a compressed partial staging file too.
        //
        //if (Flags & STAGE_FLAG_COMPRESSED) {
            StagePath = StuCreStgPath(Replica->Stage, Guid, STAGE_GENERATE_COMPRESSED_PREFIX);

            WStatus1 = FrsDeleteFile(StagePath);
            DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus1);

            FrsFree(StagePath);
        //}

        //
        // Delete the final staging file
        //
        StagePath = StuCreStgPath(Replica->Stage, Guid, STAGE_FINAL_PREFIX);

        WStatus2 = FrsDeleteFile(StagePath);
        DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus2);

        FrsFree(StagePath);

        //
        // There could be a compressed staging file too.
        //
        //if (Flags & STAGE_FLAG_COMPRESSED) {
            StagePath = StuCreStgPath(Replica->Stage, Guid, STAGE_FINAL_COMPRESSED_PREFIX);

            WStatus2 = FrsDeleteFile(StagePath);
            DPRINT1_WS(0, "++ ERROR - Failed to delete staging file %ws;", StagePath, WStatus2);

            FrsFree(StagePath);

        //}

    }

    StageRelease(Guid, L"NTFRS_FakeName", STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);

    //
    // Done
    //
    if (WIN_SUCCESS(WStatus1) && WIN_SUCCESS(WStatus2)) {
        DPRINT(5, "Deleted staging file.\n");
        return TRUE;
    } else {
        DPRINT(5, "Error deleting staging file.\n");
        return FALSE;
    }
}


BOOL
FrsDoesCoAlterNameSpace(
    IN PCHANGE_ORDER_COMMAND Coc
    )
/*++
Routine Description:
    Does this change order alter the namespace of the replicated
    directory? In other words; create, delete, or rename.

Arguments:
    Coc

Return Value:
    TRUE  - Alters namespace.
    FALSE - Not.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDoesCoAlterNameSpace:"
    ULONG   LocationCmd;

    //
    // Based on the location info, is the namespace altered?
    //
    if ((Coc->Flags & CO_FLAG_LOCATION_CMD)) {
        LocationCmd = GET_CO_LOCATION_CMD(*Coc, Command);
        if (LocationCmd != CO_LOCATION_NO_CMD) {
            return TRUE;
        }
    }

    //
    // Based on the content info, is the namespace altered?
    //
    if ((Coc->Flags & CO_FLAG_CONTENT_CMD) &&
        (Coc->ContentCmd & CO_LOCATION_MASK)) {
            return TRUE;
    }

    //
    // Namespace is not altered
    //
    return FALSE;
}


BOOL
FrsDoesCoNeedStage(
    IN PCHANGE_ORDER_COMMAND Coc
    )
/*++
Routine Description:
    Check if the change order requires a staging file.

Arguments:
    Coc

Return Value:
    TRUE  - Change order needs a staging file
    FALSE - No staging file needed
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsDoesCoNeedStage:"
    //
    // Based on the location info, is a staging file needed?
    //
    if (Coc->Flags & CO_FLAG_LOCATION_CMD)
        switch (GET_CO_LOCATION_CMD(*Coc, Command)) {
            case CO_LOCATION_CREATE:
            case CO_LOCATION_MOVEIN:
            case CO_LOCATION_MOVEIN2:
                //
                // Definitely YES
                //
                return TRUE;
            case CO_LOCATION_DELETE:
            case CO_LOCATION_MOVEOUT:
                //
                // Definitely NO
                //
                return FALSE;
            case CO_LOCATION_MOVERS:
            case CO_LOCATION_MOVEDIR:
            default:
                //
                // Definitely MAYBE; check the "usn reason"
                //
                break;
        }

    //
    // Based on the content info, is a staging file needed?
    //
    if (Coc->Flags & CO_FLAG_CONTENT_CMD &&
        Coc->ContentCmd & CO_CONTENT_NEED_STAGE)
            return TRUE;

    //
    // No staging file is needed
    //
    return FALSE;
}


VOID
StageCsCreateStage(
    IN PCOMMAND_PACKET  Cmd,
    IN BOOL             JustCheckOid
    )
/*++
Routine Description:
    Create and populate the staging file

Arguments:
    Cmd
    JustCheckOid    - There are no outbound partners so don't propagate.
                      But make sure a user hasn't inadvertantly altered
                      our object id. If so, reset it.
Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StageCsCreateStage:"

    ULONGLONG   SizeGenerated = 0;
    FILE_OBJECTID_BUFFER    FileObjId;
    MD5_CTX Md5;

    ULONG   Flags;
    ULONG   LocationCmd;
    DWORD   WStatus = ERROR_SUCCESS;
    BOOL    OidChange;
    BOOL    JustOidChange;
    BOOL    DeleteCo;

    PDATA_EXTENSION_CHECKSUM       CocDataChkSum = NULL;
    PCHANGE_ORDER_RECORD_EXTENSION CocExt;


    PCHANGE_ORDER_ENTRY     Coe = RsCoe(Cmd);
    PCHANGE_ORDER_COMMAND   Coc = RsCoc(Cmd);

    GUID    *CoGuid = &Coc->ChangeOrderGuid;
    GUID    CompressionFormatUsed;

    PREPLICA_THREAD_CTX            RtCtx      = Coe->RtCtx;
    PTABLE_CTX                     IDTableCtx = NULL;
    PIDTABLE_RECORD                IDTableRec = NULL;
    PIDTABLE_RECORD_EXTENSION      IdtExt     = NULL;
    PDATA_EXTENSION_CHECKSUM       IdtDataChkSum = NULL;
    ULONGLONG                      CurrentTime;
    ULONGLONG                      CurrentHour;
    WCHAR                          LimitWStr[32];
    WCHAR                          RangeWStr[32];

    ULONG                          IdtAttrs;
    ULONG                          CocAttrs;

#ifndef DISABLE_JRNL_CXTION_RETRY
    //
    // The jrnlcxtion is shutting down; kick the change order through retry
    //
    if (Coe->Cxtion &&
        Coe->Cxtion->JrnlCxtion &&
        !CxtionStateIs(Coe->Cxtion, CxtionStateJoined)) {
        CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retry Unjoined");
        RcsSubmitTransferToRcs(Cmd, CMD_RETRY_STAGE);
        return;
    }
#endif DISABLE_JRNL_CXTION_RETRY

    CHANGE_ORDER_TRACE(3, Coe, "Stage Gen");

    LocationCmd = GET_CO_LOCATION_CMD(Coe->Cmd, Command);

    DeleteCo = (LocationCmd == CO_LOCATION_DELETE) ||
               (LocationCmd == CO_LOCATION_MOVEOUT);

    //
    // Confirm that this file has a supported reparse point tag.  Catches
    // any change of the reparse tag while this CO was waiting to retry.
    //
    WStatus = ERROR_SUCCESS;

    if (Coc->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
        WStatus = FrsCheckReparse(Coc->FileName,
                                  (PULONG)&Coe->FileReferenceNumber,
                                  FILE_ID_LENGTH,
                                  Coe->NewReplica->pVme->VolumeHandle);
    }

    //
    // Hammer the object id on a new local file or hammer the oid
    // back to its "correct" value if the user changed it.
    // We must maintain our own object id on the file for replication
    // to work.
    //
    // Is this an object id change? If so, special case the change
    // order by simply hammering the FRS object id back onto the file.
    // This breaks link tracking but keeps replication going.
    //
    OidChange = CO_FLAG_ON(Coe, CO_FLAG_CONTENT_CMD)            &&
                (Coc->ContentCmd & USN_REASON_OBJECT_ID_CHANGE) &&
                !DeleteCo;

    JustOidChange = OidChange                                   &&
                    (LocationCmd == CO_LOCATION_NO_CMD)         &&
                    !(Coc->ContentCmd & ~USN_REASON_OBJECT_ID_CHANGE);
    //
    // A new local file or someone altered our object id!
    //
    if (WIN_SUCCESS(WStatus) &&
        (CO_FLAG_ON(Coe, CO_FLAG_LOCALCO) &&
        (CO_NEW_FILE(LocationCmd) || OidChange))) {

        //
        // Put the file's guid into the file's object id.  If the object id
        // on the file does not match the file's guid, then hammer the object
        // id to the file's guid and reset the attendent bits in the object
        // id buffer.
        //
        CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Steal OID");
        ZeroMemory(&FileObjId, sizeof(FileObjId));
        COPY_GUID(FileObjId.ObjectId, &Coc->FileGuid);
        WStatus = ChgOrdStealObjectId(Coc->FileName,
                                      (PULONG)&Coe->FileReferenceNumber,
                                      Coe->NewReplica->pVme,
                                      &Coc->FileUsn,
                                      &FileObjId);
    } else {
        WStatus = ERROR_SUCCESS;
    }

    //
    // If this isn't a simple oid change and we have successfully
    // processed the source file's object id then generate the
    // staging file (if needed)
    //
    if (!JustOidChange && WIN_SUCCESS(WStatus) && !JustCheckOid) {
        //
        // Copy the user file into the staging area after reserving space
        //
        if (FrsDoesCoNeedStage(Coc)) {
            Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;
            if (CoCmdIsDirectory(Coc)) {
                Flags |= STAGE_FLAG_FORCERESERVE;
            }

            WStatus = StageAcquire(CoGuid, Coc->FileName, Coc->FileSize, &Flags, Coe->NewReplica->ReplicaNumber, NULL);

            if (WIN_SUCCESS(WStatus)) {
                WStatus = StuGenerateStage(Coc, Coe, FALSE, &Md5, &SizeGenerated, &CompressionFormatUsed);
                if (WIN_SUCCESS(WStatus)) {

                    //
                    // If the Change Order has a file checksum, save it in theIDTable Record.
                    //
                    CocExt = Coc->Extension;
                    CocDataChkSum = DbsDataExtensionFind(CocExt, DataExtend_MD5_CheckSum);

                    if (CocDataChkSum != NULL) {
                        if (CocDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                            DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                                    CocDataChkSum->Prefix.Size);
                            DbsDataInitCocExtension(CocExt);
                            CocDataChkSum = &CocExt->DataChecksum;
                        }


                        DPRINT4(4, "OLD COC MD5: %08x %08x %08x %08x\n",
                                *(((ULONG *) &CocDataChkSum->Data[0])),
                                *(((ULONG *) &CocDataChkSum->Data[4])),
                                *(((ULONG *) &CocDataChkSum->Data[8])),
                                *(((ULONG *) &CocDataChkSum->Data[12])));

                    } else {
                        //
                        // Not found.  Init the extension buffer.
                        //
                        DPRINT(4, "OLD COC MD5: Not present\n");
                        DbsDataInitCocExtension(CocExt);
                        CocDataChkSum = &CocExt->DataChecksum;
                    }

                    //
                    // Save the MD5 checksum in the change order.
                    //
                    CopyMemory(CocDataChkSum->Data, Md5.digest, MD5DIGESTLEN);

                    if (!IS_GUID_ZERO(&CompressionFormatUsed)) {
                        //
                        // A compressed staging file was generated. Set the appropriate
                        // flags and the compression format guid in the STATE_ENTRY
                        // structure.
                        //
                        StageRelease(CoGuid, Coc->FileName,
                                     STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_CREATED |
                                     STAGE_FLAG_INSTALLED    | STAGE_FLAG_RERESERVE |
                                     STAGE_FLAG_COMPRESSED   | STAGE_FLAG_COMPRESSION_FORMAT_KNOWN,
                                     &SizeGenerated,
                                     NULL,
                                     &CompressionFormatUsed);
                    } else {
                        StageRelease(CoGuid, Coc->FileName,
                                     STAGE_FLAG_DATA_PRESENT | STAGE_FLAG_CREATED |
                                     STAGE_FLAG_INSTALLED    | STAGE_FLAG_RERESERVE,
                                     &SizeGenerated,
                                     NULL,
                                     NULL);
                    }

                    //
                    // Increment the staging files generated counter
                    //
                    PM_INC_CTR_REPSET(Coe->NewReplica, SFGenerated, 1);
                } else {
                    StageDeleteFile(Coc, NULL, FALSE);
                    StageRelease(CoGuid, Coc->FileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
                    //
                    // Increment the staging files generated with error counter
                    //
                    PM_INC_CTR_REPSET(Coe->NewReplica, SFGeneratedError, 1);
                }
            }
        } else {
            //
            // Don't need a stage file for this CO (e.g. delete or moveout)
            //
            WStatus = ERROR_SUCCESS;
        }
    }

    //
    // The "Suppress Identical Updates To Files" key controls whether FRS tries to identify and
    // suppress updates that do not change the content (everything that is used to
    // calculate the MD5 and attributes) of the file.
    //
    // Check if the the new MD5 on file is same as the one in idtable. If it is then
    // we can safely abort this CO as the change to the file was basically a NO-OP
    // This will help reducing excessive replication caused by periodically stamping
    // "same" ACLs on files. (Loss of user rights in security policy)
    //
    if (DebugInfo.SuppressIdenticalUpdt &&
        (FrsDoesCoAlterNameSpace(Coc) == FALSE) &&
        (CoCmdIsDirectory(Coc) == FALSE) &&
        (CocDataChkSum != NULL)) {

        DPRINT4(4, "NEW COC MD5: %08x %08x %08x %08x\n",
                *(((ULONG *) &CocDataChkSum->Data[0])),
                *(((ULONG *) &CocDataChkSum->Data[4])),
                *(((ULONG *) &CocDataChkSum->Data[8])),
                *(((ULONG *) &CocDataChkSum->Data[12])));

        if (RtCtx != NULL) {
           IDTableCtx = &RtCtx->IDTable;
           if (IDTableCtx != NULL) {
               IDTableRec = (PIDTABLE_RECORD)IDTableCtx->pDataRecord;
               if (IDTableRec != NULL) {

                   IdtAttrs = IDTableRec->FileAttributes &
                              ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL);
                   CocAttrs = Coc->FileAttributes &
                               ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL);

                   if (IdtAttrs == CocAttrs) {
                       IdtExt = &IDTableRec->Extension;
                       IdtDataChkSum = DbsDataExtensionFind(IdtExt, DataExtend_MD5_CheckSum);

                       if (IdtDataChkSum != NULL) {
                           if (IdtDataChkSum->Prefix.Size != sizeof(DATA_EXTENSION_CHECKSUM)) {
                               DPRINT1(0, "<MD5_CheckSum Size (%08x) invalid>\n",
                                       IdtDataChkSum->Prefix.Size);
                           }

                           DPRINT4(4, "CUR IDT MD5: %08x %08x %08x %08x\n",
                                   *(((ULONG *) &IdtDataChkSum->Data[0])),
                                   *(((ULONG *) &IdtDataChkSum->Data[4])),
                                   *(((ULONG *) &IdtDataChkSum->Data[8])),
                                   *(((ULONG *) &IdtDataChkSum->Data[12])));

                           if (MD5_EQUAL(CocDataChkSum->Data, IdtDataChkSum->Data)) {


                               //
                               // Keep a 3 hour moving average and calculate instances/hr.
                               //

                               DPRINT2(4, "LastSuppressedHour = %08x %08x, SuppressedCOsInXHours = %08x %08x\n",
                                       PRINTQUAD(LastSuppressedHour), PRINTQUAD(SuppressedCOsInXHours));

                               GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);
                               CurrentHour = CurrentTime / CONVERT_FILETIME_TO_HOURS;

                               SuppressedCOsInXHours = (SuppressedCOsInXHours // Previous value
                                                       // only keep count of COs in the range of interest.
                                                       - min(CurrentHour - LastSuppressedHour,SUPPRESSED_COS_AVERAGE_RANGE)
                                                       * (SuppressedCOsInXHours/SUPPRESSED_COS_AVERAGE_RANGE)
                                                       // add this instance.
                                                       + 1);

                               LastSuppressedHour = CurrentHour;

                               DPRINT2(4, "LastSuppressedHour = %08x %08x, SuppressedCOsInXHours = %08x %08x\n",
                                       PRINTQUAD(LastSuppressedHour), PRINTQUAD(SuppressedCOsInXHours));

                               //
                               // If the average is > SUPPRESSED_COS_AVERAGE_LIMIT then print an eventlog message.
                               //

                               if ((SuppressedCOsInXHours / SUPPRESSED_COS_AVERAGE_RANGE) >= SUPPRESSED_COS_AVERAGE_LIMIT) {

                                   _snwprintf(LimitWStr, 32, L"%d", (ULONG)(SUPPRESSED_COS_AVERAGE_LIMIT));
                                   _snwprintf(RangeWStr, 32, L"%d", (ULONG)(SUPPRESSED_COS_AVERAGE_RANGE));

                                   EPRINT2(EVENT_FRS_FILE_UPDATES_SUPPRESSED, LimitWStr, RangeWStr);
                               }

                               CHANGE_ORDER_TRACE(3, Coe, "Aborting CO, does not change MD5 and Attrib");

                               SET_COE_FLAG(Coe, COE_FLAG_STAGE_ABORTED);
                               ChgOrdInboundRetired(Coe);
                               RsCoe(Cmd) = NULL;
                               FrsCompleteCommand(Cmd, WStatus);
                               return;
                           }
                       }
                   }
               }
           }
        }
    }

    //
    // Deleted file
    //
    if (WIN_NOT_FOUND(WStatus)) {
        CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retire Deleted");
        //
        // Billy thinks the following was added to handle a morphgen 50 assert.
        // Removing it for now because this is local CO and if the file is not
        // there and we need it to make the staging file then we will never be
        // able to generate the stage file so we are done.  Note that delete
        // and moveout COs won't come thru here because code above sets the
        // status to ERROR_SUCCESS.  This just leaves rename MorphGenCos and we
        // need a stage file for them.  If the user has deleted the file out from
        // under us then we will see a Delete coming for it later.  If it was
        // a DLD case and the dir create failed to fetch the stage file since
        // it was deleted upstream then we also come thru here for the rename
        // MorphGenCo follower.  We need to abort that here because only now
        // do we know the target file is absent.
        //
        // if (!CO_FLAG_ON(Coe, CO_FLAG_MORPH_GEN)) {
        SET_COE_FLAG(Coe, COE_FLAG_STAGE_ABORTED);
        //}
        SET_COE_FLAG(Coe, COE_FLAG_STAGE_DELETED);
        ChgOrdInboundRetired(Coe);
        RsCoe(Cmd) = NULL;
        FrsCompleteCommand(Cmd, WStatus);
        return;
    }
    //
    // Retriable problem
    //
    if (WIN_RETRY_STAGE(WStatus)) {
        //
        // Shutting down; Let the Replica Command Server handle it.
        //
        if (FrsIsShuttingDown) {
            CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retry Shutdown");
            RcsSubmitTransferToRcs(Cmd, CMD_RETRY_STAGE);
        //
        // Haven't retried; wait a bit
        //
        } else if (!RsTimeout(Cmd)) {
            CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retry Cmd");
            RsTimeout(Cmd) = STAGECS_RETRY_TIMEOUT;
            FrsDelCsSubmitSubmit(&StageCs, Cmd, RsTimeout(Cmd));
        //
        // Retried and directory; retry again if this is a remote CO.
        //
        } else if (CoCmdIsDirectory(Coc) && !CO_FLAG_ON(Coe, CO_FLAG_LOCALCO)) {
            CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retry Transfer");
            RcsSubmitTransferToRcs(Cmd, CMD_RETRY_STAGE);
        //
        // Retried and file or local directory; send co through retry
        //
        } else {
            CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retry Co");
            ChgOrdInboundRetry(Coe, IBCO_STAGING_RETRY);
            RsCoe(Cmd) = NULL;
            FrsCompleteCommand(Cmd, WStatus);
        }
        return;
    }

    //
    // Unrecoverable error or we have already hammered the object id back to
    // our object id so simply abort this change order.
    //
    if (JustOidChange || !WIN_SUCCESS(WStatus)) {
        if (JustOidChange) {
            //
            // Setting the CO_FLAG_JUST_OID_RESET bit disables propagation
            // to the outbound log but enables updates to the idtable entry
            // for this file (e.g., the file's usn).
            //
            CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retire Just OID");
            SET_CO_FLAG(Coe, CO_FLAG_JUST_OID_RESET);
        } else {
            //
            // Note: if this is a failed dir create then setting abort stops
            // the service on this replica set.
            //
            CHANGE_ORDER_TRACEW(3, Coe, "Stage Gen Retire Abort", WStatus);
            SET_COE_FLAG(Coe, COE_FLAG_STAGE_ABORTED);
        }

        ChgOrdInboundRetired(Coe);
    } else {
        CHANGE_ORDER_TRACE(3, Coe, "Stage Gen Retire");
        ChgOrdInboundRetired(Coe);
    }

    RsCoe(Cmd) = NULL;
    FrsCompleteCommand(Cmd, WStatus);
}

VOID
StageCsCreateExisting(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our upstream partner has a file to send us.

    If we already have the file, generate a staging file from
    the local file instead of fetching the staging file from
    the upstream partner.

    This function is only called for remote cos for new files
    being generated by a vvjoin on the upstream partner.
    See RemoteCoAccepted() in replica.c.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StageCsCreateExisting:"
    ULONG   Flags;
    BOOL    FileAttributesMatch;
    DWORD   WStatus = ERROR_SUCCESS;
    MD5_CTX Md5;
    ULONGLONG   SizeGenerated = 0;

    PCHANGE_ORDER_ENTRY     Coe = RsCoe(Cmd);
    PCHANGE_ORDER_COMMAND   Coc = RsCoc(Cmd);

    GUID    *CoGuid = &Coc->ChangeOrderGuid;
    GUID    CompressionFormatUsed;

    CHANGE_ORDER_TRACE(3, Coe, "Stage PreExist");

    //
    // Make sure there is no stale md5 checksum attached to the cmd
    //
    RsMd5Digest(Cmd) = FrsFree(RsMd5Digest(Cmd));

    //
    // Generate staging file from preexisting file
    //
    //
    // Copy the user file into the staging area after reserving space
    //
    Flags = STAGE_FLAG_RESERVE | STAGE_FLAG_EXCLUSIVE;
    if (CoCmdIsDirectory(Coc)) {
        Flags |= STAGE_FLAG_FORCERESERVE;
    }
    WStatus = StageAcquire(CoGuid, Coc->FileName, Coc->FileSize, &Flags, Coe->NewReplica->ReplicaNumber, NULL);

    if (WIN_SUCCESS(WStatus)) {
        //
        // Set to "Regenerating" to avoid updating fields in the Coc
        //
        WStatus = StuGenerateStage(Coc, Coe, TRUE, &Md5, &SizeGenerated, &CompressionFormatUsed);

        if (WIN_SUCCESS(WStatus)) {
            if (!IS_GUID_ZERO(&CompressionFormatUsed)) {
                //
                // A compressed staging file was generated. Set the appropriate
                // flags and the compression format guid in the STATE_ENTRY
                // structure.
                //
                StageRelease(CoGuid,
                             Coc->FileName,
                             STAGE_FLAG_CREATING   | STAGE_FLAG_RERESERVE |
                             STAGE_FLAG_COMPRESSED | STAGE_FLAG_COMPRESSION_FORMAT_KNOWN,
                             &SizeGenerated,
                             NULL,
                             &CompressionFormatUsed);
            } else {
                StageRelease(CoGuid,
                             Coc->FileName,
                             STAGE_FLAG_CREATING | STAGE_FLAG_RERESERVE,
                             &SizeGenerated,
                             NULL,
                             NULL);
            }
        } else {
            StageDeleteFile(Coc, NULL, FALSE);
            StageRelease(CoGuid, Coc->FileName, STAGE_FLAG_UNRESERVE, NULL, NULL, NULL);
        }
    }

    //
    // Generated staging file; continue with fetch
    //
    if (WIN_SUCCESS(WStatus)) {
        CHANGE_ORDER_TRACE(3, Coe, "Stage PreExist Done");
        RsMd5Digest(Cmd) = FrsAlloc(MD5DIGESTLEN);
        CopyMemory(RsMd5Digest(Cmd), Md5.digest, MD5DIGESTLEN);
        RcsSubmitTransferToRcs(Cmd, CMD_CREATED_EXISTING);
        return;
    }

    //
    // Preexisting file does not exist. Continue with original fetch
    //
    if (WIN_NOT_FOUND(WStatus)) {
        CHANGE_ORDER_TRACEW(3, Coe, "Stage PreExist No File", WStatus);
        RcsSubmitTransferToRcs(Cmd, CMD_CREATED_EXISTING);
        return;
    }
    //
    // Retriable problem. This function is called again when the
    // co is retried.
    //
    if (WIN_RETRY_STAGE(WStatus)) {
        //
        // Shutting down; Let the Replica Command Server handle it.
        //
        if (FrsIsShuttingDown) {
            CHANGE_ORDER_TRACE(3, Coe, "Stage PreExist Retry Shutdown");
            RcsSubmitTransferToRcs(Cmd, CMD_CREATED_EXISTING);
        //
        // Haven't retried; wait a bit
        //
        } else if (!RsTimeout(Cmd)) {
            CHANGE_ORDER_TRACE(3, Coe, "Stage PreExist Retry Cmd");
            RsTimeout(Cmd) = STAGECS_RETRY_TIMEOUT;
            FrsDelCsSubmitSubmit(&StageCs, Cmd, RsTimeout(Cmd));
        //
        // Retried and directory; give up and fetch it
        //
        } else if (CoCmdIsDirectory(Coc)) {
            CHANGE_ORDER_TRACE(3, Coe, "Stage PreExist Retry Transfer");
            RcsSubmitTransferToRcs(Cmd, CMD_CREATED_EXISTING);
        //
        // Retried and file; send co through retry
        //
        } else {
            CHANGE_ORDER_TRACE(3, Coe, "Stage PreExist Retry Co");
            ChgOrdInboundRetry(Coe, IBCO_FETCH_RETRY);
            RsCoe(Cmd) = NULL;
            FrsCompleteCommand(Cmd, WStatus);
        }
        return;
    }
    //
    // Unrecoverable error. Let normal paths deal with it.
    //
    CHANGE_ORDER_TRACEW(3, Coe, "Stage PreExist Cannot", WStatus);
    RcsSubmitTransferToRcs(Cmd, CMD_CREATED_EXISTING);
    return;
}


VOID
StageCsFreeStaging(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Free up staging space by deleting old staging files. The LastAccessTime
    is used to decide which staging files to delete.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "StageCsFreeStaging:"

    PVOID               Key;
    PSTAGE_ENTRY        SEntry;
    PSTAGE_ENTRY        NewSEntry;
    PGEN_TABLE          StagingAreaTableByAccessTime = NULL;
    CHAR                TimeString[TIME_STRING_LENGTH];
    ULARGE_INTEGER      TimeSinceLastAccess;
    PREPLICA            Replica;
    LONG                KBToRecover;
    BOOL                Status;
    DWORD               FileSizeInKB = StSpaceRequested(Cmd);
    FILETIME            Now;
    ULARGE_INTEGER      ULNow;
    ULARGE_INTEGER      ULLastAccessTime;

    //
    // Nothing to do if we are within the Higher water mark for staging area.
    //
    if (StagingAreaAllocated + FileSizeInKB < STAGECS_STAGE_LIMIT_HIGH * StagingLimitInKb) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    KBToRecover = (LONG)(StagingAreaAllocated - STAGECS_STAGE_LIMIT_LOW * StagingLimitInKb);

    //
    // Make sure that the recovered space will be enough for the requesting file.
    //
    if ((StagingAreaAllocated - KBToRecover + FileSizeInKB) > StagingLimitInKb) {
        KBToRecover = StagingAreaAllocated + FileSizeInKB - StagingLimitInKb;
    }

    DPRINT2(3, "StagingAreaAllocated = %d, Staging space to recover = %d\n", StagingAreaAllocated, KBToRecover);

    EnterCriticalSection(&StagingAreaCleanupLock);

    //
    // Sort the staging areas by accesstime.
    //
    StagingAreaTableByAccessTime = GTabAllocFileTimeTable();
    GTabLockTable(StagingAreaTableByAccessTime);

    GTabLockTable(StagingAreaTable);

    GetSystemTimeAsFileTime(&Now);
    CopyMemory(&ULNow, &Now, sizeof(FILETIME));

    Key = NULL;
    while ((SEntry = GTabNextDatumNoLock(StagingAreaTable, &Key)) && !FrsIsShuttingDown) {
        //
        // We don't want to delete staging files for COs that are not
        // yet installed. The STAGE_FLAG_INSTALLED flag
        // is set for remote staging files once we install
        // the file. All local and regenerated staging files
        // have this flag set.
        //
        if (!(SEntry->Flags & STAGE_FLAG_INSTALLED)) {
            continue;
        }

        CopyMemory(&ULLastAccessTime, &SEntry->LastAccessTime, sizeof(FILETIME));
        TimeSinceLastAccess.QuadPart = (ULNow.QuadPart - ULLastAccessTime.QuadPart) / (10 * 1000);

        //
        // Staging files that have been recently used are not
        // eligible for recliam. This is to prevent us from
        // deleting staging files that are in the process
        // of being sent to the outbound partners.
        // Consider the case where we have 2 local changes for
        // large files (file size close to staging quota). We
        // successfully generate staging file for the first one.
        // When we try to generate staging file for the second
        // local CO we trigger cleanup and the LRU staging file
        // is the first one (only in the list). We don't want
        // to delete this staging file as it is not yet
        // sent to the downstream partner. The staging file for
        // the first CO will be eligible for reclaim when it is
        // not accessed for at least REPLACEMENT_ELIGIBILITY_TIME
        // milliseconds.
        //
        if (TimeSinceLastAccess.QuadPart < REPLACEMENT_ELIGIBILITY_TIME) {
            continue;
        }

        NewSEntry = FrsAlloc(sizeof(STAGE_ENTRY));
        CopyMemory(NewSEntry, SEntry, sizeof(STAGE_ENTRY));
        GTabInsertEntryNoLock(StagingAreaTableByAccessTime, NewSEntry, &NewSEntry->LastAccessTime, NULL);
    }
    GTabUnLockTable(StagingAreaTable);

    Key = NULL;
    while ((SEntry = GTabNextDatumNoLock(StagingAreaTableByAccessTime, &Key)) &&
           (KBToRecover > 0) && !FrsIsShuttingDown) {
        FileTimeToString(&SEntry->LastAccessTime, TimeString);
        DPRINT1(5,"Access time table %s\n",TimeString);
        Replica = ReplicaIdToAddr(SEntry->ReplicaNumber);
        Status = StageDeleteFileByGuid(&SEntry->FileOrCoGuid, Replica);
        if (Status == TRUE) {
            KBToRecover-=SEntry->FileSizeInKb;
        }

        DPRINT1(5, "Staging space left to recover = %d\n", KBToRecover);
    }

    GTabUnLockTable(StagingAreaTableByAccessTime);
    GTabFreeTable(StagingAreaTableByAccessTime, FrsFree);

    //
    // Indicate that the cleanup has completed.
    //
    LeaveCriticalSection(&StagingAreaCleanupLock);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);

    return;

}


DWORD
MainStageCs(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for a thread serving the Staging File Generator Command Server.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "MainStageCs:"
    DWORD               WStatus = ERROR_SUCCESS;
    PCOMMAND_PACKET     Cmd;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)Arg;

    //
    // Thread is pointing at the correct command server
    //
    FRS_ASSERT(FrsThread->Data == &StageCs);
    FrsThread->Exit = ThSupExitWithTombstone;

    //
    // Try-Finally
    //
    try {

        //
        // Capture exception.
        //
        try {

            //
            // Pull entries off the queue and process them
            //
cant_exit_yet:
            while (Cmd = FrsGetCommandServer(&StageCs)) {
                switch (Cmd->Command) {

                    case CMD_CREATE_STAGE:
                        COMMAND_TRACE(3, Cmd, "Stage: Create Stage");
                        StageCsCreateStage(Cmd, FALSE);
                        break;

                    case CMD_CREATE_EXISTING:
                        COMMAND_TRACE(3, Cmd, "Stage: Create Existing");
                        StageCsCreateExisting(Cmd);
                        break;

                    case CMD_CHECK_OID:
                        COMMAND_TRACE(3, Cmd, "Stage: Check Oid");
                        StageCsCreateStage(Cmd, TRUE);
                        break;

                    case CMD_FREE_STAGING:
                        COMMAND_TRACE(3, Cmd, "Stage: Free Staging");
                        StageCsFreeStaging(Cmd);
                        break;

                    default:
                        COMMAND_TRACE(0, Cmd, "Stage: ERROR COMMAND");
                        FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
                        break;
                }
            }
            //
            // Exit
            //
            FrsExitCommandServer(&StageCs, FrsThread);
            goto cant_exit_yet;

        //
        // Get exception status.
        //
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }

    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "StageCs finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT(0, "StageCs terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}


VOID
FrsStageCsInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the staging file generator

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsStageCsInitialize:"
    //
    // Initialize the command servers
    //

    CfgRegReadDWord(FKC_MAX_STAGE_GENCS_THREADS, NULL, 0, &MaxSTageCsThreads);

    FrsInitializeCommandServer(&StageCs, MaxSTageCsThreads, L"StageCs", MainStageCs);
}


VOID
FrsStageCsUnInitialize(
    VOID
    )
/*++
Routine Description:
    All of the threads have exited. The table used for managing
    the staging file space can be safely freed.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsStageCsUnInitialize:"
    DPRINT1(4, ":S: %dKB of Staging area is still allocated\n", StagingAreaAllocated);
}





VOID
ShutDownStageCs(
    VOID
    )
/*++
Routine Description:
    Shutdown the staging area command server. The staging directory
    pathname is not released because there may be threads using it.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownStageCs:"
    FrsRunDownCommandServer(&StageCs, &StageCs.Queue);
}





VOID
FrsStageCsSubmitTransfer(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command
    )
/*++
Routine Description:
    Transfer a request to the staging file generator

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsStageCsSubmitTransfer:"
    //
    // Submit a request to allocate staging area
    //
    Cmd->TargetQueue = &StageCs.Queue;
    Cmd->Command = Command;
    RsTimeout(Cmd) = 0;
    DPRINT1(1, "Stage: submit transfer 0x%x\n", Cmd);
    FrsSubmitCommandServer(&StageCs, Cmd);
}


DWORD
StageAddStagingArea(
    IN PWCHAR   StageArea
    )
/*++
Routine Description:
    Adds a new staging area to the table of staging areas.

Arguments:

    StageArea              : Path to the staging dir.

Return Value:
    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB  "StageAddStagingArea:"


    PSTAGING_AREA_ENTRY SAEntry = NULL;

    if (NewStagingAreaTable == NULL) {
        NewStagingAreaTable = GTabAllocStringTable();
        DPRINT(5,"SUDARC-DEV Created staging area table\n");
    }

    SAEntry = GTabLookupTableString(NewStagingAreaTable, StageArea, NULL);

    if (SAEntry != NULL) {
        SAEntry->ReferenceCount++;
        DPRINT2(5,"SUDARC-DEV entry exists. Path = %ws, Ref = %d\n", SAEntry->StagingArea, SAEntry->ReferenceCount);
    } else {
        SAEntry = FrsAlloc(sizeof(STAGING_AREA_ENTRY));

        SAEntry->StagingArea = FrsWcsDup(StageArea);
        SAEntry->ReferenceCount = 1;
        SAEntry->StagingAreaState = STAGING_AREA_ELIGIBLE;
        INITIALIZE_CRITICAL_SECTION(&SAEntry->StagingAreaCritSec);
        SAEntry->StagingAreaSpaceInUse = 0;
        SAEntry->StagingAreaLimitInKB = DefaultStagingLimitInKb;

        GTabInsertUniqueEntry(NewStagingAreaTable, SAEntry, StageArea, NULL);

        DPRINT1(5,"SUDARC-DEV Successfully inserted entry = %ws\n", SAEntry->StagingArea);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\replica.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    replica.c

Abstract:
    Replica Control Command Server (Replica).

    The Ds Poller periodically pulls the configuration from the DS,
    checks it for consistency, and then merges it with the current
    local configuration. The Ds Poller then makes copies of each
    replica for this machine and sends the copy to this replica
    control command server.

Author:
    Billy J. Fuller 23-May-1997

Revised:
    David A. Orbits 24-Jan-1998, added locking and interfaced with INLOG.
                                 Restructured Connection JOIN sequence.
                       Jul-1999  Registry code rewrite

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop


#include <ntdsapi.h>
#include <frs.h>
#include <tablefcn.h>
#include <ntfrsapi.h>
#include <perrepsr.h>
#include <Sddl.h>

//
// Connection flags.
//
FLAG_NAME_TABLE CxtionFlagNameTable[] = {
    {CXTION_FLAGS_CONSISTENT           , "Consistent "     },
    {CXTION_FLAGS_SCHEDULE_OFF         , "SchedOff "       },
    {CXTION_FLAGS_VOLATILE             , "Volatile "       },
    {CXTION_FLAGS_DEFERRED_JOIN        , "DeferredJoin "   },

    {CXTION_FLAGS_DEFERRED_UNJOIN      , "DeferUnjoin "    },
    {CXTION_FLAGS_TIMEOUT_SET          , "TimeOutSet "     },
    {CXTION_FLAGS_JOIN_GUID_VALID      , "JoinGuidValid "  },
    {CXTION_FLAGS_UNJOIN_GUID_VALID    , "UnJoinGuidValid "},

    {CXTION_FLAGS_PERFORM_VVJOIN       , "PerformVVJoin"   },
    {CXTION_FLAGS_DEFERRED_DELETE      , "DeferredDel "    },
    {CXTION_FLAGS_PAUSED               , "Paused "         },
    {CXTION_FLAGS_HUNG_INIT_SYNC       , "HungInitSync "   },
    {CXTION_FLAGS_TRIM_OUTLOG          , "TrimOutLog "     },
    {CXTION_FLAGS_INIT_SYNC            , "InitSync "       },
    {CXTION_FLAGS_TRIGGER_SCHEDULE     , "TriggerSched "   },

    {0, NULL}
};

//
// Directory and file filter lists from registry.
//
extern PWCHAR   RegistryFileExclFilterList;
extern PWCHAR   RegistryDirExclFilterList;

extern ULONGLONG    ActiveChange;

BOOL    CurrentSysvolReadyIsValid;
DWORD   CurrentSysvolReady;

//
// Replica tombstone in days
//
DWORD       ReplicaTombstone;
ULONGLONG   ReplicaTombstoneInFileTime;

//
// Retry a join every MinJoinRetry milliseconds, increasing by
// MinJoinRetry every retry (but no longer than MaxJoinRetry).
//
#define JOIN_RETRY_EVENT    (5) // record event every 5 join retries
LONG MinJoinRetry;
LONG MaxJoinRetry;


extern DWORD    CommTimeoutInMilliSeconds;

//
// Start replication even if the DS could not be accessed
//
DWORD ReplicaStartTimeout;

//
// Struct for the Replica Control Command Server
//      Contains info about the queues and the threads
//
COMMAND_SERVER  ReplicaCmdServer;

//
// Table of active replicas
//
PGEN_TABLE ReplicasByGuid;
PGEN_TABLE ReplicasByNumber;

//
// Table of deleted replicas discovered at startup. These replicas
// never make it into the active tables, ever.
//
PGEN_TABLE DeletedReplicas;

//
// Table of cxtions deleted during runtime. They are eventually
// freed at shutdown.
//
PGEN_TABLE DeletedCxtions;

PGEN_TABLE ReplicasNotInTheDs;


#define MINUTES_IN_INTERVAL (15)

#define CMD_DELETE_RETRY_SHORT_TIMEOUT  (10 * 1000)
#define CMD_DELETE_RETRY_LONG_TIMEOUT   (60 * 1000)

//
// Partners are not allowed to join if their clocks are out-of-sync
//
ULONGLONG MaxPartnerClockSkew;
DWORD    PartnerClockSkew;

#define ReplicaCmdSetInitialTimeOut(_Cmd_, _Init_) \
    if (RsTimeout(Cmd) == 0) {                     \
        RsTimeout(Cmd) = (_Init_);                 \
    }

#define SET_JOINED(_Replica_, _Cxtion_, _S_)                                   \
{                                                                              \
    SetCxtionState(_Cxtion_, CxtionStateJoined);                               \
    PM_INC_CTR_REPSET((_Replica_), Joins, 1);                                  \
    PM_INC_CTR_CXTION((_Cxtion_), Joins, 1);                                   \
                                                                               \
    DPRINT3(0, ":X: ***** %s   CxtG %08x  "FORMAT_CXTION_PATH2"\n",            \
            _S_,                                                               \
            ((_Cxtion_) != NULL) ? ((PCXTION)(_Cxtion_))->Name->Guid->Data1 : 0,\
            PRINT_CXTION_PATH2(_Replica_, _Cxtion_));                          \
    if (_Cxtion_->JoinCmd &&                                                   \
        (LONG)RsTimeout(_Cxtion_->JoinCmd) > (JOIN_RETRY_EVENT * MinJoinRetry)) { \
        if (_Cxtion_->Inbound) {                                               \
            EPRINT3(EVENT_FRS_LONG_JOIN_DONE,                                  \
                    _Cxtion_->Partner->Name, ComputerName, _Replica_->Root);   \
        } else {                                                               \
            EPRINT3(EVENT_FRS_LONG_JOIN_DONE,                                  \
                    ComputerName, _Cxtion_->Partner->Name, _Replica_->Root);   \
        }                                                                      \
    }                                                                          \
}

//
// Unidle the change order process queue if it is blocked.
//
#define UNIDLE_CO_PROCESS_QUEUE(_Replica_, _Cxtion_, _CoProcessQueue_)                           \
{                                                                              \
    if (_CoProcessQueue_ != NULL) {                                            \
        CXTION_STATE_TRACE(3, _Cxtion_, _Replica_, 0, "CO Process Q Unblock"); \
        FrsRtlUnIdledQueue(_CoProcessQueue_);                                  \
        _CoProcessQueue_ = NULL;                                               \
    }                                                                          \
}

//
// UNJOIN TRIGGER
//
// Trigger an unjoin after N co's on *ONE* cxtion *ONE* time.
//
#if     DBG
#define PULL_UNJOIN_TRIGGER(_Cxtion_, _Cmd_) \
{ \
    if (_Cxtion_->UnjoinTrigger && (--_Cxtion_->UnjoinTrigger == 0)) { \
        DPRINT1(0, ":X: UNJOIN TRIGGER FIRED FOR %ws\n", _Cxtion_->Name->Name); \
        FrsCompleteCommand(_Cmd_, ERROR_OPERATION_ABORTED); \
        return; \
    } \
}

#define SET_UNJOIN_TRIGGER(_Cxtion_) \
{ \
        if (DebugInfo.UnjoinTrigger) { \
            _Cxtion_->UnjoinReset = DebugInfo.UnjoinTrigger; \
            DebugInfo.UnjoinTrigger = 0; \
        } \
        _Cxtion_->UnjoinTrigger = _Cxtion_->UnjoinReset; \
        _Cxtion_->UnjoinReset <<= 1; \
        _Cxtion_->UnjoinReset = 0; \
}
#else   DBG
#define SET_UNJOIN_TRIGGER(_Cxtion_)
#define PULL_UNJOIN_TRIGGER(_Cxtion_, _Cmd_)
#endif  DBG

//
// Flags for RcsCheckCmd.
//
#define CHECK_CMD_PARTNERCOC            (0x00000001)
#define CHECK_CMD_REPLICA               (0x00000002)
#define CHECK_CMD_CXTION                (0x00000004)
#define CHECK_CMD_JOINGUID              (0x00000008)

#define CHECK_CMD_COE                   (0x00000010)
#define CHECK_CMD_COGUID                (0x00000020)
#define CHECK_CMD_NOT_EXPIRED           (0x00000040)
#define CHECK_CMD_JOINTIME              (0x00000080)

#define CHECK_CMD_REPLICA_VERSION_GUID  (0x00000100)

#define CHECK_CMD_CXTION_OK     (CHECK_CMD_REPLICA |  \
                                 CHECK_CMD_CXTION)

#define CHECK_CMD_CXTION_AND_COGUID_OK  (CHECK_CMD_CXTION_OK | \
                                         CHECK_CMD_COGUID)

#define CHECK_CMD_CXTION_AND_JOINGUID_OK  (CHECK_CMD_CXTION_OK | \
                                           CHECK_CMD_JOINGUID)


VOID
ChgOrdStartJoinRequest(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion
    );

ULONG
OutLogRetireCo(
    PREPLICA Replica,
    ULONG COx,
    PCXTION PartnerCxtion
);

ULONG
OutLogInitPartner(
    PREPLICA Replica,
    PCXTION PartnerInfo
);

ULONG
RcsForceUnjoin(
   IN PREPLICA  Replica,
   IN PCXTION   Cxtion
   );

VOID
RcsCreatePerfmonCxtionName(
    PREPLICA  Replica,
    PCXTION   Cxtion
    );

DWORD
SndCsAssignCommQueue(
    VOID
    );

VOID
SndCsCreateCxtion(
    IN OUT PCXTION  Cxtion
    );

VOID
SndCsDestroyCxtion(
    IN PCXTION  Cxtion,
    IN DWORD    CxtionFlags
    );

VOID
SndCsSubmitCommPkt(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN GUID                 *JoinGuid,
    IN BOOL                 SetTimeout,
    IN PCOMM_PACKET         CommPkt,
    IN DWORD                CommQueueIndex
    );

VOID
SndCsSubmitCommPkt2(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCHANGE_ORDER_ENTRY  Coe,
    IN BOOL                 SetTimeout,
    IN PCOMM_PACKET         CommPkt
    );

VOID
SndCsSubmitCmd(
    IN PREPLICA             Replica,
    IN PCXTION              Cxtion,
    IN PCOMMAND_SERVER      FlushCs,
    IN PCOMMAND_PACKET      FlushCmd,
    IN DWORD                CommQueueIndex
    );

VOID
ChgOrdInjectControlCo(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN ULONG    ContentCmd
    );

VOID
RcsUpdateReplicaSetMember(
    IN PREPLICA Replica
    );

VOID
RcsReplicaSetRegistry(
    IN PREPLICA     Replica
    );

VOID
CfgFilesNotToBackup(
    IN PGEN_TABLE   Replicas
    );

DWORD
NtFrsApi_Rpc_BindEx(
    IN  PWCHAR      MachineName,
    OUT PWCHAR      *OutPrincName,
    OUT handle_t    *OutHandle,
    OUT ULONG       *OutParentAuthLevel
    );

PWCHAR
FrsDsConvertName(
    IN HANDLE Handle,
    IN PWCHAR InputName,
    IN DWORD  InputFormat,
    IN PWCHAR DomainDnsName,
    IN DWORD  DesiredFormat
    );

DWORD
UtilRpcServerHandleToAuthSidString(
    IN  handle_t    ServerHandle,
    IN  PWCHAR      AuthClient,
    OUT PWCHAR      *ClientSid
    );


VOID
RcsCloseReplicaSetmember(
    IN PREPLICA Replica
    );

VOID
RcsCloseReplicaCxtions(
    IN PREPLICA Replica
    );

ULONG
DbsProcessReplicaFaultList(
    PDWORD  pReplicaSetsDeleted
    );

ULONG
DbsCheckForOverlapErrors(
    IN PREPLICA     Replica
    );

PCOMMAND_PACKET
CommPktToCmd(
    IN PCOMM_PACKET CommPkt
    );

PCOMM_PACKET
CommBuildCommPkt(
    IN PREPLICA                 Replica,
    IN PCXTION                  Cxtion,
    IN ULONG                    Command,
    IN PGEN_TABLE               VVector,
    IN PCOMMAND_PACKET          Cmd,
    IN PCHANGE_ORDER_COMMAND    Coc
    );


BOOL
RcsAreAuthNamesEqual(
    IN PWCHAR   AuthName1,
    IN PWCHAR   AuthName2
    )
/*++
Routine Description:
    Are the two auth names equal?

    The principle name comes from an rpc server handle or
    from DsCrackName(NT4 ACCOUNT NAME). The formats are
    slightly different so this isn't a simple wcsicmp().

    The principle name from the server handle has the format
    DNS-Domain-Name\ComputerName$.

    The principle name from DsCrackName has the format
    NetBIOS-Domain-Name\ComputerName$.

    The principle name from RpcMgmtInqServerPrincName() has the format
    ComputerName$@DNS-Domain-Name

    The names may be stringized sids.

Arguments:
    AuthName1  - from rpc server handle or DsCrackName()
    AuthName2  - from rpc server handle or DsCrackName()

Return Value:
    TRUE    - the princnames are effectively equal
    FALSE   - not
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsAreAuthNamesEqual:"
    BOOL    AreEqual = FALSE;
    PWCHAR  c;
    PWCHAR  Sam1Begin;
    PWCHAR  Sam2Begin;
    PWCHAR  Sam1End;
    PWCHAR  Sam2End;
    PWCHAR  Dom1Begin;
    PWCHAR  Dom2Begin;
    PWCHAR  Dom1End;
    PWCHAR  Dom2End;

    //
    // NULL Param
    //
    if (!AuthName1 || !AuthName2) {
        if (!AuthName1 && !AuthName2) {
            AreEqual = TRUE;
            goto CLEANUP;
        }
        goto CLEANUP;
    }

    //
    // principal names are usually in the format domain\samaccount
    // or stringized SID
    //
    if (WSTR_EQ(AuthName1, AuthName2)) {
        AreEqual = TRUE;
        goto CLEANUP;
    }

    //
    // Find the sam account name and the domain name
    //
    for (c = AuthName1; *c && *c != L'\\' && *c != L'@'; ++c);
    if (*c) {
        //
        // domain\samaccount
        //
        if (*c == L'\\') {
            Dom1Begin = AuthName1;
            Dom1End   = c;
            Sam1Begin = c + 1;
            Sam1End   = &AuthName1[wcslen(AuthName1)];
        }
        //
        // samaccount@dnsdomain
        //
        else {
            Sam1Begin = AuthName1;
            Sam1End   = c;
            Dom1Begin = c + 1;
            for (; *c && *c != L'.'; ++c);
            Dom1End = c;
        }
    }
    //
    // Unknown format
    //
    else {
        goto CLEANUP;
    }

    for (c = AuthName2; *c && *c != L'\\' && *c != L'@'; ++c);
    if (*c) {
        //
        // domain\samaccount
        //
        if (*c == L'\\') {
            Dom2Begin = AuthName2;
            Dom2End   = c;
            Sam2Begin = c + 1;
            Sam2End   = &AuthName2[wcslen(AuthName2)];
        }
        //
        // samaccount@dnsdomain
        //
        else {
            Sam2Begin = AuthName2;
            Sam2End   = c;
            Dom2Begin = c + 1;
            for (; *c && *c != L'.'; ++c);
            Dom2End = c;
        }
    }
    //
    // Unknown format
    //
    else {
        goto CLEANUP;
    }

    //
    // Compare samaccount
    //
    while (Sam1Begin != Sam1End && Sam2Begin != Sam2End) {
        if (towlower(*Sam1Begin) != towlower(*Sam2Begin)) {
            goto CLEANUP;
        }
        ++Sam1Begin;
        ++Sam2Begin;
    }

    //
    // compare domain
    //
    while (Dom1Begin != Dom1End && Dom2Begin != Dom2End) {
        if (towlower(*Dom1Begin) != towlower(*Dom2Begin)) {
            goto CLEANUP;
        }
        ++Dom1Begin;
        ++Dom2Begin;
    }

    AreEqual = (Sam1Begin == Sam1End &&
                Sam2Begin == Sam2End &&
                Dom1Begin == Dom1End &&
                Dom2Begin == Dom2End);
CLEANUP:

    DPRINT3(4, "Auth names %ws %s %ws\n",
            AuthName1, (AreEqual) ? "==" : "!=", AuthName2);

    return AreEqual;
}


PREPLICA
RcsFindReplicaByNumber(
    IN ULONG ReplicaNumber
    )
/*++
Routine Description:
    Find the replica by internal number

Arguments:
    ReplicaNumber

Return Value:
    Address of the replica or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFindReplicaByNumber:"
    //
    // Find the replica by internal replica number  (used in the Jet Table names)
    //
    return GTabLookup(ReplicasByNumber, &ReplicaNumber, NULL);
}




PREPLICA
RcsFindReplicaByGuid(
    IN GUID *Guid
    )
/*++
Routine Description:
    Find a replica by Guid

Arguments:
    Guid    - Replica->ReplicaName->Guid

Return Value:
    Address of the replica or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFindReplicaByGuid:"
    //
    // Find the replica by guid
    //
    return GTabLookup(ReplicasByGuid, Guid, NULL);
}




PREPLICA
RcsFindReplicaById(
    IN ULONG Id
    )
/*++
Routine Description:

    Find a replica given the internal ID.

Arguments:

    Id - Internal Replica ID.

Return Value:
    Address of the replica or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFindReplicaById:"
    PREPLICA RetVal = NULL;

    ForEachListEntry( &ReplicaListHead, REPLICA, ReplicaList,
        if (pE->ReplicaNumber == Id) {
            RetVal = pE;
            break;
        }
    );

    return RetVal;
}


BOOL
RcsCheckCmd(
    IN PCOMMAND_PACKET  Cmd,
    IN PCHAR            Debsub,
    IN ULONG            Flags
    )
/*++
Routine Description:
    Check the command packet for the specified fields.

Arguments:
    Cmd
    Hdr
    Flags

Return Value:
    TRUE    - packet is ok
    FALSE   - not
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCheckCmd:"
    BOOL    Ret = TRUE;
    PREPLICA Replica = RsReplica(Cmd);
    CHAR Tstr1[128];

    //
    // Replica
    //
    if ((Flags & CHECK_CMD_REPLICA) && !RsReplica(Cmd)) {
        DPRINT(0, "WARN - No replica in command packet\n");
        FrsCompleteCommand(Cmd, ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Partner change order command
    //
    if ((Flags & CHECK_CMD_PARTNERCOC) && !RsPartnerCoc(Cmd)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_PARTNERCOC failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Replica has been (or may be) deleted
    //
    if ((Flags & CHECK_CMD_NOT_EXPIRED) &&
        !IS_TIME_ZERO(RsReplica(Cmd)->MembershipExpires)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_NOT_EXPIRED failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Cxtion
    //
    if ((Flags & CHECK_CMD_CXTION) &&
        !(RsCxtion(Cmd) && RsCxtion(Cmd)->Guid)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_CXTION failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Join guid
    //
    if ((Flags & CHECK_CMD_JOINGUID) && !RsJoinGuid(Cmd)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_JOINGUID failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Replica Version Guid
    //
    if ((Flags & CHECK_CMD_REPLICA_VERSION_GUID) &&
        !RsReplicaVersionGuid(Cmd)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_REPLICA_VERSION_GUID failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Change order entry
    //
    if ((Flags & CHECK_CMD_COE) && !RsCoe(Cmd)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_COE failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Change order guid
    //
    if ((Flags & CHECK_CMD_COGUID) && !RsCoGuid(Cmd)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_COGUID failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    //
    // Join time
    //
    if ((Flags & CHECK_CMD_JOINTIME) && !RsJoinTime(Cmd)) {
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CHECK_CMD_JOINTIME failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';
        Ret = FALSE;
    }

    if (!Ret) {
        Tstr1[sizeof(Tstr1)-1] = '\0';
        REPLICA_STATE_TRACE(3, Cmd, Replica, ERROR_INVALID_PARAMETER, Tstr1);
        FrsCompleteCommand(Cmd, ERROR_INVALID_PARAMETER);
    }

    return Ret;
}


ULONG
RcsCheckCxtionCommon(
    IN PCOMMAND_PACKET  Cmd,
    IN PCXTION          Cxtion,
    IN PCHAR            Debsub,
    IN ULONG            Flags,
    OUT PFRS_QUEUE      *CoProcessQueue
    )
/*++
Routine Description:
    find the in/outbound cxtion referenced by a command received
    from a remote machine.

    The caller should have used RcsCheckCmd() with
        CHECK_CMD_REPLICA
        CHECK_CMD_CXTION
        CHECK_CMD_JOINGUID (if CHECK_CXTION_JOINGUID)
    before calling this function.

Arguments:
    Cmd  -- Command packet
    Cxtion -- connection struct to be checked.
    Debsub
    Flags
    CoProcessQueue -- return the pointer to the process queue to unidle.

Return Value:
    Error status code.

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCheckCxtionCommon:"

    PREPLICA  Replica = RsReplica(Cmd);

    //
    // Cxtion exists
    //
    if ((Flags & CHECK_CXTION_EXISTS) &&
        ((Cxtion == NULL) ||
         CxtionStateIs(Cxtion, CxtionStateInit))) {
        DPRINT2(1, "++ WARN - %s no cxtion for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }
    //
    // Not much purpose in continuing
    //
    if (!Cxtion) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Inbound cxtion
    //
    if ((Flags & CHECK_CXTION_INBOUND) && !Cxtion->Inbound) {
        DPRINT2(1, "++ WARN - %s cxtion is not inbound for %08x\n", Debsub, Cmd);
        //
        // Change order accept better not be waiting for this cxtion.
        //
        FRS_ASSERT(Cxtion->CoProcessQueue == NULL);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Outbound cxtion
    //
    if ((Flags & CHECK_CXTION_OUTBOUND) && Cxtion->Inbound) {
        DPRINT2(1, "++ WARN - %s cxtion is not outbound for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Jrnl cxtion
    //
    if ((Flags & CHECK_CXTION_JRNLCXTION) && !Cxtion->JrnlCxtion) {
        DPRINT2(1, "++ WARN - %s cxtion is not jrnlcxtion for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Version vector
    //
    if ((Flags & CHECK_CXTION_VVECTOR) && !Cxtion->VVector) {
        DPRINT2(1, "++ WARN - %s no version vector for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Authenticate Partner
    //
    if ((Flags & CHECK_CXTION_PARTNER)) {

        //
        // Increment the Authentications counter for
        // both the replica set and connection objects
        //
        PM_INC_CTR_CXTION(Cxtion, Authentications, 1);
        PM_INC_CTR_REPSET(Replica, Authentications, 1);

        if (
#if DBG
    //
    // We don't enable authentication when emulating machines
    //
            !ServerGuid &&
#endif DBG
            (Cxtion->PartnerAuthLevel == CXTION_AUTH_KERBEROS_FULL) &&
            RunningAsAService &&
#ifdef DS_FREE
            (NoDs == FALSE) &&
#endif DS_FREE
            (!RcsAreAuthNamesEqual(Cxtion->PartnerSid, RsAuthSid(Cmd)) &&
             !RcsAreAuthNamesEqual(Cxtion->PartnerPrincName, RsAuthClient(Cmd)))) {

            DPRINT4(1, "++ WARN - %s %08x: PrincName %ws != %ws\n",
                    Debsub, Cmd, RsAuthClient(Cmd), Cxtion->PartnerPrincName);

            DPRINT4(1, "++ WARN - %s %08x: AuthSid %ws != %ws\n",
                    Debsub, Cmd, RsAuthSid(Cmd), Cxtion->PartnerSid);

            return ERROR_INVALID_PARAMETER;
        } else {
            //
            // Increment the Authentications in error counter for
            // both the replica set and connection objects
            //
            PM_INC_CTR_CXTION(Cxtion, AuthenticationsError, 1);
            PM_INC_CTR_REPSET(Replica, AuthenticationsError, 1);
        }
    }

    //
    // Authentication info
    //
    if ((Flags & CHECK_CXTION_AUTH)) {

        //
        // Increment the Authentications counter for
        // both the replica set and connection objects
        //
        PM_INC_CTR_CXTION(Cxtion, Authentications, 1);
        PM_INC_CTR_REPSET(Replica, Authentications, 1);

        if (
#if DBG
    //
    // We don't enable authentication when emulating machines
    //
            !ServerGuid &&
#endif DBG
    //
    // We don't enable authentication when running in DS_FREE mode.
    //
#ifdef DS_FREE
            (NoDs == FALSE) &&
#endif DS_FREE
            (Cxtion->PartnerAuthLevel == CXTION_AUTH_KERBEROS_FULL) &&
            (RsAuthLevel(Cmd) != RPC_C_AUTHN_LEVEL_PKT_PRIVACY ||
             (RsAuthN(Cmd) != RPC_C_AUTHN_GSS_KERBEROS &&
              RsAuthN(Cmd) != RPC_C_AUTHN_GSS_NEGOTIATE))) {
            DPRINT2(1, "++ WARN - %s bad authentication for %08x\n", Debsub, Cmd);
            return ERROR_INVALID_PARAMETER;
        } else {
            //
            // Increment the Authentications in error counter for
            // both the replica set and connection objects
            //
            PM_INC_CTR_CXTION(Cxtion, AuthenticationsError, 1);
            PM_INC_CTR_REPSET(Replica, AuthenticationsError, 1);
        }
    }

    //
    // Fix Join
    //
    // We may receive change orders after a successful join but
    // before we receive the JOINED packet from our inbound
    // partner. Fix the JOINED flag if so.
    //
    if ((Flags & CHECK_CXTION_FIXJOINED) &&
        CxtionStateIs(Cxtion, CxtionStateWaitJoin) &&
        RsJoinGuid(Cmd) &&
        Replica &&
        GUIDS_EQUAL(&Cxtion->JoinGuid, RsJoinGuid(Cmd)) &&
        CxtionFlagIs(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID)) {
        SET_JOINED(Replica, Cxtion, "OOJOINED");
        //
        // Return the pointer to the process queue to the caller so that the caller
        // can unidle the queue after releasing the cxtion lock.
        // Never try to lock the process queue when you have the cxtion lock. It will
        // result in a deadlock.
        //
        *CoProcessQueue = Cxtion->CoProcessQueue;
        Cxtion->CoProcessQueue = NULL;
        SET_UNJOIN_TRIGGER(Cxtion);
    }

    //
    // Joined
    //
    if ((Flags & CHECK_CXTION_JOINED) &&
        !CxtionStateIs(Cxtion, CxtionStateJoined)) {
        DPRINT2(1, "++ WARN - %s cxtion is not joined for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Join guid
    //
    if ((Flags & CHECK_CXTION_JOINGUID) &&
        (!RsJoinGuid(Cmd) ||
         !GUIDS_EQUAL(&Cxtion->JoinGuid, RsJoinGuid(Cmd)) ||
         !CxtionFlagIs(Cxtion, CXTION_FLAGS_JOIN_GUID_VALID))) {
        DPRINT2(1, "++ WARN - %s wrong join guid for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // UnJoin guid
    //
    if ((Flags & CHECK_CXTION_UNJOINGUID) &&
        (!RsJoinGuid(Cmd) ||
         !GUIDS_EQUAL(&Cxtion->JoinGuid, RsJoinGuid(Cmd)) ||
         !CxtionFlagIs(Cxtion, CXTION_FLAGS_UNJOIN_GUID_VALID))) {
        DPRINT2(1, "++ WARN - %s wrong unjoin guid for %08x\n", Debsub, Cmd);
        return ERROR_INVALID_PARAMETER;
    }

    return ERROR_SUCCESS;
}


PCXTION
RcsCheckCxtion(
    IN PCOMMAND_PACKET  Cmd,
    IN PCHAR            Debsub,
    IN ULONG            Flags
    )
/*++
Routine Description:
    find the in/outbound cxtion referenced by a command received
    from a remote machine.

    The caller should have used RcsCheckCmd() with
        CHECK_CMD_REPLICA
        CHECK_CMD_CXTION
        CHECK_CMD_JOINGUID (if CHECK_CXTION_JOINGUID)
    before calling this function.

    Complete the command with an error if a specified check fails.

Arguments:
    Cmd
    Debsub
    Flags

Return Value:
    Address of the cxtion or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCheckCxtion:"
    PCXTION Cxtion;
    PREPLICA Replica = RsReplica(Cmd);
    ULONG WStatus;
    CHAR Tstr1[64];
    PFRS_QUEUE CoProcessQueue = NULL;

    //
    // Lock the connection table to sync with INLOG and OUTLOG access.
    //
    LOCK_CXTION_TABLE(Replica);

    //
    // Find the cxtion and check it.
    //
    Cxtion = GTabLookupNoLock(Replica->Cxtions, RsCxtion(Cmd)->Guid, NULL);

    WStatus = RcsCheckCxtionCommon(Cmd, Cxtion, Debsub, Flags, &CoProcessQueue);

    UNLOCK_CXTION_TABLE(Replica);

    //
    // If RcsCheckCxtionCommon wanted us to unidle the process queue then do it here
    // after releasing the cxtion lock.
    //
    UNIDLE_CO_PROCESS_QUEUE(Replica, Cxtion, CoProcessQueue);

    //
    // If check not successfull then complete the command with an error.
    //
    if (!WIN_SUCCESS(WStatus)) {
        //
        // The join command packet is being rejected; Clear the reference.
        //
        _snprintf(Tstr1, sizeof(Tstr1), "W, %s CheckCxtion failed", Debsub);
        Tstr1[sizeof(Tstr1)-1] = '\0';

        REPLICA_STATE_TRACE(3, Cmd, Replica, WStatus, Tstr1);

        if (Cxtion && Cxtion->JoinCmd == Cmd) {
            Cxtion->JoinCmd = NULL;
        }
        //
        // Do not complete the command if the check is being made for the
        // fetch command server.
        //
        if (!BooleanFlagOn(Flags, CHECK_CXTION_FOR_FETCHCS)) {
            FrsCompleteCommand(Cmd, WStatus);
        }

        return NULL;
    }

    //
    // Check is successful.  Return the Cxtion.
    //
    return Cxtion;
}


VOID
RcsJoinCxtionLater(
    IN PREPLICA         Replica,
    IN PCXTION          Cxtion,
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Check on the join status of the cxtion occasionally.  Restart the join
    process if needed.  The cxtion contains the retry timeout.

    Cmd contains enough info to get back to the replica\cxtion.

Arguments:
    Replica
    Cxtion
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsJoinCxtionLater:"
    ULONG   Timeout;

    //
    // There is already a join command packet in the works; done
    //
    if (Cxtion->JoinCmd) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }
    Cxtion->JoinCmd = Cmd;
    Cmd->Command = CMD_JOIN_CXTION;

    //
    // Stop retrying after a while, but not too long or too short.
    //
    RsTimeout(Cmd) += MinJoinRetry;

    if ((LONG)RsTimeout(Cmd) < MinJoinRetry) {
        RsTimeout(Cmd) = MinJoinRetry;
    }

    if ((LONG)RsTimeout(Cmd) > MaxJoinRetry) {
        RsTimeout(Cmd) = MaxJoinRetry;
    }

    //
    // Add in the penalty from failed rpc calls, but not too long or too short.
    //
    Timeout = RsTimeout(Cmd) + Cxtion->Penalty;

    if ((LONG)Timeout < MinJoinRetry) {
        Timeout = MinJoinRetry;
    }

    if ((LONG)Timeout > MaxJoinRetry) {
        Timeout = MaxJoinRetry;
    }

    //
    // Inform the user that the join is taking a long time.
    // The user receives no notification if a join occurs in
    // a short time.
    //
    // A trigger scheduled cxtion will stop retrying once the
    // trigger interval goes off (usually in 15 minutes).
    //
    if (!(RsTimeout(Cmd) % (JOIN_RETRY_EVENT * MinJoinRetry))) {
        if (Cxtion->Inbound) {
            EPRINT4(EVENT_FRS_LONG_JOIN, Cxtion->Partner->Name, ComputerName,
                    Replica->Root, Cxtion->PartnerDnsName);
        } else {
            EPRINT4(EVENT_FRS_LONG_JOIN, ComputerName, Cxtion->Partner->Name,
                    Replica->Root, Cxtion->PartnerDnsName);
        }
    }

    //
    // This command will come back to us in a bit
    //
    FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, Timeout);
}


VOID
RcsJoinCxtion(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Kick off the commands needed to join with our in/outbound partners.

    Joining an inbound partner is a two step process.  First, we pass a
    command to the inbound log process to allow it to scan the inbound log
    for any change orders from this connection.  These change orders are
    inserted on the CO process queue so we preserve ordering with new change
    orders that arrive after the Join completes.  In addtion we extract the
    the sequence number and change order ID of the last change order we have
    pending from this inbound partner.  Second, we send the join request to
    the inbound partner.  This same path is taken whether this is a clean
    startup or a startup after a crash.

    JOINING:
        UNJOINED        -> UNJOINED ask our partner if it is alive
        UNJOINED        -> START our partner responded
        START           -> STARTING call ChgOrdStartJoinRequest()
        STARTING        -> SCANNING (when chgord starts inlog scan)
        SCANNING        -> SENDJOIN (when chgord completes inlog scan)
        SENDJOIN        -> WAITJOIN (when join sent to partner)
        WAITJOIN        -> JOINED (when partner responds)

    UNJOINING
        STARTING        |
        SCANNING        |
        SENDJOIN        |
        WAITJOIN        -> UNJOINING (wait for remote change orders to retry)
        UNJOINING       -> UNJOINED (no more remote change orders)
        UNJOINED        -> DELETED (cxtion has been deleted)

Arguments:

    Replica -- ptr to the Replica struct
    Cxtion -- ptr to the connection struct we are talking to.

Return Value:
    True if if ReJoin is needed.

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsJoinCxtion:"
    PREPLICA       Replica;
    PCXTION        Cxtion;
    PCOMM_PACKET   CPkt;
    ULONG          CmdCode;
    DWORD          CQIndex;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsJoinCxtion entry1");

    //
    // Find and check the cxtion
    //
    Cxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS);
    if (!Cxtion) {
        return;
    }

    CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, RcsJoinCxtion entry2");


    //
    // This is our periodic join command packet
    //     - clear the reference
    //     - Ignore if the cxtion has successfully joined;
    //       our partner will inform us if there is a state change.
    //     - ignore if the replica set is in seeding state and this
    //       connection has been paused by the initial sync command server.
    //
    if (Cxtion->JoinCmd == Cmd) {
        Cxtion->JoinCmd = NULL;
        if ((CxtionStateIs(Cxtion, CxtionStateJoined) &&
            !CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN)) ||
            (BooleanFlagOn(Replica->CnfFlags,CONFIG_FLAG_SEEDING) &&
             CxtionFlagIs(Cxtion,CXTION_FLAGS_PAUSED))) {
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            return;
        }
    }

    //
    // Don't bother joining if the service is shutting down
    //
    if (FrsIsShuttingDown) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // Get lock to sync with change order accept
    //
    LOCK_CXTION_TABLE(Replica);

    switch (GetCxtionState(Cxtion)) {
        case CxtionStateInit:
            //
            // Not setup, yet. Ignore
            //
            DPRINT1(4, ":X: Cxtion isn't inited at join: "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                SetCxtionState(Cxtion, CxtionStateDeleted);
            }
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        case CxtionStateUnjoined:
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);

            //
            // Cxtion is deleted; nevermind
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                SetCxtionState(Cxtion, CxtionStateDeleted);
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            //
            // Schedule is off; nevermind
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_SCHEDULE_OFF)) {
                DPRINT1(4, ":X: Schedule is off at join: "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            //
            // Replica is deleted; nevermind
            //
            if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
                DPRINT1(4, ":S: Replica deleted at join: "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            //
            // Send our join info to our inbound partner or request an outbound
            // partner to start a join. Don't send anything if this is the
            // journal cxtion.
            //
            // Do not join with a downstream partner if this replica is still
            // seeding and is not online.
            //
            if (Cxtion->Inbound) {
                if (Cxtion->JrnlCxtion) {
                    DPRINT1(4, "DO NOT Send CMD_START_JOIN to jrnl cxtion: "FORMAT_CXTION_PATH2"\n",
                            PRINT_CXTION_PATH2(Replica, Cxtion));
                } else {
                    DPRINT1(4, ":X: Send CMD_NEED_JOIN to inbound: "FORMAT_CXTION_PATH2"\n",
                            PRINT_CXTION_PATH2(Replica, Cxtion));
                }
            } else {
                if ((BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) ||
                    Replica->IsSeeding) &&
                    !BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE)) {
                    DPRINT1(4, ":X: DO NOT Send CMD_START_JOIN until we are Online: "FORMAT_CXTION_PATH2"\n",
                            PRINT_CXTION_PATH2(Replica, Cxtion));
                } else {
                    DPRINT1(4, ":X: Send CMD_START_JOIN to outbound: "FORMAT_CXTION_PATH2"\n",
                            PRINT_CXTION_PATH2(Replica, Cxtion));
                }
            }

            //
            // Journal cxtions transition from unjoined to joined w/o
            // any intervening states UNLESS someone adds code at
            // this point to activate the journal for this set. But
            // that would require a rewrite of the journal startup
            // subsystem. Which may happen...
            //
            if (Cxtion->JrnlCxtion) {
                DPRINT1(0, ":X: ***** JOINED    "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));
                CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, JOINED");
                SetCxtionState(Cxtion, CxtionStateJoined);
                SndCsCreateCxtion(Cxtion);
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }
            //
            // Do not join with a downstream partner if this replica is still
            // seeding and is not online. Do not send a join if this
            // is a journal cxtion. Do not join if there is already an
            // active join request outstanding.
            //
            // The SndCs and the ReplicaCs cooperate to limit the
            // number of active join "pings" so that the Snd threads
            // are not hung waiting for pings to dead servers to
            // time out.
            //
            if (!Cxtion->ActiveJoinCommPkt &&
                !Cxtion->JrnlCxtion &&
                (Cxtion->Inbound ||
                 BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE) ||
                 (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) &&
                  !Replica->IsSeeding))) {

                //
                // Increment the Join Notifications sent counter for
                // both the replica set and connection objects
                //
                PM_INC_CTR_CXTION(Cxtion, JoinNSent, 1);
                PM_INC_CTR_REPSET(Replica, JoinNSent, 1);

                //
                // Assign a comm queue if none has been assigned.  A cxtion
                // must use the same comm queue for a given session (join guid)
                // to maintain packet order.  Old packets have an invalid join
                // guid and are either not sent or ignored on the receiving side.
                //
                if (!Cxtion->CommQueueIndex) {
                    Cxtion->CommQueueIndex = SndCsAssignCommQueue();
                }
                //
                // Partner is considered slow-to-respond if the last
                // rpc calls are erroring off and their cumulative
                // timeouts are greater than MinJoinRetry.
                //
                // BUT, Don't reassign the cxtion's queue index because,
                // if this is an outbound cxtion, the flush-at-join
                // logic needs to know the old queue index so that it
                // flushes the correct queue.
                //
                CQIndex = Cxtion->CommQueueIndex;
                if ((LONG)Cxtion->Penalty > MinJoinRetry) {
                    CQIndex = 0;
                }
                CmdCode = (Cxtion->Inbound) ? CMD_NEED_JOIN : CMD_START_JOIN;
                CPkt = CommBuildCommPkt(Replica, Cxtion, CmdCode, NULL, NULL, NULL);
                //
                // The SndCs and the ReplicaCs cooperate to limit the
                // number of active join "pings" so that the Snd threads
                // are not hung waiting for pings to dead servers to
                // time out.
                //
                Cxtion->ActiveJoinCommPkt = CPkt;
                SndCsSubmitCommPkt(Replica, Cxtion, NULL, NULL, FALSE, CPkt, CQIndex);
            }

            //
            // Keep trying an inbound cxtion but try the outbound connection
            // only once. The outbound partner will keep trying the join and
            // the connection will eventually join.
            //
            if (Cxtion->Inbound) {
                RcsJoinCxtionLater(Replica, Cxtion, Cmd);
            } else {
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            }

            break;


        case CxtionStateStart:
            //
            // Unjoined and our partner has responed; start the join
            //
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);

            //
            // Cxtion is deleted; nevermind
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                SetCxtionState(Cxtion, CxtionStateDeleted);
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            //
            // Schedule is off; nevermind
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_SCHEDULE_OFF)) {
                DPRINT1(4, ":X: Schedule is off at join: "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            //
            // Replica is deleted; nevermind
            //
            if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
                DPRINT1(4, ":X: Replica deleted at join: "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            if (Cxtion->Inbound) {
                //
                // Tell the inbound log subsystem to initialize for a Join with
                // an inbound partner.  When it begins processing the request it
                // sets the state to STARTING.  When it completes it sets the
                // state to SENDJOIN and sends a CMD_JOIN_CXTION command.
                //
                // We need our join guid at this time because the change
                // orders are stamped with the join guid during change order
                // accept. Mismatched joinguids result in a unjoin-with-
                // retry call so that old change orders can drain out
                // of change order accept and into the replica command
                // server after a cxtion is unjoined and joined again.
                //
                SetCxtionState(Cxtion, CxtionStateStarting);
                SndCsCreateCxtion(Cxtion);

                //
                // ** DEADLOCK WARNING **
                // The connection table lock must be unlocked before the request is
                // put on the change order process queue.  This is because the
                // change order accept thread locks the process queue while it is
                // considering the issue state of the head entry.  If the CO it is
                // trying to issue is for a connection being restarted it will wait
                // until the cxtion starts otherwise the subsequent fetch request by
                // the CO would just fail.  While change_order_accept has the queue
                // lock it then acquires the cxtion table lock.  Thus two threads
                // are acquiring two locks in different orders causing deadlock.
                //
                UNLOCK_CXTION_TABLE(Replica);
                ChgOrdStartJoinRequest(Replica, Cxtion);
                LOCK_CXTION_TABLE(Replica);
                ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            }
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        case CxtionStateStarting:
        case CxtionStateScanning:
            //
            // Join in process; our inbound partner will be informed later
            //
            DPRINT1(4, ":X: Scanning at join: "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        case CxtionStateSendJoin:
        case CxtionStateWaitJoin:
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            //
            // Replica is deleted,
            // The cxtion needs to be unjoined, or
            // The cxtion needs to be deleted
            //      Unjoin
            //
            if (!IS_TIME_ZERO(Replica->MembershipExpires) ||
                CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN) ||
                CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                break;
            }

            //
            // Send our join info to our inbound partner
            //
            // This request times out if our partner doesn't answer.
            //
            DPRINT1(4, ":X: Send join info at send/wait join: "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            SetCxtionState(Cxtion, CxtionStateWaitJoin);

            //
            // Increment the Join Notifications sent counter for
            // both the replica set and connection objects
            //
            PM_INC_CTR_CXTION(Cxtion, JoinNSent, 1);
            PM_INC_CTR_REPSET(Replica, JoinNSent, 1);


            CPkt = CommBuildCommPkt(Replica, Cxtion, CMD_JOINING, Replica->VVector, NULL, NULL);
            SndCsSubmitCommPkt2(Replica, Cxtion, NULL, TRUE, CPkt);
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        case CxtionStateJoined:
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            //
            // Replica is deleted,
            // The cxtion needs to be unjoined, or
            // The cxtion needs to be deleted
            //      Unjoin
            //
            if (!IS_TIME_ZERO(Replica->MembershipExpires) ||
                CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN) ||
                CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                break;
            }

            //
            // Refresh our inbound partner's join state (with timeout)
            //
            if (Cxtion->Inbound && !Cxtion->JrnlCxtion) {
                DPRINT1(4, ":X: send join info at join: "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));

                //
                // Increment the Join Notifications sent counter for
                // both the replica set and connection objects
                //
                PM_INC_CTR_CXTION(Cxtion, JoinNSent, 1);
                PM_INC_CTR_REPSET(Replica, JoinNSent, 1);

                CPkt = CommBuildCommPkt(Replica, Cxtion, CMD_JOINING, Replica->VVector, NULL, NULL);
                SndCsSubmitCommPkt2(Replica, Cxtion, NULL, TRUE, CPkt);
            }
            //
            // Already joined; nothing to do
            //
            DPRINT1(4, ":X: Joined at join: "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        case CxtionStateUnjoining:
            //
            // Ignore requests to join while unjoining so that we don't
            // end up with multiple inbound log scans. If this join
            // request originated from our partner then the caller
            // will set the CXTION_FLAGS_DEFERRED_JOIN and the join
            // will start at the transition from UNJOINING to UNJOINED.
            //
            DPRINT1(4, ":X: Unjoining at join: "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        case CxtionStateDeleted:
            //
            // Deleted; nothing to do
            //
            DPRINT1(4, ":X: Cxtion is deleted at join: "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;


        default:
            //
            // ?
            //
            DPRINT2(0, ":X: ERROR - bad state %d for "FORMAT_CXTION_PATH2"\n",
                    GetCxtionState(Cxtion),
                    PRINT_CXTION_PATH2(Replica, Cxtion));
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;
    }
    UNLOCK_CXTION_TABLE(Replica);
}



VOID
RcsEmptyPreExistingDir(
    IN PREPLICA Replica
    )
/*++

Routine Description:

    Delete empty directories in the preexisting directory, inclusive.

    WARN: The replica set must be filtering the preexisting directory.

Arguments:

    Replica - The replica is filtering the preexisting directory.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "RcsEmptyPreExistingDir:"
    ULONG       WStatus;
    PWCHAR      PreExistingPath     = NULL;

    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, RcsEmptyPreExistingDir entry");

    //
    // Not if the set isn't open
    //
    if (!Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, RcsEmptyPreExistingDir: not open");
        return;
    }
    //
    // Not if the set isn't journaling
    //
    if (!Replica->IsJournaling) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, RcsEmptyPreExistingDir: not journaling");
        return;
    }

    //
    // Empty the preexisting directory (continue on error)
    //
    PreExistingPath = FrsWcsPath(Replica->Root, NTFRS_PREEXISTING_DIRECTORY);
    WStatus = FrsDeletePath(PreExistingPath,
                            ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE |
                            ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY);
    DPRINT1_WS(3, "++ ERROR - FrsDeletePath(%ws) (IGNORED);", PreExistingPath, WStatus);

    REPLICA_STATE_TRACE(3, NULL, Replica, WStatus, "W,  RcsEmptyPreExistingDir: done");
    FrsFree(PreExistingPath);
}


VOID
RcsOpenReplicaSetMember(
    IN PREPLICA Replica
    )
/*++
Routine Description:

    Open a replica set.

Arguments:

    Replica -- ptr to a REPLICA struct

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsOpenReplicaSetMember:"
    ULONG                   WStatus;
    PCOMMAND_PACKET         Cmd = NULL;


    Replica->FStatus = FrsErrorSuccess;


    if (Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Replica already open");
        return;
    }

    //
    // Submit an open
    //
    Cmd = DbsPrepareCmdPkt(NULL,                 //  Cmd,
                           Replica,              //  Replica,
                           CMD_OPEN_REPLICA_SET_MEMBER, //  CmdRequest,
                           NULL,                 //  TableCtx,
                           NULL,                 //  CallContext,
                           0,                    //  TableType,
                           0,                    //  AccessRequest,
                           0,                    //  IndexType,
                           NULL,                 //  KeyValue,
                           0,                    //  KeyValueLength,
                           FALSE);               //  Submit

    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "Submit DB OPEN_REPLICA_SET_MEMBER");

    //
    // SUBMIT DB Cmd and wait for completion.
    //
    WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
    Replica->FStatus = Cmd->Parameters.DbsRequest.FStatus;

    REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->FStatus, "F, OPEN_REPLICA_SET_MEMBER return");

    //
    // If wait or database op failed
    //
    if (!WIN_SUCCESS(WStatus) || !FRS_SUCCESS(Replica->FStatus)) {
        //
        // If wait / submit failed then let caller know cmd srv submit failed.
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            Replica->FStatus = FrsErrorCmdSrvFailed;
        }

        DPRINT2_FS(0, ":S: ERROR - %ws\\%ws: Open Replica failed;",
                Replica->SetName->Name, Replica->MemberName->Name, Replica->FStatus);

        DPRINT_WS(0, "ERROR: Open Replica DB Command failed", WStatus);

        goto out;
    }

    Replica->IsOpen = FRS_SUCCESS(Replica->FStatus);

out:
    if (Cmd) {
        FrsFreeCommand(Cmd, NULL);
    }
}


VOID
RcsInitOneReplicaSet(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Open a replica set.

Arguments:
    Replica -- ptr to a REPLICA struct

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsInitOneReplicaSet:"
    ULONG  FStatus;

    //
    // Already journaling; done
    //
    if (Replica->IsJournaling) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, IsJournaling True");
        return;
    }

    if (!Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, IsOpen False");
        return;
    }

    //
    // Don't retry if in journal wrap error state error
    //
    if (Replica->ServiceState == REPLICA_STATE_JRNL_WRAP_ERROR) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, In Jrnl Wrap Error State");
        return;
    }

    //
    // Otherwise set it to the initializing state.
    //
    if (REPLICA_IN_ERROR_STATE(Replica->ServiceState)) {
        JrnlSetReplicaState(Replica, REPLICA_STATE_INITIALIZING);
    }

    //
    // Don't start journaling if the preinstall directory is unavailable
    //
    if (!HANDLE_IS_VALID(Replica->PreInstallHandle)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, No PreInstallHandle");
        return;
    }

    //
    // Initialize the DB and Journal subsystems for this replica set.
    //
    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, DbsInitOneReplicaSet call");

    FStatus = DbsInitOneReplicaSet(Replica);

    REPLICA_STATE_TRACE(3, NULL, Replica, FStatus, "F, DbsInitOneReplicaSet return");

}


VOID
RcsJoiningAfterFlush(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:

    A downstream partner (X) sent this JOINING request to us.  We are its
    inbound partner.  We should have a corresponding outbound connection
    for X.  If we do and the replication schedule allows we activate the
    outbound log partner and ack the Joining request with CMD_JOINED.

    This command packet was first placed on the SndCs's queue by
    RcsJoining() so that all of the old comm packets with the
    old join guid have been discarded. This protocol is needed because
    this function may REJOIN and revalidate the old join guid. Packets
    still on the send queue would then be sent out of order.

    NOTE:

    Activating the OUTLOG partner before sending the JOINED cmd to the partner
    can cause COs to be sent to the partner before it sees the JOINED cmd.
    Since the JoinGuid matches in the sent change orders the partner accepts
    them and queues them to the change order process queue.  If this CO gets to
    the head of the process queue the issue logic in ChgOrdAccept will
    block the queue waiting for the connection to go to the JOINED state.  When
    the JOINED cmd arrives it is processed by RcsInboundJoined() which sets the
    connection state to JOINED and unblocks the change order process queue.

    We can't send the JOINED cmd first because the partner may then send back
    a fetch request before we think it has joined.  The JOINED cmd must always
    be sent so the partner knows it can start sending fetch cmds because we
    may have no outbound COs to send.  In addtion the JOINED command contains
    the new value for LastJoinedTime that is saved in the connection record
    for the next join request.

    NOTE:

    Cxtion activation should always come from the downstream partner.  Only they
    know if a VVJoin is required because of a database re-init or restore.
    Otherwise we will just continue sending from the last unacked CO in the log.
    At best we can notify outbound partners we are now available to provide
    change orders (via CMD_JOIN_RESEND)

Arguments:

    Cmd

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsJoiningAfterFlush:"
    ULONGLONG       Delta;
    ULONG           FStatus;
    PREPLICA        Replica;
    PCXTION         OutCxtion;
    PCOMM_PACKET    CPkt;
#define  CXTION_STR_MAX  256
    WCHAR           CxtionStr[CXTION_STR_MAX];
    WCHAR           WSkew[15], WDelta[15];
    CHAR            UpstreamTimeStr[TIME_STRING_LENGTH];
    CHAR            DownstreamTimeStr[TIME_STRING_LENGTH];

    PVOID           Key;
    PGEN_ENTRY      Entry;
    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK |
                                  CHECK_CMD_REPLICA_VERSION_GUID |
                                  CHECK_CMD_JOINTIME |
                                  CHECK_CMD_NOT_EXPIRED)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsJoiningAfterFlush entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS   |
                                            CHECK_CXTION_OUTBOUND |
                                            CHECK_CXTION_PARTNER |
                                            CHECK_CXTION_AUTH);
    if (!OutCxtion) {
        return;
    }

    //
    // Shutting down; ignore join request
    //
    if (FrsIsShuttingDown) {
        CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, FrsIsShuttingDown");
        FrsCompleteCommand(Cmd, ERROR_OPERATION_ABORTED);
        return;
    }

    //
    // Do not join with a downstream partner if this replica is still
    // seeding and is not online.
    //
    if ((BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) ||
        Replica->IsSeeding) &&
        !BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE)) {
        CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, Seeding and Offline");
        FrsCompleteCommand(Cmd, ERROR_RETRY);
        return;
    }

    //
    // Already joined; should we rejoin?
    //
    if (CxtionStateIs(OutCxtion, CxtionStateJoined)) {
        //
        // Don't rejoin if this is a retry by our outbound partner
        //
        if (GUIDS_EQUAL(&OutCxtion->JoinGuid,  RsJoinGuid(Cmd)) &&
            CxtionFlagIs(OutCxtion, CXTION_FLAGS_JOIN_GUID_VALID)) {
            //
            // Tell our outbound partner that we have rejoined successfully
            // Increment the Joins counter for
            // both the replica set and connection objects
            //
            PM_INC_CTR_CXTION(OutCxtion, Joins, 1);
            PM_INC_CTR_REPSET(Replica, Joins, 1);

            CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, REJOINED");
            DPRINT1(0, ":X: ***** REJOINED  "FORMAT_CXTION_PATH2"\n",
                    PRINT_CXTION_PATH2(Replica, OutCxtion));

            CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_JOINED, NULL, NULL, NULL);
            SndCsSubmitCommPkt2(Replica, OutCxtion, NULL, FALSE, CPkt);

            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            return;
        }

        //
        // Unjoin and rejoin.  Partner may have restarted.
        // WARN: forcing an unjoin of an outbound cxtion works
        // because outbound cxtions transition from Joined to
        // Unjoined with no intervening states.
        //
        FStatus = RcsForceUnjoin(Replica, OutCxtion);
        CXTION_STATE_TRACE(3, OutCxtion, Replica, FStatus, "F, RcsForceUnjoin return");

        if (!FRS_SUCCESS(FStatus)) {
            DPRINT_FS(0, ":X: ERROR - return from RcsForceUnjoin:", FStatus);
            FrsCompleteCommand(Cmd, ERROR_REQUEST_ABORTED);
            return;
        }
    }
    //
    // Machines can't join if their times are badly out of sync
    // UNLESS this is a VOLATILE cxtion (I.e., sysvol seeding).
    //
    // Compare the time when the packet was built by our partner and the time
    // when we received the packet.
    // Time in 100nsec tics since Jan 1, 1601
    //
    if (*RsCommPktRcvTime(Cmd) > *RsJoinTime(Cmd)) {
        Delta = *RsCommPktRcvTime(Cmd) - *RsJoinTime(Cmd);
    } else {
        Delta = *RsJoinTime(Cmd) - *RsCommPktRcvTime(Cmd);
    }

    //
    // Ignore out-of-sync times if this is a volatile cxtion. Volatile
    // cxtions are only used for sysvol seeding where times don't matter.
    //
    if (!CxtionFlagIs(OutCxtion, CXTION_FLAGS_VOLATILE) &&
        (Delta > MaxPartnerClockSkew)) {
        Delta = Delta / CONVERT_FILETIME_TO_MINUTES;
        DPRINT1(0, ":X: ERROR - Joining CommPkt receive time is %08x %08x\n", PRINTQUAD(*RsCommPktRcvTime(Cmd)));
        DPRINT1(0, ":X: ERROR - Joining CommPkt send time on partner is %08x %08x\n", PRINTQUAD(*RsJoinTime(Cmd)));

        _snwprintf(CxtionStr, CXTION_STR_MAX, FORMAT_CXTION_PATH2W,
                   PRINT_CXTION_PATH2(Replica, OutCxtion));
        CxtionStr[CXTION_STR_MAX-1] = UNICODE_NULL;

        _itow(PartnerClockSkew, WSkew, 10);
        _itow((LONG)Delta, WDelta, 10);

        EPRINT3(EVENT_FRS_JOIN_FAIL_TIME_SKEW, WSkew, CxtionStr, WDelta);

        DPRINT2(0, ":X: ERROR - Cannot join (%ws) clocks are out of sync by %d minutes\n",
               CxtionStr, (LONG)Delta);

        DPRINT(0, ":X: Note: If this time difference is close to a multiple of 60 minutes then it\n");
        DPRINT(0, ":X: is likely that either this computer or its partner computer was set to the\n");
        DPRINT(0, ":X: incorrect time zone when the computer time was initially set.  Check that both \n");
        DPRINT(0, ":X: the time zones and the time is set correctly on both computers.\n");

        FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
        return;
    }

    //
    // Grab the new version vector. Initialize an empty version vector
    // if our outbound partner did not send a version vector. Our partner
    // simply does not yet have any entries in his version vector.
    //
    OutCxtion->VVector = (RsVVector(Cmd) != NULL) ?
                          RsVVector(Cmd) : GTabAllocTable();
    RsVVector(Cmd) = NULL;

    //
    // Grab the compression table from the outbound partner.
    // This table is a list of guids 1 for each compression format that
    // the partner supports.
    //

    OutCxtion->CompressionTable = (RsCompressionTable(Cmd) != NULL) ?
                                   RsCompressionTable(Cmd) : GTabAllocTable();

    DPRINT1(4, "Received following compression table from %ws.\n", OutCxtion->PartnerDnsName);

    GTabLockTable(OutCxtion->CompressionTable);
    Key = NULL;
    while (Entry = GTabNextEntryNoLock(OutCxtion->CompressionTable, &Key)) {

        FrsPrintGuid(Entry->Key1);
    }
    GTabUnLockTable(OutCxtion->CompressionTable);

    RsCompressionTable(Cmd) = NULL;


    //
    // Assign the join guid and comm queue to this cxtion.
    //
    DPRINT1(4, ":X: %ws: Assigning join guid.\n", OutCxtion->Name->Name);
    COPY_GUID(&OutCxtion->JoinGuid, RsJoinGuid(Cmd));

    SetCxtionFlag(OutCxtion, CXTION_FLAGS_JOIN_GUID_VALID |
                             CXTION_FLAGS_UNJOIN_GUID_VALID);
    //
    // Assign a comm queue. A cxtion must use the same comm queue
    // for a given session (join guid) to maintain packet order.
    // Old packets have an invalid join guid and are either not
    // sent or ignored on the receiving side.
    //
    OutCxtion->CommQueueIndex = SndCsAssignCommQueue();

    VV_PRINT_OUTBOUND(4, OutCxtion->Partner->Name, OutCxtion->VVector);

    //
    // Use the last join time to check if the connection is a new connection.
    // If the connection on upstream or the connection on downstream is new
    // then force a vvjoin. Upstream may have deleted the connection because
    // the downstream did not join for a week (Outlog change history time).
    // When the database on downstream or upstream is restored both will have
    // valid times but we want a vvjoin at that time. We don't support restoring
    // old FRS database so we will not worry about that scenario here.
    // We used to just compare LastJoinTimes and force vvjoin if they didn't
    // match but that can result in unnecessary vvjoins. (Customer reported problem)
    //
    // For E.g. If the upstream crashed when it was in this function at the point
    // where it had initialized a new LastJoinTime but before it sent the CMD_JOINED
    // packet to the downstream then when the downstream joins later LastJoinTime
    // will not match and a vvjoin will be performed unnecessarily.
    //

    FileTimeToString((PFILETIME) &OutCxtion->LastJoinTime, UpstreamTimeStr);
    FileTimeToString((PFILETIME) &RsLastJoinTime(Cmd), DownstreamTimeStr);
    CXTION_STATE_TRACE(4, OutCxtion, Replica, 0, "LastJoinTime Check");
    DPRINT2(4, ":X: Upstream (This Computer) LastJoinTime = %s ; Downstream LastJoinTime = %s\n", UpstreamTimeStr,DownstreamTimeStr);
    if ((RsLastJoinTime(Cmd) == (ULONGLONG) 1) || 
        (OutCxtion->LastJoinTime == (ULONGLONG) 1)) {
        CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, LastJoinTime Mismatch, force VVJoin");
        SetCxtionFlag(OutCxtion, CXTION_FLAGS_PERFORM_VVJOIN);
    }

    //
    // Our partner's replica version guid (aka originator guid) used
    // for dampening requests to our partner.
    //
    COPY_GUID(&OutCxtion->ReplicaVersionGuid, RsReplicaVersionGuid(Cmd));

    //
    // REPLICA JOINED
    //
    SetCxtionState(OutCxtion, CxtionStateJoined);

    //
    // Inform the user that a long join has finally completed.
    // The user receives no notification if a join occurs in a short time.
    //
    if (OutCxtion->JoinCmd &&
        (LONG)RsTimeout(OutCxtion->JoinCmd) > (JOIN_RETRY_EVENT * MinJoinRetry)) {
        if (OutCxtion->Inbound) {
            EPRINT3(EVENT_FRS_LONG_JOIN_DONE,
                    OutCxtion->Partner->Name, ComputerName, Replica->Root);
        } else {
            EPRINT3(EVENT_FRS_LONG_JOIN_DONE,
                    ComputerName, OutCxtion->Partner->Name, Replica->Root);
        }
    }

    //
    // Tell the Outbound Log that this partner has joined. This call is synchronous.
    //
#if     DBG
    //
    // Always VvJoin
    if (DebugInfo.ForceVvJoin) {
        SetCxtionFlag(OutCxtion, CXTION_FLAGS_PERFORM_VVJOIN);
    }
#endif  DBG
    FStatus = OutLogSubmit(Replica, OutCxtion, CMD_OUTLOG_ACTIVATE_PARTNER);

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, OUTLOG_ACTIVATE_PARTNER return");

    if (!FRS_SUCCESS(FStatus)) {
        //
        // Could not enable outbound log processing for this cxtion
        //
        DPRINT_FS(0, "++ ERROR - return from CMD_OUTLOG_ACTIVATE_PARTNER:", FStatus);
        RcsForceUnjoin(Replica, OutCxtion);
        FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
        return;
    }
    //
    // OUTBOUND LOG PROCESSING HAS BEEN ENABLED
    //

    //
    // Tell our outbound partner that we are ready to go.
    //
    // WARN: comm packets may have already been sent to our partner once we
    // activated outlog processing above.  In that case, our partner treated
    // the packet as an implicit CMD_JOINED and completed the join.  This
    // packet is then ignored as an extraneous join request except that it
    // causes our partner to update the last joined time to match ours.
    //
    // Increment the Joins counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(OutCxtion, Joins, 1);
    PM_INC_CTR_REPSET(Replica, Joins, 1);

    DPRINT1(0, ":X: ***** JOINED    "FORMAT_CXTION_PATH2"\n",
            PRINT_CXTION_PATH2(Replica, OutCxtion));

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, JOINED");
    //
    // Update the DB cxtion table record with the new Join Time.
    //
    // *NOTE*  The following call is synchronous.  If we have the Cxtion
    //         table lock then a hang is possible.
    //
    GetSystemTimeAsFileTime((PFILETIME)&OutCxtion->LastJoinTime);
    InterlockedIncrement(&Replica->OutLogCxtionsJoined);
    DPRINT1(4, "TEMP: OutLogCxtionsJoined  %d\n", Replica->OutLogCxtionsJoined);

    FStatus = OutLogSubmit(Replica, OutCxtion, CMD_OUTLOG_UPDATE_PARTNER);
    CXTION_STATE_TRACE(3, OutCxtion, Replica, FStatus, "F, OUTLOG_UPDATE_PARTNER return");
    if (!FRS_SUCCESS(FStatus)) {
        DPRINT3(0, "++ WARN changes to cxtion %ws (to %ws, %ws) not updated in database\n",
                OutCxtion->Name->Name, OutCxtion->Partner->Name, Replica->ReplicaName->Name);
    }


    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, Cxtion JOINED, xmit resp");

    CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_JOINED, NULL, NULL, NULL);
    SndCsSubmitCommPkt2(Replica, OutCxtion, NULL, FALSE, CPkt);
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);

    //
    // Inject a end-of-opt-vvjoin control co if this cxtion is in the
    // OptVVJoinMode. This co is used to send a fake vvjoindone to downstream
    // so it can transition out of initsync state.
    //
    OutLogAcquireLock(Replica);

    if ((OutCxtion->OLCtx != NULL) && InOptVVJoinMode(OutCxtion->OLCtx)) {
        ChgOrdInjectControlCo(Replica, OutCxtion, FCN_CO_END_OF_OPTIMIZED_VVJOIN);
    }

    //
    // Inject a end-of-join control co if this cxtion is using a trigger
    // schedule. Note that the EndOfJoin Co may have been processed by
    // the time this call returns.
    //
    if (CxtionFlagIs(OutCxtion, CXTION_FLAGS_TRIGGER_SCHEDULE)) {
        if (OutCxtion->OLCtx &&
            !InVVJoinMode(OutCxtion->OLCtx) &&
            CxtionStateIs(OutCxtion, CxtionStateJoined)) {
            ChgOrdInjectControlCo(Replica, OutCxtion, FCN_CO_END_OF_JOIN);
        }
    }

    OutLogReleaseLock(Replica);
}


VOID
RcsJoining(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:

    A downstream partner (X) sent this JOINING request to us.  We are its
    inbound partner.  We should have a corresponding outbound connection
    for X.  If we do and the replication schedule allows we activate the
    outbound log partner and ack the Joining request with CMD_JOINED.

    This command packet is first put on the SndCs's(Send Command Server)
    queue so that all of the old comm packets with the old join guid
    will have been discarded. This protocol is needed because this
    function may REJOIN and revalidate the old join guid. Packets
    still on the send queue would then be sent out of order.

    The command packet is sent to RcsJoiningAfterFlush() after
    bubbling up to the top of the send queue.

Arguments:

    Cmd

Return Value:

    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsJoining:"
    ULONG           FStatus;
    PREPLICA        Replica;
    PCXTION         OutCxtion;
    PCOMM_PACKET    CPkt;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK |
                                  CHECK_CMD_REPLICA_VERSION_GUID |
                                  CHECK_CMD_JOINTIME |
                                  CHECK_CMD_NOT_EXPIRED)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsJoining entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS   |
                                            CHECK_CXTION_OUTBOUND |
                                            CHECK_CXTION_PARTNER |
                                            CHECK_CXTION_AUTH);
    if (!OutCxtion) {
        return;
    }

    //
    // Increment the Join Notifications Received counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(OutCxtion, JoinNRcvd, 1);
    PM_INC_CTR_REPSET(Replica, JoinNRcvd, 1);

    //
    // Shutting down; ignore join request
    //
    if (FrsIsShuttingDown) {
        FrsCompleteCommand(Cmd, ERROR_OPERATION_ABORTED);
        return;
    }

    //
    // Do not join with a downstream partner if this replica is still
    // seeding and is not online.
    //
    if ((BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) ||
        Replica->IsSeeding) &&
        !BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE)) {
        FrsCompleteCommand(Cmd, ERROR_RETRY);
        return;
    }
    //
    // Put this command packet at the end of this cxtion's send queue.  Once it
    // bubbles up to the top the command packet will be sent back to this
    // command server with the ccommand CMD_JOINING_AFTER_FLUSH and will be
    // given to RcsJoiningAfterFlush() for processing.
    //
    Cmd->Command = CMD_JOINING_AFTER_FLUSH;
    SndCsSubmitCmd(Replica,
                   OutCxtion,
                   &ReplicaCmdServer,
                   Cmd,
                   OutCxtion->CommQueueIndex);
}


VOID
RcsNeedJoin(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our outbound partner has sent this packet to see if we are alive.
    Respond with a start-your-join packet.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsNeedJoin:"
    PREPLICA        Replica;
    PCXTION         OutCxtion;
    PCOMM_PACKET    CPkt;
    DWORD           CQIndex;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA |
                                  CHECK_CMD_CXTION |
                                  CHECK_CMD_NOT_EXPIRED)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsNeedJoin entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS   |
                                            CHECK_CXTION_OUTBOUND |
                                            CHECK_CXTION_PARTNER  |
                                            CHECK_CXTION_AUTH);
    if (!OutCxtion) {
        return;
    }

    //
    // Increment the Join Notifications Received counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(OutCxtion, JoinNRcvd, 1);
    PM_INC_CTR_REPSET(Replica, JoinNRcvd, 1);

    //
    // Do not join with a downstream partner if this replica is still
    // seeding and is not online.
    //

    if ((!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) &&
        !Replica->IsSeeding) ||
        BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE)) {

        CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, Xmit START_JOIN req");

        CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_START_JOIN, NULL, NULL, NULL);
        CQIndex = OutCxtion->CommQueueIndex;
        SndCsSubmitCommPkt(Replica, OutCxtion, NULL, NULL, FALSE, CPkt, CQIndex);
    }

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsStartJoin(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our inbound partner has sent this packet to tell us it is alive
    and that the join can be started.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsStartJoin:"
    PREPLICA        Replica;
    PCXTION         InCxtion;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA |
                                  CHECK_CMD_CXTION |
                                  CHECK_CMD_NOT_EXPIRED)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsStartJoin entry");

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS  |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_PARTNER |
                                           CHECK_CXTION_AUTH);
    if (!InCxtion) {
        return;
    }

    //
    // Increment the Join Notifications Received counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(InCxtion, JoinNRcvd, 1);
    PM_INC_CTR_REPSET(Replica, JoinNRcvd, 1);

    //
    // If this replica set is in seeding state and this connection is in
    // initial sync state then let the initial sync command server decide
    // how to respond to this START_JOIN. It will respond to one START_JOIN
    // at a time.
    //
    if (BooleanFlagOn(Replica->CnfFlags,CONFIG_FLAG_SEEDING) &&
        CxtionFlagIs(InCxtion,CXTION_FLAGS_INIT_SYNC)) {

        InitSyncCsSubmitTransfer(Cmd, CMD_INITSYNC_START_JOIN);
        return;
    }


    LOCK_CXTION_TABLE(Replica);


    //
    // If we were waiting for our partner to respond or think we
    // have already joined then either start the join process or
    // resend our join info.
    //
    // Otherwise, let the normal join flow take over. If there are
    // problems then the join will timeout and retry.
    //
    if (CxtionStateIs(InCxtion, CxtionStateUnjoined) ||
        CxtionStateIs(InCxtion, CxtionStateJoined)) {
        if (CxtionStateIs(InCxtion, CxtionStateUnjoined)) {
            SetCxtionState(InCxtion, CxtionStateStart);
        }
        //
        // Start the join process or resend the join info
        //
        UNLOCK_CXTION_TABLE(Replica);

        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, RcsJoinCxtion call");
        RcsJoinCxtion(Cmd);
    } else {
        UNLOCK_CXTION_TABLE(Replica);

        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, Cannot start join");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }
}


VOID
RcsSubmitReplicaCxtionJoin(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN BOOL     Later
    )
/*++
Routine Description:
    Submit a join command to a replica\cxtion.

    Build cmd pkt with Cxtion GName and replica ptr.  Submit to Replica cmd
    server.  Calls dispatch function and translates cxtion GName to cxtion ptr

    SYNCHRONIZATION -- Only called from the context of the
                       Replica Command Server. No locks needed.

Arguments:
    Replica     - existing replica
    Cxtion      - existing cxtion
    Later       - Delayed submission

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitReplicaCxtionJoin:"
    PCOMMAND_PACKET Cmd;



    //
    // The cxtion already has a join command outstanding; don't flood the
    // queue with extraneous requests.
    //
    if (Cxtion->JoinCmd) {
        return;
    }

    //
    // Not scheduled to run
    //
    if (CxtionFlagIs(Cxtion, CXTION_FLAGS_SCHEDULE_OFF)) {
        return;
    }

    //
    // Already joined; done
    //
    if (CxtionStateIs(Cxtion, CxtionStateJoined) &&
        !CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN)) {
        return;
    }

    //
    // Trigger schedules are managed by RcsCheckSchedules()
    //
    if (CxtionFlagIs(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE)) {
        return;
    }

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(Replica->Queue, CMD_JOIN_CXTION);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of replica set and new replica set
    //
    RsReplica(Cmd) = Replica;
    RsCxtion(Cmd) = FrsDupGName(Cxtion->Name);

    CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, RcsSubmitReplicaCxtionJoin entry");

    //
    // Cxtion should have just one join command outstanding
    //
    if (Later) {
        DPRINT5(4, "++ Submit LATER %08x for Cmd %08x %ws\\%ws\\%ws\n",
                Cmd->Command, Cmd, Replica->SetName->Name,
                Replica->MemberName->Name, Cxtion->Name->Name);

        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, RcsJoinCxtionLater call");
        RcsJoinCxtionLater(Replica, Cxtion, Cmd);
    } else {
        Cxtion->JoinCmd = Cmd;
        DPRINT5(4, "++ Submit %08x for Cmd %08x %ws\\%ws\\%ws\n",
                Cmd->Command, Cmd, Replica->SetName->Name,
                Replica->MemberName->Name, Cxtion->Name->Name);

        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Submit JOIN_CXTION req");
        FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
    }
}


ULONG
RcsResubmitActiveCOsOnCxtion(
    IN PREPLICA  Replica,
    IN PCXTION   Cxtion
    )
/*++
Routine Description:
    Remove the active change orders from this connection and resubmit them.
    This is done when downstream notices that the upstream has rejoined.
    It may have dropped a fetch request that we send causing us to hang for ever.

    Assumes: Caller has acquired the CXTION_TABLE lock.

Arguments:
    Replica - ptr to replica struct for this replica set.
    Cxtion - ptr to connection struct being unjoined.

Return Value:
    FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsResubmitActiveCOsOnCxtion:"

    PVOID               Key;
    PCHANGE_ORDER_ENTRY Coe;

    //
    // Take idle change orders through retry
    //
    LOCK_CXTION_COE_TABLE(Replica, Cxtion);

    Key = NULL;
    while (Coe = GTabNextDatumNoLock(Cxtion->CoeTable, &Key)) {

        if (CO_FLAG_ON(Coe, CO_FLAG_LOCALCO)) {
            CHANGE_ORDER_TRACE(3, Coe, "Do not ReSubmit Local COs");
        } else {

            FRS_ASSERT(CO_STATE_IS_LE(Coe, IBCO_FETCH_RETRY));

            CHANGE_ORDER_TRACE(3, Coe, "ReSubmit CO to fetch");
            Key = NULL;
            GTabDeleteNoLock(Cxtion->CoeTable, &Coe->Cmd.ChangeOrderGuid, NULL, NULL);
            RcsSubmitRemoteCoAccepted(Coe);
        }
    }

    UNLOCK_CXTION_COE_TABLE(Replica, Cxtion);

    return FrsErrorSuccess;
}


ULONG
RcsDrainActiveCOsOnCxtion(
    IN PREPLICA  Replica,
    IN PCXTION   Cxtion
    )
/*++
Routine Description:
    Remove the active change orders from this connection and send them
    thru retry.

    Assumes: Caller has acquired the CXTION_TABLE lock.

Arguments:
    Replica - ptr to replica struct for this replica set.
    Cxtion - ptr to connection struct being unjoined.

Return Value:
    FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsDrainActiveCOsOnCxtion:"

    PVOID               Key;
    PCHANGE_ORDER_ENTRY Coe;
    ULONG               FStatus = FrsErrorSuccess;

    //
    // Take idle change orders through retry
    //
    LOCK_CXTION_COE_TABLE(Replica, Cxtion);

    Key = NULL;
    while (Coe = GTabNextDatumNoLock(Cxtion->CoeTable, &Key)) {
        Key = NULL;
        GTabDeleteNoLock(Cxtion->CoeTable, &Coe->Cmd.ChangeOrderGuid, NULL, NULL);

        SET_COE_FLAG(Coe, COE_FLAG_NO_INBOUND);

        if (Cxtion->JrnlCxtion) {
            CHANGE_ORDER_TRACE(3, Coe, "Submit CO to stage gen retry");
            ChgOrdInboundRetry(Coe, IBCO_STAGING_RETRY);
        } else {
            CHANGE_ORDER_TRACE(3, Coe, "Submit CO to fetch retry");
            ChgOrdInboundRetry(Coe, IBCO_FETCH_RETRY);
        }
    }

    UNLOCK_CXTION_COE_TABLE(Replica, Cxtion);

    //
    // If there are no outstanding change orders that need to be taken through the
    // retry path, unjoin complete.  Otherwise, the unjoin will complete once
    // the count reaches 0.  Until then, further attempts to join will be
    // ignored.
    //
    if (Cxtion->ChangeOrderCount == 0) {
        SndCsDestroyCxtion(Cxtion, CXTION_FLAGS_UNJOIN_GUID_VALID);
        SetCxtionState(Cxtion, CxtionStateUnjoined);

        //
        // Increment the Unjoins counter for
        // both the replica set and connection objects
        //
        PM_INC_CTR_CXTION(Cxtion, Unjoins, 1);
        PM_INC_CTR_REPSET(Replica, Unjoins, 1);

        DPRINT1(0, ":X: ***** UNJOINED  "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, Cxtion));
        //
        // Deleted cxtion
        //
        if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
            SetCxtionState(Cxtion, CxtionStateDeleted);
        //
        // Rejoin if requested.
        //
        } else if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_JOIN)) {
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
            RcsSubmitReplicaCxtionJoin(Replica, Cxtion, TRUE);
        }
    } else {
        FStatus = FrsErrorUnjoining;
        DPRINT2(0, ":X: ***** UNJOINING "FORMAT_CXTION_PATH2" (%d cos)\n",
                PRINT_CXTION_PATH2(Replica, Cxtion), Cxtion->ChangeOrderCount);
    }

    return FStatus;
}


ULONG
RcsForceUnjoin(
    IN PREPLICA  Replica,
    IN PCXTION   Cxtion
    )
/*++
Routine Description:
    Unjoin this connection.

Arguments:
    Replica - ptr to replica struct for this replica set.
    Cxtion - ptr to connection struct being unjoined.

Return Value:
    FrsErrorStatus

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsForceUnjoin:"
    ULONG   FStatus = FrsErrorSuccess;
    CHAR    GuidStr[GUID_CHAR_LEN + 1];
    PFRS_QUEUE CoProcessQueue = NULL;

    //
    // Get the table lock to sync with change order accept and the
    // inbound log scanner. The outbound log process uses different
    // state to control its own processing.
    //
    LOCK_CXTION_TABLE(Replica);
    CXTION_STATE_TRACE(3, Cxtion, Replica, Cxtion->Flags, "Flags, RcsForceUnjoin entry");

    switch (GetCxtionState(Cxtion)) {

        case CxtionStateInit:
            //
            // ?
            //
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            //
            // Deleted cxtion
            //
            SetCxtionState(Cxtion, CxtionStateUnjoined);
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                SetCxtionState(Cxtion, CxtionStateDeleted);
            }
            break;

        case CxtionStateUnjoined:
            //
            // Unidle the change order process queue if it is blocked.
            //
            CoProcessQueue = Cxtion->CoProcessQueue;
            Cxtion->CoProcessQueue = NULL;

            //
            // Unjoined; nothing to do
            //
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);

            //
            // Deleted cxtion
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                SetCxtionState(Cxtion, CxtionStateDeleted);
            }
            break;

        case CxtionStateStart:
            //
            // Unidle the change order process queue if it is blocked.
            //
            CoProcessQueue = Cxtion->CoProcessQueue;
            Cxtion->CoProcessQueue = NULL;

            //
            // Haven't had a chance to start; nothing to do
            //
            SetCxtionState(Cxtion, CxtionStateUnjoined);
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);

            //
            // Deleted cxtion
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) {
                SetCxtionState(Cxtion, CxtionStateDeleted);
            }
            break;

        case CxtionStateUnjoining:
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            //
            // Take idle change orders through retry
            //
            CXTION_STATE_TRACE(3, Cxtion, Replica, Cxtion->ChangeOrderCount,
                               "COs, A-Send Idle COs to retry");
            //
            // Unidle the change order process queue if it is blocked.
            //
            CoProcessQueue = Cxtion->CoProcessQueue;
            Cxtion->CoProcessQueue = NULL;

            RcsDrainActiveCOsOnCxtion(Replica, Cxtion);

            break;

        case CxtionStateStarting:
        case CxtionStateScanning:
            //
            // Wait for the inbound scan to finish.  The change order retry
            // thread or the change order accept thread will eventually unjoin us.
            //
            SetCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            FStatus = FrsErrorUnjoining;
            break;

        case CxtionStateSendJoin:
        case CxtionStateWaitJoin:
        case CxtionStateJoined:
            //
            // Once we destroy our join guid, future remote change
            // orders will be discarded by the replica command server
            // before they show up on the change order process queue.
            //
            // This works because the replica command server is
            // single threaded per replica; any packets received during
            // this function have been enqueued for later processing.
            //
            // The outlog process may attempt to send change orders
            // if this is an outbound cxtion but they will bounce
            // because the join guid is incorrect.
            //

            //
            // Invalidate our join guid
            //
            SndCsDestroyCxtion(Cxtion, 0);
            SetCxtionState(Cxtion, CxtionStateUnjoining);
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);

            if (Cxtion->Inbound) {
                CXTION_STATE_TRACE(3, Cxtion, Replica, Cxtion->ChangeOrderCount,
                                   "COs, B-Send Idle COs to retry");
                //
                // Unidle the change order process queue if it is blocked.
                //
                CoProcessQueue = Cxtion->CoProcessQueue;
                Cxtion->CoProcessQueue = NULL;

                RcsDrainActiveCOsOnCxtion(Replica, Cxtion);

            } else {
                //
                // Tell the vvjoin command server to stop
                // Tell outlog process to Unjoin from this partner.
                // The call is synchronous so drop the lock around the call.
                //
                if (Cxtion->OLCtx != NULL) {
                    UNLOCK_CXTION_TABLE(Replica);
                    SubmitVvJoinSync(Replica, Cxtion, CMD_VVJOIN_DONE_UNJOIN);
                    FStatus = OutLogSubmit(Replica, Cxtion, CMD_OUTLOG_DEACTIVATE_PARTNER);
                    if (!FRS_SUCCESS(FStatus)) {
                        DPRINT1_FS(0, ":X: ERROR - %ws: Can't deactivate at unjoin;",
                                   Cxtion->Name->Name, FStatus);
                    }
                    LOCK_CXTION_TABLE(Replica);
                }
                //
                // Free the outbound version vector, if present
                //
                Cxtion->VVector = VVFreeOutbound(Cxtion->VVector);

                //
                // Invalidate the un/join guid
                //
                SndCsDestroyCxtion(Cxtion, CXTION_FLAGS_UNJOIN_GUID_VALID);
                SetCxtionState(Cxtion, CxtionStateUnjoined);

                //
                // Increment the Unjoins counter for
                // both the replica set and connection objects
                //
                PM_INC_CTR_CXTION(Cxtion, Unjoins, 1);
                PM_INC_CTR_REPSET(Replica, Unjoins, 1);

                DPRINT1(0, ":X: ***** UNJOINED  "FORMAT_CXTION_PATH2"\n",
                        PRINT_CXTION_PATH2(Replica, Cxtion));
                //
                // :SP1: Volatile connection cleanup.
                //
                // Deleted cxtion or outbound volatile connection. Volatile
                // connection gets deleted after the first time it UNJOINS.
                //
                if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE) ||
                    VOLATILE_OUTBOUND_CXTION(Cxtion)) {
                    SetCxtionState(Cxtion, CxtionStateDeleted);
                //
                // Rejoin
                //
                } else if (CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_JOIN)) {
                    ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
                    RcsSubmitReplicaCxtionJoin(Replica, Cxtion, TRUE);
                }
            }
            break;

        case CxtionStateDeleted:
            //
            // Unidle the change order process queue if it is blocked.
            //
            CoProcessQueue = Cxtion->CoProcessQueue;
            Cxtion->CoProcessQueue = NULL;

            //
            // Deleted; nothing to do
            //
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
            break;

        default:
            //
            // ?
            //
            DPRINT2(0, ":X: ERROR - bad state %d for "FORMAT_CXTION_PATH2"\n",
                    GetCxtionState(Cxtion), PRINT_CXTION_PATH2(Replica, Cxtion));
            break;
    }


    UNLOCK_CXTION_TABLE(Replica);

    //
    // The process queue should be unidled here after releasing the cxtion
    // lock to prevent deadlock. Never lock the process queue when you have the
    // cxtion lock.
    //
    UNIDLE_CO_PROCESS_QUEUE(Replica, Cxtion, CoProcessQueue);

    return FStatus;
}


BOOL
RcsSetSysvolReady(
    IN DWORD    NewSysvolReady
    )
/*++
Routine Description:
    Set the registry value for ...\netlogon\parameters\SysvolReady to
    the specified value. Do nothing if the SysvolReady value is
    set accordingly.

Arguments:
    None.

Return Value:
    TRUE - SysvolReady is set to TRUE
    FALSE - State of SysvolReady is unknown
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSetSysvolReady:"
    DWORD   WStatus;

    DPRINT1(4, ":S: Setting SysvolReady to %d\n", NewSysvolReady);

    //
    // Restrict values to 0 or 1
    //
    if (NewSysvolReady) {
        NewSysvolReady = 1;
    }

    if (CurrentSysvolReadyIsValid &&
        CurrentSysvolReady == NewSysvolReady) {
        DPRINT1(4, ":S: SysvolReady is already set to %d\n", NewSysvolReady);
        return TRUE;
    }

    //
    // Access the netlogon\parameters key to tell NetLogon to share the sysvol
    //
    WStatus = CfgRegWriteDWord(FKC_SYSVOL_READY, NULL, 0, NewSysvolReady);
    CLEANUP3_WS(0, "++ ERROR - writing %ws\\%ws to %d;",
                NETLOGON_SECTION, SYSVOL_READY, NewSysvolReady, WStatus, RETURN_ERROR);

    CurrentSysvolReady = NewSysvolReady;
    CurrentSysvolReadyIsValid = TRUE;
    DPRINT1(3, ":S: SysvolReady is set to %d\n", NewSysvolReady);

    //
    // Report event if transitioning from 0 to 1
    //
    if (NewSysvolReady) {
        EPRINT1(EVENT_FRS_SYSVOL_READY, ComputerName);
    }

    return TRUE;

RETURN_ERROR:
    return FALSE;
}


VOID
RcsVvJoinDoneUnJoin(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    From: Myself
    The VvJoin hack has declared victory and told our inbound partner
    to unjoin from us. That was VVJOIN_HACK_TIMEOUT seconds ago. By
    now, our inbound partner should have unjoined from us and we can
    tell dcpromo that the sysvol has been promoted.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsVvJoinDoneUnJoin:"
    PREPLICA    Replica;
    PCXTION     InCxtion;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK )) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, ReplicaVvJoinDoneUnjoin entry");

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND);
    if (!InCxtion) {
        return;
    }

    Replica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_DONE;
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsCheckPromotion(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    From: Delayed command server
    Check on the process of the sysvol promotion. If there has been
    no activity since the last time we checked, set the replica's
    promotion state to "done with error".

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCheckPromotion:"
    PREPLICA    Replica;
    PCXTION     InCxtion;
    ULONG       Timeout;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsCheckPromotion entry");

    //
    // Promotion is done; ignore
    //
    if (Replica->NtFrsApi_ServiceState != NTFRSAPI_SERVICE_PROMOTING) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica not promoting");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // No activity in awhile, declare failure
    //
    if (Replica->NtFrsApi_HackCount == RsTimeout(Cmd)) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, FRS_ERR_SYSVOL_POPULATE_TIMEOUT,
                            "W, Replica promotion timed out");
        Replica->NtFrsApi_ServiceWStatus = FRS_ERR_SYSVOL_POPULATE_TIMEOUT;
        Replica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_DONE;
        FrsCompleteCommand(Cmd, ERROR_SERVICE_SPECIFIC_ERROR);
        return;
    }
    //
    // There has been activity. Wait awhile and check again
    //
    CfgRegReadDWord(FKC_PROMOTION_TIMEOUT, NULL, 0, &Timeout);

    RsTimeout(Cmd) = Replica->NtFrsApi_HackCount;
    FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, Timeout);
}


#ifndef NOVVJOINHACK
#define VVJOIN_HACK_TIMEOUT (5 * 1000)
#endif NOVVJOINHACK
VOID
RcsVvJoinDone(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    From: Inbound partner
    The VvJoin thread has initiated all of the change orders. This doesn't
    mean that the change orders have been installed, or even received.

    At this second, we are trying to get sysvols to work; we
    don't really care if the vvjoin is done or not except in
    the case of sysvols. Hence, the hack below.

    Use the sysvol seeding hack to initiate the deleting of empty
    directories in the preexisting directory.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsVvJoinDone:"
    PREPLICA     Replica;
    PCXTION      InCxtion;
    ULONG        FStatus;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsVvJoinDone entry");

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND);
    if (!InCxtion) {
        return;
    }

    //
    // Seeding has pretty much completed. We go ahead and hammer
    // the configrecord in the DB in the hopes we don't lose this
    // once-in-replica-lifetime state transition. The state is lost
    // if this service restarts and none of the upstream partners
    // vvjoins again.
    //
    // Set the incore BOOL that lets this code know the replica
    // set is still seeding even though the CONFIG_FLAG_SEEDING
    // bit is off. And yes, this is by design. The incore flag
    // is enabled iff the DB state was updated successfully.
    //
    if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING)) {

        ClearCxtionFlag(InCxtion, CXTION_FLAGS_INIT_SYNC);

        FStatus = OutLogSubmit(Replica, InCxtion, CMD_OUTLOG_UPDATE_PARTNER);
        CXTION_STATE_TRACE(3, InCxtion, Replica, FStatus, "F, OUTLOG_UPDATE_PARTNER return");
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT3(0, "++ WARN changes to cxtion %ws (to %ws, %ws) not updated in database\n",
                    InCxtion->Name->Name, InCxtion->Partner->Name, Replica->ReplicaName->Name);
        }
    }

    //
    // First time; wait a bit and retry
    //
#ifndef NOVVJOINHACK
    if (!RsTimeout(Cmd)) {
        Replica->NtFrsApi_HackCount++; // != 0
        RsTimeout(Cmd) = Replica->NtFrsApi_HackCount;
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, VVJOIN_HACK_TIMEOUT);
        return;
    }

    //
    // There as been no activity on this cxtion for awhile after the
    // vvjoin done was received. Declare success. Tell our upstream
    // partner to discard the volatile cxtion. Update the database
    // if it hasn't already been updated. If updated successfully,
    // inform NetLogon that it is time to share the sysvol.
    //
    if (RsTimeout(Cmd) == Replica->NtFrsApi_HackCount) {
        //
        // VVJOIN DONE
        //
        //
        // Send this command to the initial sync command server for further
        // processing if we are in seeding state.
        //
        if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING)) {

            InitSyncCsSubmitTransfer(Cmd, CMD_INITSYNC_VVJOIN_DONE);
        } else {
            Cmd->Command = CMD_VVJOIN_DONE_UNJOIN;
            FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
        }
    } else {
        //
        // VVJOIN IN PROGRESS
        //
        RsTimeout(Cmd) = Replica->NtFrsApi_HackCount;
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, VVJOIN_HACK_TIMEOUT);
    }

#endif NOVVJOINHACK
}


VOID
RcsVvJoinSuccess(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Type: Local
    From: VvJoin Thread
    Change the state of the oubound cxtion from VVJOINING to JOINED and
    tell the outbound partner that the vvjoin thread is done.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsVvJoinSuccess:"
    PREPLICA    Replica;
    PCXTION     OutCxtion;
    PCOMM_PACKET    CPkt;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsVvJoinSuccess entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                            CHECK_CXTION_OUTBOUND);
    if (!OutCxtion) {
        return;
    }

    CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_VVJOIN_DONE, NULL, NULL, NULL);
    SndCsSubmitCommPkt2(Replica, OutCxtion, NULL, FALSE, CPkt);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsHungCxtion(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    From: Local OutLog Command Server

    The outlog command server has detected a wrapped ack vector. This
    may have been caused by a lost ack. In any case, check the progress
    of the change orders by examining the the ack vector, the trailing
    index, and the count of comm packets.

    A cxtion is hung if it is wrapped and both the trailing index and
    the number of comm packets received remains unchanged for
    CommTimeoutInMilliSeconds (~5 minutes). In that case, the cxtion
    is unjoined.

    If the trailing index remains unchanged but comm packets are
    being received then the timeout is reset to another
    CommTimeoutInMilliSeconds interval.

    If the cxtion appears un-hung, the command packet is completed.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsHungCxtion:"
    PREPLICA        Replica;
    PCXTION         OutCxtion;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsHungCxtion entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                            CHECK_CXTION_OUTBOUND);
    if (!OutCxtion) {
        return;
    }

    DPRINT1(4, ":X: Check Hung Cxtion for "FORMAT_CXTION_PATH2"\n",
            PRINT_CXTION_PATH2(Replica, OutCxtion));

    //
    // No out log context; can't be hung
    //
    if (!OutCxtion->OLCtx) {
        DPRINT1(4, "++ No partner context for "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, OutCxtion));
        FrsCompleteCommand(Cmd, ERROR_INVALID_PARAMETER);
        return;
    }

    //
    // No longer wrapped; not hung
    //
    if (!AVWrapped(OutCxtion->OLCtx)) {
        DPRINT1(4, "++ No longer wrapped for "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, OutCxtion));
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // AV is not wrapped at the same trailing index; not hung
    //
    if (OutCxtion->OLCtx->COTx != RsCOTx(Cmd)) {
        DPRINT3(4, "++ COTx is %d; not %d for "FORMAT_CXTION_PATH2"\n",
                OutCxtion->OLCtx->COTx,
                RsCOTx(Cmd), PRINT_CXTION_PATH2(Replica, OutCxtion));
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // Some comm pkts have shown up from the downstream partner,
    // may not be hung. Check again later.
    //
    if (OutCxtion->CommPkts != RsCommPkts(Cmd)) {
        DPRINT3(4, "++ CommPkts is %d; not %d for "FORMAT_CXTION_PATH2"\n",
                OutCxtion->CommPkts,
                RsCommPkts(Cmd), PRINT_CXTION_PATH2(Replica, OutCxtion));
        RsCommPkts(Cmd) = OutCxtion->CommPkts;
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, CommTimeoutInMilliSeconds);
    } else {
        DPRINT1(4, "++ WARN - Unjoin; cxtion is hung "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, OutCxtion));
        RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
    }
    return;
}


VOID
RcsDeleteCxtionFromReplica(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion
    )
/*++
Routine Description:
    Common subroutine that synchronously deletes the cxtion from the
    database and then removes it from the replica's table of cxtions.

    The caller is responsible for insuring that this operation is
    appropriate (cxtion exists, appropriate locks are held, ...)

Arguments:
    Replica
    Cxtion

Return Value:
    TRUE    - replica set was altered
    FALSE   - replica is unaltered
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsDeleteCxtionFromReplica:"
    ULONG   FStatus;

    //
    // Delete the cxtion from the database and then remove it from
    // the replica's table of cxtions. Keep it in the table of
    // deleted cxtions because change orders may contain the address
    // of this cxtion.
    //
    DPRINT1(4, ":X: Deleting cxtion from Db: "FORMAT_CXTION_PATH2"\n",
            PRINT_CXTION_PATH2(Replica, Cxtion));
    CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Deleting cxtion from Db");

    //
    // Must be in the deleted state to be deleted
    //
    if (!CxtionStateIs(Cxtion, CxtionStateDeleted)) {
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, ERROR Cxtion state not deleted");
        return;
    }

    FStatus = OutLogSubmit(Replica, Cxtion, CMD_OUTLOG_REMOVE_PARTNER);
    if (!FRS_SUCCESS(FStatus)) {
        CXTION_STATE_TRACE(0, Cxtion, Replica, FStatus, "F, Warn: Del cxtion failed");
        DPRINT1(0, "++ WARN Could not delete cxtion: "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, Cxtion));
    }

    if (FRS_SUCCESS(FStatus)) {
        DPRINT1(4, "++ Deleting cxtion from table: "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, Cxtion));

        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Deleting cxtion GenTab");
        GTabDelete(Replica->Cxtions, Cxtion->Name->Guid, NULL, NULL);

        //
        // Remove the connection from the perfmon tables so we stop returning
        // data and allow a new connection with the same name to be established.
        //
        DeletePerfmonInstance(REPLICACONN, Cxtion->PerfRepConnData);

        GTabInsertEntry(DeletedCxtions, Cxtion, Cxtion->Name->Guid, NULL);
    }
}


VOID
RcsUnJoinCxtion(
    IN PCOMMAND_PACKET  Cmd,
    IN BOOL             RemoteUnJoin
    )
/*++
Routine Description:
    A comm pkt could not be sent to a cxtion's partner. Unjoin the
    cxtion and periodically retry the join unless the cxtion is
    joined and volatile. In that case, delete the cxtion because
    our partner is unlikely to be able to rejoin with us (volatile
    cxtions are lost at restart).

Arguments:
    Cmd
    RemoteUnJoin    - Check authentication if remote

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsUnJoinCxtion:"
    ULONG       FStatus;
    PREPLICA    Replica;
    PCXTION     Cxtion;
    BOOL        CxtionWasJoined;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsUnJoinCxtion entry");

    //
    // Abort promotion; if any
    //
    // We no longer seed during dcpromo so a unjoin during seeding means that the
    // volatile connection has timed out (on upstream) because of no activity for
    // some time (default 30 minutes). The vvjoin will finish over the new connection
    // or the volatile connection will be re-established when the seeding downstream
    // partner comes back up.
    //
    if (Replica->NtFrsApi_ServiceState == NTFRSAPI_SERVICE_PROMOTING) {
        DPRINT1(4, ":X: Promotion aborted: unjoin for %ws.\n", Replica->SetName->Name);
        Replica->NtFrsApi_ServiceWStatus = FRS_ERR_SYSVOL_POPULATE;
        Replica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_DONE;
    }
    //
    // Find and check the cxtion
    //
    Cxtion = RcsCheckCxtion(Cmd, DEBSUB,
                                CHECK_CXTION_EXISTS |
                                CHECK_CXTION_UNJOINGUID |
                                ((RemoteUnJoin) ? CHECK_CXTION_AUTH : 0) |
                                ((RemoteUnJoin) ? CHECK_CXTION_PARTNER : 0));
    if (!Cxtion) {
        return;
    }

    CXTION_STATE_TRACE(3, Cxtion, Replica, Cxtion->Flags, "Flags, RcsUnJoinCxtion entry");
    //
    // The call to RcsForceUnjoin may alter the cxtion state.
    // Retry the join later. Don't retry if the cxtion isn't
    // joined because there are other retry mechanisms covering
    // that case.
    //
    LOCK_CXTION_TABLE(Replica);

    CxtionWasJoined = CxtionStateIs(Cxtion, CxtionStateJoined);
    if (!FrsIsShuttingDown &&
        CxtionWasJoined &&
        !CxtionFlagIs(Cxtion, CXTION_FLAGS_VOLATILE) &&
        !CxtionFlagIs(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE) &&
        !RemoteUnJoin &&
        IS_TIME_ZERO(Replica->MembershipExpires)) {

        SetCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Cxtion is DEFERRED_JOIN");
    }
    UNLOCK_CXTION_TABLE(Replica);

    FStatus = RcsForceUnjoin(Replica, Cxtion);
    CXTION_STATE_TRACE(3, Cxtion, Replica, FStatus, "F, RcsForceUnjoin return");
    if (!FRS_SUCCESS(FStatus)) {
        FrsCompleteCommand(Cmd, ERROR_REQUEST_ABORTED);
        return;
    }
    //
    // Delete the volatile cxtion if it was previously joined because
    // there is no recovery for a failed sysvol seeding operation. Or
    // if our downstream partner requested the unjoin.
    //
    if (!FrsIsShuttingDown &&
        CxtionFlagIs(Cxtion, CXTION_FLAGS_VOLATILE) &&
       (CxtionWasJoined || RemoteUnJoin)) {
        RcsDeleteCxtionFromReplica(Replica, Cxtion);
    }

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}

VOID
RcsInboundJoined(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:

    An inbound partner sent a JOINED command as a response to our join request.

    JoinGuid may not match because we are seeing an old response after a timeout
    on our end caused us to retry the join request (so the Guid changed).

    The cxtion state should be JOINING but it could be JOINED if this is a
    duplicate response.  If we timed out and gave up and/or restarted the
    entire Join sequence from the REQUEST_START state when a join response
    finally arrives the JoinGuid won't match and the response is ignored.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsInboundJoined:"
    PCXTION     InCxtion;
    ULONG       FStatus;
    PREPLICA    Replica;
    PFRS_QUEUE  CoProcessQueue = NULL;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_JOINGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsInboundJoined entry");

    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_AUTH |
                                           CHECK_CXTION_PARTNER |
                                           CHECK_CXTION_JOINGUID);
    if (!InCxtion) {
        return;
    }

    //
    // Shutting down; ignore join request
    //
    if (FrsIsShuttingDown) {
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, FrsIsShuttingDown");
        FrsCompleteCommand(Cmd, ERROR_OPERATION_ABORTED);
        return;
    }


    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, RcsInboundJoined entry");

    //
    // Increment the Join Notifications Received counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(InCxtion, JoinNRcvd, 1);
    PM_INC_CTR_REPSET(Replica, JoinNRcvd, 1);

    //
    // Update the LastJoinedTime in our connection record for use in the next
    // Join request.  The following call is synchronous.  Can't hold the
    // cxtion table lock across this call.
    //
    if (RsLastJoinTime(Cmd) != InCxtion->LastJoinTime) {
        InCxtion->LastJoinTime = RsLastJoinTime(Cmd);
        FStatus = OutLogSubmit(Replica, InCxtion, CMD_OUTLOG_UPDATE_PARTNER);
        if (!FRS_SUCCESS(FStatus)) {
            DPRINT3(0, ":X: WARN changes to cxtion %ws (to %ws, %ws) not updated in database\n",
                    InCxtion->Name->Name,
                    InCxtion->Partner->Name, Replica->ReplicaName->Name);
        }

        //
        // If the last join time is changing and we are not in the waitjoin state
        // then it means that the upstream is transitioning from join-unjoin-join.
        // We might still have outstanding fetch requests on this connection that
        // the upstream has dropped. Resubmit all fetch requests at this time.
        //

        LOCK_CXTION_TABLE(Replica);
        RcsResubmitActiveCOsOnCxtion(Replica, InCxtion);
        UNLOCK_CXTION_TABLE(Replica);

    }

    //
    // Join complete; unidle the change order process queue
    //
    if (CxtionStateIs(InCxtion, CxtionStateWaitJoin)) {
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, JOINED");
        LOCK_CXTION_TABLE(Replica);
        SET_JOINED(Replica, InCxtion, "JOINED   ");
        CoProcessQueue = InCxtion->CoProcessQueue;
        InCxtion->CoProcessQueue = NULL;
        SET_UNJOIN_TRIGGER(InCxtion);
        UNLOCK_CXTION_TABLE(Replica);
        //
        // The process queue should be unidled here after releasing the cxtion
        // lock to prevent deadlock. Never lock the process queue when you have the
        // cxtion lock.
        //
        UNIDLE_CO_PROCESS_QUEUE(Replica, InCxtion, CoProcessQueue);
    } else {
        //
        // Increment the Joins counter for both the replica set and cxtion objects
        //
        PM_INC_CTR_CXTION(InCxtion, Joins, 1);
        PM_INC_CTR_REPSET(Replica, Joins, 1);

        DPRINT1(0, ":X: ***** REJOINED  "FORMAT_CXTION_PATH2"\n",
                PRINT_CXTION_PATH2(Replica, InCxtion));
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, REJOINED");
    }


    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsRemoteCoDoneRvcd(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our outbound partner has completed processing this change order.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsRemoteCoDoneRvcd:"

    ULONGLONG   AckVersion;
    PREPLICA    Replica;
    PCXTION     OutCxtion;
    POUT_LOG_PARTNER OutLogPartner;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_OK | CHECK_CMD_PARTNERCOC)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsRemoteCoDoneRvcd entry");
    CHANGE_ORDER_COMMAND_TRACE(3, RsPartnerCoc(Cmd), "Command Remote CO Done");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                            CHECK_CXTION_OUTBOUND |
                                            CHECK_CXTION_JOINED |
                                            CHECK_CXTION_JOINGUID |
                                            CHECK_CXTION_AUTH);
    if (!OutCxtion) {
        return;
    }


    FRS_CO_COMM_PROGRESS(3, RsPartnerCoc(Cmd), RsCoSn(Cmd),
                         OutCxtion->PartSrvName, "Remote Co Done");

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, Remote Co Done");

    //
    // Update the outbound cxtion's version vector with the
    // version (guid, vsn) supplied by the outbound partner
    //
    VVUpdateOutbound(OutCxtion->VVector, RsGVsn(Cmd));
    RsGVsn(Cmd) = NULL;

    //
    // Check if this Ack is for a previous generation of the the Ack Vector
    // and if it is just ignore it.  Test for zero means that this is an old
    // rev CO that was not sent with an AckVersion so skip the test.
    // If we accept an ACK for a CO sent out with an old version of the Ack
    // vector the effect will be to either accept an Ack for the wrong CO or
    // mark the ack vector for a CO that has not yet been sent.  The latter
    // can later lead to an assert if the connection is now out of the
    // VVJoin state.
    //
    OutLogPartner = OutCxtion->OLCtx;

    AckVersion = RsPartnerCoc(Cmd)->AckVersion;
    if ((AckVersion != 0) && (AckVersion != OutLogPartner->AckVersion)) {

        CHANGE_ORDER_COMMAND_TRACE(3, RsPartnerCoc(Cmd), "Stale AckVersion - ignore");
        return;
    }

    //
    // Tell Outbound Log this CO for this connection is retired.
    //
    OutLogRetireCo(Replica, RsCoSn(Cmd), OutCxtion);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsSendRemoteCoDone(
    IN PREPLICA               Replica,
    IN PCHANGE_ORDER_COMMAND  Coc
    )
/*++
Routine Description:
    Tell our inbound partner that the change order is done

Arguments:
    Replica
    Coc

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendRemoteCoDone:"
    PCOMMAND_PACKET Cmd;
    PCXTION         InCxtion;
    PCOMM_PACKET    CPkt;

#ifndef NOVVJOINHACK
Replica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    //
    // Return the (guid,vsn) and the co guid for this change order
    //
    Cmd = FrsAllocCommand(NULL, CMD_REMOTE_CO_DONE);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    RsGVsn(Cmd) = VVGetGVsn(Replica->VVector, &Coc->OriginatorGuid);
    RsCoGuid(Cmd) = FrsDupGuid(&Coc->ChangeOrderGuid);
    RsCoSn(Cmd) = Coc->PartnerAckSeqNumber;

    //
    // Find and check the cxtion
    //
    RsReplica(Cmd) = Replica;
    RsCxtion(Cmd) = FrsBuildGName(FrsDupGuid(&Coc->CxtionGuid), NULL);
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_JOINED);
    if (!InCxtion) {
        return;
    }
    //
    // Only needed for the call to RcsCheckCxtion above.
    //
    RsCxtion(Cmd) = FrsFreeGName(RsCxtion(Cmd));
    RsReplica(Cmd) = NULL;

    //
    // Tell our inbound partner that the remote CO is done
    //
    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, Send REMOTE_CO_DONE");

    CPkt = CommBuildCommPkt(Replica, InCxtion, CMD_REMOTE_CO_DONE, NULL, Cmd, Coc);

    SndCsSubmitCommPkt2(Replica, InCxtion, NULL, FALSE, CPkt);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsInboundCommitOk(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    The change order has been retired; inform our inbound partner

Arguments:
    Replica
    Coe

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsInboundCommitOk:"
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

#ifndef NOVVJOINHACK
Replica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    DPRINT2(4, "++ Commit the retire on %s co for %ws\n",
            CO_FLAG_ON(Coe, CO_FLAG_LOCALCO) ? "Local" : "Remote", Coc->FileName);

    //
    // Tell our inbound partner that we are done with the change order
    //
    if (!CO_FLAG_ON(Coe, CO_FLAG_LOCALCO)) {
        RcsSendRemoteCoDone(Replica, Coc);
    }
}


BOOL
RcsSendCoToOneOutbound(
    IN PREPLICA                 Replica,
    IN PCXTION                  Cxtion,
    IN PCHANGE_ORDER_COMMAND    Coc
    )
/*++
Routine Description:
    Send the change order to one outbound cxtion

Arguments:
    Replica
    Cxtion
    Coc

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendCoToOneOutbound:"

    ULONG         OrigFlags;
    PCOMM_PACKET  CPkt;
    BOOL          RestoreOldParent = FALSE;
    BOOL          RestoreNewParent = FALSE;

    //
    // Must be a joined, outbound cxtion
    //
    FRS_ASSERT(!Cxtion->Inbound);

    //
    // Don't send a change order our outbound partner has seen
    //
    if (VVHasVsn(Cxtion->VVector, Coc)) {
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Dampen Send VV");
        return FALSE;
    }

    //
    // Don't send a change order to its originator unless
    // this is a vvjoin change order that isn't in the
    // originator's version vector.
    //
    if ((!COC_FLAG_ON(Coc, CO_FLAG_VVJOIN_TO_ORIG)) &&
        GUIDS_EQUAL(&Cxtion->ReplicaVersionGuid, &Coc->OriginatorGuid)) {
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Dampen Send Originator");
        return FALSE;
    }

    //
    // Send the change order to our outbound partner
    //
    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Sending");

    //
    // We don't know the value of our partner's root guid. Instead,
    // we substitute the value of our partner's guid. Our partner
    // will substitute the correct value for its root guid when
    // our partner detects our substitution.
    //
    if (GUIDS_EQUAL(&Coc->OldParentGuid, Replica->ReplicaRootGuid)) {
        RestoreOldParent = TRUE;
        COPY_GUID(&Coc->OldParentGuid, Cxtion->Partner->Guid);
    }
    if (GUIDS_EQUAL(&Coc->NewParentGuid, Replica->ReplicaRootGuid)) {
        RestoreNewParent = TRUE;
        COPY_GUID(&Coc->NewParentGuid, Cxtion->Partner->Guid);
    }

    //
    // A change order can be directed to only one outbound cxtion. Once
    // the change order goes across the wire it is no longer "directed"
    // to an outbound cxtion. So, turn off the flag before it is sent.
    //
    OrigFlags = Coc->Flags;
    CLEAR_COC_FLAG(Coc, CO_FLAG_DIRECTED_CO);

    CPkt = CommBuildCommPkt(Replica, Cxtion, CMD_REMOTE_CO, NULL, NULL, Coc);

    //
    // Restore the root guids substituted above
    //
    if (RestoreOldParent) {
        COPY_GUID(&Coc->OldParentGuid, Replica->ReplicaRootGuid);
    }
    if (RestoreNewParent) {
        COPY_GUID(&Coc->NewParentGuid, Replica->ReplicaRootGuid);
    }
    //
    // Restore the flags
    //
    SET_COC_FLAG(Coc, OrigFlags);

    SndCsSubmitCommPkt2(Replica, Cxtion, NULL, FALSE, CPkt);
    return TRUE;
}


VOID
RcsReceivedStageFile(
    IN PCOMMAND_PACKET  Cmd,
    IN ULONG            AdditionalCxtionChecks
    )
/*++
Routine Description:
    An outbound partner is sending a staging file to this inbound cxtion.
    Request more if needed.

Arguments:
    Cmd
    AdditionalReplicaChecks

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsReceivedStageFile:"
    PCXTION               InCxtion;
    PREPLICA              Replica;
    PCHANGE_ORDER_ENTRY   Coe;
    PCHANGE_ORDER_COMMAND Coc;
    PCOMM_PACKET          CPkt;
    ULONG                 Flags;
    ULONG                 WStatus;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_OK | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    Coe = RsCoe(Cmd);
    Coc = RsCoc(Cmd);

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsReceivedStageFile entry");
    CHANGE_ORDER_TRACEXP(3, Coe, "Replica received stage", Cmd);

#ifndef NOVVJOINHACK
Replica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK
    //
    // *Note*
    // Perf: Clean this up when the whole RCS, FETCS, STAGE_GEN_CS design is redone - Davidor.
    //
    // This bypass is needed because some of the callers want to make an
    // authentication check on the received data fetch packet.  In the case of an
    // MD5 match where the MD5 checksum is supplied with the Change Order
    // there is no authentication info to check so this check fails and causes
    // the connection to unjoin and sends the CO thru retry.  This makes the
    // VVJoin real slow.  This also skips over the perfmon fetch counters which
    // is good since there was no fetch.
    //
    if (COE_FLAG_ON(Coe, COE_FLAG_PRE_EXIST_MD5_MATCH)) {
        CHANGE_ORDER_TRACE(3, Coe, "MD5 Match Bypass");
        //
        // We can't skip the below because we need to check the staging
        // file flags for STAGE_FLAG_DATA_PRESENT.  If that is clear we need
        // to pass this friggen cmd pkt to the FetchCs to do the final stage file
        // reanme.  So instead clear the CHECK_CXTION_AUTH flag to avoid bogus
        // cxtion unjoins.  This stinks.
        //
        ClearFlag(AdditionalCxtionChecks, CHECK_CXTION_AUTH);
        // goto FETCH_IS_DONE;
    }

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND |
                                           AdditionalCxtionChecks);
    if (!InCxtion) {
        return;
    }

    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, RcsReceivedStageFile entry");

    //
    // If there is more staging file to fetch, go fetch it!
    //
    if (RsFileOffset(Cmd).QuadPart < RsFileSize(Cmd).QuadPart) {
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, Send more stage");

        //
        // Remember what offset of the staging file we are requesting.
        //
        //Coe->FileOffset.QuadPart = RsFileOffset(Cmd).QuadPart;

        CPkt = CommBuildCommPkt(Replica, InCxtion, CMD_SEND_STAGE, NULL, Cmd, Coc);
        SndCsSubmitCommPkt2(Replica, InCxtion, Coe, TRUE, CPkt);
        RsCoe(Cmd) = NULL;
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;

    } else {


        if (FrsDoesCoNeedStage(Coc)) {
            //
            // Even though all the data has been delivered the staging file rename
            // may not have completed.  E.g. a sharing violation on final rename.
            // If so then send the cmd back to the Fetch CS to finish up.
            //
            Flags = STAGE_FLAG_EXCLUSIVE;
            WStatus = StageAcquire(&Coc->ChangeOrderGuid,
                                   Coc->FileName,
                                   Coc->FileSize,
                                   &Flags,
                                   Replica->ReplicaNumber,
                                   NULL);

            if (WIN_RETRY_FETCH(WStatus)) {
                //
                // Retriable problem
                //
                CHANGE_ORDER_TRACEW(3, Coe, "Send to Fetch Retry", WStatus);
                FrsFetchCsSubmitTransfer(Cmd, CMD_RETRY_FETCH);
                return;
            }

            if (!WIN_SUCCESS(WStatus)) {
                //
                // Unrecoverable error; abort
                //
                CHANGE_ORDER_TRACEW(0, Coe, "Send to fetch abort", WStatus);
                FrsFetchCsSubmitTransfer(Cmd, CMD_ABORT_FETCH);
                return;
            }

            StageRelease(&Coc->ChangeOrderGuid, Coc->FileName, 0, NULL, NULL, NULL);

            //
            // Now check if we still need to finish the rename.
            //
            if (!(Flags & STAGE_FLAG_DATA_PRESENT)) {
                FrsFetchCsSubmitTransfer(Cmd, CMD_RECEIVING_STAGE);
                return;
            }
        }

        //
        // Increment the staging files fetched counter for the replica set.
        //
        PM_INC_CTR_REPSET(Replica, SFFetched, 1);
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, Stage fetch complete");
    }

    //
    // Increment the Fetch Requests Files Received counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(InCxtion, FetRReceived, 1);
    PM_INC_CTR_REPSET(Replica, FetRReceived, 1);

    //
    // Display info for dcpromo during sysvol seeding.
    // We don't seed during dcpromo anymore so we don't need to
    // display any progress information.
    //
//    if (!Replica->NtFrsApi_ServiceDisplay) {
//        Replica->NtFrsApi_ServiceDisplay = FrsWcsDup(Coc->FileName);
//    }

// FETCH_IS_DONE:

    //
    // Installing the fetched staging file
    //
    SET_CHANGE_ORDER_STATE(Coe, IBCO_FETCH_COMPLETE);
    SET_CHANGE_ORDER_STATE(Coe, IBCO_INSTALL_INITIATED);

    //
    // Install the staging file.
    //
    FrsInstallCsSubmitTransfer(Cmd, CMD_INSTALL_STAGE);
}


VOID
RcsRetryFetch(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our inbound partner has requested that we retry fetching the staging
    file at a later time.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsRetryFetch:"
    PCXTION             InCxtion;
    PREPLICA            Replica;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsRetryFetch entry");
    CHANGE_ORDER_TRACEXP(3, RsCoe(Cmd), "Replica retry fetch", Cmd);

#ifndef NOVVJOINHACK
RsReplica(Cmd)->NtFrsApi_HackCount++;
#endif NOVVJOINHACK


    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_AUTH);
    if (!InCxtion) {
        return;
    }

    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_RETRY_FETCH");

    FrsFetchCsSubmitTransfer(Cmd, CMD_RETRY_FETCH);
}


VOID
RcsAbortFetch(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Our inbound partner has requested that we abort the fetch.
    It could be out of disk space, out of disk quota or it may
    not have the original file to create the staging file.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsAbortFetch:"
    PCXTION             InCxtion;
    PREPLICA            Replica;
    PCHANGE_ORDER_ENTRY Coe;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    Coe = RsCoe(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsAbortFetch entry");
    CHANGE_ORDER_TRACEXP(3, Coe, "Replica abort fetch", Cmd);

    //
    // Abort promotion; if any
    //
    //
    // We no longer seed during dcpromo so aborting a fetch during seeding is same as
    // aborting it at any other time. If we abort a dir create then it will trigger a unjoin
    // of the volatile connection. The vvjoin will finish over the new connection
    // or the volatile connection will be re-established when the seeding downstream
    // partner comes back up.
    //
    if (Replica->NtFrsApi_ServiceState == NTFRSAPI_SERVICE_PROMOTING) {
        DPRINT1(4, "++ Promotion aborted: abort fetch for %ws.\n",
                Replica->SetName->Name);
        Replica->NtFrsApi_ServiceWStatus = FRS_ERR_SYSVOL_POPULATE;
        Replica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_DONE;
    }

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_AUTH);
    if (InCxtion == NULL) {
        return;
    }

    FrsFetchCsSubmitTransfer(Cmd, CMD_ABORT_FETCH);
}


VOID
RcsReceivingStageFile(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Received this data from our inbound partner. Give it to the fetcher
    so he can put it into the staging file.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsReceivingStageFile:"
    PREPLICA            Replica;
    PCXTION             InCxtion;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsReceivingStageFile entry");
    CHANGE_ORDER_TRACEXP(3, RsCoe(Cmd), "Replica receiving stage", Cmd);

#ifndef NOVVJOINHACK
RsReplica(Cmd)->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_AUTH);
    if (!InCxtion) {
        //
        // Note: If auth check fails we might consider aborting the CO instead.
        //       Need to first try it and see if the CO would be aborted
        //       elsewhere first.
        //
        return;
    }
    //
    // Display info for dcpromo during sysvol seeding
    // We don't seed during dcpromo anymore so we don't need to
    // display any progress information.
    //
//    if (!Replica->NtFrsApi_ServiceDisplay) {
//        Replica->NtFrsApi_ServiceDisplay = FrsWcsDup(RsCoc(Cmd)->FileName);
//    }

    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_RECEIVING_STAGE");

    //
    // Increment the Fetch Requests Bytes Received counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(InCxtion, FetBRcvd, 1);
    PM_INC_CTR_REPSET(Replica, FetBRcvd, 1);
    PM_INC_CTR_CXTION(InCxtion, FetBRcvdBytes, RsBlockSize(Cmd));
    PM_INC_CTR_REPSET(Replica, FetBRcvdBytes, RsBlockSize(Cmd));

    FrsFetchCsSubmitTransfer(Cmd, CMD_RECEIVING_STAGE);
}


VOID
RcsSendRetryFetch(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Received from the local staging file fetcher. Tell our
    outbound partner to retry the fetch at a later time.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendRetryFetch:"
    PREPLICA      Replica;
    PCXTION       OutCxtion;
    PCOMM_PACKET  CPkt;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsSendRetryFetch entry");

#ifndef NOVVJOINHACK
RsReplica(Cmd)->NtFrsApi_HackCount++;
#endif NOVVJOINHACK
    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                            CHECK_CXTION_OUTBOUND);
    if (!OutCxtion) {
        return;
    }

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, submit cmd CMD_RETRY_FETCH");

    CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_RETRY_FETCH, NULL, Cmd, NULL);

    SndCsSubmitCommPkt2(Replica, OutCxtion, NULL, FALSE, CPkt);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsSendAbortFetch(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Received from the local staging file fetcher. Tell our
    outbound partner to abort the fetch.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendAbortFetch:"
    PREPLICA      Replica;
    PCXTION       OutCxtion;
    PCOMM_PACKET  CPkt;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsSendAbortFetch entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                            CHECK_CXTION_OUTBOUND);
    if (!OutCxtion) {
        return;
    }

    //
    // Tell our outbound partner that the file has been sent
    //

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, submit cmd CMD_ABORT_FETCH");

    CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_ABORT_FETCH, NULL, Cmd, NULL);

    SndCsSubmitCommPkt2(Replica, OutCxtion, NULL, FALSE, CPkt);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsSendingStageFile(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Received from the local staging file fetcher. Push this data to
    our outbound partner.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendingStageFile:"
    PREPLICA      Replica;
    PCXTION       OutCxtion;
    PCOMM_PACKET  CPkt;


    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsSendingStageFile entry");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                            CHECK_CXTION_OUTBOUND);

    if (!OutCxtion) {
        return;
    }

    //
    // Increment the Fetch Blocks sent and Fetch Bytes sent counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(OutCxtion, FetBSent, 1);
    PM_INC_CTR_REPSET(Replica, FetBSent, 1);
    PM_INC_CTR_CXTION(OutCxtion, FetBSentBytes, RsBlockSize(Cmd));
    PM_INC_CTR_REPSET(Replica, FetBSentBytes, RsBlockSize(Cmd));

    //
    // Send the next block of the file to the outbound partner.
    //

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, submit cmd CMD_RECEIVING_STAGE");

    CPkt = CommBuildCommPkt(Replica, OutCxtion, CMD_RECEIVING_STAGE, NULL, Cmd, NULL);

    SndCsSubmitCommPkt2(Replica, OutCxtion, NULL, FALSE, CPkt);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsSendStageFile(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Received a request to send the staging control file to our
    outbound partner. Tell the staging fetcher to send it on.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendStageFile:"
    PCXTION     OutCxtion;
    PREPLICA    Replica;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_AND_COGUID_OK |
                                  CHECK_CMD_PARTNERCOC )) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsSendStageFile entry");
    CHANGE_ORDER_COMMAND_TRACE(3, RsPartnerCoc(Cmd), "Command send stage");

    //
    // Find and check the cxtion
    //
    OutCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                            CHECK_CXTION_OUTBOUND);
    if (!OutCxtion) {
        return;
    }

    //
    // Tell the staging file generator to send the file
    //

    CXTION_STATE_TRACE(3, OutCxtion, Replica, 0, "F, submit cmd CMD_SEND_STAGE");
    FrsFetchCsSubmitTransfer(Cmd, CMD_SEND_STAGE);
}


VOID
RcsRemoteCoAccepted(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    We have accepted the remote change order, fetch the staging file

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsRemoteCoAccepted:"
    DWORD                   WStatus;
    DWORD                   Flags;
    PREPLICA                Replica;
    PCXTION                 InCxtion;
    PCHANGE_ORDER_ENTRY     Coe;
    PCHANGE_ORDER_COMMAND   Coc;
    PCOMM_PACKET            CPkt;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_OK | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    Coe = RsCoe(Cmd);
    Coc = RsCoc(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsRemoteCoAccepted entry");
    CHANGE_ORDER_TRACEXP(3, Coe, "Replica remote co accepted", Cmd);

#ifndef NOVVJOINHACK
Replica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    //
    // Find and check the cxtion
    //
    // We don't need auth check here because this cmd hasn't arrived
    // from a partner. It is submitted by RcsSubmitRemoteCoAccepted()
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_JOINED);
    if (!InCxtion) {
        return;
    }

    FRS_CO_COMM_PROGRESS(3, Coc, (ULONG)(Coc->SequenceNumber),
                         InCxtion->PartSrvName, "Remote Co Accepted");

    //
    // MACRO MAY RETURN!!!
    //
    PULL_UNJOIN_TRIGGER(InCxtion, Cmd);

    if (VVHasVsn(Replica->VVector, Coc)) {
        CHANGE_ORDER_TRACE(3, Coe, "Dampen Accepted Remote Co");
    }

    //
    // Don't fetch a non-existent staging file
    //
    if (!FrsDoesCoNeedStage(Coc)) {

        //
        // Allocate or update the Join Guid.
        //
        if (RsJoinGuid(Cmd) == NULL) {
            RsJoinGuid(Cmd) = FrsDupGuid(&InCxtion->JoinGuid);
        } else {
            COPY_GUID(RsJoinGuid(Cmd), &InCxtion->JoinGuid);
        }

        RcsReceivedStageFile(Cmd, 0);
        return;
    }

    //
    // Don't refetch a recovered staging file
    //
    Flags = 0;
    WStatus = StageAcquire(&Coc->ChangeOrderGuid, Coc->FileName, QUADZERO, &Flags, Replica->ReplicaNumber, NULL);

    if (WIN_SUCCESS(WStatus)) {
        StageRelease(&Coc->ChangeOrderGuid, Coc->FileName, Flags, NULL, NULL, NULL);
        if (Flags & STAGE_FLAG_CREATED) {
            //
            // File has been fetched
            //
            RsFileOffset(Cmd).QuadPart = RsFileSize(Cmd).QuadPart;

            //
            // Allocate or update the Join Guid.
            //
            if (RsJoinGuid(Cmd) == NULL) {
                RsJoinGuid(Cmd) = FrsDupGuid(&InCxtion->JoinGuid);
            } else {
                COPY_GUID(RsJoinGuid(Cmd), &InCxtion->JoinGuid);
            }

            RcsReceivedStageFile(Cmd, 0);
            return;
        }
    }

    //
    // Attempt to use a preexisting file if this is the first block of the
    // staging file, is a vvjoin co, and there is a preinstall file.
    //
    //
    // 04/24/2002: We only do this for VVJoin COs. The change to look for a preexisting
    // for non-vvjoin COs was removed as it was at the expense of a huge
    // perf hit. Bug # 493700
    //
    if (InCxtion->PartnerMinor >= NTFRS_COMM_MINOR_1 &&
        (RsFileOffset(Cmd).QuadPart == QUADZERO) &&
        CO_FLAG_ON(Coe, CO_FLAG_VVJOIN_TO_ORIG) &&
        COE_FLAG_ON(Coe, COE_FLAG_PREINSTALL_CRE)) {

        //
        // Removed the check for a VVJoin Co above.  If this is a new file
        // (i.e. a pe-install file was created) then check for a local file
        // with a matching OID and MD5.  Put out a trace record so we can
        // tell when this case occurs.
        //
        if (!CO_FLAG_ON(Coe, CO_FLAG_VVJOIN_TO_ORIG)) {
            CHANGE_ORDER_TRACE(3, Coe, "**** Chk Existing - non-VVJOIN Co");
        }

        FrsStageCsSubmitTransfer(Cmd, CMD_CREATE_EXISTING);
        return;
    }

    //
    // fetching the staging file
    //
    SET_CHANGE_ORDER_STATE(RsCoe(Cmd), IBCO_FETCH_INITIATED);

    //
    // Increment the Fetch Requests Files Requested counter for
    // both the replica set and connection objects
    //
    PM_INC_CTR_CXTION(InCxtion, FetRSent, 1);
    PM_INC_CTR_REPSET(Replica, FetRSent, 1);

    //
    // Tell our inbound partner to send the staging file
    //

    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_SEND_STAGE");

    //
    // Remember what offset of the staging file we are requesting.
    //
    //Coe->FileOffset.QuadPart = RsFileOffset(Cmd).QuadPart;

    CPkt = CommBuildCommPkt(Replica, InCxtion, CMD_SEND_STAGE, NULL, Cmd, Coc);
    SndCsSubmitCommPkt2(Replica, InCxtion, RsCoe(Cmd), TRUE, CPkt);

    RsCoe(Cmd) = NULL;
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsSendStageFileRequest(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Generated staging file (maybe) from preexisting file.
    Request stage file from upstream partner.  If MD5Digest matches
    on Upstream partner's stage file then our pre-existing stage file (if any)
    is good.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSendStageFileRequest:"
    PREPLICA                Replica;
    PCXTION                 InCxtion;
    PCHANGE_ORDER_ENTRY     Coe;
    PCHANGE_ORDER_COMMAND   Coc;
    PCOMM_PACKET            CPkt;
    ULONG                    CocAttrs;
    ULONG                    CoeAttrs;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_OK | CHECK_CMD_COE)) {
        return;
    }

    Replica = RsReplica(Cmd);
    Coe = RsCoe(Cmd);
    Coc = RsCoc(Cmd);

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsSendStageFileRequest entry");
    CHANGE_ORDER_TRACEXP(3, Coe, "Replica created existing", Cmd);

#ifndef NOVVJOINHACK
Replica->NtFrsApi_HackCount++;
#endif NOVVJOINHACK

    CocAttrs = Coc->FileAttributes &
        ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL);
    CoeAttrs = Coe->FileAttributes &
        ~(FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL);

    //
    // If the attribs don't match then we don't want to pass along or check the
    // MD5 checksum. Otherwise we might wind up sending the local checksum
    // upstream for our partner to do the check. He won't have the Attribs and
    // would think the file was the same if only the attribs had changed.
    //

    if (CocAttrs != CoeAttrs) {
        DPRINT2(3, "Attribute miss-match, zeroing MD5.  CocAttrs: 0x%08x   CoeAttrs: 0x%08x\n", CocAttrs, CoeAttrs);
        RsMd5Digest(Cmd) = FrsFree(RsMd5Digest(Cmd));
    }

    if (RsMd5Digest(Cmd)) {
        PDATA_EXTENSION_CHECKSUM CocDataChkSum;

        //
        // We have an existing file and the checksum has been created.
        // See if we have a checksum in the changeorder from our inbound
        // partner.  If so and they match then we can move on to the install.
        //
        //
        // We also need to check the attributes and the times, since they
        // are not part of the checksum. Right now we do not have the times
        // from the upstream partner so we can't check them.
        //

        CHANGE_ORDER_TRACE(3, Coe, "Created Existing");
        CocDataChkSum = DbsDataExtensionFind(Coc->Extension, DataExtend_MD5_CheckSum);

        if ((CocDataChkSum != NULL) &&
            !IS_MD5_CHKSUM_ZERO(CocDataChkSum->Data) &&
            MD5_EQUAL(CocDataChkSum->Data, RsMd5Digest(Cmd))) {

            //
            // MD5 digest from CO matches so our file is good and we can
            // avoid having the inbound partner recompute the checksum.
            //
            CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Md5, Attribs match preexisting, no fetch");
            SET_COE_FLAG(Coe, COE_FLAG_PRE_EXIST_MD5_MATCH);

            DPRINT1(4, "++ RsFileSize(Cmd).QuadPart: %08x %08x\n",
                    PRINTQUAD(RsFileSize(Cmd).QuadPart));
            DPRINT1(4, "++ Coc->FileSize:            %08x %08x\n",
                    PRINTQUAD(Coc->FileSize));

            //
            // Even if the file is 0 bytes in length, the staging file will
            // always have at least the header. There are some retry paths
            // that will incorrectly think the staging file has been fetched
            // if RsFileSize(Cmd) is 0. So make sure it isn't.
            //
            if (RsFileSize(Cmd).QuadPart == QUADZERO) {
                RsFileSize(Cmd).QuadPart = Coc->FileSize;

                if (RsFileSize(Cmd).QuadPart == QUADZERO) {
                    RsFileSize(Cmd).QuadPart = sizeof(STAGE_HEADER);
                }
            }

            DPRINT1(4, "++ RsFileSize(Cmd).QuadPart: %08x %08x\n",
                    PRINTQUAD(RsFileSize(Cmd).QuadPart));

            //
            // Set the offset to the size of the stage file so we don't request
            // any data.
            //
            RsFileOffset(Cmd).QuadPart = RsFileSize(Cmd).QuadPart;
            RsBlockSize(Cmd) = QUADZERO;

            //
            // Find and check the cxtion
            //
            InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                                   CHECK_CXTION_INBOUND |
                                                   CHECK_CXTION_JOINED);
            if (!InCxtion) {
                return;
            }

            //
            // Allocate or update the Join Guid.
            //
            if (RsJoinGuid(Cmd) == NULL) {
                RsJoinGuid(Cmd) = FrsDupGuid(&InCxtion->JoinGuid);
            } else {
                COPY_GUID(RsJoinGuid(Cmd), &InCxtion->JoinGuid);
            }

            RcsReceivedStageFile(Cmd, 0);

            //RcsSubmitTransferToRcs(Cmd, CMD_RECEIVED_STAGE);
            return;
        }

    } else {
        CHANGE_ORDER_TRACE(3, Coe, "Could not create existing");
    }

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_JOINED);
    if (!InCxtion) {
        return;
    }

    //
    // Tell our inbound partner to send the staging file
    //
    CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_SEND_STAGE");

    //
    // Remember what offset of the staging file we are requesting.
    //
    //Coe->FileOffset.QuadPart = RsFileOffset(Cmd).QuadPart;

    CPkt = CommBuildCommPkt(Replica, InCxtion, CMD_SEND_STAGE, NULL, Cmd, Coc);
    SndCsSubmitCommPkt2(Replica, InCxtion, RsCoe(Cmd), TRUE, CPkt);

    RsCoe(Cmd) = NULL;
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsRemoteCoReceived(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Remote CO has arrived.

        Translate guid of our root dir if necc.

        Attach the Change Order extension if provided.

        Check version vector dampening and provide immediate Ack if we have
        already seen this CO.

        Finally, pass the change order on to the change order subsystem.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsRemoteCoReceived:"

    PCXTION                 InCxtion;
    PREPLICA                Replica;
    PULONG                  pULong;
    PCHANGE_ORDER_COMMAND   Coc;
    PCHANGE_ORDER_RECORD_EXTENSION CocExt;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_CXTION_OK | CHECK_CMD_PARTNERCOC )) {
        return;
    }
    Replica = RsReplica(Cmd);
    Coc = RsPartnerCoc(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsRemoteCoReceived entry");

#ifndef NOVVJOINHACK
RsReplica(Cmd)->NtFrsApi_HackCount++;
#endif NOVVJOINHACK
    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_JOIN_OK |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_AUTH |
                                           CHECK_CXTION_FIXJOINED);
    if (!InCxtion) {
        return;
    }

    //
    // Remember which cxtion this change order was directed at
    //
    COPY_GUID(&Coc->CxtionGuid, RsCxtion(Cmd)->Guid);
    CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Replica Received Remote Co");

    //
    // Our partner doesn't know the correct value for our root guid and
    // so substituted our ReplicaName->Guid (its Cxtion->Partner->Guid)
    // for its own root guids when sending the change order to us.
    // We substitute our own root guids once we receive the change order
    // and detect the substitution.
    //
    if (GUIDS_EQUAL(&Coc->OldParentGuid, RsReplica(Cmd)->ReplicaName->Guid)) {
        COPY_GUID(&Coc->OldParentGuid, RsReplica(Cmd)->ReplicaRootGuid);
    }
    if (GUIDS_EQUAL(&Coc->NewParentGuid, RsReplica(Cmd)->ReplicaName->Guid)) {
        COPY_GUID(&Coc->NewParentGuid, RsReplica(Cmd)->ReplicaRootGuid);
    }

    //
    // Init the Coc pointer to the CO Data Extension.  Down Rev partners
    // won't have one so supply an empty field.  Do this here in case VV
    // Dampening short circuits the CO and sends back the RemoteCoDone ACK here.
    //
    CocExt = RsPartnerCocExt(Cmd);

    if (CocExt == NULL) {
        CocExt = FrsAlloc(sizeof(CHANGE_ORDER_RECORD_EXTENSION));
        DbsDataInitCocExtension(CocExt);
        DPRINT(4, "Allocating initial Coc Extension\n");
    }

    Coc->Extension = CocExt;

    pULong = (PULONG) CocExt;
    DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
               pULong, *(pULong+0), *(pULong+1), *(pULong+2), *(pULong+3));
    DPRINT5(5, "Extension Buffer: (%08x) %08x %08x %08x %08x\n",
               (PCHAR)pULong+16, *(pULong+4), *(pULong+5), *(pULong+6), *(pULong+7));

    //
    // Don't redo a change order
    //
    if (VVHasVsn(RsReplica(Cmd)->VVector, Coc)) {
        //
        // Increment the Inbound CO dampned counter for
        // both the replica set and connection objects
        //
        PM_INC_CTR_CXTION(InCxtion, InCODampned, 1);
        PM_INC_CTR_REPSET(RsReplica(Cmd), InCODampned, 1);
        CHANGE_ORDER_COMMAND_TRACE(3, Coc, "Dampen Received Remote Co");

        RcsSendRemoteCoDone(RsReplica(Cmd), Coc);
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // Put the change order on the inbound queue for this replica.
    //
    ChgOrdInsertRemoteCo(Cmd, InCxtion);

    //
    // Done
    //
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsRetryStageFileCreate(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Retry generating the staging file.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsRetryStageFileCreate:"
    PREPLICA            Replica;
    PCXTION             OutCxtion;
    PCXTION             InCxtion;
    PVOID               Key;
    PCHANGE_ORDER_ENTRY Coe;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsRetryStageFileCreate entry");
    CHANGE_ORDER_TRACEXP(3, RsCoe(Cmd), "Replica retry stage", Cmd);

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_JRNLCXTION |
                                           CHECK_CXTION_JOINED);
    if (!InCxtion) {
        return;
    }

    //
    // Ignore local change order if there are no outbound cxtions
    //
    Key = NULL;
    while (OutCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        if (!OutCxtion->Inbound) {
            break;
        }
    }
    if (OutCxtion == NULL) {
        //
        // Make sure a user hasn't altered our object id on the file
        // and then retire the change order without propagating to the
        // outbound log. The stager is responsible for hammering the
        // object id because it knows how to handle sharing violations
        // and file-not-found errors.
        //
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_CHECK_OID");
        FrsStageCsSubmitTransfer(Cmd, CMD_CHECK_OID);
    } else {
        //
        // Generate the staging file
        //
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_CREATE_STAGE");
        FrsStageCsSubmitTransfer(Cmd, CMD_CREATE_STAGE);
    }
}


VOID
RcsLocalCoAccepted(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Process the accepted, local change order. Either retire it if there
    are no outbound cxtions or send it own to the staging file generator.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsLocalCoAccepted:"
    PREPLICA            Replica;
    PCXTION             OutCxtion;
    PCXTION             InCxtion;
    PVOID               Key;
    PCHANGE_ORDER_ENTRY Coe;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA | CHECK_CMD_COE)) {
        return;
    }
    Replica = RsReplica(Cmd);
    Coe = RsCoe(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsLocalCoAccepted entry");
    CHANGE_ORDER_TRACEXP(3, Coe, "Replica local co accepted", Cmd);

    //
    // Find and check the cxtion
    //
    InCxtion = RcsCheckCxtion(Cmd, DEBSUB, CHECK_CXTION_EXISTS |
                                           CHECK_CXTION_INBOUND |
                                           CHECK_CXTION_JRNLCXTION |
                                           CHECK_CXTION_JOINED);
    if (!InCxtion) {
        return;
    }

    FRS_CO_COMM_PROGRESS(3, &Coe->Cmd, Coe->Cmd.SequenceNumber,
                         InCxtion->PartSrvName, "Local Co Accepted");

    //
    // Ignore local change order if there are no outbound cxtions
    //
    Key = NULL;
    while (OutCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        if (!OutCxtion->Inbound) {
            break;
        }
    }
    if (OutCxtion == NULL) {
        //
        // Make sure a user hasn't altered our object id on the file
        // and then retire the change order without propagating to the
        // outbound log. The stager is responsible for hammering the
        // object id because it knows how to handle sharing violations
        // and file-not-found errors.
        //
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_CHECK_OID");
        FrsStageCsSubmitTransfer(Cmd, CMD_CHECK_OID);
    } else {
        //
        // Generate the staging file
        //
        CXTION_STATE_TRACE(3, InCxtion, Replica, 0, "F, submit cmd CMD_CREATE_STAGE");
        FrsStageCsSubmitTransfer(Cmd, CMD_CREATE_STAGE);
    }
}


VOID
RcsBeginMergeWithDs(
    VOID
    )
/*++
Routine Description:
    The DS has been polled and now has replicas to merge into the
    active replicas initially retrieved from the database or merged
    into the active replicas by a previous poll.

    Each active replica is marked as "not merged with ds". Any
    replica that remains in this state after the merge is done
    is a deleted replica. See RcsEndMergeWithDs().

Arguments:
    None.

Return Value:
    TRUE    - Continue with merge
    FALSE   - Abort merge
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsBeginMergeWithDs:"
    PVOID       Key;
    PREPLICA    Replica;
    extern CRITICAL_SECTION MergingReplicasWithDs;

    //
    // Wait for the replica command server to start up. The shutdown
    // code will set this event so we don't sleep forever.
    //
    WaitForSingleObject(ReplicaEvent, INFINITE);

    //
    // Synchronize with sysvol seeding
    //
    EnterCriticalSection(&MergingReplicasWithDs);

    //
    // Snapshot a copy of the replica table. Anything left in the table
    // after the merge should be deleted because a corresponding entry
    // no longer exists in the DS. This code is not multithread!
    //
    FRS_ASSERT(ReplicasNotInTheDs == NULL);
    ReplicasNotInTheDs = GTabAllocTable();

    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Insert ReplicasNotInTheDs");
        GTabInsertEntry(ReplicasNotInTheDs, Replica, Replica->ReplicaName->Guid, NULL);
    }
}


VOID
RcsSubmitReplica(
    IN PREPLICA Replica,
    IN PREPLICA NewReplica, OPTIONAL
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to a replica.

Arguments:
    Replica      - existing replica
    NewReplica   - Changes to Replica (may be NULL)
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitReplica:"
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(Replica->Queue, Command);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of replica set and new replica set
    //
    RsReplica(Cmd) = Replica;
    RsNewReplica(Cmd) = NewReplica;

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsSubmitReplica cmd");
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
}


VOID
RcsSubmitReplicaCxtion(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to a replica\cxtion.

    Build cmd pkt with Cxtion GName, replica ptr, Join Guid and supplied command.
    Submit to Replica cmd server.
    Calls dispatch function and translates cxtion GName to cxtion ptr
    Builds Comm pkt for cxtion and calls SndCsSubmit() to send it.

Arguments:
    Replica     - existing replica
    Cxtion      - existing cxtion
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitReplicaCxtion:"
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(Replica->Queue, Command);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of replica set and new replica set
    //
    RsReplica(Cmd) = Replica;
    RsCxtion(Cmd) = FrsDupGName(Cxtion->Name);
    RsJoinGuid(Cmd) = FrsDupGuid(&Cxtion->JoinGuid);
    //
    // OLCtx and CommPkts are used for CMD_HUNG_CXTION.
    // They are used to detect a hung outbound cxtion that
    // is probably hung because of a dropped ack.
    //
    if (Cxtion->OLCtx) {
        RsCOTx(Cmd) = Cxtion->OLCtx->COTx;
    }
    RsCommPkts(Cmd) = Cxtion->CommPkts - 1;

    DPRINT5(5, "Submit %08x for Cmd %08x %ws\\%ws\\%ws\n",
            Cmd->Command, Cmd, Replica->SetName->Name, Replica->MemberName->Name,
            Cxtion->Name->Name);

    CXTION_STATE_TRACE(5, Cxtion, Replica, 0, "F, RcsSubmitReplicaCxtion cmd");
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
}


DWORD
RcsSubmitReplicaSync(
    IN PREPLICA Replica,
    IN PREPLICA NewReplica,
    IN PCXTION  VolatileCxtion,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to a replica and wait for it to finish.

Arguments:
    Replica      - existing replica
    NewReplica   - Changes to Replica (may be NULL)
    VolatileCxtion - New cxtion (currently used for seeding sysvols)
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitReplicaSync:"
    DWORD           WStatus;
    PCOMMAND_PACKET Cmd;

    //
    // Allocate a command packet
    //
    Cmd = FrsAllocCommand(Replica->Queue, Command);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of replica set and new replica set
    //
    RsReplica(Cmd) = Replica;
    RsNewReplica(Cmd) = NewReplica;
    RsNewCxtion(Cmd) = VolatileCxtion;
    RsCompletionEvent(Cmd) = FrsCreateEvent(TRUE, FALSE);

    DPRINT3(5, "Submit Sync %08x for Cmd %08x %ws\n",
            Cmd->Command, Cmd, RsReplica(Cmd)->ReplicaName->Name);


    CXTION_STATE_TRACE(5, VolatileCxtion, Replica, 0, "F, RcsSubmitReplicaSync cmd");

    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);

    //
    // Wait for the command to finish
    //
    WaitForSingleObject(RsCompletionEvent(Cmd), INFINITE);
    FRS_CLOSE(RsCompletionEvent(Cmd));

    WStatus = Cmd->ErrorStatus;
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
    return WStatus;
}


VOID
RcsEndMergeWithDs(
    VOID
    )
/*++
Routine Description:
    The DS has been polled and the replicas have been merged into the
    active replicas.

    Each active replica was initially included in a temporary table.
    Any replica still left in the table is a deleted replica because
    its corresponding entry in the DS was not found.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsEndMergeWithDs:"
    PVOID       Key;
    PREPLICA    Replica;
    DWORD       ReplicaSetsDeleted;
    extern BOOL DsIsShuttingDown;
    extern CRITICAL_SECTION MergingReplicasWithDs;
    extern ULONG DsPollingInterval;
    extern ULONG DsPollingShortInterval;

    //
    // Any replica that is in the state "not merged" should be deleted
    // unless the Ds is shutting down; in which case do not process
    // deletes because a sysvol seeding operation may be in progress.
    // We do not want to delete the sysvol we are currently trying to
    // create.
    //
    Key = NULL;
    while (!DsIsShuttingDown &&
           (Replica = GTabNextDatum(ReplicasNotInTheDs, &Key))) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, submit replica CMD_DELETE");
        RcsSubmitReplica(Replica, NULL, CMD_DELETE);
    }

    DbsProcessReplicaFaultList(&ReplicaSetsDeleted);

    //
    // If any replica sets were deleted while processing the fault list then we should
    // trigger the next poll sooner so we can start the non-auth restore on the
    // deleted replica sets.
    //
    if (ReplicaSetsDeleted) {
        DsPollingInterval = DsPollingShortInterval;
    }

    GTabFreeTable(ReplicasNotInTheDs, NULL);
    ReplicasNotInTheDs = NULL;

    //
    // Synchronize with sysvol seeding
    //
    LeaveCriticalSection(&MergingReplicasWithDs);
}


VOID
RcsReplicaSetRegistry(
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    This function stores information about the replica set
    into the registry for use by ntfrsupg /restore
    (non-authoritative restore).

Arguments:

    Replica

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "RcsReplicaSetRegistry:"
    DWORD   WStatus;
    PWCHAR  ReplicaSetTypeW;
    DWORD   NumberOfPartners;
    DWORD   BurFlags;
    DWORD   ReplicaSetTombstoned;
    HKEY    HSeedingsKey = INVALID_HANDLE_VALUE;
    WCHAR   GuidW[GUID_CHAR_LEN + 1];

    //
    // Sanity check
    //
    if (!Replica ||
        !Replica->SetName || !Replica->SetName->Name ||
        !Replica->MemberName || !Replica->MemberName->Guid) {
        DPRINT(4, ":S: WARN - Partial replica set ignored\n");
        return;
    }

    //
    // Working path to jet Database dir.
    //
    CfgRegWriteString(FKC_SETS_JET_PATH, NULL, FRS_RKF_CREATE_KEY, JetPath);

    //
    // Create the subkey for this set
    //
    GuidToStrW(Replica->MemberName->Guid, GuidW);

    //
    // Replica set name
    // Replica set root path
    // Replica set stage path
    //
    CfgRegWriteString(FKC_SET_N_REPLICA_SET_NAME,
                      GuidW,
                      FRS_RKF_CREATE_KEY,
                      Replica->SetName->Name);

    CfgRegWriteString(FKC_SET_N_REPLICA_SET_ROOT,
                      GuidW,
                      FRS_RKF_CREATE_KEY,
                      Replica->Root);

    CfgRegWriteString(FKC_SET_N_REPLICA_SET_STAGE,
                      GuidW,
                      FRS_RKF_CREATE_KEY,
                      Replica->Stage);

    //
    // Replica set type
    //
    switch (Replica->ReplicaSetType) {
        case FRS_RSTYPE_ENTERPRISE_SYSVOL:
            ReplicaSetTypeW = NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE;
            break;
        case FRS_RSTYPE_DOMAIN_SYSVOL:
            ReplicaSetTypeW = NTFRSAPI_REPLICA_SET_TYPE_DOMAIN;
            break;
        case FRS_RSTYPE_DFS:
            ReplicaSetTypeW = NTFRSAPI_REPLICA_SET_TYPE_DFS;
            break;
        default:
            ReplicaSetTypeW = NTFRSAPI_REPLICA_SET_TYPE_OTHER;
            break;
    }

    CfgRegWriteString(FKC_SET_N_REPLICA_SET_TYPE,
                      GuidW,
                      FRS_RKF_CREATE_KEY,
                      ReplicaSetTypeW);

    //
    // Replica Set Tombstoned
    //
    ReplicaSetTombstoned = (!IS_TIME_ZERO(Replica->MembershipExpires)) ? 1 : 0;

    CfgRegWriteDWord(FKC_SET_N_REPLICA_SET_TOMBSTONED,
                     GuidW,
                     FRS_RKF_CREATE_KEY,
                     ReplicaSetTombstoned);


    //
    // Update the registry state under Cumulative Replica Sets for this set.
    //

    NumberOfPartners = GTabNumberInTable(Replica->Cxtions);
    //
    // If NumberOfPartners is non zero, subtract the Journal
    // Cxtion entry since its not a real connection
    //
    if (NumberOfPartners > 0) {
        NumberOfPartners -= 1;
    }

    CfgRegWriteDWord(FKC_CUMSET_N_NUMBER_OF_PARTNERS,
                     GuidW,
                     FRS_RKF_CREATE_KEY,
                     NumberOfPartners);


    //
    // Init Backup / Restore flags.
    //
    BurFlags = NTFRSAPI_BUR_FLAGS_NONE;
    CfgRegWriteDWord(FKC_CUMSET_N_BURFLAGS, GuidW, FRS_RKF_CREATE_KEY, BurFlags);


    //
    // If done seeding then cleanup the sysvol seeding key.
    //
    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING)) {

        WStatus = CfgRegOpenKey(FKC_SYSVOL_SEEDING_SECTION_KEY,
                                NULL,
                                FRS_RKF_CREATE_KEY,
                                &HSeedingsKey);
        CLEANUP1_WS(4, ":S: WARN - Cannot create sysvol seedings key for %ws;",
                    Replica->SetName->Name, WStatus, CLEANUP);

        //
        // Seeding is over so delete sysvol seeding key using replica set Name.
        //
        WStatus = RegDeleteKey(HSeedingsKey, Replica->ReplicaName->Name);
        DPRINT1_WS(4, ":S: WARN - Cannot delete seeding key for %ws;",
                   Replica->SetName->Name, WStatus);
    }

CLEANUP:

    FRS_REG_CLOSE(HSeedingsKey);
}


BOOL
RcsReplicaIsRestored(
    IN PREPLICA Replica
    )
/*++

Routine Description:

    Check if the replica set should be deleted because it has been
    restored. Only called from RcsInitKnownReplicaSetMembers() at startup. The
    BurFlags will be wiped after the replica set is recreated (if ever).

Arguments:

    Replica

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "RcsReplicaIsRestored:"
    DWORD   WStatus;
    DWORD   BurFlags;
    BOOL    IsRestored = FALSE;
    WCHAR   GuidW[GUID_CHAR_LEN + 1];

    //
    // Sanity check
    //
    if (!Replica ||
        !Replica->MemberName || !Replica->MemberName->Guid) {
        DPRINT(0, ":S: WARN - Partial replica set ignored\n");
        return IsRestored;
    }

    //
    // Get BurFlags
    //   FRS_CONFIG_SECTION\Cumulative Replica Sets\Replica Sets\<guid>\BurFlags
    //
    GuidToStrW(Replica->MemberName->Guid, GuidW);

    WStatus = CfgRegReadDWord(FKC_CUMSET_N_BURFLAGS, GuidW, FRS_RKF_CREATE_KEY, &BurFlags);
    CLEANUP_WS(0, ":S: ERROR - Can't read FKC_CUMSET_N_BURFLAGS;", WStatus, CLEANUP);

    if ((BurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) &&
        (BurFlags & NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY) &&
        (BurFlags & (NTFRSAPI_BUR_FLAGS_PRIMARY |
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE))) {
        //
        // SUCCESS
        //
        IsRestored = TRUE;
        DPRINT1(4, ":S: %ws has been restored\n", Replica->SetName->Name);
    } else {
        //
        // FAILURE
        //
        DPRINT1(4, ":S: %ws has not been restored\n", Replica->SetName->Name);
    }

CLEANUP:

    return IsRestored;
}


VOID
RcsReplicaDeleteRegistry (
    IN PREPLICA     Replica
    )
/*++

Routine Description:

    This function deletes the information about the replica set
    from the registry.

Arguments:

    Replica

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "RcsReplicaDeleteRegistry:"
    DWORD   WStatus;
    HKEY    HKey = INVALID_HANDLE_VALUE;
    HKEY    HAllSetsKey = INVALID_HANDLE_VALUE;
    HKEY    HCumusKey = INVALID_HANDLE_VALUE;
    WCHAR   GuidW[GUID_CHAR_LEN + 1];

    //
    // Sanity check
    //
    if (!Replica ||
        !Replica->SetName || !Replica->SetName->Name ||
        !Replica->MemberName || !Replica->MemberName->Guid) {
        DPRINT(0, ":S: WARN - Partial replica set ignored\n");
        return;
    }

    //
    // Delete old state from the registry
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_CONFIG_SECTION,
                           0,
                           KEY_ALL_ACCESS,
                           &HKey);
    CLEANUP1_WS(0, ":S: WARN - Cannot open parameters for %ws;",
                Replica->SetName->Name, WStatus, CLEANUP);

    //
    // Create the subkey for all sets
    //
    WStatus = RegCreateKey(HKey, FRS_SETS_KEY, &HAllSetsKey);
    CLEANUP1_WS(0, ":S: WARN - Cannot create sets key for %ws;",
                Replica->SetName->Name, WStatus, CLEANUP);

    //
    // Delete the subkey for this set
    //
    GuidToStrW(Replica->MemberName->Guid, GuidW);
    WStatus = RegDeleteKey(HAllSetsKey, GuidW);
    CLEANUP1_WS(0, ":S: WARN - Cannot delete set key for %ws;",
                Replica->SetName->Name, WStatus, CLEANUP);

    //
    // Cumulative Replica Sets
    //
    //
    // Create the subkey for all sets
    //
    WStatus = RegCreateKey(HKey, FRS_CUMULATIVE_SETS_KEY, &HCumusKey);
    CLEANUP1_WS(0, ":S: WARN - Cannot create cumulative sets key for %ws;",
                Replica->SetName->Name, WStatus, CLEANUP);

    //
    // Delete the subkey for this set
    //
    WStatus = RegDeleteKey(HCumusKey, GuidW);
    CLEANUP1_WS(0, ":S: WARN - Cannot delete cumulative key for %ws;",
                Replica->SetName->Name, WStatus, CLEANUP);

CLEANUP:
    FRS_REG_CLOSE(HKey);
    FRS_REG_CLOSE(HAllSetsKey);
    FRS_REG_CLOSE(HCumusKey);
}


VOID
RcsReplicaClearRegistry(
    VOID
    )
/*++

Routine Description:

    This function deletes all of the replica set information in the registry.
    This function should only be called after enumerating the configrecords.

Arguments:

    None.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "RcsReplicaClearRegistry:"
    DWORD   WStatus;
    HKEY    HKey = INVALID_HANDLE_VALUE;
    HKEY    HAllSetsKey = INVALID_HANDLE_VALUE;
    WCHAR   KeyBuf[MAX_PATH + 1];

    //
    // Empty the replica set info out of the registry
    //

    //
    // Set new state in the registry
    //
    WStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           FRS_CONFIG_SECTION,
                           0,
                           KEY_ALL_ACCESS,
                           &HKey);
    CLEANUP_WS(0, "WARN - Cannot open parameters for delete sets", WStatus, CLEANUP);

    //
    // Create the subkey for all sets
    //
    WStatus = RegCreateKey(HKey, FRS_SETS_KEY, &HAllSetsKey);
    CLEANUP_WS(0, "WARN - Cannot create sets key for delete sets", WStatus, CLEANUP);

    //
    // Delete the subkeys
    //
    do {
        WStatus = RegEnumKey(HAllSetsKey, 0, KeyBuf, MAX_PATH + 1);
        if (WIN_SUCCESS(WStatus)) {
            WStatus = RegDeleteKey(HAllSetsKey, KeyBuf);
        }
    } while (WIN_SUCCESS(WStatus));

    if (WStatus != ERROR_NO_MORE_ITEMS) {
        CLEANUP_WS(0, "WARN - Cannot delete all keys", WStatus, CLEANUP);
    }

CLEANUP:
    FRS_REG_CLOSE(HKey);
    FRS_REG_CLOSE(HAllSetsKey);
}


DWORD
RcsCreateReplicaSetMember(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Create a database record for Replica.

Arguments:
    Replica

Return Value:
    An Frs Error status
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCreateReplicaSetMember:"
    ULONG                   Status;
    ULONG                   FStatus;
    ULONG                   WStatus;
    ULONG                   RootLen;
    ULONG                   i, Rest;

    PVOID                   Key;
    PCXTION                 Cxtion;
    PCOMMAND_PACKET         Cmd = NULL;
    PTABLE_CTX              TableCtx = NULL;
    PWCHAR                  WStatusUStr, FStatusUStr;


#define  CXTION_EVENT_RPT_MAX 8
    PWCHAR InWStr, OutWStr, WStrArray[CXTION_EVENT_RPT_MAX];

#define  CXTION_STR_MAX  256
    WCHAR CxtionStr[CXTION_STR_MAX];


    extern ULONGLONG        ActiveChange;

    Replica->FStatus = FrsErrorSuccess;

    //
    // We are creating a new replica set member. Set the Cnf flag to CONFIG_FLAG_SEEDING.
    // This will trigger a serialvvjoin for this replica set.
    if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_PRIMARY)) {
        SetFlag(Replica->CnfFlags, CONFIG_FLAG_SEEDING);
    }


    //
    // Table context?
    //
    TableCtx = DbsCreateTableContext(ConfigTablex);

    //
    // Submitted to the db command server
    //
    Cmd = DbsPrepareCmdPkt(NULL,                //  Cmd,
                           Replica,             //  Replica,
                           CMD_CREATE_REPLICA_SET_MEMBER, //  CmdRequest,
                           TableCtx,            //  TableCtx,
                           NULL,                //  CallContext,
                           0,                   //  TableType,
                           0,                   //  AccessRequest,
                           0,                   //  IndexType,
                           NULL,                //  KeyValue,
                           0,                   //  KeyValueLength,
                           FALSE);              //  Submit

    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Submit DB CMD_CREATE_REPLICA_SET_MEMBER");
    //
    // SUBMIT DB Cmd and wait for completion.
    //
    WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
    Replica->FStatus = Cmd->Parameters.DbsRequest.FStatus;
    //
    // If wait or database op failed
    //
    if (!WIN_SUCCESS(WStatus) || !FRS_SUCCESS(Replica->FStatus)) {
        //
        // If wait / submit failed then let caller know cmd srv submit failed.
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            Replica->FStatus = FrsErrorCmdSrvFailed;
        }

        DPRINT2_FS(0, ":S: ERROR - %ws\\%ws: Create Replica failed;",
                Replica->SetName->Name, Replica->MemberName->Name, Replica->FStatus);

        DPRINT_WS(0, "ERROR: Create Replica DB Command failed", WStatus);

        //
        // Post the failure in the event log.
        //
        WStatusUStr = FrsAtoW(ErrLabelW32(WStatus));
        FStatusUStr = FrsAtoW(ErrLabelFrs(Replica->FStatus));

        EPRINT8(EVENT_FRS_REPLICA_SET_CREATE_FAIL,
                Replica->SetName->Name,
                ComputerDnsName,
                Replica->MemberName->Name,
                Replica->Root,
                Replica->Stage,
                JetPath,
                WStatusUStr,
                FStatusUStr);

        FrsFree(WStatusUStr);
        FrsFree(FStatusUStr);

        goto out;
    }

    //
    // Post the success in the event log.
    //
    EPRINT6(EVENT_FRS_REPLICA_SET_CREATE_OK,
            Replica->SetName->Name,
            ComputerDnsName,
            Replica->MemberName->Name,
            Replica->Root,
            Replica->Stage,
            JetPath);

    //
    // Increment the Replica Sets Created Counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, RSCreated, 1);


    InWStr = FrsGetResourceStr(IDS_INBOUND);
    OutWStr = FrsGetResourceStr(IDS_OUTBOUND);
    i = 0;

    //
    // Create the cxtions
    //
    Key = NULL;
    while (Cxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
        Key = NULL;

        //
        // Skip inconsistent cxtions and journal cxtions
        //
        if ((!Cxtion->JrnlCxtion) &&
            CxtionFlagIs(Cxtion, CXTION_FLAGS_CONSISTENT)) {
            CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, submit cmd CMD_OUTLOG_ADD_NEW_PARTNER");
            FStatus = OutLogSubmit(Replica, Cxtion, CMD_OUTLOG_ADD_NEW_PARTNER);

            CXTION_STATE_TRACE(3, Cxtion, Replica, FStatus, "F, CMD_OUTLOG_ADD_NEW_PARTNER return");
            //
            // Build a string for the event log.
            //
            if (Cxtion->PartnerDnsName != NULL) {
                _snwprintf(CxtionStr, CXTION_STR_MAX, L"%ws  \"%ws\"",
                           Cxtion->Inbound ? InWStr : OutWStr,
                           Cxtion->PartnerDnsName);

                CxtionStr[CXTION_STR_MAX-1] = UNICODE_NULL;

                WStrArray[i++] = FrsWcsDup(CxtionStr);

                if (i == CXTION_EVENT_RPT_MAX) {

                    EPRINT9(EVENT_FRS_REPLICA_SET_CXTIONS, Replica->SetName->Name,
                           WStrArray[0], WStrArray[1], WStrArray[2], WStrArray[3],
                           WStrArray[4], WStrArray[5], WStrArray[6], WStrArray[7]);

                    for (i = 0; i < CXTION_EVENT_RPT_MAX; i++) {
                        WStrArray[i] = FrsFree(WStrArray[i]);
                    }

                    i = 0;
                }
            }
        }
        //
        // Done with this cxtion
        //
        GTabDelete(Replica->Cxtions, Cxtion->Name->Guid, NULL, FrsFreeType);
    }

    if (i > 0) {
        //
        // print any left over.
        //
        Rest = i;
        for (i = Rest; i < CXTION_EVENT_RPT_MAX; i++) {
            WStrArray[i] = L" ";
        }

        EPRINT9(EVENT_FRS_REPLICA_SET_CXTIONS, Replica->SetName->Name,
               WStrArray[0], WStrArray[1], WStrArray[2], WStrArray[3],
               WStrArray[4], WStrArray[5], WStrArray[6], WStrArray[7]);

        for (i = 0; i < Rest; i++) {
            WStrArray[i] = FrsFree(WStrArray[i]);
        }
    }

    FrsFree(InWStr);
    FrsFree(OutWStr);

    //
    // Set the OID data structure which is a part of the
    // counter data structure stored in the hash table
    // Add ReplicaSet Instance to the registry
    //
    if (Replica->Root != NULL) {
        DPRINT(5, "PERFMON:Adding Set:REPLICA.C:1\n");
        AddPerfmonInstance(REPLICASET, Replica->PerfRepSetData, Replica->Root);
    }

    //
    // Add to the replica tables (by guid and by number)
    //
    Replica->Queue = FrsAlloc(sizeof(FRS_QUEUE));
    FrsInitializeQueue(Replica->Queue, &ReplicaCmdServer.Control);

    GTabInsertEntry(ReplicasByGuid, Replica, Replica->ReplicaName->Guid, NULL);
    GTabInsertEntry(ReplicasByNumber, Replica, &Replica->ReplicaNumber, NULL);

    //
    // WARNING: NO Failure return is allowed after this point because the
    // Replica struct is pointed at by a number of other data structs like the
    // Three above.  A Failure return here causes our caller to free the replica
    // struct but of course it does that without first pulling it out of any of
    // the above or calling the DB Service to tell it that the replica struct is
    // going away This is unfortunate but its 7/8/99 and too late to clean this up.
    //

    //
    // Set registry value "FilesNotToBackup"
    //
    CfgFilesNotToBackup(ReplicasByGuid);

    //
    // Open the replica set
    //
    RcsOpenReplicaSetMember(Replica);

    //
    // See comment above.
    //
    Replica->FStatus = FrsErrorSuccess;


    //if (Replica->FStatus != FrsErrorSuccess) {
    //    goto out;
    //}


    //
    // Insert replica information into the registry
    //
    RcsReplicaSetRegistry(Replica);

out:
    if (Cmd) {
        FrsFreeCommand(Cmd, NULL);
    }
    if (TableCtx) {
        DbsFreeTableContext(TableCtx, 0);
    }
    if (!FRS_SUCCESS(Replica->FStatus)) {
        //
        // Ds poll thread will restart the replica during the next
        // polling cycle if ActiveChange is set to 0.
        //
        ActiveChange = 0;
    }

    return Replica->FStatus;
}


BOOL
RcsReplicaHasExpired(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Has this replica's tombstone expired?

Arguments:
    Replica

Return Value:
    TRUE    - Tombstone has expired.
    FALSE   - Not tombstoned or tombstone has not expired.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsReplicaHasExpired:"
    FILETIME    FileTime;
    ULONGLONG   Now;

    //
    // Is it tombstoned?
    //
    if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
        GetSystemTimeAsFileTime(&FileTime);
        COPY_TIME(&Now, &FileTime);
        //
        // Has it expired?
        //
        if (Now > Replica->MembershipExpires) {
            REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Replica has expired");
            return TRUE;
        }
    }
    //
    // Not expired
    //
    return FALSE;
}




PREPLICA
RcsFindSysVolByType(
    IN DWORD   ReplicaSetType
    )
/*++
Routine Description:
    Find the sysvol with the indicated type.

Arguments:
    ReplicaSetType

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFindSysVolByType:"
    PREPLICA    Replica;
    PVOID       Key;

    //
    // Find a match for the sysvol by name
    //
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        if (!FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType)) {
            continue;
        }
        //
        // SysVol types match
        //
        if (Replica->ReplicaSetType == ReplicaSetType) {
            //
            // Don't return expired replicas
            //
            if (RcsReplicaHasExpired(Replica)) {
                DPRINT2(4, ":S: %ws\\%ws: IGNORING, tombstoned expired.\n",
                        Replica->SetName->Name, Replica->MemberName->Name);
                continue;
            }
            return Replica;
        }
    }
    return NULL;
}


PREPLICA
RcsFindSysVolByName(
    IN PWCHAR   ReplicaSetName
    )
/*++
Routine Description:
    The replica set from the Ds could not be located by its Ds-object guid.
    This may be a sysvol that has been seeded but hasn't picked up its
    guids from its Ds objects. Try to find the sysvol by name.

Arguments:
    ReplicaSetName

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFindSysVolByName:"
    PREPLICA    Replica;
    PVOID       Key;
    FILETIME    FileTime;
    ULONGLONG   Now;

    //
    // Find a match for the sysvol by name
    //
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        if (!FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType)) {
            continue;
        }
        if (WSTR_EQ(ReplicaSetName, Replica->ReplicaName->Name)) {
            //
            // Don't return expired replicas
            //
            if (RcsReplicaHasExpired(Replica)) {
                DPRINT2(4, ":S: %ws\\%ws: IGNORING, tombstoned expired.\n",
                        Replica->SetName->Name, Replica->MemberName->Name);
                continue;
            }
            return Replica;
        }
    }
    return NULL;
}






PREPLICA
RcsFindNextReplica(
    IN PVOID    *Key
    )
/*++
Routine Description:
    Return the next replica in the active replication subsystem.

Arguments:
    Key

Return Value:
    Replica or NULL.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFindNextReplica:"
    //
    // Next replica
    //
    return GTabNextDatum(ReplicasByGuid, Key);
}


VOID
RcsMergeReplicaFromDs(
    IN PREPLICA DsReplica
    )
/*++
Routine Description:
    Merge this replica from the DS with the active replicas.

Arguments:
    DsReplica

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsMergeReplicaFromDs:"
    PVOID       Key;
    PREPLICA    Replica;

    DPRINT(4, ":S: Merge Replica from the DS\n");
    FRS_PRINT_TYPE(4, DsReplica);

    //
    // If the replica is not in the table, create it
    //
    Replica = GTabLookup(ReplicasByGuid, DsReplica->ReplicaName->Guid, NULL);

    if (Replica && REPLICA_STATE_NEEDS_RESTORE(Replica->ServiceState)) {
        //
        // This replica is on the fault list and will be deleted at the end
        // of poll when we process the fault list. We should not try to
        // do anything with this replica. Just remove it from ReplicasNotInTheDs
        // table and free the DsReplica structure.
        //
        GTabDelete(ReplicasNotInTheDs, Replica->ReplicaName->Guid, NULL, NULL);
        FrsFreeType(DsReplica);
        return;
    }
    //
    // Might be a sysvol that has been seeded but hasn't picked up
    // its final guids from its Ds objects. Try to find it by name.
    //
    if (!Replica &&
        FRS_RSTYPE_IS_SYSVOL(DsReplica->ReplicaSetType)) {
        //
        // Pretend there isn't a match if the replica has already
        // been merged with the info in the DS. We only want to merge once.
        // We deduce that the merge hasn't occured if the replica set
        // guid and the root guid are the same. They should be different
        // since the replica set guid wasn't available when the root
        // guid was created.
        //
        // Otherwise, we could end up with a sysvol replica that
        // claims its root path is an old sysvol root instead of a new
        // sysvol root (assuming ntfrsupg was run twice).
        //
        // The old sysvol will be tombstoned and will eventually
        // be deleted.
        //
        // Note: seeding during dcpromo is now broken since root guid
        //       is created when set is created in the db and so
        //       never matches the set guid. fix if seeding during
        //       dcpromo is resurrected (with CnfFlag)
        //
        Replica = RcsFindSysVolByName(DsReplica->ReplicaName->Name);
        if (Replica && !GUIDS_EQUAL(Replica->SetName->Guid,
                                    Replica->ReplicaRootGuid)) {
            Replica = NULL;
        }
    }
    if (Replica) {
        //
        // Replica still exists in the DS; don't delete it
        //
        GTabDelete(ReplicasNotInTheDs, Replica->ReplicaName->Guid, NULL, NULL);
        //
        // Tell the replica to merge with the information from the DS
        // and to retry any failed or new startup operations like
        // starting the journal and joining new connections.
        //
        if (DsReplica->Consistent) {
            (VOID) RcsSubmitReplicaSync(Replica, DsReplica, NULL, CMD_START);
        } else {
            //
            // WARN: it looks like it gets freed here but still lives in the
            //       ReplicasByGuid table --- AV later if table enumed.
            //       RcsBeginMergeWithDs() does an enum of this table.
            //
            FrsFreeType(DsReplica);
        }
    } else {
        //
        // Insert the replica into the database and add it to the table
        // of active replicas. Comm packets will continue to be discarded
        // because the replica is not yet "accepting" remote change orders
        //
        // Replica sets for sysvols must exist in the database prior to
        // the entries in the Ds. If the opposite is true then the entry
        // in the Ds is bogus; probably the result of the Ds polling thread
        // being unabled to delete the Ds objects after a dcdemote. In
        // any case, ignore the Ds.
        //
        if (DsReplica->Consistent &&
           FRS_SUCCESS(RcsCreateReplicaSetMember(DsReplica))) {
                RcsSubmitReplicaSync(DsReplica, NULL, NULL, CMD_START);
        } else {
            //
            // WARN: The above could happen here too if Consistent is false
            // and DsReplica is in a table.
            // Also happens if RcsCreateReplicaSetMember() fails.
            // since it can fail after DsReplica is added to.
            // the ReplicasByGuid and ReplicasByNumber tables. Sigh.
            //
            FrsFreeType(DsReplica);
        }
    }
}


VOID
RcsMergeReplicaGName(
    IN PREPLICA Replica,
    IN PWCHAR   Tag,
    IN PGNAME   GName,
    IN PGNAME   NewGName
    )
/*++
Routine Description:
    Update the Replica with new information from NewReplica.

Arguments:
    Replica
    GName
    NewGName

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsMergeReplicaGName:"

    //
    // Name
    //
    if (WSTR_NE(GName->Name, NewGName->Name)) {
        DPRINT5(0, "++ %ws\\%ws - Changing %ws name from %ws to %ws.\n",
                Replica->ReplicaName->Name, Replica->MemberName->Name, Tag,
                GName->Name, NewGName->Name);

        FrsDsSwapPtrs(&GName->Name, &NewGName->Name);
        Replica->NeedsUpdate = TRUE;
    }
    //
    // Guid
    //
    if (!GUIDS_EQUAL(GName->Guid, NewGName->Guid)) {
        DPRINT3(0, "++ %ws\\%ws - Changing guid for %ws.\n",
                Replica->ReplicaName->Name, Replica->MemberName->Name, Tag);

        FrsDsSwapPtrs(&GName->Guid, &NewGName->Guid);
        Replica->NeedsUpdate = TRUE;
    }
}


VOID
RcsMergeReplicaFields(
    IN PREPLICA Replica,
    IN PREPLICA NewReplica
    )
/*++
Routine Description:
    Update the Replica with new information from NewReplica.

Arguments:
    Replica     - active replica
    NewReplica

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsMergeReplicaFields:"
    BOOL            IsSysVol;
    PWCHAR          DirFilterList;
    PWCHAR          TmpList;
    UNICODE_STRING  TempUStr;

    if (NewReplica == NULL) {
        return;
    }
    //
    // CHECK FIELDS THAT CAN'T CHANGE
    //

    //
    // Replica type
    //
    if (Replica->ReplicaSetType != NewReplica->ReplicaSetType) {
        DPRINT4(0, "++ ERROR - %ws\\%ws - Changing replica type from %d to %d is not allowed.\n",
                Replica->ReplicaName->Name, Replica->MemberName->Name,
                Replica->ReplicaSetType, NewReplica->ReplicaSetType);
        NewReplica->Consistent = FALSE;
        return;
    }

    //
    // ReplicaName Guid
    //
    IsSysVol = FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType);
    if (!GUIDS_EQUAL(Replica->ReplicaName->Guid, NewReplica->ReplicaName->Guid)) {
        if (!IsSysVol) {
            DPRINT2(0, "++ ERROR - %ws\\%ws - Changing replica guid is not allowed.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name);
            return;
        }
    }

    //
    // Set Guid
    //
    if (!GUIDS_EQUAL(Replica->SetName->Guid, NewReplica->SetName->Guid)) {
        if (!IsSysVol) {
            DPRINT2(0, "++ ERROR - %ws\\%ws - Changing set guid is not allowed.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name);
            return;
        }
    }

    //
    // Root Guid
    //      Cannot be changed because it is created whenever the set
    //      is created in the DB. The root guid from the DS is always
    //      ignored.
    //
    // if (!GUIDS_EQUAL(Replica->ReplicaRootGuid, NewReplica->ReplicaRootGuid)) {
        // if (!IsSysVol) {
            // DPRINT2(0, "++ ERROR - %ws\\%ws - Changing root guid "
                    // "is not allowed.\n",
                    // Replica->ReplicaName->Name,
                    // Replica->MemberName->Name);
            // return;
        // }
    // }

    //
    // Stage Path.
    //
    if (WSTR_NE(Replica->Stage, NewReplica->Stage)) {

        DPRINT3(3, "The staging path for the replica set (%ws) has changed from (%ws) to (%ws).\n",
                Replica->SetName->Name, Replica->Stage, NewReplica->Stage);

        EPRINT3(EVENT_FRS_STAGE_HAS_CHANGED, Replica->SetName->Name, Replica->Stage,
                NewReplica->Stage);

        FrsFree(Replica->NewStage);
        Replica->NewStage = FrsWcsDup(NewReplica->Stage);
        Replica->NeedsUpdate = TRUE;
    }

    //
    // Updating the replica's guid is tricky since the guid is
    // used by the other subsystems, like RPC, to find a replica
    // set. Both the old and new guid are temporarily in the
    // lookup table. Once the guid is updated, the old entry is
    // deleted.
    //
    if (!GUIDS_EQUAL(Replica->ReplicaName->Guid, NewReplica->ReplicaName->Guid)) {
        DPRINT2(0, "++ %ws\\%ws - Changing guid for Replica.\n",
                Replica->ReplicaName->Name, Replica->MemberName->Name);

        GTabInsertEntry(ReplicasByGuid, Replica, NewReplica->ReplicaName->Guid, NULL);
        FrsDsSwapPtrs(&Replica->ReplicaName->Guid, &NewReplica->ReplicaName->Guid);

        GTabDelete(ReplicasByGuid, NewReplica->ReplicaName->Guid, NULL, NULL);
        COPY_GUID(NewReplica->ReplicaName->Guid, Replica->ReplicaName->Guid);
        Replica->NeedsUpdate = TRUE;
    }

    //
    // FIELDS THAT CAN CHANGE
    //

    //
    // FrsRsoFlags
    //
    Replica->FrsRsoFlags = NewReplica->FrsRsoFlags;

    //
    // ReplicaName (note that the guid was handled above)
    //
    RcsMergeReplicaGName(Replica, L"Replica", Replica->ReplicaName, NewReplica->ReplicaName);

    //
    // MemberName
    //
    RcsMergeReplicaGName(Replica, L"Member", Replica->MemberName, NewReplica->MemberName);
    //
    // SetName
    //
    RcsMergeReplicaGName(Replica, L"Set", Replica->SetName, NewReplica->SetName);
    //
    // Schedule
    //
    if (Replica->Schedule || NewReplica->Schedule) {
        if ((Replica->Schedule && !NewReplica->Schedule) ||
            (!Replica->Schedule && NewReplica->Schedule) ||
            (Replica->Schedule->Size != NewReplica->Schedule->Size) ||
            (memcmp(Replica->Schedule,
                    NewReplica->Schedule,
                    Replica->Schedule->Size))) {
            DPRINT2(0, "++ %ws\\%ws - Changing replica schedule.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name);

            FrsDsSwapPtrs(&Replica->Schedule, &NewReplica->Schedule);
            Replica->NeedsUpdate = TRUE;
        }
    }

    //
    // File Exclusion Filter
    //
    if (Replica->FileFilterList || NewReplica->FileFilterList) {
        if ((Replica->FileFilterList && !NewReplica->FileFilterList) ||
            (!Replica->FileFilterList && NewReplica->FileFilterList) ||
            WSTR_NE(Replica->FileFilterList, NewReplica->FileFilterList)) {

            DPRINT4(0, "++ %ws\\%ws - Changing file filter from %ws to %ws.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name,
                    Replica->FileFilterList, NewReplica->FileFilterList);

            FrsDsSwapPtrs(&Replica->FileFilterList, &NewReplica->FileFilterList);
            if (!Replica->FileFilterList) {
                Replica->FileFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                               NULL,
                                               RegistryFileExclFilterList,
                                               DEFAULT_FILE_FILTER_LIST);
            }
            RtlInitUnicodeString(&TempUStr, Replica->FileFilterList);
            LOCK_REPLICA(Replica);
            FrsLoadNameFilter(&TempUStr, &Replica->FileNameFilterHead);
            UNLOCK_REPLICA(Replica);
            Replica->NeedsUpdate = TRUE;
        }
    }

    //
    // File Inclusion Filter (Registry only)
    //
    if (Replica->FileInclFilterList || NewReplica->FileInclFilterList) {
        if ((Replica->FileInclFilterList && !NewReplica->FileInclFilterList) ||
            (!Replica->FileInclFilterList && NewReplica->FileInclFilterList) ||
            WSTR_NE(Replica->FileInclFilterList, NewReplica->FileInclFilterList)) {

            DPRINT4(0, "++ %ws\\%ws - Changing file Inclusion filter from %ws to %ws.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name,
                    Replica->FileInclFilterList, NewReplica->FileInclFilterList);

            FrsDsSwapPtrs(&Replica->FileInclFilterList, &NewReplica->FileInclFilterList);

            RtlInitUnicodeString(&TempUStr, Replica->FileInclFilterList);
            LOCK_REPLICA(Replica);
            FrsLoadNameFilter(&TempUStr, &Replica->FileNameInclFilterHead);
            UNLOCK_REPLICA(Replica);
            Replica->NeedsUpdate = TRUE;
        }
    }

    //
    // Directory Filter
    //
    if (Replica->DirFilterList || NewReplica->DirFilterList) {
        if ((Replica->DirFilterList && !NewReplica->DirFilterList) ||
            (!Replica->DirFilterList && NewReplica->DirFilterList) ||
            WSTR_NE(Replica->DirFilterList, NewReplica->DirFilterList)) {

            DPRINT4(0, "++ %ws\\%ws - Changing dir filter from %ws to %ws.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name,
                    Replica->DirFilterList, NewReplica->DirFilterList);

            FrsDsSwapPtrs(&Replica->DirFilterList, &NewReplica->DirFilterList);

            if (!Replica->DirFilterList) {
                Replica->DirFilterList =  FRS_DS_COMPOSE_FILTER_LIST(
                                              NULL,
                                              RegistryDirExclFilterList,
                                              DEFAULT_DIR_FILTER_LIST);
            }

            //
            // Add the pre-install dir, the pre-existing dir and the
            // replication suppression prefix name to the dir filter list.
            //
            DirFilterList = FrsWcsCat3(NTFRS_PREINSTALL_DIRECTORY,
                                       L",",
                                       Replica->DirFilterList);

            TmpList = FrsWcsCat3(NTFRS_PREEXISTING_DIRECTORY, L",", DirFilterList);
            FrsFree(DirFilterList);
            DirFilterList = TmpList;

#if 0
            //
            // This workaround did not solve the DFS dir create problem because the
            // later rename of the dir to the final target name is treated like
            // a movein operation so the dir replicates which was what we were trying
            // to avoid since that led to name morph collisions on other DFS alternates
            // which were doing the same thing.
            //
            TmpList = FrsWcsCat3(NTFRS_REPL_SUPPRESS_PREFIX, L"*,", DirFilterList);
            FrsFree(DirFilterList);
            DirFilterList = TmpList;
#endif

            DPRINT3(0, "++ %ws\\%ws - New dir filter: %ws\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name, DirFilterList);

            RtlInitUnicodeString(&TempUStr, DirFilterList);

            LOCK_REPLICA(Replica);
            FrsLoadNameFilter(&TempUStr, &Replica->DirNameFilterHead);
            UNLOCK_REPLICA(Replica);

            FrsFree(DirFilterList);
            Replica->NeedsUpdate = TRUE;
        }
    }

    //
    // Directory Inclusion Filter (Registry only)
    //
    if (Replica->DirInclFilterList || NewReplica->DirInclFilterList) {
        if ((Replica->DirInclFilterList && !NewReplica->DirInclFilterList) ||
            (!Replica->DirInclFilterList && NewReplica->DirInclFilterList) ||
            WSTR_NE(Replica->DirInclFilterList, NewReplica->DirInclFilterList)) {

            DPRINT4(0, "++ %ws\\%ws - Changing dir inclusion filter from %ws to %ws.\n",
                    Replica->ReplicaName->Name, Replica->MemberName->Name,
                    Replica->DirInclFilterList, NewReplica->DirInclFilterList);

            FrsDsSwapPtrs(&Replica->DirInclFilterList, &NewReplica->DirInclFilterList);

            RtlInitUnicodeString(&TempUStr, Replica->DirInclFilterList);
            LOCK_REPLICA(Replica);
            FrsLoadNameFilter(&TempUStr, &Replica->DirNameInclFilterHead);
            UNLOCK_REPLICA(Replica);
            Replica->NeedsUpdate = TRUE;
        }
    }

    //
    // The Replica->CnfFlags are only valid when the replica is created.
    // They are ignored thereafter.
    //
}


PCXTION
RcsCreateSeedingCxtion(
    IN PREPLICA Replica,
    IN PCXTION  SeedingCxtion
    )
/*++
Routine Description:
    Create a seeding cxtion if needed.

    This function may open and read the registry.
    This function may RPC to another computer.

Arguments:
    Replica         - active replica
    SeedingCxtion   - seeding cxtion

Return Value:
    NULL    - no seeding cxtion needed (or possible)
    Otherwise, a seeding cxtion with a matching cxtion on
    another computer (specified by the registry).
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCreateSeedingCxtion:"
    DWORD       WStatus;
    PVOID       Key;
    ULONG       ParentAuthLevel;
    PWCHAR      KeyName = NULL;
    PWCHAR      ParentComputer = NULL;
    PWCHAR      ParentPrincName = NULL;
    PWCHAR      ParentNT4Name = NULL;
    handle_t    ParentHandle = NULL;
    PWCHAR      LocalServerName = NULL;
    GUID        SeedingGuid;
    GUID        ParentGuid;
    PSID        pSid = NULL;
    PWCHAR      SidString = NULL;
    PWCHAR      DomainName = NULL;
    DWORD       ccDomainName = 0;
    DWORD       cbSid = 0;
    SID_NAME_USE SidUse = SidTypeInvalid;
    extern ULONGLONG ActiveChange;


    //
    // This operation is non-critical. The sysvol will eventually seed
    // after the FRS and KCC information converges on the appropriate
    // DCs. Hence, trap exceptions and ignore them.
    //
    try {

        //
        // Already created. Seeding during dcpromo.
        //
        if (SeedingCxtion) {
            goto CLEANUP_OK;
        }

        //
        // No seeding cxtion is needed
        //
        if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING)) {
            goto CLEANUP_OK;
        }

        //
        // Do not create another seeding cxtion. The sysvol will eventually
        // be seeded from a KCC generated cxtion (from the DS). But it may
        // take awhile because both the FRS objects and the KCC must converge
        // after the KCC has run. And then the FRS service has to notice the
        // convergence.
        //
        Key = NULL;
        while (SeedingCxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
            if (CxtionFlagIs(SeedingCxtion, CXTION_FLAGS_VOLATILE)) {
                    break;
            }
        }
        if (SeedingCxtion) {
            SeedingCxtion = NULL;
            goto CLEANUP_OK;
        }
        //
        // Retrieve the parent computer's name
        //
        WStatus = CfgRegReadString(FKC_SYSVOL_SEEDING_N_PARENT,
                                   Replica->ReplicaName->Name,
                                   0,
                                   &ParentComputer);

        CLEANUP1_WS(0, ":X: ERROR - no parent computer for %ws :",
                    Replica->ReplicaName->Name, WStatus, CLEANUP_OK);

        //
        // Bind to the parent
        //
        WStatus = NtFrsApi_Rpc_BindEx(ParentComputer,
                                     &ParentPrincName,
                                     &ParentHandle,
                                     &ParentAuthLevel);
        CLEANUP_WS(0, "ERROR - binding", WStatus, CLEANUP);

        DPRINT3(4, ":X: Seeding cxtion has bound to %ws (princ name is %ws) auth level %d\n",
                ParentComputer, ParentPrincName, ParentAuthLevel);

        //
        // Placeholder guid for the cxtion
        //      Updated once the Ds objects are created
        //
        FrsUuidCreate(&SeedingGuid);

        //
        // Get local computer's NT4 style name. Send ServerPrincName if
        // conversion fails.
        //

        LocalServerName = FrsDsConvertName(DsHandle, ServerPrincName, DS_USER_PRINCIPAL_NAME, NULL, DS_NT4_ACCOUNT_NAME);

        if (LocalServerName == NULL) {
            LocalServerName = FrsWcsDup(ServerPrincName);
        }

        //
        // Create volatile cxtion on the parent
        //
        try {
            WStatus = FrsRpcStartPromotionParent(ParentHandle,
                                                 NULL,
                                                 NULL,
                                                 Replica->SetName->Name,
                                                 NTFRSAPI_REPLICA_SET_TYPE_DOMAIN,
                                                 ParentComputer,
// Change the following to ComputerName for old DNS behavior
                                                 ComputerDnsName,
                                                 LocalServerName,   // NT$ style name or user principal name.
                                                 ParentAuthLevel,
                                                 sizeof(GUID),
                                                 (PUCHAR)&SeedingGuid,
                                                 (PUCHAR)Replica->MemberName->Guid,
                                                 (PUCHAR)&ParentGuid);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            GET_EXCEPTION_CODE(WStatus);
        }
        CLEANUP1_WS(0, ":X: ERROR - Can't create seeding cxtion on parent %ws;",
                    ParentComputer, WStatus, CLEANUP);

        DPRINT3(4, ":X: Seeding cxtion has been created on %ws (princ name is %ws) auth level %d\n",
                ParentComputer, ParentPrincName, ParentAuthLevel);


        ParentNT4Name = FrsDsConvertName(DsHandle, ParentPrincName, DS_USER_PRINCIPAL_NAME, NULL, DS_NT4_ACCOUNT_NAME);

        if (ParentNT4Name == NULL) {
            ParentNT4Name = FrsWcsDup(ParentPrincName);
        }

        if(!LookupAccountName(NULL,
                              ParentNT4Name,
                              NULL, // NULL means the function will give us the required size
                              &cbSid,
                              NULL, // NULL means the function will give us the required size
                              &ccDomainName,
                              &SidUse
                              )) {
            //
            // Couldn't find parent's sid!!
            //

            WStatus = GetLastError();

            if(WStatus != ERROR_INSUFFICIENT_BUFFER) {
                DPRINT2(0, "++ ERROR - Unable to get SID for %ws. WStatus = 0x%08x\n", ParentNT4Name, WStatus);
                goto CLEANUP;
            }

            WStatus = ERROR_SUCCESS;
        }

        //
        // Allocate the needed memory and make the call again.
        //

        DomainName = FrsAlloc(sizeof(WCHAR) * (ccDomainName + 1));
        pSid = FrsAlloc(cbSid);

        if(!LookupAccountName(NULL,
                              ParentNT4Name,
                              pSid,
                              &cbSid,
                              DomainName,
                              &ccDomainName,
                              &SidUse
                              )) {
            //
            // Couldn't find parent's sid!!
            //

            WStatus = GetLastError();
            DPRINT2(0, "++ ERROR - Unable to get SID for %ws. WStatus = 0x%08x\n", ParentNT4Name, WStatus);
            goto CLEANUP;
        }
/*
        if(SidUse != SidTypeComputer) {
            //
            // This Sid is the wrong type.
            //
            DPRINT2(4, "++ WARNING - SID for %ws is not SidTypeComputer. SidUse = %d\n", ParentNT4Name, SidUse);

        }
*/
        if(!ConvertSidToStringSid(pSid, &SidString)) {

            WStatus = GetLastError();
            DPRINT1(0, "++ ERROR - Unable to convert SID to string. WStatus = 0x%08x\n", WStatus);
            goto CLEANUP;

        }

        //
        // Create local seeding cxtion
        //
        SeedingCxtion = FrsAllocType(CXTION_TYPE);
            SeedingCxtion->PartnerSid = FrsWcsDup(SidString);
        LocalFree(SidString);
        SeedingCxtion->Inbound = TRUE;
        SetCxtionFlag(SeedingCxtion, CXTION_FLAGS_CONSISTENT |
                                     CXTION_FLAGS_VOLATILE);

        SeedingCxtion->Name = FrsBuildGName(FrsDupGuid(&SeedingGuid),
                                            FrsWcsDup(ParentComputer));

        SeedingCxtion->Partner = FrsBuildGName(FrsDupGuid(&ParentGuid),
                                               FrsWcsDup(ParentComputer));

        SeedingCxtion->PartnerDnsName = FrsWcsDup(ParentComputer);
        SeedingCxtion->PartnerPrincName = FrsWcsDup(ParentNT4Name);
        SeedingCxtion->PartSrvName = FrsWcsDup(ParentComputer);
        SeedingCxtion->PartnerAuthLevel = ParentAuthLevel;
        SetCxtionState(SeedingCxtion, CxtionStateUnjoined);

CLEANUP_OK:
        WStatus = ERROR_SUCCESS;

CLEANUP:;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "ERROR - Exception", WStatus);
    }
    try {
        if (ParentHandle) {
            RpcBindingFree(&ParentHandle);
        }
        FrsFree(KeyName);
        FrsFree(ParentComputer);
        FrsFree(ParentPrincName);
        FrsFree(ParentNT4Name);
        FrsFree(LocalServerName);
        FrsFree(pSid);
        FrsFree(DomainName);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
        DPRINT_WS(0, "ERROR - Cleanup Exception", WStatus);
    }
    //
    // Retry later. ERROR_SUCCESS means don't retry; there may have
    // been errors that retrying is unlikely to fix.
    //
    if (!WIN_SUCCESS(WStatus)) {
        //
        // Ds poll thread will restart the replica during the next
        // polling cycle if ActiveChange is set to 0.
        //
        ActiveChange = 0;
    }
    return SeedingCxtion;
}


VOID
RcsSetCxtionSchedule(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN DWORD    ScheduleIndex,
    IN DWORD    ScheduleShift
    )
/*++
Routine Description:
    Set or clear the CXTION_FLAGS_SCHEDULE_OFF bit in the cxtion
    depending on whether the 15min interval identified by
    (ScheduleIndex, ScheduleShift) is set.

    Trigger schedules use the bit differently. A triggered cxtion
    may actually be joined and running even if the schedule is OFF
    because the current set of cos haven't been received/sent, yet.

    So, be careful. The interpretation of CXTION_FLAGS_SCHEDULE_OFF
    varies with the type of schedule.

Arguments:
    Replica

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSetCxtionSchedule:"
    ULONG       i;
    BOOL        On;
    PSCHEDULE   Schedule;

    //
    // Set or clear CXTION_FLAGS_SCHEDULE_OFF
    //

    //
    // Inbound connection AND In seeding state AND option is set to
    // ignore schedule.
    //
    if (Cxtion->Inbound &&
        ((BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) ||
          Replica->IsSeeding) &&
         NTDSCONN_IGNORE_SCHEDULE(Cxtion->Options))
       ) {

        Schedule = NULL;

    //
    // Outbound connection AND (In vvjoin mode OR never joined) AND option is set to
    // ignore schedule.
    //
    } else if (!Cxtion->Inbound &&
               ((Cxtion->OLCtx == NULL) ||
                WaitingToVVJoin(Cxtion->OLCtx) ||
                InVVJoinMode(Cxtion->OLCtx)) &&
               NTDSCONN_IGNORE_SCHEDULE(Cxtion->Options)
              ) {

        Schedule = NULL;

    } else {
        //
        // No schedule == always on
        //
        Schedule = Cxtion->Schedule;
        if (!Schedule) {
            Schedule = Replica->Schedule;
        }
    }

    //
    // Is this 15minute interval ON or OFF?
    //
    On = TRUE;
    if (Schedule) {
        //
        // Find the interval schedule
        //
        for (i = 0; i < Schedule->NumberOfSchedules; ++i) {
            if (Schedule->Schedules[i].Type == SCHEDULE_INTERVAL) {
                On = ((*(((PUCHAR)Schedule) +
                      Schedule->Schedules[i].Offset +
                      ScheduleIndex)) >> ScheduleShift) & 1;
                break;
            }
        }
    }
    if (On) {
        DPRINT1(0, ":X: %08x, schedule is on\n",
                (Cxtion->Name && Cxtion->Name->Guid) ? Cxtion->Name->Guid->Data1 : 0);
        ClearCxtionFlag(Cxtion, CXTION_FLAGS_SCHEDULE_OFF);

    } else {
        DPRINT1(0, ":X: %08x, schedule is off.\n",
                (Cxtion->Name && Cxtion->Name->Guid) ? Cxtion->Name->Guid->Data1 : 0);
        SetCxtionFlag(Cxtion, CXTION_FLAGS_SCHEDULE_OFF);
    }
}


VOID
RcsCheckCxtionSchedule(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion
    )
/*++
Routine Description:
    Call the function to set or clear CXTION_FLAGS_SCHEDULE_OFF once
    the current interval has been determined and the appropriate locks
    acquired.

    Called when a replica is "opened" (read from the DB) and when a
    cxtion is created or its schedule altered in RcsMergeReplicaCxtions().

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCheckCxtionSchedule:"
    DWORD       ScheduleIndex;
    DWORD       ScheduleShift;
    SYSTEMTIME  SystemTime;
    DWORD       ScheduleHour;
    BOOL        On;

    //
    // Find the current interval
    //
    GetSystemTime(&SystemTime);
    ScheduleHour = (SystemTime.wDayOfWeek * 24) + SystemTime.wHour;
    ScheduleShift = SystemTime.wMinute / MINUTES_IN_INTERVAL;
    ScheduleIndex = ScheduleHour;
    FRS_ASSERT(ScheduleIndex < SCHEDULE_DATA_BYTES);

    //
    // Set or clear CXTION_FLAGS_SCHEDULE_OFF
    //
    LOCK_CXTION_TABLE(Replica);
    RcsSetCxtionSchedule(Replica, Cxtion, ScheduleIndex, ScheduleShift);
    UNLOCK_CXTION_TABLE(Replica);
}


VOID
RcsCheckSchedules(
    IN PCOMMAND_PACKET Cmd
    )
/*++
Routine Description:
    Check all schedules every so often.

    There are three schedule protocols:
        Sysvol cxtion within a site
        ---------------------------
            The cxtion is always on; any schedule is ignored. Normal join
            retries apply. The normal join retry is to increase the timeout
            by MinJoinTimeout every retry until the join succeeds. A
            successful unjoin is followed by an immediate join.
        Normal cxtion
        -------------
            The schedule is treated as a 15 minute interval stop/start
            schedule. Normal join retries apply.

        Sysvol cxtion between sites
        ---------------------------
            The cxtion is treated as a 15-minute interval trigger schedule.
            The downstream partner initiates the join. The upstream partner
            ignores its schedule and responds to any request by the downstream
            partner. The upstream partner unjoins the cxtion when the current
            contents of the outlog at the time of join have been sent and
            acked.

    For interoperability, the minor comm version was bumped and the
    outbound trigger cxtion is not unjoined when the end-of-join
    control co is encountered if the partner is downrev.

    I.e., B2 <-> B3 systems behave like B2 systems wrt trigger
    scheduled cxtions.

Arguments:
    Cmd

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCheckSchedules:"
    PVOID       ReplicaKey;
    PVOID       CxtionKey;
    PREPLICA    Replica;
    PCXTION     Cxtion;
    DWORD       ScheduleIndex;
    DWORD       ScheduleShift;
    SYSTEMTIME  BeginSystemTime;
    SYSTEMTIME  EndSystemTime;
    DWORD       ScheduleHour;
    DWORD       MilliSeconds;
    BOOL        On;

    DPRINT1(5, ":X: Command check schedules %08x\n", Cmd);

    //
    // Loop if the interval changes during processing
    //
AGAIN:

    //
    // Current 15min interval
    //
    GetSystemTime(&BeginSystemTime);
    ScheduleHour = (BeginSystemTime.wDayOfWeek * 24) + BeginSystemTime.wHour;
    ScheduleShift = BeginSystemTime.wMinute / MINUTES_IN_INTERVAL;
    ScheduleIndex = ScheduleHour;
    FRS_ASSERT(ScheduleIndex < SCHEDULE_DATA_BYTES);

    //
    // For each replica (while not shutting down)
    //
    LOCK_REPLICA_TABLE(ReplicasByGuid);
    ReplicaKey = NULL;
    while ((!FrsIsShuttingDown) &&
           (Replica = GTabNextDatumNoLock(ReplicasByGuid, &ReplicaKey))) {
        //
        // Replica hasn't been started or is deleted; ignore for now
        //
        if (!Replica->IsAccepting) {
            continue;
        }

        //
        // Don't bother; replica has been deleted
        //
        if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
            continue;
        }

        //
        // For each cxtion (while not shutting down)
        //
        LOCK_CXTION_TABLE(Replica);
        CxtionKey = NULL;
        while ((!FrsIsShuttingDown) &&
               (Cxtion = GTabNextDatumNoLock(Replica->Cxtions, &CxtionKey))) {
            //
            // Ignore the (local) journal connection.
            //
            if (Cxtion->JrnlCxtion) {
                continue;
            }
            //
            // Set the cxtion flags related to schedules
            //
            RcsSetCxtionSchedule(Replica, Cxtion, ScheduleIndex, ScheduleShift);
            //
            // Schedule is off. Unjoin the cxtion UNLESS this is
            // a trigger schedule, in which case the cxtion will
            // turn itself off once the current set of changes
            // have been sent.
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_SCHEDULE_OFF)) {
                if (!CxtionStateIs(Cxtion, CxtionStateUnjoined) &&
                    !CxtionStateIs(Cxtion, CxtionStateDeleted) &&
                    !CxtionStateIs(Cxtion, CxtionStateStart) &&
                    !CxtionFlagIs(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE)) {
                    RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_UNJOIN);
                }
            //
            // Schedule is on. Join the cxtion unless it is already
            // joined or is controlled by a trigger schedule. The
            // join is needed for a trigger scheduled cxtion in case
            // the upstream partner has sent its cos and is now
            // unjoined.
            //
            // Do not send a CMD_JOIN if this replica set is still seeding and
            // connection is in INIT_SYNC state and marked paused.
            // Initial sync command server will unpause it when it is ready to join.
            //
            } else {
                if ((!CxtionStateIs(Cxtion, CxtionStateJoined) ||
                     CxtionFlagIs(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE))  &&
                    (!CxtionFlagIs(Cxtion, CXTION_FLAGS_PAUSED)             ||
                    (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) ||
                     !CxtionFlagIs(Cxtion, CXTION_FLAGS_INIT_SYNC)))
                   ) {

                    RcsSubmitReplicaCxtion(Replica, Cxtion, CMD_JOIN_CXTION);
                }
            }
        }
        UNLOCK_CXTION_TABLE(Replica);
    }
    UNLOCK_REPLICA_TABLE(ReplicasByGuid);
    //
    // Has the clock ticked into the next interval? If so, check again
    //
    GetSystemTime(&EndSystemTime);
    if (EndSystemTime.wDayOfWeek != BeginSystemTime.wDayOfWeek ||
        EndSystemTime.wHour != BeginSystemTime.wHour ||
        (EndSystemTime.wMinute / MINUTES_IN_INTERVAL) != (BeginSystemTime.wMinute / MINUTES_IN_INTERVAL)) {
        goto AGAIN;
    }
    //
    // Time until the beginning of the next 15 minute interval
    //
    MilliSeconds = ((((EndSystemTime.wMinute + MINUTES_IN_INTERVAL)
                    / MINUTES_IN_INTERVAL)
                    * MINUTES_IN_INTERVAL)
                    - EndSystemTime.wMinute);
    DPRINT1(5, ":X: Check schedules in %d minutes\n", MilliSeconds);
    MilliSeconds *= (60 * 1000);
    FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, MilliSeconds);
}


VOID
RcsMergeReplicaCxtions(
    IN PREPLICA Replica,
    IN PREPLICA NewReplica,
    IN PCXTION  VolatileCxtion
    )
/*++
Routine Description:
    Update the Replica's cxtions with information from NewReplica.

Arguments:
    Replica     - active replica
    NewReplica
    VolatileCxtion  -- Ptr to a cxtion struct created for temporary connections.
                       Hence the name Volatile.  Currently used for Sysvol Seeding.

Return Value:
    TRUE    - replica set was altered
    FALSE   - replica is unaltered
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsMergeReplicaCxtions:"
    ULONG               FStatus;
    PVOID               Key;
    PCXTION             Cxtion;
    PCXTION             NextCxtion;
    BOOL                UpdateNeeded;
    PCXTION             NewCxtion;

    //
    // Note:  Review - There needs to be a lock on the table or the cxtion
    //                 since the outlog, chgorder, and replica code may
    //                 reference the cxtion struct in parallel.
    //

    //
    // The cxtions are enumerated when the replica is opened. If the
    // replica isn't opened then we don't know the state of the existing
    // cxtions.
    //
    if (!Replica->IsOpen) {
        return;
    }

    //
    // The replica's config record can't be updated; ignore cxtion changes
    //
    if (Replica->NeedsUpdate) {
        return;
    }

    //
    // Add the seeding cxtion
    //      The seeding cxtion is created by the caller when the
    //      sysvol is seeded after dcpromo. Otherwise, it is created
    //      at this time.
    //
    //      WARN - The function may open and read the registry and may
    //      RPC to another computer.
    //
    VolatileCxtion = RcsCreateSeedingCxtion(Replica, VolatileCxtion);
    if (VolatileCxtion) {
        //
        // Update the cxtion table
        //
        // *NOTE*  The following call is synchronous.  If we have the Cxtion
        //         table lock then a hang is possible.
        //
        FStatus = OutLogSubmit(Replica, VolatileCxtion, CMD_OUTLOG_ADD_NEW_PARTNER);
        if (FRS_SUCCESS(FStatus)) {
            //
            // Update the incore cxtion table
            //
            GTabInsertEntry(Replica->Cxtions, VolatileCxtion, VolatileCxtion->Name->Guid, NULL);
            OutLogInitPartner(Replica, VolatileCxtion);
        } else {
            //
            // Chuck the cxtion. We will retry the create during the
            // next ds polling cycle.
            //
            FrsFreeType(VolatileCxtion);
        }
    }

    //
    // Done
    //
    if (!NewReplica) {
        return;
    }

    //
    // Check for altered or deleted cxtions
    //
    Key = NULL;
    for (Cxtion = GTabNextDatum(Replica->Cxtions, &Key); Cxtion; Cxtion = NextCxtion) {
        NextCxtion = GTabNextDatum(Replica->Cxtions, &Key);
        //
        // Ignore the (local) journal connection.
        //
        if (Cxtion->JrnlCxtion) {
            continue;
        }
        //
        // This cxtion is volatile, it will disappear after the sysvol is seeded.
        // NOTE: the cxtion flags are not stored in the database so, at
        // restart, this cxtion will not have the flag, CXTION_FLAGS_VOLATILE,
        // set.  The cxtion is deleted at restart because there isn't a
        // corresponding DS entry.
        //
        if (CxtionFlagIs(Cxtion, CXTION_FLAGS_VOLATILE)) {
            continue;
        }

        NewCxtion = GTabLookup(NewReplica->Cxtions, Cxtion->Name->Guid, NULL);

        //
        // Delete the cxtion after unjoining. A Cxtion is deleted if it is not
        // found in the DS. A connection can also be deleted if the outbound log cleanup
        // decides that a particular outbound connection is holding up COs longer than
        // the specified history time. (Outlog Change History In Minutes)
        //
        if (NewCxtion == NULL || (!Cxtion->Inbound && CxtionFlagIs(Cxtion, CXTION_FLAGS_TRIM_OUTLOG))) {
            //
            // Unjoin the cxtion after setting the deferred delete bit.
            // The deferred delete bit will keep the cxtion from re-joining
            // before it can be deleted during the next pass of the ds
            // polling thread. Warning - cxtion may reappear at any time!
            //
            if (!CxtionStateIs(Cxtion, CxtionStateDeleted)) {
                LOCK_CXTION_TABLE(Replica);
                ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
                ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
                SetCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_DELETE);
                UNLOCK_CXTION_TABLE(Replica);
                RcsForceUnjoin(Replica, Cxtion);
            }
            //
            // If successfully unjoined; move to the deleted-cxtion table
            //
            if (CxtionStateIs(Cxtion, CxtionStateDeleted)) {
                RcsDeleteCxtionFromReplica(Replica, Cxtion);
            }
            continue;
        //
        // Deleted cxtion reappeared; reanimate it
        //
        // if the cxtion is deleted or marked for delete
        //    and new cxtion is consistent
        //    and partner's guid's match
        // then reanimate
        //
        // Don't attempt to reanimate a cxtion if the info in the DS
        // is inconsistent or the cxtion's partner has changed. The
        // cxtion is deleted when its partner changes because the
        // state kept per cxtion is partner specific.
        //
        } else if ((CxtionStateIs(Cxtion, CxtionStateDeleted) ||
                    CxtionFlagIs(Cxtion, CXTION_FLAGS_DEFERRED_DELETE)) &&
                   CxtionFlagIs(NewCxtion, CXTION_FLAGS_CONSISTENT) &&
                   GUIDS_EQUAL(Cxtion->Partner->Guid, NewCxtion->Partner->Guid)) {
            LOCK_CXTION_TABLE(Replica);
            ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_DELETE);
            if (CxtionStateIs(Cxtion, CxtionStateDeleted)) {
                SetCxtionState(Cxtion, CxtionStateUnjoined);
            }
            UNLOCK_CXTION_TABLE(Replica);
        }

        //
        // Check for altered fields; Ignore if not consistent
        //
        if (CxtionFlagIs(NewCxtion, CXTION_FLAGS_CONSISTENT)) {
            //
            // No changes, yet
            //
            UpdateNeeded = FALSE;

            //
            // Ignore all change is a field changed that isn't allowed
            // to change.
            //

            //
            // Cxtion Guid
            //
            if (!GUIDS_EQUAL(Cxtion->Name->Guid, NewCxtion->Name->Guid)) {
                DPRINT2(0, ":X: ERROR - %ws\\%ws - Changing cxtion guid is not allowed.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name);
                goto DELETE_AND_CONTINUE;
            }

            //
            // Partner Guid
            //
            // The cxtion is deleted when its partner changes because the
            // state kept per cxtion is partner specific. If the cxtion
            // has been newly altered so that its previous mismatched
            // partner guid now matches then the check in the previous
            // basic block would have reanimated the cxtion before getting
            // to this code. Hence, the lack of an "else" clause.
            //
            if (!GUIDS_EQUAL(Cxtion->Partner->Guid, NewCxtion->Partner->Guid)) {
                DPRINT2(0, ":X: ERROR - %ws\\%ws - Changing cxtion's partner guid "
                        "is not allowed. DELETING CURRENT CXTION!\n",
                        Replica->MemberName->Name, Cxtion->Name->Name);
                //
                // Unjoin the cxtion after setting the deferred delete bit.
                // The deferred delete bit will keep the cxtion from re-joining
                // before it can be deleted during the next pass of the ds
                // polling thread. Warning - cxtion may reappear at any time!
                //
                if (!CxtionStateIs(Cxtion, CxtionStateDeleted)) {
                    LOCK_CXTION_TABLE(Replica);
                    ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_JOIN);
                    ClearCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_UNJOIN);
                    SetCxtionFlag(Cxtion, CXTION_FLAGS_DEFERRED_DELETE);
                    UNLOCK_CXTION_TABLE(Replica);
                    RcsForceUnjoin(Replica, Cxtion);
                }
                //
                // If successfully unjoined; move to the deleted-cxtion table
                //
                if (CxtionStateIs(Cxtion, CxtionStateDeleted)) {
                    RcsDeleteCxtionFromReplica(Replica, Cxtion);
                }
                goto DELETE_AND_CONTINUE;
            }

            //
            // Partner Name
            //
            if (WSTR_NE(Cxtion->Partner->Name, NewCxtion->Partner->Name)) {
                DPRINT4(4, ":X: %ws\\%ws - Changing cxtion's partner name from %ws to %ws.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        Cxtion->Partner->Name, NewCxtion->Partner->Name);
                FrsDsSwapPtrs(&Cxtion->Partner->Name, &NewCxtion->Partner->Name);
                UpdateNeeded = TRUE;
            }

            //
            // Partner PrincName
            //
            if (WSTR_NE(Cxtion->PartnerPrincName, NewCxtion->PartnerPrincName)) {
                DPRINT4(4, ":X: %ws\\%ws - Changing cxtion's partner princname from %ws to %ws.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        Cxtion->PartnerPrincName, NewCxtion->PartnerPrincName);
                FrsDsSwapPtrs(&Cxtion->PartnerPrincName, &NewCxtion->PartnerPrincName);
                UpdateNeeded = TRUE;
            }

            //
            // Partner Dns Name
            //
            if (WSTR_NE(Cxtion->PartnerDnsName, NewCxtion->PartnerDnsName)) {
                DPRINT4(4, ":X: %ws\\%ws - Changing cxtion's partner DNS name from %ws to %ws.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        Cxtion->PartnerDnsName, NewCxtion->PartnerDnsName);
                FrsDsSwapPtrs(&Cxtion->PartnerDnsName, &NewCxtion->PartnerDnsName);
                UpdateNeeded = TRUE;
            }

            //
            // Partner SID
            //
            if (WSTR_NE(Cxtion->PartnerSid, NewCxtion->PartnerSid)) {
                DPRINT4(4, ":X: %ws\\%ws - Changing cxtion's partner SID from %ws to %ws.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        Cxtion->PartnerSid, NewCxtion->PartnerSid);
                FrsDsSwapPtrs(&Cxtion->PartnerSid, &NewCxtion->PartnerSid);
                UpdateNeeded = TRUE;
            }

            //
            // Cxtion Schedule
            //
            if (Cxtion->Schedule || NewCxtion->Schedule) {
                if ((Cxtion->Schedule && !NewCxtion->Schedule) ||
                    (!Cxtion->Schedule && NewCxtion->Schedule) ||
                    (Cxtion->Schedule->Size != NewCxtion->Schedule->Size) ||
                    (memcmp(Cxtion->Schedule,
                            NewCxtion->Schedule,
                            Cxtion->Schedule->Size))) {
                    DPRINT2(4, ":X: %ws\\%ws - Changing cxtion schedule.\n",
                            Replica->MemberName->Name, Cxtion->Name->Name);
                    FrsDsSwapPtrs(&Cxtion->Schedule, &NewCxtion->Schedule);
                    RcsCheckCxtionSchedule(Replica, Cxtion);
                    UpdateNeeded = TRUE;
                }
            }

            //
            // Partner Server Name
            //
            if (WSTR_NE(Cxtion->PartSrvName, NewCxtion->PartSrvName)) {
                DPRINT4(4, ":X: %ws\\%ws - Changing partner's server name from %ws to %ws.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        Cxtion->PartSrvName, NewCxtion->PartSrvName);
                FrsDsSwapPtrs(&Cxtion->PartSrvName, &NewCxtion->PartSrvName);
                UpdateNeeded = TRUE;
            }

            //
            // Cxtion options.
            //
            if (Cxtion->Options != NewCxtion->Options) {
                DPRINT4(4, ":X: %ws\\%ws - Changing Cxtion's options from 0x%08x to 0x%08x.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        Cxtion->Options, NewCxtion->Options);
                Cxtion->Options = NewCxtion->Options;
                Cxtion->Priority = FRSCONN_GET_PRIORITY(Cxtion->Options);
                UpdateNeeded = TRUE;
            }

            //
            // Schedule type
            //
            if (CxtionFlagIs(NewCxtion, CXTION_FLAGS_TRIGGER_SCHEDULE) !=
                CxtionFlagIs(Cxtion,    CXTION_FLAGS_TRIGGER_SCHEDULE)) {

                DPRINT4(4, ":X: %ws\\%ws - Changing schedule type from %s to %s.\n",
                        Replica->MemberName->Name, Cxtion->Name->Name,
                        CxtionFlagIs(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE) ?
                            "Trigger" : "Stop/Start",
                        CxtionFlagIs(NewCxtion, CXTION_FLAGS_TRIGGER_SCHEDULE) ?
                            "Trigger" : "Stop/Start");

                if (CxtionFlagIs(NewCxtion, CXTION_FLAGS_TRIGGER_SCHEDULE)) {
                    SetCxtionFlag(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE);
                } else {
                    ClearCxtionFlag(Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE);
                }
                UpdateNeeded = TRUE;
            }

            //
            // No changes, done
            //
            if (!UpdateNeeded) {
                goto DELETE_AND_CONTINUE;
            }
            //
            // Update the cxtion table in the DB
            //
            // *NOTE*  The following call is synchronous.  If we have the Cxtion
            //         table lock then a hang is possible.
            //
            FStatus = OutLogSubmit(Replica, Cxtion, CMD_OUTLOG_UPDATE_PARTNER);
            if (!FRS_SUCCESS(FStatus)) {
                DPRINT3(0, ":X: WARN changes to cxtion %ws (to %ws, %ws) not updated in database\n",
                        Cxtion->Name->Name, Cxtion->Partner->Name,
                        Replica->ReplicaName->Name);
                //
                // Ds poll thread will restart the replica during the next
                // polling cycle if ActiveChange is set to 0.
                //
                ActiveChange = 0;
            }
        }
DELETE_AND_CONTINUE:
        //
        // Remove the cxtion from the new replica set. Anything left
        // after this loop must be a new cxtion. Free the partner
        // so that FrsFreeType() will not attempt to unbind our
        // partner's handles.
        //
        NewCxtion->Partner = FrsFreeGName(NewCxtion->Partner);
        GTabDelete(NewReplica->Cxtions, Cxtion->Name->Guid, NULL, FrsFreeType);
    }

    //
    // New cxtions
    //
    for (Key = NULL;
         NewCxtion = GTabNextDatum(NewReplica->Cxtions, &Key);
         Key = NULL) {

        //
        // Remove the cxtion from the new replica
        //
        GTabDelete(NewReplica->Cxtions, NewCxtion->Name->Guid, NULL, NULL);

        //
        // Inconsistent cxtion; ignore
        //
        if (NewCxtion->JrnlCxtion ||
            !CxtionFlagIs(NewCxtion, CXTION_FLAGS_CONSISTENT)) {
            FrsFreeType(NewCxtion);
            continue;
        }
        RcsCheckCxtionSchedule(Replica, NewCxtion);

        //
        // Update the cxtion table
        //
        // *NOTE*  The following call is synchronous.  If we have the Cxtion
        //         table lock then a hang is possible.
        //
        FStatus = OutLogSubmit(Replica, NewCxtion, CMD_OUTLOG_ADD_NEW_PARTNER);
        if (FRS_SUCCESS(FStatus)) {
            DPRINT2(4, ":X: %ws\\%ws - Created cxtion.\n",
                    Replica->MemberName->Name, NewCxtion->Name->Name);
            //
            // Update the incore cxtion table
            //
            GTabInsertEntry(Replica->Cxtions, NewCxtion, NewCxtion->Name->Guid, NULL);

            DPRINT(5, ":X: PERFMON:Adding Connection:REPLICA.C:2\n");
            RcsCreatePerfmonCxtionName(Replica, NewCxtion);

            OutLogInitPartner(Replica, NewCxtion);

        } else {
            DPRINT2_FS(0, ":X: %ws\\%ws - ERROR creating cxtion;",
                    Replica->MemberName->Name, NewCxtion->Name->Name, FStatus);
            //
            // Chuck the cxtion. We will retry the create during the
            // next ds polling cycle.
            //
            FrsFreeType(NewCxtion);
            //
            // Ds poll thread will restart the replica during the next
            // polling cycle if ActiveChange is set to 0.
            //
            ActiveChange = 0;
        }
    }
}


VOID
RcsCreatePerfmonCxtionName(
    PREPLICA  Replica,
    PCXTION   Cxtion
    )
/*++
Routine Description:

    Set the OID data structure which is a part of the counter data structure
    stored in the hash table.

    Add ReplicaConn Instance to the registry


Arguments:
    Replica     - active replica
    Cxtion      - Connection being added.

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCreatePerfmonCxtionName:"

    PWCHAR ToFrom;
    ULONG  NameLen;
    PWCHAR CxNamePtr;

    if ((Cxtion->PartSrvName != NULL) && (Replica->Root != NULL)) {
        //
        // The oid name used in the HT_REPLICA_CONN_DATA is of the form
        //   Replica->Root::FROM:Cxtion->PartSrvName  or
        //   Replica->Root::TO:Cxtion->PartSrvName
        //

        WCHAR Tstr[256];
        _snwprintf(Tstr, ARRAY_SZ(Tstr), L"%ws%ws%ws",
                  Replica->Root,
                  (Cxtion->Inbound) ? (L"::FROM:") : (L"::TO:"),
                  Cxtion->PartSrvName);
         Tstr[ARRAY_SZ(Tstr)-1] = L'\0';
        //
        // Finally, add the REPLICACONN instance to the Registry
        //
        AddPerfmonInstance(REPLICACONN, Cxtion->PerfRepConnData, Tstr);
    }
}


VOID
RcsSubmitStopReplicaToDb(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Release the replica's journal state and outbound log state.
    This will also close the replica set if it was open.  The close happens
    after the Journaling on the replica has stopped so we save the correct
    Journal restart USN.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitStopReplicaToDb:"
    PCOMMAND_PACKET         Cmd = NULL;
    ULONG                   WStatus;

    Replica->FStatus = FrsErrorSuccess;

    //
    // Abort promotion; if any
    //
    if (Replica->NtFrsApi_ServiceState == NTFRSAPI_SERVICE_PROMOTING) {
        DPRINT1(4, ":S: Promotion aborted: stop for %ws.\n", Replica->SetName->Name);
        Replica->NtFrsApi_ServiceWStatus = FRS_ERR_SYSVOL_POPULATE;
        Replica->NtFrsApi_ServiceState = NTFRSAPI_SERVICE_DONE;
    }

    //
    // Attempt to stop journaling even if "IsJournaling" is false because
    // may have journal state even if it isn't journaling. The journal
    // is kept in pVme.
    //
    if (Replica->pVme == NULL) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica->pVme == NULL");
        //
        // Close replica is OK here as long as the Journal has not
        // been started on this replica set.
        //
        RcsCloseReplicaSetmember(Replica);
        RcsCloseReplicaCxtions(Replica);
        return;
    }

    //
    // Submitted to the db command server
    //
    Cmd = DbsPrepareCmdPkt(NULL,             //  Cmd,
                           Replica,          //  Replica,
                           CMD_STOP_REPLICATION_SINGLE_REPLICA, //  CmdRequest,
                           NULL,             //  TableCtx,
                           NULL,             //  CallContext,
                           0,                //  TableType,
                           0,                //  AccessRequest,
                           0,                //  IndexType,
                           NULL,             //  KeyValue,
                           0,                //  KeyValueLength,
                           FALSE);           //  Submit
    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

    //
    // SUBMIT DB Cmd and wait for completion.
    //
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Submit DB CMD_STOP_REPLICATION_SINGLE_REPLICA");
    WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
    Replica->FStatus = Cmd->Parameters.DbsRequest.FStatus;
    //
    // If wait or database op failed
    //
    if (!WIN_SUCCESS(WStatus) || !FRS_SUCCESS(Replica->FStatus)) {
        //
        // If wait / submit failed then let caller know cmd srv submit failed.
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            Replica->FStatus = FrsErrorCmdSrvFailed;
        }

        DPRINT2_FS(0, ":S: ERROR - %ws\\%ws: Stop Replica failed;",
                Replica->SetName->Name, Replica->MemberName->Name, Replica->FStatus);

        DPRINT_WS(0, "ERROR: Stop Replica DB Command failed", WStatus);
        goto out;
    }

    Replica->IsOpen = FALSE;

out:
    if (Cmd) {
        FrsFreeCommand(Cmd, NULL);
    }

}


VOID
RcsCloseReplicaCxtions(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    "Delete" the cxtions from active processing. RcsOpenReplicaSetMember() will
    generate new cxtion structs before active processing (aka joining)
    occurs. The cxtions remain in the DeletedCxtions table so that
    other threads that may have been time sliced just after acquiring
    the cxtion pointer but before making use of it will not AV. We
    could have put in locks but then there would be deadlock and
    perf considerations; all for the sake of this seldom occuring
    operation.

Arguments:
    Replica

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCloseReplicaCxtions:"
    PVOID   Key;
    PCXTION Cxtion;

    //
    // Open; ignore request
    //
    if (Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Replica open at close cxtions");
        return;
    }

    //
    // "Delete" the cxtions from active processing. RcsOpenReplicaSetMember() will
    // generate new cxtion structs before active processing (aka joining)
    // occurs. The cxtions remain in the DeletedCxtions table so that
    // other threads that may have been time sliced just after acquiring
    // the cxtion pointer but before making use of it will not AV. We
    // could have put in locks but then there would be deadlock and
    // perf considerations; all for the sake of this seldom occuring
    // operation.
    //
    if (Replica->Cxtions) {
        Key = NULL;
        while (Cxtion = GTabNextDatum(Replica->Cxtions, &Key)) {
            Key = NULL;
            CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, GenTable Cxtion deleted");
            GTabDelete(Replica->Cxtions, Cxtion->Name->Guid, NULL, NULL);

            //
            // Remove the connection from the perfmon tables so we stop returning
            // data and allow a new connection with the same name to be established.
            //
            // Journal cxtion does not have a perfmon entry
            //
            if (!Cxtion->JrnlCxtion) {
                DeletePerfmonInstance(REPLICACONN, Cxtion->PerfRepConnData);
            }
            GTabInsertEntry(DeletedCxtions, Cxtion, Cxtion->Name->Guid, NULL);
        }
    }
}


VOID
RcsCloseReplicaSetmember(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Close an open replica

Arguments:
    Replica

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCloseReplicaSetmember:"
    PCOMMAND_PACKET         Cmd = NULL;
    ULONG                   WStatus;
    PVOID                   Key;
    PCXTION                 Cxtion;

    Replica->FStatus = FrsErrorSuccess;

    //
    // Not open or still journaling; ignore request
    //
    if (!Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica not open");
        return;
    }

    //
    // Submitted to the db command server
    //
    Cmd = DbsPrepareCmdPkt(NULL,             //  Cmd,
                           Replica,          //  Replica,
                           CMD_CLOSE_REPLICA_SET_MEMBER,  //  CmdRequest,
                           NULL,             //  TableCtx,
                           NULL,             //  CallContext,
                           0,                //  TableType,
                           0,                //  AccessRequest,
                           0,                //  IndexType,
                           NULL,             //  KeyValue,
                           0,                //  KeyValueLength,
                           FALSE);           //  Submit
    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

    //
    // SUBMIT DB Cmd and wait for completion.
    //
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Submit DB CMD_CLOSE_REPLICA_SET_MEMBER");

    WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
    Replica->FStatus = Cmd->Parameters.DbsRequest.FStatus;
    //
    // If wait or database op failed
    //
    if (!WIN_SUCCESS(WStatus) || !FRS_SUCCESS(Replica->FStatus)) {
        //
        // If wait / submit failed then let caller know cmd srv submit failed.
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            Replica->FStatus = FrsErrorCmdSrvFailed;
        }

        DPRINT2_FS(0, ":S: ERROR - %ws\\%ws: Close Replica failed;",
                   Replica->SetName->Name, Replica->MemberName->Name, Replica->FStatus);

        DPRINT_WS(0, "ERROR: Close Replica DB Command failed", WStatus);
        goto out;
    }

    Replica->IsOpen = FALSE;

out:
    if (Cmd) {
        FrsFreeCommand(Cmd, NULL);
    }
}


VOID
RcsDeleteReplicaFromDb(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Delete the replica from the database

Arguments:
    Replica

Return Value:
    winerror
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsDeleteReplicaFromDb:"
    PCOMMAND_PACKET         Cmd = NULL;
    ULONG                   WStatus;

    Replica->FStatus = FrsErrorSuccess;

    //
    // Replica must be closed to delete
    //
    if (Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica not closed.");
        return;
    }

    //
    // Submitted to the db command server
    //
    Cmd = DbsPrepareCmdPkt(NULL,             //  Cmd,
                           Replica,          //  Replica,
                           CMD_DELETE_REPLICA_SET_MEMBER,  //  CmdRequest,
                           NULL,             //  TableCtx,
                           NULL,             //  CallContext,
                           0,                //  TableType,
                           0,                //  AccessRequest,
                           0,                //  IndexType,
                           NULL,             //  KeyValue,
                           0,                //  KeyValueLength,
                           FALSE);           //  Submit
    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

    //
    // SUBMIT DB Cmd and wait for completion.
    //
    REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Submit DB CMD_DELETE_REPLICA_SET_MEMBER");
    WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
    Replica->FStatus = Cmd->Parameters.DbsRequest.FStatus;
    //
    // If wait or database op failed
    //
    if (!WIN_SUCCESS(WStatus) || !FRS_SUCCESS(Replica->FStatus)) {
        //
        // If wait / submit failed then let caller know cmd srv submit failed.
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            Replica->FStatus = FrsErrorCmdSrvFailed;
        }

        DPRINT2_FS(0, ":S: ERROR - %ws\\%ws: Delete Replica failed;",
                Replica->SetName->Name, Replica->MemberName->Name, Replica->FStatus);

        DPRINT_WS(0, "ERROR: Delete Replica DB Command failed", WStatus);
        goto out;
    }

out:
    if (Cmd) {
        FrsFreeCommand(Cmd, NULL);
    }
}


VOID
RcsUpdateReplicaSetMember(
    IN PREPLICA Replica
    )
/*++
Routine Description:
    Update the database record for Replica.

    *Note*
    Perf: RcsUpdateReplicaSetMember() should return status as part
          of the function call not use some side-effect flag(NeedsUpdate)
          in the Replica struct.

Arguments:
    Replica

Return Value:
    winerror
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsUpdateReplicaSetMember:"
    PCOMMAND_PACKET         Cmd = NULL;
    ULONG                   WStatus;

    Replica->FStatus = FrsErrorSuccess;

    //
    // Replica is not dirty
    //
    if (!Replica->NeedsUpdate || !Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica not open or not dirty");
        return;
    }

    //
    // Command packet
    //
    Cmd = DbsPrepareCmdPkt(NULL,             //  Cmd,
                           Replica,          //  Replica,
                           CMD_UPDATE_REPLICA_SET_MEMBER,  //  CmdRequest,
                           NULL,             //  TableCtx,
                           NULL,             //  CallContext,
                           0,                //  TableType,
                           0,                //  AccessRequest,
                           0,                //  IndexType,
                           NULL,             //  KeyValue,
                           0,                //  KeyValueLength,
                           FALSE);           //  Submit

    //
    // Don't free the packet when the command completes.
    //
    FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);

    //
    // SUBMIT DB Cmd and wait for completion.
    //
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Submit DB CMD_UPDATE_REPLICA_SET_MEMBER");
    WStatus = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
    Replica->FStatus = Cmd->Parameters.DbsRequest.FStatus;
    //
    // If wait or database op failed
    //
    if (!WIN_SUCCESS(WStatus) || !FRS_SUCCESS(Replica->FStatus)) {
        //
        // If wait / submit failed then let caller know cmd srv submit failed.
        //
        if (FRS_SUCCESS(Replica->FStatus)) {
            Replica->FStatus = FrsErrorCmdSrvFailed;
        }

        DPRINT2_FS(0, ":S: ERROR - %ws\\%ws: Update Replica failed;",
                Replica->SetName->Name, Replica->MemberName->Name, Replica->FStatus);

        DPRINT_WS(0, "ERROR: Update Replica DB Command failed", WStatus);
        goto out;
    }

    Replica->NeedsUpdate = !FRS_SUCCESS(Replica->FStatus);

out:
    if (Cmd) {
        FrsFreeCommand(Cmd, NULL);
    }
}


BOOL
RcsHasReplicaRootPathMoved(
    IN  PREPLICA  Replica,
    IN  PREPLICA  NewReplica,
    OUT PDWORD    ReplicaState
    )
/*++
Routine Description:
    Check if the replica root path has moved. Called at each poll.

    The following checks are made to make sure that the volume and journal
    info is not changed while the service was not running.

    VOLUME SERIAL NUMBER MISMATCH CHECK:
        In case of a mismatch the replica set is marked to be deleted.

    REPLICA ROOT DIR OBJECTID MISMATCH CHECK:
        In case of a mismatch the replica set is marked to be deleted.

    REPLICA ROOT DIR FID MISMATCH CHECK:
        In case of a mismatch the replica set is marked to be deleted.


Arguments:
    Replica       - Existing replica structure.
    NewReplica    - New replica structure from DS.
    ReplicaState  - Error state to move to if root has moved.

Return Value:
    BOOL.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsHasReplicaRootPathMoved:"

    HANDLE                       NewRootHandle       = INVALID_HANDLE_VALUE;
    DWORD                        WStatus;
    DWORD                        VolumeInfoLength;
    PFILE_FS_VOLUME_INFORMATION  VolumeInfo          = NULL;
    IO_STATUS_BLOCK              Iosb;
    NTSTATUS                     Status;
    PCONFIG_TABLE_RECORD         ConfigRecord        = NULL;
    CHAR                         GuidStr[GUID_CHAR_LEN];
    BOOL                         Result              = FALSE;
    PCOMMAND_PACKET              CmdPkt              = NULL;
    ULONG                        AccessRequest;
    PDB_SERVICE_REQUEST          DbsRequest          = NULL;
    FILE_OBJECTID_BUFFER         ObjectIdBuffer;
    FILE_INTERNAL_INFORMATION    InternalFileInfo;
    PREPLICA_THREAD_CTX          RtCtx               = NULL;
    PTABLE_CTX                   IDTableCtx          = NULL;
    PVOID                        pKey                = NULL;
    PIDTABLE_RECORD              IDTableRec          = NULL;

    //
    // If this is the first time we are starting this replica set.
    // Nothing to compare with.
    //
    if (NewReplica == NULL) {
        goto RETURN;
    }

    ConfigRecord = (PCONFIG_TABLE_RECORD)Replica->ConfigTable.pDataRecord;

    //
    // Always open the path by masking off the FILE_OPEN_REPARSE_POINT flag
    // because we want to open the destination dir not the junction if the root
    // happens to be a mount point.
    //
    WStatus = FrsOpenSourceFileW(&NewRootHandle,
                                 NewReplica->Root,
                                 GENERIC_READ,
                                 FILE_OPEN_FOR_BACKUP_INTENT);
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(0, "ERROR - Unable to open root path %ws. Retry as next poll.",
                   NewReplica->Root, WStatus);
        goto RETURN;
    }

    //
    // Get the volume information.
    //
    VolumeInfoLength = sizeof(FILE_FS_VOLUME_INFORMATION) +
                       MAXIMUM_VOLUME_LABEL_LENGTH;

    VolumeInfo = FrsAlloc(VolumeInfoLength);

    Status = NtQueryVolumeInformationFile(NewRootHandle,
                                          &Iosb,
                                          VolumeInfo,
                                          VolumeInfoLength,
                                          FileFsVolumeInformation);
    if (!NT_SUCCESS(Status)) {

        DPRINT2(0,"ERROR - Getting  NtQueryVolumeInformationFile for %ws. NtStatus = %08x\n",
                NewReplica->Root, Status);

        goto RETURN;
    }

    //
    // VOLUME SERIAL NUMBER MISMATCH CHECK:
    //
    // If LastShutdown is 0 then this is the very first time we have started
    // replication on this replica set so save the volumeinformation in
    // the config record. Even if Lastshutdown is not 0 CnfUsnJournalID could
    // be 0 because it was not getting correctly updated in Win2K.. For sysvol replica sets the
    // JournalID was getting updated correctly but not the volume information.
    //
    if ((ConfigRecord->LastShutdown == (ULONGLONG)0)               ||
        (ConfigRecord->ServiceState == CNF_SERVICE_STATE_CREATING) ||
        (ConfigRecord->CnfUsnJournalID == (ULONGLONG)0)            ||
        (
         (ConfigRecord->FSVolInfo != NULL) &&
         (ConfigRecord->FSVolInfo->VolumeSerialNumber == 0)
        )) {

        CopyMemory(ConfigRecord->FSVolInfo,VolumeInfo,sizeof(FILE_FS_VOLUME_INFORMATION) + MAXIMUM_VOLUME_LABEL_LENGTH);
        Replica->NeedsUpdate = TRUE;

    } else
        //
        // Check if the VolumeSerialNumber for New Replica matches with the
        // VolumeSerialNumber from the config record for this replica set. If
        // it does not then it means that this replica set has been moved.
        // Returning error here will trigger a deletion of the replica set. The set will
        // be recreated at the next poll cycle and it will either be primary or non-auth
        // depending on the case.
        //

    if (VolumeInfo->VolumeSerialNumber != ConfigRecord->FSVolInfo->VolumeSerialNumber) {
        DPRINT1(0,"ERROR - VolumeSerialNumber mismatch for Replica Set (%ws)\n",Replica->ReplicaName->Name);
        DPRINT2(0,"ERROR - VolumeSerialNumber %x(FS) != %x(DB)\n",
                VolumeInfo->VolumeSerialNumber,ConfigRecord->FSVolInfo->VolumeSerialNumber);
        DPRINT1(0,"ERROR - Replica Set (%ws) is marked to be deleted\n",Replica->ReplicaName->Name);
        Replica->FStatus = FrsErrorMismatchedVolumeSerialNumber;
        *ReplicaState = REPLICA_STATE_MISMATCHED_VOLUME_SERIAL_NO;
        Result = TRUE;
        goto RETURN;
    }

    VolumeInfo = FrsFree(VolumeInfo);

    //
    // Get the FID for the replica root.
    //
    //
    // zero the buffer in case the data that comes back is short.
    //
    ZeroMemory(&InternalFileInfo, sizeof(FILE_INTERNAL_INFORMATION));

    Status = NtQueryInformationFile(NewRootHandle,
                                    &Iosb,
                                    &InternalFileInfo,
                                    sizeof(FILE_INTERNAL_INFORMATION),
                                    FileInternalInformation);

    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "ERROR getting FID for %ws\n", NewReplica->Root);
        goto RETURN;
    }

    //
    // zero the buffer in case the data that comes back is short.
    //
    ZeroMemory(&ObjectIdBuffer, sizeof(FILE_OBJECTID_BUFFER));

    //
    // Get the Object ID from the replica root.
    //
    Status = NtFsControlFile(
        NewRootHandle,                   // file handle
        NULL,                            // event
        NULL,                            // apc routine
        NULL,                            // apc context
        &Iosb,                           // iosb
        FSCTL_GET_OBJECT_ID,             // FsControlCode
        &NewRootHandle,                  // input buffer
        sizeof(HANDLE),                  // input buffer length
        &ObjectIdBuffer,                 // OutputBuffer for data from the FS
        sizeof(FILE_OBJECTID_BUFFER));   // OutputBuffer Length

    if (NT_SUCCESS(Status)) {
        GuidToStr((GUID *)ObjectIdBuffer.ObjectId, GuidStr);
        DPRINT1(4, ":S: Oid for replica root is %s\n", GuidStr );
    } else
    if (Status == STATUS_NOT_IMPLEMENTED) {
        DPRINT1(0, ":S: ERROR - FSCTL_GET_OBJECT_ID failed on file %ws. Object IDs are not enabled on the volume.\n",
                NewReplica->Root);

        DisplayNTStatus(Status);
    }
    FRS_CLOSE(NewRootHandle);

    //
    // REPLICA ROOT DIR OBJECTID MISMATCH CHECK:
    //
    // If LastShutdown is 0 then this is the very first time we have started replication on this replica set
    // in that case skip this check.
    //
    if (ConfigRecord->LastShutdown != (ULONGLONG)0               &&
        ConfigRecord->ServiceState != CNF_SERVICE_STATE_CREATING &&
        ConfigRecord->CnfUsnJournalID != (ULONGLONG)0) {

        //
        // The replica root might have been recreated in which case it will might
        // have a object ID. In that vase we want to recreate the replica set.
        // Check if the ReplicaRootGuid from config record matches with the ReplicaRootGuid
        // from the FileSystem. If it does not then it means that
        // this replica set has been moved. Returning error here will trigger
        // a deletion of the replica set. The set will be recreated at the next
        // poll cycle and it will either be primary or non-auth depending on the
        // case.
        //
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND                   ||
            Status == STATUS_OBJECTID_NOT_FOUND                      ||
            !GUIDS_EQUAL(&(ObjectIdBuffer.ObjectId), &(ConfigRecord->ReplicaRootGuid))) {

            DPRINT1(0,"ERROR - Replica root guid mismatch for Replica Set (%ws)\n",Replica->ReplicaName->Name);

            GuidToStr((GUID *)ObjectIdBuffer.ObjectId, GuidStr);
            DPRINT1(0,"ERROR - Replica root guid (FS) (%s)\n",GuidStr);

            GuidToStr((GUID *)&(ConfigRecord->ReplicaRootGuid), GuidStr);
            DPRINT1(0,"ERROR - Replica root guid (DB) (%s)\n",GuidStr);

            DPRINT1(0,"ERROR - Replica Set (%ws) is marked to be deleted\n",Replica->ReplicaName->Name);

            Replica->FStatus = FrsErrorMismatchedReplicaRootObjectId;
            *ReplicaState = REPLICA_STATE_MISMATCHED_REPLICA_ROOT_OBJECT_ID;
            Result = TRUE;
            goto RETURN;
        }
    }

    //
    // REPLICA ROOT DIR FID MISMATCH CHECK:
    //
    // If LastShutdown is 0 then this is the very first time we have started replication on this replica set
    // in that case skip this check.
    //
    if (ConfigRecord->LastShutdown != (ULONGLONG)0               &&
        ConfigRecord->ServiceState != CNF_SERVICE_STATE_CREATING &&
        ConfigRecord->CnfUsnJournalID != (ULONGLONG)0) {
        //
        // Open the ID table.
        //
        RtCtx = FrsAllocType(REPLICA_THREAD_TYPE);
        IDTableCtx = &RtCtx->IDTable;

        AccessRequest = DBS_ACCESS_BYKEY | DBS_ACCESS_CLOSE;
        pKey = (PVOID)&(ConfigRecord->ReplicaRootGuid);

        CmdPkt = DbsPrepareCmdPkt(CmdPkt,                //  CmdPkt,
                                  Replica,               //  Replica,
                                  CMD_READ_TABLE_RECORD, //  CmdRequest,
                                  IDTableCtx,            //  TableCtx,
                                  NULL,                  //  CallContext,
                                  IDTablex,              //  TableType,
                                  AccessRequest,         //  AccessRequest,
                                  GuidIndexx,            //  IndexType,
                                  pKey,                  //  KeyValue,
                                  sizeof(GUID),         //  KeyValueLength,
                                  FALSE);                //  Submit

        if (CmdPkt == NULL) {
            DPRINT(0, "ERROR - Failed to init the cmd pkt\n");
            RtCtx = FrsFreeType(RtCtx);
            goto RETURN;;
        }
        FrsSetCompletionRoutine(CmdPkt, FrsCompleteKeepPkt, NULL);

        Status = FrsSubmitCommandServerAndWait(&DBServiceCmdServer, CmdPkt, INFINITE);

        DbsRequest = &CmdPkt->Parameters.DbsRequest;
        IDTableCtx = DBS_GET_TABLECTX(DbsRequest);
        IDTableRec = IDTableCtx->pDataRecord;
        if (DbsRequest == NULL || DbsRequest->FStatus != FrsErrorSuccess) {

            RtCtx = FrsFreeType(RtCtx);
            FrsFreeCommand(CmdPkt, NULL);
            goto RETURN;
        }

        //
        // The replica root might have been recreated by a restore operation in which case
        // it will have the same object ID but a different FID. In that case we want
        // to recreate the replica set. Check if the FID from IDTable matches with the FID
        // from the FileSystem. If it does not then it means that this replica set has been
        // moved. Returning error here will trigger a deletion of the replica set. The set
        // will be recreated at the next poll cycle and it will either be primary or non-auth
        // depending on the case.
        // This can also happen when a junction point is present in the initial path to the replica
        // root. At a later time the junction points destination is changed and the replica rpot
        // has been moved.
        //
        if (IDTableRec->FileID != InternalFileInfo.IndexNumber.QuadPart) {

            DPRINT1(0,"ERROR - Replica root fid mismatch for Replica Set (%ws)\n",Replica->ReplicaName->Name);

            DPRINT1(0,"ERROR - Replica root fid (FS) (%08x %08x)\n",PRINTQUAD(InternalFileInfo.IndexNumber.QuadPart));

            DPRINT1(0,"ERROR - Replica root fid (DB) (%08x %08x)\n",PRINTQUAD(IDTableRec->FileID));

            DPRINT1(0,"ERROR - Replica Set (%ws) is marked to be deleted\n",Replica->ReplicaName->Name);

            RtCtx = FrsFreeType(RtCtx);
            FrsFreeCommand(CmdPkt, NULL);
            Replica->FStatus = FrsErrorMismatchedReplicaRootFileId;
            *ReplicaState = REPLICA_STATE_MISMATCHED_REPLICA_ROOT_FILE_ID;
            Result = TRUE;
            goto RETURN;
        }
        RtCtx = FrsFreeType(RtCtx);
        FrsFreeCommand(CmdPkt, NULL);
    }

RETURN:

    VolumeInfo = FrsFree(VolumeInfo);
    FRS_CLOSE(NewRootHandle);
    return Result;
}


VOID
RcsStartReplicaSetMember(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Bring the replica up to joined, active status.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsStartReplicaSetMember:"
    PREPLICA            Replica;
    PCXTION             Cxtion;
    ULONGLONG           MembershipExpires;
    PVOID               Key;
    DWORD               NumberOfCxtions;
    DWORD               ReplicaState;
    ULONG               FStatus;
    PWCHAR              CmdFile = NULL;
    ULONG               FileAttributes;
    extern ULONGLONG    ActiveChange;
    extern ULONG        DsPollingInterval;
    WCHAR               DsPollingIntervalStr[7]; // Max interval is NTFRSAPI_MAX_INTERVAL.
    FRS_ERROR_CODE      SavedFStatus;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsStartReplicaSetMember entry");
    FRS_PRINT_TYPE(4, Replica);

    //
    // Increment the Replica Sets started counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, RSStarted, 1);

    //
    // Someone is trying to start a deleted replica. This is either part
    // of startup and we are simply trying to start replication on all
    // replicas or a deleted replica has actually reappeared.
    //

    if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica Tombstoned");

        //
        // The deletion hasn't completed processing. The jrnlcxtion cannot
        // be restarted without restarting the entire replica set. The
        // set needs to be "closed" and then "opened". Let the tombstoning
        // finish before attempting to re-open. A completely closed
        // replica set has IsOpen set to FALSE and no cxtions.
        //
        if (Replica->IsOpen || GTabNumberInTable(Replica->Cxtions)) {
            REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica tombstone in progress");
            RcsSubmitTransferToRcs(Cmd, CMD_DELETE);
            return;
        }

        //
        // Don't start a deleted replica unless it has magically reappeared.
        //
        if (RsNewReplica(Cmd) == NULL) {
            FrsCompleteCommand(Cmd, ERROR_RETRY);
            return;
        }
        //
        // Don't reanimate if the tombstone has expired
        //
        if (RcsReplicaHasExpired(Replica)) {
            //
            // Remove registry entry
            //
            RcsReplicaDeleteRegistry(Replica);
            REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica Expired");
            FrsCompleteCommand(Cmd, ERROR_RETRY);
            return;
        }

        //
        // A deleted replica has reappeared; undelete the replica
        //
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica Reanimating");
        RcsOpenReplicaSetMember(Replica);
        MembershipExpires = Replica->MembershipExpires;
        Replica->MembershipExpires = 0;
        Replica->NeedsUpdate = TRUE;
        RcsUpdateReplicaSetMember(Replica);
        //
        // The above friggen call set NeedsUpdate to false if the update succeeded.
        //

        //
        // Replica cannot be marked as "undeleted" in the DB; retry later
        // and *don't* start. We wouldn't want to start replication only
        // to have the replica disappear from the database at the next
        // reboot or service startup because its timeout expired.
        //

        FStatus = DbsCheckForOverlapErrors(Replica);

        if (Replica->NeedsUpdate || !FRS_SUCCESS(FStatus)) {
            REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica Reanimation failed");
            Replica->MembershipExpires = MembershipExpires;
            FrsCompleteCommand(Cmd, ERROR_RETRY);
            //
            // Ds poll thread will restart the replica during the next
            // polling cycle if ActiveChange is set to 0.
            //
            ActiveChange = 0;
            //
            //  Note: Does there need to be a replica set close here?
            //        Need to check all use of Replica->IsOpen to figure this out.
            //
            return;
        }

        //
        // The open above returned success so Replica->IsOpen would be set
        // as expected but since the replica set was marked expired the actual
        // service state for the replica set is STOPPED and the handles to
        // The pre-install dir was never opened.  The call to reopen later
        // will fail if Replica->IsOpen is still TRUE.  So close it for now.
        //
        // *Note*
        // Perf: Get rid of the friggen Replica->IsOpen flag and use the service
        //       state as originally intended.
        //

        RcsCloseReplicaSetmember(Replica);

        //
        // No longer tombstoned; update the registry
        //
        RcsReplicaSetRegistry(Replica);

        //
        // Set registry value "FilesNotToBackup"
        //
        CfgFilesNotToBackup(ReplicasByGuid);
    }

    //
    // If this replica is in the error state then first make sure it is closed.
    // and reset its state to initializing.
    //
    if (REPLICA_IN_ERROR_STATE(Replica->ServiceState)) {
        RcsCloseReplicaSetmember(Replica);
        JrnlSetReplicaState(Replica, REPLICA_STATE_INITIALIZING);
    }

    //
    // Check if the replica root path has moved between two polls.
    //
    if (RcsHasReplicaRootPathMoved(Replica, RsNewReplica(Cmd), &ReplicaState)) {
        //
        // Save the FStatus. We need the correct FStatus to report in the
        // eventlog written in JrnlSetReplicaState(). FStatus set by
        // RcsHasReplicaRootPathMoved() is overwritten when we stop and
        // close the replica set.
        //
        //
        SavedFStatus = Replica->FStatus;

        //
        // The replica root has moved. This could be a intentional move or
        // it could be caused by change of drive letter. In any case we need a
        // confirmation from the user to go ahead and trigger a non-auth restore
        // of the replica set. We will look for a special file "NTFRS_CMD_FILE_MOVE_ROOT"
        // under the new replica root. If this file is present we will go ahead and delete
        // the replica set which will trigger a non-auth restore at the next poll.
        // The command file is deleted when the replica set is initialized.
        //

        CmdFile = FrsWcsCat3((RsNewReplica(Cmd))->Root, L"\\", NTFRS_CMD_FILE_MOVE_ROOT);

        FileAttributes = GetFileAttributes(CmdFile);

        if ((FileAttributes == 0xffffffff) ||
            (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            //
            // Get the DsPollingInteval in minutes.
            //
            _itow(DsPollingInterval / (60 * 1000), DsPollingIntervalStr, 10);

            EPRINT4(EVENT_FRS_ROOT_HAS_MOVED, Replica->SetName->Name, Replica->Root,
                    (RsNewReplica(Cmd))->Root, DsPollingIntervalStr);

            DPRINT1(0,"ERROR Command file not found at the new root %ws. Can not move root.\n",CmdFile);
            //
            // This replica state will not trigger a delete but it will still put it on
            // the fault list.
            //
            ReplicaState = REPLICA_STATE_ERROR;
        }

        CmdFile = FrsFree(CmdFile);
        RcsSubmitStopReplicaToDb(Replica);
        RcsCloseReplicaSetmember(Replica);
        RcsCloseReplicaCxtions(Replica);

        //
        // Write the saved FStatus back so we can write it to the eventlog.
        //
        Replica->FStatus = SavedFStatus;
        JrnlSetReplicaState(Replica, ReplicaState);

        FrsCompleteCommand(Cmd, ERROR_RETRY);
        ActiveChange = 0;
        return;
    }
    //
    // Retry the open
    //
    RcsOpenReplicaSetMember(Replica);
    REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->IsOpen, "B, Replica opened");

    //
    // Pre-Install Dir should now be open.
    //
    if (!HANDLE_IS_VALID(Replica->PreInstallHandle) ||
        !FRS_SUCCESS(Replica->FStatus)) {
        FrsCompleteCommand(Cmd, ERROR_RETRY);
        ActiveChange = 0;
        return;
    }

    //
    // Retry the journal
    //
    RcsInitOneReplicaSet(Replica);
    REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->IsJournaling, "B, Journal opened");

    //
    // Update the database iff fields have changed
    //
    RcsMergeReplicaFields(Replica, RsNewReplica(Cmd));

    //
    // If needed, update the replica in the database
    //
    RcsUpdateReplicaSetMember(Replica);
    //
    // The above friggen call set Replica->NeedsUpdate to false if the update succeeded.
    //

    //
    // Update the database iff cxtions have changed
    //
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Merge Replica Cxtions");
    NumberOfCxtions = GTabNumberInTable(Replica->Cxtions);
    RcsMergeReplicaCxtions(Replica, RsNewReplica(Cmd), RsNewCxtion(Cmd));
    RsNewCxtion(Cmd) = NULL;
    if (NumberOfCxtions != GTabNumberInTable(Replica->Cxtions)) {
        RcsReplicaSetRegistry(Replica);
    }

    //
    // Accept remote change orders and join outbound connections.
    //
    if (Replica->IsOpen && Replica->IsJournaling) {
        Replica->IsAccepting = TRUE;
        REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->IsAccepting, "B, Is Accepting");
    }


    //
    // Retry the join
    //
    if (Replica->IsOpen && Replica->IsJournaling) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica accepting, Starting cxtions");

        //
        // If we are in the seeding state then let the Initial Sync command server
        // control the joining.
        //
        if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING)) {

            if (Replica->InitSyncQueue == NULL) {
                //
                // Initialize the queue for the InitSync Command server.
                //

                Replica->InitSyncQueue = FrsAlloc(sizeof(FRS_QUEUE));
                FrsInitializeQueue(Replica->InitSyncQueue, &InitSyncCs.Control);
                REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, submit CMD_INITSYNC_START_SYNC");
                InitSyncSubmitToInitSyncCs(Replica, CMD_INITSYNC_START_SYNC);
            } else {
                //
                // Initial Sync command server is already working on this replica set.
                //
                REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica in initial sync state");
            }
        }

        //
        // Process all the connections in the table by putting a command
        // packet for each cxtion on this replica's command queue.
        //
        Key = NULL;
        while (Cxtion = GTabNextDatum(Replica->Cxtions, &Key)) {

            //
            // If replica is in seeding state then skip the connections that have
            // not completed their initial join. (CXTION_FLAGS_INIT_SYNC)
            // These connections will be joined by the initial sync command server.
            //
            if (BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) &&
                CxtionFlagIs(Cxtion, CXTION_FLAGS_INIT_SYNC)) {
                CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, skip cxtion join");
                continue;
            }

            CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, submit cxtion join");
            RcsSubmitReplicaCxtionJoin(Replica, Cxtion, FALSE);
        }

    } else {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica is NOT accepting");
        //
        // Ds poll thread will restart the replica during the next
        // polling cycle if ActiveChange is set to 0.
        //
        ActiveChange = 0;
    }


    //
    // Check if this replica set is journaling and is not seeding or is online.
    //
    if (Replica->IsJournaling &&
        ((!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_SEEDING) &&
        !Replica->IsSeeding) ||
        BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE))){

        //
        // If this is a sysvol replica set then set sysvol ready if not already set.
        //
        if (FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType) &&
            !Replica->IsSysvolReady) {

            Replica->IsSysvolReady = RcsSetSysvolReady(1);
            if (!Replica->IsSysvolReady) {
                //
                // Ds poll thread will restart the replica during the next
                // polling cycle if ActiveChange is set to 0.
                //
                ActiveChange = 0;
                REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica sysvol not ready");
            } else {
                RcsReplicaSetRegistry(Replica);
                REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica sysvol is ready");
            }
        }

        //
        // Also make this set online if not already set.
        //
        if (!BooleanFlagOn(Replica->CnfFlags, CONFIG_FLAG_ONLINE)) {
            SetFlag(Replica->CnfFlags, CONFIG_FLAG_ONLINE);
            REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica is Online");
            Replica->NeedsUpdate = TRUE;
        }
    }

    if (Replica->NeedsUpdate) {
        //
        // Ds poll thread will restart the replica during the next
        // polling cycle if ActiveChange is set to 0.
        //
        ActiveChange = 0;
    }
    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
}


VOID
RcsDeleteReplicaRetry(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Retry bringing the replica down to an unjoined, idle status.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsDeleteReplicaRetry:"
    FILETIME    FileTime;
    ULONGLONG   Now;
    PREPLICA    Replica;
    PVOID       CxtionKey;
    PCXTION     Cxtion;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsDeleteReplicaRetry entry");

    //
    // No longer tombstoned; done
    //
    if (IS_TIME_ZERO(Replica->MembershipExpires)) {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    }

    //
    // Start the unjoin process on all cxtions
    //
    CxtionKey = NULL;
    while ((!FrsIsShuttingDown) &&
           (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey))) {
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Force unjoin cxtion");
        RcsForceUnjoin(Replica, Cxtion);
    }

    //
    // Are all cxtions unjoined?
    //
    CxtionKey = NULL;
    Cxtion = NULL;
    while ((!FrsIsShuttingDown) &&
           (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey))) {
        if (!CxtionStateIs(Cxtion, CxtionStateUnjoined) &&
            !CxtionStateIs(Cxtion, CxtionStateDeleted)) {
            break;
        }
    }

    //
    // Not all cxtions are unjoined (or deleted). Retry this command
    // in a bit if the replica set ramains tombstoned.
    //
    if (Cxtion) {
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Retry delete later, again");
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, CMD_DELETE_RETRY_LONG_TIMEOUT);
        return;
    }

    //
    // All of the cxtions were successfully unjoined. Shut down the replica.
    //

    //
    // Stop accepting comm packets. Errors are returned to our partner.
    //
    // IsAccepting will become TRUE again in RcsStartReplicaSetMember() before
    // any cxtion rejoins.
    //
    Replica->IsAccepting = FALSE;
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica is NOT Accepting");

    //
    // Stop journal processing and close the replica.
    //
    RcsSubmitStopReplicaToDb(Replica);
    REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->IsOpen, "IsOpen, Replica closed");
    if (Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->FStatus, "F, Replica still open");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    } else {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica closed");
    }

    //
    // "Delete" the cxtions from active processing. RcsOpenReplicaSetMember() will
    // generate new cxtion structs before active processing (aka joining)
    // occurs. The cxtions remain in the DeletedCxtions table so that
    // other threads that may have been time sliced just after acquiring
    // the cxtion pointer but before making use of it will not AV. We
    // could have put in locks but then there would be deadlock and
    // perf considerations; all for the sake of this seldom occuring
    // operation.
    //
    RcsCloseReplicaCxtions(Replica);

    //
    // Increment the Replica Sets deleted counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, RSDeleted, 1);

    //
    // Has the tombstone expired?
    //
    if (RcsReplicaHasExpired(Replica)) {
        RcsSubmitTransferToRcs(Cmd, CMD_DELETE_NOW);
    } else {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }
    return;
}


VOID
RcsDeleteReplicaSetMember(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Bring the replica down to an unjoined, idle status.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsDeleteReplicaSetMember:"
    FILETIME    FileTime;
    ULONGLONG   Now;
    PREPLICA    Replica;
    PVOID       CxtionKey;
    PCXTION     Cxtion;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsDeleteReplicaSetMember entry");

    //
    // Time in 100nsec tics since Jan 1, 1601
    //
    GetSystemTimeAsFileTime(&FileTime);
    COPY_TIME(&Now, &FileTime);

    //
    // SET THE TOMBSTONE
    //
    if (IS_TIME_ZERO(Replica->MembershipExpires)) {

        //
        // Set the timeout
        //
        Replica->MembershipExpires = Now + ReplicaTombstoneInFileTime;

        //
        // Update the database record
        //
        Replica->NeedsUpdate = TRUE;
        RcsUpdateReplicaSetMember(Replica);
        //
        // The above friggen call set NeedsUpdate to false if the update succeeded.
        //

        //
        // Couldn't update; reset the timeout and retry at the next ds poll
        //
        if (Replica->NeedsUpdate) {
            Replica->MembershipExpires = 0;
            FrsCompleteCommand(Cmd, ERROR_RETRY);
            return;
        }
    }

    //
    // Set registry value "FilesNotToBackup"
    //
    CfgFilesNotToBackup(ReplicasByGuid);

    //
    // Tombstoned; update the registry
    //
    RcsReplicaSetRegistry(Replica);

    //
    // Start the unjoin process on all cxtions
    //
    CxtionKey = NULL;
    while ((!FrsIsShuttingDown) &&
           (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey))) {
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Force unjoin cxtion");
        RcsForceUnjoin(Replica, Cxtion);
    }

    //
    // Are all cxtions unjoined?
    //
    CxtionKey = NULL;
    Cxtion = NULL;
    while ((!FrsIsShuttingDown) &&
           (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey))) {
        if (!CxtionStateIs(Cxtion, CxtionStateUnjoined) &&
            !CxtionStateIs(Cxtion, CxtionStateDeleted)) {
            break;
        }
    }

    //
    // Not all cxtions are unjoined (or deleted). Try again at the
    // next ds polling cycle IFF the set is still deleted. Return
    // success since the set has been successfully marked as
    // tombstoned.
    if (Cxtion) {
        //
        // Complete the old command packet in case another thread
        // is waiting on it (like FrsDsStartDemotion()).
        //
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Retry delete later");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);

        //
        // Allocate a new command packet that will retry the delete
        // as long as the replica set remains tombstoned.
        //
        Cmd = FrsAllocCommand(Replica->Queue, CMD_DELETE_RETRY);
        FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);
        RsReplica(Cmd) = Replica;
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, CMD_DELETE_RETRY_SHORT_TIMEOUT);
        return;
    }

    //
    // All of the cxtions were successfully unjoined. Shut down the replica.
    //

    //
    // Stop accepting comm packets. Errors are returned to our partner.
    //
    // IsAccepting will become TRUE again in RcsStartReplicaSetMember() before
    // any cxtion rejoins.
    //
    Replica->IsAccepting = FALSE;
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica is NOT Accepting");

    //
    // Stop journal processing and close the replica.
    //
    RcsSubmitStopReplicaToDb(Replica);
    REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->IsOpen, "IsOpen, Replica closed");
    if (Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->FStatus, "F, Replica still open");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    } else {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica closed");
    }

    //
    // "Delete" the cxtions from active processing. RcsOpenReplicaSetMember() will
    // generate new cxtion structs before active processing (aka joining)
    // occurs. The cxtions remain in the DeletedCxtions table so that
    // other threads that may have been time sliced just after acquiring
    // the cxtion pointer but before making use of it will not AV. We
    // could have put in locks but then there would be deadlock and
    // perf considerations; all for the sake of this seldom occuring
    // operation.
    //
    RcsCloseReplicaCxtions(Replica);

    //
    // Increment the Replica Sets deleted counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, RSDeleted, 1);

    //
    // Has the tombstone expired?
    //
    if (RcsReplicaHasExpired(Replica)) {
        RcsSubmitTransferToRcs(Cmd, CMD_DELETE_NOW);
    } else {
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    }
    return;
}


VOID
RcsDeleteReplicaSetMemberNow(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Bring the replica down to an unjoined, idle status. Don't reanimate.

Arguments:
    Cmd.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsDeleteReplicaSetMemberNow:"
    FILETIME    FileTime;
    ULONGLONG   Now;
    PREPLICA    Replica;
    PVOID       CxtionKey;
    PCXTION     Cxtion;
    ULONGLONG   OldMembershipExpires;

    //
    // Check the command packet
    //
    if (!RcsCheckCmd(Cmd, DEBSUB, CHECK_CMD_REPLICA)) {
        return;
    }
    Replica = RsReplica(Cmd);
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, RcsDeleteReplicaSetMemberNow entry");

    //
    // Time in 100nsec tics since Jan 1, 1601
    //
    GetSystemTimeAsFileTime(&FileTime);
    COPY_TIME(&Now, &FileTime);

    if (IS_TIME_ZERO(Replica->MembershipExpires) || Replica->MembershipExpires >= Now) {

        //
        // Never reanimate this replica.
        //
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Marking Replica expired");
        RcsOpenReplicaSetMember(Replica);
        OldMembershipExpires = Replica->MembershipExpires;
        Replica->MembershipExpires = Now - ONEDAY;
        Replica->NeedsUpdate = TRUE;
        RcsUpdateReplicaSetMember(Replica);
        //
        // The above friggen call set NeedsUpdate to false if the update succeeded.
        //

        //
        // Replica cannot be updated in the DB. Give up.
        //
        if (Replica->NeedsUpdate) {
            Replica->MembershipExpires = OldMembershipExpires;
            FrsCompleteCommand(Cmd, ERROR_RETRY);
            return;
        }
    }
    //
    // Set registry value "FilesNotToBackup"
    //
    CfgFilesNotToBackup(ReplicasByGuid);

    //
    // Remove registry entry
    //
    RcsReplicaDeleteRegistry(Replica);

    //
    // Start the unjoin process on all cxtions
    //
    CxtionKey = NULL;
    while ((!FrsIsShuttingDown) &&
           (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey))) {
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Force unjoin cxtion");
        RcsForceUnjoin(Replica, Cxtion);
    }

    //
    // Are all cxtions unjoined?
    //
    CxtionKey = NULL;
    Cxtion = NULL;
    while ((!FrsIsShuttingDown) &&
           (Cxtion = GTabNextDatum(Replica->Cxtions, &CxtionKey))) {
        if (!CxtionStateIs(Cxtion, CxtionStateUnjoined) &&
            !CxtionStateIs(Cxtion, CxtionStateDeleted)) {
            break;
        }
    }

    //
    // Not all cxtions are unjoined (or deleted). Try again at the
    // next ds polling cycle IFF the set is still deleted. Return
    // success since the set has been successfully marked as
    // do-not-animate.
    //
    if (Cxtion) {
        //
        // Complete the old command packet in case another thread
        // is waiting on it (like FrsDsStartDemotion()).
        //
        CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Retry delete later");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);

        //
        // Allocate a new command packet that will retry the delete
        // as long as the replica set remains tombstoned.
        //
        Cmd = FrsAllocCommand(Replica->Queue, CMD_DELETE_RETRY);
        FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);
        RsReplica(Cmd) = Replica;
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, CMD_DELETE_RETRY_SHORT_TIMEOUT);
        return;
    }
    //
    // All of the cxtions were successfully unjoined. Shut down the replica.
    //

    //
    // Stop accepting comm packets. Errors are returned to our partner.
    //
    Replica->IsAccepting = FALSE;
    REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica is NOT Accepting");

    //
    // Stop journal processing and close the replica.
    //
    RcsSubmitStopReplicaToDb(Replica);
    REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->IsOpen, "IsOpen, Replica closed");
    if (Replica->IsOpen) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, Replica->FStatus, "F, Replica still open");
        FrsCompleteCommand(Cmd, ERROR_SUCCESS);
        return;
    } else {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Replica closed");
    }

    //
    // "Delete" the cxtions from active processing. RcsOpenReplicaSetMember() will
    // generate new cxtion structs before active processing (aka joining)
    // occurs. The cxtions remain in the DeletedCxtions table so that
    // other threads that may have been time sliced just after acquiring
    // the cxtion pointer but before making use of it will not AV. We
    // could have put in locks but then there would be deadlock and
    // perf considerations; all for the sake of this seldom occuring
    // operation.
    //
    RcsCloseReplicaCxtions(Replica);

    //
    // Delete the replica set tables in the db.
    //
    RcsDeleteReplicaFromDb(Replica);

    //
    // Remove the replica from any in-memory tables that it might be in.
    //
    if (RcsFindReplicaByGuid(Replica->ReplicaName->Guid) != NULL) {
        GTabDelete(ReplicasByGuid, Replica->ReplicaName->Guid, NULL, NULL);
    }

    if (RcsFindReplicaByNumber(Replica->ReplicaNumber) != NULL) {
        GTabDelete(ReplicasByNumber, &Replica->ReplicaNumber, NULL, NULL);
    }

    //
    // Increment the Replica Sets removed counter
    //
    PM_INC_CTR_SERVICE(PMTotalInst, RSRemoved, 1);

    FrsCompleteCommand(Cmd, ERROR_SUCCESS);
    return;
}


VOID
RcsStartValidReplicaSetMembers(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Tell the replicas to bring themselves up to joined, active status.
    This includes the journal and joining with inbound partners.

    This routine is run once at service startup and then once
    an hour to check the schedule.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsStartValidReplicaSetMembers:"
    PVOID       Key;
    PREPLICA    Replica;
    ULONG       TimeOut;
    SYSTEMTIME  SystemTime;

    DPRINT1(4, ":S: Command start replicas waiting %08x\n", Cmd);
    WaitForSingleObject(ReplicaEvent, INFINITE);
    DPRINT1(4, ":S: Command start replicas %08x\n", Cmd);

    //
    // Send a start command to each replica. Replicas that are already
    // started or starting will ignore the command. The replicas will
    // check their join status and rejoin if needed.
    //
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Submit Start Replica");
        RcsSubmitReplica(Replica, NULL, CMD_START);
    }

    //
    // Milliseconds till the next hour
    //
    GetSystemTime(&SystemTime);
    TimeOut = ((60 - SystemTime.wMinute) * 60000) +
              ((60 - SystemTime.wSecond) * 1000) +
              (1000 - SystemTime.wMilliseconds);
    DPRINT1(4, "Check schedules in %d seconds\n", TimeOut / 1000);
#if DBG
if (DebugInfo.Interval) {
    TimeOut = DebugInfo.Interval * 1000;
    DPRINT1(0, ":X: DEBUG - toggle schedules in %d seconds\n", TimeOut / 1000);
}
#endif  DBG
    FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, TimeOut);
}


ULONG
RcsSubmitCmdPktToRcsQueue(
    IN PCOMMAND_PACKET Cmd,
    IN PCOMM_PACKET    CommPkt,
    IN PWCHAR       AuthClient,
    IN PWCHAR       AuthName,
    IN PWCHAR       AuthSid,
    IN DWORD        AuthLevel,
    IN DWORD        AuthN,
    IN DWORD        AuthZ
    )
/*++
Routine Description:
    Convert a comm packet into a command packet and send
    it to the correct replica set. NOTE - RPC owns the comm
    packet.

Arguments:
    CommPkt
    AuthClient
    AuthName
    AuthSid
    AuthLevel
    AuthN
    AuthZ

Return Value:
    Error status to be propagated to the sender
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitCmdPktToRcsQueue:"
    DWORD           WStatus;
    PREPLICA        Replica;
    PCXTION         Cxtion = NULL;
    ULONG           WaitTime;
    ULONG           NumWaitingCOs;
    ULONGLONG       *pFileTime = NULL;


    //
    // Must have the replica's name in order to queue the command
    //
    if (RsReplicaName(Cmd) == NULL || RsReplicaName(Cmd)->Name == NULL ) {
        COMMAND_RCV_TRACE(3, Cmd, Cxtion, ERROR_INVALID_NAME, "RcvFail - no replica name");
        FrsCompleteCommand(Cmd, ERROR_INVALID_NAME);
        return ERROR_INVALID_NAME;
    }
    //
    // Find the target replica
    //
    Replica = GTabLookup(ReplicasByGuid, RsReplicaName(Cmd)->Guid, NULL);
    if (Replica == NULL) {
        COMMAND_RCV_TRACE(4, Cmd, Cxtion, ERROR_FILE_NOT_FOUND, "RcvFail - replica not found");
        FrsCompleteCommand(Cmd, ERROR_FILE_NOT_FOUND);
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // The target replica may not be accepting comm packets
    //
    if (!Replica->IsAccepting) {
        COMMAND_RCV_TRACE(4, Cmd, Cxtion, ERROR_RETRY, "RcvFail - not accepting");
        FrsCompleteCommand(Cmd, ERROR_RETRY);
        return ERROR_RETRY;
    }

    //
    // Find the cxtion
    //
    if (RsCxtion(Cmd)) {
        LOCK_CXTION_TABLE(Replica);

        Cxtion = GTabLookupNoLock(Replica->Cxtions, RsCxtion(Cmd)->Guid, NULL);
        if (Cxtion != NULL) {
            Cxtion->PartnerMajor = CommPkt->Major;
            Cxtion->PartnerMinor = CommPkt->Minor;

            //
            // The count of comm packets is used to detect a hung outbound
            // cxtion (See CMD_HUNG_CXTION).  The hang is most likely caused by
            // a dropped ack.
            //
            Cxtion->CommPkts++;

            //
            // This change order may already exist on this machine. If so,
            // use its change order entry because we will need its database
            // context for updates.
            //
            LOCK_CXTION_COE_TABLE(Replica, Cxtion);

            if (RsCoGuid(Cmd)) {
                RsCoe(Cmd) = GTabLookupNoLock(Cxtion->CoeTable, RsCoGuid(Cmd), NULL);
                //
                // Note this command should be a response to a stage file
                // fetch request.  As such the Command code should be one of
                // the following:
                // CMD_RECEIVING_STAGE, CMD_RETRY_FETCH, or CMD_ABORT_FETCH.
                //
                // Also this response should have the same data that we are expecting.
                // Consider a case of a outstanding request for staging data. Now we
                // rejoin and send the request again (Win2K SP3 and greater), now
                // we can get responses to both the requests. We do not want to start
                // two parallel chain of requests for subsequent data in the staging file.
                //
                // If it is anything else then don't pull it out of the table.
                //
                // This check is needed because if we have just restarted this
                // connection then this CO could be a resend of a CO that was
                // already restarted from the Inbound log.  Without the Command
                // check we would incorrectly attach this Coe state to the wrong
                // command packet and possibly cancel the timeout check.
                //
                if (RsCoe(Cmd) && ((Cmd->Command == CMD_RECEIVING_STAGE) ||
                                   (Cmd->Command == CMD_RETRY_FETCH)     ||
                                   (Cmd->Command == CMD_ABORT_FETCH))) {
                    GTabDeleteNoLock(Cxtion->CoeTable, RsCoGuid(Cmd), NULL, NULL);
                } else {
                    RsCoe(Cmd) = NULL;
                }
            }

            NumWaitingCOs = GTabNumberInTable(Cxtion->CoeTable);
            UNLOCK_CXTION_COE_TABLE(Replica, Cxtion);

            //
            // There is no need to keep a timeout pending if there are no
            // idle change orders. Otherwise, bump the timeout since we
            // have received something from our partner.
            //
            // Note: Need better filter for commands that aren't ACKs.
            //
            if (CxtionFlagIs(Cxtion, CXTION_FLAGS_TIMEOUT_SET)) {

                //
                // :SP1: Volatile connection cleanup.
                //
                // A volatile connection is used to seed sysvols after dcpromo.
                // If there is inactivity on a volatile outbound connection for
                // more than FRS_VOLATILE_CONNECTION_MAX_IDLE_TIME then this
                // connection is unjoined.  An unjoin on a volatile outbound
                // connection triggers a delete on that connection.  This is to
                // prevent the case where staging files are kept for ever on the
                // parent for a volatile connection.
                //
                WaitTime = (VOLATILE_OUTBOUND_CXTION(Cxtion) ?
                                FRS_VOLATILE_CONNECTION_MAX_IDLE_TIME :
                                CommTimeoutInMilliSeconds);

                if (VOLATILE_OUTBOUND_CXTION(Cxtion)) {
                    GetSystemTimeAsFileTime((PFILETIME)&SRTimeoutSetTime(Cxtion->CommTimeoutCmd));
                    SRLastJoinTime(Cxtion->CommTimeoutCmd) = Cxtion->LastJoinTime;
                    WaitSubmit(Cxtion->CommTimeoutCmd, WaitTime, CMD_DELAYED_COMPLETE);
                } else

                if (NumWaitingCOs > 0) {
                    if (RsCoe(Cmd) != NULL) {
                        //
                        // Extend the timer since we still have outstanding
                        // change orders that need a response from our partner
                        // and the current comm packet is responding to one of
                        // those change orders.
                        //
                        GetSystemTimeAsFileTime((PFILETIME)&SRTimeoutSetTime(Cxtion->CommTimeoutCmd));
                        SRLastJoinTime(Cxtion->CommTimeoutCmd) = Cxtion->LastJoinTime;

                        WaitSubmit(Cxtion->CommTimeoutCmd, WaitTime, CMD_DELAYED_COMPLETE);
                    }
                } else

                if (Cmd->Command != CMD_START_JOIN) {
                    //
                    // Not volatile outbound and no COs in CoeTable waiting for
                    // a response so disable the cxtion timer...  but
                    // CMD_START_JOIN's do not disable the join timer because
                    // they aren't sent in response to a request by this
                    // service.  Disabling the timer might hang the service as
                    // it waits for a response that never comes and a timeout
                    // that never hits.
                    //
                    ClearCxtionFlag(Cxtion, CXTION_FLAGS_TIMEOUT_SET);
                }
            }

        } else {
            COMMAND_RCV_TRACE(4, Cmd, Cxtion, ERROR_SUCCESS, "RcvFail - cxtion not found");
        }

        UNLOCK_CXTION_TABLE(Replica);

        if (Cxtion != NULL) {
            COMMAND_RCV_TRACE(4, Cmd, Cxtion, ERROR_SUCCESS, "RcvSuccess");
        }

    } else {
        COMMAND_RCV_TRACE(4, Cmd, Cxtion, ERROR_SUCCESS, "RcvFail - no cxtion");
    }

    //
    // Update the command with the replica pointer and the change order
    // command with the local the replica number.
    //
    if (RsPartnerCoc(Cmd)) {
        RsPartnerCoc(Cmd)->NewReplicaNum = ReplicaAddrToId(Replica);
        //
        // We will never see a remotely generated MOVERS.  We always
        // see a delete to the old RS followed by a create in the
        // new RS.  So set both replica ptrs to our Replica struct.
        //
        RsPartnerCoc(Cmd)->OriginalReplicaNum = ReplicaAddrToId(Replica);
    }
    RsReplica(Cmd) = Replica;

    //
    // Authentication info
    //
    RsAuthClient(Cmd) = FrsWcsDup(AuthClient);
    RsAuthName(Cmd) = FrsWcsDup(AuthName);
    RsAuthLevel(Cmd) = AuthLevel;
    RsAuthN(Cmd) = AuthN;
    RsAuthZ(Cmd) = AuthZ;

    switch(Cmd->Command) {

        case CMD_JOINING:
            //
            // This is a Joining packet so save the current time
            // in the Cmd as the receive time. This time is used to make
            // the time skew check.
            //
            pFileTime = FrsAlloc(sizeof(FILETIME));
            GetSystemTimeAsFileTime((FILETIME *)pFileTime);
            RsCommPktRcvTime(Cmd) = pFileTime;

            // Intentional fall through.

        case CMD_NEED_JOIN:
        case CMD_START_JOIN:
        case CMD_JOINED:

        case CMD_UNJOIN_REMOTE:
            //
            // Set user sid
            //
            RsAuthSid(Cmd) = FrsWcsDup(AuthSid);
            break;
        default:
            break;
    }

    //
    // Put the command on the replica's queue
    //
    Cmd->TargetQueue = Replica->Queue;
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);

    return ERROR_SUCCESS;
}


VOID
RcsInitKnownReplicaSetMembers(
    IN PCOMMAND_PACKET Cmd
    )
/*++
Routine Description:
    Wait for the database to be initialized and then take the
    replicas that were retrieved from the database and put them
    into the table that the replica control command server
    uses. Open the replicas. The journal will be started when
    a replica successfully joins with an outbound partner.

Arguments:
    Cmd

Return Value:
    winerror
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsInitKnownReplicaSetMembers:"
    FILETIME    FileTime;
    ULONGLONG   Now;
    GUID        Record0Guid;
    PREPLICA    Replica, NextReplica;
    PVOID       Key;
    ULONG       RootLen;

    //
    // Time in 100nsec tics since Jan 1, 1601
    //
    GetSystemTimeAsFileTime(&FileTime);
    COPY_TIME(&Now, &FileTime);

    //
    // A non-empty table implies multiple calls to this
    // routine our an out-of-sequence call to this routine.
    //
    FRS_ASSERT(GTabNumberInTable(ReplicasByGuid) == 0);
    FRS_ASSERT(GTabNumberInTable(ReplicasByNumber) == 0);

    //
    // Wait for the database, journal, and comm subsystem to start up
    //
    WaitForSingleObject(CommEvent, INFINITE);
    WaitForSingleObject(DataBaseEvent, INFINITE);
    WaitForSingleObject(JournalEvent, INFINITE);
    WaitForSingleObject(ChgOrdEvent, INFINITE);

    if (FrsIsShuttingDown) {
        FrsCompleteCommand(Cmd, ERROR_OPERATION_ABORTED);
        return;
    }

    //
    // Delete the contents of the Replica Set key in the registry
    // and refresh with the current info in the database.
    //
    RcsReplicaClearRegistry();

    //
    // The database built a list of replicas. Insert them into the tables
    //
    ForEachListEntry(&ReplicaListHead, REPLICA, ReplicaList,
        // loop iterator pE is of type REPLICA

        //
        // Replica was opened as part of the database initialization
        //
        pE->IsOpen = TRUE;
        REPLICA_STATE_TRACE(3, Cmd, pE, pE->IsOpen, "B, Replica opened");

        //
        // The timeout for the deleted replica has expired; attempt to
        // delete the replica from the database. The delete will be
        // retried at the next startup if this delete fails. In any case,
        // the replica does not show up in the active set of replicas
        // and so is ignored by all further processing except for shutdown.
        //
        if (RcsReplicaIsRestored(pE) ||
            (!IS_TIME_ZERO(pE->MembershipExpires) && pE->MembershipExpires < Now)) {
            GTabInsertEntry(DeletedReplicas, pE, pE->ReplicaName->Guid, NULL);
            continue;
        }
        //
        // Insert replica information into the registry
        //
        RcsReplicaSetRegistry(pE);

        //
        // Create a queue
        //
        pE->Queue = FrsAlloc(sizeof(FRS_QUEUE));
        FrsInitializeQueue(pE->Queue, &ReplicaCmdServer.Control);


        REPLICA_STATE_TRACE(3, Cmd, pE, 0, "F, Replica added to GUID table");
        //
        // Table by guid
        //
        GTabInsertEntry(ReplicasByGuid, pE, pE->ReplicaName->Guid, NULL);
        //
        // Add ReplicaSet Instance to the registry
        //
        if (pE->Root != NULL) {
            DPRINT(5, ":S: PERFMON:Adding Set:REPLICA.C:2\n");
            AddPerfmonInstance(REPLICASET, pE->PerfRepSetData, pE->Root);
        }

        //
        // Table by number
        //
        GTabInsertEntry(ReplicasByNumber, pE, &pE->ReplicaNumber, NULL);
    );

    //
    // Now account for the replica sets that are on the fault list.
    //
    ForEachListEntry(&ReplicaFaultListHead, REPLICA, ReplicaList,
        // loop iterator pE is of type REPLICA

        //
        // Replica was opened as part of the database initialization
        //
        pE->IsOpen = FALSE;
        REPLICA_STATE_TRACE(3, Cmd, pE, pE->IsOpen, "B, Replica not opened");

        //
        // The timeout for the deleted replica has expired; attempt to
        // delete the replica from the database. The delete will be
        // retried at the next startup if this delete fails. In any case,
        // the replica does not show up in the active set of replicas
        // and so is ignored by all further processing except for shutdown.
        //
        if (RcsReplicaIsRestored(pE) ||
            (!IS_TIME_ZERO(pE->MembershipExpires) && pE->MembershipExpires < Now)) {
            GTabInsertEntry(DeletedReplicas, pE, pE->ReplicaName->Guid, NULL);
            continue;
        }
        //
        // Insert replica information into the registry
        //
        RcsReplicaSetRegistry(pE);

        //
        // Create a queue
        //
        pE->Queue = FrsAlloc(sizeof(FRS_QUEUE));
        FrsInitializeQueue(pE->Queue, &ReplicaCmdServer.Control);


        REPLICA_STATE_TRACE(3, Cmd, pE, 0, "F, Replica added to GUID table");
        //
        // Table by guid
        //
        GTabInsertEntry(ReplicasByGuid, pE, pE->ReplicaName->Guid, NULL);

        //
        // Table by number
        //
        GTabInsertEntry(ReplicasByNumber, pE, &pE->ReplicaNumber, NULL);
    );



    //
    // Set the registry value "FilesNotToBackup"
    //
    CfgFilesNotToBackup(ReplicasByGuid);

    //
    // Close the expired replica sets
    //
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        if (!IS_TIME_ZERO(Replica->MembershipExpires)) {
        //
        // Close replica is OK here as long as the Journal has not been started
        // on this replica set.
        //
            RcsCloseReplicaSetmember(Replica);
            RcsCloseReplicaCxtions(Replica);
        }
    }

    //
    // Delete the replica sets with expired tombstones
    //
    Key = NULL;
    for (Replica = GTabNextDatum(DeletedReplicas, &Key);
         Replica;
         Replica = NextReplica) {

        NextReplica = GTabNextDatum(DeletedReplicas, &Key);

        //
        // Replica number 0 is reserved for the template tables in post
        // WIN2K but Databases built with Win2K can still use replica
        // number 0.
        //
        // Record 0 contains the DB templates. Don't delete it but
        // change its fields so that it won't interfere with the
        // creation of other replica set.
        // Note: New databases will not use replica number zero but old
        // databases will.  To avoid name conflicts with replica sets
        // created in the future we still need to overwrite a few
        // fields in config record zero.
        //
        if (Replica->ReplicaNumber == DBS_TEMPLATE_TABLE_NUMBER) {

            if (WSTR_NE(Replica->ReplicaName->Name, NTFRS_RECORD_0)) {
                //
                // Pull the entry out of the table since we are changing the
                // replica guid below.  (makes the saved guid ptr in the entry
                // invalid and can lead to access violation).
                //
                GTabDelete(DeletedReplicas, Replica->ReplicaName->Guid, NULL, NULL);

                FrsUuidCreate(&Record0Guid);
                //
                // ReplicaName
                //
                FrsFreeGName(Replica->ReplicaName);
                Replica->ReplicaName = FrsBuildGName(FrsDupGuid(&Record0Guid),
                                                     FrsWcsDup(NTFRS_RECORD_0));
                //
                // MemberName
                //
                FrsFreeGName(Replica->MemberName);
                Replica->MemberName = FrsBuildGName(FrsDupGuid(&Record0Guid),
                                                    FrsWcsDup(NTFRS_RECORD_0));
                //
                // SetName
                //
                FrsFreeGName(Replica->SetName);
                Replica->SetName = FrsBuildGName(FrsDupGuid(&Record0Guid),
                                                 FrsWcsDup(NTFRS_RECORD_0));
                //
                // SetType
                //
                Replica->ReplicaSetType = FRS_RSTYPE_OTHER;

                //
                // Root (to avoid failing a replica create because of
                //       overlapping roots)
                //
                FrsFree(Replica->Root);
                Replica->Root = FrsWcsDup(NTFRS_RECORD_0_ROOT);

                //
                // Stage (to avoid failing a replica create because of
                //        overlapping Stages)
                //
                FrsFree(Replica->Stage);
                Replica->Stage = FrsWcsDup(NTFRS_RECORD_0_STAGE);

                //
                // Update
                //
                Replica->NeedsUpdate = TRUE;
                RcsUpdateReplicaSetMember(Replica);
                //
                // The above friggen call set NeedsUpdate to false if the update succeeded.
                //
                if (Replica->NeedsUpdate) {
                    DPRINT(0, ":S: ERROR - Can't update record 0.\n");
                }

                //
                // Insert the entry back into the table with the new Guid index.
                //
                GTabInsertEntry(DeletedReplicas,
                                      Replica,
                                      Replica->ReplicaName->Guid,
                                      NULL);

            }
            RcsCloseReplicaSetmember(Replica);
            RcsCloseReplicaCxtions(Replica);
        } else {
            REPLICA_STATE_TRACE(3, Cmd, Replica, 0, "F, Deleting Tombstoned replica");

            //
            // Close replica is OK here as long as the Journal has not
            // been started on this replica set.
            //
            RcsCloseReplicaSetmember(Replica);
            RcsCloseReplicaCxtions(Replica);
            RcsDeleteReplicaFromDb(Replica);
        }
    }

    SetEvent(ReplicaEvent);

    //
    // Check the schedules every so often
    //
    Cmd->Command = CMD_CHECK_SCHEDULES;
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);

    //
    // Free up memory by reducing our working set size
    //
    SetProcessWorkingSetSize(ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
}


DWORD
RcsExitThread(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:

    Immediate cancel of all outstanding RPC calls for the thread
    identified by FrsThread. Set the tombstone to 5 seconds from
    now. If this thread does not exit within that time, any calls
    to ThSupWaitThread() will return a timeout error.

Arguments:
    FrsThread

Return Value:
    ERROR_SUCCESS
--*/
{
#undef DEBSUB
#define  DEBSUB  "RcsExitThread:"

    ULONG WStatus;

    if (HANDLE_IS_VALID(FrsThread->Handle)) {
        DPRINT1(4, ":S: Canceling RPC requests for thread %ws\n", FrsThread->Name);
        WStatus = RpcCancelThread(FrsThread->Handle);
        if (!RPC_SUCCESS(WStatus)) {
            DPRINT_WS(0, ":S: RpcCancelThread failed.", WStatus);
        }
    }

    return ThSupExitWithTombstone(FrsThread);
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)                   // Not all control paths return (due to infinite loop)
#endif

DWORD
RcsMain(
    PVOID  Arg
    )
/*++
Routine Description:
    Entry point for replica control command server thread

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsMain:"
    PCOMMAND_PACKET Cmd;
    PCOMMAND_SERVER Cs;
    PFRS_QUEUE      IdledQueue;
    ULONG           Status;
    PFRS_THREAD     FrsThread = (PFRS_THREAD)Arg;
    DWORD WStatus = ERROR_SUCCESS;

    //
    // Try-Finally
    //
    try {

    //
    // Capture exception.
    //
    try {

        FRS_ASSERT(FrsThread->Data == &ReplicaCmdServer);
        //
        // Immediate cancel of outstanding RPC calls during shutdown
        //
        WStatus = RpcMgmtSetCancelTimeout(0);
        DPRINT_WS(0, "Timeout cancel failed.", WStatus);

        FrsThread->Exit = RcsExitThread;

    cant_exit_yet:
        //
        // Replica Control Command Server
        //      Controls access to the database entries
        //
        while (Cmd = FrsGetCommandServerIdled(&ReplicaCmdServer, &IdledQueue)) {
            switch (Cmd->Command) {
                //
                // INITIALIZATION, STARTUP, AND CONFIGURATION
                //
                case CMD_INIT_SUBSYSTEM:
                    DPRINT(0, ":S: Replica subsystem is starting.\n");
                    DPRINT1(4, ":S: Command init subsystem %08x\n", Cmd);
                    RcsInitKnownReplicaSetMembers(Cmd);
                    if (!FrsIsShuttingDown) {
                        DPRINT(0, ":S: Replica subsystem has started.\n");
                    }
                    break;

                case CMD_CHECK_SCHEDULES:
                    RcsCheckSchedules(Cmd);
                    break;

                case CMD_START_REPLICAS:
                    RcsStartValidReplicaSetMembers(Cmd);
                    break;

                case CMD_START:
                    RcsStartReplicaSetMember(Cmd);
                    break;

                case CMD_DELETE:
                    RcsDeleteReplicaSetMember(Cmd);
                    break;

                case CMD_DELETE_RETRY:
                    RcsDeleteReplicaRetry(Cmd);
                    break;

                case CMD_DELETE_NOW:
                    RcsDeleteReplicaSetMemberNow(Cmd);
                    break;

                //
                // CHANGE ORDERS
                //

                case CMD_LOCAL_CO_ACCEPTED:
                    RcsLocalCoAccepted(Cmd);
                    break;

                case CMD_REMOTE_CO:
                    RcsRemoteCoReceived(Cmd);
                    break;

                case CMD_REMOTE_CO_ACCEPTED:
                    RcsRemoteCoAccepted(Cmd);
                    break;

                case CMD_SEND_STAGE:
                    RcsSendStageFile(Cmd);
                    break;

                case CMD_SENDING_STAGE:
                    RcsSendingStageFile(Cmd);
                    break;

                case CMD_RECEIVING_STAGE:
                    RcsReceivingStageFile(Cmd);
                    break;

                case CMD_CREATED_EXISTING:
                    RcsSendStageFileRequest(Cmd);
                    break;

                case CMD_RECEIVED_STAGE:
                    RcsReceivedStageFile(Cmd, CHECK_CXTION_AUTH);
                    break;

                case CMD_REMOTE_CO_DONE:
                    RcsRemoteCoDoneRvcd(Cmd);
                    break;

                case CMD_SEND_ABORT_FETCH:
                    RcsSendAbortFetch(Cmd);
                    break;

                case CMD_ABORT_FETCH:
                    RcsAbortFetch(Cmd);
                    break;

                case CMD_SEND_RETRY_FETCH:
                    RcsSendRetryFetch(Cmd);
                    break;

                case CMD_RETRY_STAGE:
                    RcsRetryStageFileCreate(Cmd);
                    break;

                case CMD_RETRY_FETCH:
                    RcsRetryFetch(Cmd);
                    break;

                //
                // JOINING
                //
                case CMD_NEED_JOIN:
                    RcsNeedJoin(Cmd);
                    break;

                case CMD_START_JOIN:
                    RcsStartJoin(Cmd);
                    break;

                case CMD_JOIN_CXTION:
                    RcsJoinCxtion(Cmd);
                    break;

                case CMD_JOINING_AFTER_FLUSH:
                    RcsJoiningAfterFlush(Cmd);
                    break;

                case CMD_JOINING:
                    RcsJoining(Cmd);
                    break;

                case CMD_JOINED:
                    RcsInboundJoined(Cmd);
                    break;

                case CMD_UNJOIN:
                    RcsUnJoinCxtion(Cmd, FALSE);
                    break;

                case CMD_UNJOIN_REMOTE:
                    RcsUnJoinCxtion(Cmd, TRUE);
                    break;

                case CMD_HUNG_CXTION:
                    RcsHungCxtion(Cmd);
                    break;

                //
                // VVJOIN
                //
                case CMD_VVJOIN_SUCCESS:
                    RcsVvJoinSuccess(Cmd);
                    break;

                case CMD_VVJOIN_DONE:
                    RcsVvJoinDone(Cmd);
                    break;

                case CMD_VVJOIN_DONE_UNJOIN:
                    RcsVvJoinDoneUnJoin(Cmd);
                    break;

                case CMD_CHECK_PROMOTION:
                    RcsCheckPromotion(Cmd);
                    break;

                default:
                    DPRINT1(0, "Replica Control: unknown command 0x%x\n", Cmd->Command);
                    FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
                    break;
            }
            FrsRtlUnIdledQueue(IdledQueue);
        }
        //
        // Exit
        //
        FrsExitCommandServer(&ReplicaCmdServer, FrsThread);
        goto cant_exit_yet;

    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }

    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "RcsMain finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_PROCESS_ABORTED)) {
            DPRINT(0, "RcsMain terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;

}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif



VOID
RcsInitializeReplicaCmdServer(
    VOID
    )
/*++
Routine Description:
    Initialize the replica set command server and idle it until the
    database is initialized.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsInitializeReplicaCmdServer:"
    ULONG           Status;
    PCOMMAND_PACKET Cmd;
    DWORD MaxRepThreads;

    //
    // Retry a join every MinJoinRetry milliseconds, doubling the interval
    // every retry. Stop retrying when the interval is greater than
    // MaxJoinRetry.
    //
    CfgRegReadDWord(FKC_MIN_JOIN_RETRY, NULL, 0, &MinJoinRetry);
    DPRINT1(0, ":S: Min Join Retry       : %d\n", MinJoinRetry);

    CfgRegReadDWord(FKC_MAX_JOIN_RETRY, NULL, 0, &MaxJoinRetry);
    DPRINT1(0, ":S: Max Join Retry       : %d\n", MaxJoinRetry);


    //
    // The replica command server services commands for configuration changes
    // and REPLICATION.
    //
    CfgRegReadDWord(FKC_MAX_REPLICA_THREADS, NULL, 0, &MaxRepThreads);
    DPRINT1(0, ":S: Max Replica Threads  : %d\n", MaxRepThreads);

    //
    // Start replication even if the DS could not be accessed
    //
    CfgRegReadDWord(FKC_REPLICA_START_TIMEOUT, NULL, 0, &ReplicaStartTimeout);
    DPRINT1(0, ":S: Replica Start Timeout: %d\n", ReplicaStartTimeout);

    //
    // Partners are not allowed to join if their clocks are out-of-sync
    //
    CfgRegReadDWord(FKC_PARTNER_CLOCK_SKEW, NULL, 0, &PartnerClockSkew);
    DPRINT1(0, ":S: Partner Clock Skew   : %d\n", PartnerClockSkew);

    MaxPartnerClockSkew = (ULONGLONG)PartnerClockSkew *
                          CONVERT_FILETIME_TO_MINUTES;
    //
    // Replica tombstone in days
    //
    CfgRegReadDWord(FKC_REPLICA_TOMBSTONE, NULL, 0, &ReplicaTombstone);
    DPRINT1(0, ":S: Replica Tombstone    : %d\n", ReplicaTombstone);

    ReplicaTombstoneInFileTime = (ULONGLONG)ReplicaTombstone *
                                  CONVERT_FILETIME_TO_DAYS;

    //
    // Start the Replica command server
    //
    FrsInitializeCommandServer(&ReplicaCmdServer, MaxRepThreads, L"ReplicaCs", RcsMain);

    //
    // Empty table of replicas. Existing replicas will be filled in after
    // the database has started up.
    //
    DeletedReplicas = GTabAllocTable();
    DeletedCxtions = GTabAllocTable();
    ReplicasByNumber = GTabAllocNumberTable();

    //
    // Tell the replica command server to init.
    //
    Cmd = FrsAllocCommand(&ReplicaCmdServer.Queue, CMD_INIT_SUBSYSTEM);
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);

    //
    // The DS may have changed while the service was down. In fact, the
    // service may have been down because the DS was being changed. The
    // current state of the configuration in the DS should be merged
    // with the state in the database before replication begins. But
    // the DS may not be reachable. We don't want to delay replication
    // in the off chance that the DS changed, but we do want to pick
    // up any changes before replication begins. Our compromise is to
    // allow a few minutes for the DS to come online and then start
    // replication anyway.
    //
    if (ReplicaStartTimeout) {
        Cmd = FrsAllocCommand(&ReplicaCmdServer.Queue, CMD_START_REPLICAS);
        FrsDelCsSubmitSubmit(&ReplicaCmdServer, Cmd, ReplicaStartTimeout);
    }
}


VOID
RcsFrsUnInitializeReplicaCmdServer(
    VOID
    )
/*++
Routine Description:
    Free up the RCS memory.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsFrsUnInitializeReplicaCmdServer:"
    GTabFreeTable(ReplicasByNumber, NULL);
    GTabFreeTable(ReplicasByGuid, FrsFreeType);
    GTabFreeTable(DeletedReplicas, FrsFreeType);
    GTabFreeTable(DeletedCxtions, FrsFreeType);
}


VOID
RcsShutDownReplicaCmdServer(
    VOID
    )
/*++
Routine Description:
    Abort the replica control command server

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsShutDownReplicaCmdServer:"
    PVOID       Key;
    PVOID       SubKey;
    PREPLICA    Replica;
    PCXTION     Cxtion;

    //
    // Rundown all known queues. New queue entries will bounce.
    //
    Key = NULL;
    while (Replica = GTabNextDatum(ReplicasByGuid, &Key)) {
        REPLICA_STATE_TRACE(3, NULL, Replica, 0, "F, Rundown replica cmd srv");
        FrsRunDownCommandServer(&ReplicaCmdServer, Replica->Queue);

        SubKey = NULL;
        while (Cxtion = GTabNextDatum(Replica->Cxtions, &SubKey)) {
            if (Cxtion->VvJoinCs) {
                CXTION_STATE_TRACE(3, Cxtion, Replica, 0, "F, Rundown replica VVJoin srv");
                FrsRunDownCommandServer(Cxtion->VvJoinCs, &Cxtion->VvJoinCs->Queue);
            }
        }
    }

    FrsRunDownCommandServer(&ReplicaCmdServer, &ReplicaCmdServer.Queue);
}


VOID
RcsCmdPktCompletionRoutine(
    IN PCOMMAND_PACKET Cmd,
    IN PVOID           Arg
    )
/*++
Routine Description:
    Completion routine for Replica. Free the replica set info
    and send the command on to the generic command packet
    completion routine for freeing.

Arguments:
    Cmd
    Arg - Cmd->CompletionArg

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsCmdPktCompletionRoutine:"
    PCHANGE_ORDER_ENTRY Coe;

    DPRINT1(5, "Replica completion %08x\n", Cmd);

    //
    // To preserve order among change orders all subsequent change orders
    // from this connection are going to the Inbound log (as a consequence
    // of the Unjoin below).  We will retry them later when the connection
    // is restarted.
    //
    if (RsCoe(Cmd)) {
        Coe = RsCoe(Cmd);
        RsCoe(Cmd) = NULL;
        //
        // Unjoin if possible
        //      The unjoin will fail if there isn't a cxtion or
        //      the join guid is out-of-date. Which is what we
        //      want -- we don't want a lot of unjoins flooding
        //      the replica queue and wrecking havoc with future
        //      joins.
        //
        // WARN: Must happen before the call to ChgOrdInboundRetry below.
        //
        if (RsReplica(Cmd)) {
            CHANGE_ORDER_TRACE(3, Coe, "Retry/Unjoin");
            RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
            Cmd = NULL;
        }
        //
        // Retry the change order. This must happen *AFTER* issueing
        // the unjoin above so that any change orders kicked loose by
        // the following retry will be pushed into the retry path because
        // their join guid will be invalidated during the unjoin.
        //
        SET_COE_FLAG(Coe, COE_FLAG_NO_INBOUND);

        if (CO_STATE_IS_LE(Coe, IBCO_STAGING_RETRY)) {

            CHANGE_ORDER_TRACE(3, Coe, "Submit CO to staging retry");
            ChgOrdInboundRetry(Coe, IBCO_STAGING_RETRY);
        } else
        if (CO_STATE_IS_LE(Coe, IBCO_FETCH_RETRY)) {

            CHANGE_ORDER_TRACE(3, Coe, "Submit CO to fetch retry");
            ChgOrdInboundRetry(Coe, IBCO_FETCH_RETRY);
        } else
        if (CO_STATE_IS_LE(Coe, IBCO_INSTALL_RETRY)) {

            CHANGE_ORDER_TRACE(3, Coe, "Submit CO to install retry");
            ChgOrdInboundRetry(Coe, IBCO_INSTALL_RETRY);
        } else {

            CHANGE_ORDER_TRACE(3, Coe, "Submit CO to retry");
            ChgOrdInboundRetry(Coe, CO_STATE(Coe));
        }


        //
        // Command was transfered to the replica command server for unjoin
        //
        if (!Cmd) {
            return;
        }
    }
    //
    // The originator owns the disposition of this command packet
    //
    if (HANDLE_IS_VALID(RsCompletionEvent(Cmd))) {
        SetEvent(RsCompletionEvent(Cmd));
        return;
    }

    //
    // Free up the "address" portion of the command
    //
    FrsFreeGName(RsTo(Cmd));
    FrsFreeGName(RsFrom(Cmd));
    FrsFreeGName(RsReplicaName(Cmd));
    FrsFreeGName(RsCxtion(Cmd));

    FrsFree(RsBlock(Cmd));
    FrsFree(RsGVsn(Cmd));
    FrsFree(RsCoGuid(Cmd));
    FrsFree(RsJoinGuid(Cmd));
    FrsFree(RsJoinTime(Cmd));
    FrsFree(RsCommPktRcvTime(Cmd));
    FrsFree(RsReplicaVersionGuid(Cmd));
    //
    // Free the copy of our partner's change order command and the data extension.
    //
    if (RsPartnerCoc(Cmd) != NULL) {
        FrsFree(RsPartnerCocExt(Cmd));
        FrsFree(RsPartnerCoc(Cmd));
    }

    //
    // a replica (never free the RsReplica(Cmd) field; it addresses
    // an active replica in the Replicas table).
    //
    FrsFreeType(RsNewReplica(Cmd));

    //
    // Seeding cxtion
    // Delete the connection from the perfmon tables.
    //
    if (RsNewCxtion(Cmd) != NULL) {
        FrsFreeType(RsNewCxtion(Cmd));
    }

    //
    // Free the compression table, if any.
    //
    if (RsCompressionTable(Cmd)) {
        GTabFreeTable(RsCompressionTable(Cmd), FrsFree);
    }
    //
    // Free the version vector, if any
    //
    RsVVector(Cmd) = VVFreeOutbound(RsVVector(Cmd));
    RsReplicaVv(Cmd) = VVFreeOutbound(RsReplicaVv(Cmd));

    //
    // Authentication info
    //
    FrsFree(RsAuthClient(Cmd));
    FrsFree(RsAuthName(Cmd));
    FrsFree(RsAuthSid(Cmd));

    //
    // Md5 Digest
    //
    FrsFree(RsMd5Digest(Cmd));

    //
    // Send the packet on to the generic completion routine for freeing
    //
    FrsSetCompletionRoutine(Cmd, FrsFreeCommand, NULL);
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
}


VOID
RcsSubmitTransferToRcs(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command
    )
/*++
Routine Description:
    Transfer a request to the replica command server

Arguments:
    Cmd
    Command

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitTransferToRcs:"

    Cmd->TargetQueue = RsReplica(Cmd)->Queue;
    Cmd->Command = Command;
    RsTimeout(Cmd) = 0;

    DPRINT3(5, "Transfer %08x (%08x) to %ws\n",
            Command, Cmd, RsReplica(Cmd)->SetName->Name);

    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
}



VOID
RcsSubmitRemoteCoInstallRetry(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    Submit a remote change order to retry the file install.

Arguments:
    Coe - Change order entry.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitRemoteCoInstallRetry:"
    PCOMMAND_PACKET     Cmd;
    PREPLICA            Replica;

    Replica = Coe->NewReplica;
    Cmd = FrsAllocCommand(Replica->Queue, 0);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of change order entry
    //
    RsCoe(Cmd) = Coe;

    //
    // Mask out the irrelevant usn reasons
    //
    RsCoc(Cmd)->ContentCmd &= CO_CONTENT_MASK;

    //
    // Guid of the change order entry
    //
    RsCoGuid(Cmd) = FrsDupGuid(&RsCoc(Cmd)->ChangeOrderGuid);

    //
    // Initialize the command packet for eventual transfer to
    // the replica set command server
    //
    RsReplica(Cmd) = Replica;

    //
    // Cxtion's guid (note - we lose the printable name for now)
    //
    RsCxtion(Cmd) = FrsBuildGName(FrsDupGuid(&Coe->Cmd.CxtionGuid), NULL);

    DPRINT3(5, "Submit %08x (%08x) to %ws\n",
            CMD_REMOTE_CO_ACCEPTED, Cmd, Replica->SetName->Name);
    FrsInstallCsSubmitTransfer(Cmd, CMD_INSTALL_STAGE);
}


VOID
RcsSubmitRemoteCoAccepted(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    Submit a remote change order to the staging file generator.

Arguments:
    Co

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitRemoteCoAccepted:"
    PCOMMAND_PACKET     Cmd;
    PREPLICA            Replica;

    Replica = Coe->NewReplica;
    Cmd = FrsAllocCommand(Replica->Queue, CMD_REMOTE_CO_ACCEPTED);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of change order entry
    //
    RsCoe(Cmd) = Coe;

    //
    // Mask out the irrelevant usn reasons
    //
    RsCoc(Cmd)->ContentCmd &= CO_CONTENT_MASK;

    //
    // Guid of the change order entry
    //
    RsCoGuid(Cmd) = FrsDupGuid(&RsCoc(Cmd)->ChangeOrderGuid);

    //
    // Initialize the command packet for eventual transfer to
    // the replica set command server
    //
    RsReplica(Cmd) = Replica;

    //
    // Cxtion's guid (note - we lose the printable name for now)
    //
    RsCxtion(Cmd) = FrsBuildGName(FrsDupGuid(&Coe->Cmd.CxtionGuid), NULL);

    //
    // Join guid
    //
    RsJoinGuid(Cmd) = FrsDupGuid(&Coe->JoinGuid);

    DPRINT1(5, "Submit %08x\n", Cmd);
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
}


VOID
RcsSubmitLocalCoAccepted(
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    Submit a local change order to the staging file generator.

Arguments:
    Coe

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitLocalCoAccepted:"
    PCOMMAND_PACKET     Cmd;
    PREPLICA            Replica;

    //
    // NewReplica?
    //
    Replica = Coe->NewReplica;
    Cmd = FrsAllocCommand(Replica->Queue, CMD_LOCAL_CO_ACCEPTED);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Address of the change order entry
    //
    RsCoe(Cmd) = Coe;

    //
    // Mask out the irrelevant usn reasons
    //
    RsCoc(Cmd)->ContentCmd &= CO_CONTENT_MASK;

    //
    // Guid of the change order entry
    //
    RsCoGuid(Cmd) = FrsDupGuid(&RsCoc(Cmd)->ChangeOrderGuid);

    //
    // Initialize the command packet for eventual transfer to
    // the replica set command server
    //
    RsReplica(Cmd) = Replica;

    //
    // Cxtion's guid (note - we lose the printable name for now)
    //
    RsCxtion(Cmd) = FrsBuildGName(FrsDupGuid(&Coe->Cmd.CxtionGuid), NULL);

    DPRINT1(5, "Submit %08x\n", Cmd);
    FrsSubmitCommandServer(&ReplicaCmdServer, Cmd);
}


ULONG
RcsSubmitCommPktWithErrorToRcs(
    IN PCOMM_PACKET     CommPkt
    )
/*++
Routine Description:
    A comm packet could not be sent because of an error. If the
    comm packet was for a joined cxtion then the affected
    replica\cxtion is unjoined.

Arguments:
    CommPkt - Comm packet that couldn't be sent

Return Value:
    Error status to be propagated to the sender
--*/
{
#undef DEBSUB
#define DEBSUB  "RcsSubmitCommPktWithErrorToRcs:"
    PCOMMAND_PACKET Cmd;
    PREPLICA        Replica;
    PGNAME          TmpGName;

    //
    // Convert the comm packet into a command packet
    //
    Cmd = CommPktToCmd(CommPkt);

    FRS_ASSERT(Cmd != NULL);
    FRS_ASSERT(RsTo(Cmd));
    FRS_ASSERT(RsFrom(Cmd));
    FRS_ASSERT(RsReplicaName(Cmd));

    //
    // Rebuild the replica name to address the originating, or local, replica
    //
    TmpGName = RsReplicaName(Cmd);
    RsReplicaName(Cmd) = FrsBuildGName(FrsDupGuid(RsFrom(Cmd)->Guid),
                                       FrsWcsDup(RsReplicaName(Cmd)->Name));
    FrsFreeGName(TmpGName);

    //
    // Adjust the "to" and "from" addresses
    //
    TmpGName = RsTo(Cmd);
    RsTo(Cmd) = RsFrom(Cmd);
    RsFrom(Cmd) = TmpGName;

    //
    // Find the target replica
    //
    Replica = GTabLookup(ReplicasByGuid, RsReplicaName(Cmd)->Guid, NULL);
    if (Replica == NULL) {
        DPRINT1(4, ":S: WARN - Submit comm pkt w/error: Replica not found: %ws\n",
                RsReplicaName(Cmd)->Name);
        FrsCompleteCommand(Cmd, ERROR_FILE_NOT_FOUND);
        return ERROR_FILE_NOT_FOUND;
    }
    RsReplica(Cmd) = Replica;

    //
    // The target replica may not be accepting comm packets. The
    // target replica will reset itself before accepting
    // commpkts again.
    //
    if (!Replica->IsAccepting) {
        DPRINT1(4, ":S: WARN -  Submit comm pkt w/error: Replica is not accepting: %ws\n",
                Replica->ReplicaName->Name);
        FrsCompleteCommand(Cmd, ERROR_RETRY);
        return ERROR_RETRY;
    }
    switch (Cmd->Command) {
        //
        // NEVER SENT VIA A COMM PKT
        //
        case CMD_INIT_SUBSYSTEM:
        case CMD_CHECK_SCHEDULES:
        case CMD_START_REPLICAS:
// case CMD_STOP:
        case CMD_START:
        case CMD_DELETE:
        case CMD_DELETE_NOW:
        case CMD_LOCAL_CO_ACCEPTED:
        case CMD_REMOTE_CO_ACCEPTED:
        case CMD_SENDING_STAGE:
        case CMD_RECEIVED_STAGE:
        case CMD_CREATED_EXISTING:
        case CMD_SEND_ABORT_FETCH:
        case CMD_SEND_RETRY_FETCH:
        case CMD_JOIN_CXTION:
        case CMD_UNJOIN:
        case CMD_VVJOIN_START:
        case CMD_VVJOIN_SUCCESS:
        case CMD_HUNG_CXTION:
        case CMD_JOINING_AFTER_FLUSH:
            FRS_ASSERT(!"RcsSubmitCommPktWithErrorToRcs: invalid cmd for comm pkt");
            break;

        //
        // There is other retry code in replica.c that will take care of these
        //
        case CMD_UNJOIN_REMOTE:
        case CMD_JOINED:
        case CMD_NEED_JOIN:
        case CMD_START_JOIN:
            DPRINT3(5, ":X: Ignore commpkt with error Command:%08x Cmd:%08x CommPkt:%08x\n",
                    Cmd->Command, Cmd, CommPkt);
            FrsCompleteCommand(Cmd, ERROR_SUCCESS);
            break;

        //
        // SENT VIA COMM PKT; UNJOIN
        //
        case CMD_JOINING:
        case CMD_REMOTE_CO:
        case CMD_SEND_STAGE:
        case CMD_RECEIVING_STAGE:
        case CMD_REMOTE_CO_DONE:
        case CMD_ABORT_FETCH:
        case CMD_RETRY_FETCH:
        case CMD_VVJOIN_DONE:
            //
            // Put the unjoin command on the replica's queue
            //
            DPRINT3(5, ":X: Submit commpkt with error Command:%08x Cmd:%08x CommPkt:%08x\n",
                    Cmd->Command, Cmd, CommPkt);
            RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
            break;

        default:
            break;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frs\vvjoin.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    vvjoin.c

Abstract:

    Our outbound partner requested a join but the outbound log does not
    contain the change orders needed to bring our outbound partner up-to-
    date. Instead, this thread will scan our idtable and generate
    refresh change orders for our outbound partner. This process is
    termed a vvjoin because the outbound partner's version vector is
    used as a filter when deciding which files and directories in our
    idtable will be sent.

    Once the vvjoin is completed, our outbound partner will regenerate
    his version vector and attempt the join again with the outbound log
    sequence number saved at the beginning of the vvjoin. If that sequence
    number is no longer available in the oubound log, the vvjoin is
    repeated with, hopefully, fewer files being sent to our outbound
    partner.

Author:

    Billy J Fuller 27-Jan-1998

Environment

    User mode, winnt32

--*/
#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define DEBSUB  "vvjoin:"

#include <frs.h>
#include <tablefcn.h>
#include <perrepsr.h>

#if   DBG
DWORD   VvJoinTrigger   = 0;
DWORD   VvJoinReset     = 0;
DWORD   VvJoinInc       = 0;
#define VV_JOIN_TRIGGER(_VvJoinContext_) \
{ \
    if (VvJoinTrigger && !--VvJoinTrigger) { \
        VvJoinReset += VvJoinInc; \
        VvJoinTrigger = VvJoinReset; \
        DPRINT1(0, ":V: DEBUG -- VvJoin Trigger HIT; reset to %d\n", VvJoinTrigger); \
        *((DWORD *)&_VvJoinContext_->JoinGuid) += 1; \
    } \
}
#else  DBG
#define VV_JOIN_TRIGGER(_VvJoinContext_)
#endif DBG


#if DBG
#define VVJOIN_TEST()                       VvJoinTest()
#define VVJOIN_PRINT(_S_, _VC_)             VvJoinPrint(_S_, _VC_)
#define VVJOIN_PRINT_NODE(_S_, _I_, _N_)    VvJoinPrintNode(_S_, _I_, _N_)
#define VVJOIN_TEST_SKIP_BEGIN(_X_, _C_)    VvJoinTestSkipBegin(_X_, _C_)
#define VVJOIN_TEST_SKIP_CHECK(_X, _F, _B_) VvJoinTestSkipCheck(_X, _F, _B_)
#define VVJOIN_TEST_SKIP_END(_X_)           VvJoinTestSkipEnd(_X_)
#define VVJOIN_TEST_SKIP(_C_)               VvJoinTestSkip(_C_)
#else DBG
#define VVJOIN_TEST()
#define VVJOIN_PRINT(_S_, _VC_)
#define VVJOIN_PRINT_NODE(_S_, _I_, _N_)
#define VVJOIN_TEST_SKIP_BEGIN(_X_, _C_)
#define VVJOIN_TEST_SKIP_CHECK(_X_, _F_, _B_)
#define VVJOIN_TEST_SKIP_END(_X_)
#endif

//
// Context global to a vvjoin thread
//
typedef struct _VVJOIN_CONTEXT {
    PRTL_GENERIC_TABLE  Guids;         // all nodes by guid
    PRTL_GENERIC_TABLE  Originators;   // originator nodes by originator
    DWORD               (*Send)();
                                // IN PVVJOIN_CONTEXT VvJoinContext,
                                // IN PVVJOIN_NODE    VvJoinNode);
    DWORD               NumberSent;
    PREPLICA            Replica;
    PCXTION             Cxtion;
    PGEN_TABLE          CxtionVv;
    PGEN_TABLE          ReplicaVv;
    PTHREAD_CTX         ThreadCtx;
    PTABLE_CTX          TableCtx;
    GUID                JoinGuid;
    LONG                MaxOutstandingCos;
    LONG                OutstandingCos;
    LONG                OlTimeout;
    LONG                OlTimeoutMax;
    PWCHAR              SkipDir;
    PWCHAR              SkipFile1;
    PWCHAR              SkipFile2;
    BOOL                SkippedDir;
    BOOL                SkippedFile1;
    BOOL                SkippedFile2;
} VVJOIN_CONTEXT, *PVVJOIN_CONTEXT;

//
// One node per file from the idtable
//
typedef struct _VVJOIN_NODE {
    ULONG               Flags;
    GUID                FileGuid;
    GUID                ParentGuid;
    GUID                Originator;
    ULONGLONG           Vsn;
    PRTL_GENERIC_TABLE  Vsns;
} VVJOIN_NODE, *PVVJOIN_NODE;

//
// Maximum timeout (unless overridden by registry)
//
#define VVJOIN_TIMEOUT_MAX  (180 * 1000)

//
// Flags for VVJOIN_NODE
//
#define VVJOIN_FLAGS_ISDIR          0x00000001
#define VVJOIN_FLAGS_SENT           0x00000002
#define VVJOIN_FLAGS_ROOT           0x00000004
#define VVJOIN_FLAGS_PROCESSING     0x00000008
#define VVJOIN_FLAGS_OUT_OF_ORDER   0x00000010
#define VVJOIN_FLAGS_DELETED        0x00000020

//
// Maximum number of vvjoin threads PER CXTION
//
#define VVJOIN_MAXTHREADS_PER_CXTION    (1)

//
// Next entry in any gen table (don't splay)
//
#define VVJOIN_NEXT_ENTRY(_T_, _K_) \
    (PVOID)RtlEnumerateGenericTableWithoutSplaying(_T_, _K_)



PCHANGE_ORDER_ENTRY
ChgOrdMakeFromIDRecord(
    IN PIDTABLE_RECORD IDTableRec,
    IN PREPLICA        Replica,
    IN ULONG           LocationCmd,
    IN ULONG           CoFlags,
    IN GUID           *CxtionGuid
);



PVOID
VvJoinAlloc(
    IN PRTL_GENERIC_TABLE   Table,
    IN DWORD                NodeSize
    )
/*++
Routine Description:
    Allocate space for a table entry. The entry includes the user-defined
    struct and some overhead used by the generic table routines. The
    generic table routines call this function when they need memory.

Arguments:
    Table       - Address of the table (not used).
    NodeSize    - Bytes to allocate

Return Value:
    Address of newly allocated memory.
--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinAlloc:"

    //
    // Need to check if NodeSize == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
    //
    if (NodeSize == 0) {
        return NULL;
    }

    return FrsAlloc(NodeSize);
}





VOID
VvJoinFree(
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                Buffer
    )
/*++
Routine Description:
    Free the space allocated by VvJoinAlloc(). The generic table
    routines call this function to free memory.

Arguments:
    Table   - Address of the table (not used).
    Buffer  - Address of previously allocated memory

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinFree:"
    FrsFree(Buffer);
}


PVOID
VvJoinFreeContext(
    IN PVVJOIN_CONTEXT  VvJoinContext
    )
/*++
Routine Description:
    Free the context and its contents

Arguments:
    VvJoinContext

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinFreeContext:"
    JET_ERR         jerr;
    PVVJOIN_NODE    VvJoinNode;
    PVVJOIN_NODE    *Entry;
    PVVJOIN_NODE    *SubEntry;

    //
    // Done
    //
    if (!VvJoinContext) {
        return NULL;
    }

    //
    // Free the entries in the generic table of originators. The nodes
    // addressed by the entries are freed below.
    //
    if (VvJoinContext->Originators) {
        while (Entry = RtlEnumerateGenericTable(VvJoinContext->Originators, TRUE)) {
            VvJoinNode = *Entry;
            if (VvJoinNode->Vsns) {
                while (SubEntry = RtlEnumerateGenericTable(VvJoinNode->Vsns, TRUE)) {
                    RtlDeleteElementGenericTable(VvJoinNode->Vsns, SubEntry);
                }
                VvJoinNode->Vsns = FrsFree(VvJoinNode->Vsns);
            }
            RtlDeleteElementGenericTable(VvJoinContext->Originators, Entry);
        }
        VvJoinContext->Originators = FrsFree(VvJoinContext->Originators);
    }
    //
    // Free the entries in the generic table of files. The nodes are freed,
    // too, because no other table addresses them.
    //
    if (VvJoinContext->Guids) {
        while (Entry = RtlEnumerateGenericTable(VvJoinContext->Guids, TRUE)) {
            VvJoinNode = *Entry;
            RtlDeleteElementGenericTable(VvJoinContext->Guids, Entry);
            FrsFree(VvJoinNode);
        }
        VvJoinContext->Guids = FrsFree(VvJoinContext->Guids);
    }
    //
    // Free the version vector and the cxtion guid.
    //
    VVFreeOutbound(VvJoinContext->CxtionVv);
    VVFreeOutbound(VvJoinContext->ReplicaVv);

    //
    // Jet table context
    //
    if (VvJoinContext->TableCtx) {
        DbsFreeTableContext(VvJoinContext->TableCtx,
                            VvJoinContext->ThreadCtx->JSesid);
    }
    //
    // Now close the jet session and free the Jet ThreadCtx.
    //
    if (VvJoinContext->ThreadCtx) {
        jerr = DbsCloseJetSession(VvJoinContext->ThreadCtx);
        if (!JET_SUCCESS(jerr)) {
            DPRINT_JS(1,":V: DbsCloseJetSession : ", jerr);
        } else {
            DPRINT(4, ":V: DbsCloseJetSession complete\n");
        }
        VvJoinContext->ThreadCtx = FrsFreeType(VvJoinContext->ThreadCtx);
    }

    //
    // Free the context
    //
    FrsFree(VvJoinContext);

    //
    // DONE
    //
    return NULL;
}


RTL_GENERIC_COMPARE_RESULTS
VvJoinCmpGuids(
    IN PRTL_GENERIC_TABLE   Guids,
    IN PVVJOIN_NODE         *VvJoinNode1,
    IN PVVJOIN_NODE         *VvJoinNode2
    )
/*++
Routine Description:
    Compare the Guids of the two entries.

    This function is used by the gentable runtime to compare entries.
    In this case, each entry in the table addresses a node.

Arguments:
    Guids        - Sorted by Guid
    VvJoinNode1  - PVVJOIN_NODE
    VvJoinNode2  - PVVJOIN_NODE

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinCmpGuids:"
    INT             Cmp;

    FRS_ASSERT(VvJoinNode1 && VvJoinNode2 && *VvJoinNode1 && *VvJoinNode2);

    Cmp = memcmp(&(*VvJoinNode1)->FileGuid,
                 &(*VvJoinNode2)->FileGuid,
                 sizeof(GUID));
    if (Cmp < 0) {
        return GenericLessThan;
    } else if (Cmp > 0) {
        return GenericGreaterThan;
    }
    return GenericEqual;
}


RTL_GENERIC_COMPARE_RESULTS
VvJoinCmpVsns(
    IN PRTL_GENERIC_TABLE   Vsns,
    IN PVVJOIN_NODE         *VvJoinNode1,
    IN PVVJOIN_NODE         *VvJoinNode2
    )
/*++
Routine Description:
    Compare the vsns of the two entries as unsigned values.

    This function is used by the gentable runtime to compare entries.
    In this case, each entry in the table addresses a node.

Arguments:
    Vsns         - Sorted by Vsn
    VvJoinNode1  - PVVJOIN_NODE
    VvJoinNode2  - PVVJOIN_NODE

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinCmpVsns:"
    INT             Cmp;

    FRS_ASSERT(VvJoinNode1  && VvJoinNode2 && *VvJoinNode1 && *VvJoinNode2);

    if ((ULONGLONG)(*VvJoinNode1)->Vsn > (ULONGLONG)(*VvJoinNode2)->Vsn) {
        return GenericGreaterThan;
    } else if ((ULONGLONG)(*VvJoinNode1)->Vsn < (ULONGLONG)(*VvJoinNode2)->Vsn) {
        return GenericLessThan;
    }
    return GenericEqual;
}


RTL_GENERIC_COMPARE_RESULTS
VvJoinCmpOriginators(
    IN PRTL_GENERIC_TABLE   Originators,
    IN PVVJOIN_NODE         *VvJoinNode1,
    IN PVVJOIN_NODE         *VvJoinNode2
    )
/*++
Routine Description:
    Compare the originators ID of the two entries.

    This function is used by the gentable runtime to compare entries.
    In this case, each entry in the table addresses a node.

Arguments:
    Originators  - Sorted by Guid
    VvJoinNode1  - PVVJOIN_NODE
    VvJoinNode2  - PVVJOIN_NODE

Return Value:
    <0      First < Second
    =0      First == Second
    >0      First > Second
--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinCmpOriginators:"
    INT             Cmp;

    FRS_ASSERT(VvJoinNode1  && VvJoinNode2 && *VvJoinNode1 && *VvJoinNode2);

    Cmp = memcmp(&(*VvJoinNode1)->Originator, &(*VvJoinNode2)->Originator, sizeof(GUID));

    if (Cmp < 0) {
        return GenericLessThan;
    } else if (Cmp > 0) {
        return GenericGreaterThan;
    }
    return GenericEqual;
}


DWORD
VvJoinInsertEntry(
    IN PVVJOIN_CONTEXT  VvJoinContext,
    IN DWORD            Flags,
    IN GUID             *FileGuid,
    IN GUID             *ParentGuid,
    IN GUID             *Originator,
    IN PULONGLONG       Vsn
)
/*++

Routine Description:

    Insert the entry into the table of files (Guids) and the
    table of originators (Originators). This function is called
    during the IDTable scan.

Arguments:

    VvJoinContext
    Flags
    FileGuid
    ParentGuid
    Originator
    Vsn

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinInsertEntry:"
    PVVJOIN_NODE    VvJoinNode;
    PVVJOIN_NODE    VvJoinOriginators;
    PVVJOIN_NODE    *Entry;
    BOOLEAN         IsNew;

    //
    // First call, allocate the table of files
    //
    if (!VvJoinContext->Guids) {
        VvJoinContext->Guids = FrsAlloc(sizeof(RTL_GENERIC_TABLE));
        RtlInitializeGenericTable(VvJoinContext->Guids,
                                  VvJoinCmpGuids,
                                  VvJoinAlloc,
                                  VvJoinFree,
                                  NULL);
    }
    //
    // First call, allocate the table of originators
    //
    if (!VvJoinContext->Originators) {
        VvJoinContext->Originators = FrsAlloc(sizeof(RTL_GENERIC_TABLE));
        RtlInitializeGenericTable(VvJoinContext->Originators,
                                  VvJoinCmpOriginators,
                                  VvJoinAlloc,
                                  VvJoinFree,
                                  NULL);
    }
    //
    // One node per file
    //
    VvJoinNode = FrsAlloc(sizeof(VVJOIN_NODE));
    VvJoinNode->FileGuid = *FileGuid;
    VvJoinNode->ParentGuid = *ParentGuid;
    VvJoinNode->Originator = *Originator;
    VvJoinNode->Vsn = *Vsn;
    VvJoinNode->Flags = Flags;


    //
    // Insert into the table of files
    //
    RtlInsertElementGenericTable(VvJoinContext->Guids,
                                 &VvJoinNode,
                                 sizeof(PVVJOIN_NODE),
                                 &IsNew);
    //
    // Duplicate Guids! The IDTable must be corrupt. Give up.
    //
    if (!IsNew) {
        return ERROR_DUP_NAME;
    }

    //
    // Must be the root of the replicated tree. The root directory
    // isn't replicated but is included in the table to make the
    // code for "directory scans" cleaner.
    //
    if (Flags & VVJOIN_FLAGS_SENT) {
        return ERROR_SUCCESS;
    }

    //
    // The table of originators is used to order the files when
    // sending them to our outbound partner.
    //
    // The table is really a table of tables. The first table
    // is indexed by originator, and the second by vsn.
    //
    Entry = RtlInsertElementGenericTable(VvJoinContext->Originators,
                                         &VvJoinNode,
                                         sizeof(PVVJOIN_NODE),
                                         &IsNew);
    VvJoinOriginators = *Entry;
    FRS_ASSERT((IsNew && !VvJoinOriginators->Vsns) ||
               (!IsNew && VvJoinOriginators->Vsns));

    if (!VvJoinOriginators->Vsns) {
        VvJoinOriginators->Vsns = FrsAlloc(sizeof(RTL_GENERIC_TABLE));
        RtlInitializeGenericTable(VvJoinOriginators->Vsns,
                                  VvJoinCmpVsns,
                                  VvJoinAlloc,
                                  VvJoinFree,
                                  NULL);
    }

    RtlInsertElementGenericTable(VvJoinOriginators->Vsns,
                                 &VvJoinNode,
                                 sizeof(PVVJOIN_NODE),
                                 &IsNew);
    //
    // Every vsn should be unique. IDTable must be corrupt. give up
    //
    if (!IsNew) {
        return ERROR_DUP_NAME;
    }

    return ERROR_SUCCESS;
}


#if DBG
VOID
VvJoinPrintNode(
    ULONG           Sev,
    PWCHAR          Indent,
    PVVJOIN_NODE    VvJoinNode
    )
/*++

Routine Description:

    Print a node

Arguments:

    Indent
    VvJoinNode

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinPrintNode:"
    CHAR            Originator[GUID_CHAR_LEN];
    CHAR            FileGuidA[GUID_CHAR_LEN];
    CHAR            ParentGuidA[GUID_CHAR_LEN];

    GuidToStr(&VvJoinNode->Originator, Originator);
    GuidToStr(&VvJoinNode->FileGuid, FileGuidA);
    GuidToStr(&VvJoinNode->ParentGuid, ParentGuidA);
    DPRINT2(Sev, ":V: %wsNode: %08x\n", Indent, VvJoinNode);
    DPRINT2(Sev, ":V: %ws\tFlags     : %08x\n", Indent, VvJoinNode->Flags);
    DPRINT2(Sev, ":V: %ws\tFileGuid  : %s\n", Indent, FileGuidA);
    DPRINT2(Sev, ":V: %ws\tParentGuid: %s\n", Indent, ParentGuidA);
    DPRINT2(Sev, ":V: %ws\tOriginator: %s\n", Indent, Originator);
    DPRINT2(Sev, ":V: %ws\tVsn       : %08x %08x\n", Indent, PRINTQUAD(VvJoinNode->Vsn));
    DPRINT2(Sev, ":V: %ws\tVsns      : %08x\n", Indent, VvJoinNode->Vsns);
}


VOID
VvJoinPrint(
    ULONG            Sev,
    PVVJOIN_CONTEXT  VvJoinContext
    )
/*++

Routine Description:

    Print the tables

Arguments:

    VvJoinContext

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinPrint:"
    PVOID           Key;
    PVOID           SubKey;
    PVVJOIN_NODE    *Entry;
    PVVJOIN_NODE    VvJoinNode;

    DPRINT1(Sev, ":V: >>>>> %s\n", DEBSUB);
    DPRINT(Sev, "\n");
    DPRINT(Sev, ":V: GUIDS\n");
    if (VvJoinContext->Guids) {
        Key = NULL;
        while (Entry = VVJOIN_NEXT_ENTRY(VvJoinContext->Guids, &Key)) {
            VvJoinPrintNode(Sev, L"", *Entry);
        }
    }
    DPRINT(Sev, "\n");
    DPRINT(Sev, ":V: ORIGINATORS\n");
    if (VvJoinContext->Originators) {
        Key = NULL;
        while (Entry = VVJOIN_NEXT_ENTRY(VvJoinContext->Originators, &Key)) {
            VvJoinPrintNode(Sev, L"", *Entry);
            VvJoinNode = *Entry;
            DPRINT(Sev, "\n");
            DPRINT(Sev, ":V: \tVSNS\n");
            if (VvJoinNode->Vsns) {
                SubKey = NULL;
                while (Entry = VVJOIN_NEXT_ENTRY(VvJoinNode->Vsns, &SubKey)) {
                    VvJoinPrintNode(Sev, L"\t", *Entry);
                }
            }
        }
    }
}


//
// Used to test the code that sends files
//
VVJOIN_NODE TestNodes[] = {
//  Flags FileGuid                 ParentGuid                    Originator              Vsn Vsns
    7,    1,0,0,0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,0,0,0,        0,0,0,1,2,3,4,5,6,7,8,  9,  NULL,

    1,    0,0,0,0,0,0,0,0,0,0,2,   1,0,0,0,0,0,0,0,0,0,0,        0,0,0,1,2,3,4,5,6,7,8,  39, NULL,
    1,    0,0,0,0,0,0,0,0,0,0,1,   0,0,0,0,0,0,0,0,0,0,2,        0,0,0,1,2,3,4,5,6,7,8,  29, NULL,

    1,    0,0,0,0,0,0,0,0,0,0,12,  1,0,0,0,0,0,0,0,0,0,0,        0,0,0,1,2,3,4,5,6,7,9,  39, NULL,
    1,    0,0,0,0,0,0,0,0,0,0,11,  0,0,0,0,0,0,0,0,0,0,12,       0,0,0,1,2,3,4,5,6,7,9,  29, NULL,

    1,    0,0,0,0,0,0,0,0,0,0,22,  0,0,0,0,0,0,0,0,0,0,96,       0,0,0,1,2,3,4,5,6,7,7,  39, NULL,
    1,    0,0,0,0,0,0,0,0,0,0,21,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,7,  29, NULL,

    0,    0,0,0,0,0,0,0,0,0,0,31,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,7,  49, NULL,
    0,    0,0,0,0,0,0,0,0,0,0,41,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,8,  49, NULL,
    0,    0,0,0,0,0,0,0,0,0,0,51,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  49, NULL,

    0,    0,0,0,0,0,0,0,0,0,0,61,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,7,  9,  NULL,
    0,    0,0,0,0,0,0,0,0,0,0,71,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,8,  9,  NULL,
    0,    0,0,0,0,0,0,0,0,0,0,81,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  9,  NULL,

    0,    0,0,0,0,0,0,0,0,0,0,91,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  10, NULL,
    0,    0,0,0,0,0,0,0,0,0,0,92,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  11, NULL,
    0,    0,0,0,0,0,0,0,0,0,0,93,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  12, NULL,
    0,    0,0,0,0,0,0,0,0,0,0,94,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  13, NULL,
    0,    0,0,0,0,0,0,0,0,0,0,95,  0,0,0,0,0,0,0,0,0,0,22,       0,0,0,1,2,3,4,5,6,7,9,  14, NULL,
    1,    0,0,0,0,0,0,0,0,0,0,96,  1,0,0,0,0,0,0,0,0,0,0,        0,0,0,1,2,3,4,5,6,7,9,  99, NULL,
};
//
// Expected send order of the above array
//
VVJOIN_NODE TestNodesExpected[] = {
// Flags  FileGuid                 ParentGuid                   Originator                       Vsn  Vsns
   0x19,  0,0,0,0,0,0,0,0,0,0,96,  1,0,0,0,0,0,0,0,0,0,0,       0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 99,  NULL,
   0x19,  0,0,0,0,0,0,0,0,0,0,22,  0,0,0,0,0,0,0,0,0,0,96,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 7, 39,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,61,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 7,  9,  NULL,
   0x01,  0,0,0,0,0,0,0,0,0,0,21,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 7, 29,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,31,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 7, 49,  NULL,

      0,  0,0,0,0,0,0,0,0,0,0,71,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,  9,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,81,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9,  9,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,91,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 10,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,92,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 11,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,93,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 12,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,94,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 13,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,95,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 14,  NULL,

   0x19,  0,0,0,0,0,0,0,0,0,0,2,   1,0,0,0,0,0,0,0,0,0,0,       0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 39,  NULL,
   0x01,  0,0,0,0,0,0,0,0,0,0,1,   0,0,0,0,0,0,0,0,0,0,2,       0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 29,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,41,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 49,  NULL,

   0x19,  0,0,0,0,0,0,0,0,0,0,12,  1,0,0,0,0,0,0,0,0,0,0,       0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 39,  NULL,
   0x01,  0,0,0,0,0,0,0,0,0,0,11,  0,0,0,0,0,0,0,0,0,0,12,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 29,  NULL,
      0,  0,0,0,0,0,0,0,0,0,0,51,  0,0,0,0,0,0,0,0,0,0,22,      0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 9, 49,  NULL,
};
DWORD   NumberOfTestNodes = ARRAY_SZ(TestNodes);
DWORD   NumberOfExpected = ARRAY_SZ(TestNodesExpected);

DWORD
VvJoinTestSend(
    IN PVVJOIN_CONTEXT  VvJoinContext,
    IN PVVJOIN_NODE     VvJoinNode
)
/*++

Routine Description:

    Pretend to send a test node. Compare the node with the expected
    results.

Arguments:

    VvJoinContext
    VvJoinNode

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinTestSend:"
    CHAR            VGuid[GUID_CHAR_LEN];
    CHAR            EGuid[GUID_CHAR_LEN];
    PVVJOIN_NODE    Expected;

    VVJOIN_PRINT_NODE(5, L"TestSend ", VvJoinNode);

    //
    // Sending too many!
    //
    if (VvJoinContext->NumberSent >= NumberOfTestNodes) {
        DPRINT2(0, ":V: ERROR - TOO MANY (%d > %d)\n",
                VvJoinContext->NumberSent, NumberOfTestNodes);
        return ERROR_GEN_FAILURE;
    }

    //
    // Compare this node with the node we expected to send
    //
    Expected = &TestNodesExpected[VvJoinContext->NumberSent];
    VvJoinContext->NumberSent++;

    if (!GUIDS_EQUAL(&VvJoinNode->FileGuid, &Expected->FileGuid)) {
        GuidToStr(&VvJoinNode->FileGuid, VGuid);
        GuidToStr(&Expected->FileGuid, EGuid);
        DPRINT2(0, ":V: ERROR - UNEXPECTED ORDER (FileGuid %s != %s)\n", VGuid, EGuid);
        return ERROR_GEN_FAILURE;
    }

    if (VvJoinNode->Flags != Expected->Flags) {
        DPRINT2(0, ":V: ERROR - UNEXPECTED ORDER (Flags %08x != %08x)\n",
                VvJoinNode->Flags, Expected->Flags);
        return ERROR_GEN_FAILURE;
    }

    if (!GUIDS_EQUAL(&VvJoinNode->ParentGuid, &Expected->ParentGuid)) {
        GuidToStr(&VvJoinNode->ParentGuid, VGuid);
        GuidToStr(&Expected->ParentGuid, EGuid);
        DPRINT2(0, ":V: ERROR - UNEXPECTED ORDER (ParentGuid %s != %s)\n", VGuid, EGuid);
        return ERROR_GEN_FAILURE;
    }

    if (VvJoinNode->Vsn != Expected->Vsn) {
        DPRINT(0, ":V: ERROR - UNEXPECTED ORDER (Vsn)\n");
        return ERROR_GEN_FAILURE;
    }

    if (!GUIDS_EQUAL(&VvJoinNode->Originator, &Expected->Originator)) {
        GuidToStr(&VvJoinNode->Originator, VGuid);
        GuidToStr(&Expected->Originator, EGuid);
        DPRINT2(0, ":V: ERROR - UNEXPECTED ORDER (Originator %s != %s)\n", VGuid, EGuid);
        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}


VOID
VvJoinTest(
    VOID
)
/*++

Routine Description:

    Test ordering by filling the tables from a hardwired array and then
    calling the ordering code to send them. Check that the ordering
    code sends the nodes in the correct order.

Arguments:

    None.

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinTest:"
    DWORD           WStatus;
    DWORD           i;
    DWORD           NumberSent;
    PVVJOIN_CONTEXT VvJoinContext;
    DWORD           VvJoinSendInOrder(IN PVVJOIN_CONTEXT VvJoinContext);
    DWORD           VvJoinSendOutOfOrder(IN PVVJOIN_CONTEXT VvJoinContext);

    if (!DebugInfo.VvJoinTests) {
        DPRINT(4, ":V: VvJoin tests disabled\n");
        return;
    }

    //
    // Pretend that the hardwired array is an IDTable and fill up the tables
    //
    DPRINT1(0, ":V: >>>>> %s\n", DEBSUB);
    DPRINT2(0, ":V: >>>>> %s Starting (%d entries)\n", DEBSUB, NumberOfTestNodes);

    VvJoinContext = FrsAlloc(sizeof(VVJOIN_CONTEXT));
    VvJoinContext->Send = VvJoinTestSend;

    for (i = 0; i < NumberOfTestNodes; ++i) {
        WStatus = VvJoinInsertEntry(VvJoinContext,
                                    TestNodes[i].Flags,
                                    &TestNodes[i].FileGuid,
                                    &TestNodes[i].ParentGuid,
                                    &TestNodes[i].Originator,
                                    &TestNodes[i].Vsn);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT_WS(0, ":V: ERROR - inserting test nodes;", WStatus);
            break;
        }
    }
    VVJOIN_PRINT(5, VvJoinContext);

    //
    // Send the "files" through our send routine
    //
    do {
        NumberSent = VvJoinContext->NumberSent;
        WStatus = VvJoinSendInOrder(VvJoinContext);
        if (WIN_SUCCESS(WStatus) &&
            NumberSent == VvJoinContext->NumberSent) {
            WStatus = VvJoinSendOutOfOrder(VvJoinContext);
        }
    } while (WIN_SUCCESS(WStatus) &&
             NumberSent != VvJoinContext->NumberSent);


    //
    // DONE
    //
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":V: ERROR - TEST FAILED;", WStatus);
    } else if (VvJoinContext->NumberSent != NumberOfExpected) {
        DPRINT2(0, ":V: ERROR - TEST FAILED; Expected to send %d; not %d\n",
                NumberOfExpected, VvJoinContext->NumberSent);
    } else {
        DPRINT(0, ":V: TEST PASSED\n");
    }
    VvJoinContext = VvJoinFreeContext(VvJoinContext);
}


VOID
VvJoinTestSkipBegin(
    IN PVVJOIN_CONTEXT  VvJoinContext,
    IN PCOMMAND_PACKET  Cmd
)
/*++

Routine Description:

    Create a directory and files that will be skipped.

Arguments:

    VvJoinContext
    Cmd

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinTestSkipBegin:"
    HANDLE  Handle;
    DWORD   WStatus;

    if (!DebugInfo.VvJoinTests) {
       DPRINT(4, ":V: VvJoin tests disabled\n");
       return;
    }

    VvJoinContext->SkipDir = FrsWcsPath(RsReplica(Cmd)->Root, L"SkipDir");
    VvJoinContext->SkipFile1 = FrsWcsPath(VvJoinContext->SkipDir, L"SkipFile1");
    VvJoinContext->SkipFile2 = FrsWcsPath(RsReplica(Cmd)->Root, L"SkipFile2");

    if (!WIN_SUCCESS(FrsCreateDirectory(VvJoinContext->SkipDir))) {
        DPRINT1(0, ":V: ERROR - Can't create %ws\n", VvJoinContext->SkipDir);
    }
    WStatus = StuCreateFile(VvJoinContext->SkipFile1, &Handle);
    if (!HANDLE_IS_VALID(Handle) || !WIN_SUCCESS(WStatus)) {
        DPRINT1(0, ":V: ERROR - Can't create %ws\n", VvJoinContext->SkipFile1);
    } else {
        CloseHandle(Handle);
    }
    WStatus = StuCreateFile(VvJoinContext->SkipFile2, &Handle);
    if (!HANDLE_IS_VALID(Handle) || !WIN_SUCCESS(WStatus)) {
        DPRINT1(0, ":V: ERROR - Can't create %ws\n", VvJoinContext->SkipFile2);
    } else {
        CloseHandle(Handle);
    }

    //
    // Wait for the local change orders to propagate
    //
    Sleep(10 * 1000);
}


VOID
VvJoinTestSkipCheck(
    IN PVVJOIN_CONTEXT  VvJoinContext,
    IN PWCHAR           FileName,
    IN BOOL             IsDir
    )
/*++

Routine Description:

    Did we skip the correct files/dirs?

Arguments:

    VvJoinContext
    FileName
    IsDir

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinTestSkipCheck:"

    if (!DebugInfo.VvJoinTests) {
       return;
    }

    if (IsDir && WSTR_EQ(FileName, L"SkipDir")) {
        VvJoinContext->SkippedDir = TRUE;
    } else if (!IsDir && WSTR_EQ(FileName, L"SkipFile1")) {
        VvJoinContext->SkippedFile1 = TRUE;
    } else if (!IsDir && WSTR_EQ(FileName, L"SkipFile2")) {
        VvJoinContext->SkippedFile2 = TRUE;
    }
}


VOID
VvJoinTestSkipEnd(
    IN PVVJOIN_CONTEXT   VvJoinContext
    )
/*++

Routine Description:

    Did we skip the correct files/dirs?

Arguments:

    VvJoinContext

Thread Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinTestSkipEnd:"

    if (!DebugInfo.VvJoinTests) {
       return;
    }

    if (VvJoinContext->SkippedDir &&
        VvJoinContext->SkippedFile1 &&
        VvJoinContext->SkippedFile2) {
        DPRINT(0, ":V: Skip Test Passed\n");
    } else {
        DPRINT(0, ":V: ERROR - Skip Test failed\n");
    }
    FrsDeleteFile(VvJoinContext->SkipFile1);
    FrsDeleteFile(VvJoinContext->SkipFile2);
    FrsDeleteFile(VvJoinContext->SkipDir);
    VvJoinContext->SkipDir = FrsFree(VvJoinContext->SkipDir);
    VvJoinContext->SkipFile1 = FrsFree(VvJoinContext->SkipFile1);
    VvJoinContext->SkipFile2 = FrsFree(VvJoinContext->SkipFile2);
}
#endif DBG


PVVJOIN_NODE
VvJoinFindNode(
    PVVJOIN_CONTEXT VvJoinContext,
    GUID            *FileGuid
    )
/*++

Routine Description:

    Find the node by Guid in the file table.

Arguments:

    VvJoinContext
    FileGuid

Thread Return Value:

    Node or NULL

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinFindNode:"
    VVJOIN_NODE     Node;
    VVJOIN_NODE     *pNode;
    PVVJOIN_NODE    *Entry;

    //
    // No file table? Let the caller deal with it
    //
    if (!VvJoinContext->Guids) {
        return NULL;
    }

    //
    // Build a phoney node to use as a key
    //
    Node.FileGuid = *FileGuid;
    pNode = &Node;
    Entry = RtlLookupElementGenericTable(VvJoinContext->Guids, &pNode);
    if (Entry) {
        return *Entry;
    }
    return NULL;
}


DWORD
VvJoinSendInOrder(
    PVVJOIN_CONTEXT  VvJoinContext
    )
/*++

Routine Description:

    Look through the originator tables and find a node at the
    head of the list that can be sent in the proper VSN order.
    Stop looping when none of the nodes can be sent in order.

    Even if a node is in order, its parent may not have been sent,
    and so the file represented by the node cannot be sent.

Arguments:

    VvJoinContext

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinSendInOrder:"
    DWORD           WStatus;
    BOOL            SentOne;
    PVOID           Key;
    PVOID           SubKey;
    PVVJOIN_NODE    *Entry;
    PVVJOIN_NODE    *SubEntry;
    PVVJOIN_NODE    VvJoinNode;
    PVVJOIN_NODE    VsnNode;
    PVVJOIN_NODE    ParentNode;
    CHAR            ParentGuidA[GUID_CHAR_LEN];
    CHAR            FileGuidA[GUID_CHAR_LEN];

    //
    // Continue to scan the originator tables until nothing can be sent
    //
    DPRINT1(4, ":V: >>>>> %s\n", DEBSUB);
    do {
        WStatus = ERROR_SUCCESS;
        SentOne = FALSE;
        //
        // No tables or no entries; nothing to do
        //
        if (!VvJoinContext->Originators) {
            goto CLEANUP;
        }
        if (!RtlNumberGenericTableElements(VvJoinContext->Originators)) {
            VvJoinContext->Originators = FrsFree(VvJoinContext->Originators);
            goto CLEANUP;
        }
        //
        // Examine the head of each originator table. If the entry can
        // be sent in order, do so.
        Key = NULL;
        while (Entry = VVJOIN_NEXT_ENTRY(VvJoinContext->Originators, &Key)) {
            VvJoinNode = *Entry;
            //
            // No entries; done
            //
            if (!RtlNumberGenericTableElements(VvJoinNode->Vsns)) {
                RtlDeleteElementGenericTable(VvJoinContext->Originators, Entry);
                VvJoinNode->Vsns = FrsFree(VvJoinNode->Vsns);
                Key = NULL;
                continue;
            }
            //
            // Scan for an unsent entry
            //
            SubKey = NULL;
            while (SubEntry = VVJOIN_NEXT_ENTRY(VvJoinNode->Vsns, &SubKey)) {
                VsnNode = *SubEntry;
                VVJOIN_PRINT_NODE(5, L"CHECKING ", VsnNode);
                //
                // Entry was previously sent; remove it and continue
                //
                if (VsnNode->Flags & VVJOIN_FLAGS_SENT) {
                    DPRINT(5, ":V: ALREADY SENT\n");
                    RtlDeleteElementGenericTable(VvJoinNode->Vsns, SubEntry);
                    SubKey = NULL;
                    continue;
                }
                //
                // VsnNode is the head of this list and can be sent in
                // order iff its parent has been sent. Find its parent
                // and check it.
                //
                ParentNode = VvJoinFindNode(VvJoinContext, &VsnNode->ParentGuid);

                //
                // Something is really wrong; everyone's parent should
                // be in the file table UNLESS we picked up a file whose
                // parent was created after we began the IDTable scan.
                //
                // But this is okay if the idtable entry is a tombstoned
                // delete. I am not sure why but I think it has to do
                // with name morphing, reanimation, and out-of-order
                // directory tree deletes.
                //
                if (!ParentNode) {
                    //
                    // Let the reconcile code decide to accept
                    // this change order. Don't let it be dampened.
                    //
                    if (VsnNode->Flags & VVJOIN_FLAGS_DELETED) {
                        VsnNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
                    } else {
                        VsnNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
                    }
                }
                //
                // Parent hasn't been sent; we can't send this node
                // Unless it is a tombstoned delete that lacks a parent
                // node. See above.
                //
                if (ParentNode && !(ParentNode->Flags & VVJOIN_FLAGS_SENT)) {
                    break;
                }
                //
                // Parent has been sent; send this node to the outbound
                // log to be sent on to our outbound partner. If we
                // cannot create this change order give up and return
                // to our caller.
                //
                WStatus = (VvJoinContext->Send)(VvJoinContext, VsnNode);
                if (!WIN_SUCCESS(WStatus)) {
                    goto CLEANUP;
                }
                //
                // Remove it from the originator table
                //
                VsnNode->Flags |= VVJOIN_FLAGS_SENT;
                SentOne = TRUE;
                RtlDeleteElementGenericTable(VvJoinNode->Vsns, SubEntry);
                SubKey = NULL;
                continue;
            }
        }
    } while (WIN_SUCCESS(WStatus) && SentOne);
CLEANUP:
    return WStatus;
}


BOOL
VvJoinInOrder(
    PVVJOIN_CONTEXT  VvJoinContext,
    PVVJOIN_NODE     VvJoinNode
    )
/*++

Routine Description:

    Is this node at the head of an originator list? In other words,
    can this node be sent in order?

Arguments:

    VvJoinContext
    VvJoinNode

Thread Return Value:

    TRUE  - head of list
    FALSE - NOT

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinInOrder:"
    PVOID           Key;
    PVVJOIN_NODE    *Entry;
    PVVJOIN_NODE    OriginatorNode;
    CHAR            FileGuidA[GUID_CHAR_LEN];

    //
    // No originators or no entries. In either case, this node
    // cannot possibly be on the head of a list.
    //
    DPRINT1(4, ":V: >>>>> %s\n", DEBSUB);
    if (!VvJoinContext->Originators) {
        goto NOTFOUND;
    }
    if (!RtlNumberGenericTableElements(VvJoinContext->Originators)) {
        goto NOTFOUND;
    }
    //
    // Find the originator table.
    //
    Entry = RtlLookupElementGenericTable(VvJoinContext->Originators,
                                         &VvJoinNode);
    if (!Entry || !*Entry) {
        goto NOTFOUND;
    }
    //
    // No entries; this node cannot possibly be on the head of a list.
    //
    OriginatorNode = *Entry;
    if (!OriginatorNode->Vsns) {
        goto NOTFOUND;
    }
    if (!RtlNumberGenericTableElements(OriginatorNode->Vsns)) {
        goto NOTFOUND;
    }
    //
    // Head of this list of nodes sorted by vsn
    //
    Key = NULL;
    Entry = VVJOIN_NEXT_ENTRY(OriginatorNode->Vsns, &Key);
    if (!Entry || !*Entry) {
        goto NOTFOUND;
    }
    //
    // This node is at the head of the list if the entry at the head
    // of the list points to it.
    //
    return (*Entry == VvJoinNode);

NOTFOUND:
    GuidToStr(&VvJoinNode->FileGuid, FileGuidA);
    DPRINT1(0, ":V: ERROR - node %s is not in a list\n", FileGuidA);
    return FALSE;
}


DWORD
VvJoinSendIfParentSent(
    PVVJOIN_CONTEXT  VvJoinContext,
    PVVJOIN_NODE     VvJoinNode
    )
/*++

Routine Description:

    Send this node if its parent has been sent. Otherwise, try to
    send its parent.

Arguments:

    VvJoinContext
    VvJoinNode

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinSendIfParentSent:"
    DWORD           WStatus;
    PVVJOIN_NODE    ParentNode;
    CHAR            ParentGuidA[GUID_CHAR_LEN];
    CHAR            FileGuidA[GUID_CHAR_LEN];

    DPRINT1(4, ":V: >>>>> %s\n", DEBSUB);

    //
    // Find this node's parent
    //
    ParentNode = VvJoinFindNode(VvJoinContext, &VvJoinNode->ParentGuid);
    //
    // Something is really wrong. Every node should have a parent UNLESS
    // its parent was created after the IDTable scan began. In either case,
    // give up.
    //
    //
    // But this is okay if the idtable entry is a tombstoned
    // delete. I am not sure why but I think it has to do
    // with name morphing, reanimation, and out-of-order
    // directory tree deletes.
    //
    if (!ParentNode) {
        //
        // Let the reconcile code decide to accept
        // this change order. Don't let it be dampened.
        //
        if (VvJoinNode->Flags & VVJOIN_FLAGS_DELETED) {
            VvJoinNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
        } else {
            VvJoinNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
        }
    }
    //
    // A loop in the directory hierarchy!? Give up.
    //
    if (ParentNode && (ParentNode->Flags & VVJOIN_FLAGS_PROCESSING)) {
        GuidToStr(&VvJoinNode->ParentGuid, ParentGuidA);
        GuidToStr(&VvJoinNode->FileGuid, FileGuidA);
        DPRINT2(0, ":V: ERROR - LOOP parent node %s for %s\n", ParentGuidA, FileGuidA);
        WStatus = ERROR_INVALID_DATA;
        goto CLEANUP;
    }
    //
    // Has this node's parent been sent?
    //
    if (!ParentNode || (ParentNode->Flags & VVJOIN_FLAGS_SENT)) {
        //
        // Sending out of order; don't update the version vector
        //
        if (ParentNode && !VvJoinInOrder(VvJoinContext, VvJoinNode)) {
            VvJoinNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
        }
        //
        // Send this node (its parent has been sent)
        //
        WStatus = (VvJoinContext->Send)(VvJoinContext, VvJoinNode);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
        VvJoinNode->Flags |= VVJOIN_FLAGS_SENT;
    } else {
        //
        // Recurse to see if we can send the parent
        //
        ParentNode->Flags |= VVJOIN_FLAGS_PROCESSING;
        WStatus = VvJoinSendIfParentSent(VvJoinContext, ParentNode);
        ParentNode->Flags &= ~VVJOIN_FLAGS_PROCESSING;
    }

CLEANUP:
    return WStatus;
}


DWORD
VvJoinSendOutOfOrder(
    PVVJOIN_CONTEXT  VvJoinContext
    )
/*++

Routine Description:

    This function is called after VvJoinSendInOrder(). All of the nodes
    that could be sent in order have been sent. At this time, we take
    the first entry of the first originator table and send it or, if
    its parent hasn't been sent, its parent. The search for the parent
    recurses until we have a node whose parent has been sent. The
    recursion will stop because we will either hit the root or we will
    loop.

Arguments:

    VvJoinContext

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinSendOutOfOrder:"
    DWORD           WStatus = ERROR_SUCCESS;
    PVOID           Key;
    PVOID           SubKey;
    PVVJOIN_NODE    *Entry     = NULL;
    PVVJOIN_NODE    *SubEntry  = NULL;
    PVVJOIN_NODE    VvJoinNode = NULL;
    PVVJOIN_NODE    VsnNode    = NULL;
    PVVJOIN_NODE    ParentNode = NULL;

    DPRINT1(4, ":V: >>>>> %s\n", DEBSUB);
    //
    // No table or no entries; nothing to do
    //
    if (!VvJoinContext->Originators) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }
    if (!RtlNumberGenericTableElements(VvJoinContext->Originators)) {
        VvJoinContext->Originators = FrsFree(VvJoinContext->Originators);
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }
    //
    // Find the first originator table with entries
    //
    Key = NULL;
    while (Entry = VVJOIN_NEXT_ENTRY(VvJoinContext->Originators, &Key)) {
        VvJoinNode = *Entry;
        if (!RtlNumberGenericTableElements(VvJoinNode->Vsns)) {
            RtlDeleteElementGenericTable(VvJoinContext->Originators, Entry);
            VvJoinNode->Vsns = FrsFree(VvJoinNode->Vsns);
            Key = NULL;
            continue;
        }
        //
        // Scan for an unsent entry
        //
        SubKey = NULL;
        while (SubEntry = VVJOIN_NEXT_ENTRY(VvJoinNode->Vsns, &SubKey)) {
            VsnNode = *SubEntry;
            VVJOIN_PRINT_NODE(5, L"CHECKING ", VsnNode);
            //
            // Entry was previously sent; remove it and continue
            //
            if (VsnNode->Flags & VVJOIN_FLAGS_SENT) {
                DPRINT(5, ":V: ALREADY SENT\n");
                RtlDeleteElementGenericTable(VvJoinNode->Vsns, SubEntry);
                SubKey = NULL;
                continue;
            }
            break;
        }
        //
        // No unsent entries; reset the loop indicator back to the first
        // entry so that the code at the top of the loop will delete
        // this originator and then look at other originators.
        //
        if (!SubEntry) {
            Key = NULL;
        } else {
            break;
        }
    }
    //
    // No more entries; done
    //
    if (!SubEntry) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }
    //
    // Send this entry if its parent has been sent. Otherwise, recurse.
    // The VVJOIN_FLAGS_PROCESSING detects loops.
    //
    VsnNode = *SubEntry;
    VsnNode->Flags |= VVJOIN_FLAGS_PROCESSING;
    WStatus = VvJoinSendIfParentSent(VvJoinContext, VsnNode);
    VsnNode->Flags &= ~VVJOIN_FLAGS_PROCESSING;

CLEANUP:
    return WStatus;
}


JET_ERR
VvJoinBuildTables(
    IN PTHREAD_CTX      ThreadCtx,
    IN PTABLE_CTX       TableCtx,
    IN PIDTABLE_RECORD  IDTableRec,
    IN PVVJOIN_CONTEXT  VvJoinContext
)
/*++

Routine Description:

    This is a worker function passed to FrsEnumerateTable().  Each time
    it is called it inserts an entry into the vvjoin tables. These
    tables will be used later to send the appropriate files and directories
    to our outbound partner.

    Files that would have been dampened are not included.

    All directories are included but directories that would have been
    dampened are marked as "SENT". Keeping the complete directory
    hierarchy makes other code in this subsystem easier.

Arguments:

    ThreadCtx   - Needed to access Jet.
    TableCtx    - A ptr to an IDTable context struct.
    IDTableRec  - A ptr to a IDTable record.
    VvJoinContext

Thread Return Value:

    A Jet error status.  Success means call us with the next record.
    Failure means don't call again and pass our status back to the
    caller of FrsEnumerateTable().

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinBuildTables:"


    ULONGLONG   SystemTime;
    ULONGLONG   ExpireTime;

    ULONGLONG   OriginatorVSN = IDTableRec->OriginatorVSN;
    GUID        *OriginatorGuid = &IDTableRec->OriginatorGuid;
    PGEN_TABLE  ReplicaVv = VvJoinContext->ReplicaVv;

    DWORD       WStatus;
    DWORD       Flags = 0;

    //
    // First check to see if our partner already has this file by comparing
    // the OriginatorVSN in our IDTable record with the corresponding value
    // in the version vector we got from the partner.
    //
    if (VVHasVsnNoLock(VvJoinContext->CxtionVv, OriginatorGuid, OriginatorVSN)) {
        //
        // Yes, buts its a dir; include in the tables but mark it as sent.  We
        // include it in the tables because the code that checks for an
        // existing parent requires the entire directory tree.
        //
        if (IDTableRec->FileIsDir) {
            DPRINT1(4, ":V: Dir %ws is in the Vv; INSERT SENT.\n", IDTableRec->FileName);
            Flags |= VVJOIN_FLAGS_SENT;
        } else {

            //
            // Dampened file, done
            //
            DPRINT1(4, ":V: File %ws is in the Vv; SKIP.\n", IDTableRec->FileName);
            return JET_errSuccess;
        }
    }

    //
    // Ignore files that have changed since the beginning of the IDTable scan.
    // Keep directories but mark them as sent out-of-order.  We must still
    // send the directories because a file with a lower VSN may depend on this
    // directory's existance.  We mark the directory out-of-order because we
    // can't be certain that we have seen all of the directories and files
    // with VSNs lower than this.
    //
    // Note: If the orginator guid is not found in our Replica VV then we have
    // to send the file and let the partner accept/reject.  This can happen
    // if one or more COs arrived here with a new originator guid and were
    // all marked out-of-order.  Because the VVRetire code will not update the
    // VV for out-of-order COs the new originator guid will not get added to
    // our Replica VV so VVHasVsn will return FALSE making us think that a new
    // CO has arrived since the scan started (and get sent out) which is
    // not the case.  The net effect is that the file won't get sent.
    // (Yes this actually happened.)
    //
    if (!VVHasVsnNoLock(ReplicaVv, OriginatorGuid, OriginatorVSN) &&
        VVHasOriginatorNoLock(ReplicaVv, OriginatorGuid)) {

        if (IDTableRec->FileIsDir) {
            DPRINT1(4, ":V: Dir %ws is not in the ReplicaVv; Mark out-of-order.\n",
                    IDTableRec->FileName);

            Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
            VVJOIN_TEST_SKIP_CHECK(VvJoinContext, IDTableRec->FileName, TRUE);
        } else if (IsIdRecVVFlagSet(IDTableRec, IDREC_VVFLAGS_SKIP_VV_UPDATE)){
            //
            // If the skip vvupdate flag is set the we need to send the CO even though
            // it may already be in the outbound log. By skipping it here we will
            // never send it as the current outlog sequence number may be past
            // the CO.
            //
            DPRINT1(4, ":V: File %ws is not in the ReplicaVv but marked SkipVVUpdate; do not Skip.\n",
                    IDTableRec->FileName);

            VVJOIN_TEST_SKIP_CHECK(VvJoinContext, IDTableRec->FileName, FALSE);
        } else {
            //
            // Ignored file, done
            //
            DPRINT1(4, ":V: File %ws is not in the ReplicaVv; Skip.\n",
                    IDTableRec->FileName);

            VVJOIN_TEST_SKIP_CHECK(VvJoinContext, IDTableRec->FileName, FALSE);
            return JET_errSuccess;
        }
    }

    //
    // Deleted
    //
    if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {
        Flags |= VVJOIN_FLAGS_DELETED;

        //
        // Check for expired tombstones and don't send them.
        //
        GetSystemTimeAsFileTime((PFILETIME)&SystemTime);
        COPY_TIME(&ExpireTime, &IDTableRec->TombStoneGC);

        if ((ExpireTime < SystemTime) && (ExpireTime != QUADZERO)) {

            //
            // IDTable record has expired.  Delete it.
            //
            if (IDTableRec->FileIsDir) {
                DPRINT1(4, ":V: Dir %ws IDtable record has expired.  Don't send.\n",
                        IDTableRec->FileName);
                Flags |= VVJOIN_FLAGS_SENT;
            } else {

                //
                // Expired and not a dir so don't even insert in tables.
                //
                DPRINT1(4, ":V: File %ws is expired; SKIP.\n", IDTableRec->FileName);
                return JET_errSuccess;
            }
        }
    }

    //
    // Ignore incomplete entries. Check for the IDREC_FLAGS_NEW_FILE_IN_PROGRESS flag.
    //
    if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_NEW_FILE_IN_PROGRESS)) {
        DPRINT1(4, ":V: %ws is new file in progress; SKIP.\n", IDTableRec->FileName);
        return JET_errSuccess;
    }

    //
    // The root node is never sent.
    //
    if (GUIDS_EQUAL(&IDTableRec->FileGuid,
                    VvJoinContext->Replica->ReplicaRootGuid)) {
        DPRINT1(4, ":V: %ws is root\n", IDTableRec->FileName);
        Flags |= VVJOIN_FLAGS_ROOT | VVJOIN_FLAGS_SENT;
    }

    //
    // Is a directory
    //
    if (IDTableRec->FileIsDir) {
        DPRINT1(4, ":V: %ws is directory\n", IDTableRec->FileName);
        Flags |= VVJOIN_FLAGS_ISDIR;
    }

    //
    // Include in the vvjoin tables.
    //
    WStatus = VvJoinInsertEntry(VvJoinContext,
                                Flags,
                                &IDTableRec->FileGuid,
                                &IDTableRec->ParentGuid,
                                OriginatorGuid,
                                &OriginatorVSN);
    CLEANUP3_WS(4, ":V: ERROR - inserting %ws for %ws\\%ws;",
                IDTableRec->FileName, VvJoinContext->Replica->SetName->Name,
                VvJoinContext->Replica->MemberName->Name, WStatus, CLEANUP);

    //
    // Stop the VvJoin if the cxtion is no longer joined
    //
    VV_JOIN_TRIGGER(VvJoinContext);
    if (!CxtionFlagIs(VvJoinContext->Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
        !GUIDS_EQUAL(&VvJoinContext->JoinGuid, &VvJoinContext->Cxtion->JoinGuid)) {
        DPRINT(0, ":V: VVJOIN ABORTED; MISMATCHED JOIN GUIDS\n");
        goto CLEANUP;
    }

    return JET_errSuccess;

CLEANUP:

    return JET_errKeyDuplicate;
}


DWORD
VvJoinSend(
    IN PVVJOIN_CONTEXT  VvJoinContext,
    IN PVVJOIN_NODE     VvJoinNode
)
/*++

Routine Description:

    Generate a refresh change order and inject it into the outbound
    log. The staging file will be generated on demand. See the
    outlog.c code for more information.

Arguments:

    VvJoinContext
    VvJoinNode

Thread Return Value:

    Win32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "VvJoinSend:"
    JET_ERR                 jerr;
    PCOMMAND_PACKET         Cmd;
    PIDTABLE_RECORD         IDTableRec;
    PCHANGE_ORDER_ENTRY     Coe;
    ULONG                   CoFlags;
    LONG                    OlTimeout = VvJoinContext->OlTimeout;
    ULONG                   LocationCmd = CO_LOCATION_CREATE;

    VVJOIN_PRINT_NODE(5, L"Sending ", VvJoinNode);

    //
    // Read the IDTable entry for this file
    //
    jerr = DbsReadRecord(VvJoinContext->ThreadCtx,
                         &VvJoinNode->FileGuid,
                         GuidIndexx,
                         VvJoinContext->TableCtx);
    if (!JET_SUCCESS(jerr)) {
        DPRINT_JS(0, "DbsReadRecord:", jerr);
        return ERROR_NOT_FOUND;
    }

    //
    // Deleted
    //
    IDTableRec = VvJoinContext->TableCtx->pDataRecord;
    if (IsIdRecFlagSet(IDTableRec, IDREC_FLAGS_DELETED)) {
        VvJoinNode->Flags |= VVJOIN_FLAGS_DELETED;
        LocationCmd = CO_LOCATION_DELETE;
    }
    //
    // How could this happen?!
    //
    if (!GUIDS_EQUAL(&VvJoinNode->FileGuid, &IDTableRec->FileGuid)) {
        return ERROR_OPERATION_ABORTED;
    } else {
        DPRINT1(4, ":V: Read IDTable entry for %ws\n", IDTableRec->FileName);
    }

    //
    // File or dir changed after the IDTable scan. Ignore files
    // but send directories marked as out-of-order. We do this
    // because a file with a lower VSN may require this directory.
    // Note that a directory's VSN may be higher because it was
    // newly created or simply altered by, say, changing its times
    // or adding an alternate data stream.
    //
    if (!GUIDS_EQUAL(&IDTableRec->OriginatorGuid, &VvJoinNode->Originator) ||
        IDTableRec->OriginatorVSN != VvJoinNode->Vsn) {
        DPRINT3(4, ":V: WARN: VSN/ORIGINATOR Mismatch for %ws\\%ws %ws\n",
                VvJoinContext->Replica->SetName->Name,
                VvJoinContext->Replica->MemberName->Name,
                IDTableRec->FileName);

        if (VvJoinNode->Flags & VVJOIN_FLAGS_DELETED) {
            //
            // If this entry was marked deleted it is possible that it was
            // reamimated with a demand refresh CO.  If that happened then
            // the VSN in the IDTable would have changed (getting us here)
            // but no CO would get placed in the Outbound log (since demand
            // refresh COs don't propagate).  So let the reconcile code
            // decide to accept/reject this change order. Don't let it be dampened.
            //
            DPRINT1(4, ":V: Sending delete tombstone for %ws out of order\n", IDTableRec->FileName);
            VvJoinNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;
        } else

        if (VvJoinNode->Flags & VVJOIN_FLAGS_ISDIR) {
            DPRINT1(4, ":V: Sending directory %ws out of order\n", IDTableRec->FileName);
            VvJoinNode->Flags |= VVJOIN_FLAGS_OUT_OF_ORDER;

        } else {

            DPRINT1(4, ":V: Skipping file %ws\n", IDTableRec->FileName);
            VvJoinNode->Flags |= VVJOIN_FLAGS_SENT;
        }
    }

    if (!(VvJoinNode->Flags & VVJOIN_FLAGS_SENT)) {
        if (VvJoinNode->Flags & VVJOIN_FLAGS_DELETED) {
            FRS_CO_FILE_PROGRESS(IDTableRec->FileName,
                                 IDTableRec->OriginatorVSN,
                                 "VVjoin sending delete");
        } else {
            FRS_CO_FILE_PROGRESS(IDTableRec->FileName,
                                 IDTableRec->OriginatorVSN,
                                 "VVjoin sending create");
        }


        CoFlags = 0;
        //
        // Change order has a Location command
        //
        SetFlag(CoFlags, CO_FLAG_LOCATION_CMD);
        //
        // Mascarade as a local change order since the staging file
        // is created from the local version of the file and isn't
        // from a inbound partner.
        //
        SetFlag(CoFlags, CO_FLAG_LOCALCO);

        //
        // Refresh change orders will not be propagated by our outbound
        // partner to its outbound partners.
        //
        // Change of plans; allow the propagation to occur so that
        // parallel vvjoins and vvjoinings work (A is vvjoining B is
        // vvjoining C).
        //
        // SetFlag(CoFlags, CO_FLAG_REFRESH);

        //
        // Directed at one cxtion
        //
        SetFlag(CoFlags, CO_FLAG_DIRECTED_CO);


        //
        // This vvjoin requested change order may end up going back to its
        // originator because the originator's version vector doesn't seem to
        // have this file/dir.  This could happen if the database was deleted on
        // the originator and is being re-synced.  Since the originator could be
        // several hops away the bit stays set to suppress dampening back to the
        // originator.  If it gets to the originator then reconcile logic there
        // decides to accept or reject.
        //
        SetFlag(CoFlags, CO_FLAG_VVJOIN_TO_ORIG);


        if (IsIdRecVVFlagSet(IDTableRec, IDREC_VVFLAGS_SKIP_VV_UPDATE)) {
            SetFlag(CoFlags, CO_FLAG_SKIP_VV_UPDATE);
        }
        //
        // Increment the LCO Sent At Join counters
        // for both the Replic set and connection objects.
        //
        PM_INC_CTR_REPSET(VvJoinContext->Replica, LCOSentAtJoin, 1);
        PM_INC_CTR_CXTION(VvJoinContext->Cxtion, LCOSentAtJoin, 1);

        //
        // By "out of order" we mean that the VSN on this change order
        // should not be used to update the version vector because there
        // may be other files or dirs with lower VSNs that will be sent
        // later. We wouldn't want our partner to dampen them.
        //
        if (VvJoinNode->Flags & VVJOIN_FLAGS_OUT_OF_ORDER) {
            SetFlag(CoFlags, CO_FLAG_OUT_OF_ORDER);
        }

        //
        // Build a change order entry from the IDtable Record.
        //
        Coe = ChgOrdMakeFromIDRecord(IDTableRec,
                                     VvJoinContext->Replica,
                                     LocationCmd,
                                     CoFlags,
                                     VvJoinContext->Cxtion->Name->Guid);

        //
        // Set CO state
        //
        SET_CHANGE_ORDER_STATE(Coe, IBCO_OUTBOUND_REQUEST);

        //
        // The DB server is responsible for updating the outbound log.
        // WARNING -- The operation is synchronous so that an command
        // packets will not be sitting on the DB queue once an unjoin
        // command has completed. If this call is made async; then
        // some thread must wait for the DB queue to drain before
        // completing the unjoin operation. E.g., use the inbound
        // changeorder count for these outbound change orders and don't
        // unjoin until the count hits 0.
        //
        Cmd = DbsPrepareCmdPkt(NULL,                        //  CmdPkt,
                               VvJoinContext->Replica,      //  Replica,
                               CMD_DBS_INJECT_OUTBOUND_CO,  //  CmdRequest,
                               NULL,                        //  TableCtx,
                               Coe,                         //  CallContext,
                               0,                           //  TableType,
                               0,                           //  AccessRequest,
                               0,                           //  IndexType,
                               NULL,                        //  KeyValue,
                               0,                           //  KeyValueLength,
                               FALSE);                      //  Submit
        FrsSetCompletionRoutine(Cmd, FrsCompleteKeepPkt, NULL);
        FrsSubmitCommandServerAndWait(&DBServiceCmdServer, Cmd, INFINITE);
        FrsFreeCommand(Cmd, NULL);
        //
        // Stats
        //
        VvJoinContext->NumberSent++;
        VvJoinContext->OutstandingCos++;
    }

    //
    // Stop the vvjoin thread
    //
    if (FrsIsShuttingDown) {
        return ERROR_PROCESS_ABORTED;
    }
    //
    // Stop the VvJoin if the cxtion is no longer joined
    //
    VV_JOIN_TRIGGER(VvJoinContext);

RETEST:
    if (!CxtionFlagIs(VvJoinContext->Cxtion, CXTION_FLAGS_JOIN_GUID_VALID) ||
        !GUIDS_EQUAL(&VvJoinContext->JoinGuid, &VvJoinContext->Cxtion->JoinGuid)) {
        DPRINT(0, ":V: VVJOIN ABORTED; MISMATCHED JOIN GUIDS\n");
        return ERROR_OPERATION_ABORTED;
    }
    //
    // Throttle the number of vvjoin change orders outstanding so
    // that we don't fill up the staging area or the database.
    //
    if (VvJoinContext->OutstandingCos >= VvJoinContext->MaxOutstandingCos) {
        if (VvJoinContext->Cxtion->OLCtx->OutstandingCos) {
            DPRINT2(0, ":V: Throttling for %d ms; %d OutstandingCos\n",
                    OlTimeout, VvJoinContext->Cxtion->OLCtx->OutstandingCos);

            Sleep(OlTimeout);

            OlTimeout <<= 1;
            //
            // Too small
            //
            if (OlTimeout < VvJoinContext->OlTimeout) {
                OlTimeout = VvJoinContext->OlTimeout;
            }
            //
            // Too large
            //
            if (OlTimeout > VvJoinContext->OlTimeoutMax) {
                OlTimeout = VvJoinContext->OlTimeoutMax;
            }
            goto RETEST;
        }
        //
        // The number of outstanding cos went to 0; send another slug
        // of change orders to the outbound log process.
        //
        VvJoinContext->OutstandingCos = 0;
    }
    return ERROR_SUCCESS;
}


VOID
ChgOrdInjectControlCo(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN ULONG    ContentCmd
    );
ULONG
MainVvJoin(
    PVOID  FrsThreadCtxArg
)
/*++
Routine Description:

    Entry point for processing vvjoins. This thread scans the IDTable
    and generates change orders for files and dirs that our outbound
    partner lacks. The outbound partner's version vector is used
    to select the files and dirs. This thread is invoked during
    join iff the change orders needed by our outbound partner have
    been deleted from the outbound log. See outlog.c for more info
    about this decision.

    This process is termed a vvjoin to distinguish it from a normal
    join. A normal join sends the change orders in the outbound
    log to our outbound partner without invoking this thread.

    This thread is a command server and is associated with a
    cxtion by a PCOMMAND_SERVER field (VvJoinCs) in the cxtion.
    Like all command servers, this thread will exit after a
    few minutes if there is no work and will be spawned when
    work shows up on its queue.

Arguments:

    FrsThreadCtxArg - Frs thread context

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB  "MainVvJoin:"

    JET_ERR             jerr;
    ULONG               WStatus = ERROR_SUCCESS;
    ULONG               FStatus;
    DWORD               NumberSent;
    PCOMMAND_PACKET     Cmd;
    PFRS_THREAD         FrsThread = (PFRS_THREAD)FrsThreadCtxArg;
    PCOMMAND_SERVER     VvJoinCs = FrsThread->Data;
    PVVJOIN_CONTEXT     VvJoinContext = NULL;

    DPRINT(1, ":S: VvJoin Thread is starting.\n");
    FrsThread->Exit = ThSupExitWithTombstone;

    //
    // Quick verification test
    //
    VVJOIN_TEST();

    //
    // Try-Finally
    //
    try {

    //
    // Capture exception.
    //
    try {

CANT_EXIT_YET:

    DPRINT(1, ":S: VvJoin Thread has started.\n");
    while((Cmd = FrsGetCommandServer(VvJoinCs)) != NULL) {

        //
        // Shutting down; stop accepting command packets
        //
        if (FrsIsShuttingDown) {
            FrsRunDownCommandServer(VvJoinCs, &VvJoinCs->Queue);
        }
        switch (Cmd->Command) {
            case CMD_VVJOIN_START: {
                DPRINT3(1, ":V: Start vvjoin for %ws\\%ws\\%ws\n",
                        RsReplica(Cmd)->SetName->Name, RsReplica(Cmd)->MemberName->Name,
                        RsCxtion(Cmd)->Name);
                //
                // The database must be started before we create a jet session
                //      WARN: The database event may be set by the shutdown
                //      code in order to force threads to exit.
                //
                WaitForSingleObject(DataBaseEvent, INFINITE);
                if (FrsIsShuttingDown) {
                    RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                    WStatus = ERROR_PROCESS_ABORTED;
                    break;
                }

                //
                // Global info
                //
                VvJoinContext = FrsAlloc(sizeof(VVJOIN_CONTEXT));
                VvJoinContext->Send = VvJoinSend;

                //
                // Outstanding change orders
                //
                CfgRegReadDWord(FKC_VVJOIN_LIMIT, NULL, 0, &VvJoinContext->MaxOutstandingCos);

                DPRINT1(4, ":V: VvJoin Max OutstandingCos is %d\n",
                        VvJoinContext->MaxOutstandingCos);

                //
                // Outbound Log Throttle Timeout
                //
                CfgRegReadDWord(FKC_VVJOIN_TIMEOUT, NULL, 0, &VvJoinContext->OlTimeout);

                if (VvJoinContext->OlTimeout < VVJOIN_TIMEOUT_MAX) {
                    VvJoinContext->OlTimeoutMax = VVJOIN_TIMEOUT_MAX;
                } else {
                    VvJoinContext->OlTimeoutMax = VvJoinContext->OlTimeout;
                }

                DPRINT2(4, ":V: VvJoin Outbound Log Throttle Timeout is %d (%d max)\n",
                        VvJoinContext->OlTimeout, VvJoinContext->OlTimeoutMax);

                //
                // Allocate a context for Jet to run in this thread.
                //
                VvJoinContext->ThreadCtx = FrsAllocType(THREAD_CONTEXT_TYPE);
                VvJoinContext->TableCtx = DbsCreateTableContext(IDTablex);

                //
                // Setup a Jet Session (returning the session ID in ThreadCtx).
                //
                jerr = DbsCreateJetSession(VvJoinContext->ThreadCtx);
                if (JET_SUCCESS(jerr)) {
                    DPRINT(4,":V: JetOpenDatabase complete\n");
                } else {
                    DPRINT_JS(0,":V: ERROR - OpenDatabase failed.", jerr);
                    FStatus = DbsTranslateJetError(jerr, FALSE);
                    RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                    break;
                }

                //
                // Pull over the params from the command packet into our context
                //

                //
                // Replica
                //
                VvJoinContext->Replica = RsReplica(Cmd);
                //
                // Outbound version vector
                //
                VvJoinContext->CxtionVv = RsVVector(Cmd);
                RsVVector(Cmd) = NULL;
                //
                // Replica's version vector
                //
                VvJoinContext->ReplicaVv = RsReplicaVv(Cmd);
                RsReplicaVv(Cmd) = NULL;
                //
                // Join Guid
                //
                COPY_GUID(&VvJoinContext->JoinGuid, RsJoinGuid(Cmd));
                //
                // Cxtion
                //
                VvJoinContext->Cxtion = GTabLookup(VvJoinContext->Replica->Cxtions,
                                                   RsCxtion(Cmd)->Guid,
                                                   NULL);
                if (!VvJoinContext->Cxtion) {
                    DPRINT2(4, ":V: No Cxtion for %ws\\%ws; unjoining\n",
                            VvJoinContext->Replica->SetName->Name,
                            VvJoinContext->Replica->MemberName->Name);
                    RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                    break;
                }

                DPRINT2(4, ":V: VvJoining %ws\\%ws\n",
                        VvJoinContext->Replica->SetName->Name,
                        VvJoinContext->Replica->MemberName->Name);

                VV_PRINT_OUTBOUND(4, L"Cxtion ", VvJoinContext->CxtionVv);
                VV_PRINT_OUTBOUND(4, L"Replica ", VvJoinContext->ReplicaVv);

                VVJOIN_TEST_SKIP_BEGIN(VvJoinContext, Cmd);

                //
                // Init the table context and open the ID table.
                //
                jerr = DbsOpenTable(VvJoinContext->ThreadCtx,
                                    VvJoinContext->TableCtx,
                                    VvJoinContext->Replica->ReplicaNumber,
                                    IDTablex,
                                    NULL);
                if (!JET_SUCCESS(jerr)) {
                    DPRINT_JS(0,":V: ERROR - DbsOpenTable failed.", jerr);
                    RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                    break;
                }

                //
                // Scan thru the IDTable by the FileGuidIndex calling
                // VvJoinBuildTables() for each record to make entires
                // in the vvjoin tables.
                //
                jerr = FrsEnumerateTable(VvJoinContext->ThreadCtx,
                                         VvJoinContext->TableCtx,
                                         GuidIndexx,
                                         VvJoinBuildTables,
                                         VvJoinContext);

                //
                // We're done.  Return success if we made it to the end
                // of the ID Table.
                //
                if (jerr != JET_errNoCurrentRecord ) {
                    DPRINT_JS(0,":V: ERROR - FrsEnumerateTable failed.", jerr);
                    RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                    break;
                }
                VVJOIN_PRINT(5, VvJoinContext);

                //
                // Send the files and dirs to our outbound partner in order,
                // if possible. Otherwise send them on out-of-order. Stop
                // on error or shutdown.
                //
                do {
                    //
                    // Send in order
                    //
                    NumberSent = VvJoinContext->NumberSent;
                    WStatus = VvJoinSendInOrder(VvJoinContext);
                    //
                    // Send out of order
                    //
                    // If none could be sent in order, send one out-of-order
                    // and then try to send in-order again.
                    //
                    if (WIN_SUCCESS(WStatus) &&
                        !FrsIsShuttingDown &&
                        NumberSent == VvJoinContext->NumberSent) {
                        WStatus = VvJoinSendOutOfOrder(VvJoinContext);
                    }
                } while (WIN_SUCCESS(WStatus) &&
                         !FrsIsShuttingDown &&
                         NumberSent != VvJoinContext->NumberSent);

                //
                // Shutting down; abort
                //
                if (FrsIsShuttingDown) {
                    WStatus = ERROR_PROCESS_ABORTED;
                }

                DPRINT5(1, ":V: vvjoin %s for %ws\\%ws\\%ws (%d sent)\n",
                        (WIN_SUCCESS(WStatus)) ? "succeeded" : "failed",
                        RsReplica(Cmd)->SetName->Name, RsReplica(Cmd)->MemberName->Name,
                        RsCxtion(Cmd)->Name, VvJoinContext->NumberSent);

                VVJOIN_TEST_SKIP_END(VvJoinContext);

                //
                // We either finished without problems or we force an unjoin
                //
                if (WIN_SUCCESS(WStatus)) {
                    ChgOrdInjectControlCo(VvJoinContext->Replica,
                                          VvJoinContext->Cxtion,
                                          FCN_CO_NORMAL_VVJOIN_TERM);
                    VvJoinContext->NumberSent++;
                    if (CxtionFlagIs(VvJoinContext->Cxtion, CXTION_FLAGS_TRIGGER_SCHEDULE)) {
                        ChgOrdInjectControlCo(VvJoinContext->Replica,
                                              VvJoinContext->Cxtion,
                                              FCN_CO_END_OF_JOIN);
                        VvJoinContext->NumberSent++;
                    }
                    RcsSubmitTransferToRcs(Cmd, CMD_VVJOIN_SUCCESS);

                } else {

                    ChgOrdInjectControlCo(VvJoinContext->Replica,
                                          VvJoinContext->Cxtion,
                                          FCN_CO_ABNORMAL_VVJOIN_TERM);
                    VvJoinContext->NumberSent++;
                    RcsSubmitTransferToRcs(Cmd, CMD_UNJOIN);
                }
                break;
            }

            case CMD_VVJOIN_DONE: {
                DPRINT3(1, ":V: Stop vvjoin for %ws\\%ws\\%ws\n",
                        RsReplica(Cmd)->SetName->Name, RsReplica(Cmd)->MemberName->Name,
                        RsCxtion(Cmd)->Name);
                FrsRunDownCommandServer(VvJoinCs, &VvJoinCs->Queue);
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            case CMD_VVJOIN_DONE_UNJOIN: {
                DPRINT3(1, ":V: Stop vvjoin for unjoining %ws\\%ws\\%ws\n",
                        RsReplica(Cmd)->SetName->Name, RsReplica(Cmd)->MemberName->Name,
                        RsCxtion(Cmd)->Name);
                FrsCompleteCommand(Cmd, ERROR_SUCCESS);
                break;
            }

            default: {
                DPRINT1(0, ":V: ERROR - Unknown command %08x\n", Cmd->Command);
                FrsCompleteCommand(Cmd, ERROR_INVALID_PARAMETER);
                break;
            }
        }  // end of switch
        //
        // Clean up our context
        //
        VvJoinContext = VvJoinFreeContext(VvJoinContext);
    }


    VvJoinContext = VvJoinFreeContext(VvJoinContext);
    DPRINT(1, ":S: Vv Join Thread is exiting.\n");
    FrsExitCommandServer(VvJoinCs, FrsThread);
    DPRINT(1, ":S: CAN'T EXIT, YET; Vv Join Thread is still running.\n");
    goto CANT_EXIT_YET;


    //
    // Get exception status.
    //
    } except (EXCEPTION_EXECUTE_HANDLER) {
        GET_EXCEPTION_CODE(WStatus);
    }


    } finally {

        if (WIN_SUCCESS(WStatus)) {
            if (AbnormalTermination()) {
                WStatus = ERROR_OPERATION_ABORTED;
            }
        }

        DPRINT_WS(0, "VvJoinCs finally.", WStatus);

        //
        // Trigger FRS shutdown if we terminated abnormally.
        //
        if (!WIN_SUCCESS(WStatus) && (WStatus != ERROR_PROCESS_ABORTED)) {
            DPRINT(0, "VvJoinCs terminated abnormally, forcing service shutdown.\n");
            FrsIsShuttingDown = TRUE;
            SetEvent(ShutDownEvent);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }

    return WStatus;
}


VOID
SubmitVvJoin(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to a vvjoin command server.

Arguments:

    Replica
    Cxtion
    Command

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB  "SubmitVvJoin:"
    PCOMMAND_PACKET Cmd;

    //
    // Don't create command servers during shutdown
    //      Obviously, the check isn't protected and so
    //      a command server may get kicked off and never
    //      rundown if the replica subsystem shutdown
    //      function has already been called BUT the
    //      vvjoin threads use the exittombstone so
    //      the shutdown thread won't wait too long for the
    //      vvjoin threads to exit.
    //
    if (FrsIsShuttingDown) {
        return;
    }

    //
    // First submission; create the command server
    //
    if (!Cxtion->VvJoinCs) {
        Cxtion->VvJoinCs = FrsAlloc(sizeof(COMMAND_SERVER));
        FrsInitializeCommandServer(Cxtion->VvJoinCs,
                                   VVJOIN_MAXTHREADS_PER_CXTION,
                                   L"VvJoinCs",
                                   MainVvJoin);
    }
    Cmd = FrsAllocCommand(&Cxtion->VvJoinCs->Queue, Command);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Outbound version vector
    //
    RsReplica(Cmd) = Replica;
    RsCxtion(Cmd) = FrsDupGName(Cxtion->Name);
    RsJoinGuid(Cmd) = FrsDupGuid(&Cxtion->JoinGuid);
    RsVVector(Cmd) = VVDupOutbound(Cxtion->VVector);
    RsReplicaVv(Cmd) = VVDupOutbound(Replica->VVector);

    //
    // And away we go
    //
    DPRINT5(4, ":V: Submit %08x for Cmd %08x %ws\\%ws\\%ws\n",
            Cmd->Command, Cmd, RsReplica(Cmd)->SetName->Name,
            RsReplica(Cmd)->MemberName->Name, RsCxtion(Cmd)->Name);

    FrsSubmitCommandServer(Cxtion->VvJoinCs, Cmd);
}


DWORD
SubmitVvJoinSync(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    )
/*++
Routine Description:
    Submit a command to a vvjoin command server.

Arguments:

    Replica
    Cxtion
    Command

Return Value:
    None.
--*/
{
#undef  DEBSUB
#define DEBSUB  "SubmitVvJoinSync:"
    PCOMMAND_PACKET Cmd;
    DWORD           WStatus;

    //
    // First submission; done
    //
    if (!Cxtion->VvJoinCs) {
        return ERROR_SUCCESS;
    }

    Cmd = FrsAllocCommand(&Cxtion->VvJoinCs->Queue, Command);
    FrsSetCompletionRoutine(Cmd, RcsCmdPktCompletionRoutine, NULL);

    //
    // Outbound version vector
    //
    RsReplica(Cmd) = Replica;
    RsCxtion(Cmd) = FrsDupGName(Cxtion->Name);
    RsCompletionEvent(Cmd) = FrsCreateEvent(TRUE, FALSE);

    //
    // And away we go
    //
    DPRINT5(4, ":V: Submit Sync %08x for Cmd %08x %ws\\%ws\\%ws\n",
            Cmd->Command, Cmd, RsReplica(Cmd)->SetName->Name,
            RsReplica(Cmd)->MemberName->Name, RsCxtion(Cmd)->Name);

    FrsSubmitCommandServer(Cxtion->VvJoinCs, Cmd);

    //
    // Wait for the command to finish
    //
    WaitForSingleObject(RsCompletionEvent(Cmd), INFINITE);
    FRS_CLOSE(RsCompletionEvent(Cmd));

    WStatus = Cmd->ErrorStatus;
    FrsCompleteCommand(Cmd, Cmd->ErrorStatus);
    return WStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frswmipv\frswmipv.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frswmipv.cpp

Abstract:
    This is the implementation of the WMI provider for NTFRS. This file
    contains the implementation of the CProvider class.

Author:
    Sudarshan Chitre (sudarc) , Mathew George (t-mattg) -  3-Aug-2000

Environment
    User mode winnt

--*/


extern "C" {
#include <ntreppch.h>
#include <frs.h>
}

#include <frswmipv.h>

//
// Extern globals from other modules.
//
extern "C" PGEN_TABLE ReplicasByGuid;
extern "C" PCHAR OLPartnerStateNames[];

// const CLSID CLSID_Provider = {0x39143F73,0xFDB1,0x4CF5,0x8C,0xB7,0xC8,0x43,0x9E,0x3F,0x5C,0x20};

/////////////////////////////////////////////////////////////////////////////
// CProvider


//
// Class constructor/destructor
//

CProvider::CProvider()
/*++
Routine Description:
    Initializes members of the CProvider class.

Arguments:
    None

Return Value:
    None

--*/
{
    ODS(L"CProvider constructor.\n");
    m_NumReplicaSets = 5;
    m_dwRef = 0;
    m_ipNamespace = NULL;
    m_ipMicrosoftFrs_DfsMemberClassDef = NULL;
    m_ipMicrosoftFrs_SysVolMemberClassDef = NULL;
    m_ipMicrosoftFrs_DfsConnectionClassDef = NULL;
    m_ipMicrosoftFrs_SysVolConnectionClassDef = NULL;
	m_ipMicrosoftFrs_DfsMemberEventClassDef = NULL;
}

CProvider::~CProvider()
/*++
Routine Description:
    Deallocates resources acquired by this object.

Arguments:
    None

Return Value:
    None

--*/
{
    if(m_ipNamespace)
	{
        m_ipNamespace->Release();
		m_ipNamespace = NULL;
	}

    if(m_ipMicrosoftFrs_DfsMemberClassDef)
	{
        m_ipMicrosoftFrs_DfsMemberClassDef->Release();
		m_ipMicrosoftFrs_DfsMemberClassDef = NULL;
	}

    if(m_ipMicrosoftFrs_SysVolMemberClassDef)
	{
        m_ipMicrosoftFrs_SysVolMemberClassDef->Release();
		m_ipMicrosoftFrs_SysVolMemberClassDef = NULL;
	}

    if(m_ipMicrosoftFrs_DfsConnectionClassDef)
	{
        m_ipMicrosoftFrs_DfsConnectionClassDef->Release();
		m_ipMicrosoftFrs_DfsConnectionClassDef = NULL;
	}

    if(m_ipMicrosoftFrs_SysVolConnectionClassDef)
	{
        m_ipMicrosoftFrs_SysVolConnectionClassDef->Release();
		m_ipMicrosoftFrs_SysVolConnectionClassDef = NULL;
	}


    if(m_ipMicrosoftFrs_DfsMemberEventClassDef)
	{
        m_ipMicrosoftFrs_DfsMemberEventClassDef->Release();
		m_ipMicrosoftFrs_DfsMemberEventClassDef = NULL;
	}
}


//
// Methods for the IUnknown interface
//

ULONG CProvider::AddRef()
/*++
Routine Description:
    Increments the reference count of the object.

Arguments:
    None

Return Value:
    Current reference count. (> 0)

--*/
{
    return InterlockedIncrement((LONG *)&m_dwRef);
}

ULONG CProvider::Release()
/*++
Routine Description:
    Decrements the reference count of the object. Frees
    the object resource when the reference count becomes
    zero.

Arguments:
    None

Return Value:
    New reference count.
--*/
{
    ULONG dwRef = InterlockedDecrement((LONG *)&m_dwRef);
    if(dwRef == 0)
        delete this;
    return dwRef;
}


HRESULT CProvider::QueryInterface(REFIID riid, void** ppv)
/*++
Routine Description:
    This method is called by COM to obtain pointers to
    a given interface. The provider currently supports
    the IUnknown, IWbemProviderInit and the IWbemServices
    interface.

Arguments:
    riid : GUID of the required interface.
    ppv  : Pointer where the "interface pointer" is returned.

Return Value:
    Status of operation. Pointer to the requested interface
    is returned in *ppv.
--*/
{
    if(riid == IID_IUnknown || riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemServices)
    {
        *ppv = (IWbemServices *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemEventProvider)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//
// Methods for the IWbemProviderInit interface.
//

STDMETHODIMP CProvider::Initialize(
    IN LPWSTR pszUser,
    IN LONG lFlags,
    IN LPWSTR pszNamespace,
    IN LPWSTR pszLocale,
    IN IWbemServices *pNamespace,
    IN IWbemContext *pCtx,
    IN IWbemProviderInitSink *pInitSink
    )
/*++
Routine Description:

    This method is called to initialize the provider.
    We obtain the class defns of the classes we support
    from WMI by calling GetObject on the namespace pointer.

Arguments:

    wszUser : [in] Pointer to the user name, if per-user initialization was requested
    in the __Win32Provider registration instance for this provider. Otherwise, this
    will be NULL. Note that this parameter is set to NULL for Event (consumer)
    providers regardless of the value of PerUserInitialization.

    lFlags : [in] Reserved. It must be zero.

    wszNamespace : [in] Namespace name for which the provider is being initialized.

    wszLocale : [in] Locale name for which the provider is being initialized. This
    is typically a string of the following format, where the hex value is a
    Microsoft standard LCID value:  "MS_409". This parameter may be NULL.

    pNamespace : [in] An IWbemServices pointer back into Windows Management.
    This pointer is capable of servicing any requests made by the provider.
    The provider should use the IWbemProviderInit::AddRef method on this
    pointer if it is going to call back into Windows Management during its
    execution.

    pCtx : [in] An IWbemContext pointer associated with initialization. This
    parameter may be NULL. If the provider will make requests back into Windows
    Management before completing initialization, it should use the
    IWbemProviderInit::AddRef method on this pointer. For more information,
    see Making Calls to WMI.

    pInitSink : [in] An IWbemProviderInitSink pointer that is used by the provider
    to report initialization status.

Return Value:
    The provider should return WBEM_S_NO_ERROR and indicate its status using the
    supplied object sink in the pInitSink parameter. However, if a provider
    returns WBEM_E_FAILED and does not use the sink, then the provider
    initialization will be considered as failed.
--*/

{
    // WBEM_VALIDATE_INTF_PTR( pNamespace );
    // WBEM_VALIDATE_INTF_PTR( pCtx );
    // WBEM_VALIDATE_INTF_PTR( pInitSink );
    HRESULT res = WBEM_S_NO_ERROR;

    ODS(L"In Initialize().\n");

    //
    // Fill up our member variables.
    //
    m_ipNamespace = pNamespace;
    m_ipNamespace->AddRef();

    BSTR bstrObjectName = SysAllocString(L"MicrosoftFrs_DfsMember");

    res = m_ipNamespace->GetObject( bstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_ipMicrosoftFrs_DfsMemberClassDef,
                                    NULL );
    if(FAILED(res))
    {
        ODS(L"\nFailed to get ReplicaSetSummaryInfo class definition.\n");
        SysFreeString(bstrObjectName);
        m_ipNamespace->Release();
        return res;
    }

    SysReAllocString(&bstrObjectName, L"MicrosoftFrs_SysVolMember");
    res = m_ipNamespace->GetObject( bstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_ipMicrosoftFrs_SysVolMemberClassDef,
                                    NULL );
    if(FAILED(res))
    {
        ODS(L"\nFailed to get ReplicaSetSummaryInfo class definition.\n");
        SysFreeString(bstrObjectName);
        m_ipNamespace->Release();
        return res;
    }

    SysReAllocString(&bstrObjectName, L"MicrosoftFrs_DfsConnection");
    ODS(bstrObjectName);
    res = m_ipNamespace->GetObject( bstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_ipMicrosoftFrs_DfsConnectionClassDef,
                                    NULL );
    if(FAILED(res))
    {
        ODS(L"\nFailed to get InboundPartnerInfo class definition.\n");
        SysFreeString(bstrObjectName);
        m_ipNamespace->Release();
        return res;
    }

    SysReAllocString(&bstrObjectName, L"MicrosoftFrs_SysVolConnection");
    ODS(bstrObjectName);
    res = m_ipNamespace->GetObject( bstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_ipMicrosoftFrs_SysVolConnectionClassDef,
                                    NULL );
    if(FAILED(res))
    {
        ODS(L"\nFailed to get InboundPartnerInfo class definition.\n");
        SysFreeString(bstrObjectName);
        m_ipNamespace->Release();
        return res;
    }


    SysReAllocString(&bstrObjectName, L"MicrosoftFrs_DfsMemberEvent");
    res = m_ipNamespace->GetObject( bstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    pCtx,
                                    &m_ipMicrosoftFrs_DfsMemberEventClassDef,
                                    NULL );
    if(FAILED(res))
    {
        ODS(L"\nFailed to get MicrosoftFrs_DfsMemberEvent class definition.\n");
        SysFreeString(bstrObjectName);
        m_ipNamespace->Release();
        return res;
    }
    
	//
    // Let winmgmt know that we have initialized.
    //
    pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
    ODS(L"Completed IWbemProviderInit::Initialize() \n");
    return WBEM_S_NO_ERROR ;
    // return WBEM_E_FAILED;
}

STDMETHODIMP CProvider::GetObjectAsync(
    IN const BSTR bstrObjectPath,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler)
/*++
Routine Description:
    This method is called by WMI to obtain the instance
    of a given object. The requested instance is indicated
    to WMI using the pResponseHandler interface.

Arguments:
    strObjectPath : [in] Path of the object to retrieve. If this is NULL, an empty
    object, which can become a new class, is returned.

    lFlags : [in] Flags which affect the behavior of this method.

    pCtx : [in] Typically NULL. Otherwise, this is a pointer to an IWbemContext
    object that may be used by the provider producing the requested class or
    instance.

    pResponseHandler :[in] Pointer to the caller's implementation of IWbemObjectSink.
    This handler receives the requested object when it becomes available through the
    IWbemObjectSink::Indicate method.

Return Value:
    Status of operation.
--*/
{
 /*
    HRESULT hRes;

    // WBEM_VALIDATE_IN_STRING_PTR( bstrObjectPath );
    // TODO : check lFlags?
    // WBEM_VALIDATE_INTF_PTR( pCtx );
    // WBEM_VALIDATE_INTF_PTR( pResponseHandler );

    static LPCWSTR ROOTSTR_MEMBER =
        L"Microsoft_NtFrsMemberStatus.ReplicaSetGUID=\"";
    static LPCWSTR ROOTSTR_CONNECTION_LIST =
        L"Microsoft_NtFrsConnectionStatus.CompositeGUID=\"";

    ODS(L"In IWbemServices::GetObjectAsync()\n");

    //
    // First check whether the given path matches the summary info
    // object path.
    //
    int rootlen = lstrlen(ROOTSTR_MEMBER);

    if (lstrlen(bstrObjectPath) > rootlen &&
        0 == _wcsnicmp(bstrObjectPath, ROOTSTR_MEMBER, rootlen))
    {
        //
        // Extract the index/key by removing the prefix.
        //
        BSTR bstrIndexValue = SysAllocString(
            (const OLECHAR *)((BSTR)bstrObjectPath + rootlen));
        // remove trailing doublequote
        bstrIndexValue[lstrlen(bstrIndexValue)-1] = L'\0';

        hRes = EnumNtFrsMemberStatus(pCtx, pResponseHandler, bstrIndexValue );
        SysFreeString(bstrIndexValue);
        return hRes;
    }

    //
    // else  : check for the inbound partner info object path.
    //
    rootlen = lstrlen(ROOTSTR_CONNECTION_LIST);
    if (lstrlen(bstrObjectPath) > rootlen &&
        0 == _wcsnicmp(bstrObjectPath, ROOTSTR_CONNECTION_LIST, rootlen)
       )
    {
        // remove prefix
        BSTR bstrIndexValue = SysAllocString(
            (const OLECHAR *)((BSTR)bstrObjectPath + rootlen));
        // remove trailing doublequote
        bstrIndexValue[lstrlen(bstrIndexValue)-1] = L'\0';

        hRes = EnumNtFrsConnectionStatus( pCtx, pResponseHandler, bstrIndexValue );
        SysFreeString(bstrIndexValue);
        return hRes;
    }

    return WBEM_E_INVALID_OBJECT_PATH;
 */
    return WBEM_E_INVALID_OBJECT_PATH;
}


STDMETHODIMP CProvider::CreateInstanceEnumAsync(
    IN const BSTR bstrClass,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler)
/*++
Routine Description:
    This method is called by WMI to enumerate all instances
    of a given class. All the instances are indicated to WMI
    using the pResponseHandler interface.

Arguments:
    strObjectPath : [in] Name of the class whose instances are required.

    lFlags : [in] Flags which affect the behavior of this method.

    pCtx : [in] Typically NULL. Otherwise, this is a pointer to an IWbemContext
    object that may be used by the provider producing the requested class or
    instance.

    pResponseHandler :[in] Pointer to the caller's implementation of IWbemObjectSink.
    This handler receives the requested objects when it becomes available through the
    IWbemObjectSink::Indicate method.

Return Value:
    Status of operation.
--*/
{

    // WBEM_VALIDATE_IN_STRING_PTR( bstrClass );
    // TODO : check lFlags?
    // WBEM_VALIDATE_INTF_PTR( pCtx );
    // WBEM_VALIDATE_INTF_PTR( pResponseHandler );

    ODS(L"In IWbemServices::CreateInstanceEnumAsync().\n");

    if ( 0 == lstrcmp( bstrClass, L"MicrosoftFrs_DfsMember"))
    {
        return EnumNtFrsMemberStatus(pCtx, pResponseHandler );
    }
    else if ( 0 == lstrcmp( bstrClass, L"MicrosoftFrs_DfsConnection") )
    {
        return EnumNtFrsConnectionStatus( pCtx, pResponseHandler );
    }

    return WBEM_E_INVALID_OBJECT_PATH;

}

HRESULT CProvider::EnumNtFrsMemberStatus(
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue
        )
/*++
Routine Description:
    Enumerates all instances of the Microsoft_NtFrsMemberStatus
    class. Instances are indicated using the pResponseHandler
    interface.

Arguments:
    pCtx : [in] Typically NULL. Otherwise, this is a pointer to an IWbemContext
    object that may be used by the provider producing the requested class or
    instance.

    pResponseHandler : [in] Pointer to the caller's implementation of IWbemObjectSink.
    This handler receives the requested objects when it becomes available through the
    IWbemObjectSink::Indicate method.

    bstrFilterValue : [in] A filter which limits the returned instances to
    a subset of the actual instances. If NULL, all instances are returned.

Return Value:
    Status of operation.
--*/

{
#undef DEBSUB
#define DEBSUB  "CProvider::EnumNtFrsMemberStatus:"

    IWbemClassObject *pInstance;
    PVOID       Key;
    PREPLICA    Replica;
    VARIANT     var;
    WCHAR       GuidWStr[GUID_CHAR_LEN + 1];
    PWCHAR      TempStr = NULL;

    // WBEM_VALIDATE_INTF_PTR( pCtx );
    // WBEM_VALIDATE_INTF_PTR( pResponseHandler );
    // WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL( bstrFilterValue );

    HRESULT hRes = WBEM_S_NO_ERROR;

    ODS(L"Enumerating instances.\n");
    Key = NULL;
    while (Replica = (PREPLICA)GTabNextDatum(ReplicasByGuid, &Key)) {

        //
        // Spawn an instance of the Microsoft_NtFrsMemberStatus object.
        //
        if (Replica->ReplicaSetType != FRS_RSTYPE_DOMAIN_SYSVOL) {
            m_ipMicrosoftFrs_DfsMemberClassDef->SpawnInstance(0, &pInstance);
        } else {
            continue;
        }

        //
        // TODO : Fill in the members of this object.
        //

//        String          ReplicaSetGUID;
//
//        String          ReplicaSetName;
//        String          ReplicaMemberRoot;
//        String          ReplicaMemberStage;
//        String          FileFilter;
//        String          DirFilter;
//        String          ReplicaMemberState;
//        String          ReplicaSetType;


        //String          ReplicaSetGUID;
/*
        V_VT(&var) = VT_BSTR;

        GuidToStrW(Replica->ReplicaName->Guid, GuidWStr);
        V_BSTR(&var) = SysAllocString(GuidWStr);

        hRes = pInstance->Put( L"ReplicaSetGUID", 0, &var, 0 );
        VariantClear(&var);

        if(hRes != WBEM_S_NO_ERROR)
            break;


        //String          ReplicaSetName;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString(Replica->ReplicaName->Name);

        hRes = pInstance->Put( L"ReplicaSetName", 0, &var, 0 );
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;


        //String          ReplicaMemberRoot;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString(Replica->Root);

        hRes = pInstance->Put( L"ReplicaMemberRoot", 0, &var, 0 );
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;


        //String          ReplicaMemberStage;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString(Replica->Stage);

        hRes = pInstance->Put( L"ReplicaMemberStage", 0, &var, 0 );
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;


        //String          FileFilter;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString(Replica->FileFilterList);

        hRes = pInstance->Put( L"FileFilter", 0, &var, 0 );
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;


        //String          DirFilter;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString(Replica->DirFilterList);

        hRes = pInstance->Put( L"DirFilter", 0, &var, 0 );
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;

        //String          ReplicaMemberState;

        V_VT(&var) = VT_BSTR;
        TempStr = (PWCHAR)FrsAlloc((strlen(RSS_NAME(Replica->ServiceState)) + 1) * sizeof(WCHAR));
        wsprintf(TempStr, L"%hs", RSS_NAME(Replica->ServiceState));
        V_BSTR(&var) = SysAllocString(TempStr);
        hRes = pInstance->Put( L"ReplicaMemberState", 0, &var, 0 );
        TempStr = (PWCHAR)FrsFree(TempStr);
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;

        //String          ReplicaSetType;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = SysAllocString(FRS_RSTYPE_IS_SYSVOL(Replica->ReplicaSetType)?
                                      L"SYSVOL" : L"DFS");
        hRes = pInstance->Put( L"ReplicaSetType", 0, &var, 0 );
        VariantClear(&var);
        if(hRes != WBEM_S_NO_ERROR)
            break;

        // Default values for other fields.
*/
        //
        // Send the result to WMI.
        //
        hRes = pResponseHandler->Indicate(1, &pInstance);

        if(hRes != WBEM_S_NO_ERROR)
            break;

        pInstance->Release();

        // TODO : Optimize this by storing all the return objects
        // in an array and then indicating all the objects to
        // WMI in 1 shot.
    }

    //
    // Indicate to WMI that we are done.
    //
    ODS(L"Completed instance enumeration. Setting status.\n");
    pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hRes, NULL, NULL);
    ODS(L"Finished setting status. Returning from EnumNtFrsMemberStatus()\n");

    return hRes;
}

HRESULT CProvider::EnumNtFrsConnectionStatus(
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler,
    IN const BSTR bstrFilterValue)
/*++
Routine Description:
    Enumerates all instances of the Microsoft_NtFrsConnectionStatus
    class. Instances are indicated using the pResponseHandler
    interface.

Arguments:
    pCtx : [in] Typically NULL. Otherwise, this is a pointer to an IWbemContext
    object that may be used by the provider producing the requested class or
    instance.

    pResponseHandler : [in] Pointer to the caller's implementation of IWbemObjectSink.
    This handler receives the requested objects when it becomes available through the
    IWbemObjectSink::Indicate method.

    bstrFilterValue : [in] A filter which limits the returned instances to
    a subset of the actual instances. If NULL, all instances are returned.

Return Value:
    Status of operation.
--*/

{
#undef DEBSUB
#define DEBSUB  "CProvider::EnumNtFrsConnectionStatus:"

    IWbemClassObject *pInstance;
    PVOID       Key1;
    PVOID       Key2;
    PREPLICA    Replica;
    PCXTION     Cxtion;
    VARIANT     var;
    WCHAR       GuidWStr[GUID_CHAR_LEN + 1];
    CHAR        TimeStr[TIME_STRING_LENGTH];
    PWCHAR      TempStr = NULL;

    HRESULT hRes = WBEM_S_NO_ERROR;

    Key1 = NULL;
    while (Replica = (PREPLICA)GTabNextDatum(ReplicasByGuid, &Key1)) {
        if (Replica->Cxtions == NULL) {
            continue;
        }

        if (Replica->ReplicaSetType == FRS_RSTYPE_DOMAIN_SYSVOL) {
            continue;
        }

        Key2 = NULL;
        while (Cxtion = (PCXTION)GTabNextDatum(Replica->Cxtions, &Key2)) {

            if (Cxtion->JrnlCxtion == TRUE) {
                continue;
            }
            //
            // Spawn an instance of the Microsoft_NtFrsConnectionStatus object.
            //
            m_ipMicrosoftFrs_DfsConnectionClassDef->SpawnInstance(0, &pInstance);

            //
            // TODO : Fill in the members of this object.
            //
//            String          ReplicaSetGUID;

//            String          PartnerGUID;
//
//            String          ConnectionName;
//            String          ConnectionGUID;
//            String          PartnerDnsName;
//            String          ConnectionState;
//            DATETIME        LastJoinTime;
//            boolean         Inbound;
//
//            String          OBPartnerState;
//            uint32          OBPartnerLeadIndex
//            uint32          OBPartnerTrailIndex
//            uint32          OBPartnerOutstandingCOs
//            uint32          OBPartnerOutstandingQuota

/*
            //String          ReplicaSetGUID;

            if (Replica->ReplicaName != NULL) {
                V_VT(&var) = VT_BSTR;
                GuidToStrW(Replica->ReplicaName->Guid, GuidWStr);
                V_BSTR(&var) = SysAllocString(GuidWStr);

                hRes = pInstance->Put( L"ReplicaSetGUID", 0, &var, 0 );
                VariantClear(&var);

                if(hRes != WBEM_S_NO_ERROR)
                    break;
            }

            //String          PartnerGUID;


            if (Cxtion->Partner != NULL) {
                V_VT(&var) = VT_BSTR;
                GuidToStrW(Cxtion->Partner->Guid, GuidWStr);
                V_BSTR(&var) = SysAllocString(GuidWStr);

                hRes = pInstance->Put( L"PartnerGUID", 0, &var, 0 );
                VariantClear(&var);

                if(hRes != WBEM_S_NO_ERROR)
                    break;
            }


            //String          ConnectionName;

            if (Cxtion->Name != NULL) {
                V_VT(&var) = VT_BSTR;
                V_BSTR(&var) = SysAllocString(Cxtion->Name->Name);

                hRes = pInstance->Put( L"ConnectionName", 0, &var, 0 );
                VariantClear(&var);

                if(hRes != WBEM_S_NO_ERROR)
                    break;


                //String          ConnectionGUID;

                V_VT(&var) = VT_BSTR;
                GuidToStrW(Cxtion->Name->Guid, GuidWStr);
                V_BSTR(&var) = SysAllocString(GuidWStr);

                hRes = pInstance->Put( L"ConnectionGUID", 0, &var, 0 );
                VariantClear(&var);

                if(hRes != WBEM_S_NO_ERROR)
                    break;
            }




            //String          PartnerDnsName;

            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = SysAllocString(Cxtion->PartnerDnsName);

            hRes = pInstance->Put( L"PartnerDnsName", 0, &var, 0 );
            VariantClear(&var);
            if(hRes != WBEM_S_NO_ERROR)
                break;


            //String          ConnectionState;

            V_VT(&var) = VT_BSTR;
            TempStr = (PWCHAR)FrsAlloc((strlen(CxtionStateNames[Cxtion->State]) + 1) * sizeof(WCHAR));
            wsprintf(TempStr, L"%hs", CxtionStateNames[Cxtion->State]);
            V_BSTR(&var) = SysAllocString(TempStr);
            hRes = pInstance->Put( L"ConnectionState", 0, &var, 0 );
            TempStr = (PWCHAR)FrsFree(TempStr);
            VariantClear(&var);
            if(hRes != WBEM_S_NO_ERROR)
                break;


            //String          LastJoinTime;

            V_VT(&var) = VT_BSTR;
            FileTimeToString((PFILETIME) &Cxtion->LastJoinTime, TimeStr);
            TempStr = (PWCHAR)FrsAlloc((strlen(TimeStr) + 1) * sizeof(WCHAR));
            wsprintf(TempStr, L"%hs", TimeStr);
            V_BSTR(&var) = SysAllocString(TempStr);
            hRes = pInstance->Put( L"LastJoinTime", 0, &var, 0 );
            TempStr = (PWCHAR)FrsFree(TempStr);
            VariantClear(&var);
            if(hRes != WBEM_S_NO_ERROR) {
                break;
            }


            //boolean          Inbound;

            V_VT(&var) = VT_BOOL;
            V_BOOL(&var) = (Cxtion->Inbound)? VARIANT_TRUE : VARIANT_FALSE ;
            hRes = pInstance->Put( L"Inbound", 0, &var, 0 );
            VariantClear(&var);
            if(hRes != WBEM_S_NO_ERROR)
                break;


            if (Cxtion->Inbound == FALSE && Cxtion->OLCtx != NULL) {
                //String          OBPartnerState;

                V_VT(&var) = VT_BSTR;
                TempStr = (PWCHAR)FrsAlloc((strlen(OLPartnerStateNames[Cxtion->OLCtx->State]) + 1) * sizeof(WCHAR));
                wsprintf(TempStr, L"%hs", OLPartnerStateNames[Cxtion->OLCtx->State]);
                V_BSTR(&var) = SysAllocString(TempStr);
                hRes = pInstance->Put( L"OBPartnerState", 0, &var, 0 );
                TempStr = (PWCHAR)FrsFree(TempStr);
                VariantClear(&var);
                if(hRes != WBEM_S_NO_ERROR)
                    break;


                //uint32          OBPartnerleadIndex;

                V_VT(&var) = VT_I4;
                V_I4(&var) = Cxtion->OLCtx->COLx;
                hRes = pInstance->Put( L"OBPartnerLeadIndex", 0, &var, 0 );
                VariantClear(&var);
                if(hRes != WBEM_S_NO_ERROR)
                    break;


                //uint32          OBPartnerTrailIndex;

                V_VT(&var) = VT_I4;
                V_I4(&var) = Cxtion->OLCtx->COTx;
                hRes = pInstance->Put( L"OBPartnerTrailIndex", 0, &var, 0 );
                VariantClear(&var);
                if(hRes != WBEM_S_NO_ERROR)
                    break;


                //uint32          OBPartnerOutstandingCOs;

                V_VT(&var) = VT_I4;
                V_I4(&var) = Cxtion->OLCtx->OutstandingCos;
                hRes = pInstance->Put( L"OBPartnerOutstandingCOs", 0, &var, 0 );
                VariantClear(&var);
                if(hRes != WBEM_S_NO_ERROR)
                    break;


                //uint32          OBPartnerOutstandingQuota;

                V_VT(&var) = VT_I4;
                V_I4(&var) = Cxtion->OLCtx->OutstandingQuota;
                hRes = pInstance->Put( L"OBPartnerOutstandingQuota", 0, &var, 0 );
                VariantClear(&var);
                if(hRes != WBEM_S_NO_ERROR)
                    break;

            }
*/
            //
            // Send the result to WMI.
            //
            hRes = pResponseHandler->Indicate(1, &pInstance);


            if(hRes != WBEM_S_NO_ERROR)
                break;

            pInstance->Release();

        }
    }

    //
    // Indicate to WMI that we are done.
    //
    ODS(L"Completed instance enumeration. Setting status.\n");
    pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hRes, NULL, NULL);
    ODS(L"Finished setting status. Returning from EnumNtFrsMemberStatus()\n");

    return hRes;
}

//
// IWbemEventProvider interface
//

STDMETHODIMP CProvider::ProvideEvents( 
			IWbemObjectSink __RPC_FAR *pSink,
			long lFlags )
{
	ODS(L"IwbemEventProvider::ProvideEvents() called.\n");

	pSink->AddRef();
	m_pEventSink = pSink;

	return WBEM_S_NO_ERROR;
}


//
// TODO : TO send events to the collector, construct an instance of
// the required class and then call CProvider::m_pEventSink->Indicate();
//
// Note that the any objects sent as an event must be derived from
// the class __ExtrinsicEvent.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

UNICODE=1

SDKINC = $(SDK_INC_PATH)
SDKCRTINC = $(CRT_INC_PATH)
PRIVINC = $(DS_INC_PATH)

INCS = -I$(SDKINC) -I$(SDKCRTINC) -I$(PRIVINC) -I..\inc

EXTRN_DEPENDS = $(SDKINC)\winbase.h \
                $(SDKINC)\windef.h

NET_C_DEFINES= -DMIDL_PASS -DINCL_32= -DNT -DRPC_NO_WINDOWS_H
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"


BINPLACE_CMD= -binplace

#
# Define Products and Dependencies
#

all: binplace

binplace:
        $(BINPLACE_CMD) ..\perfdll\ntfrsrep.ini
        $(BINPLACE_CMD) ..\perfdll\ntfrsrep.h
        $(BINPLACE_CMD) ..\perfdll\ntfrscon.ini
        $(BINPLACE_CMD) ..\perfdll\ntfrscon.h

#
# MIDL COMPILE
#

#
# SERVICE RPC
#
$(O)\frsrpc.h \
$(O)\frsrpc_c.c \
$(O)\frsrpc_s.c \ : .\frsrpc.idl .\frsrpc.acf $(EXTRN_DEPENDS)
    midl \
            $(MIDL_OPTIMIZATION)     \
            -oldnames                \
            -error ref               \
            -ms_ext                  \
            -c_ext $(CPP)            \
            -prefix server "SERVER_" \
            -acf .\frsrpc.acf        \
            -out .\$(O)              \
            $(INCS)                  \
                .\frsrpc.idl

#
# API RPC
#
$(O)\frsapi.h \
$(O)\frsapi_c.c \
$(O)\frsapi_s.c \ : .\frsapi.idl .\frsapi.acf $(EXTRN_DEPENDS)
    midl \
            $(MIDL_OPTIMIZATION) \
            -oldnames            \
            -error ref           \
            -ms_ext              \
            -c_ext $(CPP)        \
            -acf .\frsapi.acf    \
            -out .\$(O)          \
            $(INCS)              \
                .\frsapi.idl

#
# PERFMON RPC
#
$(O)\perffrs.h \
$(O)\perffrs_c.c \
$(O)\perffrs_s.c \ : .\perffrs.idl .\perffrs.acf $(EXTRN_DEPENDS)
    midl \
            $(MIDL_OPTIMIZATION) \
            -oldnames            \
            -error ref           \
            -ms_ext              \
            -c_ext $(CPP)        \
            -acf .\perffrs.acf   \
            -out .\$(O)          \
            $(INCS)              \
                .\perffrs.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frswmipv\frswmipv.h ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frs.h

Abstract:
    This header contains the definition of the CProvider and the CFactory
    classes. It also includes WMI related declarations relevant to NTFRS.

Author:
    Sudarshan Chitre (sudarc) , Mathew George (t-mattg) -  3-Aug-2000
--*/

#ifndef __PROVIDER_H_
#define __PROVIDER_H_
/*
#include <windows.h>
#include <objbase.h>
#include <comdef.h>
#include <initguid.h>
#include <wbemcli.h>
#include <wbemidl.h>

#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <tchar.h>
*/

#include <wbemcli.h>
#include <wbemidl.h>
#include <tchar.h>


extern const CLSID CLSID_Provider;

#define ODS OutputDebugString
//#define ODS

extern "C" {
DWORD FrsWmiInitialize();
DWORD FrsWmiShutdown();
}

//
// Class definitions
//


class CProvider :	public IWbemProviderInit,
					public IWbemServices,
					public IWbemEventProvider
{
public:

    CProvider();
    ~CProvider();

    //
    // Interface IUnknown
    //
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    //
    // Interface IWbemProviderInit
    //
    STDMETHOD(Initialize)(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink
         );

	//
	// Interface IWbemEventProvider
	//

	// +++++++ Implemented +++++++++

	STDMETHOD(ProvideEvents)( 
			IWbemObjectSink __RPC_FAR *pSink,
			long lFlags
			);

    //
    // Interface IWbemServices
    //

    // +++++++ Implemented +++++++

    STDMETHOD(GetObjectAsync)(
        IN const BSTR bstrObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);

    STDMETHOD(CreateInstanceEnumAsync)(
        IN const BSTR bstrClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);

    // --- NOT Implemented ---

    STDMETHOD(OpenNamespace)(
        IN const BSTR strNamespace,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemServices **ppWorkingNamespace,
        IN OUT IWbemCallResult **ppResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(CancelAsyncCall)(
        IN IWbemObjectSink *pSink)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(QueryObjectSink)(
        IN long lFlags,
        OUT IWbemObjectSink **ppResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(GetObject)(
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemClassObject **ppObject,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(PutClass)(
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(PutClassAsync)(
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(DeleteClass)(
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(DeleteClassAsync)(
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(CreateClassEnum)(
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(CreateClassEnumAsync)(
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(PutInstance)(
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(PutInstanceAsync)(
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(DeleteInstance)(
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(DeleteInstanceAsync)(
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(CreateInstanceEnum)(
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(ExecQuery)(
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(ExecQueryAsync)(
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(ExecNotificationQuery)(
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(ExecNotificationQueryAsync)(
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(ExecMethod)(
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN OUT IWbemClassObject **ppOutParams,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };

    STDMETHOD(ExecMethodAsync)(
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };


protected:

    //
    // Place my own methods right here !
    //
    HRESULT CProvider::EnumNtFrsMemberStatus(
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue = NULL
        );

    HRESULT CProvider::EnumNtFrsConnectionStatus(
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrFilterValue = NULL
        );

    //
    // Member variables.
    //
    IWbemServices *m_ipNamespace;
    IWbemClassObject *m_ipMicrosoftFrs_DfsMemberClassDef;
    IWbemClassObject *m_ipMicrosoftFrs_SysVolMemberClassDef;
    IWbemClassObject *m_ipMicrosoftFrs_DfsConnectionClassDef;
    IWbemClassObject *m_ipMicrosoftFrs_SysVolConnectionClassDef;
	
	// Event class definitions. (sample)
	IWbemClassObject *m_ipMicrosoftFrs_DfsMemberEventClassDef;

	IWbemObjectSink *m_pEventSink;	// Event sink.

    int m_NumReplicaSets;
    ULONG m_dwRef;

};


class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};


#endif //__PROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\frswmipv\frscomsv.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    server.cpp

Abstract:
    This is the implementation of the class factory for the NTFRS WMI provider.
    This file contains the implementation of the CFactory class and other
    global initialization functions relating to the provider.

Author:
    Sudarshan Chitre (sudarc) , Mathew George (t-mattg) -  3-Aug-2000

Environment
    User mode winnt

--*/

#include <frswmipv.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

//DEFINE_GUID(CLSID_Provider,
//            0x39143F73,0xFDB1,0x4CF5,0x8C,0xB7,0xC8,0x43,0x9E,0x3F,0x5C,0x20);

const CLSID CLSID_Provider = {0x39143F73,0xFDB1,0x4CF5,0x8C,0xB7,0xC8,0x43,0x9E,0x3F,0x5C,0x20};

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////

static DWORD dwRegId;
static IClassFactory *pClassFactory = NULL;
static ULONG g_cLock = 0;

//
// Routines to update registry when installing/uninstalling our server.
//

void RegisterServer()
{
    return;
}

void UnregisterServer()
{
    return;
}

//
// Implementation of the IClassFactory interface.
//


CFactory::CFactory(const CLSID & ClsId)
/*++
Routine Description:
    Constructor for the class factory.

Arguments:
    ClsId : [in] CLSID of the server object which it creates when the
    CreateInstance method is called.

Return Value:
    None

--*/

{
    m_cRef = 0;
    g_cLock++;
    m_ClsId = ClsId;
}

CFactory::~CFactory()
/*++
Routine Description:
    Destructor for the class factory.

Arguments:
    None.

Return Value:
    None

--*/
{
    g_cLock--;
}

// Implementation of the IUnknown interface

ULONG CFactory::AddRef()
/*++
Routine Description:
    Increments the reference count of the object.

Arguments:
    None

Return Value:
    Current reference count. (> 0)

--*/
{
    return ++m_cRef;
}


ULONG CFactory::Release()
/*++
Routine Description:
    Decrements the reference count of the object. Frees
    the object resource when the reference count becomes
    zero.

Arguments:
    None

Return Value:
    New reference count.
--*/
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;

    return 0;
}

STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
/*++
Routine Description:
    This method is called by COM to obtain pointers to
    the IUnknown or the IClassFactory interface.

Arguments:
    riid : GUID of the required interface.
    ppv  : Pointer where the "interface pointer" is returned.

Return Value:
    Status of operation. Pointer to the requested interface
    is returned in *ppv.
--*/
{
    *ppv = 0;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
/*++
Routine Description:
    Constructs an instance of the CProvider object and returns
    a pointer to the IUnknown interface.

Arguments:
    pUnkOuter : [in] IUnknown of the aggregrator. We do not
    support aggregration, and so this parameter should be null.

    riid : [in] GUID of the object to be instantiated.

    ppv  : Destination for the IUnknown interface pointer.

Return Value:
    Status of operation. Pointer to the IUnknown interface of the
    requested object is returned in *ppv.

    S_OK                        Success
    CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
    E_NOINTERFACE               No such interface supported.

--*/
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = E_OUTOFMEMORY;

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    if (m_ClsId == CLSID_Provider)
    {
        pObj = (IWbemProviderInit *) new CProvider;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}


STDMETHODIMP CFactory::LockServer(BOOL fLock)
/*++
Routine Description:
    Increments.Decrements the reference count of the server, so that
    resource can be deallocated when all instances of all objects
    provided by ther server are destroyed.

Arguments:
    fLock : [in] Boolean indicating whether the refcount is to
    be incremented or decremented.

Return Value:
    Status of the operation.
--*/
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}


DWORD FrsWmiInitialize()
/*++
Routine Description:
    Main entry point to the WMI subsystem of NTFRS. This function
    initializes the COM libraries, initializes security and
    registers our class factory with COM.
    NOTE : The thread which calls this function should not
    terminate until the FrsWmiShutdown() function is called.

Arguments:
    None.

Return Value:
    Status of the operation.
--*/
{

    HRESULT hRes;

    // Initialize the COM library.
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hRes))
        return hRes;


    // Initialize COM security.
    hRes = CoInitializeSecurity (
            NULL,                           //Points to security descriptor
            -1,                             //Count of entries in asAuthSvc
            NULL,                           //Array of names to register
            NULL,                           //Reserved for future use
            RPC_C_AUTHN_LEVEL_CONNECT,      //The default authentication level for proxies
            RPC_C_IMP_LEVEL_IMPERSONATE,    //The default impersonation level for proxies
            NULL,                           //Authentication information for
                                            //each authentication service
            EOAC_DYNAMIC_CLOAKING,          //Additional client and/or
                                            // server-side capabilities
            0                               //Reserved for future use
        );

    if(FAILED(hRes))
    {
        CoUninitialize() ;
        return hRes;
    }

    // Get a pointer to our class factory.
    pClassFactory = new CFactory(CLSID_Provider);
    pClassFactory->AddRef();

    // Register our server with COM.
    CoRegisterClassObject(CLSID_Provider, pClassFactory,
        CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE, &dwRegId);

    return ERROR_SUCCESS;
}

DWORD FrsWmiShutdown()
/*++
Routine Description:
    Shuts down the WMI subsystem within FRS, releases & and deregisters the
    class factory, unloads the COM libraries and free any other allocated
    resource.

Arguments:
    None.

Return Value:
    Status of the operation.
--*/
{
    //
    // Shutdown the server
    //
    pClassFactory->Release();
    CoRevokeClassObject(dwRegId);
    CoUninitialize();
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\debug.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    debug.c

Abstract:
    This header file defines data structures and macros related to internal
    FRS monitoring and activity logging.  The activity log is always present
    but the amount of information placed in the log can be controlled by a
    severity level parameter.  See below.

    In addition, FRS contains constraint checks throughout the code using the
    FRS_ASSERT() macro.  FRS follows a "Fail Fast" model for failure recovery.
    If the constraint is not satisfied FRS places an entry in the event log
    and abruptly shuts down.  The objective is to minimize the likelyhood that
    continued execution will propagate invalid state into the FRS database.
    The WIN2K Service Controller is set to automatically restart FRS after a
    short delay.

Author:
    David A. Orbits  20-Mar-1997


--*/



// Guidelines for Severity Level Use in DPRINT():
//
// 0 - Most severe, eg. fatal inconsistency, mem alloc fail. Least noisey.
// 1 - Important info, eg. Key config parameters, unexpected conditions
// 2 -
// 3 - Change Order Process trace records.
// 4 - Status results, e.g. table lookup failures, new entry inserted
// 5 - Information level messages to show flow.  Noisest level. Maybe in a loop
//

/*  Debug output macros

    This is a simple debugging package for generating conditional
    printf output.

    AT RUN-TIME

    There are 2 run-time options:

    1 - A list of subsystems to be debugged.  Either a list of subsystem
        names delimited by a ":" or an "*" which means debug all
        (e.g. sub1:sub2: Sub3:).  (Names are case sensitive and spaces
        between names are ignored.)

    2 - A severity level (1-5) that indicates the level of detailed
        information to be produced.  (The higher the level, the more
        data produced.


    AT COMPILE-TIME

    Compile with the /DDBG=1 option to define the preprocessor variable
    DBG to 1.  This will generate debug source code.  For customer shipment,
    set /DDBG=0 and all debug code will be removed.  (Actually a
    ";" will be generated.)


    AT CODE-TIME

    1 - Include the DEBUG.H header at the top of your source listing.

    2 - #DEFINE DEBSUB to contain the name (a string delimited by a ":") of
        the software subsystem contained in this source (e.g. #define DEBSUB
        "MySub:") (You could optionally redefine DEBSUB for each function in
        your source to give you function-level debugging.)

    3 - Invoke the DEBUGINIT macro that calls the Debug function before any
        source debug statements are executed.  This funciton prompts STDIN for
        the user specified run-time options.  (Alternatively you could
        hardcode your own assignment of the DebugInfo data structure which
        holds the run-time options.)

    4 - Everywhere you want to a printf for debugging, put a DPRINT statement
        instead and specify a severity level with the statement.  The
        statement will be printed if the severity is this level or higher
        (assuming that the subsystem is to be debugged).  The severity level
        allows for different amounts of output to be generated if problem
        is very bad.

    For example, a severity of 1 DPRINT statement might just indicate that
    a certain function was entered while a severity of 5 might print
    information that is inside a tight loop.

    (Actually there are 6 DPRINT statements provided depending on the
    number of printf arguments.)


    NOTE

    All printf's are surrounded by semaphores.  Be careful not to invoke
    routines as parms to printf because you can have a deadlock situation.


    EXAMPLE PROGRAM

    **   include "debug.h"
    **   include "string.h"
    **
    **   #define DEBSUB "sub1:"
    **
    **   main()
    **   {
    **       DEBUGINIT;
    **
    **       DPRINT(4,"this is a sub1 debug of 4\n");
    **       DPRINT(1,"this is a sub1 debug of 1\n");
    **   }

*/


#ifndef _debug_h_
#define _debug_h_

#ifdef __cplusplus
extern "C" {
#endif


// <DebugInfo>, of type DEBUGARG, contains the debug run-time settings.
//
// DebSubSystems contains a list of subsystem names to be debugged
// delimited by ":".  An "*" found in this array indicates that all
// subsystems are to be debugged.
//
// The severity indicates the amount of debug information to be produced.
// The higher the severity the more data that will be dumped.
//
// A specific thread can be traced by entering its ID.  An id of 0 means all.
//

typedef struct _DEBUGARG {
    ULONG               Severity;       // 1 - 5 on stdout
    PCHAR               Systems;        // subsystem to debug
    ULONG               ThreadId;       // thread id to debug (0 = All)
    BOOL                Disabled;       // debugging has been disabled
    BOOL                Suppress;       // suppress debug print
    BOOL                DisableCompression;   // Enable support for compression.
    BOOL                ReclaimStagingSpace;  // Disable reclaiming of staging space.
    BOOL                SaveOutlogChangeHistory; // To disable Saving COs in outlog longer than needed.
    BOOL                SuppressIdenticalUpdt; // Suppress updates that do not change the content.
    BOOL                EnableRenameUpdates;   // Force use of pre-install file and final rename on all updates.
    BOOL                EnableInstallOverride; // Allow rename of file targets when target is write locked.
    ULONG               OutlogChangeHistory;  // How long to keep changes in the outlog.
    ULONG               LogSeverity;    // 1 - 5 on log file
    ULONG               MaxLogLines;    // max dprint log lines
    ULONG               LogLines;       // current dprint lines logged
    ULONG               TotalLogLines;  // total dprint lines logged
    PWCHAR              LogFile;        // dprint log file
    PWCHAR              LogDir;         // dprint log directory.
    HANDLE              LogFILE;       // open log file stream
    ULONG               Interval;       // scheduling interval
    BOOL                TestFid;        // enable the rename-fid tests
    PCHAR               Recipients;     // email recipients
    PCHAR               Profile;        // email profile
    PCHAR               BuildLab;       // Build lab ID string from registry.
    PWCHAR              AssertShare;    // share to copy assert files
    BOOL                CopyLogs;       // copy logs into assert share
    ULONG               AssertFiles;    // number of assert files
    ULONG               LogFiles;       // number of log files
    BOOL                PrintStats;     // Print stats at DebUnLock()
    BOOL                PrintingStats;  // Currently printing stats
    ULONG               RestartSeconds; // Must run this long for restart
    BOOL                Restart;        // restart on assertion failure
    ULONGLONG           StartSeconds;   // start time in seconds
    PWCHAR              CommandLine;    // Original command line
    BOOL                Break;          // Break into the debugger on assert
    ULONG               AssertSeconds;  // assert after this many seconds
    BOOL                VvJoinTests;    // enable VvJoin Tests
    ULONG               Tests;          // Enable random tests
    ULONG               UnjoinTrigger;  // unjoin trigger
    LONG                FetchRetryTrigger;    // fetch retry trigger
    LONG                FetchRetryReset;      // fetch retry trigger reset
    LONG                FetchRetryInc;        // fetch retry trigger reset inc
    BOOL                ForceVvJoin;    // force vvjoin at every true join
    BOOL                Mem;            // Check memory allocations/frees
    BOOL                MemCompact;     // Compact mem at every free
    BOOL                Queues;         // Check queues
    BOOL                EnableJrnlWrapAutoRestore; // Automatic Restore on Journal Wrap?
    DWORD               DbsOutOfSpace;        // Create REAL out of space errors on DB
    DWORD               DbsOutOfSpaceTrigger; // dummy out-of-space error
    LONG                LogFlushInterval;     // Flush the log every n lines.
    PCHAR               TestCodeName;         // Name string for test code to run
    ULONG               TestSubCodeNumber;    // ID number for sub test
    ULONG               TestTriggerCount;     // Trigger test when count goes from 0 to 1.
    ULONG               TestTriggerRefresh;   // Trigger count refresh value when count goes from 0 to 1.
    CRITICAL_SECTION    DbsOutOfSpaceLock;    // lock for out-of-space tests
    CRITICAL_SECTION    Lock;           // single thread semaphore
} DEBUGARG, *PDEBUGARG;

#define DBG_DBS_OUT_OF_SPACE_OP_NONE   (0)     // no out of space errors
#define DBG_DBS_OUT_OF_SPACE_OP_CREATE (1)     // out of space error during create
#define DBG_DBS_OUT_OF_SPACE_OP_DELETE (2)     // out of space error during delete
#define DBG_DBS_OUT_OF_SPACE_OP_WRITE  (3)     // out of space error during write
#define DBG_DBS_OUT_OF_SPACE_OP_REMOVE (4)     // out of space error during remove
#define DBG_DBS_OUT_OF_SPACE_OP_MULTI  (5)     // out of space error during multi
#define DBG_DBS_OUT_OF_SPACE_OP_MAX    (5)     // Max value for param

extern DEBUGARG DebugInfo;


//
// forward declare actual functions used by DPRINT's
//
VOID
DebLock(
    VOID
    );

VOID
DebUnLock(
    VOID
    );

VOID
DebPrintNoLock(
    IN ULONG,
    IN BOOL,
    IN PUCHAR,
    IN PCHAR,
    IN UINT,
    ...
    );

VOID
DebPrintTrackingNoLock(
    IN ULONG   Sev,
    IN PUCHAR  Str,
    IN ... );

VOID
DebPrint(
    IN ULONG,
    IN PUCHAR,
    IN PCHAR,
    IN UINT,
    ...
    );

BOOL
DoDebug(
    IN ULONG,
    IN PUCHAR
    );

//
// These are used instead of printf statements.  Semaphores surround the
// printf and all output is provided by the subsystem.
//
#define DPRINT(_sev_,str)                     \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__)

#define DPRINT1(_sev_, str,p1)                \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1 )

#define DPRINT2(_sev_, str,p1,p2)             \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1, p2 )

#define DPRINT3(_sev_, str,p1,p2,p3)          \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3 )

#define DPRINT4(_sev_, str,p1,p2,p3,p4)       \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4 )

#define DPRINT5(_sev_, str,p1,p2,p3,p4,p5)    \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5 )

#define DPRINT6(_sev_, str,p1,p2,p3,p4,p5,p6) \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6 )

#define DPRINT7(_sev_, str,p1,p2,p3,p4,p5,p6,p7) \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1,p2,p3,p4,p5,p6,p7)

#define DPRINT8(_sev_, str,p1,p2,p3,p4,p5,p6,p7,p8) \
         DebPrint((_sev_), (PUCHAR)str, DEBSUB, __LINE__, p1,p2,p3,p4,p5,p6,p7,p8 )



#define DPRINT_NOLOCK(_sev_, str)                    \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__)

#define DPRINT_NOLOCK1(_sev_, str,p1)                \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__, p1 )

#define DPRINT_NOLOCK2(_sev_, str,p1,p2)             \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__, p1, p2 )

#define DPRINT_NOLOCK3(_sev_, str,p1,p2,p3)          \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3 )

#define DPRINT_NOLOCK4(_sev_, str,p1,p2,p3,p4)       \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4 )

#define DPRINT_NOLOCK5(_sev_, str,p1,p2,p3,p4,p5)    \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5 )

#define DPRINT_NOLOCK6(_sev_, str,p1,p2,p3,p4,p5,p6) \
         DebPrintNoLock((_sev_), TRUE, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6 )


//
// DPRINT_FS(sev, "display text", FStatus)
//
#define DPRINT_FS(_sev_, _str, _fstatus)                         \
         if (!FRS_SUCCESS(_fstatus)) {                           \
             DebPrint((_sev_),                                   \
                      (PUCHAR)(_str "  FStatus: %s\n"),          \
                      DEBSUB, __LINE__, ErrLabelFrs(_fstatus) ); \
         }

#define DPRINT1_FS(_sev_, _str, _p1, _fstatus)                        \
         if (!FRS_SUCCESS(_fstatus)) {                                \
             DebPrint((_sev_),                                        \
                      (PUCHAR)(_str "  FStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelFrs(_fstatus) ); \
         }

#define DPRINT2_FS(_sev_, _str, _p1, _p2, _fstatus)                        \
         if (!FRS_SUCCESS(_fstatus)) {                                     \
             DebPrint((_sev_),                                             \
                      (PUCHAR)(_str "  FStatus: %s\n"),                    \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelFrs(_fstatus) ); \
         }

#define DPRINT3_FS(_sev_, _str, _p1, _p2, _p3, _fstatus)                        \
         if (!FRS_SUCCESS(_fstatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  FStatus: %s\n"),                         \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ErrLabelFrs(_fstatus) ); \
         }

#define DPRINT4_FS(_sev_, _str, _p1, _p2, _p3, _p4, _fstatus)                       \
         if (!FRS_SUCCESS(_fstatus)) {                                              \
             DebPrint((_sev_),                                                      \
                      (PUCHAR)(_str "  FStatus: %s\n"),                             \
                      DEBSUB, __LINE__, _p1, _p2, _p3, _p4, ErrLabelFrs(_fstatus)); \
         }

//
// CLEANUP_FS(sev, "display text", FStatus, branch_target)
//   Like DPRINT but takes a branch target as last arg if success test fails.
//
#define CLEANUP_FS(_sev_, _str, _fstatus, _branch)               \
         if (!FRS_SUCCESS(_fstatus)) {                           \
             DebPrint((_sev_),                                   \
                      (PUCHAR)(_str "  FStatus: %s\n"),          \
                      DEBSUB, __LINE__, ErrLabelFrs(_fstatus) ); \
             goto _branch;                                       \
         }

#define CLEANUP1_FS(_sev_, _str, _p1, _fstatus, _branch)              \
         if (!FRS_SUCCESS(_fstatus)) {                                \
             DebPrint((_sev_),                                        \
                      (PUCHAR)(_str "  FStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelFrs(_fstatus) ); \
             goto _branch;                                            \
         }

#define CLEANUP2_FS(_sev_, _str, _p1, _p2, _fstatus, _branch)              \
         if (!FRS_SUCCESS(_fstatus)) {                                     \
             DebPrint((_sev_),                                             \
                      (PUCHAR)(_str "  FStatus: %s\n"),                    \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelFrs(_fstatus) ); \
             goto _branch;                                                 \
         }

#define CLEANUP3_FS(_sev_, _str, _p1, _p2, _p3, _fstatus, _branch)              \
         if (!FRS_SUCCESS(_fstatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  FStatus: %s\n"),                         \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ErrLabelFrs(_fstatus) ); \
             goto _branch;                                                      \
         }

#define CLEANUP4_FS(_sev_, _str, _p1, _p2, _p3, _p4, _fstatus, _branch)              \
         if (!FRS_SUCCESS(_fstatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  FStatus: %s\n"),                         \
                      DEBSUB, __LINE__, _p1, _p2, _p3, _p4, ErrLabelFrs(_fstatus) ); \
             goto _branch;                                                      \
         }


//
// DPRINT_WS(sev, "display text", WStatus)
//
#define DPRINT_WS(_sev_, _str, _wstatus)                         \
         if (!WIN_SUCCESS(_wstatus)) {                           \
             DebPrint((_sev_),                                   \
                      (PUCHAR)(_str "  WStatus: %s\n"),          \
                      DEBSUB, __LINE__, ErrLabelW32(_wstatus) ); \
         }

#define DPRINT1_WS(_sev_, _str, _p1, _wstatus)                        \
         if (!WIN_SUCCESS(_wstatus)) {                                \
             DebPrint((_sev_),                                        \
                      (PUCHAR)(_str "  WStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelW32(_wstatus) ); \
         }


#define DPRINT1_WS_NOLOCK(_sev_, _str, _p1, _wstatus)                        \
         if (!WIN_SUCCESS(_wstatus)) {                                \
             DebPrintNoLock((_sev_),                                  \
                      TRUE,                                           \
                      (PUCHAR)(_str "  WStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelW32(_wstatus) ); \
         }

#define DPRINT2_WS(_sev_, _str, _p1, _p2, _wstatus)                        \
         if (!WIN_SUCCESS(_wstatus)) {                                     \
             DebPrint((_sev_),                                             \
                      (PUCHAR)(_str "  WStatus: %s\n"),                    \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelW32(_wstatus) ); \
         }

#define DPRINT3_WS(_sev_, _str, _p1, _p2, _p3, _wstatus)                        \
         if (!WIN_SUCCESS(_wstatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  WStatus: %s\n"),                         \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ErrLabelW32(_wstatus) ); \
         }

#define DPRINT4_WS(_sev_, _str, _p1, _p2, _p3, _p4, _wstatus)                        \
         if (!WIN_SUCCESS(_wstatus)) {                                               \
             DebPrint((_sev_),                                                       \
                      (PUCHAR)(_str "  WStatus: %s\n"),                              \
                      DEBSUB, __LINE__, _p1, _p2, _p3, _p4, ErrLabelW32(_wstatus) ); \
         }


//
// CLEANUP_WS(sev, "display text", wstatus, branch_target)
//   Like DPRINT but takes a branch target as last arg if success test fails.
//

#define CLEANUP_WS(_sev_, _str, _wstatus, _branch)               \
         if (!WIN_SUCCESS(_wstatus)) {                           \
             DebPrint((_sev_),                                   \
                      (PUCHAR)(_str "  WStatus: %s\n"),          \
                      DEBSUB, __LINE__, ErrLabelW32(_wstatus) ); \
             goto _branch;                                       \
         }

#define CLEANUP1_WS(_sev_, _str, _p1, _wstatus, _branch)              \
         if (!WIN_SUCCESS(_wstatus)) {                                \
             DebPrint((_sev_),                                        \
                      (PUCHAR)(_str "  WStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelW32(_wstatus) ); \
             goto _branch;                                            \
         }

#define CLEANUP2_WS(_sev_, _str, _p1, _p2, _wstatus, _branch)              \
         if (!WIN_SUCCESS(_wstatus)) {                                     \
             DebPrint((_sev_),                                             \
                      (PUCHAR)(_str "  WStatus: %s\n"),                    \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelW32(_wstatus) ); \
             goto _branch;                                                 \
         }

#define CLEANUP3_WS(_sev_, _str, _p1, _p2, _p3, _wstatus, _branch)              \
         if (!WIN_SUCCESS(_wstatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  WStatus: %s\n"),                         \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ErrLabelW32(_wstatus) ); \
             goto _branch;                                                      \
         }


//
// DPRINT_NT(sev, "display text", Nttatus)
//
#define DPRINT_NT(_sev_, _str, _NtStatus)                         \
         if (!NT_SUCCESS(_NtStatus)) {                            \
             DebPrint((_sev_),                                    \
                      (PUCHAR)(_str "  NTStatus: %s\n"),          \
                      DEBSUB, __LINE__, ErrLabelNT(_NtStatus) );  \
         }

#define DPRINT1_NT(_sev_, _str, _p1, _NtStatus)                        \
         if (!NT_SUCCESS(_NtStatus)) {                                 \
             DebPrint((_sev_),                                         \
                      (PUCHAR)(_str "  NTStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelNT(_NtStatus) );  \
         }

#define DPRINT2_NT(_sev_, _str, _p1, _p2, _NtStatus)                        \
         if (!NT_SUCCESS(_NtStatus)) {                                      \
             DebPrint((_sev_),                                              \
                      (PUCHAR)(_str "  NTStatus: %s\n"),                    \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelNT(_NtStatus) );  \
         }

#define DPRINT3_NT(_sev_, _str, _p1, _p2, _p3, _NtStatus)                       \
         if (!NT_SUCCESS(_NtStatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  NTStatus: %s\n"),                        \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ErrLabelNT(_NtStatus) ); \
         }

#define DPRINT4_NT(_sev_, _str, _p1, _p2, _p3, _p4, _NtStatus)                       \
         if (!NT_SUCCESS(_NtStatus)) {                                               \
             DebPrint((_sev_),                                                       \
                      (PUCHAR)(_str "  NTStatus: %s\n"),                             \
                      DEBSUB, __LINE__, _p1, _p2, _p3, _p4, ErrLabelNT(_NtStatus) ); \
         }


//
// CLEANUP_NT(sev, "display text", NtStatus, branch_target)
//   Like DPRINT but takes a branch target as last arg if success test fails.
//

#define CLEANUP_NT(_sev_, _str, _NtStatus, _branch)               \
         if (!NT_SUCCESS(_NtStatus)) {                            \
             DebPrint((_sev_),                                    \
                      (PUCHAR)(_str "  NTStatus: %s\n"),          \
                      DEBSUB, __LINE__, ErrLabelNT(_NtStatus) );  \
             goto _branch;                                        \
         }

#define CLEANUP1_NT(_sev_, _str, _p1, _NtStatus, _branch)              \
         if (!NT_SUCCESS(_NtStatus)) {                                 \
             DebPrint((_sev_),                                         \
                      (PUCHAR)(_str "  NTStatus: %s\n"),               \
                      DEBSUB, __LINE__, _p1, ErrLabelNT(_NtStatus) );  \
             goto _branch;                                             \
         }

#define CLEANUP2_NT(_sev_, _str, _p1, _p2, _NtStatus, _branch)              \
         if (!NT_SUCCESS(_NtStatus)) {                                      \
             DebPrint((_sev_),                                              \
                      (PUCHAR)(_str "  NTStatus: %s\n"),                    \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelNT(_NtStatus) );  \
             goto _branch;                                                  \
         }

#define CLEANUP3_NT(_sev_, _str, _p1, _p2, _p3, _NtStatus, _branch)             \
         if (!NT_SUCCESS(_NtStatus)) {                                          \
             DebPrint((_sev_),                                                  \
                      (PUCHAR)(_str "  NTStatus: %s\n"),                        \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ErrLabelNT(_NtStatus) ); \
             goto _branch;                                                      \
         }




//
// DPRINT_JS(sev, "display text", jerr)
//

#define DPRINT_JS(_sev_, _str, _jerr)                         \
         if (!JET_SUCCESS(_jerr)) {                           \
             DebPrint((_sev_),                                \
                      (PUCHAR)(_str "  JStatus: %s\n"),       \
                      DEBSUB, __LINE__, ErrLabelJet(_jerr) ); \
         }

#define DPRINT1_JS(_sev_, _str, _p1, _jerr)                        \
         if (!JET_SUCCESS(_jerr)) {                                \
             DebPrint((_sev_),                                     \
                      (PUCHAR)(_str "  JStatus: %s\n"),            \
                      DEBSUB, __LINE__, _p1, ErrLabelJet(_jerr) ); \
         }

#define DPRINT2_JS(_sev_, _str, _p1, _p2, _jerr)                        \
         if (!JET_SUCCESS(_jerr)) {                                     \
             DebPrint((_sev_),                                          \
                      (PUCHAR)(_str "  JStatus: %s\n"),                 \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelJet(_jerr) ); \
         }



//
// CLEANUP_JS(sev, "display text", jerr, branch_target)
//   Like DPRINT but takes a branch target as last arg if success test fails.
//

#define CLEANUP_JS(_sev_, _str, _jerr, _branch)               \
         if (!JET_SUCCESS(_jerr)) {                           \
             DebPrint((_sev_),                                \
                      (PUCHAR)(_str "  JStatus: %s\n"),       \
                      DEBSUB, __LINE__, ErrLabelJet(_jerr) ); \
             goto _branch;                                    \
         }

#define CLEANUP1_JS(_sev_, _str, _p1, _jerr, _branch)              \
         if (!JET_SUCCESS(_jerr)) {                                \
             DebPrint((_sev_),                                     \
                      (PUCHAR)(_str "  JStatus: %s\n"),            \
                      DEBSUB, __LINE__, _p1, ErrLabelJet(_jerr) ); \
             goto _branch;                                         \
         }

#define CLEANUP2_JS(_sev_, _str, _p1, _p2, _jerr, _branch)              \
         if (!JET_SUCCESS(_jerr)) {                                     \
             DebPrint((_sev_),                                          \
                      (PUCHAR)(_str "  JStatus: %s\n"),                 \
                      DEBSUB, __LINE__, _p1, _p2, ErrLabelJet(_jerr) ); \
             goto _branch;                                              \
         }



//
// DPRINT_LS(sev, "display text", LDAP_Status)
//
#define DPRINT_LS(_sev_, _str, _LStatus)                             \
         if (!LDP_SUCCESS(_LStatus)) {                               \
             DebPrint((_sev_),                                       \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),         \
                      DEBSUB, __LINE__, ldap_err2string(_LStatus) ); \
         }

#define DPRINT1_LS(_sev_, _str, _p1, _LStatus)                            \
         if (!LDP_SUCCESS(_LStatus)) {                                    \
             DebPrint((_sev_),                                            \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),              \
                      DEBSUB, __LINE__, _p1, ldap_err2string(_LStatus) ); \
         }

#define DPRINT2_LS(_sev_, _str, _p1, _p2, _LStatus)                            \
         if (!LDP_SUCCESS(_LStatus)) {                                         \
             DebPrint((_sev_),                                                 \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),                   \
                      DEBSUB, __LINE__, _p1, _p2, ldap_err2string(_LStatus) ); \
         }

#define DPRINT3_LS(_sev_, _str, _p1, _p2, _p3, _LStatus)                            \
         if (!LDP_SUCCESS(_LStatus)) {                                              \
             DebPrint((_sev_),                                                      \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),                        \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ldap_err2string(_LStatus) ); \
         }

//
// CLEANUP_LS(sev, "display text", LDAP_Status, branch_target)
//   Like DPRINT but takes a branch target as last arg if success test fails.
//
#define CLEANUP_LS(_sev_, _str, _LStatus, _branch)                   \
         if (!LDP_SUCCESS(_LStatus)) {                               \
             DebPrint((_sev_),                                       \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),         \
                      DEBSUB, __LINE__, ldap_err2string(_LStatus) ); \
             goto _branch;                                           \
         }

#define CLEANUP1_LS(_sev_, _str, _p1, _LStatus, _branch)                  \
         if (!LDP_SUCCESS(_LStatus)) {                                    \
             DebPrint((_sev_),                                            \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),              \
                      DEBSUB, __LINE__, _p1, ldap_err2string(_LStatus) ); \
             goto _branch;                                                \
         }

#define CLEANUP2_LS(_sev_, _str, _p1, _p2, _LStatus, _branch)                  \
         if (!LDP_SUCCESS(_LStatus)) {                                         \
             DebPrint((_sev_),                                                 \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),                   \
                      DEBSUB, __LINE__, _p1, _p2, ldap_err2string(_LStatus) ); \
             goto _branch;                                                     \
         }

#define CLEANUP3_LS(_sev_, _str, _p1, _p2, _p3, _LStatus, _branch)                  \
         if (!LDP_SUCCESS(_LStatus)) {                                              \
             DebPrint((_sev_),                                                      \
                      (PUCHAR)(_str "  Ldap Status: %ws\n"),                        \
                      DEBSUB, __LINE__, _p1, _p2, _p3, ldap_err2string(_LStatus) ); \
             goto _branch;                                                          \
         }


//
// Send Mail
//
#if  0
VOID
DbgSendMail(
    IN PCHAR    Subject,
    IN PCHAR    Content
    );

#define SENDMAIL(_Subject_, _Content_)  DbgSendMail(_Subject_, _Content_)
#endif 0


//
// Define the debug initialization routine
//
VOID
DbgInitLogTraceFile(
    IN LONG    argc,
    IN PWCHAR  *argv
    );

VOID
DbgMustInit(
    IN LONG argc,
    IN PWCHAR *argv
    );

VOID
DbgCaptureThreadInfo(
    PWCHAR   ArgName,
    PTHREAD_START_ROUTINE EntryPoint
    );

VOID
DbgCaptureThreadInfo2(
    PWCHAR   ArgName,
    PTHREAD_START_ROUTINE EntryPoint,
    ULONG    ThreadId
    );

VOID
DbgMinimumInit(
    VOID
    );

VOID
DbgFlush(
    VOID
    );

#define DEBUG_FLUSH()                   DbgFlush()

VOID
DbgDoAssert(
    IN PCHAR,
    IN UINT,
    IN PCHAR
    );

#define FRS_ASSERT(_exp) { if (!(_exp)) DbgDoAssert(#_exp, __LINE__, DEBSUB); }

#define FRS_FORCE_ACCVIO               \
    DPRINT(0, "FRS_FORCE_ACCVIO\n");   \
    *((PULONG) (0)) = 0;

//
// Insert a debug test point.  The external trigger is set via the registry.
//   TestCodeName is the ascii string for the test name.
//   TestCodeNumber is the sub-code number for the particular test of interest.
//   TestTriggerCount is the number of times to skip the test before it triggers.
//   TestTriggerRefresh is the value to reset the count to when it hits zero.
//
// The name and number are used to select the test point of interest.
// An optional condition test can be used to further control test selection.
// WHen the trigger hits zero {_STMT_} is executed.
//

#define FRS_DEBUG_TEST_POINT1(_tcname, _tcnum, _cond1, _STMT_)                 \
    if (DebugInfo.TestCodeName &&                                              \
        ASTR_EQ(DebugInfo.TestCodeName, _tcname) &&                            \
        (DebugInfo.TestSubCodeNumber == _tcnum)) {                             \
            if ((_cond1) &&                                                    \
                (--DebugInfo.TestTriggerCount == 0)                            \
                ) {                                                            \
                                                                               \
                    DebPrint(0, (PUCHAR)(":TP: %s : %d  (%s) triggered\n"),    \
                             DEBSUB, __LINE__,                                 \
                             DebugInfo.TestCodeName,                           \
                             DebugInfo.TestSubCodeNumber,                      \
                             #_cond1 );                                        \
                    DebugInfo.TestTriggerCount = DebugInfo.TestTriggerRefresh; \
                   { _STMT_ ;}                                                 \
            }                                                                  \
    }


#define XRAISEGENEXCEPTION(_x) {RaiseException((_x) ,EXCEPTION_NONCONTINUABLE,0,0);}

//
// Used for stack trace and tests
//
#define STACK_TRACE(_Stack_, _Depth_)               \
                DbgStackTrace(_Stack_, _Depth_)

#define STACK_PRINT(_Severity_, _Stack_, _Depth_)   \
                DbgStackPrint(_Severity_, DEBSUB, __LINE__, _Stack_, _Depth_)

#define STACK_TRACE_AND_PRINT(_Severity_)   \
                DbgPrintStackTrace(_Severity_, DEBSUB, __LINE__)

VOID
DbgStackTrace(
    PULONG_PTR  Stack,
    ULONG   Depth
    );

VOID
DbgStackPrint(
    ULONG   Severity,
    PCHAR   Debsub,
    UINT    LineNo,
    PULONG_PTR  Stack,
    ULONG   Depth
    );

VOID
DbgPrintStackTrace(
    ULONG   Severity,
    PCHAR   Debsub,
    UINT    LineNo
    );


//
// check for improper cleanup at shutdown
//
extern VOID     JrnlDumpVmeFilterTable(VOID);


#ifdef __cplusplus
}
#endif

#endif /* _debug_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\config.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    config.h

Abstract:

    Config parameters for the NT File Replication Service.

    All configuration parameters that come from the registry are defined in a
    Key Context table in config.c.  The struct FRS_REGISTRY_KEY, defined
    below, defines the data format for each table entry.  An extensive list
    of flags defined below govern the processing of registry keys, e.g.
    generate and event log entry or not, range check the value or not, allow
    a builtin default value or not, etc.

    To add a new registry key to FRS do the following:
        1. Add key code to the FRS_REG_KEY_CODE enum below.
        2. Create a new entry in the Key Context table in config.c
           Look at examples for other keys that may have similar properties
           to your new key.
        3. Add calls to CfgRegxxx functions to read or write the key.

    If you set the Key Context up to supply a default value the call to the
    CfgRegReadxxx functions will always return a usable value.  In addition if
    the appropriate flags are set these functions will put a message in the
    FRS event log when the user has specified a bad value for the key or a
    required key was not found.  The CfgRegxxx functions also put error
    messages in the Debug Trace Log so in many cases the caller does not need
    to test the return status to log an error or use a default or add code to
    range check a parameter.


Author:

    David Orbits (davidor) - 4-Mar-1997
                             Major Revision July-1999.

Revision History:


--*/

#ifdef __cplusplus
extern "C" {
#endif


typedef struct _FRS_REGISTRY_KEY {
    PWCHAR          KeyName;         // Registry key string.
    PWCHAR          ValueName;       // Name of registry value.
    DWORD           Units;           // UNITS_DAYS, UNITS_HOURS, etc.

    DWORD           RegValueType;    // Registry Data type for value
    DWORD           DataValueType;   // FRS data type code from FRS_DATA_TYPES for conversion.
    DWORD           ValueMin;        // Minimum data value, or string len
    DWORD           ValueMax;        // Maximum Data value, or string len
    DWORD           ValueDefault;    // Default data value if not present.
    DWORD           EventCode;       // Event log error code

    PWCHAR          StringDefault;   // Default value for string types.
    LONG            FrsKeyCode;      // Frs code name for this key.
    ULONG           Flags;           // See below.

} FRS_REGISTRY_KEY, *PFRS_REGISTRY_KEY;


#define EVENT_FRS_NONE  0

//
// Registry key flag definitions.
//
#define FRS_RKF_KEY_PRESENT           0x00000001   // Key is present in reg.
#define FRS_RKF_VALUE_PRESENT         0x00000002   // Value is present in reg.
#define FRS_RKF_DISPLAY_ERROR         0x00000004   // Put a message in the log
#define FRS_RKF_LOG_EVENT             0x00000008   // put event in error log.

#define FRS_RKF_READ_AT_START         0x00000010   // Read the key at startup
#define FRS_RKF_READ_AT_POLL          0x00000020   // Read the key during polling
#define FRS_RKF_RANGE_CHECK           0x00000040   // Range check the value read
#define FRS_RKF_SYNTAX_CHECK          0x00000080   // Perform syntax check using DataValueType

#define FRS_RKF_KEY_MUST_BE_PRESENT   0x00000100   // Key must be present
#define FRS_RKF_VALUE_MUST_BE_PRESENT 0x00000200   // Value must be present
#define FRS_RKF_OK_TO_USE_DEFAULT     0x00000400   // Use default val if not present or out of range
#define FRS_RKF_FORCE_DEFAULT_VALUE   0x00000800   // Return default on read, Write default to registry on a write

#define FRS_RKF_DEBUG_MODE_ONLY       0x00001000   // Use key only if in debug mode
#define FRS_RKF_TEST_MODE_ONLY        0x00002000   // Use key only if running in special Test mode
#define FRS_RKF_API_ACCESS_CHECK_KEY  0x00004000   // Key used to make API enable checks
#define FRS_RKF_CREATE_KEY            0x00008000   // Create Key if it doesn't exist.

#define FRS_RKF_KEEP_EXISTING_VALUE   0x00010000   // On a write, suppress the write if a value exists.
#define FRS_RKF_KEY_ACCCHK_READ       0x00020000   // Perform only a read access check of fully formed key path.  No key create.
#define FRS_RKF_KEY_ACCCHK_WRITE      0x00040000   // Perform only a write access check of fully formed key path.  No key create.
#define FRS_RKF_RANGE_SATURATE        0x00080000   // If value is out of range then use either Min or Max. (currently only for CfgRegWriteDWord)


#define FRS_RKF_DEBUG_PARAM           0x02000000   // This key is a debug paramter


typedef  enum _FRS_DATA_UNITS {
    UNITS_NONE = 0,
    UNITS_SECONDS,
    UNITS_MINUTES,
    UNITS_HOURS,
    UNITS_DAYS,
    UNITS_MILLISEC,
    UNITS_KBYTES,
    UNITS_BYTES,
    UNITS_MBYTES,
    FRS_DATA_UNITS_MAX
} FRS_DATA_UNITS;


//
// The FrsReg... apis take a key code from the list below.  The key table
// is searched for the entry with the corresponding key code to provide the
// context for the registry key operation.
//  PERF: at startup sort the entries in the key table by key code so the
//  key entry search becomes an array index calc.
//
typedef  enum _FRS_REG_KEY_CODE {
    FKC_END_OF_TABLE = 0,
    //
    // Service Debug Keys
    //
    FKC_DEBUG_ASSERT_FILES,
    FKC_DEBUG_ASSERT_SECONDS,
    FKC_DEBUG_ASSERT_SHARE,
    FKC_DEBUG_BREAK,
    FKC_DEBUG_COPY_LOG_FILES,
    FKC_DEBUG_DBS_OUT_OF_SPACE,
    FKC_DEBUG_DBS_OUT_OF_SPACE_TRIGGER,
    FKC_DEBUG_DISABLE,
    FKC_DEBUG_LOG_FILE,

    FKC_DEBUG_LOG_FILES,
    FKC_DEBUG_LOG_FLUSH_INTERVAL,
    FKC_DEBUG_LOG_SEVERITY,
    FKC_DEBUG_MAX_LOG,
    FKC_DEBUG_MEM,
    FKC_DEBUG_MEM_COMPACT,
    FKC_DEBUG_PROFILE,
    FKC_DEBUG_QUEUES,
    FKC_DEBUG_RECIPIENTS,
    FKC_DEBUG_RESTART_SECONDS,
    FKC_DEBUG_SEVERITY,

    FKC_DEBUG_SUPPRESS,
    FKC_DEBUG_SYSTEMS,
    FKC_DEBUG_TEST_CODE_NAME,
    FKC_DEBUG_TEST_CODE_NUMBER,
    FKC_DEBUG_TEST_TRIGGER_COUNT,
    FKC_DEBUG_TEST_TRIGGER_REFRESH,
    FKC_DEBUG_BUILDLAB,

    //
    // Service Config keys
    //
    FKC_COMM_TIMEOUT,
    FKC_DIR_EXCL_FILTER_LIST,
    FKC_DIR_INCL_FILTER_LIST,
    FKC_DS_POLLING_LONG_INTERVAL,
    FKC_DS_POLLING_SHORT_INTERVAL,
    FKC_ENUMERATE_DIRECTORY_SIZE,
    FKC_FILE_EXCL_FILTER_LIST,
    FKC_FILE_INCL_FILTER_LIST,
    FKC_FRS_MESSAGE_FILE_PATH,
    FKC_FRS_MUTUAL_AUTHENTICATION_IS,

    FKC_MAX_JOIN_RETRY,
    FKC_MAX_REPLICA_THREADS,
    FKC_MAX_RPC_SERVER_THREADS,
    FKC_RPC_PORT_ASSIGNMENT,
    FKC_MAX_INSTALLCS_THREADS,
    FKC_MAX_STAGE_GENCS_THREADS,
    FKC_MAX_STAGE_FETCHCS_THREADS,
    FKC_MAX_INITSYNCCS_THREADS,
    FKC_MIN_JOIN_RETRY,
    FKC_PARTNER_CLOCK_SKEW,
    FKC_RECONCILE_WINDOW,
    FKC_INLOG_RETRY_TIME,
    FKC_CO_AGING_DELAY,
    FKC_OUTLOG_REPEAT_INTERVAL,
    FKC_PROMOTION_TIMEOUT,
    FKC_REPLICA_START_TIMEOUT,
    FKC_REPLICA_TOMBSTONE,
    FKC_MAX_CO_RETRY_TIMEOUT_MINUTES,
    FKC_MAX_CO_RETRY_TIMEOUT_COUNT,
    FKC_SHUTDOWN_TIMEOUT,

    FKC_SNDCS_MAXTHREADS_PAR,
    FKC_STAGING_LIMIT,
    FKC_VVJOIN_LIMIT,
    FKC_VVJOIN_TIMEOUT,
    FKC_WORKING_DIRECTORY,
    FKC_DBLOG_DIRECTORY,
    FKC_NTFS_JRNL_SIZE,
    FKC_MAX_NUMBER_REPLICA_SETS,
    FKC_MAX_NUMBER_JET_SESSIONS,
    FKC_OUT_LOG_CO_QUOTA,
    FKC_OUTLOG_CHANGE_HISTORY,
    FKC_SAVE_OUTLOG_CHANGE_HISTORY,
    FKC_SUPPRESS_IDENTICAL_UPDATES,
    FKC_ENABLE_INSTALL_OVERRIDE,
    FKC_ENABLE_RENAME_BASED_UPDATES,
    FKC_PRESERVE_FILE_OID,
    FKC_DEBUG_DISABLE_COMPRESSION,
    FKC_LDAP_SEARCH_TIMEOUT_IN_MINUTES,
    FKC_LDAP_BIND_TIMEOUT_IN_SECONDS,
    FKC_COMPRESS_STAGING_FILES,
    FKC_RECLAIM_STAGING_SPACE,
    FKC_ENABLE_JOURNAL_WRAP_AUTOMATIC_RESTORE,
    FKC_LOCKED_OUTLOG_CLEANUP,

    //
    // Per Replica Set Keys
    //
    FKC_SET_SECTION_KEY,
    FKC_SETS_JET_PATH,
    FKC_SET_N_REPLICA_SET_NAME,
    FKC_SET_N_REPLICA_SET_ROOT,
    FKC_SET_N_REPLICA_SET_STAGE,
    FKC_SET_N_REPLICA_SET_TYPE,

    FKC_SET_N_DIR_EXCL_FILTER_LIST,
    FKC_SET_N_DIR_INCL_FILTER_LIST,
    FKC_SET_N_FILE_EXCL_FILTER_LIST,
    FKC_SET_N_FILE_INCL_FILTER_LIST,

    FKC_SET_N_REPLICA_SET_TOMBSTONED,
    FKC_SET_N_REPLICA_SET_COMMAND,
    FKC_SET_N_REPLICA_SET_PRIMARY,
    FKC_SET_N_REPLICA_SET_STATUS,
    FKC_CUMSET_SECTION_KEY,
    FKC_CUMSET_N_NUMBER_OF_PARTNERS,
    FKC_CUMSET_N_BURFLAGS,
    //
    // System Volume Keys
    //
    FKC_SYSVOL_READY,
    FKC_SYSVOL_SECTION_KEY,
    FKC_SYSVOL_INFO_COMMITTED,
    FKC_SET_N_SYSVOL_NAME,
    FKC_SET_N_SYSVOL_ROOT,
    FKC_SET_N_SYSVOL_STAGE,
    FKC_SET_N_SYSVOL_TYPE,

    FKC_SET_N_SYSVOL_DIR_EXCL_FILTER_LIST,
    FKC_SET_N_SYSVOL_DIR_INCL_FILTER_LIST,
    FKC_SET_N_SYSVOL_FILE_EXCL_FILTER_LIST,
    FKC_SET_N_SYSVOL_FILE_INCL_FILTER_LIST,

    FKC_SET_N_SYSVOL_COMMAND,
    FKC_SET_N_SYSVOL_PARENT,
    FKC_SET_N_SYSVOL_PRIMARY,
    FKC_SET_N_SYSVOL_STATUS,
    FKC_SYSVOL_SEEDING_N_PARENT,
    FKC_SYSVOL_SEEDING_N_RSNAME,
    FKC_SYSVOL_SEEDING_SECTION_KEY,
    //
    // Event Logging Keys
    //
    FKC_EVENTLOG_FILE,
    FKC_EVENTLOG_DISPLAY_FILENAME,
    FKC_EVENTLOG_EVENT_MSG_FILE,
    FKC_EVENTLOG_SOURCES,
    FKC_EVENTLOG_RETENTION,
    FKC_EVENTLOG_MAXSIZE,
    FKC_EVENTLOG_DISPLAY_NAMEID,
    FKC_EVENTLOG_CUSTOM_SD,
    FKC_EVENTLOG_TYPES_SUPPORTED,

    //
    // API Access Check Keys
    //
    FKC_ACCCHK_PERFMON_ENABLE,
    FKC_ACCCHK_PERFMON_RIGHTS,
    FKC_ACCCHK_GETDS_POLL_ENABLE,
    FKC_ACCCHK_GETDS_POLL_RIGHTS,
    FKC_ACCCHK_GET_INFO_ENABLE,
    FKC_ACCCHK_GET_INFO_RIGHTS,
    FKC_ACCCHK_SETDS_POLL_ENABLE,
    FKC_ACCCHK_SETDS_POLL_RIGHTS,
    FKC_ACCCHK_STARTDS_POLL_ENABLE,
    FKC_ACCCHK_STARTDS_POLL_RIGHTS,
    FKC_ACCESS_CHK_DCPROMO_ENABLE,
    FKC_ACCESS_CHK_DCPROMO_RIGHTS,
    FKC_ACCESS_CHK_IS_PATH_REPLICATED_ENABLE,
    FKC_ACCESS_CHK_IS_PATH_REPLICATED_RIGHTS,

    //
    // Backup-restore writer related keys
    //
    FKC_ACCESS_CHK_WRITER_COMMANDS_ENABLE,
    FKC_ACCESS_CHK_WRITER_COMMANDS_RIGHTS,

    //
    // Backup/Restore related keys.
    //
    FKC_BKUP_SECTION_KEY,
    FKC_BKUP_STOP_SECTION_KEY,
    FKC_BKUP_MV_SETS_SECTION_KEY,
    FKC_BKUP_MV_CUMSETS_SECTION_KEY,
    FKC_BKUP_STARTUP_GLOBAL_BURFLAGS,
    FKC_BKUP_STARTUP_SET_N_BURFLAGS,

    //
    // Perfmon related keys.
    //
    FKC_REPLICA_SET_FIRST_CTR,
    FKC_REPLICA_SET_FIRST_HELP,
    FKC_REPLICA_SET_LINKAGE_EXPORT,
    FKC_REPLICA_CXTION_FIRST_CTR,
    FKC_REPLICA_CXTION_FIRST_HELP,
    FKC_REPLICA_CXTION_LINKAGE_EXPORT,

    //
    // Reparse Point keys
    //
    FKC_REPARSE_TAG_KEY,
    FKC_REPARSE_TAG_TYPE,
    FKC_REPARSE_TAG_REPLICATION_TYPE,

    FRS_REG_KEY_CODE_MAX
} FRS_REG_KEY_CODE;



DWORD
CfgRegReadDWord(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PULONG           DataRet
);

DWORD
CfgRegReadString(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PWSTR            *pStrRet
);

DWORD
CfgRegWriteDWord(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    IN  ULONG            NewData
);

DWORD
CfgRegWriteString(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    IN  PWSTR            NewStr
);

DWORD
CfgRegOpenKey(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT HKEY             *RethKey
);

PWCHAR
CfgRegGetValueName(
    IN  FRS_REG_KEY_CODE KeyIndex
);

DWORD
CfgRegCheckEnable(
    IN  FRS_REG_KEY_CODE KeyIndex,
    IN  PWCHAR           KeyArg1,
    IN  ULONG            Flags,
    OUT PBOOL            Enabled,
    OUT PBOOL            EnabledAndRequired
);

DWORD
CfgRegReadReparseTagInfo(
    VOID
    );




//
//  Following is the list keys defined for use by the FRS
//
#define SERVICE_ROOT            L"System\\CurrentControlSet\\Services"

#define SERVICE_NAME            L"NtFrs"
#define SERVICE_PRINCIPAL_NAME  L"NtFrs-88f5d2bd-b646-11d2-a6d3-00c04fc9b232"

#define FRS_SETS_KEY            L"Replica Sets"
#define FRS_CUMULATIVE_SETS_KEY      L"Cumulative Replica Sets"

#define FRS_CONFIG_SECTION      SERVICE_ROOT                                   \
                                    L"\\" SERVICE_NAME                         \
                                        L"\\Parameters"

#define FRS_SYSVOL_SECTION      SERVICE_ROOT                                   \
                                    L"\\" SERVICE_NAME                         \
                                        L"\\Parameters"                        \
                                            L"\\SysVol"

#define FRS_SETS_SECTION        SERVICE_ROOT                                   \
                                    L"\\" SERVICE_NAME                         \
                                        L"\\Parameters"                        \
                                            L"\\" FRS_SETS_KEY

#define FRS_REPARSE_TAG_SECTION SERVICE_ROOT                                   \
                                    L"\\" SERVICE_NAME                         \
                        L"\\Parameters"                        \
                        L"\\Reparse Points"

#define FRS_CUMULATIVE_SETS_SECTION  SERVICE_ROOT                              \
                                         L"\\" SERVICE_NAME                    \
                                             L"\\Parameters"                   \
                                                L"\\" FRS_CUMULATIVE_SETS_KEY

#define NETLOGON_SECTION        SERVICE_ROOT                                   \
                                    L"\\Netlogon"                              \
                                        L"\\Parameters"

#define JET_PATH                L"Database Directory"


#define WINNT_ROOT             L"software\\microsoft\\windows nt"

#define FRS_CURRENT_VER_SECTION    WINNT_ROOT                                  \
                                       L"\\current version"


//
//  Backup Restore related keys.
//
//
// Flags from backup/restore
//
#define FRS_VALUE_BURFLAGS  L"BurFlags"

#define FRS_BACKUP_RESTORE_SECTION                                             \
                            SERVICE_ROOT                                       \
                                L"\\" SERVICE_NAME                             \
                                    L"\\Parameters"                            \
                                        L"\\" L"Backup/Restore"

#define FRS_BACKUP_RESTORE_STOP_SECTION                                        \
                            SERVICE_ROOT                                       \
                                L"\\" SERVICE_NAME                             \
                                    L"\\Parameters"                            \
                                        L"\\Backup/Restore"                    \
                                            L"\\Stop NtFrs from Starting"

#define FRS_BACKUP_RESTORE_MV_SECTION                                          \
                            SERVICE_ROOT                                       \
                                L"\\" SERVICE_NAME                             \
                                    L"\\Parameters"                            \
                                        L"\\Backup/Restore"                    \
                                            L"\\Process at Startup"

#define FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION                          \
                            SERVICE_ROOT                                       \
                                L"\\" SERVICE_NAME                             \
                                    L"\\Parameters"                            \
                                        L"\\Backup/Restore"                    \
                                            L"\\Process at Startup"            \
                                                L"\\" FRS_CUMULATIVE_SETS_KEY

#define FRS_BACKUP_RESTORE_MV_SETS_SECTION                                     \
                            SERVICE_ROOT                                       \
                                L"\\" SERVICE_NAME                             \
                                    L"\\Parameters"                            \
                                        L"\\Backup/Restore"                    \
                                            L"\\Process at Startup"            \
                                                L"\\" FRS_SETS_KEY

#define FRS_OLD_FILES_NOT_TO_BACKUP L"SOFTWARE"                                \
                                        L"\\Microsoft"                         \
                                            L"\\Windows NT"                    \
                                                L"\\CurrentVersion"            \
                                                    L"\\FilesNotToBackup"

#define FRS_NEW_FILES_NOT_TO_BACKUP L"SYSTEM"                                  \
                                        L"\\CurrentControlSet"                 \
                                            L"\\Control"                       \
                                                L"\\BackupRestore"             \
                                                    L"\\FilesNotToBackup"

#define FRS_KEYS_NOT_TO_RESTORE     L"SYSTEM"                                  \
                                        L"\\CurrentControlSet"                 \
                                            L"\\Control"                       \
                                                L"\\BackupRestore"             \
                                                    L"\\KeysNotToRestore"


//
// Used to set KeysNotToRestore
//
// Set the restore registry key KeysNotToRestore so that NtBackup will retain
// the ntfrs restore keys by moving them into the final restored registry.
//
// CurrentControlSet\Services\NtFrs\Parameters\Backup/Restore\Process at Startup\
//
#define FRS_VALUE_FOR_KEYS_NOT_TO_RESTORE                                      \
    L"CurrentControlSet"                                                       \
        L"\\Services"                                                          \
            L"\\" SERVICE_NAME                                                 \
                L"\\Parameters"                                                \
                    L"\\Backup/Restore"                                        \
                        L"\\Process at Startup"                                \
                            L"\\"

//
// Some files not to backup.
//
#define NTFRS_DBG_LOG_FILE  L"\\NtFrs"
#define NTFRS_DBG_LOG_DIR   L"%SystemRoot%\\debug"



//
// Event Log Related Keys
//
#define EVENTLOG_ROOT           SERVICE_ROOT                                   \
                                    L"\\EventLog"

#define DEFAULT_MESSAGE_FILE_PATH   L"%SystemRoot%\\system32\\ntfrsres.dll"

#define FRS_EVENTLOG_SECTION    SERVICE_ROOT                                   \
                                    L"\\EventLog"                              \
                                        L"\\" SERVICE_LONG_NAME

#define FRS_EVENT_TYPES (EVENTLOG_SUCCESS          |                           \
                         EVENTLOG_ERROR_TYPE       |                           \
                         EVENTLOG_WARNING_TYPE     |                           \
                         EVENTLOG_INFORMATION_TYPE |                           \
                         EVENTLOG_AUDIT_SUCCESS    |                           \
                         EVENTLOG_AUDIT_FAILURE)

//
// Shutdown and Startup timeouts for Service Controller.
// Service will forcefully exit if it takes more than
// MAXIMUM_SHUTDOWN_TIMEOUT to shutdown cleanly.
//
#define DEFAULT_SHUTDOWN_TIMEOUT    (90)    // 90 seconds
#define MAXIMUM_SHUTDOWN_TIMEOUT    (300)    // 300 seconds
#define DEFAULT_STARTUP_TIMEOUT     (30)    // 30 seconds


//
// The delayed command server processes a timeout queue. To avoid excessive
// context switches, an entry on the timeout queue times out if it is
// within some delta of the head of the queue. The delta can be adjusted
// by setting the following registry value.
//
#define FUZZY_TIMEOUT_VALUE_IN_MILLISECONDS \
           L"Fuzzy Timeout Value In MilliSeconds"

#define DEFAULT_FUZZY_TIMEOUT_VALUE     (5 * 1000)

//
// :SP1: Volatile connection cleanup.
//
// A volatile connection is used to seed sysvols after dcpromo.
// If there is inactivity on a volatile outbound connection for more than
// FRS_VOLATILE_CONNECTION_MAX_IDLE_TIME then this connection is unjoined. An unjoin on
// a volatile outbound connection triggers a delete on that connection.
// This is to prevent the case where staging files are kept for ever on
// the parent for a volatile connection.
//

#define FRS_VOLATILE_CONNECTION_MAX_IDLE_TIME   (30 * 60 * 1000)   // 30 Minutes in milliseconds
//
// Sysvol
//
#define REPLICA_SET_PARENT          L"Replica Set Parent"
#define REPLICA_SET_COMMAND         L"Replica Set Command"
#define REPLICA_SET_NAME            L"Replica Set Name"
#define REPLICA_SET_SEEDING_NAME    L"Replica Set Seeding Name"
#define REPLICA_SET_TYPE            L"Replica Set Type"
#define REPLICA_SET_PRIMARY         L"Replica Set Primary"
#define REPLICA_SET_STATUS          L"Replica Set Status"
#define REPLICA_SET_ROOT            L"Replica Set Root"
#define REPLICA_SET_STAGE           L"Replica Set Stage"
#define REPLICA_SET_TOMBSTONED      L"Replica Set Tombstoned"
#define SYSVOL_INFO_IS_COMMITTED    L"SysVol Information is Committed"
#define SYSVOL_READY                L"SysvolReady"

//
// Enumerate Directory
//
#define DEFAULT_ENUMERATE_DIRECTORY_SIZE    (2048)
#define MINIMUM_ENUMERATE_DIRECTORY_SIZE \
    (((MAX_PATH + 1) * sizeof(WCHAR)) + sizeof(FILE_DIRECTORY_INFORMATION))

//
// Default values for config parameters.
//
#define DEFAULT_FILE_FILTER_LIST   TEXT("*.tmp, *.bak, ~*")
#define DEFAULT_DIR_FILTER_LIST    TEXT("")

//
// Preinstall files are put into Root\NTFRS_PREINSTALL_DIRECTORY
//
#define NTFRS_PREINSTALL_DIRECTORY  L"DO_NOT_REMOVE_NtFrs_PreInstall_Directory"

//
// Files skipped during primary load are put in
// Root\NTFRS_PREINSTALL_DIRECTORY\NTFRS_SKIPPED_FILES
//
#define NTFRS_SKIPPED_FILES  L"NtFrs_Skipped_Files"

//
// Preexisting files are put into Root\NTFRS_PREEXISTING_DIRECTORY
//
#define NTFRS_PREEXISTING_DIRECTORY L"NtFrs_PreExisting___See_EventLog"

//
// Command file to confir that it is OK to move the root to the
// new location. Command file is created at the new root location.
//
#define NTFRS_CMD_FILE_MOVE_ROOT L"NTFRS_CMD_FILE_MOVE_ROOT"



//
// Generic Enabled or Disabled
//
#define FRS_IS_DEFAULT_ENABLED  L"Default (Enabled)"
#define FRS_IS_DEFAULT_ENABLED_AND_REQUIRED  L"Default (Enabled and Required)"
#define FRS_IS_DEFAULT_DISABLED L"Default (Disabled)"
#define FRS_IS_ENABLED          L"Enabled"
#define FRS_IS_ENABLED_AND_REQUIRED          L"Enabled and Required"
#define FRS_IS_DISABLED         L"Disabled"

//
// Access Checks for RPC API calls (not the service <-> service RPC calls)
//
#define ACCESS_CHECKS_KEY      L"Access Checks"
#define ACCESS_CHECKS_KEY_PATH FRS_CONFIG_SECTION L"\\" ACCESS_CHECKS_KEY

#define ACCESS_CHECKS_ARE      L"Access checks are [Enabled or Disabled]"
#define ACCESS_CHECKS_ARE_DEFAULT_ENABLED   FRS_IS_DEFAULT_ENABLED
#define ACCESS_CHECKS_ARE_DEFAULT_DISABLED  FRS_IS_DEFAULT_DISABLED
#define ACCESS_CHECKS_ARE_ENABLED           FRS_IS_ENABLED
#define ACCESS_CHECKS_ARE_DISABLED          FRS_IS_DISABLED

#define ACCESS_CHECKS_REQUIRE  L"Access checks require [Full Control or Read]"
#define ACCESS_CHECKS_REQUIRE_DEFAULT_READ  L"Default (Read)"
#define ACCESS_CHECKS_REQUIRE_DEFAULT_WRITE L"Default (Full Control)"
#define ACCESS_CHECKS_REQUIRE_READ          L"Read"
#define ACCESS_CHECKS_REQUIRE_WRITE         L"Full Control"


//
// The following are used as indices into the API Access Check table defined
// in frsrpc.c.  Entries added here must be added there too.  The order of the
// entries in the two tables MUST be the same.
//
typedef  enum _FRS_API_ACCESS_CHECKS {
    ACX_START_DS_POLL = 0,
    ACX_SET_DS_POLL,
    ACX_GET_DS_POLL,
    ACX_INTERNAL_INFO,
    ACX_COLLECT_PERFMON_DATA,
    ACX_DCPROMO,
    ACX_IS_PATH_REPLICATED,
    ACK_WRITER_COMMANDS,

    ACX_MAX
} FRS_API_ACCESS_CHECKS;

//
// These are the Access Check Key (ACK) names for the API Access Checks.
// They all live in the registry at:  "FRS_CONFIG_SECTION\Access Checks"
//
#define ACK_START_DS_POLL        L"Start Ds Polling"
#define ACK_SET_DS_POLL          L"Set Ds Polling Interval"
#define ACK_GET_DS_POLL          L"Get Ds Polling Interval"
#define ACK_INTERNAL_INFO        L"Get Internal Information"
#define ACK_COLLECT_PERFMON_DATA L"Get Perfmon Data"
#define ACK_DCPROMO              L"dcpromo"
#define ACK_IS_PATH_REPLICATED   L"Is Path Replicated"
#define ACK_WRITER_COMMANDS      L"Writer Commands"



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\frsinrpc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    frsinrpc.h

Abstract:

    Structs shared with rpc functions. This will be fleshed out over time.

Author:

    Billy Fuller 18-Apr-1997

Revision History:

--*/

//
// The version vector
//
typedef struct _COMM_PACKET {
    ULONG   Major;              // major version number
    ULONG   Minor;              // minor version number
    ULONG   CsId;               // command server id
    ULONG   MemLen;             // allocated memory
#ifdef  MIDL_PASS
    [range(0, 256 * 1024)]  ULONG   PktLen;             // data length
#else   MIDL_PASS
    ULONG   PktLen;             // data length
#endif MIDL_PASS
    ULONG   UpkLen;             // unpack length
#ifdef  MIDL_PASS
    [size_is(PktLen)]      UCHAR  *Pkt;                 // blob in RPC syntax
    [ignore]               void   *DataName;
    [ignore]               void   *DataHandle;
#else   MIDL_PASS
    UCHAR    *Pkt;            // blob in C syntax
    PWCHAR    DataName;
    HANDLE    DataHandle;
#endif MIDL_PASS
} COMM_PACKET, *PCOMM_PACKET;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\frs.h ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    frs.h

Abstract:
    This header handles information global to the ntrepl\frs modules

Author:
    Billy Fuller (billyf) - 20-Mar-1997
--*/

#ifndef _FRSH_
#define _FRSH_

#include <schedule.h>
#include <debug.h>
#include <frsrpc.h>
#include <frsapi.h>
#include <frsalloc.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <mmsystem.h>
#include <global.h>
#include <winsvc.h>

#include <ntfrsres.h>

#include <eventlog.h>
#include <resource.h>



#ifndef FRSCONN_PRIORITY_MASK

//
// The following is here to support this function in WIN2K since it is not
// defined in ntdsapi.h for win2K
//
//
// The high 4 bits of the options attribute are used by NTFRS to assign priority
// for inbound connections. Bit 31 is used to force FRS to ignore schedule during
// the initial sync. Bits 30 - 28 are used to specify a priority between 0-7.
//

#define FRSCONN_PRIORITY_MASK             0x70000000
#define FRSCONN_MAX_PRIORITY              0x8

#define NTDSCONN_OPT_IGNORE_SCHEDULE_MASK 0x80000000

#define NTDSCONN_IGNORE_SCHEDULE(_options_)\
        (((_options_) & NTDSCONN_OPT_IGNORE_SCHEDULE_MASK) >> 31)

#define FRSCONN_GET_PRIORITY(_options_)    \
        (((((_options_) & FRSCONN_PRIORITY_MASK) >> 28) != 0 ) ? \
         (((_options_) & FRSCONN_PRIORITY_MASK) >> 28) :        \
         FRSCONN_MAX_PRIORITY                                   \
        )
#endif



//
// Types for the common comm subsystem
//
typedef enum _COMMAND_SERVER_ID {
    CS_NONE = 0,
    CS_RS,

    CS_MAX
} COMMAND_SERVER_ID, *PCOMMAND_SERVER_ID;


//
// GLOBALS
//
#define NTFRS_MAJOR         (0)
#define NTFRS_MINOR         (0)

extern ULONG    NtFrsMajor;
extern ULONG    NtFrsMinor;
extern PCHAR    NtFrsModule;
extern PCHAR    NtFrsDate;
extern PCHAR    NtFrsTime;

//
// Staging File Version Levels
//
#define NTFRS_STAGE_MAJOR   (0)
#define NTFRS_STAGE_MINOR_0 (0)
#define NTFRS_STAGE_MINOR_1 (1) // ChangeOrder Record extension added to stage file.
#define NTFRS_STAGE_MINOR_2 (2) // Compression Guid added to stage file.
#define NTFRS_STAGE_MINOR_3 (3) // Reparse Point data added to stage file.

extern ULONG    NtFrsStageMajor;
extern ULONG    NtFrsStageMinor;

//
// Communication packet version levels.
//
#define NTFRS_COMM_MINOR_0  (0)
#define NTFRS_COMM_MINOR_1  (1) // MD5
#define NTFRS_COMM_MINOR_2  (2) // Trigger schedule
#define NTFRS_COMM_MINOR_3  (3) // ChangeOrder Record Extension.
//
// The following minor rev forces the Replica Number fields in the change order
// to be a ULONG (v.s. ULONG_PTR) for 32 - 64 bit interop.  Add hack to always
// ship the 4 ptrs in the CO as 32 bits of zeros for 32 bit compat (see schema.h).
//
// Also the change order extension supports a var len comm element v.s.  fixed
// size as in rev_3.  When sending the CO Externsion to rev 3 servers you can
// only send the COMM_CO_EXT_WIN2K element with the MD5 checksum.  For Rev 4
// servers and above you can send COMM_CO_EXTENSION_2 data elements.
//
// Added COMM_COMPRESSION_GUID as part of Join request.
//
#define NTFRS_COMM_MINOR_4  (4) // ChangeOrder Record Extension. COMM_CO_EXTENSION_2

//
// will send out COMM_CO_EXTENSION_2 to level 4 and 5 partners.
//
#define NTFRS_COMM_MINOR_5  (5)

//
// Bump minor for SP3 QFE so CONNSTAT can tell.
//
#define NTFRS_COMM_MINOR_6  (6)

//
// Bump minor for SP3 QFE+1 so CONNSTAT can tell. (.xls file fix)
//
#define NTFRS_COMM_MINOR_7  (7)

//
// Bump minor for .NET server
//
#define NTFRS_COMM_MINOR_8  (8)

//
// Bump minor for WIN2K SP4
//
#define NTFRS_COMM_MINOR_9  (9)

extern ULONG    NtFrsCommMinor;

//
// Version number for the perfmon counters.
// Change this version any time the counters change or
// any help text associated with the counters changes.
// Change in version will trigger the counters to be
// loaded again.
//

#define NTFRS_PERF_COUNTER_VER_1    (1)

extern ULONG NtFrsPerfCounterVer;


//
// SCHEDULE
// Defines for both an byte-per-hour and a nibble-per-hour
//
#ifdef  SCHEDULE_NIBBLE_PER_HOUR
//
// Each hour in a schedule is 4 bits (rounded up).
//
#define SCHEDULE_DATA_BYTES     ((SCHEDULE_DATA_ENTRIES + 1) / 2)
//
// Each hour in a schedule is 8 bits (byte).
//
#else   SCHEDULE_NIBBLE_PER_HOUR
#define SCHEDULE_DATA_BYTES     SCHEDULE_DATA_ENTRIES
#endif  SCHEDULE_NIBBLE_PER_HOUR

//
// Defines for checking Service state transitions.
// Used in FrsSetServiceStatus()
//
#define FRS_SVC_TRANSITION_TABLE_SIZE 5
#define FRS_SVC_TRANSITION_LEGAL      0
#define FRS_SVC_TRANSITION_NOOP       1
#define FRS_SVC_TRANSITION_ILLEGAL    2

//
// FRS MEMORY MANAGEMENT
//
VOID
FrsInitializeMemAlloc(
    VOID
    );
VOID
FrsUnInitializeMemAlloc(
    VOID
    );

//
// DS
//
//
// Some useful DS search constants
//
#define CONFIG_NAMING_CONTEXT       L"cn=configuration"

#define CLASS_ANY                   L"(objectClass=*)"
#define CLASS_CXTION                L"(objectClass=nTDSConnection)"
#define CLASS_MEMBER                L"(objectClass=nTFRSMember)"
#define CLASS_REPLICA_SET           L"(objectClass=nTFRSReplicaSet)"
#define CLASS_NTFRS_SETTINGS        L"(objectClass=nTFRSSettings)"
#define CLASS_NTDS_SETTINGS         L"(objectClass=nTDSSettings)"
#define CLASS_SUBSCRIBER            L"(objectClass=nTFRSSubscriber)"
#define CLASS_SUBSCRIPTIONS         L"(objectClass=nTFRSSubscriptions)"
#define CLASS_NTDS_DSA              L"(objectClass=nTDSDSA)"
#define CLASS_COMPUTER              L"(objectClass=computer)"
#define CLASS_USER                  L"(objectClass=user)"
#define CLASS_SERVER                L"(objectClass=server)"



#define CATEGORY_ANY                L"(objectCategory=*)"
#define CATEGORY_CXTION             L"(objectCategory=nTDSConnection)"
#define CATEGORY_MEMBER             L"(objectCategory=nTFRSMember)"
#define CATEGORY_REPLICA_SET        L"(objectCategory=nTFRSReplicaSet)"
#define CATEGORY_NTFRS_SETTINGS     L"(objectCategory=nTFRSSettings)"
#define CATEGORY_NTDS_SETTINGS      L"(objectCategory=nTDSSettings)"
#define CATEGORY_SUBSCRIBER         L"(objectCategory=nTFRSSubscriber)"
#define CATEGORY_SUBSCRIPTIONS      L"(objectCategory=nTFRSSubscriptions)"
#define CATEGORY_NTDS_DSA           L"(objectCategory=nTDSDSA)"
#define CATEGORY_COMPUTER           L"(objectCategory=computer)"
#define CATEGORY_USER               L"(objectCategory=user)"
#define CATEGORY_SERVER             L"(objectCategory=server)"

//
// Codes for the various Config Node to Object Type mappings
//   Note: Update string array DsConfigTypeName[] when this changes.
//
#define CONFIG_TYPE_UNDEFINED       (0)
#define CONFIG_TYPE_IN_CXTION       (1)
#define CONFIG_TYPE_MEMBER          (2)
#define CONFIG_TYPE_REPLICA_SET     (3)
#define CONFIG_TYPE_NTFRS_SETTINGS  (4)
#define CONFIG_TYPE_NTDS_SETTINGS   (5)
#define CONFIG_TYPE_SUBSCRIBER      (6)
#define CONFIG_TYPE_SUBSCRIPTIONS   (7)
#define CONFIG_TYPE_NTDS_DSA        (8)
#define CONFIG_TYPE_COMPUTER        (9)
#define CONFIG_TYPE_USER            (10)
#define CONFIG_TYPE_SERVER          (11)
#define CONFIG_TYPE_SERVICES_ROOT   (12)
#define CONFIG_TYPE_OUT_CXTION      (13)


#define ATTR_DIRECTORY_FILTER       L"frsDirectoryFilter"
#define ATTR_FILE_FILTER            L"frsFileFilter"
#define ATTR_NEW_SET_GUID           L"frsReplicaSetGUID"
#define ATTR_OLD_SET_GUID           L"replicaSetGUID"
#define ATTR_CLASS                  L"objectClass"
#define ATTR_DN                     L"distinguishedName"
#define ATTR_OBJECT_GUID            L"objectGUID"
#define ATTR_SCHEDULE               L"schedule"
#define ATTR_NEW_VERSION_GUID       L"frsVersionGuid"
#define ATTR_OLD_VERSION_GUID       L"replicaVersionGuid"
#define ATTR_REPLICA_SET            L"nTFRSReplicaSet"
#define ATTR_NTFRS_SETTINGS         L"nTFRSSettings"
#define ATTR_SERVER                 L"server"
#define ATTR_MEMBER                 L"nTFRSMember"
#define ATTR_REPLICA_ROOT           L"frsRootPath"
#define ATTR_REPLICA_STAGE          L"frsStagingPath"
#define ATTR_FROM_SERVER            L"fromServer"
#define ATTR_PRIMARY_MEMBER         L"frsPrimaryMember"
#define ATTR_SCHEDULE               L"schedule"
#define ATTR_USN_CHANGED            L"uSNChanged"
#define ATTR_FRS_FLAGS              L"fRSFlags"
#define ATTR_NAMING_CONTEXTS        L"namingContexts"
#define ATTR_DEFAULT_NAMING_CONTEXT L"defaultNamingContext"
#define ATTR_COMPUTER_REF           L"frsComputerReference"
#define ATTR_COMPUTER_REF_BL        L"frsComputerReferenceBL"
#define ATTR_SERVER_REF             L"ServerReference"
#define ATTR_SERVER_REF_BL          L"ServerReferenceBL"
#define ATTR_MEMBER_REF             L"frsMemberReference"
#define ATTR_MEMBER_REF_BL          L"frsMemberReferenceBL"
#define ATTR_WORKING                L"frsWorkingPath"
#define ATTR_SET_TYPE               L"frsReplicaSetType"
#define ATTR_SUBSCRIPTIONS          L"nTFRSSubscriptions"
#define ATTR_SUBSCRIBER             L"nTFRSSubscriber"
#define ATTR_CN                     L"cn"
#define ATTR_EXTENSIONS             L"frsExtensions"
#define ATTR_SAM                    L"sAMAccountName"
#define ATTR_CXTION                 L"nTDSConnection"
#define ATTR_ENABLED_CXTION         L"enabledConnection"
#define ATTR_OPTIONS                L"options"
#define ATTR_TRANSPORT_TYPE         L"transportType"
#define ATTR_USER_ACCOUNT_CONTROL   L"userAccountControl"
#define ATTR_DNS_HOST_NAME          L"dNSHostName"
#define ATTR_SERVICE_PRINCIPAL_NAME L"servicePrincipalName"
#define ATTR_TRUE                   L"TRUE"
#define ATTR_FALSE                  L"FALSE"
#define ATTR_WHEN_CHANGED           L"whenChanged"
#define ATTR_WHEN_CREATED           L"whenCreated"

#define CN_ROOT                     L""
#define CN_SYSVOLS                  L"Microsoft System Volumes"
#define CN_ENTERPRISE_SYSVOL        NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE
#define CN_SERVERS                  L"Servers"
#define CN_NTDS_SETTINGS            L"ntds settings"
#define CN_SUBSCRIPTIONS            L"NTFRS Subscriptions"
#define CN_COMPUTERS                L"Computers"
#define CN_DOMAIN_CONTROLLERS       L"Domain Controllers"
#define CN_SERVICES                 L"Services"
#define CN_SITES                    L"Sites"
#define CN_SYSTEM                   L"System"
#define CN_NTFRS_SETTINGS           L"File Replication Service"
#define CN_DOMAIN_SYSVOL            L"Domain System Volume (SYSVOL share)"

//
// Some useful ldap macroes
//
#define LDAP_FREE_MSG(x)        {if (x) {ldap_msgfree(x); (x) = NULL;}}
#define LDAP_FREE_VALUES(x)     {if (x) {ldap_value_free(x); (x) = NULL;}}
#define LDAP_FREE_BER_VALUES(x) {if (x) {ldap_value_free_len(x); (x) = NULL;}}

//
// DS Poller
//
VOID
FrsDsInitialize(
    VOID
    );

DWORD
FrsDsSetDsPollingInterval(
    IN ULONG    UseShortInterval,
    IN DWORD    LongInterval,
    IN DWORD    ShortInterval
    );

DWORD
FrsDsGetDsPollingInterval(
    OUT ULONG    *Interval,
    OUT ULONG    *LongInterval,
    OUT ULONG    *ShortInterval
    );


DWORD
FrsDsStartDemotion(
    IN PWCHAR   ReplicaSetName
    );

DWORD
FrsDsCommitDemotion(
    VOID
    );


//
// Default File and Directory filter lists.
//
//    The compiled in default is only used if no value is supplied in
//    EITHER the DS or the Registry.
//    The table below shows how the final filter is formed.
//
//    value      Value
//    supplied  supplied        Resulting filter string Used
//    in DS     in Registry
//      No        No             DEFAULT_xxx_FILTER_LIST
//      No        Yes            Value from registry
//      Yes       No             Value from DS
//      Yes       Yes            Value from DS + Value from registry
//
//
#define FRS_DS_COMPOSE_FILTER_LIST(_DsFilterList, _RegFilterList, _DefaultFilterList) \
                                                                               \
    (((_DsFilterList) != NULL) ?                                               \
        (   ((_RegFilterList) != NULL) ?                                       \
            FrsWcsCat3((_DsFilterList), L",", (_RegFilterList)) :              \
            FrsWcsDup((_DsFilterList))                                         \
        ) :                                                                    \
        (   ((_RegFilterList) != NULL) ?                                       \
            FrsWcsDup((_RegFilterList)) :                                      \
            FrsWcsDup((_DefaultFilterList))                                    \
        )                                                                      \
     )

//
// Add a new message to the ds polling summary.
//
#define FRS_DS_ADD_TO_POLL_SUMMARY(_DsPollSummaryBuf, _NewMessage, _NewMessageLen)  \
                                                                                    \
        if ((DsPollSummaryBufLen + _NewMessageLen) > DsPollSummaryMaxBufLen ) {     \
            PWCHAR  _TempDsPollSummaryBuf = NULL;                                   \
            _TempDsPollSummaryBuf = FrsAlloc(DsPollSummaryMaxBufLen + 2 * 1000);    \
            DsPollSummaryMaxBufLen += (2 * 1000);                                   \
            CopyMemory(_TempDsPollSummaryBuf, DsPollSummaryBuf, DsPollSummaryBufLen);   \
            FrsFree(DsPollSummaryBuf);                                              \
            DsPollSummaryBuf = _TempDsPollSummaryBuf;                               \
        }                                                                           \
                                                                                    \
        CopyMemory(&DsPollSummaryBuf[DsPollSummaryBufLen/2], _NewMessage, _NewMessageLen);\
        DsPollSummaryBufLen += _NewMessageLen;


//
// FRS Dummy event logging routines
//
extern VOID LogFrsException(FRS_ERROR_CODE, ULONG_PTR, PWCHAR);
extern VOID LogException(DWORD, PWCHAR);

//
// FRS Exception Handling
//
extern VOID      FrsRaiseException(FRS_ERROR_CODE, ULONG_PTR);
extern DWORD     FrsException(EXCEPTION_POINTERS *);
extern DWORD     FrsExceptionLastCode(VOID);
extern ULONG_PTR FrsExceptionLastInfo(VOID);
extern VOID      FrsExceptionQuiet(BOOL);
extern PVOID     MallocException(DWORD);

//
// FRS Events
//
extern HANDLE   ShutDownEvent;      // shutdown the service
extern HANDLE   DataBaseEvent;      // database is up and running
extern HANDLE   JournalEvent;       // journal is up and running
extern HANDLE   ChgOrdEvent;        // Change order accept is up and running
extern HANDLE   ReplicaEvent;       // replica is up and running
extern HANDLE   CommEvent;          // communication is up and running
extern HANDLE   DsPollEvent;        // used to poll the ds
extern HANDLE   DsShutDownComplete; // ds polling thread has shut down
extern HANDLE   FrsThawEvent;       // Used to signal end of freeze.
                                    // FrsThawEvent is used by backup.
extern HANDLE   FrsNoInstallsInProgressEvent; // Used by Install CS to signal that
                                              // there are no installs in progress.
                                              // Used by backup.

//
// FRS Global flags
//
extern BOOL EventLogIsRunning;  // is the event log service up and running?
extern BOOL RpcssIsRunning;     // is the rpc endpoint service up and running?

//
// Main Initialization
//
VOID
MainInit(
    VOID
    );

//
// Outbound Log Processor
//
VOID
OutLogInitialize(
    VOID
    );

VOID
ShutDownOutLog(
    VOID
    );

//
// Vv Join
//
VOID
SubmitVvJoin(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    );

DWORD
SubmitVvJoinSync(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    );

//
// FRS RPC
//
//
// The protocols sequences we think we know how to support
//     XXX these constants should be in a win header file!
//
#define PROTSEQ_TCP_IP      L"ncacn_ip_tcp"

//
// Perfmon APIs come over the local rpc.
//
#define PROTSEQ_LRPC      L"ncalrpc"

//
// All computer names passed to RpcStringBindingCompose() using PROTSEQ_TCP_IP
// need to have the leading two back slashes removed or the call fails with
// RPC_S_SERVER_UNAVAILABLE.
//
#define FRS_TRIM_LEADING_2SLASH(_Name_)                                       \
        if (((_Name_) != NULL)           &&                                   \
            (wcslen(_Name_) > 1)         &&                                   \
            ((_Name_)[0] == L'\\' )      &&                                   \
            ((_Name_)[1] == L'\\')) {                                         \
            (_Name_) += 2;                                                    \
        }

DWORD
FrsRpcBindToServer(
    IN  PGNAME   Name,
    IN  PWCHAR   PrincName,
    IN  ULONG    AuthLevel,
    OUT handle_t *Handle
    );

BOOL
FrsRpcInitialize(
    VOID
    );

VOID
FrsRpcUnInitialize(
    VOID
    );

VOID
FrsRpcUnBindFromServer(
    handle_t *Handle
    );


//
// FRS threads
//
#if DBG
DWORD
FrsTest(
    PVOID
    );
#endif DBG

//
// FRS Thread Management Support
//
VOID
ThSupSubmitThreadExitCleanup(
    PFRS_THREAD
    );

VOID
ThSupInitialize(
    VOID
    );

DWORD
ThSupExitThreadGroup(
    DWORD (*)(PVOID)
    );

VOID
ThSupExitSingleThread(
    PFRS_THREAD
    );

DWORD
ThSupWaitThread(
    PFRS_THREAD FrsThread,
    DWORD Millisec
    );

PVOID
ThSupGetThreadData(
    PFRS_THREAD
    );

PFRS_THREAD
ThSupGetThread(
    DWORD (*)(PVOID)
    );

VOID
ThSupReleaseRef(
    PFRS_THREAD
    );

BOOL
ThSupCreateThread(
    PWCHAR Name,
    PVOID Param,
    DWORD (*Main)(PVOID),
    DWORD (*Exit)(PVOID)
    );

DWORD
ThSupExitThreadNOP(
    PVOID
    );

DWORD
ThSupExitWithTombstone(
    PVOID
    );

//
// shutdown functions called by ShutDown()
//
extern VOID ShutDownRpc(VOID);      // Cleanup after StartRpc thread

//
// Globals
//
extern WCHAR    ComputerName[MAX_COMPUTERNAME_LENGTH + 2];  // A useful piece of info
extern PWCHAR   ComputerDnsName;                            // A useful piece of info

//
// Service functions
//
DWORD
FrsGetServiceState(
    PWCHAR,
    PWCHAR
    );

BOOL
FrsWaitService(
    PWCHAR,
    PWCHAR,
    INT,
    INT
    );

BOOL
FrsIsServiceRunning(
    PWCHAR,
    PWCHAR
    );

DWORD
FrsSetServiceStatus(
    IN DWORD    Status,
    IN DWORD    CheckPoint,
    IN DWORD    Hint,
    IN DWORD    ExitCode
    );

//
// FRS Version Vector
//

#define LOCK_GEN_TABLE(_vv_)                                \
    GTabLockTable(_vv_);                                    \
    DPRINT1(5, "LOCK_GEN_TABLE: "#_vv_":%08x\n", _vv_);

#define UNLOCK_GEN_TABLE(_vv_)                              \
    DPRINT1(5, "UNLOCK_GEN_TABLE: "#_vv_":%08x\n", _vv_);   \
    GTabUnLockTable(_vv_);

PGEN_TABLE
VVDupOutbound(
    IN PGEN_TABLE   VV
    );

ULONG
VVReserveRetireSlot(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  Coe
    );

ULONG
VVRetireChangeOrder(
    IN PTHREAD_CTX          ThreadCtx,
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN ULONG                CleanUpFlags
    );

PCHANGE_ORDER_ENTRY
VVReferenceRetireSlot(
    IN PREPLICA  Replica,
    IN PCHANGE_ORDER_COMMAND CoCmd
    );

VOID
VVUpdate(
    IN PGEN_TABLE   VV,
    IN ULONGLONG    Vsn,
    IN GUID         *Guid
    );

VOID
VVInsertOutbound(
    IN PGEN_TABLE   VV,
    IN PGVSN        GVsn
    );

VOID
VVUpdateOutbound(
    IN PGEN_TABLE   VV,
    IN PGVSN        GVsn
    );

BOOL
VVHasVsnNoLock(
    IN PGEN_TABLE   VV,
    IN GUID         *OriginatorGuid,
    IN ULONGLONG    Vsn
    );

BOOL
VVHasOriginatorNoLock(
    IN PGEN_TABLE   VV,
    IN GUID         *OriginatorGuid
    );

BOOL
VVHasVsn(
    IN PGEN_TABLE               VV,
    IN PCHANGE_ORDER_COMMAND    Coc
    );

PGVSN
VVGetGVsn(
    IN PGEN_TABLE VV,
    IN GUID       *Guid
    );

PVOID
VVFreeOutbound(
    IN PGEN_TABLE VV
    );

VOID
VVFree(
    IN PGEN_TABLE VV
    );

#if DBG
#define VV_PRINT(_Severity_, _Header_, _VV_)                                \
        DPRINT1(_Severity_, "++ VV_PRINT :%08x\n", _VV_);                   \
        VVPrint(_Severity_, _Header_, _VV_, FALSE)
#define VV_PRINT_OUTBOUND(_Severity_, _Header_, _VV_)                       \
        DPRINT1(_Severity_, "++ VV_PRINT_OUTBOUND :%08x\n", _VV_);          \
        VVPrint(_Severity_, _Header_, _VV_, TRUE)
VOID
VVPrint(
    IN ULONG        Severity,
    IN PWCHAR       Header,
    IN PGEN_TABLE   VV,
    IN BOOL         IsOutbound
    );

#else DBG

#define VV_PRINT(_Severity_, _Header_, _VV_)
#define VV_PRINT_OUTBOUND(_Severity_, _Header_, _VV_)

#endif DBG

//
// FRS Generic Table Routines
//
PGEN_TABLE
GTabAllocTable(
    VOID
    );

PGEN_TABLE
GTabAllocNumberTable(
    VOID
    );

PGEN_TABLE
GTabAllocFileTimeTable(
    VOID
    );

PGEN_TABLE
GTabAllocStringTable(
    VOID
    );

PGEN_TABLE
GTabAllocStringAndBoolTable(
    VOID
    );

VOID
GTabEmptyTableNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    );

VOID
GTabEmptyTable(
    IN PGEN_TABLE   GTable,
    IN PVOID        (*CallerFree)(PVOID)
    );

PVOID
GTabFreeTable(
    PGEN_TABLE,
    PVOID (*)(PVOID)
    );

PVOID
GTabLookup(
    PGEN_TABLE,
    PVOID,
    PWCHAR
    );

BOOL
GTabIsEntryPresent(
    IN PGEN_TABLE   GTable,
    IN GUID         *Key1,
    IN PWCHAR       Key2
    );

PVOID
GTabLookupTableString(
    IN PGEN_TABLE   GTable,
    IN PWCHAR       Key1,
    IN PWCHAR       Key2
    );

PVOID
GTabLookupNoLock(
    PGEN_TABLE,
    PVOID,
    PWCHAR
    );

PGEN_ENTRY
GTabLookupEntryNoLock(
    PGEN_TABLE,
    PVOID,
    PWCHAR
    );

PGEN_ENTRY
GTabNextEntryNoLock(
    PGEN_TABLE,
    PVOID
    );

PVOID
GTabNextDatumNoLock(
    IN PGEN_TABLE  GTable,
    IN PVOID       *Key
    );

PVOID
GTabNextDatum(
    PGEN_TABLE,
    PVOID
    );

DWORD
GTabNumberInTable(
    PGEN_TABLE
    );

VOID
GTabLockTable(
    PGEN_TABLE
    );

VOID
GTabUnLockTable(
    PGEN_TABLE
    );

PVOID
GTabInsertUniqueEntry(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN PVOID        Key1,
    IN PVOID        Key2
    );

PVOID
GTabInsertUniqueEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN PVOID        Key1,
    IN PVOID        Key2
    );

VOID
GTabInsertEntry(
    PGEN_TABLE,
    PVOID,
    PVOID,
    PWCHAR
    );

VOID
GTabInsertEntryNoLock(
    IN PGEN_TABLE   GTable,
    IN PVOID        NewData,
    IN PVOID        Key1,
    IN PWCHAR       Key2
    );

VOID
GTabDelete(
    PGEN_TABLE,
    PVOID,
    PWCHAR,
    PVOID (*)(PVOID)
    );

VOID
GTabDeleteNoLock(
    PGEN_TABLE,
    PVOID,
    PWCHAR,
    PVOID (*)(PVOID)
    );

VOID
GTabPrintTable(
    PGEN_TABLE
    );

//
// GNAME
//
PVOID
FrsFreeGName(
    PVOID
    );

PGNAME
FrsBuildGName(
    GUID *,
    PWCHAR
    );

PGVSN
FrsBuildGVsn(
    GUID *,
    ULONGLONG
    );

PGNAME
FrsCopyGName(
    GUID *,
    PWCHAR
    );

PGNAME
FrsDupGName(
    PGNAME
    );

VOID
FrsPrintGName(
    PGNAME
    );

VOID
FrsPrintGuid(
    GUID *
    );

GUID *
FrsDupGuid(
    GUID *
    );

//
// FRS REPLICA COMMAND SERVER
//

#define FRS_CO_COMM_PROGRESS(_sev, _cmd, _sn, _partner, _text)               \
DPRINT7(_sev, ":: CoG %08x, CxtG %08x, Sn %5d, vsn %08x %08x, FN: %-15ws, [%s], %ws\n", \
    (_cmd)->ChangeOrderGuid.Data1,                                           \
    (_cmd)->CxtionGuid.Data1,                                                \
    (_sn),                                                                   \
    PRINTQUAD((_cmd)->FrsVsn),                                               \
    (_cmd)->FileName,                                                        \
    (_text),                                                                 \
    (_partner));



#define FRS_CO_FILE_PROGRESS(_F_, _V_, _M_) \
    DPRINT3(0, ":V: %-11ws (%08x): %s\n", _F_, (ULONG)(_V_), _M_);

#define FRS_CO_FILE_PROGRESS_WSTATUS(_F_, _V_, _M_, _W_) \
    DPRINT4(0, ":V: %-11ws (%08x): %s (%d)\n", _F_, (ULONG)(_V_), _M_, _W_);


VOID
RcsInitializeReplicaCmdServer(
    VOID
    );

VOID
RcsFrsUnInitializeReplicaCmdServer(
    VOID
    );

VOID
RcsShutDownReplicaCmdServer(
    VOID
    );

PREPLICA
RcsFindReplicaByNumber(
    IN ULONG ReplicaNumber
    );

PREPLICA
RcsFindReplicaByGuid(
    IN GUID *Guid
    );

PREPLICA
RcsFindReplicaById(
    IN ULONG Id
    );

PREPLICA
RcsFindSysVolByName(
    IN PWCHAR ReplicaSetName
    );

PREPLICA
RcsFindSysVolByType(
    IN DWORD ReplicaSetType
    );

PREPLICA
RcsFindNextReplica(
    IN PVOID *Key
    );

VOID
RcsSubmitReplicaCxtion(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    );

DWORD
RcsSubmitReplicaSync(
    IN PREPLICA Replica,
    IN PREPLICA NewReplica, OPTIONAL
    IN PCXTION  VolatileCxtion,  OPTIONAL
    IN USHORT   Command
    );

VOID
RcsSubmitReplica(
    IN PREPLICA Replica,
    IN PREPLICA NewReplica, OPTIONAL
    IN USHORT   Command
    );

DWORD
RcsCreateReplicaSetMember(
    IN PREPLICA Replica
    );

VOID
RcsMergeReplicaFromDs(
    IN PREPLICA Replica
    );

VOID
RcsBeginMergeWithDs(
    VOID
    );

VOID
RcsEndMergeWithDs(
    VOID
    );

ULONG
RcsSubmitCommPktWithErrorToRcs(
    IN PCOMM_PACKET     CommPkt
    );

VOID
RcsSubmitTransferToRcs(
    IN PCOMMAND_PACKET  Cmd,
    IN USHORT           Command
    );

VOID
RcsCmdPktCompletionRoutine(
    IN PCOMMAND_PACKET  Cmd,
    IN PVOID            Arg
    );

VOID
RcsSubmitRemoteCoInstallRetry(
    IN PCHANGE_ORDER_ENTRY  Coe
    );

VOID
RcsSubmitRemoteCoAccepted(
    IN PCHANGE_ORDER_ENTRY  Coe
    );

VOID
RcsSubmitLocalCoAccepted(
    IN PCHANGE_ORDER_ENTRY  Coe
    );

VOID
RcsInboundCommitOk(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  Coe
    );

BOOL
RcsSendCoToOneOutbound(
    IN PREPLICA                 Replica,
    IN PCXTION                  Cxtion,
    IN PCHANGE_ORDER_COMMAND    Coc
    );

PCXTION
RcsCheckCxtion(
    IN PCOMMAND_PACKET  Cmd,
    IN PCHAR            Debsub,
    IN ULONG            Flags
    );

//
// Flags for RcsCheckCxtion
//
#define CHECK_CXTION_EXISTS      (0x00000001)
#define CHECK_CXTION_INBOUND     (0x00000002)
#define CHECK_CXTION_OUTBOUND    (0x00000004)
#define CHECK_CXTION_JRNLCXTION  (0x00000008)

#define CHECK_CXTION_JOINGUID    (0x00000010)
#define CHECK_CXTION_JOINED      (0x00000020)
#define CHECK_CXTION_VVECTOR     (0x00000040)
#define CHECK_CXTION_PARTNER     (0x00000080)

#define CHECK_CXTION_AUTH        (0x00000100)
#define CHECK_CXTION_FIXJOINED   (0x00000200)
#define CHECK_CXTION_UNJOINGUID  (0x00000400)
#define CHECK_CXTION_FOR_FETCHCS (0x00000800)


#define CHECK_CXTION_JOIN_OK (CHECK_CXTION_EXISTS   |      \
                              CHECK_CXTION_JOINED   |      \
                              CHECK_CXTION_JOINGUID )


//
// FRS COMMAND SERVER
//
VOID
FrsSubmitCommandServer(
    PCOMMAND_SERVER,
    PCOMMAND_PACKET
    );

ULONG
FrsSubmitCommandServerAndWait(
    IN PCOMMAND_SERVER  Cs,
    IN PCOMMAND_PACKET  Cmd,
    IN ULONG            Timeout
    );

VOID
FrsKickCommandServer(
    PCOMMAND_SERVER
    );

PCOMMAND_PACKET
FrsGetCommandServer(
    PCOMMAND_SERVER
    );

PCOMMAND_PACKET
FrsGetCommandServerIdled(
    IN  PCOMMAND_SERVER,
    OUT PFRS_QUEUE *
    );

PCOMMAND_PACKET
FrsGetCommandServerTimeout(
    IN  PCOMMAND_SERVER,
    IN  ULONG,
    OUT PBOOL
    );

PCOMMAND_PACKET
FrsGetCommandServerTimeoutIdled(
    IN  PCOMMAND_SERVER,
    IN  ULONG,
    OUT PFRS_QUEUE *,
    OUT PBOOL
    );

DWORD
FrsWaitForCommandServer(
    PCOMMAND_SERVER,
    DWORD
    );

VOID
FrsExitCommandServer(
    PCOMMAND_SERVER,
    PFRS_THREAD
    );

VOID
FrsRunDownCommandServer(
    PCOMMAND_SERVER,
    PFRS_QUEUE
    );

VOID
FrsCancelCommandServer(
    PCOMMAND_SERVER,
    PFRS_QUEUE
    );

VOID
FrsInitializeCommandServer(
    PCOMMAND_SERVER,
    DWORD,
    PWCHAR,
    DWORD (*)(PVOID)
    );

VOID
FrsDeleteCommandServer(
    PCOMMAND_SERVER
    );

//
// FRS STAGING FILE GENERATOR SERVER
//
VOID
ShutDownStageCs(
    VOID
    );

VOID
FrsStageCsInitialize(
    VOID
    );

VOID
FrsStageCsUnInitialize(
    VOID
    );

VOID
FrsStageCsSubmitTransfer(
    IN PCOMMAND_PACKET,
    IN USHORT
    );

BOOL
StageDeleteFile(
    IN PCHANGE_ORDER_COMMAND Coc,
    IN PREPLICA Replica,
    IN BOOL Acquire
    );

DWORD
StageAcquire(
    IN     GUID         *ChangeOrderGuid,
    IN     PWCHAR       Name,
    IN     ULONGLONG    FileSize,
    IN OUT PULONG       Flags,
    IN     DWORD        ReplicaNumber,
    OUT    GUID         *CompressionFormatUsed
    );

VOID
StageRelease(
    IN GUID         *ChangeOrderGuid,
    IN PWCHAR       Name,
    IN ULONG        Flags,
    IN PULONGLONG   SizeOfFileGenerated,
    IN FILETIME     *LastAccessTime,
    OUT GUID        *CompressionFormatUsed
    );

VOID
StageReleaseNotRecovered(
    );

VOID
StageReleaseAll(
    );


//
// The argument functions passed to the get compression / decompression routines.
//

typedef
DWORD
(NTAPI *PFRS_DECOMPRESS_BUFFER) (
    OUT PUCHAR  DecompressedBuf,
    IN  DWORD   DecompressedBufLen,
    IN  PUCHAR  CompressedBuf,
    IN  DWORD   CompressedBufLen,
    OUT DWORD   *pDecompressedSize,
    OUT DWORD   *pBytesProcessed,
    OUT PVOID   *pDecompressContext
    );
/*++

Arguments:
    DecompressedBuf    : Resultant decompressed buffer.
    DecompressedBufLen : Max size of decompressed buffer.
    CompressedBuf      : Input buffer.
    CompressedBufLen   : Input buffer length.
    pDecompressedSize  : Size of decompressed buffer.
    pBytesProcessed    : Total bytes processed (could be over multiple calls to this function)
    pDecompressContext : Decompress context returned if multiple calls are needed to
                         decompress this buffer. Valid context is returned when ERROR_MORE_DATA
                         is returned.

Return Value:
    Win Status

--*/

typedef
PVOID
(NTAPI *PFRS_FREE_DECOMPRESS_BUFFER) (
    IN PVOID   *pDecompressContext
    );
/*++

Arguments:
    pDecompressContext : Decompress context to free.

Return Value:
    NULL ptr

--*/


typedef
DWORD
(NTAPI *PFRS_COMPRESS_BUFFER) (
    IN  PUCHAR UnCompressedBuf,
    IN  DWORD  UnCompressedBufLen,
    OUT PUCHAR CompressedBuf,
    IN  DWORD  CompressedBufLen,
    OUT DWORD  *pCompressedSize
    );
/*++

    UnCompressedBuf    : Source buffer.
    UnCompressedBufLen : Length of source buffer.
    CompressedBuf      : Resultant compressed buffer.
    CompressedBufLen   : Length of compressed buffer supplied.
    CompressedSize     : Actual size of the compressed data.

Return Value:
    Win Status

--*/

DWORD
FrsGetCompressionRoutine(
    IN  PWCHAR   FileName,
    IN  HANDLE   FileHandle,
    OUT PFRS_COMPRESS_BUFFER *ppFrsCompressBuffer,
    //OUT DWORD    (**ppFrsCompressBuffer)(
    //                                     IN UnCompressedBuf,
    //                                     IN UnCompressedBufLen,
    //                                     CompressedBuf,
    //                                     CompressedBufLen,
    //                                     CompressedSize),
    OUT GUID     *pCompressionFormatGuid
    );

DWORD
FrsGetDecompressionRoutine(
    IN  PCHANGE_ORDER_COMMAND        Coc,
    IN  PSTAGE_HEADER                StageHeader,
    OUT PFRS_DECOMPRESS_BUFFER      *ppFrsDecompressBuffer,
    OUT PFRS_FREE_DECOMPRESS_BUFFER *ppFrsFreeDecompressContext
    //OUT DWORD (**ppFrsDecompressBuffer)(OUT DecompressedBuf,
    //                                    IN DecompressedBufLen,
    //                                    IN CompressedBuf,
    //                                    IN CompressedBufLen,
    //                                    OUT DecompressedSize,
    //                                    OUT BytesProcessed),
    //OUT PVOID (**ppFrsFreeDecompressContext)(IN pDecompressContext)
    );

DWORD
FrsGetDecompressionRoutineByGuid(
    IN  GUID                        *CompressionFormatGuid,
    OUT PFRS_DECOMPRESS_BUFFER      *ppFrsDecompressBuffer,
    OUT PFRS_FREE_DECOMPRESS_BUFFER *ppFrsFreeDecompressContext
    //OUT DWORD (**ppFrsDecompressBuffer)(OUT DecompressedBuf,
    //                                    IN DecompressedBufLen,
    //                                    IN CompressedBuf,
    //                                    IN CompressedBufLen,
    //                                    OUT DecompressedSize,
    //                                    OUT BytesProcessed),
    //OUT PVOID (**ppFrsFreeDecompressContext)(IN pDecompressContext)
    );





BOOL
FrsDoesCoAlterNameSpace(
    IN PCHANGE_ORDER_COMMAND Coc
    );

BOOL
FrsDoesCoNeedStage(
    IN PCHANGE_ORDER_COMMAND Coc
    );

DWORD
FrsVerifyVolume(
    IN PWCHAR   Name,
    IN PWCHAR   SetName,
    IN ULONG    Flags
    );

DWORD
FrsDoesDirectoryExist(
    IN  PWCHAR   Name,
    OUT PDWORD   pAttributes
    );

DWORD
FrsCheckForNoReparsePoint(
    IN PWCHAR   Name
    );

DWORD
FrsDoesFileExist(
    IN PWCHAR   Name
    );

DWORD
FrsCreateDirectory(
    IN PWCHAR
    );

DWORD
StuCreateFile(
    IN  PWCHAR,
    OUT PHANDLE
    );

DWORD
FrsDeleteFile(
    IN PWCHAR
    );

DWORD
StuWriteFile(
    IN PWCHAR,
    IN HANDLE,
    IN PVOID,
    IN DWORD
    );

DWORD
StuReadFile(
    IN PWCHAR,
    IN HANDLE,
    IN PVOID,
    IN DWORD,
    IN PULONG
    );

BOOL
StuReadBlockFile(
    IN PWCHAR,
    IN HANDLE,
    IN PVOID,
    IN DWORD
    );

DWORD
FrsSetCompression(
    IN PWCHAR,
    IN HANDLE,
    IN USHORT
    );

DWORD
FrsGetCompression(
    IN PWCHAR,
    IN HANDLE,
    IN PUSHORT
    );

DWORD
FrsSetFilePointer(
    IN PWCHAR,
    IN HANDLE,
    IN ULONG,
    IN ULONG
    );

DWORD
FrsSetFileTime(
    IN PWCHAR,
    IN HANDLE,
    IN FILETIME *,
    IN FILETIME *,
    IN FILETIME *
    );

DWORD
FrsSetEndOfFile(
    IN PWCHAR,
    IN HANDLE
    );

BOOL
FrsGetFileInfoByHandle(
    IN  PWCHAR,
    IN  HANDLE,
    OUT PFILE_NETWORK_OPEN_INFORMATION
    );

DWORD
FrsFlushFile(
    IN PWCHAR,
    IN HANDLE
    );

DWORD
StuOpenFile(
    IN  PWCHAR,
    IN  DWORD,
    OUT PHANDLE
    );

DWORD
FrsSetFileAttributes(
    IN PWCHAR,
    IN HANDLE,
    IN ULONG
    );

BOOL
FrsCreateStageName(
    IN  GUID *,
    OUT PWCHAR *
    );

PWCHAR
StuCreStgPath(
    IN PWCHAR,
    IN GUID *,
    IN PWCHAR
    );

DWORD
StuInstallRename(
    IN PCHANGE_ORDER_ENTRY,
    IN BOOL,
    IN BOOL
    );

ULONG
StuInstallStage(
    IN PCHANGE_ORDER_ENTRY
    );

//
// FRS STAGING FILE FETCHER SERVER
//
VOID
ShutDownFetchCs(
    VOID
    );

VOID
FrsFetchCsInitialize(
    VOID
    );

VOID
FrsFetchCsSubmitTransfer(
    PCOMMAND_PACKET,
    USHORT
    );

//
// FRS STAGING FILE INSTALLER SERVER
//
VOID
ShutDownInstallCs(
    VOID
    );

VOID
FrsInstallCsInitialize(
    VOID
    );

VOID
FrsInstallCsSubmitTransfer(
    PCOMMAND_PACKET,
    USHORT
    );

//
// FRS INITIAL SYNC COOMMAND SERVER
//
VOID
ShutDownInitSyncCs(
    VOID
    );

VOID
InitSyncCsInitialize(
    VOID
    );

VOID
InitSyncCsSubmitTransfer(
    PCOMMAND_PACKET,
    USHORT
    );

VOID
InitSyncSubmitToInitSyncCs(
    IN PREPLICA Replica,
    IN USHORT   Command
    );

//
// FRS DELAYED SERVER
//
VOID
FrsDelCsSubmitSubmit(
    PCOMMAND_SERVER,
    PCOMMAND_PACKET,
    ULONG
    );

VOID
FrsDelQueueSubmit(
    IN PCOMMAND_PACKET  DelCmd,
    IN ULONG            Timeout
    );

VOID
FrsDelCsSubmitUnIdled(
    PCOMMAND_SERVER,
    PFRS_QUEUE,
    ULONG
    );

VOID
FrsDelCsSubmitKick(
    PCOMMAND_SERVER,
    PFRS_QUEUE,
    ULONG
    );

VOID
ShutDownDelCs(
    VOID
    );

VOID
FrsDelCsInitialize(
    VOID
    );

//
// FRS COMM SUBSYSTEM
//
BOOL
CommCheckPkt(
    PCOMM_PACKET
    );

BOOL
CommValidatePkt(
    PCOMM_PACKET
    );

VOID
CommDumpCommPkt(
    PCOMM_PACKET,
    DWORD
    );

//
// FRS utilities
//
DWORD
FrsForceOpenId(
    OUT PHANDLE                 Handle,
    OUT OVERLAPPED              *OpLock,
    IN  PVOLUME_MONITOR_ENTRY   pVme,
    IN  PVOID                   Id,
    IN  DWORD                   IdLen,
    IN  ACCESS_MASK             DesiredAccess,
    IN  ULONG                   CreateOptions,
    IN  ULONG                   ShareMode,
    IN  ULONG                   CreateDispostion
    );

DWORD
FrsRenameByHandle(
    IN PWCHAR  Name,
    IN ULONG   NameLen,
    IN HANDLE  Handle,
    IN HANDLE  TargetHandle,
    IN BOOL    ReplicaIfExists
    );

DWORD
FrsDeleteByHandle(
    IN PWCHAR  Name,
    IN HANDLE  Handle
    );

DWORD
FrsCheckObjectId(
    IN PWCHAR  Name,
    IN HANDLE  Handle,
    IN GUID    *Guid
    );

DWORD
FrsOpenBaseNameForInstall(
    IN  PCHANGE_ORDER_ENTRY Coe,
    OUT HANDLE              *Handle
    );

DWORD
FrsGetObjectId(
    IN  HANDLE Handle,
    OUT PFILE_OBJECTID_BUFFER ObjectIdBuffer
    );

#define GENERIC_PREFIX                     L"NTFRS_"
#define STAGE_FINAL_PREFIX                 GENERIC_PREFIX
#define STAGE_FINAL_COMPRESSED_PREFIX      L"NTFRS_CMP_"
#define PRE_INSTALL_PREFIX                 GENERIC_PREFIX
#define STAGE_GENERATE_PREFIX              L"NTFRS_G_"
#define STAGE_GENERATE_COMPRESSED_PREFIX   L"NTFRS_G_CMP_"
#define INSTALL_OVERRIDE_PREFIX            L"NTFRS_DELETED_FILE_"

PWCHAR
FrsCreateGuidName(
    IN GUID   *Guid,
    IN PWCHAR Prefix
    );

//
// MISC
//
VOID
FrsDsSwapPtrs(
    PVOID *,
    PVOID *
    );
#if DBG
#define INITIALIZE_HARD_WIRED() FrsDsInitializeHardWired()
VOID
FrsDsInitializeHardWired(
    VOID
    );
#else DBG
#define INITIALIZE_HARD_WIRED()
#endif DBG

//
// Outbound Log Processor
//
ULONG
OutLogSubmit(
    IN PREPLICA Replica,
    IN PCXTION  Cxtion,
    IN USHORT   Command
    );

//
// Database
//
JET_ERR
DbsUpdateTable(
    IN PTABLE_CTX TableCtx
    );

ULONG
DbsPackSchedule(
    IN PSCHEDULE    Schedule,
    IN ULONG        Fieldx,
    IN PTABLE_CTX   TableCtx
    );

ULONG
DbsPackStrW(
    IN PWCHAR       StrW,
    IN ULONG        Fieldx,
    IN PTABLE_CTX   TableCtx
    );

ULONG
DbsUnPackStrW(
    OUT PWCHAR      *StrW,
    IN  ULONG       Fieldx,
    IN  PTABLE_CTX  TableCtx
    );


//
// The subsystem commands below apply to an entire subsystem, e.g. the
// journal.  Some of the commands may not apply to a subsystem.
// The service level commands are the means to tell a subsystem that you
// want the subsystem to provide/perform a given service.  For example
// a PREPARE_SERVICE command sent to the Journal subsystem tells the
// journal to initialize journalling for a specified replica set.  Multiple
// prepare service commands are sent when the FRS first starts up.  They are
// then followed by a START_SUBSYSTEM command.  This way the journal knows
// to start processing the USN journal on a gvien volume at the lowest
// CommitUsn point for ANY replica set hosted by the volume.
//
// Some commands may not be implemented by all subsystems.  For example
// the PAUSE_SERVICE command is not provided for a single replica set
// as long as the FRS is running because we have to continuously monitor
// the journal so as not to lose data.  Some subsystems may not have any
// service level commands.
//

#define CMD_COMMAND_ERROR               0x00

#define CMD_INIT_SUBSYSTEM              0x01
#define CMD_START_SUBSYSTEM             0x02
#define CMD_STOP_SUBSYSTEM              0x03
#define CMD_PAUSE_SUBSYSTEM             0x04
#define CMD_QUERY_INFO_SUBSYSTEM        0x05
#define CMD_SET_CONFIG_SUBSYSTEM        0x06
#define CMD_QUERY_CONFIG_SUBSYSTEM      0x07
#define CMD_CANCEL_COMMAND_SUBSYSTEM    0x08
#define CMD_READ_SUBSYSTEM              0x09
#define CMD_WRITE_SUBSYSTEM             0x0A

#define CMD_PREPARE_SERVICE1            0x21
#define CMD_PREPARE_SERVICE2            0x22
#define CMD_START_SERVICE               0x23
#define CMD_STOP_SERVICE                0x24
#define CMD_PAUSE_SERVICE               0x25
#define CMD_QUERY_INFO_SERVICE          0x26
#define CMD_SET_CONFIG_SERVICE          0x27
#define CMD_QUERY_CONFIG_SERVICE        0x28
#define CMD_CANCEL_COMMAND_SERVICE      0x29
#define CMD_READ_SERVICE                0x2A
#define CMD_WRITE_SERVICE               0x2B
#define CMD_RESYNC_SERVICE              0x2C
#define CMD_VERIFY_SERVICE              0x2D

extern FRS_QUEUE    JournalProcessQueue;
extern FRS_QUEUE    DBServiceProcessQueue;

//
// Service UNIQUE Commands start at 0x100 for each service.
//


/***********************************************************
*                                                          *
*       Commands specific to the Journal service.          *
*                                                          *
***********************************************************/
// sequence break
#define CMD_JOURNAL_PAUSED                  0x101
#define CMD_JOURNAL_INIT_ONE_RS             0x102
#define CMD_JOURNAL_DELETE_DIR_FILTER_ENTRY 0x103
#define CMD_JOURNAL_CLEAN_WRITE_FILTER      0x104



/***********************************************************
*                                                          *
*       Commands specific to the Database service.         *
*                                                          *
***********************************************************/
// sequence break
#define CMD_CLOSE_TABLE                      0x101
#define CMD_UPDATE_RECORD_FIELDS             0x102
#define CMD_UPDATE_TABLE_RECORD              0x103
#define CMD_INSERT_TABLE_RECORD              0x104
#define CMD_READ_TABLE_RECORD                0x105
#define CMD_CREATE_REPLICA_SET_MEMBER        0x106
#define CMD_OPEN_REPLICA_SET_MEMBER          0x107
#define CMD_CLOSE_REPLICA_SET_MEMBER         0x108
#define CMD_LOAD_REPLICA_FILE_TREE           0x109
#define CMD_DELETE_REPLICA_SET_MEMBER        0x10A
#define CMD_DELETE_TABLE_RECORD              0x10B
#define CMD_CREATE_START_NEW_MEMBER          0x10C
#define CMD_LOAD_ONE_REPLICA_FILE_TREE       0x10D
#define CMD_STOP_REPLICATION_SINGLE_REPLICA  0x10E
#define CMD_DBS_RETIRE_INBOUND_CO            0x10F
#define CMD_DBS_RETRY_INBOUND_CO             0x110
#define CMD_DBS_RETIRE_REJECTED_CO           0x111
#define CMD_UPDATE_REPLICA_SET_MEMBER        0x112
#define CMD_DBS_REPLICA_SAVE_MARK            0x113
#define CMD_DBS_INJECT_OUTBOUND_CO           0x114
#define CMD_DBS_REPLICA_SERVICE_STATE_SAVE   0x115

//
// Given a ptr to a DB_SERVICE_REQUEST return the ptr to the data record.
//
#define DBS_GET_RECORD_ADDRESS(_DbsRequest) \
    ((_DbsRequest)->TableCtx->pDataRecord)

#define DBS_GET_TABLECTX(_DbsRequest) \
    ((_DbsRequest)->TableCtx)

#define DBS_FREE_TABLECTX(_DbsRequest)                              \
    DbsFreeTableCtx((_DbsRequest)->TableCtx, COMMAND_PACKET_TYPE);  \
    (_DbsRequest)->TableCtx = FrsFree((_DbsRequest)->TableCtx);

//
// The following access macros assume that the field buffers used for the record
// read and write operations are the same.  That is that both the Jet Set and
// Ret structs point to the same buffer.  They each take a table ctx parameter
// and a record field ID code (defined as an ENUM in schema.h).
//

// Get the field's receive buffer length.

#define DBS_GET_FIELD_SIZE(_TableCtx, _Field)  \
                          ((_TableCtx)->pJetRetCol[_Field].cbActual)

// Get the field's maximum buffer length.

#define DBS_GET_FIELD_SIZE_MAX( _TableCtx, _Field)  \
                              ((_TableCtx)->pJetRetCol[_Field].cbData)

// Get the address of the field's buffer.

#define DBS_GET_FIELD_ADDRESS( _TableCtx, _Field)  \
                             ((_TableCtx)->pJetRetCol[_Field].pvData)

//
// Set the size of the data in the field buffer.
// Warning - Don't do this on fixed size fields.
//
#define DBS_SET_FIELD_SIZE(_TableCtx, _Field, _NewSize)                        \
                          (_TableCtx)->pJetRetCol[_Field].cbActual = _NewSize; \
                          (_TableCtx)->pJetSetCol[_Field].cbData = _NewSize;

//
// Set the maximum size of the field buffer.
// Warning - Don't do this on fixed size fields.
// Warning - ONLY USE IF YOU KNOW WHAT YOU'RE DOING OTHERWISE USE DBS_REALLOC_FIELD
//
#define DBS_SET_FIELD_SIZE_MAX(_TableCtx, _Field, _NewSize)  \
                              (_TableCtx)->pJetRetCol[_Field].cbData = _NewSize;

// Set the address of the field's buffer.  It doesn't update the ptr in base record.
// Warning - Don't do this on fixed size fields.
// Warning - ONLY USE IF YOU KNOW WHAT YOU'RE DOING OTHERWISE USE DBS_REALLOC_FIELD

#define DBS_SET_FIELD_ADDRESS( _TableCtx, _Field, _NewAddr)  \
                             (_TableCtx)->pJetRetCol[_Field].pvData = _NewAddr; \
                             (_TableCtx)->pJetSetCol[_Field].pvData = _NewAddr;

//
// Reallocate the buffer size for a variable length binary field.
// Set _NewSize to zero to delete the buffer.
// Set _KeepData to TRUE if you want to copy the data from the old buffer to the new.
// This function also updates the buffer pointer in the base record.
//
#define DBS_REALLOC_FIELD(_TableCtx, _FieldIndex, _NewSize, _KeepData)  \
    DbsTranslateJetError(DbsReallocateFieldBuffer(_TableCtx,            \
                                                  _FieldIndex,          \
                                                  _NewSize,             \
                                                  _KeepData), TRUE)

#define DBS_ACCESS_BYKEY  0
#define DBS_ACCESS_FIRST  1
#define DBS_ACCESS_LAST   2
#define DBS_ACCESS_NEXT   3

#define DBS_ACCESS_MASK   (0xF)

//
// If set the close the table after completing the operation.
//
#define DBS_ACCESS_CLOSE          (0x80000000)
//
// If set then free the table context struct and the data record struct
// after completing the operation.  Useful on record inserts and the table
// close command.  (CMD_CLOSE_TABLE)
//
#define DBS_ACCESS_FREE_TABLECTX  (0x40000000)



/***********************************************************
*                                                          *
*     Commands specific to the Outbound Log subsystem.     *
*                                                          *
***********************************************************/
// sequence break
#define CMD_OUTLOG_WORK_CO             0x100
#define CMD_OUTLOG_ADD_REPLICA         0x101
#define CMD_OUTLOG_REMOVE_REPLICA      0x102
#define CMD_OUTLOG_INIT_PARTNER        0x103
#define CMD_OUTLOG_ADD_NEW_PARTNER     0x104
#define CMD_OUTLOG_DEACTIVATE_PARTNER  0x105
#define CMD_OUTLOG_ACTIVATE_PARTNER    0x106
#define CMD_OUTLOG_CLOSE_PARTNER       0x107
#define CMD_OUTLOG_REMOVE_PARTNER      0x108
#define CMD_OUTLOG_RETIRE_CO           0x109
#define CMD_OUTLOG_UPDATE_PARTNER      0x10A
#define CMD_OUTLOG_CLEANUP             0x10B



/***********************************************************
*                                                          *
*       Commands specific to the test subsystem.           *
*                                                          *
***********************************************************/
// sequence break
#define CMD_NOP                        0x100



/***********************************************************
*                                                          *
*   Commands specific to the replica command server        *
*                                                          *
***********************************************************/
// sequence break
//
//
#define CMD_UNKNOWN             0x100
#define CMD_START               0x108
#define CMD_DELETE              0x110
#define CMD_DELETE_RETRY        0x112
#define CMD_DELETE_NOW          0x114
#define CMD_START_REPLICAS      0x118
#define CMD_CHECK_SCHEDULES     0x119

#define CMD_JOIN_CXTION         0x120
#define CMD_NEED_JOIN           0x121
#define CMD_START_JOIN          0x122
#define CMD_JOINED              0x128
#define CMD_JOINING             0x130
#define CMD_JOINING_AFTER_FLUSH 0x131
#define CMD_VVJOIN_START        0x132
#define CMD_VVJOIN_SUCCESS      0x134
#define CMD_VVJOIN_DONE         0x136
#define CMD_VVJOIN_DONE_UNJOIN  0x138
#define CMD_UNJOIN              0x140
#define CMD_UNJOIN_REMOTE       0x148
#define CMD_CHECK_PROMOTION     0x150
#define CMD_HUNG_CXTION         0x160

#define CMD_LOCAL_CO_ACCEPTED   0x200
#define CMD_CREATE_STAGE        0x210
#define CMD_CREATE_EXISTING     0x212
#define CMD_CHECK_OID           0x214
#define CMD_REMOTE_CO           0x218
#define CMD_REMOTE_CO_ACCEPTED  0x220
#define CMD_SEND_STAGE          0x228
#define CMD_SENDING_STAGE       0x230
#define CMD_RECEIVING_STAGE     0x238
#define CMD_RECEIVED_STAGE      0x240
#define CMD_CREATED_EXISTING    0x242
#define CMD_RETRY_STAGE         0x243
#define CMD_RETRY_FETCH         0x244
#define CMD_SEND_RETRY_FETCH    0x245
#define CMD_ABORT_FETCH         0x246
#define CMD_SEND_ABORT_FETCH    0x247
#define CMD_INSTALL_STAGE       0x248
#define CMD_REMOTE_CO_DONE      0x250


/*****************************************************************
*                                                                *
*   Commands specific to the init sync controller command server *
*                                                                *
*****************************************************************/
// sequence break
//
//
#define CMD_INITSYNC_START_SYNC         0x100
#define CMD_INITSYNC_JOIN_NEXT          0x101
#define CMD_INITSYNC_START_JOIN         0x102
#define CMD_INITSYNC_VVJOIN_DONE        0x103
#define CMD_INITSYNC_KEEP_ALIVE         0x104
#define CMD_INITSYNC_CHECK_PROGRESS     0x105
#define CMD_INITSYNC_UNJOIN             0x106
#define CMD_INITSYNC_JOINED             0x107
#define CMD_INITSYNC_COMM_TIMEOUT       0x108



/***********************************************************
*                                                          *
*       Commands specific to the Delayed command server.   *
*                                                          *
***********************************************************/
// sequence break
//
#define CMD_DELAYED_SUBMIT        0x100
#define CMD_DELAYED_UNIDLED       0x101
#define CMD_DELAYED_KICK          0x102
#define CMD_DELAYED_QUEUE_SUBMIT  0x103
#define CMD_DELAYED_COMPLETE      0x104


/***********************************************************
*                                                          *
*       Commands specific to the DS command server.        *
*                                                          *
***********************************************************/
// sequence break
//
#define CMD_POLL_DS 0x100


/***********************************************************
*                                                          *
*     Commands specific to the thread command server.      *
*                                                          *
***********************************************************/
// sequence break
//
#define CMD_WAIT    0x100


/***********************************************************
*                                                          *
*     Commands specific to the Send command server.        *
*                                                          *
***********************************************************/
// sequence break
//
#define CMD_SND_COMM_PACKET 0x100
#define CMD_SND_CMD         0x110


/***********************************************************
*                                                          *
*     Commands specific to the Receive command server.     *
*                                                          *
***********************************************************/
// sequence break
//
#define CMD_RECEIVE 0x100



/***********************************************************
*                                                          *
*  Commands specific to the staging area command server.   *
*                                                          *
***********************************************************/
// sequence break
//
#define CMD_ALLOC_STAGING   0x100
#define CMD_FREE_STAGING    0x101



/***********************************************************
*                                                          *
*  Completion routine types for use in command packets.    *
*                                                          *
***********************************************************/
//
//
#define COMPLETION_INVOKE_ON_CANCEL        0x20
#define COMPLETION_INVOKE_ON_SUCCESS       0x40
#define COMPLETION_INVOKE_ON_ERROR         0x80




/*++

 VOID
 FrsSetCompletionRoutine(
     IN PCOMMAND_PACKET CmdPkt,
     IN PCOMMAND_PACKET_COMPLETION_ROUTINE CompletionRoutine,
     IN PVOID Context,
     IN BOOLEAN InvokeOnSuccess,
     IN BOOLEAN InvokeOnError,
     IN BOOLEAN InvokeOnCancel
     )

 Routine Description:

     This routine is invoked to set the address of a completion routine which
     is to be invoked when a command packet has been completed by a
     subsystem.

     If the completion routine and the completion queue are both null then
     the packet is freed at completion.

     If both are specified the completion routine is called first and on
     return the packet is placed on the CompletionQueue.  The Completion
     routine can of course modify the CompletionQueue.

     If a Completion Routine is provided then the packet is never freed
     by the command packet completion dispatchet.  This is the responsibility
     of the completion routine.

 Arguments:

     CmdPkt - Pointer to the Command Packet itself.

     CompletionRoutine - Address of the completion routine that is to be
         invoked once the command packet is completed.

     Context - Specifies a context parameter to be passed to the completion
         routine.

     InvokeOnSuccess - Specifies that the completion routine is invoked when the
         operation is successfully completed.

     InvokeOnError - Specifies that the completion routine is invoked when the
         operation completes with an error status.

     InvokeOnCancel - Specifies that the completion routine is invoked when the
         operation is being canceled.

 Return Value:

     None.

--*/


#define FrsSetCompletionRoutine(_CmdPkt, _CompletionRoutine, _CompletionArg) { \
    (_CmdPkt)->CompletionRoutine = (_CompletionRoutine); \
    (_CmdPkt)->CompletionArg = (_CompletionArg); \
}

#define FrsSetCommandErrorStatus(_CmdPkt, _Status ) \
    (_CmdPkt)->FrsErrorStatus = (_Status)

#define FrsSetCommand( _CmdPkt, _Queue, _Command, _Flags) { \
    (_CmdPkt)->TargetQueue = (_Queue); \
    (_CmdPkt)->Command = (USHORT) (_Command); \
    (_CmdPkt)->Flags = (UCHAR) (_Flags); \
}

//
// Mark this command request as synchronous.
//
#define FrsSetCommandSynchronous( _CmdPkt)  \
    (_CmdPkt)->Flags |= CMD_PKT_FLAGS_SYNC;

//
// The following are special queues for handling commands.
//
VOID
FrsSubmitCommand(
    IN PCOMMAND_PACKET CmdPkt,
    IN BOOL Headwise
    );

ULONG
FrsSubmitCommandAndWait(
    IN PCOMMAND_PACKET  Cmd,
    IN BOOL             Headwise,
    IN ULONG            Timeout
    );

VOID
FrsUnSubmitCommand(
    IN PCOMMAND_PACKET CmdPkt
    );

VOID
FrsCompleteCommand(
    IN PCOMMAND_PACKET CmdPkt,
    IN DWORD           ErrorStatus
    );

VOID
FrsCommandScheduler(
    PFRS_QUEUE Queue
    );

PCOMMAND_PACKET
FrsAllocCommand(
    IN PFRS_QUEUE   TargetQueue,
    IN USHORT       Command
    );

PCOMMAND_PACKET
FrsAllocCommandEx(
    IN PFRS_QUEUE   TargetQueue,
    IN USHORT       Command,
    IN ULONG        Size
    );

VOID
FrsFreeCommand(
    IN PCOMMAND_PACKET  Cmd,
    IN PVOID            Arg
    );

PCOMMAND_PACKET
FrsGetCommand(
    IN PFRS_QUEUE   Queue,
    IN DWORD        MilliSeconds
    );

VOID
FrsRunDownCommand(
    IN PFRS_QUEUE   Queue
    );

extern FRS_QUEUE FrsScheduleQueue;

//
// Some Journal related functions.
//
ULONG
JrnlMonitorInit(
    PFRS_QUEUE ReplicaListHead,
    ULONG Phase
);

ULONG
JrnlPauseVolume(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN DWORD                 MilliSeconds
    );

ULONG
JrnlUnPauseVolume(
    IN PVOLUME_MONITOR_ENTRY pVme,
    IN PJBUFFER              Jbuff,
    IN BOOL                  HaveLock
    );

BOOL
JrnlSetReplicaState(
    IN PREPLICA Replica,
    IN ULONG NewState
    );

#if DBG
#define DUMP_USN_RECORD2(_Severity, _UsnRecord, _ReplicaNum, _LocCmd) \
    DumpUsnRecord(_Severity, _UsnRecord, _ReplicaNum, _LocCmd, DEBSUB, __LINE__)

#define DUMP_USN_RECORD(_Severity, _UsnRecord) \
    DumpUsnRecord(_Severity, _UsnRecord, 0, CO_LOCATION_NUM_CMD, DEBSUB, __LINE__)

VOID
DumpUsnRecord(
    IN ULONG Severity,
    IN PUSN_RECORD UsnRecord,
    IN ULONG ReplicaNumber,
    IN ULONG LocationCmd,
    IN PCHAR Debsub,
    IN ULONG uLineNo
    );

#else DBG
#define DUMP_USN_RECORD(_Severity, _UsnRecord)
#endif DBG

ULONG
ChgOrdInsertRemoteCo(
    IN PCOMMAND_PACKET  Cmd,
    IN PCXTION          Cxtion
    );

DWORD
ChgOrdHammerObjectId(
    IN     PWCHAR                  Name,
    IN     PVOID                   Id,
    IN     DWORD                   IdLen,
    IN     PVOLUME_MONITOR_ENTRY   pVme,
    IN     BOOL                    CallerSupplied,
    OUT    USN                     *Usn,
    IN OUT PFILE_OBJECTID_BUFFER   FileObjID,
    IN OUT BOOL                    *ExistingOid
    );

 DWORD
 ChgOrdSkipBasicInfoChange(
     IN PCHANGE_ORDER_ENTRY  Coe,
     IN PBOOL                SkipCo
     );

VOID
JrnlCleanupVme(
    IN PVOLUME_MONITOR_ENTRY pVme
    );

//
// Waitable timer list
//
DWORD
WaitSubmit(
    IN PCOMMAND_PACKET  Cmd,
    IN DWORD            Timeout,
    IN USHORT           TimeoutCommand
    );

VOID
WaitUnsubmit(
    IN PCOMMAND_PACKET  Cmd
    );

VOID
WaitInitialize(
    VOID
    );

VOID
ShutDownWait(
    VOID
    );


BOOL
ReparseTagReplicateFileData(
    DWORD ReparseTag
    );

BOOL
ReparseTagReplicateReparsePoint(
    DWORD ReparseTag
    );

VOID
FrsCheckLocalResources(
    );


#define ReparseTagReplicate(Tag) (ReparseTagReplicateFileData(Tag) || ReparseTagReplicateReparsePoint(Tag))

#define REPARSE_TAG_REPLICATION_TYPE_NONE           L"None"
#define REPARSE_TAG_REPLICATION_TYPE_FILE_DATA      L"File Data"
#define REPARSE_TAG_REPLICATION_TYPE_REPARSE_POINT  L"Reparse Point"


typedef struct _FRS_VALID_PARTNER_TABLE_STRUCT {

    // So we don't free the struct too soon.
    // The ref count is set to 1 when the struct is created.
    // Each function that uses the struct must increase the ref count before
    // using it and decrement the count when done.
    // When we change the global variable, pPartnerTableStruct, to point to
    // a new struct the count gets decremented. The struct will not be freed
    // until the ref count is zero.
    ULONG ReferenceCount;

    // indexed by partner sid.
    // A hit means that machine is a valid partner.
    // The table elements are meaningless.
    PQHASH_TABLE pPartnerTable;

    // Indexed by connection guid.
    // Each table element is a string containing the name of the partner.
    PQHASH_TABLE pPartnerConnectionTable;

    // Used for linking the list of old structs.
    struct _FRS_VALID_PARTNER_TABLE_STRUCT *Next;
} FRS_VALID_PARTNER_TABLE_STRUCT, *PFRS_VALID_PARTNER_TABLE_STRUCT;

//
// See definition of pValidPartnerTableStruct for more info on these macros
//
#define ACQUIRE_VALID_PARTNER_TABLE_POINTER(_pptr) {                           \
            EnterCriticalSection(&CritSec_pValidPartnerTableStruct);           \
            if(pValidPartnerTableStruct == NULL) {                             \
                *(_pptr) = NULL;                                               \
            } else {                                                           \
                FRS_ASSERT(pValidPartnerTableStruct->ReferenceCount != 0);     \
                InterlockedIncrement(&(pValidPartnerTableStruct->ReferenceCount));\
                *(_pptr) = pValidPartnerTableStruct;                           \
            }                                                                  \
            LeaveCriticalSection(&CritSec_pValidPartnerTableStruct);           \
        }

#define RELEASE_VALID_PARTNER_TABLE_POINTER(_ptr) \
            InterlockedDecrement(&((_ptr)->ReferenceCount))

#define SWAP_VALID_PARTNER_TABLE_POINTER(_newPtr, _pOldPtr) {                  \
            EnterCriticalSection(&CritSec_pValidPartnerTableStruct);           \
            if(pValidPartnerTableStruct != NULL) {                             \
                FRS_ASSERT(pValidPartnerTableStruct->ReferenceCount != 0);     \
                InterlockedDecrement(&(pValidPartnerTableStruct->ReferenceCount));\
            }                                                                  \
            *(_pOldPtr) = pValidPartnerTableStruct;                            \
            pValidPartnerTableStruct = (_newPtr);                              \
            InterlockedIncrement(&(pValidPartnerTableStruct->ReferenceCount)); \
            LeaveCriticalSection(&CritSec_pValidPartnerTableStruct);           \
        }

//
// In most cases we can not proceed if we are unable to initialize
// the critical section. Instead of handling the return value at every place
// we raise a low memory exception here which will cause us to
// shutdown the service.
//
// Spin count for critical sections.
#define NTFRS_CRITSEC_SPIN_COUNT    4000
#define INITIALIZE_CRITICAL_SECTION(_CritSec) \
        { \
            if (!InitializeCriticalSectionAndSpinCount(_CritSec, NTFRS_CRITSEC_SPIN_COUNT)) {\
                RaiseException(ERROR_OUTOFMEMORY, 0, 0, NULL); \
            }\
        }

//
// For FRS writer support.
//

#define FREE_VALID_PARTNER_TABLE_STRUCT(_pStruct) {                            \
            FRS_ASSERT((_pStruct)->ReferenceCount == 0);                       \
            FrsFreeType((_pStruct)->pPartnerTable);                            \
            FrsFreeType((_pStruct)->pPartnerConnectionTable);                  \
            FrsFree(_pStruct);                                                 \
        }

extern BOOL  FrsFrozenForBackup;
extern LONG FrsFilesInInstall;

DWORD
FrsThawAfterBackup();

DWORD
FrsFreezeForBackup();

DWORD
InitializeFrsWriter();

VOID
ShutDownFrsWriter();

#endif   // _FRSH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\frstrace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       frstrace.h
//
//--------------------------------------------------------------------------

#ifndef _FRSTRACE_H
#define _FRSTRACE_H

#include "wmistr.h"
#include "evntrace.h"

#define FRS_TRACE_VERSION            1

typedef enum _tagFrsTracedEvent {
    EnumFrsTrans
} EnumFrsTracedEvent;

// Do the actual trace logs
//
VOID
FrsWmiTraceEvent(
    IN DWORD     WmiEventType,
    IN DWORD     TraceGuid,
    IN DWORD     rtnStatus
    );

#endif /* _FRSTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\fileno.h ===
//
// fileno.h - defines symbolic constants for server c code files.
// File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.

#define DSID(fileno,line) (((fileno) << 16) | (line))

// define directory numbers

#define DIRNO_ADMIN     (0)                             // ntrepl\admin
#define DIRNO_DBLAYER   (1 << 8)                        // ntrepl\dblayer
#define DIRNO_COMM      (2 << 8)                        // ntrepl\comm
#define DIRNO_INC       (3 << 8)                        // ntrepl\inc
#define DIRNO_JET       (4 << 8)                        // ntrepl\jet
#define DIRNO_REPL      (5 << 8)                        // ntrepl\repl
#define DIRNO_SETUP     (6 << 8)                        // ntrepl\setup
#define DIRNO_UTIL      (7 << 8)                        // ntrepl\util

// util directory
#define FILENO_ALERT            (DIRNO_UTIL + 0)        // alert.c
#define FILENO_DEBUG            (DIRNO_UTIL + 0)        // debug.c
#define FILENO_CONFIG           (DIRNO_UTIL + 1)        // config.c
#define FILENO_EVENT            (DIRNO_UTIL + 2)        // event.c
#define FILENO_EXCEPT           (DIRNO_UTIL + 3)        // except.c


// dblayer directory

#define FILENO_DBEVAL           (DIRNO_DBLAYER + 0)     // dbeval.c
#define FILENO_DBINDEX          (DIRNO_DBLAYER + 1)     // dbindex.c
#define FILENO_DBINIT           (DIRNO_DBLAYER + 2)     // dbinit.c
#define FILENO_DBISAM           (DIRNO_DBLAYER + 3)     // dbisam.c
#define FILENO_DBJETEX          (DIRNO_DBLAYER + 4)     // dbjetex.c
#define FILENO_DBOBJ            (DIRNO_DBLAYER + 5)     // dbobj.c
#define FILENO_DBSUBJ           (DIRNO_DBLAYER + 6)     // dbsubj.c
#define FILENO_DBSYNTAX         (DIRNO_DBLAYER + 7)     // dbsyntax.c
#define FILENO_DBTOOLS          (DIRNO_DBLAYER + 8)     // dbtools.c
#define FILENO_DBPROP           (DIRNO_DBLAYER + 9)     // dbprop.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\frserror.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    frserror.h

Abstract:

    This header defines functions, messages and status codes for error
    processing.


Author:

    David Orbits (davidor) - 10-Mar-1997

Revision History:

--*/

#ifndef _FRSERROR_
#define _FRSERROR_


#define bugbug(_text_)
#define bugmor(_text_)

//
// get the jet (aka ESENT) error codes.
//
#include <jet.h>


//
// FRS Error Codes
//


typedef enum _FRS_ERROR_SEVERITY {
    FrsSeverityServiceFatal = 0,  // FRS Service is crashing.
    FrsSeverityReplicaFatal,      // Service on just this replica set is stopping.
    FrsSeverityException,         // More than a warning but less than fatal
    FrsSeverityWarning,           // Warning errors e.g. Startup check failed doing verification.
    FrsSeverityInfo,              // Informational status only
    FrsSeverityIgnore,            // A way to filter out a class of jet errors.
    FRS_MAX_ERROR_SEVERITY
} FRS_ERROR_SEVERITY;

typedef enum _FRS_ERROR_CODE {
    FrsErrorSuccess = 0,
    FrsErrorDiskSpace,          // out of disk space
    FrsErrorDatabaseNotFound,   // no db or path to db is in error
    FrsErrorDatabaseCorrupted,  // not a db or a scrambled db
    FrsErrorInternalError,      // unexpected error occurred - catchall
    FrsErrorAccess,             // couldn't access a file or the db
    FrsErrorNotFound,           // Record or table not found.
    FrsErrorConflict,           // Record or table create conflict
    FrsErrorResource,           // Resource limit e.g. handles or memory hit.
    FrsErrorBadParam,           // Bad parameter to a function.
    FrsErrorInfo,               // informational error, e.g. JET_errObjectNotFound
    FrsErrorVvRevision,         // Vers Vector revision mismatch
    FrsErrorVvLength,           // vers vector length mismatch
    FrsErrorVvChecksum,         // version vector checksum mismatch.
    FrsErrorEndOfTable,         // No next record, end of table hit.
    FrsErrorInvalidRegistryParam, // Invalid registry parameter
    FrsErrorNoPrivileges,       // Couldn't get the necessary privileges to run.
    FrsErrorNoOpenJournals,     // Can't start replication because no journals were opened.
    FrsErrorCmdPktTimeOut,      // Command packet timeout.
    FrsErrorInvalidHandle,      // Invalid File Handle.
    FrsErrorInvalidOperation,   // Invalid operation requested.
    FrsErrorInvalidChangeOrder, // Invalid change order.
    FrsErrorResourceInUse,      // A resource required by this operation is in use.
    FrsErrorBufferOverflow,     // Buffer overflow NTSTATUS.
    FrsErrorNotInitialized,     // Function called without proper initialization
    FrsErrorReplicaPhase1Failed,// Phase 1 of replica set init failed.
    FrsErrorReplicaPhase2Failed,// Phase 2 of replica set init failed.
    FrsErrorJournalStateWrong,  // The journal is in an unexpected state.
    FrsErrorJournalInitFailed,  // The NTFS journal failed to initialize.
    FrsErrorJournalStartFailed, // The NTFS journal failed to start.
    FrsErrorJournalPauseFailed, // The NTFS journal failed to Pause, could be timeout.
    FrsErrorJournalReplicaStop, // Failed to detatch the replica from The journal.
    FrsErrorJournalWrapError,   // Initial NTFS journal record not present.  Journal has wrapped.
    FrsErrorChgOrderAbort,      // Change order processing has been aborted.
    FrsErrorQueueIsRundown,     // The request queue has been rundown.
    FrsErrorMoreWork,           // There is more work to do on this command / operation.
    FrsErrorDampened,           // This request is suppressed because it has already been seen.
    FrsErrorStageFileDelFailed, // An attempt to delete the staging file failed.
    FrsErrorKeyDuplicate,       // An attempt to insert a record with a duplicate key
    FrsErrorBadOutLogPartnerData, // Either the data was corrupt, unavail or was wrong.
    FrsErrorPartnerActivateFailed, // Failed to activate an outbound partner.
    FrsErrorDirCreateFailed,    // We failed to create a new DIR.  This stops repl.
    FrsErrorSessionNotClosed,   // Failed to close all RtCtx's in replica set.
    FrsErrorRecordLocked,       // The record being accessed is locked.
    FrsErrorDeleteRequested,    // Enum function status return to delete entry.
    FrsErrorTerminateEnum,      // Enum function status return to end enumeration.
    FrsErrorIdtFileIsDeleted,   // File is marked deleted in IDTable.
    FrsErrorVVSlotNotFound,     // VVSlot not found on VVretire of Out of Order CO.
    FrsErrorJetSecIndexCorrupted,   // Jet (upgrade, collating, jet err -1414)
    FrsErrorPreInstallDirectory,    // creating preinstall directory
    FrsErrorUnjoining,          // cxtion is still unjoining
    FrsErrorNameMorphConflict,  // File name morph conflict was detected.
    FrsErrorInvalidGuid,        // The generated Guid is missing the net address.
    FrsErrorDbWriteConflict,    // DB update conflict if two sessions try to update the same record.
    FrsErrorCantMoveOut,        // Request for a Moveout of a non-empty directory failed.
    FrsErrorFoundKey,           // The Key being searched by QHashEnumerateTable was found
    FrsErrorTunnelConflict,     // oid conflict with id table entry (resolved)
    FrsErrorTunnelConflictRejectCO, // oid conflict with id table entry (CO rejected)
    FrsErrorPrepareRoot,        // Could not prepare the root dir for replication, bad path? share viol?
    FrsErrorCmdSrvFailed,       // A command server request failed to get submitted
    FrsErrorPreinstallCreFail,  // Failed to create the pre-install dir.
    FrsErrorStageDirOpenFail,   // Failed to open the staging dir.
    FrsErrorReplicaRootDirOpenFail,   // Failed to open the replica tree root dir.
    FrsErrorShuttingDown,       // Shutdown in progress.
    FrsErrorReplicaSetTombstoned,  // Replica set is marked for deletion.
    FrsErrorVolumeRootDirOpenFail, // Failed to open the volume root directory for this replica set
    FrsErrorUnsupportedFileSystem, // The file system on this volume does provide the features required by FRS.

    FrsErrorBadPathname,         // ERROR_BAD_PATHNAME
    FrsErrorFileExists,          // ERROR_FILE_EXISTS
    FrsErrorSharingViolation,    // ERROR_SHARING_VIOLATION
    FrsErrorDirNotEmpty,         // ERROR_DIR_NOT_EMPTY
    FrsErrorOplockNotGranted,    // ERROR_OPLOCK_NOT_GRANTED
    FrsErrorRetry,               // ERROR_RETRY
    FrsErrorRequestCancelled,    // ERROR_OPERATION_ABORTED

    FRS_ERROR_LISTEN,
    FRS_ERROR_REGISTEREP,
    FRS_ERROR_REGISTERIF,
    FRS_ERROR_INQ_BINDINGS,
    FRS_ERROR_PROTSEQ,

    //
    // New error codes that trigger a non_auth restore.
    //
    FrsErrorMismatchedVolumeSerialNumber,  // The Volume serial number from DB does not match the one from FileSystem.
    FrsErrorMismatchedReplicaRootObjectId, // The Replica root's ObjectID from DB does not match the one from FileSystem.
    FrsErrorMismatchedReplicaRootFileId,   // The Replica root's FID from DB does not match the one from FileSystem.
    FrsErrorMismatchedJournalId,           // The Journal ID from DB does not match the one from FileSystem.

    // Added in QFE after Win2K SP3.
    FrsErrorIdtFileIsDeleteDef,   // File is marked delete deferred in IDTable.

    FRS_MAX_ERROR_CODE
} FRS_ERROR_CODE;




//
// Useful WIN32 STATUS defines
//
#define WIN_SUCCESS(_Status)            ((_Status) == ERROR_SUCCESS)
#define WIN_NOT_IMPLEMENTED(_Status)    ((_Status) == ERROR_INVALID_FUNCTION)
#define WIN_ACCESS_DENIED(_Status)      ((_Status) == ERROR_ACCESS_DENIED)
#define WIN_INVALID_PARAMETER(_Status)  ((_Status) == ERROR_INVALID_PARAMETER)
#define WIN_DIR_NOT_EMPTY(_Status)      ((_Status) == ERROR_DIR_NOT_EMPTY)

#define WIN_BAD_PATH(_Status)           ((_Status) == ERROR_BAD_PATHNAME)

#define WIN_BUF_TOO_SMALL(_Status)      (((_Status) == ERROR_MORE_DATA) ||     \
                                         ((_Status) == ERROR_INSUFFICIENT_BUFFER))

#define RPC_SUCCESS(_Status)            ((_Status) == RPC_S_OK)

//
// Returned when rename fails because the target name is taken
//
#define WIN_ALREADY_EXISTS(_Status)     ((_Status) == ERROR_ALREADY_EXISTS)


//
// Returned when getting the object id
//
#define WIN_OID_NOT_PRESENT(_Status)    ((_Status) == ERROR_FILE_NOT_FOUND)

//
// Oid, Fid, or relative path not found
//
//  Fid  not found is ERROR_INVALID_PARAMETER
//  Oid  not found is ERROR_FILE_NOT_FOUND
//  Path not found is ERROR_FILE_NOT_FOUND
//
// A new error ERROR_DELETE_PENDING was added on 11/01/2000. Now STATUS_DELETE_PENDING
// maps to this new error.
//
#define WIN_NOT_FOUND(_Status)          ((_Status) == ERROR_FILE_NOT_FOUND || \
                                         (_Status) == ERROR_DELETE_PENDING || \
                                         (_Status) == ERROR_INVALID_PARAMETER)

#define NT_NOT_FOUND(_ntstatus_)                              \
           (((_ntstatus_) == STATUS_DELETE_PENDING)        || \
            ((_ntstatus_) == STATUS_FILE_DELETED)          || \
            ((_ntstatus_) == STATUS_OBJECT_NAME_NOT_FOUND) || \
            ((_ntstatus_) == STATUS_OBJECTID_NOT_FOUND)    || \
            ((_ntstatus_) == STATUS_FILE_RENAMED)          || \
            ((_ntstatus_) == STATUS_OBJECT_PATH_NOT_FOUND))

//
// Retry the install (staging file)
//
// Note: remove ERROR_ACCESS_DENIED when FILE_OPEN_FOR_BACKUP_INTENT bug is fixed.
//
#define WIN_RETRY_INSTALL(_Status)  ((_Status) == ERROR_SHARING_VIOLATION ||  \
                                     (_Status) == ERROR_ACCESS_DENIED ||      \
                                     (_Status) == ERROR_DISK_FULL ||          \
                                     (_Status) == ERROR_HANDLE_DISK_FULL ||   \
                                     (_Status) == ERROR_DIR_NOT_EMPTY ||      \
                                     (_Status) == ERROR_OPLOCK_NOT_GRANTED || \
                                     (_Status) == ERROR_RETRY)

//
// Retry the delete
//
#define WIN_RETRY_DELETE(_Status)       WIN_RETRY_INSTALL(_Status)

//
// Retry the generate (staging file)
//
#define WIN_RETRY_STAGE(_Status)        WIN_RETRY_INSTALL(_Status)

//
// Retry the fetch (staging file)
//
#define WIN_RETRY_FETCH(_Status)        WIN_RETRY_INSTALL(_Status)

//
// Retry the creation of the preinstall file
//
#define WIN_RETRY_PREINSTALL(_Status)   WIN_RETRY_INSTALL(_Status)

//
// Generic !ERROR_SUCCESS status
//
#define WIN_SET_FAIL(_Status)           (_Status = ERROR_GEN_FAILURE)

//
// Generic "retry operation" error
//
#define WIN_SET_RETRY(_Status)          (_Status = ERROR_RETRY)



//
// THis macro checks the error returns from WaitForSingleObject.
//
#define CHECK_WAIT_ERRORS(_Severity_, _WStatus_, _WaitObjectCount_, _Action_) \
                                                                              \
    if ((_WStatus_ == WAIT_TIMEOUT) || (_WStatus_ == ERROR_TIMEOUT)) {        \
        DPRINT(_Severity_, "++ >>>>>>>>>>>> Wait timeout <<<<<<<<<<<<\n");    \
        if (_Action_) return _WStatus_;                                       \
    } else                                                                    \
    if (_WStatus_ == WAIT_ABANDONED) {                                        \
        DPRINT(_Severity_, "++ >>>>>>>>>>>> Wait abandoned <<<<<<<<<<<<\n");  \
        if (_Action_) return _WStatus_;                                       \
    } else                                                                    \
    if (_WStatus_ == WAIT_FAILED) {                                           \
        _WStatus_ = GetLastError();                                           \
        DPRINT_WS(_Severity_, "++ ERROR: wait failed :", _WStatus_);          \
        if (_Action_) return _WStatus_;                                       \
    } else                                                                    \
    if (_WStatus_ >= _WaitObjectCount_) {                                     \
        DPRINT_WS(_Severity_, "++ >>>>>>>>>> Wait failed <<<<<<<<<", _WStatus_);\
        if (_Action_) return _WStatus_;                                       \
    }

#define ACTION_RETURN     TRUE
#define ACTION_CONTINUE   FALSE

//
// Like above but with no Action arg so it can be used in a finally {} clause.
//
#define CHECK_WAIT_ERRORS2(_Severity_, _WStatus_, _WaitObjectCount_)          \
                                                                              \
    if (_WStatus_ == WAIT_TIMEOUT) {                                          \
        DPRINT(_Severity_, "++ >>>>>>>>>>>> Wait timeout <<<<<<<<<<<<\n");    \
    } else                                                                    \
    if (_WStatus_ == WAIT_ABANDONED) {                                        \
        DPRINT(_Severity_, "++ >>>>>>>>>>>> Wait abandoned <<<<<<<<<<<<\n");  \
    } else                                                                    \
    if (_WStatus_ == WAIT_FAILED) {                                           \
        _WStatus_ = GetLastError();                                           \
        DPRINT_WS(_Severity_, "++ ERROR: wait failed :", _WStatus_);          \
    } else                                                                    \
    if (_WStatus_ >= _WaitObjectCount_) {                                     \
        DPRINT_WS(_Severity_, "++ >>>>>>>>>>>>>>> Wait failed : %s <<<<<<<<<", _WStatus_);\
    }




#define GET_EXCEPTION_CODE(_x_)                                              \
{                                                                            \
    (_x_) = GetExceptionCode();                                              \
    DPRINT1_WS(0, "++ ERROR - EXCEPTION (%08x) :", (_x_),(_x_));             \
}


#define LDP_SUCCESS(_Status)            ((_Status) == LDAP_SUCCESS)

//
// Translate Jet error codes to an FRS Error code.
//

FRS_ERROR_CODE
DbsTranslateJetError0(
    IN JET_ERR jerr,
    IN BOOL    BPrint
    );

#define DbsTranslateJetError(_jerr_, _print_)                                \
    (((_jerr_) == JET_errSuccess) ? FrsErrorSuccess :                        \
                                    DbsTranslateJetError0(_jerr_, _print_))

FRS_ERROR_CODE
FrsTranslateWin32Error(
    IN DWORD WStatus
    );

FRS_ERROR_CODE
FrsTranslateNtError(
    IN NTSTATUS Status,
    IN BOOL     BPrint
    );

ULONG
DisplayNTStatusSev(
    IN ULONG    Sev,
    IN NTSTATUS Status
    );

ULONG
DisplayNTStatus(
    IN NTSTATUS Status
    );

ULONG
FrsSetLastNTError(
    NTSTATUS Status
    );

VOID
DisplayErrorMsg(
    IN ULONG    Severity,
    IN ULONG    WindowsErrorCode
    );

PCHAR
ErrLabelW32(
    ULONG WStatus
    );

PCHAR
ErrLabelNT(
    NTSTATUS Status
    );

PCHAR
ErrLabelFrs(
    ULONG FStatus
    );

PCHAR
ErrLabelJet(
    LONG jerr
    );

//
// FRS Error Handling
//

#define FRS_SUCCESS(_Status)            ((_Status) == FrsErrorSuccess)

VOID
FrsError(
    FRS_ERROR_CODE
    );

VOID FrsErrorCode(
    FRS_ERROR_CODE,
    DWORD
    );

VOID FrsErrorCodeMsg1(
    FRS_ERROR_CODE,
    DWORD,
    PWCHAR
    );

VOID FrsErrorCodeMsg2(
    FRS_ERROR_CODE,
    DWORD,
    PWCHAR,
    PWCHAR
    );

VOID FrsErrorCodeMsg3(
    FRS_ERROR_CODE,
    DWORD,
    PWCHAR,
    PWCHAR,
    PWCHAR
    );

VOID FrsErrorMsg1(
    FRS_ERROR_CODE,
    PWCHAR
    );

VOID FrsErrorMsg2(
    FRS_ERROR_CODE,
    PWCHAR,
    PWCHAR
    );

VOID FrsErrorMsg3(
    FRS_ERROR_CODE,
    PWCHAR,
    PWCHAR,
    PWCHAR
    );




#endif // _FRSERROR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\netapi\svcimgs\ntrepl\inc\frsalloc.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    frsalloc.h

Abstract:

    Function and struct defs for FrsAlloc() and FrsFree().

Author:

    David Orbits (davidor) - 3-Mar-1997

Revision History:

--*/

#ifndef _FRSALLOC_
#define _FRSALLOC_

#include <genhash.h>
#include <frserror.h>


#define FrsAllocType(_Type_)  FrsAllocTypeSize(_Type_, 0)

#define ZERO_FID ((ULONGLONG)0)



typedef struct _REPLICA_SERVICE_STATE_ {
    PFRS_QUEUE ServiceList;
    PCHAR      Name;
} REPLICA_SERVICE_STATE, *PREPLICA_SERVICE_STATE;

extern REPLICA_SERVICE_STATE ReplicaServiceState[];

//
// Every struct allocated by FrsAllocate() starts with an FRS_NODE_HEADER.
//
typedef struct _FRS_NODE_HEADER {
    USHORT Type;
    USHORT Size;
} FRS_NODE_HEADER, *PFRS_NODE_HEADER;


//
// Each different type of node allocated has a node type entry defined here.
// Note - Any change here should be reflected in NodeTypeNames in frsalloc.c.
//

typedef enum  _NODE_TYPE {
    THREAD_CONTEXT_TYPE = 16,   // Per thread global context
    REPLICA_TYPE,               // Per Replica Set Context
    REPLICA_THREAD_TYPE,        // Context for a given replica set in the
                                // environment of a given thread.
    CONFIG_NODE_TYPE,           // node from the DS
    CXTION_TYPE,                // a cxtion
    GHANDLE_TYPE,               // a guid/rpc handle
    THREAD_TYPE,                // generic thread context
    GEN_TABLE_TYPE,             // generic table
    JBUFFER_TYPE,               // NTFS Journal buffer
    VOLUME_MONITOR_ENTRY_TYPE,  // NTFS Volume Journal state.
    COMMAND_PACKET_TYPE,        // Subsystem command packet.
    GENERIC_HASH_TABLE_TYPE,    // Generic hash table control struct.
    CHANGE_ORDER_ENTRY_TYPE,    // ChangeOrder from journal.
    FILTER_TABLE_ENTRY_TYPE,    // Journal Filter Entry.
    QHASH_TABLE_TYPE,           // Parent File ID table base struct.
    OUT_LOG_PARTNER_TYPE,       // Outbound log partner state.
    WILDCARD_FILTER_ENTRY_TYPE, // Wildcard filename filter entries.
    REPARSE_TAG_TABLE_ENTRY_TYPE, // ReparseTagTable entry.
    NODE_TYPE_MAX
} NODE_TYPE;

#define NODE_TYPE_MIN THREAD_CONTEXT_TYPE


typedef struct _REPARSE_TAG_TABLE_ENTRY {
    FRS_NODE_HEADER Header;
    PWCHAR ReplicationType;
} REPARSE_TAG_TABLE_ENTRY, *PREPARSE_TAG_TABLE_ENTRY;
//
// Some type defs missing from Jet.
//

typedef JET_INSTANCE        *PJET_INSTANCE;
typedef JET_TABLECREATE     *PJET_TABLECREATE;
typedef JET_SETCOLUMN       *PJET_SETCOLUMN;
typedef JET_RETRIEVECOLUMN  *PJET_RETRIEVECOLUMN;
typedef JET_SESID           *PJET_SESID;
typedef JET_DBID            *PJET_DBID;
typedef JET_TABLEID         *PJET_TABLEID;
typedef JET_INDEXCREATE     *PJET_INDEXCREATE;
typedef JET_COLUMNCREATE    *PJET_COLUMNCREATE;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                       S T A G E  E N T R Y                                **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// Access to the staging files is controlled by this data structure.
// The structure is also used to manage the staging space.
//
// The change order guid is used as the key to the entry. The entries
// are ordered in a gen table.
//
// The file size is used to reserve space. Granted the file's size is
// only an approximation of the amount of disk space needed by the
// staging file; but its all we have. It is better than nothing.
//
// Both the state of the staging file and its attributes are stored
// in the Flags field.

//
// Attributes
//
#define STAGE_FLAG_RESERVE          0x00000001  // reserve staging space
#define STAGE_FLAG_UNRESERVE        0x00000002  // release staging space
#define STAGE_FLAG_FORCERESERVE     0x00000004  // force reserve
#define STAGE_FLAG_EXCLUSIVE        0x00000008  // exclusive access

#define STAGE_FLAG_RERESERVE        0x00000010  // rereserve staging space

#define STAGE_FLAG_FILE_GUID        0x00000020  // entry is indexed by file guid
#define STAGE_FLAG_STAGE_MANAGEMENT 0x00000040  // acquiring for data management

#define STAGE_FLAG_ATTRIBUTE_MASK   0x0000FFFF

//
// States
//
#define STAGE_FLAG_CREATING     0x80000000  // staging file is being created
#define STAGE_FLAG_DATA_PRESENT 0x40000000  // staging file awaiting final reaname.
#define STAGE_FLAG_CREATED      0x20000000  // staging file has been created
#define STAGE_FLAG_INSTALLING   0x10000000  // staging file is being installed

#define STAGE_FLAG_INSTALLED    0x08000000  // staging file has been installed
#define STAGE_FLAG_RECOVERING   0x04000000  // staging file is being recovered
#define STAGE_FLAG_RECOVERED    0x02000000  // staging file has been recovered

//
// Flags needed for compression support.
//
#define STAGE_FLAG_COMPRESSED                0x01000000  // There is a compressed staging
                                                         // staging file for this entry.
#define STAGE_FLAG_DECOMPRESSED              0x00800000  // The staging file has been
                                                         // decompressed once for a downlevel partner.
#define STAGE_FLAG_COMPRESSION_FORMAT_KNOWN  0x00400000  // The CompressedGuid off the
                                                         // STAGE_ENTRY structure is set.

#define STAGE_FLAG_STATE_MASK   0xFFFF0000

//
// Stage entry
//
typedef struct _STAGE_ENTRY {
//    GUID        CoGuid;                 // change order guid is the key
    GUID        FileOrCoGuid;           // index for the table. This is
                                        // the file guid if
                                        // STAGE_FLAG_FILE_GUID flag is set
                                        // else it is the change order guid.

    ULONG       FileSizeInKb;           // reserved space in kb
    ULONG       CompressedFileSizeInKb; // Size of compressedfile if present.
    ULONG       ReferenceCount;         // for shared access during fetch
    ULONG       Flags;                  // state and attributes
    GUID        CompressionGuid;        // Guid of the compression format that
                                        // was used to compress this staging file.

    DWORD       StagingAreaIndex;       // Index into the StagingAreaArray
                                        // for this replica set.

    DWORD       FileVersionNumber;      // Version number of the file.
    FILETIME    LastAccessTime;         // Last time this staging file was accessed
    DWORD       ReplicaNumber;          // Number of the replica set owning this stage
                                        // file.

} STAGE_ENTRY, *PSTAGE_ENTRY;



#define STAGE_FILE_TRACE(_sev, _guid, _fname, _size, _pflags, _text)           \
    StageFileTrace(_sev, DEBSUB, __LINE__, _guid, _fname, &(_size), _pflags, _text)



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                       S T A G E _ A R E A _ E N T R Y                     **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The following structure defines each entry of the Staging area table. This is
// a global table of all the staging areas available to FRS on this machine.
// Each staging area is included once in the table even if it is shared by more
// than one replica set. The ReferenceCount value of the entry specifies how many
// replica sets are currently using this staging area.
//

//
// The StagingAreaState variable of the STAGE_AREA_ENTRY structure can have one
// of the following values.
//

#define STAGING_AREA_ELIGIBLE   0x1
#define STAGING_AREA_DISABLED   0x2
#define STAGING_AREA_DELETED    0x3
#define STAGING_AREA_AT_QUOTA   0x4
#define STAGING_AREA_DISK_FULL  0x5
#define STAGING_AREA_ERROR      0x6


typedef struct _STAGING_AREA_ENTRY {
    CRITICAL_SECTION    StagingAreaCritSec; // Critical section to serialize
                                            // updates to items in this entry.

    PWCHAR          StagingArea;            // Absolute path to the staging directory.
    ULONG           StagingAreaLimitInKB;   // Staging area limit.
    ULONG           StagingAreaSpaceInUse;  // Current staging space in use under
                                            // this area.

    DWORD           StagingAreaState;       // State of this staging area.
    DWORD           ReferenceCount;         // Number of replica sets using
                                            // this staging area.

}STAGING_AREA_ENTRY, *PSTAGING_AREA_ENTRY;




 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                       T H R E A D _ C T X                                 **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The following struct defines the per-thread global context.  i.e. it is not
// replica specific.
//
typedef struct _THREAD_CTX {
    FRS_NODE_HEADER  Header;

    ULONG       ThreadType;         // Main thread, update thread, ...

    LIST_ENTRY  ThreadListEntry;    // List of all threads in the process.

    FRS_LIST ThreadCtxListHead;     // Head of all open REPLICA_THREAD_CTX's for this thread.

    JET_INSTANCE JInstance;         // Jet Instance
    JET_SESID    JSesid;            // Session ID for this thread
    JET_DBID     JDbid;             // Database ID for this thread

} THREAD_CTX, *PTHREAD_CTX;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                         T A B L E _ C T X                                 **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

struct _RECORD_FIELDS;

//
// The following struct defines the context for an instance of an open table.
//
typedef struct _TABLE_CTX {
    JET_TABLEID           Tid;              // Jet Table ID.
    ULONG                 ReplicaNumber;    // Table belongs to this Replica Number
    ULONG                 TableType;        // The type code of this table.
    ULONG                 PropertyFlags;    // see schema.h
    JET_SESID             Sesid;            // The Jet session id when table opened.
    PJET_TABLECREATE      pJetTableCreate;  // Table create info
    struct _RECORD_FIELDS *pRecordFields;   // Field descriptor for this record.
    PJET_SETCOLUMN        pJetSetCol;       // Struct to write Config
    PJET_RETRIEVECOLUMN   pJetRetCol;       // Struct to read Config
    PVOID                 pDataRecord;      // Data record storage
} TABLE_CTX, *PTABLE_CTX;



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                  R E P L I C A _ T H R E A D _ C T X                      **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The following struct defines the per-thread replica context.  Each thread
// needs its own set of table IDs for the replica, its own table records and
// its own replica context when doing work on a given replica.
//
// ** NOTE **  The correct value for TABLE_TYPE_MAX comes from schema.h
// any module that uses this struct must include schema.h first.
// We undef this at the end to possibly generate a compile error.
//


typedef struct _REPLICA_THREAD_CTX {
    FRS_NODE_HEADER  Header;

    //
    // The order of the table context structs MUST be in the same order as
    // the members of the TABLE_TYPE enum defined in schema.h so they
    // can be accessed as an array.
    //
    union {
        struct {
            TABLE_CTX INLOGTable;
            TABLE_CTX OUTLOGTable;
            TABLE_CTX IDTable;
            TABLE_CTX DIRTable;
            TABLE_CTX VVTable;
            TABLE_CTX CXTIONTable;
        };

        TABLE_CTX RtCtxTables[TABLE_TYPE_MAX];
    };


// Tunnel Table


    JET_TABLEID  JetSortTbl;        // Temp table for sorting
    JET_COLUMNID SortColumns[2];    // ColumnIDs for the two columns in the
                                    // sort table.

    LIST_ENTRY ThreadCtxList;       // Links all contexts assoc with this thread.

    LIST_ENTRY ReplicaCtxList;      // Links all contexts assoc with this replica set.

//    ULONG       OpenTransCount;     // open transactions for this thread

//    LCID        dwLcid;             // Locale to use for Unicode compares.  Null
                                    // means to use a default sort



    // Put all DBG components at end of structure so that dsexts routines
    // can easily ignore them (and get all other fields right) in both
    // debug and free builds.

#if DBG
//    ULONG       MemSize;            // The running total of memory allocated
//    ULONG       OrgSize;            // The running total of memory allocated
//    LONG        cJetSess;           // jet session count for this thread
#endif
} REPLICA_THREAD_CTX, *PREPLICA_THREAD_CTX;

//
// Call FrsAllocTypeSize() with the following flag in the size parameter
// to only allocate a RtCtx struct with minimal TableCtx init.  No call
// to DbsAllocTableCtx() is made on the individual replica tables.
//
#define FLAG_FRSALLOC_NO_ALLOC_TBL_CTX  0x1


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                      S T A G E   H E A D E R                              **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// Header at the beginning of every stage file.
//

typedef struct _STAGE_HEADER_ {
    ULONG   Major;          // MUST BE FIRST  major version
    ULONG   Minor;          // MUST BE SECOND minor version
    ULONG   DataHigh;       // offset from beginning of file to data
    ULONG   DataLow;        // offset from beginning of file to data
    //
    // NTFRS_STAGE_MINOR_0
    //
    // compression mode of the original source file as stored in NTFS.
    USHORT                        Compression;

    FILE_NETWORK_OPEN_INFORMATION Attributes;

    CHANGE_ORDER_COMMAND          ChangeOrderCommand;

    FILE_OBJECTID_BUFFER          FileObjId;

    //
    // NTFRS_STAGE_MINOR_1  (must remain at the WIN2K size for interop compat.)
    //
    CO_RECORD_EXTENSION_WIN2K     CocExt;

    //
    // NTFRS_STAGE_MINOR_2
    // The compression Guid identifies the compression algorithm used on
    // the stage file data.
    //
    GUID                          CompressionGuid;

    //
    // The Data offsets above allow us to find the beginning of the backup
    // restore data so the Stage Header is extensible.
    //
    // Only Add new data to this structure here and adjust the minor
    // version number so Up-Rev members can tell when an incoming stage file
    // was generated by another Up-Rev member.  The layout of the data above
    // can never change or down-rev members will break when given an up-rev
    // stage file.
    //

    //
    // To support replication of encrypted data we need to store the offset and
    // size of the RawEncrypted data read using the RawFile APIs
    //

    ULONG                         EncryptedDataHigh;    // offset from beginning of file to encrypted data
    ULONG                         EncryptedDataLow;     // offset from beginning of file to encrypted data
    LARGE_INTEGER                 EncryptedDataSize;    // size of encrypted data.

    //
    // NTFRS_STAGE_MINOR_3
    //

    BOOL    ReparseDataPresent;         // Is there reparse data in this file?
    ULONG   ReparsePointDataHigh;       // offset from beginning of file to reparse data
    ULONG   ReparsePointDataLow;        // offset from beginning of file to reparse data

}STAGE_HEADER, *PSTAGE_HEADER;


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                      C O N F I G _ N O D E                                **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/
//
// We build an incore copy of the DS hierarchy sites\settings\servers\cxtions.
// Hence the interrelated structs for site, settings, server, and cxtion.
//
// The node struct is a generic node created with info from the DS tree.
//
// XXX The uSNCreated is being used as a GUID!
//
//
// The state of nodes as they migrate to/from the DB
//

//
// The generic table routines can't handle dups or multithreading. So
// we provide wrapper routines that add duplicate key proccessing and
// multithreading.
//
typedef struct _GEN_ENTRY GEN_ENTRY, *PGEN_ENTRY;
struct _GEN_ENTRY {
        PVOID           Data;       // The real entry in the table
        GUID            *Key1;      // For compares
        PWCHAR          Key2;       // For compares (may be NULL)
        PGEN_ENTRY      Dups;       // remember dups
};

//
// A generic table with a lock and duplicate processing
//
typedef struct _GEN_TABLE {
    FRS_NODE_HEADER     Header;     // Memory management
    CRITICAL_SECTION    Critical;   // critical section
    RTL_GENERIC_TABLE   Table;      // RTL GENERIC TABLE
} GEN_TABLE, *PGEN_TABLE;

//
// A guid/name is a binary guid and its corresponding printable name
//
typedef struct _GNAME {
    GUID    *Guid;  // binary guid
    PWCHAR  Name;   // printable name (NOT A STRING VERSION OF THE GUID!)
} GNAME, *PGNAME;

typedef struct _CONFIG_NODE    CONFIG_NODE, *PCONFIG_NODE;
struct _CONFIG_NODE {
    FRS_NODE_HEADER     Header;         // For memory management
    BOOL                Consistent;     // node is consistent
    BOOL                Inbound;        // TRUE if Inbound cxtion
    BOOL                ThisComputer;   // Member object for this computer
    ULONG               DsObjectType;   // Type code corresponding to the DS Object
    PWCHAR              Dn;             // fully qualified distinguished name for DS object.
    PWCHAR              PrincName;      // NT4 Account Name
    PWCHAR              SettingsDn;     // FQDN of NTDS Settings (DSA) reference for DC system volumes
    PWCHAR              ComputerDn;     // computer reference
    PWCHAR              MemberDn;       // member reference
    PWCHAR              SetType;        // Type of replica set
    PWCHAR              DnsName;        // of this member's computer object
    PWCHAR              PartnerDnsName; // of this cxtion's partner
    PWCHAR              Sid;            // of this member's computer
    PWCHAR              PartnerSid;     // partner's sid (from member's computer)
    PGNAME              Name;           // printable name and guid
    PGNAME              PartnerName;    // printable name and guid of our partner
    PWCHAR              PartnerDn;      // distinguished name for partner
    PWCHAR              PartnerCoDn;    // partner's computer dn
    PCONFIG_NODE        Partner;        // partner's node in the tree
    PWCHAR              Root;           // Root of replicated tree
    PWCHAR              Stage;          // staging area
    PWCHAR              Working;        // working directory
    PWCHAR              FileFilterList; // File Filter
    PWCHAR              DirFilterList;  // Directory Filter
    PCONFIG_NODE        Peer;           // address of peer in tree
    PCONFIG_NODE        Parent;         // parent in tree
    PCONFIG_NODE        Children;       // children
    ULONG               NumChildren;    // helps check the tree's linkage
    PSCHEDULE           Schedule;
    ULONG               ScheduleLength;
    ULONG               FrsRsoFlags;    // ATTR_FRS_FLAGS
    ULONG               CxtionOptions;  // Options on the NTDS-Connection object.
                                        // Only NTDSCONN_OPT_TWOWAY_SYNC is of interest.
    PWCHAR              UsnChanged;     // usn changed from the DS
    BOOL                SameSite;
    PWCHAR              EnabledCxtion;  // Cxtion is disabled iff == L"FALSE"
    BOOL                VerifiedOverlap; // Decrease cpu usage; check once
};


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                            C X T I O N                                    **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// A connection
//

struct _OUT_LOG_PARTNER_;

typedef struct _CXTION  CXTION, *PCXTION;
struct _CXTION {
    FRS_NODE_HEADER Header;     // memory management
    ULONG           State;      // Incore state
    ULONG           Flags;      // misc flags
    BOOL            Inbound;    // TRUE if inbound cxtion        *
    BOOL            JrnlCxtion; // TRUE if this Cxtion struct is for the local NTFS Journal
    PGNAME          Name;       // Cxtion name/guid from the DS  *
    PGNAME          Partner;    // Partner's name/guid from the DS    *
    PWCHAR          PartnerDnsName;     // partner's DNS name from the DS *
    PWCHAR          PartnerPrincName;   // partner's server principle name *
    PWCHAR          PartnerSid;         // partner's sid (string) *
    PWCHAR          PartSrvName;        // Partner's server name
    ULONG           PartnerAuthLevel;   // Authentication level  *
    PGEN_TABLE      VVector;            // partner's version vector
    PGEN_TABLE      CompressionTable;   // partner's list of supported compression formats.
    PSCHEDULE       Schedule;           // schedule                      *
    DWORD           Options;            // options attribute from DS *
    DWORD           Priority;           // options attribute from DS *
    ULONG           TerminationCoSeqNum;// The Seq Num of most recent Termination CO inserted.
    PCOMMAND_SERVER VvJoinCs;           // command server for vvjoins
    struct _COMMAND_PACKET  *JoinCmd;   // check join status; rejoin if needed
                                        // NULL == no delayed cmd outstanding
    ULONGLONG       LastJoinTime;       // The time of the last successful join on this cxtion.
    GUID            JoinGuid;           // Unique id for this join
    GUID            ReplicaVersionGuid; // partner's originator guid
    DWORD           CommQueueIndex;     // Comm layer queue for sending pkts
    DWORD           ChangeOrderCount;   // remote/control change orders pending
    PGEN_TABLE      CoeTable;           // table of idle change orders
    struct _COMMAND_PACKET *CommTimeoutCmd; // Timeout (waitable timer) packet
    DWORD           UnjoinTrigger;      // DBG force unjoin in # remote cos
    DWORD           UnjoinReset;        // reset force unjoin trigger
    PFRS_QUEUE      CoProcessQueue;     // If non-null then Unidle the queue when
                                        // JOIN succeeds or fails.
    ULONG           CommPkts;           // Number of comm pkts
    ULONG           Penalty;            // Penalty in Milliseconds
    PCOMM_PACKET    ActiveJoinCommPkt;  // Don't flood Q w/many join pkts
    ULONG           PartnerMajor;       // From comm packet
    ULONG           PartnerMinor;       // From comm packet
    struct _OUT_LOG_PARTNER_ *OLCtx;    // Outbound Log Context for this connection.

    struct _HASHTABLEDATA_REPLICACONN *PerfRepConnData; // PERFMON counter data structure
};
//
// Cxtion State
//
// A connection is initially created in the INIT state and then goes to
// the UNJOINED state.  From there it goes to the STARTING state
// when a StartJoin request is sent to the inbound log subsystem.  When
// inlog starts the request it advances the state to SCANNING.  When it
// has scanned the inbound log for the replica set and has requeued any
// change orders from this inbound partner's connection it advances the
// state to SENDJOIN.  The Replica subsystem then picks it up as part of
// its retry path, does any one time init, and sends the Join request to
// the inbound partner and advances to WAITJOIN.
//
// Once the join request is completed the state goes to JOINED if it succeeded
// or to UNJOINED if it failed.  Always use SetCxtionState() to set a new state.
//
// Note: It must go to one of these two states because the change order accept
// logic in the inbound log process may be blocked on a retry change order for
// this connection because it is waiting for the join to finish before it issues
// the CO.
//
typedef enum _CXTION_STATE {
    CxtionStateInit = 0,        // Newly allocated
    CxtionStateUnjoined,        // Not joined to partner
    CxtionStateStart,           // Inbound Partner has requested join
    CxtionStateStarting,        // Starting the join
    CxtionStateScanning,        // Scanning the inbound log
    CxtionStateSendJoin,        // Scan complete, send join request to partner
    CxtionStateWaitJoin,        // Sent request, waiting for partner's reply
    CxtionStateJoined,          // Joined with partner
    CxtionStateUnjoining,       // Draining remote co's through retry
    CxtionStateDeleted,         // Cxtion has been deleted
    CXTION_MAX_STATE
} CXTION_STATE;


extern PCHAR CxtionStateNames[CXTION_MAX_STATE];


//
// Cxtion flags
// Cxtion flags are divided in two parts. Ones that are in the upper short part
// of the DWORD and the ones that are in the lower short part of the DWORD.

// Following lower short flags are volatile and are not saved in the DB.

#define CXTION_FLAGS_CONSISTENT         0x00000001  // info from ds is okay
#define CXTION_FLAGS_SCHEDULE_OFF       0x00000002  // schedule says stop
#define CXTION_FLAGS_VOLATILE           0x00000004  // sysvol seeding cxtion; delete at unjoin
#define CXTION_FLAGS_DEFERRED_JOIN      0x00000008  // join requested during unjoin

#define CXTION_FLAGS_DEFERRED_UNJOIN    0x00000010  // Unjoin requested during join
#define CXTION_FLAGS_TIMEOUT_SET        0x00000020  // timeout cmd on timeout queue
#define CXTION_FLAGS_JOIN_GUID_VALID    0x00000040  // guid valid for networking
#define CXTION_FLAGS_UNJOIN_GUID_VALID  0x00000080  // guid valid for unjoin only

#define CXTION_FLAGS_PERFORM_VVJOIN     0x00000100  // Force a vvjoin
#define CXTION_FLAGS_DEFERRED_DELETE    0x00000200  // deferred delete
#define CXTION_FLAGS_PAUSED             0x00000400  // Used to serialize vvjoin.
#define CXTION_FLAGS_HUNG_INIT_SYNC     0x00000800  // Used to detect hung init syncs.

#define CXTION_FLAGS_TRIM_OUTLOG        0x00001000  // Used to trim outlog by deleting this connection.


// Following upper short flags are stored in the upper short part of the
// CxtionRecord->Flags field in the DB. The outlog state of the connection is
// stored in the lower short part of the CxtionRecord.

#define CXTION_FLAGS_INIT_SYNC          0x40000000  // Connection has not completed initial sync.
#define CXTION_FLAGS_TRIGGER_SCHEDULE   0x80000000  // DB: sysvol uses a trigger schedule

//
// Both the OutLogPartner and Cxtion are stored in a single cxtion record.
// Unfortunately, there is only one flags word. For now, the low short
// belongs to the OutLogPartner->Flags and the upper short Cxtion->Flags.
//
#define CXTION_FLAGS_CXTION_RECORD_MASK 0xffff0000

//
// Volatile outbound connections need timeout protection for inactivity so
// we don't accumulate staging file data if they have gone away.
//
#define VOLATILE_OUTBOUND_CXTION(_cxtion) \
    (CxtionFlagIs((_cxtion), CXTION_FLAGS_VOLATILE) && !(_cxtion)->Inbound)

//
// The replica lock protects the filter lists (for now)
//
#define LOCK_REPLICA(_replica_) \
    DPRINT1(5, "LOCK_REPLICA: "#_replica_":%08x\n", PtrToUlong(_replica_)); \
    EnterCriticalSection(&(_replica_)->ReplicaLock);

#define UNLOCK_REPLICA(_replica_) \
    LeaveCriticalSection(&(_replica_)->ReplicaLock); \
    DPRINT1(5, "UNLOCK_REPLICA: "#_replica_":%08x\n", PtrToUlong(_replica_));

//
// The table lock protects the gen table of cxtions and
// the cxtion's join guid and state.
//
#define LOCK_CXTION_TABLE(_replica)                                           \
    ReplicaStateTrace2(5, DEBSUB, __LINE__, _replica, "LOCK_CXTION_TABLE");   \
    GTabLockTable((_replica)->Cxtions);

#define UNLOCK_CXTION_TABLE(_replica)                                         \
    GTabUnLockTable((_replica)->Cxtions);                                     \
    ReplicaStateTrace2(5, DEBSUB, __LINE__, _replica, "UNLOCK_CXTION_TABLE");

//
// The table lock protects the gen table of change orders active on this cxtion
// so they can be sent thru retry if the cxtion unjoins.
//
#define LOCK_CXTION_COE_TABLE(_replica, _cxtion_)                              \
    CxtionStateTrace(5, DEBSUB, __LINE__, _cxtion_, _replica, 0, "LOCK_CXTION_COE_TABLE");\
    GTabLockTable((_cxtion_)->CoeTable);

#define UNLOCK_CXTION_COE_TABLE(_replica, _cxtion_)                            \
    CxtionStateTrace(5, DEBSUB, __LINE__, _cxtion_, _replica, 0, "UNLOCK_CXTION_COE_TABLE");\
    GTabUnLockTable((_cxtion_)->CoeTable);

//
// The table lock protects the gen table of replicas
//
#define LOCK_REPLICA_TABLE(_replica_table_) \
    DPRINT1(5, "LOCK_REPLICA_TABLE: "#_replica_table_":%08x\n", PtrToUlong(_replica_table_)); \
    GTabLockTable(_replica_table_);

#define UNLOCK_REPLICA_TABLE(_replica_table_) \
    GTabUnLockTable(_replica_table_);         \
    DPRINT1(5, "UNLOCK_REPLICA_TABLE: "#_replica_table_":%08x\n", PtrToUlong(_replica_table_));

//
// The remote change order count is used when transitioning the cxtion
// from unjoining to unjoined. The transition doesn't occur until the
// count goes to 0. Internal join requests are ignored during this time.
// Join requests initiated by our partner are deferred until the cxtion
// is unjoined. The count goes to 0 when all of the remote change orders
// have been taken through the retire or retry path.
//
#define INCREMENT_CXTION_CHANGE_ORDER_COUNT(_replica_, _cxtion_) \
    InterlockedIncrement(&((_cxtion_)->ChangeOrderCount)); \
    CXTION_STATE_TRACE(3, (_cxtion_), (_replica_), (_cxtion_)->ChangeOrderCount, "N, CXT CO CNT INC");

//
// Synchronize with LOCK_CXTION_TABLE()
//
#define CHECK_CXTION_UNJOINING(_replica_, _cxtion_) \
    if (!(_cxtion_)->ChangeOrderCount && \
        CxtionStateIs(_cxtion_, CxtionStateUnjoining)) { \
        RcsSubmitReplicaCxtion(_replica_, _cxtion_, CMD_UNJOIN); \
    }

#define DECREMENT_CXTION_CHANGE_ORDER_COUNT(_replica_, _cxtion_) \
    InterlockedDecrement(&((_cxtion_)->ChangeOrderCount)); \
    CXTION_STATE_TRACE(3, (_cxtion_), (_replica_), (_cxtion_)->ChangeOrderCount, "N, CXT CO CNT DEC"); \
    CHECK_CXTION_UNJOINING(_replica_, _cxtion_);


//
// Initialize the cxtion Guid, Cxtion ptr and the Join Guid for this CO.
// Also increment the CO count for the Cxtion.
//
#define INIT_LOCALCO_CXTION_AND_COUNT(_Replica_, _Coe_)                       \
                                                                              \
    LOCK_CXTION_TABLE(_Replica_);                                             \
    (_Coe_)->Cmd.CxtionGuid = (_Replica_)->JrnlCxtionGuid;                    \
    (_Coe_)->Cxtion = GTabLookupNoLock((_Replica_)->Cxtions,                  \
                                       &(_Coe_)->Cmd.CxtionGuid,              \
                                       NULL);                                 \
    if ((_Coe_)->Cxtion != NULL) {                                            \
        INCREMENT_CXTION_CHANGE_ORDER_COUNT(_Replica_, (_Coe_)->Cxtion);      \
        (_Coe_)->JoinGuid = (_Coe_)->Cxtion->JoinGuid;                        \
    } else {                                                                  \
        DPRINT(4, "++ Cxtion Guid lookup for Jrnl returned Null. Count unchanged.\n");\
    }                                                                         \
    UNLOCK_CXTION_TABLE(_Replica_);


//
// Translate the CxtionGuid to a ptr and increment the Cxtion ChangeOrderCount.
//
#define ACQUIRE_CXTION_CO_REFERENCE(_Replica_, _Coe_)                         \
    FRS_ASSERT((_Coe_)->Cxtion == NULL);                                      \
    LOCK_CXTION_TABLE(_Replica_);                                             \
    (_Coe_)->Cxtion = GTabLookupNoLock((_Replica_)->Cxtions,                  \
                                       &(_Coe_)->Cmd.CxtionGuid,              \
                                       NULL);                                 \
    if ((_Coe_)->Cxtion != NULL) {                                            \
        if (CxtionFlagIs((_Coe_)->Cxtion, CXTION_FLAGS_JOIN_GUID_VALID)) {    \
            INCREMENT_CXTION_CHANGE_ORDER_COUNT(_Replica_, (_Coe_)->Cxtion);  \
        } else {                                                              \
            CXTION_STATE_TRACE(3, (_Coe_)->Cxtion, (_Replica_), (_Coe_)->Cxtion->ChangeOrderCount, "N, CXT CO CNT INVALID JOIN"); \
            (_Coe_)->Cxtion = NULL;                                           \
        }                                                                     \
    } else {                                                                  \
        DPRINT(4, "++ Cxtion Guid lookup returned Null. Count unchanged.\n"); \
    }                                                                         \
    UNLOCK_CXTION_TABLE(_Replica_);

//
// Initialize ONLY the cxtion Guid and the Join Guid for this CO.
// Leave the CO Cxtion ptr alone.
//
#define INIT_LOCALCO_CXTION_GUID(_Replica_, _Coe_)                            \
{                                                                             \
    PCXTION TCxtion;                                                          \
    LOCK_CXTION_TABLE(_Replica_);                                             \
    (_Coe_)->Cmd.CxtionGuid = (_Replica_)->JrnlCxtionGuid;                    \
    TCxtion = GTabLookupNoLock((_Replica_)->Cxtions,                          \
                               &(_Coe_)->Cmd.CxtionGuid,                      \
                               NULL);                                         \
    if (TCxtion != NULL) {                                                    \
        (_Coe_)->JoinGuid = TCxtion->JoinGuid;                                \
    }                                                                         \
    UNLOCK_CXTION_TABLE(_Replica_);                                           \
}


//
// Release the CO count for this cxtion.  A common code fragment on error path.
//
#define DROP_CO_CXTION_COUNT(_Replica_, _Coe_, _WStatus_)                      \
    if ((_WStatus_) != ERROR_SUCCESS) {                                        \
        DPRINT1(0, "++ ERROR - ChangeOrder insert failed: %d\n", (_WStatus_)); \
    }                                                                          \
    LOCK_CXTION_TABLE(_Replica_);                                              \
    if ((_Coe_)->Cxtion) {                                                     \
        DECREMENT_CXTION_CHANGE_ORDER_COUNT((_Replica_), (_Coe_)->Cxtion);     \
    }                                                                          \
    UNLOCK_CXTION_TABLE(_Replica_);                                            \
    (_Coe_)->Cxtion = NULL;



/*
VOID
SetCxtionState(
    PCXTION _cxtion_,
    ULONG _state_
    )

    Defines new connection state.
*/

#define SetCxtionState(_cxtion_, _state_)                                     \
    SetCxtionStateTrace(3, DEBSUB, __LINE__, _cxtion_, _state_);              \
    (_cxtion_)->State = _state_;

/*
VOID
GetCxtionState(
    PCXTION _cxtion_
    )

    returns connection state.
*/

#define GetCxtionState(_cxtion_) ((_cxtion_)->State)


/*
PCHAR
GetCxtionStateName(
    PCXTION _c_
    )

    returns connection state name.
*/
#define GetCxtionStateName(_c_)                     \
    (CxtionStateNames[GetCxtionState(_c_)] == NULL) \
        ? "<null>"                                  \
        : CxtionStateNames[GetCxtionState(_c_)]


/*
BOOL
CxtionStateIs(
    PCXTION _x_,
    ULONG _Flag_
    )

    Test connection state.

*/

#define CxtionStateIs(_x_, _state_) ((_x_)->State == _state_)

/*
BOOL
CxtionFlagIs(
    PCXTION _x_,
    ULONG _Flag_
    )

    Test flag state.

*/
#define CxtionFlagIs(_x_, _Flag_) BooleanFlagOn((_x_)->Flags, _Flag_)

/*
VOID
SetCxtionFlag(
    PCXTION _x_,
    ULONG _Flag_
    )

    Set flag state.

*/
#define SetCxtionFlag(_x_, _Flag_) SetFlag((_x_)->Flags, _Flag_)

/*
VOID
ClearCxtionFlag(
    PCXTION _x_,
    ULONG _Flag_
    )

    Set flag state.

*/
#define ClearCxtionFlag(_x_, _Flag_) ClearFlag((_x_)->Flags, _Flag_)


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                       O U T   L O G   P A R T N E R                       **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// The following state is kept for each outbound partner in the configuration.
// It tracks our current output change order state with respect to the partner.
//
// The max number of change orders outstanding for any one partner is limited
// by the ACK_VECTOR_SIZE (number of bits).  This must be a power of 2.
// It is defined in schema.h because it is saved in the connection record.
//
// There are two types of Outbound COs, Normal and Directed.  A Normal CO is
// sent to all registered outbound partners.  A Directed CO is sent to a single
// partner as specified by the ConnectionGuid in the CO.
//
// A given outbound partner can be in one of two modes, Normal and VVJoined.
// In Normal mode the partner is sent all normal COs and any directed
// COs addressed to it.  In VVJoined mode the partner is only sent Directed COs.
// Normal COs are held until the partner returns to Normal mode.  The
// Normal mode outlog sequence number to continue from is saved in
// COTxNormalModeSave while the partner is in VV Join mode.  The current mode
// for the partner is kept in OLP_FLAGS_VVJOIN_MODE.  This is saved in the
// DB so a VVJOIN operation can continue across schedule interruptions and
// machine crashes.
//

typedef struct _OUT_LOG_PARTNER_ {
    FRS_NODE_HEADER  Header;    // Memory alloc
    LIST_ENTRY List;            // Link on the change order set list. (DONT MOVE)

    ULONG    Flags;             // misc state flags.  see below.
    ULONG    State;             // Current state of this outbound partner.
    ULONGLONG AckVersion;       // Ack vector version number (GMT of last reset).
    SINGLE_LIST_ENTRY SaveList; // The link for the DB save list.
    ULONG    COLxRestart;       // Restart point for Leading change order index.
    ULONG    COLxVVJoinDone;    // COLx where VVJoin Finished and was rolled back.
    ULONG    COLx;              // Leading change order index / sequence number.
    ULONG    COTx;              // Trailing change order index / sequence number.
    ULONG    COTxLastSaved;     // COTx value last saved in DB.
    ULONG    COTxNormalModeSave;// Saved Normal Mode COTx while in VV Join Mode.
    ULONG    COTslot;           // Slot in Ack Vector corresponding to COTx.
    ULONG    OutstandingCos;    // The current number of change orders outstanding.
    ULONG    OutstandingQuota;  // The maximum number of COs outstanding.

    ULONG    AckVector[ACK_VECTOR_LONGS];  // The partner ack vector.

    PCXTION  Cxtion;            // The partner connection.  Has Guid and VVector.
    PQHASH_TABLE MustSendTable; // Tracks COx of Files we must send when skipping earlier duplicates.

} OUT_LOG_PARTNER, *POUT_LOG_PARTNER;

//
// States for the outbound log partner.
//
#define OLP_INITIALIZING    0   // The partner state is initing.
#define OLP_UNJOINED        1   // The partner is not joined.
#define OLP_ELIGIBLE        2   // The partner can accept further COs
#define OLP_STANDBY         3   // The partner is ready to join the eligible list.
#define OLP_AT_QUOTA        4   // The partner is at quota for for outstanding COs.
#define OLP_INACTIVE        5   // The partner is not accepting change orders.
                                // We could still get late ACKs from this partner.
#define OLP_ERROR           6   // The partner is in an Error state.
#define OLP_MAX_STATE       6   // The partner is in an Error state.

//
// Flags word definitions. (Saved in Flags in Cxtion table record in DB)
//
// Following lower short flags are stored in the lower short part of the
// CxtionRecord->Flags field in the DB. The Cxtion->Flags are stored in the
// upper short part of the CxtionRecord.
//
#define OLP_FLAGS_ENABLED_CXTION    0x00000001  // Enabled-Connection from NTDS-Connection
#define OLP_FLAGS_GENERATED_CXTION  0x00000002  // Generated-Connection from NTDS-Connection
#define OLP_FLAGS_VVJOIN_MODE       0x00000004  // Connection is in VV JOIN Mode.
#define OLP_FLAGS_LOG_TRIMMED       0x00000008  // Deleted COs for log destined for this Partner.
#define OLP_FLAGS_REPLAY_MODE       0x00000010  // Connection in replay mode.
#define OLP_FLAGS_OPT_VVJOIN_MODE   0x00000020  // Connection in optimized vvjoin mode.

//
// Both the OutLogPartner and Cxtion are stored in a single cxtion record.
// Unfortunately, there is only one flags word. For now, the low short
// belongs to the OutLogPartner->Flags and the upper short Cxtion->Flags.
//
#define OLP_FLAGS_CXTION_RECORD_MASK    0x0000ffff


#define  WaitingToVVJoin(_olp_) (((_olp_)->COLx == 0) && ((_olp_)->COTx == 0))

#define  InVVJoinMode(_olp_) (BooleanFlagOn((_olp_)->Flags, OLP_FLAGS_VVJOIN_MODE))

#define  InOptVVJoinMode(_olp_) (BooleanFlagOn((_olp_)->Flags, OLP_FLAGS_OPT_VVJOIN_MODE))

#define  InReplayMode(_olp_) (BooleanFlagOn((_olp_)->Flags, OLP_FLAGS_REPLAY_MODE))

//
// Macro to update state field of an Outbound log partner.
//
#define SET_OUTLOG_PARTNER_STATE(_Partner_, _state_)                        \
{                                                                           \
    DPRINT3(4, ":X: OutLog Partner state change from %s to %s for %ws\n",   \
            OLPartnerStateNames[(_Partner_)->State],                        \
            OLPartnerStateNames[(_state_)],                                 \
            (_Partner_)->Cxtion->Name->Name);                               \
    (_Partner_)->State = (_state_);                                         \
}


//
//  Mark this outbound log partner as inactive and put it on the inactive list.
//
#define SET_OUTLOG_PARTNER_INACTIVE(_Replica_, _OutLogPartner_)                \
    FrsRemoveEntryList(&((_OutLogPartner_)->List));                            \
    SET_OUTLOG_PARTNER_STATE((_OutLogPartner_), OLP_INACTIVE);                 \
    InsertTailList(&((_Replica_)->OutLogInActive), &((_OutLogPartner_)->List));

//
//  Mark this outbound log AVWRAPed partner as AT_QUOTA and put it on the active list.
//
#define SET_OUTLOG_PARTNER_AVWRAP(_Replica_, _OutLogPartner_)                  \
    FrsRemoveEntryList(&((_OutLogPartner_)->List));                            \
    SET_OUTLOG_PARTNER_STATE((_OutLogPartner_), OLP_AT_QUOTA);                 \
    InsertTailList(&((_Replica_)->OutLogActive), &((_OutLogPartner_)->List));  \
    DPRINT3(1, "AVWRAP on OutLog partner %08x on Replica %08x, %ws\n",         \
            _OutLogPartner_, _Replica_, (_Replica_)->ReplicaName->Name);

//
//  Mark this outbound log partner as AT_QUOTA and put it on the active list.
//
#define SET_OUTLOG_PARTNER_AT_QUOTA(_Replica_, _OutLogPartner_)                \
    FrsRemoveEntryList(&((_OutLogPartner_)->List));                            \
    SET_OUTLOG_PARTNER_STATE((_OutLogPartner_), OLP_AT_QUOTA);                 \
    InsertTailList(&((_Replica_)->OutLogActive), &((_OutLogPartner_)->List));

//
//  Mark this outbound log partner as UNJOINED and put it on the inactive list.
//
#define SET_OUTLOG_PARTNER_UNJOINED(_Replica_, _OutLogPartner_)                \
    FrsRemoveEntryList(&((_OutLogPartner_)->List));                            \
    SET_OUTLOG_PARTNER_STATE((_OutLogPartner_), OLP_UNJOINED);                 \
    InsertTailList(&((_Replica_)->OutLogInActive), &((_OutLogPartner_)->List));

//
// Macros to access AckVector.
//

#define ResetAckVector(_P_)                                              \
        (_P_)->OutstandingCos = 0;                                       \
        (_P_)->COTslot = 1;                                              \
        GetSystemTimeAsFileTime((PFILETIME)&(_P_)->AckVersion);          \
        ZeroMemory((_P_)->AckVector, ACK_VECTOR_BYTES);

#define AVSlot(_COx_, _P_)                                               \
    ((((_COx_) - (_P_)->COTx) + (_P_)->COTslot) & (ACK_VECTOR_SIZE-1))

#define ClearAVBit(_COx_, _P_) {                                         \
    ULONG _bit_ = AVSlot((_COx_), (_P_));                                \
    PULONG _avw_ = &((_P_)->AckVector[ _bit_ >> 5]);                     \
    *_avw_ &= ~(1 << (_bit_ & 31));                                      \
}

#define SetAVBit(_COx_, _P_) {                                           \
    ULONG _bit_ = AVSlot((_COx_), (_P_));                                \
    PULONG _avw_ = &((_P_)->AckVector[ _bit_ >> 5]);                     \
    *_avw_ |= (1 << (_bit_ & 31));                                       \
}

#define ReadAVBitBySlot(_Slotx_, _P_)                                    \
    ((((_P_)->AckVector[ ((_Slotx_) >> 5) & ACK_VECTOR_LONG_MASK]) >>    \
        ((_Slotx_) & 31)) & 1)

#define ClearAVBitBySlot(_Slotx_, _P_)                                   \
    (((_P_)->AckVector[ ((_Slotx_) >> 5) & ACK_VECTOR_LONG_MASK]) &=     \
        ~(1 << ((_Slotx_) & 31)) )

#define ReadAVBit(_COx_, _P_)                                            \
    ((((_P_)->AckVector[ (AVSlot((_COx_), (_P_))) >> 5]) >>              \
                        ((AVSlot((_COx_), (_P_))) & 31)) & 1)
//
// If the trailing index minus one equals the leading index modulo the AV size
// then the vector is full and we can't issue the next change order until the
// trailing index advances.
//
#define AVWrapped(_P_) ((((_P_)->COTx-1) & (ACK_VECTOR_SIZE-1) ) == \
                        (((_P_)->COLx)   & (ACK_VECTOR_SIZE-1) ))

//
// Test to see if a given outlog sequence number is outside the range of the
// current Ack Vector window.
//
#define SeqNumOutsideAVWindow(_sn_, _P_)                                    \
    (((_sn_) < ((_P_)->COTx )) ||                                           \
     ((_sn_) > ((_P_)->COLx + (ACK_VECTOR_SIZE-1))))


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                         R E P L I C A   S E T                             **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// An instantiation of a replica set on a machine
//
//
// A Guid and VSN for the version vector. The Vsn is valid iff
// ValidVsn is TRUE.
//
typedef struct _GVSN {
    ULONGLONG  Vsn;
    GUID      Guid;
} GVSN, *PGVSN;

//
// The version vector is also responsible for ordering change orders to the
// outbound log.  The ordering is maintained by keeping a list of change
// order retire slots anchored by the version vector entry in the version
// vector table.  Hence, the version vector will no longer use the GVSN as
// the entry in the version vector.  BUT the outbound version vector
// continues to use the GVSN as the version vector entry.  This will only
// work if GVSN is the first field in a VV_ENTRY.
//

struct _CHANGE_ORDER_ENTRY_;

typedef struct _VV_ENTRY {
    GVSN                        GVsn;               // MUST BE FIRST
    LIST_ENTRY                  ListHead;
    ULONG                       CleanUpFlags;
} VV_ENTRY, *PVV_ENTRY;

#define VV_ENTRY_RETIRE_ACTIVE   0x00000001

#define VV_RETIRE_SLOT_FLAG_OUT_OF_ORDER    0x00000001

typedef struct _VV_RETIRE_SLOT {
    LIST_ENTRY                  Link;
    ULONGLONG                   Vsn;
    ULONG                       CleanUpFlags;
    ULONG                       RetireSlotFlags;
    struct _CHANGE_ORDER_ENTRY_ *ChangeOrder;
} VV_RETIRE_SLOT, *PVV_RETIRE_SLOT;


//
// The following struct defines the common information related to a given
// replica set.  This is reference by all threads using the replica set.
// Put this struct into a Generic Table indexed by GUID.
// A machine can have several members of the same replica set. The member's
// guid is used to identify the replica set.
//
struct _COMMAND_PACKET;
struct _VOLUME_MONITOR_ENTRY;
typedef struct _QHASH_TABLE_ QHASH_TABLE, *PQHASH_TABLE;

typedef struct _REPLICA {
    FRS_NODE_HEADER     Header;           // memory management
    CRITICAL_SECTION    ReplicaLock;      // protects filter list (for now)
    ULONG               ReferenceCount;
    ULONG               CnfFlags;         // From the config record
    ULONG               ReplicaSetType;   // Type of replica set
    ULONG               FrsRsoFlags;      // From ATTR_FRS_FLAGS in ntfrsReplicaSet object.
    BOOL                Consistent;       // replica is consistent
    BOOL                IsOpen;           // database table is open
    BOOL                IsJournaling;     // journal has been started
    BOOL                IsAccepting;      // accepting comm requests
    BOOL                NeedsUpdate;      // needs updating in the database
    BOOL                IsSeeding;        // Seeding thread is deployed
    BOOL                IsSysvolReady;    // SysvolReady is set to 1
    LIST_ENTRY          ReplicaList;      // Link all replicas together
    ULONG               ServiceState;     // stop, started, ...
    FRS_ERROR_CODE      FStatus;          // error
    PFRS_QUEUE          Queue;            // controlled by the command server
    PGNAME              ReplicaName;      // Set name/Server guid from the DS
    ULONG               ReplicaNumber;    // Internal id (name)
    PGNAME              MemberName;       // Member name/guid from the DS
    PGNAME              SetName;          // Set/guid name from the DS
    GUID                *ReplicaRootGuid; // guid assigned to Root dir
    GUID                ReplicaVersionGuid; // originator guid for version vector
    PSCHEDULE           Schedule;         // schedule
    PGEN_TABLE          VVector;          // Version vector
    PGEN_TABLE          OutlogVVector;    // Version vector for records in outlog.
    PGEN_TABLE          Cxtions;          // in/outbound cxtions
    PWCHAR              Root;             // Root path
    PWCHAR              Stage;            // Staging path
    PWCHAR              NewStage;         // This maps to the current staging path in the
                                          // DS. NewStage will be the one written to
                                          // the config record but Stage will be used until
                                          // next reboot.
    PWCHAR              Volume;           // Volume???
    ULONGLONG           MembershipExpires;// membership tombstone
    ULONGLONG           PreInstallFid;    // For journal filtering.
    TABLE_CTX           ConfigTable;      // Db table context
    FRS_LIST            ReplicaCtxListHead; // Links all open contexts on this replica set.

    PWCHAR              FileFilterList;         // Raw file filter
    PWCHAR              FileInclFilterList;     // Raw file inclusion filter

    PWCHAR              DirFilterList;          // Raw directory filter
    PWCHAR              DirInclFilterList;      // Raw directory inclusion filter

    LIST_ENTRY          FileNameFilterHead;     // Head of file name exclusion filter list.
    LIST_ENTRY          FileNameInclFilterHead; // Head of file name inclusion filter list.

    LIST_ENTRY          DirNameFilterHead;      // Head of directory name filter list.
    LIST_ENTRY          DirNameInclFilterHead;  // Head of directory name Inclusion filter list.

    PQHASH_TABLE        NameConflictTable;  // Sequence COs using the same file name.

    LONG                InLogRetryCount;  // Count of number CO needing a Retry.
    ULONG               InLogSeqNumber;   // The last sequence number used in Inlog
    //
    //
    // The inlog retry table tracks which retry change orders are currently
    // active so we don't reissue the same change order until current
    // invocation completes.  This can happen when the system gets backed up
    // and the change order retry thread kicks off again to issue retry COs
    // before the last batch are able to finish.  This state could be kept in
    // the Inlog record but then it means extra writes to the DB.
    // The sequence number is used to detect changes in the table when we don't
    // have the lock.  It is per-replica because it uses the change order
    // sequence number of the inlog record and they aren't unique across
    // replicas.
    //
    PQHASH_TABLE        ActiveInlogRetryTable;
    union {
        struct {
            ULONG       AIRSequenceNum;
            ULONG       AIRSequenceNumSample;
        };
        ULONGLONG QuadChunkA;
    };

    //
    // Status of sysvol seeding.
    // Returned for NtFrsApi_Rpc_PromotionStatusW().
    //
    DWORD               NtFrsApi_ServiceState;
    DWORD               NtFrsApi_ServiceWStatus;
#ifndef NOVVJOINHACK
    DWORD               NtFrsApi_HackCount;         // temporary hack
#endif NOVVJOINHACK
    PWCHAR              NtFrsApi_ServiceDisplay;

    //
    // List and queues used by the InitSync Command server.
    //
    PGEN_TABLE          InitSyncCxtionsMasterList;  // sorted list of inbound connections
                                                    // used to serialize initial vvjoin.
    PGEN_TABLE          InitSyncCxtionsWorkingList; // subset of the InitSyncCxtionsMasterList.
                                                    // current working list.
    PFRS_QUEUE          InitSyncQueue;              // Queue for the initsync command server.

    //
    // The Outbound log process state for this replica.
    //
    CRITICAL_SECTION    OutLogLock;       // protects the OutLog state
    LIST_ENTRY          OutLogEligible;   // Eligible outbound log partners
    LIST_ENTRY          OutLogStandBy;    // Partners ready to join eligible list
    LIST_ENTRY          OutLogActive;     // Active outbound log partners
    LIST_ENTRY          OutLogInActive;   // Inactive outbound log partners

    ULONGLONG           OutLogRepeatInterval; // Minimum Time in sec between sending update COs
    PQHASH_TABLE        OutLogRecordLock; // Sync access to outlog records.
    PQHASH_TABLE        OutLogDominantTable; // Tracks dominate COx when multiple COs for same file are present.
    ULONG               OutLogSeqNumber;  // The last sequence number used in Outlog
    ULONG               OutLogJLx;        // The Joint Leading Index
    ULONG               OutLogJTx;        // The Joint Trailing Index
    ULONG               OutLogCOMax;      // The index of the Max change order in the log.
    ULONG               OutLogCOMin;      // The index of the Min change order in the log.
    ULONG               OutLogWorkState;  // The output log current processing state.
    struct _COMMAND_PACKET *OutLogCmdPkt; // Cmd pkt to queue when idle and have work.
    PTABLE_CTX          OutLogTableCtx;   // Output Log Table context.
    ULONG               OutLogCountVVJoins; // Count of number of VVJoins in progress.
    BOOL                OutLogDoCleanup;  // True means give log cleanup a run.
    ULONG               OutLogCxtionsJoined;  // Count of Outlog connections that have been joined at least once.

    //
    // The handle to the preinstall directory
    //
    HANDLE              PreInstallHandle;

    //
    // The volume journal state for this replica.
    //
    GUID                JrnlCxtionGuid;    // Used as the Cxtion Guid for Local Cos
    USN                 InlogCommitUsn;    // Our current USN Journal commit point.
    //USN                 JournalUsn;      // The Journal USN for this replica.
    USN                 JrnlRecoveryStart; // Point to start recovery.
    USN                 JrnlRecoveryEnd;   // Point where recovery is complete.
    LIST_ENTRY          RecoveryRefreshList; // List of file refresh req change orders.
    LIST_ENTRY          VolReplicaList;    // Links all REPLICA structs on volume together.
    USN                 LastUsnRecordProcessed; // Current Journal subsystem read USN.
    LONG                LocalCoQueueCount; // Count of number local COs in process queue

    struct _VOLUME_MONITOR_ENTRY  *pVme;  // Ref to the VME for this Replica.
    struct _HASHTABLEDATA_REPLICASET *PerfRepSetData;  // PERFMON counter data structure
} REPLICA, *PREPLICA;



//
// FRS Flags defs from FRS Replica Set Object.
//
//
// If true, Install Override tells FRS to attempt to rename an opened
// target file out of the way in order to allow installation of a new
// updated version of the file.  E.G. an open .exe or .dll file would
// be treated this way.  Normally (i.e. when FALSE) FRS will wait until
// it can open the target with write access.  Install override only works
// if FRS can open the file for rename.  This requires DELETE access to
// the file so if the target file is currently open with a sharing mode
// that denies DELETE access to other opens then FRS will not be able to
// install the updated version until the file is closed.
// *NOTE* Install Override only applies to files, not directories.
//
#define FRS_RSO_FLAGS_ENABLE_INSTALL_OVERRIDE    0x00000001

//
// If true, then remote change orders that update existing files will
// always use a pre-install file in which to build the content followed
// by a rename to insert the file into its target location in the replica
// tree.  The benefit is that if FRS runs out of disk space during the
// install phase or the system crashes then a partial file (or a truncated file)
// is not left in the tree.  The old content is left in place.  The
// drawback of this is the need for enough disk space to hold two copies of
// the target file.
//
#define FRS_RSO_FLAGS_ENABLE_RENAME_UPDATES      0x00000002


#define REPLICA_OPTION_ENABLED(_replica_, _x_)  BooleanFlagOn((_replica_)->FrsRsoFlags, (_x_))



#define OutLogAcquireLock(_Replica_) EnterCriticalSection(&((_Replica_)->OutLogLock))
#define OutLogReleaseLock(_Replica_) LeaveCriticalSection(&((_Replica_)->OutLogLock))


//
// Replica States (these track the journal states)
//
#define REPLICA_STATE_ALLOCATED                          0
#define REPLICA_STATE_INITIALIZING                       1
#define REPLICA_STATE_STARTING                           2
#define REPLICA_STATE_ACTIVE                             3

#define REPLICA_STATE_4_UNUSED                           4
#define REPLICA_STATE_PAUSING                            5
#define REPLICA_STATE_PAUSED                             6
#define REPLICA_STATE_STOPPING                           7

#define REPLICA_STATE_STOPPED                            8
#define REPLICA_STATE_ERROR                              9
#define REPLICA_STATE_JRNL_WRAP_ERROR                   10
#define REPLICA_STATE_REPLICA_DELETED                   11

#define REPLICA_STATE_MISMATCHED_VOLUME_SERIAL_NO       12
#define REPLICA_STATE_MISMATCHED_REPLICA_ROOT_OBJECT_ID 13
#define REPLICA_STATE_MISMATCHED_REPLICA_ROOT_FILE_ID   14
#define REPLICA_STATE_MISMATCHED_JOURNAL_ID             15

#define REPLICA_STATE_MAX                               15

#define REPLICA_IN_ERROR_STATE(_x_) (          \
    ((_x_) == REPLICA_STATE_ERROR)             \
    )

#define REPLICA_FSTATUS_ROOT_HAS_MOVED(_x_) (                     \
    ((_x_) == FrsErrorMismatchedVolumeSerialNumber)   ||          \
    ((_x_) == FrsErrorMismatchedReplicaRootObjectId)  ||          \
    ((_x_) == FrsErrorMismatchedReplicaRootFileId)                \
    )


#define REPLICA_STATE_NEEDS_RESTORE(_x_) (                                 \
    (((_x_) == REPLICA_STATE_JRNL_WRAP_ERROR) && DebugInfo.EnableJrnlWrapAutoRestore)  ||   \
    ((_x_) == REPLICA_STATE_MISMATCHED_VOLUME_SERIAL_NO)       ||          \
    ((_x_) == REPLICA_STATE_MISMATCHED_REPLICA_ROOT_OBJECT_ID) ||          \
    ((_x_) == REPLICA_STATE_MISMATCHED_REPLICA_ROOT_FILE_ID)   ||          \
    (((_x_) == REPLICA_STATE_MISMATCHED_JOURNAL_ID) && DebugInfo.EnableJrnlWrapAutoRestore) \
    )

#define REPLICA_IS_ACTIVE_MASK 0x00000068    // 0110 1000
#define REPLICA_IS_ACTIVE(_Replica_)                                      \
    ((( 1 << (_Replica_)->ServiceState) & REPLICA_IS_ACTIVE_MASK) != 0)

//
// State of Replica with respect to the Output log process. (OutLogWorkState)
//
#define OL_REPLICA_INITIALIZING   0
#define OL_REPLICA_WAITING        1     // Waiting for change orders to send
#define OL_REPLICA_WORKING        2     // On the work queue sending COs
#define OL_REPLICA_STOPPING       3     // STOP request initiated.
#define OL_REPLICA_STOPPED        4     // Out Log activity on replica stopped.
#define OL_REPLICA_NOPARTNERS     5     // There are no outbound partners.
#define OL_REPLICA_ERROR          6
#define OL_REPLICA_PROC_MAX_STATE 6


//
// Macro to update state field of Outbound log processing on this replica.
//
#define SET_OUTLOG_REPLICA_STATE(_Replica_, _state_)                       \
{                                                                          \
    DPRINT3(4, ":X: OutLogWorkState change from %s to %s for %ws\n",       \
            OLReplicaProcStateNames[(_Replica_)->OutLogWorkState],         \
            OLReplicaProcStateNames[(_state_)],                            \
            (_Replica_)->ReplicaName->Name);                               \
    (_Replica_)->OutLogWorkState = (_state_);                              \
}

#define HASH_REPLICA(_p_, _TABLE_SIZE_) \
( ( (((ULONG)_p_) >> 4) + (((ULONG)_p_) >> 16) ) & ((_TABLE_SIZE_)-1) )

#define NO_OUTLOG_PARTNERS(_Replica_) (Replica->OutLogCxtionsJoined == 0)

//
// Macros for managing the LocalCoQueueCount
//
#define  INC_LOCAL_CO_QUEUE_COUNT(_R_)                       \
{                                                            \
    LONG Temp;                                               \
    Temp = InterlockedIncrement(&(_R_)->LocalCoQueueCount);  \
    DPRINT1(5, "++LocalCoQueueCount now %d\n", Temp);        \
}

#define  DEC_LOCAL_CO_QUEUE_COUNT(_R_)                       \
{                                                            \
    LONG Temp;                                               \
    Temp = InterlockedDecrement(&(_R_)->LocalCoQueueCount);  \
    DPRINT1(5, "--LocalCoQueueCount now %d\n", Temp);        \
}



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                            F R S _ T H R E A D                            **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

//
// Keep track of the threads we create
//
typedef struct _FRS_THREAD   FRS_THREAD, *PFRS_THREAD;
struct _FRS_THREAD {
    FRS_NODE_HEADER Header;               // memory management
    LIST_ENTRY      List;                 // list of all threads
    HANDLE          Handle;               // handle for this thread (may be NULL)
    DWORD           Id;                   // Id returned by CreateThread()
    LONG            Ref;                  // reference count
    PVOID           Data;                 // Set by FrsThreadInit parameter
    ULARGE_INTEGER  StartTime;            // Start of rpc call
    BOOL            Running;              // Thread is assumed to be running
    PWCHAR          Name;                 // printable name
    DWORD           ExitTombstone;        // if non-zero then start of Tombstone period.
    DWORD           (*Main)(PVOID);       // entry point
    DWORD           (*Exit)(PFRS_THREAD); // exit the thread
};


 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                            V O L U M E  G U I D  I N F O                  **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

typedef struct _VOLUME_INFO_NODE {
    WCHAR     DriveName[8];       // Drive name of the form "\\.\D:\"
    ULONG     VolumeSerialNumber; // VolumeSerialNumber.
} VOLUME_INFO_NODE, *PVOLUME_INFO_NODE;



 /******************************************************************************
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 **                            G U I D / H A N D L E                          **
 **                                                                           **
 **                                                                           **
 *******************************************************************************
 ******************************************************************************/

typedef struct _HANDLE_LIST HANDLE_LIST, *PHANDLE_LIST;
struct _HANDLE_LIST {
    PHANDLE_LIST    Next;       // next handle
    handle_t        RpcHandle;  // a bound rpc handle
};

//
// Keep track of rpc handles to a specific machine (guid)
//
typedef struct _GHANDLE GHANDLE, *PGHANDLE;
struct _GHANDLE {
    FRS_NODE_HEADER     Header;         // memory management
    CRITICAL_SECTION    Lock;           // protects the list of handles
    BOOL                Ref;            // Reference bit
    GUID                Guid;           // machine guid
    PHANDLE_LIST        HandleList;     // list of rpc handles
};


/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**                          Q H A S H    T A B L E                           **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/


//
// The hash calc routine is called to generate the hash value of the key data
// on lookups and inserts.
//
typedef
ULONG
(NTAPI *PQHASH_CALC2_ROUTINE) (
    PVOID Buf,
    PULONGLONG QKey
);

//
// The keymatch routine is called to confirm an exact match on the Key Data.
//
typedef
BOOL
(NTAPI *PQHASH_KEYMATCH_ROUTINE) (
    PVOID Buf,
    PVOID QKey
);

//
//  The free routine is called on the nodes of the large key QHash tables
//  when the table is freed.
//

typedef
PVOID
(NTAPI *PQHASH_FREE_ROUTINE) (
    PVOID Buf
    );

//
// The Qhash entry.   *** Keep the size of this a multiple of quadwords.
//
typedef struct _QHASH_ENTRY_ {
    SINGLE_LIST_ENTRY     NextEntry;
    ULONG_PTR             Flags;
    ULONGLONG             QKey;
    ULONGLONG             QData;

} QHASH_ENTRY, *PQHASH_ENTRY;



typedef struct _QHASH_TABLE_ {
    FRS_NODE_HEADER                Header;
    ULONG                          BaseAllocSize;
    ULONG                          ExtensionAllocSize;
    LIST_ENTRY                     ExtensionListHead;
    SINGLE_LIST_ENTRY              FreeList;
    CRITICAL_SECTION               Lock;

    HANDLE                         HeapHandle;
    PGENERIC_HASH_CALC_ROUTINE     HashCalc;
    PQHASH_CALC2_ROUTINE           HashCalc2;
    PQHASH_KEYMATCH_ROUTINE        KeyMatch;
    PQHASH_FREE_ROUTINE            HashFree;
    ULONG                          NumberEntries;

    PQHASH_ENTRY                   HashRowBase;
    ULONG                          Flags;

} QHASH_TABLE, *PQHASH_TABLE;


#define QHashAcquireLock(_Table_) EnterCriticalSection(&((_Table_)->Lock))
#define QHashReleaseLock(_Table_) LeaveCriticalSection(&((_Table_)->Lock))

#define SET_QHASH_TABLE_HASH_CALC(_h_, _f_)  (_h_)->HashCalc = (_f_)
#define SET_QHASH_TABLE_HASH_CALC2(_h_, _f_)  (_h_)->HashCalc2 = (_f_)
#define SET_QHASH_TABLE_KEY_MATCH(_h_, _f_)  (_h_)->KeyMatch = (_f_)
#define SET_QHASH_TABLE_FREE(_h_, _f_)  (_h_)->HashFree = (_f_)

#define QHASH_FLAG_LARGE_KEY      0x00000001

#define SET_QHASH_TABLE_FLAG(_h_, _f_)  (_h_)->Flags |= (_f_)

#define IS_QHASH_LARGE_KEY(_h_)  BooleanFlagOn((_h_)->Flags, QHASH_FLAG_LARGE_KEY)

#define DOES_QHASH_LARGE_KEY_MATCH(_h_, _a_, _b_)                              \
    (!IS_QHASH_LARGE_KEY(_h_) || ((_h_)->KeyMatch)((PVOID)(_a_), (PVOID)(_b_)))


//
// The argument function passed to QHashEnumerateTable().
//
typedef
ULONG
(NTAPI *PQHASH_ENUM_ROUTINE) (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    );

ULONG
QHashDump (
    PQHASH_TABLE Table,
    PQHASH_ENTRY BeforeNode,
    PQHASH_ENTRY TargetNode,
    PVOID Context
    );

ULONG
QHashEnumerateTable(
    IN PQHASH_TABLE HashTable,
    IN PQHASH_ENUM_ROUTINE Function,
    IN PVOID Context
    );

GHT_STATUS
QHashLookup(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    OUT PULONGLONG  QData,
    OUT PULONG_PTR  Flags
    );

PQHASH_ENTRY
QHashLookupLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    );

GHT_STATUS
QHashInsert(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG QData,
    IN ULONG_PTR Flags,
    IN BOOL HaveLock
    );

PQHASH_ENTRY
QHashInsertLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG QData,
    IN ULONG_PTR Flags
    );

GHT_STATUS
QHashUpdate(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey,
    IN PULONGLONG QData,
    IN ULONG_PTR Flags
    );

GHT_STATUS
QHashDelete(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    );

VOID
QHashDeleteLock(
    IN PQHASH_TABLE HashTable,
    IN PVOID        ArgQKey
    );

VOID
QHashDeleteByFlags(
    IN PQHASH_TABLE HashTable,
    IN ULONG_PTR Flags
    );

VOID
QHashEmptyLargeKeyTable(
    IN PQHASH_TABLE HashTable
    );

/******************************************************************************
*******************************************************************************
**                                                                           **
**                                                                           **
**                  V O L U M E    M O N I T O R     E N T R Y               **
**                                                                           **
**                                                                           **
*******************************************************************************
******************************************************************************/

//
// A volume monitor entry is allocated for each file system volume we monitor.
// When a new replica set is initialized we check the list first to see if
// we are already monitoring the journal on that volume.  The reference count
// tracks the number of replica sets that are active on this volume.  When
// it goes to zero we can stop monitoring the volume journal.
//
// IoActive is set TRUE when the first Read request is sent to the journal.
// From that point on the JournalReadThread will continue to post new read
// requests as the previous request completes.  When the referen