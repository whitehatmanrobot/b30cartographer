          BYTE FileName[MAX_PATH+10];
                IO_STATUS_BLOCK Iosb2;

                Status = NtQueryInformationFile(
                    ChildHandle,
                    &Iosb2,
                    FileName,
                    sizeof( FileName ),
                    FileNameInformation );

                if (!NT_SUCCESS( Status )) {
                    printf( "\nNtQUeryInformationFile failed - %x\n", Status );
                } else {
                    PFILE_NAME_INFORMATION fn = (PFILE_NAME_INFORMATION) FileName;
                    printf( "%.*ws\n", fn->FileNameLength / sizeof( WCHAR ), fn->FileName );
                }

                NtClose( ChildHandle );
            }

            FileNameInfo = 
                (PFILE_NAME_INFORMATION) Add2Ptr( FileNameInfo, QuadAlign( Length ));
        }
    }
    
    
    //
    //  Close the file
    //
    
    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfskd\ntfskdapi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    NtfsKd.c

Abstract:

    KD Extension Api for examining Ntfs specific data structures

Author:

    Keith Kaplan [KeithKa]    24-Apr-96
    Portions by Jeff Havens

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

KDDEBUGGER_DATA64 KdDebuggerData;

//
// The help strings printed out
//

static LPSTR Extensions[] = {
    "NTFS Debugger Extensions:\n",
    "cachedrecords               Dump all threads with cached filerecord bcbs",
    "cachedruns [addr]           Dump the given cached run array ",
    "ccb        [addr]           Dump Cache Control Block",
    "fcb        [addr] [1|2|...] Dump File Control Block",
    "fcbtable   [addr] [1|2|...] Dump File Control Block Table",
    "file       [addr] [1|2|...] Dump File Object",
    "filerecord [addr]           Dump the on-disk file record if cached, addr can be a fileobj, fcb or scb",
    "foirp      [addr] [1|2|...] Dump File Object by IRP address",
    "hashtable  [addr]           Dump an lcb hashtable",
    "icthread   [addr] [1|2|...] Dump IrpContext by thread address",
    "irpcontext [addr] [1|2|...] Dump IrpContext structure",
    "lcb        [addr]           Dump Link Control Block",
    "mcb        [addr]           Dump Map Control Block",
    "ntfsdata          [1|2|...] Dump NtfsData structure",
    "ntfshelp                    Dump this display",
    "scb        [addr] [1|2|...] Dump Stream Control Block",
    "transaction [addr]          Dump the transaction attached to an irpcontext",
    "vcb        [addr] [0|1|2]   Dump Volume Control Block",
    0
};



VOID
ParseAndDump (
    IN PCHAR args,
    IN BOOL NoOptions,
    IN STRUCT_DUMP_ROUTINE DumpFunction,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    )

/*++

Routine Description:

    Parse command line arguments and dump an ntfs structure.

Arguments:

    Args - String of arguments to parse.

    DumpFunction - Function to call with parsed arguments.

Return Value:

    None

--*/

{
    CHAR StringStructToDump[1024];
    CHAR StringStructToDump2[1024];
    ULONG64 StructToDump = 0;
    ULONG64 StructToDump2 = 0;
    LONG Options;

    //
    //  If the caller specified an address then that's the item we dump
    //

    StructToDump = 0;
    Options = 0;

    StringStructToDump[0] = '\0';

    if (*args) {
        if (NoOptions) {
            sscanf(args,"%s %s", StringStructToDump, StringStructToDump2 );
            if (!GetExpressionEx(args,&StructToDump, &args)) {
                dprintf("unable to get expression %s\n",StringStructToDump);
                return;
            }
            if (!GetExpressionEx(args,&StructToDump2, &args)) {
                dprintf("unable to get expression %s\n",StringStructToDump2);
                return;
            }
        } else {
            sscanf(args,"%s %lx", StringStructToDump, &Options );
            if (!GetExpressionEx(args,&StructToDump, &args)) {
                dprintf("unable to get expression %s\n",StringStructToDump);
                return;
            }
        }
    }

    (*DumpFunction) ( StructToDump, StructToDump2, Options, Processor, hCurrentThread );

    dprintf( "\n" );
}


VOID
PrintHelp (
    VOID
    )
/*++

Routine Description:

    Dump out one line of help for each DECLARE_API

Arguments:

    None

Return Value:

    None

--*/
{
    int i;

    for( i=0; Extensions[i]; i++ ) {
        dprintf( "   %s\n", Extensions[i] );
    }
}


DECLARE_API( ccb )

/*++

Routine Description:

    Dump ccb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpCcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( fcb )

/*++

Routine Description:

    Dump fcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( fcbtable )

/*++

Routine Description:

    Dump fcb table struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFcbTable, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( file )

/*++

Routine Description:

    Dump FileObject struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFileObject, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( filerecord )

/*++

Routine Description:

    Dump file record struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFileRecord, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( foirp )

/*++

Routine Description:

    Dump FileObject struct, given an irp

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFileObjectFromIrp, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( icthread )

/*++

Routine Description:

    Dump IrpContext struct, given a Thread

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpIrpContextFromThread, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( irpcontext )

/*++

Routine Description:

    Dump IrpContext

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpIrpContext, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( lcb )

/*++

Routine Description:

    Dump lcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpLcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( logfile )

/*++

Routine Description:

    Dump log file

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpLogFile, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( mcb )

/*++

Routine Description:

    Dump mcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpMcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( ntfsdata )

/*++

Routine Description:

    Dump the NtfsData struct

Arguments:

    arg - [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpNtfsData, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( ntfshelp )

/*++

Routine Description:

    Dump help message

Arguments:

    None

Return Value:

    None

--*/

{
    INIT_API();

    PrintHelp();
}


DECLARE_API( scb )

/*++

Routine Description:

    Dump Scb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpScb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( vcb )

/*++

Routine Description:

    Dump Vcb struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpVcb, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( dsc )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpSysCache, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( cachedrecords )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpCachedRecords, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( extents )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpExtents, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( hashtable )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, TRUE, (STRUCT_DUMP_ROUTINE) DumpHashTable, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( dumpchain )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpFcbLcbChain, (USHORT)dwProcessor, hCurrentThread );
}


DECLARE_API( overflow )

/*++

Routine Description:

    Dump private syscache log from SCB

Arguments:

    arg - [scb address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpOverflow, (USHORT)dwProcessor, hCurrentThread );
}




DECLARE_API( cachedruns )

/*++

Routine Description:

    Dump the cached runs structure

Arguments:

    arg - [cached runs address]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpCachedRuns, (USHORT)dwProcessor, hCurrentThread );
}



DECLARE_API( transaction )

/*++

Routine Description:

    Dump the transaction associated with the given irpcontext

Arguments:

    arg - [irpcontext]

Return Value:

    None

--*/

{
    INIT_API();

    ParseAndDump( (PCHAR) args, FALSE, (STRUCT_DUMP_ROUTINE) DumpTransaction, (USHORT)dwProcessor, hCurrentThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\longstream.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    LongStream.cxx

Abstract:

    Create some long stream names

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <string.h>
#include <stdio.h>

#define DEFAULT_DATA_STREAM "::$DATA"

//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    if (RelatedObject == NULL) {
        
        RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    } else {
        
        RtlInitUnicodeString(&str, pwszFile);

    }

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		RelatedObject,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}


void DumpStreams( 
    char *FileName
    )
{
    WCHAR UnicodeFileName[2*MAX_PATH];
    NTSTATUS Status;
    HANDLE FileHandle;

    printf( "%s:\n", FileName );
    
    //
    //  Make the filename into something unicode
    //

    SzToWsz( UnicodeFileName, FileName );

    //
    //  Create the base file
    //
    
    Status = OpenObject( UnicodeFileName,
                         NULL,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         &FileHandle );

    if (!NT_SUCCESS( Status )) {
        printf( "unable to open filename - %x\n", Status );
        return;
    }
        
    //
    //  Dump out all stream names
    //

    ULONG Length = 32768;
    PBYTE BigBuffer = new BYTE[Length];
    IO_STATUS_BLOCK IoStatusBlock;

    Status = NtQueryInformationFile( FileHandle, &IoStatusBlock, BigBuffer, Length, FileStreamInformation );
    if (!NT_SUCCESS( Status )) {
        printf( "Can't get stream names - %x\n", Status );
    } else {
        PFILE_STREAM_INFORMATION FileStreamInformation = (PFILE_STREAM_INFORMATION) BigBuffer;

        while ((ULONG)((PBYTE)FileStreamInformation - BigBuffer) < IoStatusBlock.Information) {
            printf( "%16I64x %16I64x %.*ws\n",
                    FileStreamInformation->StreamSize,
                    FileStreamInformation->StreamAllocationSize,
                    FileStreamInformation->StreamNameLength,
                    FileStreamInformation->StreamName
                    );
            if (FileStreamInformation->NextEntryOffset == 0) {
                break;
            }
            FileStreamInformation = (PFILE_STREAM_INFORMATION)((PBYTE)FileStreamInformation + FileStreamInformation->NextEntryOffset);
        }
    }

    NtClose( FileHandle );
}


void
LongStream (
    char *FileName
    )
{
    WCHAR UnicodeFileName[2*MAX_PATH];
    NTSTATUS Status;
    HANDLE FileHandle;

    //
    //  Make the filename into something unicode
    //

    SzToWsz( UnicodeFileName, FileName );

    //
    //  Create the base file
    //
    
    Status = OpenObject( UnicodeFileName,
                         NULL,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         &FileHandle );

    if (!NT_SUCCESS( Status )) {
        printf( "unable to open filename - %x\n", Status );
        return;
    }
        
    
    //
    //  Binary loop creating stream names trying to find the max length allowed
    //

    ULONG StartLength = 1024;
    ULONG GrowLength = 1024;

    while (GrowLength != 0) {
        PWCHAR UnicodeStreamName = new WCHAR[StartLength + 2];
        HANDLE StreamHandle;

        UnicodeStreamName[0] = L':';
        for (ULONG i = 0; i < StartLength; i++) {
            UnicodeStreamName[i + 1] = L'Z';
        }
        UnicodeStreamName[StartLength + 1] = L'\0';

        Status = OpenObject( UnicodeStreamName,
                             FileHandle,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             &StreamHandle );
        
        delete [] UnicodeStreamName;
        
        if (!NT_SUCCESS( Status )) {
            printf( "Failure at %d\n", StartLength );
            StartLength -= GrowLength;
            GrowLength /= 2;
            StartLength += GrowLength;
        } else {
            printf( "Success at %d\n", StartLength );
            GrowLength /= 2;
            StartLength += GrowLength;
        }
    }

    NtClose( FileHandle );
}



int __cdecl
main (
    int argc,
    char **argv)
{
    argc--;
    argv++;

    if (argc == 0) {
        return 0;
    }

    if (!_stricmp( "-d", argv[0])) {
        DbgPrint( "--------------------------------------------\n" );
        while (--argc != 0) {
            DumpStreams( *++argv );
        }
        DbgPrint( "--------------------------------------------\n" );
    } else {
        DbgPrint( "--------------------------------------------\n" );
        while (argc-- != 0) {
            LongStream( *argv++ );
        }
        DbgPrint( "--------------------------------------------\n" );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bkup.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    bkup.c - test backup read / write

Abstract:

    Driver for backup read/write

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <tchar.h>


//
//
//

#define SHIFTBYN(c,v,n) ((c) -= (n), (v) += (n))
#define SHIFT(c,v) SHIFTBYN( (c), (v), 1 )

void Usage( void )
{
    fprintf( stderr, "Usage:  bkup [-r file] performs backup read, output to stdout\n" );
    fprintf( stderr, "             [-w backupimage newfile] performs backup write\n" );
}

int __cdecl
main (
    int argc,
    char **argv
    )
{
    SHIFT( argc, argv );
    
    if (argc == 2 && !strcmp( *argv, "-r" )) {
        SHIFT( argc, argv );
        
        HANDLE h = CreateFile( *argv,               //  file name
                               FILE_READ_DATA | FILE_READ_ATTRIBUTES,
                                                    //  desired access
                               FILE_SHARE_READ,     //  share mode
                               NULL,                //  security
                               OPEN_EXISTING,       //  disposition
                               0,                   //  flags and attributes
                               0 );                 //  template file

        if (h == INVALID_HANDLE_VALUE) {
            fprintf( stderr, "CreateFile returned %x\n", GetLastError( ));
            return 1;
        }

        BYTE *p = new BYTE[65536];
        ULONG Length, Written;
        
        PVOID Context = NULL;
        
        while (TRUE) {
            if (!BackupRead( h, p, 65536, &Length, FALSE, TRUE, &Context )) {
                fprintf( stderr, "BackupRead returned %x\n", GetLastError( ));
                return 1;
            }
            
            if (Length == 0) {
                break;
            }
            
            fprintf( stderr, "Transferring %x\n", Length );
            if (!WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), p, Length, &Written, NULL ))
            {
                fprintf( stderr, "WriteFile returned %x\n", GetLastError( ));
                return 1;
            }
        }
    } else if (argc == 3 && !strcmp( *argv, "-w" )) {
        SHIFT( argc, argv );

        HANDLE hOld = CreateFile( *argv,            //  file name
                                  FILE_READ_DATA,   //  desired access
                                  FILE_SHARE_READ,  //  share mode
                                  NULL,             //  security
                                  OPEN_EXISTING,    //  disposition
                                  0,                //  flags and attributes
                                  0 );              //  template file

        if (hOld == INVALID_HANDLE_VALUE) {
            fprintf( stderr, "CreateFile destination returned %x\n", GetLastError( ));
            return 1;
        }

        SHIFT( argc, argv );
        
        HANDLE hNew = CreateFile( *argv,            //  file name
                                  FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES,
                                                    //  desired access
                                  FALSE,            //  share mode
                                  NULL,             //  security
                                  CREATE_ALWAYS,    //  disposition
                                  0,                //  flags and attributes
                                  0 );              //  template file

        if (hNew == INVALID_HANDLE_VALUE) {
            fprintf( stderr, "CreateFile destination returned %x\n", GetLastError( ));
            return 1;
        }

        BYTE *p = new BYTE[127];
        ULONG Length, Written;
        
        PVOID Context = NULL;
        
        while (TRUE) {
            if (!ReadFile( hOld, p, 127, &Length, NULL )) {
                fprintf( stderr, "ReadFile returned %x\n", GetLastError( ));
                return 1;
            }
            
            if (Length == 0) {
                break;
            }

            fprintf( stderr, "Transferring %x\n", Length );
            
            if (!BackupWrite( hNew, p, Length, &Written, FALSE, TRUE, &Context )) {
                fprintf( stderr, "BackupWrite returned %x\n", GetLastError( ));
                return 1;
            }
        }
    } else {
        Usage( );
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\ntfskd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE
#define RTL_USE_AVL_TABLES 0

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>
#include <imagehlp.h>

#include <memory.h>

#include <fsrtl.h>

#undef CREATE_NEW
#undef OPEN_EXISTING

#include <ntfsproc.h>

PSTR
FormatValue(
    ULONG64 addr
    );

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif //  DBG

//
//  We're 64 bit aware
//          

#define KDEXT_64BIT

#define KDEXT_64BIT
#include <wdbgexts.h>

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

typedef PVOID (*STRUCT_DUMP_ROUTINE)(
    IN ULONG64 Address,
    IN ULONG64 Address2,
    IN LONG Options,
    IN USHORT Processor,
    IN HANDLE hCurrentThread
    );

#define DECLARE_DUMP_FUNCTION(s)                   \
    VOID                                           \
    s(                                             \
        IN ULONG64 Address,                        \
        IN ULONG64 Address2,                       \
        IN LONG Options,                           \
        IN USHORT Processor,                       \
        IN HANDLE hCurrentThread                   \
     )

#define INIT_DUMP()                                                     \
    UNREFERENCED_PARAMETER( Address );                                  \
    UNREFERENCED_PARAMETER( Address2 );                                 \
    UNREFERENCED_PARAMETER( Options );                                  \
    UNREFERENCED_PARAMETER( Processor );                                \
    UNREFERENCED_PARAMETER( hCurrentThread );

#define INIT_API()                                                      \
    UNREFERENCED_PARAMETER( hCurrentProcess );                          \
    UNREFERENCED_PARAMETER( hCurrentThread );                           \
    UNREFERENCED_PARAMETER( dwCurrentPc );                              \
    UNREFERENCED_PARAMETER( dwProcessor );                              \
    UNREFERENCED_PARAMETER( args );                                     \
    if (GetExpression( "NTFS!NtfsData" ) == 0) {                        \
        Ioctl( IG_RELOAD_SYMBOLS, "NTFS.SYS", 8 );                      \
    }                                                                   \
    if (KdDebuggerData.KernBase == 0) {                                 \
        KdDebuggerData.Header.OwnerTag = KDBG_TAG;                      \
        KdDebuggerData.Header.Size = sizeof(KdDebuggerData);            \
        if (!Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof(KdDebuggerData) )) {   \
            KdDebuggerData.KernBase = 1;                                \
        }                                                               \
    }

extern KDDEBUGGER_DATA64 KdDebuggerData;


#define SYM(s)  "NTFS!" #s
#define NT(s)   "NT!" #s


typedef struct _DUMP_ENUM_CONTEXT {
    ULONG Options;
    USHORT Processor;
    HANDLE hCurrentThread;
    ULONG64 ReturnValue;
} DUMP_ENUM_CONTEXT, *PDUMP_ENUM_CONTEXT;


//
// prototypes
//

DECLARE_DUMP_FUNCTION( DumpCachedRecords );
DECLARE_DUMP_FUNCTION( DumpCcb );
DECLARE_DUMP_FUNCTION( DumpExtents );
DECLARE_DUMP_FUNCTION( DumpFcb );
DECLARE_DUMP_FUNCTION( DumpFcbLcbChain );
DECLARE_DUMP_FUNCTION( DumpFcbTable );
DECLARE_DUMP_FUNCTION( DumpFileObject );
DECLARE_DUMP_FUNCTION( DumpFileObjectFromIrp );
DECLARE_DUMP_FUNCTION( DumpFileRecord );
DECLARE_DUMP_FUNCTION( DumpFileRecordContents );
DECLARE_DUMP_FUNCTION( DumpHashTable );
DECLARE_DUMP_FUNCTION( DumpIrpContext );
DECLARE_DUMP_FUNCTION( DumpIrpContextFromThread );
DECLARE_DUMP_FUNCTION( DumpLcb );
DECLARE_DUMP_FUNCTION( DumpLogFile );
DECLARE_DUMP_FUNCTION( DumpMcb );
DECLARE_DUMP_FUNCTION( DumpNtfsData );
DECLARE_DUMP_FUNCTION( DumpOverflow );
DECLARE_DUMP_FUNCTION( DumpScb );
DECLARE_DUMP_FUNCTION( DumpSysCache );
DECLARE_DUMP_FUNCTION( DumpVcb );
DECLARE_DUMP_FUNCTION( DumpCachedRuns );
DECLARE_DUMP_FUNCTION( DumpTransaction );

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\quota.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <windows.h>

#define QuadAlign(n) (((n) + (sizeof(LONGLONG) - 1)) & ~(sizeof(LONGLONG) - 1))
#define DwordAlign(n)(((n) + (sizeof(ULONG) - 1)) & ~(sizeof(ULONG) - 1))

#define STRUCT_COUNT(n, type, name_length)                                         \
        ((((n) * QuadAlign(sizeof(type)) + ((name_length) * sizeof(WCHAR))) + \
          sizeof(type) - 1) /                                             \
         sizeof(type))

#define SID_MAX_LENGTH        \
    (FIELD_OFFSET(SID, SubAuthority) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)

#define DISK_EVENT_MODULE "System"

#define IO_FILE_QUOTA_THRESHOLD          ((NTSTATUS)0x40040024L)
#define IO_FILE_QUOTA_LIMIT              ((NTSTATUS)0x80040025L)

VOID
DumpQuota (
    IN PFILE_QUOTA_INFORMATION pfqi,
    IN PCHAR SeverName
    );

CHAR *
FileTimeToString(
    FILETIME *pft
    );

VOID
PrintError(
    ULONG ErrorCode
    );

VOID
Usage();

BOOLEAN QuickSid;

VOID
STDMETHODVCALLTYPE
main(
    int Argc,
    char *Argv[]
    )

{
    HANDLE FileHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ANSI_STRING DiskName;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG BufferSize;
    ULONG SidListLength;
    LONG i;
    PWCHAR Wstr;
    PEVENTLOGRECORD EventLogRecord;
    FILE_QUOTA_INFORMATION QuotaInfo[STRUCT_COUNT(10, FILE_QUOTA_INFORMATION, 4)];
    FILE_QUOTA_INFORMATION TempQuotaInfo[STRUCT_COUNT(1, FILE_QUOTA_INFORMATION, 32)];
    FILE_GET_QUOTA_INFORMATION SidList[STRUCT_COUNT(10, FILE_GET_QUOTA_INFORMATION, 4)];
    PFILE_GET_QUOTA_INFORMATION SidListPtr;
    PFILE_QUOTA_INFORMATION QuotaInfoPtr;
    FILE_FS_CONTROL_INFORMATION ControlInfo;
    FILE_FS_CONTROL_INFORMATION TempControlInfo;
    PCHAR ServerName = NULL;
    SID_NAME_USE SidNameUse;
    LARGE_INTEGER TempLargeInt;
    ULONG ErrorCode;
    ULONG DomainLength;
    CHAR Domain[100];
    PCHAR TempPtr;
    BOOLEAN UserGiven = 0;
    BOOLEAN DriveLetter = 0;
    BOOLEAN EventLog = 0;
    BOOLEAN SettingDefault = 0;
    BOOLEAN DefaultGiven = 0;
    BOOLEAN DeletingUser = 0;

    struct {
        UCHAR DefaultLimit : 1;
        UCHAR DefaultThreshold : 1;
        UCHAR Flags : 1;
    } DefaultFlags = { 0, 0, 0 };

    if (Argc < 2) {
        printf ( "Processor feature is %d\n", IsProcessorFeaturePresent(0));
        Usage();
        exit(1);
    }

    RtlZeroMemory(&QuotaInfo, sizeof(QuotaInfo));
    QuotaInfoPtr = QuotaInfo;
    RtlZeroMemory(&SidList, sizeof(SidList));
    SidListPtr = SidList;

    RtlInitString( &DiskName, "\\DosDevices\\d:\\$Extend\\$Quota:$Q:$INDEX_ALLOCATION" );
    RtlAnsiStringToUnicodeString( &NameString, &DiskName, TRUE );

    // Look for the d and repleace it with the requested Argument.

    for (Wstr = NameString.Buffer; *Wstr != L'd'; Wstr++);

    for (i = 1; i < Argc; i++) {

        if (*Argv[i] != '-') {

            if (DriveLetter || !isalpha(*Argv[i])) {
                Usage();
                exit(1);
            }

            TempPtr =  Argv[i];
            *Wstr = RtlAnsiCharToUnicodeChar( &TempPtr );
            DriveLetter++;
            continue;
        }

        switch (Argv[i][1]) {
        case 'd':

            DefaultGiven = 1;
            SettingDefault = 1;
            break;

        case 'e':

            if (EventLog) {
                Usage();
                exit(1);
            }

            if (Argv[i][2] == '\0') {
                i++;
                if (i < Argc && Argv[i][0] == '\\') {
                    ServerName = Argv[i];
                }

            } else {

                ServerName = &Argv[i][2];
            }

            EventLog++;
            break;

        case 'u':

            QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) ((PCHAR) QuotaInfoPtr +
                                QuotaInfoPtr->NextEntryOffset);

            SidListPtr = (PFILE_GET_QUOTA_INFORMATION) ((PCHAR) SidListPtr +
                                SidListPtr->NextEntryOffset);

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing user name\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }

            QuotaInfoPtr->SidLength = SID_MAX_LENGTH;
            DomainLength = sizeof(Domain);

            if (!LookupAccountName( NULL,
                                    TempPtr,
                                    &QuotaInfoPtr->Sid,
                                    &QuotaInfoPtr->SidLength,
                                    Domain,
                                    &DomainLength,
                                    &SidNameUse)) {

                printf("%s: Bad acccount name %s. Error = %d\n",
                       Argv[0],
                       TempPtr,
                       ErrorCode = GetLastError());

                PrintError( ErrorCode );
                exit(1);
            }

            //
            // Initialize the values to something resonable.
            //

            QuotaInfoPtr->QuotaThreshold.QuadPart = ~0I64;
            QuotaInfoPtr->QuotaLimit.QuadPart = ~0I64;

            QuotaInfoPtr->SidLength = RtlLengthSid( &QuotaInfoPtr->Sid);

            QuotaInfoPtr->NextEntryOffset =
                            FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) +
                            QuadAlign(QuotaInfoPtr->SidLength);

            memcpy( &SidListPtr->Sid, &QuotaInfoPtr->Sid, QuotaInfoPtr->SidLength);
            SidListPtr->SidLength = QuotaInfoPtr->SidLength;

            SidListPtr->NextEntryOffset =
                            FIELD_OFFSET( FILE_GET_QUOTA_INFORMATION, Sid ) +
                            QuadAlign(SidListPtr->SidLength);


            SettingDefault = 0;
            UserGiven++;
            break;

        case 't':

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing Argument\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }


            if (!sscanf( TempPtr, "%I64i", &TempLargeInt)) {
                printf("%s: Missing threshold value\n", Argv[0] );
                exit(1);
            }

            if (SettingDefault) {
                ControlInfo.DefaultQuotaThreshold = TempLargeInt;
                DefaultFlags.DefaultThreshold = TRUE;

            } else {
                QuotaInfoPtr->QuotaThreshold = TempLargeInt;
            }

            break;

        case 'l':

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing limit value\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }

            if (!sscanf( TempPtr, "%I64i", &TempLargeInt)) {
                printf("%s: Missing value\n", Argv[0] );
                exit(1);
            }

            if (SettingDefault) {
                ControlInfo.DefaultQuotaLimit = TempLargeInt;
                DefaultFlags.DefaultLimit = TRUE;

            } else {
                QuotaInfoPtr->QuotaLimit = TempLargeInt;

                if (TempLargeInt.QuadPart == -2i64) {
                    DeletingUser = TRUE;
                }
            }

            break;

        case 'q':
            QuickSid++;
            break;

        case 'f':

            if (Argv[i][2] == '\0') {
                i++;
                if (i >= Argc) {
                    printf("%s: Missing flag setting\n", Argv[0] );
                    exit(1);
                }

                TempPtr =  Argv[i];

            } else {

                TempPtr =  Argv[i];
                TempPtr += 2;
            }

            switch (*TempPtr) {
            case 'e':
                ControlInfo.FileSystemControlFlags |= FILE_VC_QUOTA_ENFORCE;
                break;

            case 't':
                ControlInfo.FileSystemControlFlags |= FILE_VC_QUOTA_TRACK;
                break;

            case 'd':
                ControlInfo.FileSystemControlFlags &= ~(FILE_VC_QUOTA_MASK |
                                                        FILE_VC_LOG_QUOTA_LIMIT |
                                                        FILE_VC_LOG_QUOTA_THRESHOLD);
                break;

            default:

                printf("%s: Invalid or missing flag setting.\n", Argv[0] );
                Usage();
                exit(1);
            }

            while (*++TempPtr != '\0') {
                switch (*TempPtr) {
                case 'l':
                    ControlInfo.FileSystemControlFlags |= FILE_VC_LOG_QUOTA_LIMIT;
                    break;
                case 't':
                    ControlInfo.FileSystemControlFlags |= FILE_VC_LOG_QUOTA_THRESHOLD;
                    break;
                default:

                    printf("%s: Invalid flag setting.\n", Argv[0] );
                    Usage();
                    exit(1);

                }

            }

            DefaultGiven = 1;
            DefaultFlags.Flags = TRUE;
            break;

        default:
            printf("%s: Invalid or missing flag setting.\n", Argv[0] );

        case '?':
            Usage();
            exit(1);
            break;

        }
    }

    if (DriveLetter == 0  && EventLog == 0 ) {
        printf("%s: Missing drive-letter\n", Argv[0] );
    }

    if (EventLog &&
        (DriveLetter || UserGiven)) {
        Usage();
        exit(1);
    }

    if (EventLog) {

        //
        //  Open the event log and read andy events.
        //

        FileHandle = OpenEventLog( ServerName, DISK_EVENT_MODULE );

        if (FileHandle == NULL) {
                printf("%s: Event log open failed. %s. Error = %d\n",
                       Argv[0],
                       ServerName == NULL ? "Local machine" : ServerName,
                       ErrorCode = GetLastError());

                PrintError( ErrorCode );
                exit(1);
        }

        while (ReadEventLog( FileHandle,
                             EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                             0,
                             QuotaInfo,
                             sizeof(QuotaInfo),
                             &BufferSize,
                             &i )) {

            if (BufferSize == 0) {
                break;
            }

            for (EventLogRecord = (PEVENTLOGRECORD) QuotaInfo;
                 (PCHAR) EventLogRecord  < (PCHAR) QuotaInfo + BufferSize;
                 EventLogRecord = (PEVENTLOGRECORD)((PCHAR) EventLogRecord +
                                            EventLogRecord->Length)) {

                if (EventLogRecord->EventID == IO_FILE_QUOTA_THRESHOLD) {
                    printf( "Quota threshold event at: %s",
                            ctime( &EventLogRecord->TimeGenerated ));
                } else if (EventLogRecord->EventID == IO_FILE_QUOTA_LIMIT) {
                    printf( "Quota limit event at: %s",
                            ctime( &EventLogRecord->TimeGenerated ));
                } else {
                    continue;
                }

                //
                //  Look for the device name. It is the second string.
                //

                TempPtr = ((PCHAR) EventLogRecord +
                          EventLogRecord->StringOffset);

                printf( "    on device %s\n", TempPtr );

                TempPtr = ((PCHAR) EventLogRecord +
                          EventLogRecord->DataOffset +
                          FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData ));

                //
                //  Need to align the buffer.
                //

                RtlCopyMemory( TempQuotaInfo,
                               TempPtr,
                               EventLogRecord->DataLength -
                               FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData ));

                DumpQuota( TempQuotaInfo, ServerName );
            }
        }

        ErrorCode = GetLastError();

        if (ErrorCode =! ERROR_HANDLE_EOF) {
            printf("%s: Event log read failed. Error = %d\n",
                   Argv[0],
                   ErrorCode);

            PrintError( ErrorCode );
        }

        CloseEventLog( FileHandle );

        exit(0);
    }

    //
    // Terminate the list.
    //

    BufferSize = (PCHAR) QuotaInfoPtr - (PCHAR) QuotaInfo +
            QuotaInfoPtr->NextEntryOffset;
    QuotaInfoPtr->NextEntryOffset = 0;

    SidListLength = (PCHAR) SidListPtr - (PCHAR) SidList +
            SidListPtr->NextEntryOffset;
    SidListPtr->NextEntryOffset = 0;

    SidListPtr = SidList;


    InitializeObjectAttributes( &ObjectAttributes,
                                  &NameString,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL );

    Status = NtOpenFile( &FileHandle,
                         FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT | FILE_OPEN_FOR_BACKUP_INTENT);

    if (!NT_SUCCESS( Status )) {
        printf( "Error opening input file %S; error was: %lx\n", NameString.Buffer, Status );
        PrintError( Status );
        exit(1);
    }


    if (DefaultGiven) {

        Status = NtQueryVolumeInformationFile( FileHandle,
                                               &IoStatus,
                                               &TempControlInfo,
                                               sizeof( FILE_FS_CONTROL_INFORMATION ),
                                               FileFsControlInformation );

        if (!NT_SUCCESS( Status )) {
            printf( "Error NtQueryVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }

        if (DefaultFlags.Flags) {
            TempControlInfo.FileSystemControlFlags &= ~FILE_VC_QUOTA_MASK;
            TempControlInfo.FileSystemControlFlags |=
                ControlInfo.FileSystemControlFlags;
        }

        if (DefaultFlags.DefaultLimit) {
            TempControlInfo.DefaultQuotaLimit = ControlInfo.DefaultQuotaLimit;
        }

        if (DefaultFlags.DefaultThreshold) {
            TempControlInfo.DefaultQuotaThreshold = ControlInfo.DefaultQuotaThreshold;
        }

        Status = NtSetVolumeInformationFile( FileHandle,
                                           &IoStatus,
                                           &TempControlInfo,
                                           sizeof( FILE_FS_CONTROL_INFORMATION ),
                                           FileFsControlInformation );

        if (!NT_SUCCESS( Status )) {
            printf( "Error NtSetVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }
    }

    Status = NtQueryVolumeInformationFile( FileHandle,
                                           &IoStatus,
                                           &TempControlInfo,
                                           sizeof( FILE_FS_CONTROL_INFORMATION ),
                                           FileFsControlInformation );

    printf( "FileSystemControlFlags = %8lx\n", TempControlInfo.FileSystemControlFlags);
    if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) ==
        FILE_VC_QUOTA_NONE) {

        TempPtr = "Quotas are disabled on this volume";
    } else if ((TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) ==
        FILE_VC_QUOTA_TRACK) {

        TempPtr = "Quota tracking is enabled on this volume";

    }else if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_ENFORCE) {

        TempPtr = "Quota tracking and enforment is enabled on this volume";

    }

    printf("%s.\n", TempPtr);

    switch (TempControlInfo.FileSystemControlFlags &
            (FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD)) {
    case FILE_VC_LOG_QUOTA_LIMIT:
        printf("Logging enable for quota limits.\n");
        break;
    case FILE_VC_LOG_QUOTA_THRESHOLD:
        printf("Logging enable for quota thresholds.\n");
        break;
    case FILE_VC_LOG_QUOTA_LIMIT | FILE_VC_LOG_QUOTA_THRESHOLD:
        printf("Logging enable for quota limits and threshold.\n");
        break;
    case 0:
        printf("Logging for quota events is not enabled.\n");
        break;
    }

    if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTA_MASK) {
        if (TempControlInfo.FileSystemControlFlags & FILE_VC_QUOTAS_INCOMPLETE) {
            TempPtr = "The quota values are incomplete.\n";
        } else
        {
            TempPtr = "The quota values are up to date.\n";
        }

        printf(TempPtr);
    }

    printf("Default Quota Threshold = %16I64x\n", TempControlInfo.DefaultQuotaThreshold.QuadPart);
    printf("Default Quota Limit     = %16I64x\n\n", TempControlInfo.DefaultQuotaLimit.QuadPart);

    if (UserGiven) {

        Status = NtSetQuotaInformationFile( FileHandle,
                                           &IoStatus,
                                           QuotaInfo,
                                           BufferSize );

        if (!NT_SUCCESS( Status )) {
            printf( "Error NtSetVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }

    }

    if (!UserGiven || DeletingUser) {
        SidListPtr = NULL;
        SidListLength = 0;
    }

    do {

        Status = NtQueryQuotaInformationFile( FileHandle,
                                              &IoStatus,
                                              QuotaInfo,
                                              sizeof(QuotaInfo),
                                              FALSE,
                                              SidListPtr,
                                              SidListLength,
                                              NULL,
                                              FALSE );

        if (!NT_SUCCESS( Status ) && Status != STATUS_NO_MORE_ENTRIES) {
            printf( "Error NtQueryVolumeInformationFile; error was %lx\n", Status );
            PrintError( Status );
            exit(1);
        }

        QuotaInfoPtr = QuotaInfo;

        while (TRUE) {

            DumpQuota( QuotaInfoPtr, ServerName );

            if (QuotaInfoPtr->NextEntryOffset == 0) {
                break;
            }

            QuotaInfoPtr = (PFILE_QUOTA_INFORMATION) ((PCHAR) QuotaInfoPtr +
                            QuotaInfoPtr->NextEntryOffset);

        }
    } while ( Status != STATUS_NO_MORE_ENTRIES );

    NtClose( FileHandle );
}

VOID
DumpQuota (
    IN PFILE_QUOTA_INFORMATION FileQuotaInfo,
    IN PCHAR ServerName
    )
{
    SID_NAME_USE SidNameUse;
    ULONG AccountLength, DomainLength;
    ULONG ErrorCode;
    char AccountName[128];
    char DomainName[128];
    UNICODE_STRING String;
    NTSTATUS Status;

    AccountLength = sizeof(AccountName) - 1;
    DomainLength = sizeof(DomainName) - 1;

    if (FileQuotaInfo->SidLength == 0) {

        printf( "Default quota values \n" );

    } else if (QuickSid) {

        String.Buffer = (PWCHAR) AccountName;
        String.MaximumLength = sizeof( AccountName );
        String.Length = 0;

        Status = RtlConvertSidToUnicodeString( &String,
                                               &FileQuotaInfo->Sid,
                                               FALSE );

        if (!NT_SUCCESS(Status)) {
            printf("DumpQuota: RtlConvertSidToUnicodeString failed. Error = %d\n",
               Status);
            PrintError( Status );
        } else {
            printf( "SID Value       = %S\n", String.Buffer );
        }

    } else if (LookupAccountSidA(
            ServerName,
            &FileQuotaInfo->Sid,
            AccountName,
            &AccountLength,
            DomainName,
            &DomainLength,
            &SidNameUse))
    {
        char *String;

        AccountName[AccountLength] = '\0';
        DomainName[DomainLength] = '\0';
        switch (SidNameUse)
        {
            case SidTypeUser:           String = "User"; break;
            case SidTypeGroup:          String = "Group"; break;
            case SidTypeDomain:         String = "Domain"; break;
            case SidTypeAlias:          String = "Alias"; break;
            case SidTypeWellKnownGroup: String = "WellKnownGroup"; break;
            case SidTypeDeletedAccount: String = "DeletedAccount"; break;
            case SidTypeInvalid:        String = "Invalid"; break;
            default:                    String = "Unknown"; break;
        }
        printf(
            "SID Name        = %s\\%s (%s)\n",
            DomainName,
            AccountName,
            String);

    } else {

        printf("DumpQuota: Bad acccount SID. Error = %d\n",
               ErrorCode = GetLastError());
        PrintError( ErrorCode );

    }

    printf("Change time     = %s\n", FileTimeToString((PFILETIME) &FileQuotaInfo->ChangeTime));
    printf("Quota Used      = %16I64x\n", FileQuotaInfo->QuotaUsed.QuadPart);
    printf("Quota Threshold = %16I64x\n", FileQuotaInfo->QuotaThreshold.QuadPart);
    printf("Quota Limit     = %16I64x\n\n", FileQuotaInfo->QuotaLimit.QuadPart);

}

char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

CHAR *
FileTimeToString(FILETIME *FileTime)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;
    static char Buffer[32];

    Buffer[0] = '\0';
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            return("Time???");
        }
        sprintf(
            Buffer,
            "%s %s %2d %2d:%02d:%02d %4d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wYear);
    }
    return(Buffer);
}

VOID
PrintError(ULONG ErrorCode)
{
    UCHAR ErrorBuffer[80];
    ULONG Count;
    HMODULE FileHandle = NULL;
    ULONG Flags = FORMAT_MESSAGE_FROM_SYSTEM;

    if (ErrorCode > MAXLONG) {
        Flags = FORMAT_MESSAGE_FROM_HMODULE;
        FileHandle = LoadLibrary( "ntdll" );
        if (FileHandle == NULL) {
            ULONG ErrorCode;

            printf("PrintError: LoadLibrary filed. Error = %d\n",
                   ErrorCode = GetLastError());

            PrintError( ErrorCode );
        }

    }

    Count = FormatMessage(Flags,
                  FileHandle,
                  ErrorCode,
                  0,
                  ErrorBuffer,
                  sizeof(ErrorBuffer),
                  NULL
                  );

    if (Count != 0) {
        printf("Error was: %s\n", ErrorBuffer);
    } else {
        printf("Format message failed.  Error: %d\n", GetLastError());
    }

    if (FileHandle != NULL) {
        FreeLibrary( FileHandle );
    }
}

VOID
Usage()
{
    printf( "Usage: %s -e [\\ServerName] | drive-letter  [-q ] [ -f e|t|d [lt] ] [-d | -u account-name -t Threshold -l Limit] \n", __argv[0] );
    printf( "    -e [\\ServerName] Print quota events from specified server default is local.\n");
    printf( "    [-q] Quick print Sids. \n");
    printf( "    [-f e|t|d[lt] ] Set volume quota flags (For example -f elt ): \n");
    printf( "        [e]nforce quota limits.\n" );
    printf( "        [t]rack quota usage.\n" );
    printf( "        [d]isable quotas.\n" );
    printf( "        [l]imit events should be logged.\n" );
    printf( "        [t]threhold events should be logged.\n" );
    printf( "    [-d] Set default user quota values.\n");
    printf( "    [-u AccountName] Set quota values for user. \n");
    printf( "    [-l Limit] Set 64-Bit limit value preivously specified user. \n");
    printf( "        A limit of -2 indicates a defunct user can be removed. \n");
    printf( "    [-t Threshold] Set 64-Bit threshold value preivously specified user. \n\n");
    printf( "    Example:\n    %s d -f elt -d -t 4194304 -l 5242880 -u administrators -l 0xffffffffffffffff -t 0xffffffffffffffff\n",  __argv[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\opentest.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    proptest.c

Abstract:

    This module contains tests for Ntfs Property support.

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#include <ddeml.h>      // for CP_WINUNICODE

#include <objidl.h>

extern "C"
{
#include <propapi.h>
}

#include <stgprop.h>

#include <stgvar.hxx>
#include <propstm.hxx>
#include <align.hxx>
#include <sstream.hxx>

#include <propvar.h>


//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		NULL,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}

void
OpenTest (
    char *FileName
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    WCHAR WFileName[MAX_PATH];
    char InputBuffer[10];
    char OutputBuffer[200];
    IO_STATUS_BLOCK Iosb;


    //
    //  OPENTEST file count
    //
    
    //
    //  Create the new file
    //
    
    SzToWsz( WFileName, FileName );

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_CREATE,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to open %s - %x\n", FileName, Status );
    }

    //
    //  Write a small amount of data
    //

    Status = NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, InputBuffer, 10, NULL, NULL );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to write %s - %x\n", FileName, Status );
    }
    
    //
    //  Close the file
    //

    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }

    //
    //  Overwrite the file
    //

    Status = OpenObject( WFileName,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA,
                         FALSE,
                         FILE_OVERWRITE,
                         &Handle );

    if (!NT_SUCCESS( Status )) {
        printf( "Unable to overwrite %s - %x\n", FileName, Status );
    }

    //
    //  Write a small amount of data
    //

    Status = NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, InputBuffer, 10, NULL, NULL );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to write %s - %x\n", FileName, Status );
    }

    //
    //  Close the file
    //

    Status = NtClose( Handle );
    if (!NT_SUCCESS( Status )) {
        printf( "Unable to close %s - %x\n", FileName, Status );
    }

    //
    //  Delete the file
    //

    {    
        OBJECT_ATTRIBUTES oa;
        UNICODE_STRING str;
    
        RtlDosPathNameToNtPathName_U( WFileName, &str, NULL, NULL );
    
        InitializeObjectAttributes(
            &oa,
            &str,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);
    
        Status = NtDeleteFile( &oa );
    
        RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);

        if (!NT_SUCCESS( Status )) {
            printf( "Unable to delete %s - %x\n", FileName, Status );
        }
        
    }
}



int __cdecl
main (
    int argc,
    char **argv)
{
    DbgPrint( "--------------------------------------------\n" );
    while (--argc != 0) {
        OpenTest( *++argv );
    }
    DbgPrint( "--------------------------------------------\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\rentest.cxx ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    rentest.c

Abstract:

    This module contains tests for stream rename support

--*/


extern "C" {
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>

#include <stdio.h>

#define DEFAULT_DATA_STREAM "::$DATA"

//
//  Simple wrapper for NtCreateFile
//

NTSTATUS
OpenObject (
    WCHAR const *pwszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;

    if (RelatedObject == NULL) {
        
        RtlDosPathNameToNtPathName_U(pwszFile, &str, NULL, NULL);

    } else {
        
        RtlInitUnicodeString(&str, pwszFile);

    }

    InitializeObjectAttributes(
		&oa,
		&str,
		OBJ_CASE_INSENSITIVE,
		RelatedObject,
		NULL);

    Status = NtCreateFile(
                ph,
                DesiredAccess | SYNCHRONIZE,
                &oa,
                &isb,
                NULL,                   // pallocationsize (none!)
                FILE_ATTRIBUTE_NORMAL,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                NULL,                   // EA buffer (none!)
                0);

    RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(Status);
}


void
SzToWsz (
    OUT WCHAR *Unicode,
    IN char *Ansi
    )
{
    while (*Unicode++ = *Ansi++)
        ;
}

typedef enum {
    NoTarget,
    EmptyTarget,
    NonZeroTarget
} TARGET_STATUS;

typedef enum {
    EmptySource,
    SmallSource,
    BigSource
} SOURCE_STATUS;

void
StickDataIn (
    HANDLE Handle,
    char *SomeData,
    SOURCE_STATUS SourceStatus
    )
{
    if (SourceStatus == EmptySource) {
    
    } else if (SourceStatus == SmallSource) {
        IO_STATUS_BLOCK Iosb;
        
        NTSTATUS Status = 
            NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, SomeData, strlen( SomeData ), NULL, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "Unable to stick data in - %x\n", Status );
        }
    
        NtFlushBuffersFile( Handle, &Iosb );
    
    } else if (SourceStatus == BigSource) {
        IO_STATUS_BLOCK Iosb;
        LARGE_INTEGER Offset;

        Offset.QuadPart = 1024 * 1024;
        
        NTSTATUS Status = 
            NtWriteFile( Handle, NULL, NULL, NULL, &Iosb, SomeData, strlen( SomeData ), &Offset, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "Unable to stick data in - %x\n", Status );
        }
        
        NtFlushBuffersFile( Handle, &Iosb );
    }
    
}

void
CheckData (
    HANDLE Handle,
    char *Data,
    SOURCE_STATUS SourceStatus,
    int Line
    )
{
    if (SourceStatus == EmptySource) {
        //
        //  Verify that the source is zero bytes long
        //
    
    } else if (SourceStatus == SmallSource) {
        IO_STATUS_BLOCK Iosb;
        char *FileData = new char[ strlen( Data )];
        
        NTSTATUS Status = 
            NtReadFile( Handle, NULL, NULL, NULL, &Iosb, FileData, strlen( Data ), NULL, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "line %d Unable to read data  - %x\n", Line, Status );
        }

        if (memcmp( Data, FileData, strlen( Data ))) {
            printf( "line %d small data is different\n", Line );
            printf( "File: '%.*s'  Test: '%s'\n", strlen( Data ), FileData, Data );
        }
    
        delete [] FileData;

    } else if (SourceStatus == BigSource) {
        IO_STATUS_BLOCK Iosb;
        char *FileData = new char[ strlen( Data )];
        LARGE_INTEGER Offset;

        Offset.QuadPart = 1024 * 1024;
        
        NTSTATUS Status = 
            NtReadFile( Handle, NULL, NULL, NULL, &Iosb, FileData, strlen( Data ), &Offset, NULL );
        
        if (!NT_SUCCESS( Status )) {
            printf( "line %d Unable to read data in - %x\n", Line, Status );
        }

        if (memcmp( Data, FileData, strlen( Data ))) {
            printf( "line %d large data is different\n", Line );
            printf( "File: '%.*s'  Test: '%s'\n", strlen( Data ), FileData, Data );
        }
    
        delete [] FileData;
    }
}

#define TESTONE                                                 \
        printf( "TestOne( %s, %s, %x, %x, %x, Line %d ): ",     \
                SourceStream, TargetStream,                     \
                TargetStatus, ReplaceIfExists, ExpectedStatus,  \
                Line )

#define CLOSE(h)    {                                   \
    NTSTATUS TmpStatus = NtClose(h);                    \
    h = INVALID_HANDLE_VALUE;                           \
    if (!NT_SUCCESS( TmpStatus )) {                     \
        TESTONE; printf( "Couldn't close handle @ %d\n", __LINE__ );   \
    }                                                   \
}

//
//  Open a handle relative to the parent of the Source stream.
//  

void
TestOne (
    char *FileName,
    char *SourceStream,
    SOURCE_STATUS SourceStatus,
    char *TargetStream,
    TARGET_STATUS TargetStatus,
    BOOLEAN ReplaceIfExists,
    NTSTATUS ExpectedStatus,
    int Line
    )
{
    NTSTATUS Status;
    WCHAR UnicodeFullSourceStreamName[MAX_PATH];
    WCHAR UnicodeFullTargetStreamName[MAX_PATH];
    WCHAR UnicodeTargetStreamName[MAX_PATH];
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    
    //
    //  Convert names to unicode and form complete source name
    //

    SzToWsz( UnicodeFullSourceStreamName, FileName );
    SzToWsz( UnicodeFullSourceStreamName + wcslen( UnicodeFullSourceStreamName ), SourceStream );
    SzToWsz( UnicodeTargetStreamName, TargetStream );
    SzToWsz( UnicodeFullTargetStreamName, FileName );
    SzToWsz( UnicodeFullTargetStreamName + wcslen( UnicodeFullTargetStreamName ), TargetStream );
    
    //
    //  Create/open source stream 
    //

    Status = OpenObject( UnicodeFullSourceStreamName,
                         NULL,
                         FILE_SYNCHRONOUS_IO_NONALERT,
                         FILE_READ_DATA | FILE_WRITE_DATA | DELETE,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_OPEN_IF,
                         &SourceHandle );

    if (!NT_SUCCESS( Status )) {
        TESTONE; printf( "unable to open source stream - %x\n", Status );
    }

    //
    //  Stick data into source
    //

    StickDataIn( SourceHandle, SourceStream, SourceStatus );

    //
    //  If target is not supposed to exist
    //

    if (TargetStatus == NoTarget) {
        
        //
        //  Create/Open target stream with delete-on-close
        //

        Status = OpenObject( UnicodeFullTargetStreamName,              
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE,
                             FILE_READ_DATA | FILE_WRITE_DATA | DELETE,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             &TargetHandle );
        
        //
        //  Close target stream (do the delete)
        //

        if (NT_SUCCESS( Status )) {
            CLOSE( TargetHandle );
        } else {
            TESTONE; printf( "Unable to set NoTarget on %s - %x\n", TargetStream, Status );
        }
    
    } else {
        
        //
        //  Create/open target stream
        //
        
        Status = OpenObject( UnicodeFullTargetStreamName,
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             &TargetHandle );
        if (!NT_SUCCESS( Status )) {
            TESTONE; printf( "unable to open target for sizing %x\n", Status );
        }

        FILE_END_OF_FILE_INFORMATION EndOfFile;
        EndOfFile.EndOfFile.QuadPart = 0i64;
        
        IO_STATUS_BLOCK Iosb;
        Status = NtSetInformationFile( TargetHandle,
                                       &Iosb,
                                       &EndOfFile,
                                       sizeof( EndOfFile ),
                                       FileEndOfFileInformation );

        
        //
        //  If target has data in it
        //
        
        if (TargetStatus == NonZeroTarget) {
            
            //
            //  Stick data into target
            //

            StickDataIn( TargetHandle, TargetStream, SmallSource );

        }

        //
        //  Close target
        //

        CLOSE( TargetHandle );

    }

    //
    //  Set up FileRenameInformation
    //
    
    char buffer[sizeof( FILE_RENAME_INFORMATION ) + MAX_PATH * sizeof( WCHAR )];
    PFILE_RENAME_INFORMATION FileRenameInformationBlock = (PFILE_RENAME_INFORMATION) buffer;

    FileRenameInformationBlock->ReplaceIfExists = ReplaceIfExists;
    FileRenameInformationBlock->RootDirectory = NULL;
    FileRenameInformationBlock->FileNameLength = strlen( TargetStream ) * sizeof( WCHAR );
    SzToWsz( FileRenameInformationBlock->FileName, TargetStream );
    
    //
    //  Attempt to rename
    //

    IO_STATUS_BLOCK Iosb;
    Status = NtSetInformationFile( SourceHandle,
                                   &Iosb,
                                   FileRenameInformationBlock,
                                   sizeof( buffer ),
                                   FileRenameInformation );

    //
    //  Check output status codes
    //

    if (Status != ExpectedStatus) {
        TESTONE; printf( "status was %x\n", Status );
    }
    
    //
    //  Close Source stream
    //

    CLOSE( SourceHandle );
    
    //
    //  If we succeeded in tehe rename
    //

    if (NT_SUCCESS( Status )) {
        //
        //  Verify that the source stream no longer exists
        //
    
        Status = OpenObject( UnicodeFullSourceStreamName,
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             &SourceHandle );
    
        //
        //  Verify that the source does/doesn't exist as appropriate
        //
    
        if (NT_SUCCESS( Status )) {
            
            if (!strcmp( SourceStream, DEFAULT_DATA_STREAM )) {
                //  Default data stream still exists.  No problem
            } else {
                TESTONE; printf( "source stream still exists\n" );
            }
            
            CLOSE( SourceHandle );
    
        } else if (!strcmp( SourceStream, DEFAULT_DATA_STREAM )) {
            TESTONE; printf( "failed to open default data stream - %x\n", Status );
        } else {
            //  failed to open previous source stream.  No problem
        }

        //
        //  Reopen the target stream (formerly source stream)
        //
        
        Status = OpenObject( UnicodeFullTargetStreamName,
                             NULL,
                             FILE_SYNCHRONOUS_IO_NONALERT,
                             FILE_READ_DATA | FILE_WRITE_DATA,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN,
                             &TargetHandle );

        if (!NT_SUCCESS( Status )) {
            TESTONE; printf( "unable to open target for verification %x\n", Status );
        }

        //
        //  Verify the contents
        //

        CheckData( TargetHandle, SourceStream, SourceStatus, Line );

        CLOSE( TargetHandle );
    }
}


void
RenameTest (
    char *FileName
    )
{
    //  Test:
    //      ::$Data to :New             Succeed
    //      ::$Data to :NonZero         Fail always
    //      ::$Data to :Empty           Succeed if ReplaceIfExists
    //      :Test to ::$Data <empty>    Succeed if ReplaceIfExists
    //      :Test to ::$Data <nonzero>  Fail always
    //
    //      XXX:Test to YYY:Test        Fail always
    //

    //      ::$Data to :New             Succeed
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    
    //      ::$Data to :NonZero         Fail always
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":NonZero",           NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":NonZero",           NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":NonZero",           NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":NonZero",           NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":NonZero",           NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":NonZero",           NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    
    //      ::$Data to :Empty           Succeed if ReplaceIfExists
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":Empty",             EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, EmptySource, ":Empty",             EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":Empty",             EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, SmallSource, ":Empty",             EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":Empty",             EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, DEFAULT_DATA_STREAM, BigSource,   ":Empty",             EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );

    //      :Test to ::$Data <empty>    Succeed if ReplaceIfExists
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    
    //      :Test to ::$Data <nonzero>  Fail always
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, DEFAULT_DATA_STREAM,  NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, DEFAULT_DATA_STREAM,  NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   DEFAULT_DATA_STREAM,  NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );

    //      :Test to :New               Succeed
    TestOne( FileName, ":Test",             EmptySource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NoTarget,      FALSE, STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NoTarget,      TRUE,  STATUS_SUCCESS, __LINE__ );

    //      :Test to :NonZero           Fail always
    TestOne( FileName, ":Test",             EmptySource, ":New",               NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, ":New",               NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NonZeroTarget, FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               NonZeroTarget, TRUE,  STATUS_INVALID_PARAMETER,     __LINE__ );
    
    //      :Test to :Empty             Succeed if ReplaceIfExists
    TestOne( FileName, ":Test",             EmptySource, ":New",               EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             EmptySource, ":New",               EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             SmallSource, ":New",               EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               EmptyTarget,   FALSE, STATUS_OBJECT_NAME_COLLISION, __LINE__ );
    TestOne( FileName, ":Test",             BigSource,   ":New",               EmptyTarget,   TRUE,  STATUS_SUCCESS, __LINE__ );
    
}



int __cdecl
main (
    int argc,
    char **argv)
{
    DbgPrint( "--------------------------------------------\n" );
    while (--argc != 0) {
        RenameTest( *++argv );
    }
    DbgPrint( "--------------------------------------------\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\brian.h ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>

extern BOOLEAN SynchronousCmds;
extern ULONG (*DbgPrintLocation)(PCH Format,...);



ULONG
GetLastError(
    VOID
    );

HANDLE
CreateThread(
    IN PVOID lpThreadAttributes,
    IN ULONG dwStackSize,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG dwCreationFlags,
    OUT PVOID lpThreadId
    );

#define FlagOn( Flags,SingleFlag ) (             \
    (BOOLEAN)(((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )

//
//  Shell constants
//

#define SHELL_UNKNOWN                   0
#define SHELL_EXIT                      1
#define SHELL_OPEN                      2
#define SHELL_CLEAR_BUFFER              3
#define SHELL_DISPLAY_BYTES             4
#define SHELL_COPY_BUFFER               5
#define SHELL_ALLOC_MEM                 6
#define SHELL_DEALLOC_MEM               7
#define SHELL_PUT_EA                    8
#define SHELL_FILL_EA                   9
#define SHELL_DISPLAY_HANDLE            10
#define SHELL_CLOSE_HANDLE              11
#define SHELL_READ_FILE                 12
#define SHELL_PAUSE                     13
#define SHELL_QUERY_EAS                 14
#define SHELL_SET_EAS                   15
#define SHELL_BREAK                     16
#define SHELL_OPLOCK                    17
#define SHELL_WRITE                     18
#define SHELL_QDIR                      19
#define SHELL_DISPLAY_QDIR              20
#define SHELL_QFILE                     21
#define SHELL_DISPLAY_QFILE             22
#define SHELL_NOTIFY_CHANGE             23
#define SHELL_ENTER_TIME                24
#define SHELL_DISPLAY_TIME              25
#define SHELL_SETFILE                   26
#define SHELL_QUERY_VOLUME              27
#define SHELL_DISPLAY_QVOL              28
#define SHELL_SET_VOLUME                29
#define SHELL_FSCTRL                    30
#define SHELL_IOCTL                     31
#define SHELL_CANCEL_IO                 32
#define SHELL_SPARSE                    33
#define SHELL_USN                       34
#define SHELL_FILL_BUFFER               35
#define SHELL_FILL_BUFFER_USN           36
#define SHELL_DISPLAY_WORDS             37
#define SHELL_DISPLAY_DWORDS            38
#define SHELL_REPARSE                   39

#define try_return(S) { S; goto try_exit; }
#define bprint (*DbgPrintLocation)(

//
//  Support routines contained in prmptsup.c
//

PCHAR
SwallowNonWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    );

PCHAR
SwallowWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    );

ULONG
AnalyzeBuffer (
    PCHAR *BuffPtr,
    PULONG ParamStringLen
    );

BOOLEAN
ExtractCmd (
    PCHAR *BufferPtr,
    PULONG BufferLen
    );

VOID
CommandSummary ();

//
//  Routines contained in topen.c
//

VOID
InputOpenFile(
    IN PCHAR ParamBuffer
    );

#define ROUND_UP( x, y )  ((ULONG)(x) + ((y)-1) & ~((y)-1))

//
//  Routines contained in tbuffer.c
//

#define MAX_BUFFERS                 200

typedef struct _BUFFER_ELEMENT {

    PCHAR   Buffer;
    ULONG   Length;
    BOOLEAN Used;

} BUFFER_ELEMENT, *PBUFFER_ELEMENT;

extern BUFFER_ELEMENT Buffers[MAX_BUFFERS];
extern HANDLE BufferEvent;

VOID
InitBuffers (
    );

VOID
UninitBuffers (
    );

NTSTATUS
AllocateBuffer (
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex
    );

NTSTATUS
DeallocateBuffer (
    IN ULONG Index
    );

BOOLEAN
BufferInfo (
    IN ULONG Index,
    OUT PVOID *BufferAddress,
    OUT PULONG RegionSize
    );

VOID
InputClearBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayBuffer(
    IN PCHAR ParamBuffer,
    IN ULONG DisplaySize
    );

VOID
InputCopyBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputAllocMem(
    IN PCHAR ParamBuffer
    );

VOID
InputDeallocMem(
    IN PCHAR ParamBuffer
    );

VOID
InputFillBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputFillBufferUsn(
    IN PCHAR ParamBuffer
    );

//
//  Ea routines contained in tea.c
//

VOID
InputPutEaName(
    IN PCHAR ParamBuffer
    );

VOID
InputFillEaBuffer(
    IN PCHAR ParamBuffer
    );

VOID
InputQueryEa(
    IN PCHAR ParamBuffer
    );

VOID
InputSetEa(
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in thandle.c
//

#define MAX_HANDLES                 200

typedef struct _HANDLE_ELEMENT {

    HANDLE Handle;
    BOOLEAN Used;

} HANDLE_ELEMENT, *PHANDLE_ELEMENT;

HANDLE_ELEMENT Handles[MAX_HANDLES];
HANDLE HandleEvent;

VOID
InitHandles (
    );

VOID
UninitHandles (
    );

NTSTATUS
ObtainIndex (
    OUT PUSHORT NewIndex
    );

NTSTATUS
FreeIndex (
    IN USHORT Index
    );

VOID
InputDisplayHandle (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tclose.c
//

VOID
InputCloseIndex (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tevent.c
//

#define MAX_EVENTS                  200

typedef struct _EVENT_ELEMENT {

    HANDLE Handle;
    BOOLEAN Used;

} EVENT_ELEMENT, *PEVENT_ELEMENT;

EVENT_ELEMENT Events[MAX_EVENTS];
HANDLE EventEvent;

VOID
InitEvents (
    );

VOID
UninitEvents (
    );

NTSTATUS
ObtainEvent (
    OUT PUSHORT NewIndex
    );

VOID
FreeEvent (
    IN USHORT Index
    );

//
//  Routines contained in tread.c
//

VOID
InputRead(
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tpause.c
//

VOID
InputPause (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tbreak.c
//

VOID
InputBreak (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in toplock.c
//

VOID
InputOplock (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tdevctl.c
//

VOID
InputDevctrl (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tfsctrl.c
//

VOID
InputFsctrl (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tsparse.c
//

VOID
InputSparse (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tusn.c
//

VOID
InputUsn (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in treparse.c
//

VOID
InputReparse (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in twrite.c
//

VOID
InputWrite (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tqdir.c
//

VOID
InputQDir (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayQDir (
    IN PCHAR ParamBuffer
    );

VOID
DisplayQDirNames (
    IN USHORT BufferIndex
    );

VOID
DisplayQDirDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQDirFullDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQDirIdFullDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQBothDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQIdBothDirs (
    IN USHORT BufferIndex
    );

VOID
DisplayQOleDirs (
    IN USHORT BufferIndex
    );

//
//  Routines contained in ttime.c
//

VOID
InputEnterTime (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayTime (
    IN PCHAR ParamBuffer
    );

VOID
PrintTime (
    IN PTIME Time
    );

VOID
BPrintTime (
    IN PTIME Time
    );

//
//  Routines contained in tmisc.c
//

VOID
PrintLargeInteger (
    IN PLARGE_INTEGER LargeInt
    );

ULONG
AsciiToInteger (
    IN PCHAR Ascii
    );

ULONGLONG
AsciiToLargeInteger (
    IN PCHAR Ascii
    );

//
//  Routines contained in tqfile.c
//

VOID
InputQFile (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayQFile (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tnotify.c
//

VOID
InputNotifyChange (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tsetfile.c
//

VOID
InputSetFile (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tqvolume.c
//

VOID
InputQVolume (
    IN PCHAR ParamBuffer
    );

VOID
InputDisplayQVolume (
    IN PCHAR ParamBuffer
    );

//
//  Routines contained in tsetvol.c
//

VOID
InputSetVolume (
    IN PCHAR ParamBuffer
    );

//
//  Routines defined in tcancel.c
//

VOID
InputCancelIndex (
    IN PCHAR ParamBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\bshell.c ===
#include "brian.h"

//
//  Global variables
//
BUFFER_ELEMENT Buffers[MAX_BUFFERS];
HANDLE BufferEvent = NULL;

//
//  Control if debug prints go to the debug screen or the console.  By
//  default they go to the debug screen.  In Synchronous mode they go
//  to the console.
//

ULONG (*DbgPrintLocation)(PCH Format,...) = DbgPrint;

//
//  Flag if we are in Synchronous mode or not.  In Synchronous mode all
//  commands (except OPLOCKS) are executed Synchronously with the shell.
//  The default mode is NOT Synchronous mode.
//

BOOLEAN SynchronousCmds = FALSE;

//
//  If set do to give the BSHELL prompt
//

BOOLEAN BatchMode = FALSE;


//
//  Prototypes
//

int
ParseCmdLine (
    int argc,
    char *argv[]
    );

void
DisplayUsage();


//
//  Main Routine
//

#if i386
__cdecl
#endif
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOLEAN ExitWhile = FALSE;
    UCHAR Buffer[256];
    PCHAR ParamString;
    ULONG ParamStringLen;

    InitBuffers();
    InitHandles();
    InitEvents();

    if (!ParseCmdLine( argc, argv ))
        return STATUS_SUCCESS;

    while (!ExitWhile) {

        ParamString = Buffer;

        if (!BatchMode) { 

            printf( "\nBSHELL> " );
            if (gets( ParamString ) == NULL)        //exit on error
                return;

            printf( " " );

        } else {

            if (gets( ParamString ) == NULL)        //exit on error
                return;

            printf("BSHELL> %s\n",ParamString);
        }

        fflush( stdout );

        ParamStringLen = strlen( ParamString );

        switch (AnalyzeBuffer( &ParamString, &ParamStringLen )) {

        case SHELL_EXIT:

            ExitWhile = TRUE;
            break;

        case SHELL_OPEN:

            InputOpenFile( ParamString + ParamStringLen );
            break;

        case SHELL_CLEAR_BUFFER:

            InputClearBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_BYTES:

            InputDisplayBuffer( ParamString + ParamStringLen, sizeof( CHAR ));
            break;

        case SHELL_DISPLAY_WORDS:

            InputDisplayBuffer( ParamString + ParamStringLen, sizeof( WCHAR ));
            break;

        case SHELL_DISPLAY_DWORDS:

            InputDisplayBuffer( ParamString + ParamStringLen, sizeof( ULONG ));
            break;

        case SHELL_COPY_BUFFER:

            InputCopyBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_ALLOC_MEM:

            InputAllocMem( ParamString + ParamStringLen );
            break;

        case SHELL_DEALLOC_MEM:

            InputDeallocMem( ParamString + ParamStringLen );
            break;

        case SHELL_FILL_BUFFER:

            InputFillBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_FILL_BUFFER_USN:

            InputFillBufferUsn( ParamString + ParamStringLen );
            break;

        case SHELL_PUT_EA:

            InputPutEaName( ParamString + ParamStringLen );
            break;

        case SHELL_FILL_EA:

            InputFillEaBuffer( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_HANDLE:

            InputDisplayHandle( ParamString + ParamStringLen );
            break;

        case SHELL_CLOSE_HANDLE:

            InputCloseIndex( ParamString + ParamStringLen );
            break;

        case SHELL_CANCEL_IO:

            InputCancelIndex( ParamString + ParamStringLen );
            break;

        case SHELL_READ_FILE:

            InputRead( ParamString + ParamStringLen );
            break;

        case SHELL_PAUSE:

            InputPause( ParamString + ParamStringLen );
            break;

        case SHELL_QUERY_EAS:

            InputQueryEa( ParamString + ParamStringLen );
            break;

        case SHELL_SET_EAS:

            InputSetEa( ParamString + ParamStringLen );
            break;

        case SHELL_BREAK:

            InputBreak( ParamString + ParamStringLen );
            break;

        case SHELL_OPLOCK:

            InputOplock( ParamString + ParamStringLen );
            break;

        case SHELL_WRITE:

            InputWrite( ParamString + ParamStringLen );
            break;

        case SHELL_QDIR:

            InputQDir( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_QDIR:

            InputDisplayQDir( ParamString + ParamStringLen );
            break;

        case SHELL_QFILE:

            InputQFile( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_QFILE:

            InputDisplayQFile( ParamString + ParamStringLen );
            break;

        case SHELL_NOTIFY_CHANGE:

            InputNotifyChange( ParamString + ParamStringLen );
            break;

        case SHELL_ENTER_TIME:

            InputEnterTime( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_TIME:

            InputDisplayTime( ParamString + ParamStringLen );
            break;

        case SHELL_SETFILE:

            InputSetFile( ParamString + ParamStringLen );
            break;

        case SHELL_QUERY_VOLUME:

            InputQVolume( ParamString + ParamStringLen );
            break;

        case SHELL_DISPLAY_QVOL:

            InputDisplayQVolume( ParamString + ParamStringLen );
            break;

        case SHELL_SET_VOLUME:

            InputSetVolume( ParamString + ParamStringLen );
            break;

        case SHELL_FSCTRL:

            InputFsctrl( ParamString + ParamStringLen );
            break;

        case SHELL_SPARSE:

            InputSparse( ParamString + ParamStringLen );
            break;

        case SHELL_USN:

            InputUsn( ParamString + ParamStringLen );
            break;

        case SHELL_REPARSE:

            InputReparse( ParamString + ParamStringLen );
            break;

        case SHELL_IOCTL:

            InputDevctrl( ParamString + ParamStringLen );
            break;

        default :

            //
            //  Print out the possible command.
            //

            CommandSummary();
        }
    }

    UninitEvents();
    UninitBuffers();
    UninitHandles();

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( envp );
}



int
ParseCmdLine (
    int argc,
    char *argv[]
    )
{
    int i,j;
    char *cp;

    for (i=1; i < argc; i++) {
        cp = argv[i];

        //
        //  See if a switch was specified
        //

        if (cp[0] == '-' || cp[0] == '/') {

            for (j=1; cp[j] != 0; j++) {

                switch (cp[j]) {
                    //
                    //  Handle the "synchronous" switch
                    //

                    case 's':
                    case 'S':
                        SynchronousCmds = TRUE;
                        DbgPrintLocation = printf;
                        break;

                    //
                    //  Handle the "prompt" switch
                    //

                    case 'b':
                    case 'B':
                        BatchMode = TRUE;
                        SynchronousCmds = TRUE;
                        DbgPrintLocation = printf;
                        break;

                    //
                    //  Display usage for unknown switch
                    //

                    case 'h':
                    case 'H':
                    case '?':
                    default:
                        DisplayUsage();
                        return FALSE;
                }
            }

        } else {

            //
            //  Display usage for unknown parameters
            //

            DisplayUsage();
            return FALSE;
        }
    }
    return TRUE;
}



void
DisplayUsage()
{
    printf("\nUsage:  bshell [/bs]\n"
           "    /b      - Execute in batch mode (which also sets synchronous mode)\n"
           "    /s      - Execute commands synchronously\n"
          );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tbreak.c ===
#include "brian.h"


VOID
InputBreak (
    IN PCHAR ParamBuffer
    )
{
    DbgBreakPoint();

    return;

    UNREFERENCED_PARAMETER( ParamBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\prmptsup.c ===
#include "brian.h"

PCHAR
SwallowNonWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    )
{
    ULONG LocalCount = 0;

    while (*Ptr) {

        if (*Ptr == ' ' || *Ptr == '\t' ) {

            break;
        }

        LocalCount += 1;
        Ptr++;
    }

    *Count = LocalCount;
    return Ptr;
}

PCHAR
SwallowWhite (
    IN PCHAR Ptr,
    OUT PULONG Count
    )
{
    ULONG LocalCount = 0;

    while (*Ptr != '\0') {

        if (*Ptr != ' ' && *Ptr != '\t') {

            break;
        }

        LocalCount += 1;
        Ptr++;
    }

    *Count = LocalCount;
    return Ptr;
}

ULONG
AnalyzeBuffer (
    PCHAR *BuffPtr,
    PULONG ParamStringLen
    )
{
    ULONG BytesSwallowed;
    ULONG Count;
    PCHAR CurrentChar;

    if (!ExtractCmd( BuffPtr, &BytesSwallowed )) {

        return SHELL_UNKNOWN;
    }

    //
    //  Lower case the command string.
    //

    for (Count = 0, CurrentChar = *BuffPtr; Count < BytesSwallowed; Count++, CurrentChar++) {

        if ((*CurrentChar <= 'Z') && (*CurrentChar >= 'A')) {

            *CurrentChar += ('a' - 'A');
        }
    }

    *ParamStringLen = BytesSwallowed;

    if ((BytesSwallowed == 2) &&
        RtlEqualMemory( *BuffPtr, "op", 2 )) {

        return SHELL_OPEN;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "die", 3 )) {

        return SHELL_EXIT;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "clb", 3 )) {

        return SHELL_CLEAR_BUFFER;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "db", 2 )) {

        return SHELL_DISPLAY_BYTES;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dw", 2 )) {

        return SHELL_DISPLAY_WORDS;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dd", 2 )) {

        return SHELL_DISPLAY_DWORDS;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "cb", 2 )) {

        return SHELL_COPY_BUFFER;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "am", 2 )) {

        return SHELL_ALLOC_MEM;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dm", 2 )) {

        return SHELL_DEALLOC_MEM;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "fb", 2 )) {

        return SHELL_FILL_BUFFER;

    } else if ((BytesSwallowed == 5) &&
               RtlEqualMemory( *BuffPtr, "fbusn", 5 )) {

        return SHELL_FILL_BUFFER_USN;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "pea", 3 )) {

        return SHELL_PUT_EA;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "fea", 3 )) {

        return SHELL_FILL_EA;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "di", 2 )) {

        return SHELL_DISPLAY_HANDLE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "cl", 2 )) {

        return SHELL_CLOSE_HANDLE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "rd", 2 )) {

        return SHELL_READ_FILE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "pa", 2 )) {

        return SHELL_PAUSE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "qea", 3 )) {

        return SHELL_QUERY_EAS;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "sea", 3 )) {

        return SHELL_SET_EAS;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "br", 2 )) {

        return SHELL_BREAK;

    } else if ((BytesSwallowed == 4) &&
               RtlEqualMemory( *BuffPtr, "oplk", 4 )) {

        return SHELL_OPLOCK;

    } else if ((BytesSwallowed == 4) &&
               RtlEqualMemory( *BuffPtr, "fsct", 4 )) {

        return SHELL_FSCTRL;

    } else if ((BytesSwallowed == 6) &&
               RtlEqualMemory( *BuffPtr, "sparse", 6 )) {

        return SHELL_SPARSE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "usn", 3 )) {

        return SHELL_USN;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "rp", 2 )) {

        return SHELL_REPARSE;

    } else if ((BytesSwallowed == 5) &&
               RtlEqualMemory( *BuffPtr, "ioctl", 4 )) {

        return SHELL_IOCTL;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "wr", 2 )) {

        return SHELL_WRITE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "qd", 2 )) {

        return SHELL_QDIR;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "dqd", 3 )) {

        return SHELL_DISPLAY_QDIR;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "qf", 2 )) {

        return SHELL_QFILE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "dqf", 3 )) {

        return SHELL_DISPLAY_QFILE;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "ncd", 3 )) {

        return SHELL_NOTIFY_CHANGE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "et", 2 )) {

        return SHELL_ENTER_TIME;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "dt", 2 )) {

        return SHELL_DISPLAY_TIME;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "sf", 2 )) {

        return SHELL_SETFILE;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "qv", 2 )) {

        return SHELL_QUERY_VOLUME;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "dqv", 3 )) {

        return SHELL_DISPLAY_QVOL;

    } else if ((BytesSwallowed == 2) &&
               RtlEqualMemory( *BuffPtr, "sv", 2 )) {

        return SHELL_SET_VOLUME;

    } else if ((BytesSwallowed == 3) &&
               RtlEqualMemory( *BuffPtr, "can", 2 )) {

        return SHELL_CANCEL_IO;
    }

    return SHELL_UNKNOWN;
}

BOOLEAN
ExtractCmd (
    PCHAR *BufferPtr,
    PULONG BufferLen
    )
{
    BOOLEAN Status;
    PCHAR CurrentLoc;
    PCHAR StartLoc;
    ULONG BytesSwallowed;

    //
    //  Remember the total length and the starting position.
    //  Bytes swallowed is zero.
    //

    CurrentLoc = *BufferPtr;
    BytesSwallowed = 0;
    Status = TRUE;

    //
    //  Swallow leading white spaces.
    //

    CurrentLoc = SwallowWhite (CurrentLoc, &BytesSwallowed);

    //
    //  If first character is NULL, then there was no command.
    //

    if (!*CurrentLoc) {

        Status = FALSE;

    //
    //  Else find the next white space.
    //

    } else {

        StartLoc = CurrentLoc;

        CurrentLoc = SwallowNonWhite (CurrentLoc, &BytesSwallowed);
    }

    //
    //  Update the passed in values.
    //  Return the status of this operation.
    //

    *BufferPtr = StartLoc;
    *BufferLen = BytesSwallowed;

    return Status;
}

VOID
CommandSummary ()
{
    printf( "\nBSHELL Command Summary" );
    printf( "\n\tdie      Exit BSHELL" );
    printf( "\n\tpa       Pause input" );
    printf( "\n\tbr       Break into debugger" );
    printf( "\n" );
    printf( "\n\top       Open a file, directory or volume" );
    printf( "\n\tcan      Cancel IO on a handle" );
    printf( "\n\tcl       Close a file handle" );
    printf( "\n" );
    printf( "\n\tqd       Query directory operation" );
    printf( "\n\tdqd      Disply query directory buffer" );
    printf( "\n\tncd      Notify change directory" );
    printf( "\n" );
    printf( "\n\trd       Read from a file" );
    printf( "\n\twr       Write to a file" );
    printf( "\n" );
    printf( "\n\tqf       Query file information" );
    printf( "\n\tdqf      Display query file buffer" );
    printf( "\n\tsf       Set file information" );
    printf( "\n" );
    printf( "\n\tqv       Query volume information" );
    printf( "\n\tdqv      Display volume informatin" );
    printf( "\n\tsv       Set volume information" );
    printf( "\n" );
    printf( "\n\tfsct     Fsctrl operation" );
    printf( "\n\tsparse   Sparse file operation" );
    printf( "\n\tusn      Usn operation" );
    printf( "\n\trp       Reparse operation" );
    printf( "\n\toplk     Oplock operation" );
    printf( "\n\tioctl    Ioctl operation" );
    printf( "\n" );
    printf( "\n\tclb      Clear a buffer" );
    printf( "\n\tdb       Display a buffer in bytes" );
    printf( "\n\tdw       Display a buffer in words" );
    printf( "\n\tdd       Display a buffer in dwords" );
    printf( "\n\tcb       Copy a buffer" );
    printf( "\n\tfb       Fill a buffer" );
    printf( "\n\tfbusn    Fill a usn fsctl buffer" );
    printf( "\n" );
    printf( "\n\tam       Allocate memory" );
    printf( "\n\tdm       Deallocate memory" );
    printf( "\n" );
    printf( "\n\tdi       Display information on an index" );
    printf( "\n" );
    printf( "\n\tqea      Query the ea's for a file" );
    printf( "\n\tsea      Set the ea's for a file" );
    printf( "\n\tpea      Store an ea name in a buffer for query ea" );
    printf( "\n\tfea      Store an ea name in a buffer to set an ea" );
    printf( "\n" );
    printf( "\n\tet       Enter a time value into a buffer" );
    printf( "\n\tdt       Display a buffer as a time value" );
    printf( "\n\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\analyze\analyze.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       analyze.cxx
//
//  Contents:   program to analyze the lock order table
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    3-16-2000   benl   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#define _NTFS_NTFSDBG_DEFINITIONS_
#include "lockorder.h"

typedef struct {
    LIST_ENTRY Links;
    NTFS_RESOURCE_NAME Resource;
} RESOURCE_LIST, *PRESOURCE_LIST;

typedef struct {
    NTFS_RESOURCE_NAME Resource;
    LIST_ENTRY Links;
    NTFS_OWNERSHIP_STATE EndState;
} RESOURCE_STATE_LIST, *PRESOURCE_STATE_LIST;

//
//  structure used to track the order a state is reached by
//  

typedef struct {
    NTFS_OWNERSHIP_STATE State;
    BOOLEAN ReachedByRelease;
    LIST_ENTRY Links;          //  RESOURCE_LIST
} RESOURCE_STATE_ORDER, *PRESOURCE_STATE_ORDER;


//+---------------------------------------------------------------------------
//
//  Function:   CompareRoutine
//
//  Synopsis:   
//
//  Arguments:  [Table]  -- 
//              [First]  -- 
//              [Second] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

RTL_GENERIC_COMPARE_RESULTS CompareRoutine( struct _RTL_GENERIC_TABLE *Table, PVOID First, PVOID Second )
{
    PULONG FirstUlong = (PULONG)First;
    PULONG SecondUlong = (PULONG)Second;

    if (*FirstUlong == *SecondUlong) {
        return GenericEqual;
    } else if (*FirstUlong < *SecondUlong) {
        return GenericLessThan;
    } else {
        return GenericGreaterThan;
    }
} // CompareRoutine


//+---------------------------------------------------------------------------
//
//  Function:   AllocateRoutine
//
//  Synopsis:   
//
//  Arguments:  [Table]    -- 
//              [ByteSize] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

PVOID AllocateRoutine( struct _RTL_GENERIC_TABLE *Table, CLONG ByteSize )
{
    return malloc( ByteSize );
} // AllocateRoutine


//+---------------------------------------------------------------------------
//
//  Function:   FreeRoutine
//
//  Synopsis:   
//
//  Arguments:  [Table]  -- 
//              [Buffer] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

VOID FreeRoutine( struct _RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    free( Buffer );
} // FreeRoutine


//+---------------------------------------------------------------------------
//
//  Function:   FindOrInsertStateOrder
//
//  Synopsis:   
//
//  Arguments:  [Table]   -- 
//              [Element] -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void FindOrInsertStateOrder( PRTL_GENERIC_TABLE StateTable, NTFS_OWNERSHIP_STATE State )
{
    RESOURCE_STATE_ORDER TemplateState;
    PRESOURCE_STATE_ORDER NewState;

    TemplateState.State = State;
    if (!(RtlLookupElementGenericTable( StateTable, &TemplateState ))) {
        NewState = (PRESOURCE_STATE_ORDER)RtlInsertElementGenericTable( StateTable, &TemplateState, sizeof( TemplateState ), NULL );
        InitializeListHead( &NewState->Links );
        NewState->ReachedByRelease = FALSE;
    }
} // FindOrInsertStateOrder


//+---------------------------------------------------------------------------
//
//  Function:   FindOrInsertStateList
//
//  Synopsis:   
//
//  Arguments:  [StateTable] -- 
//              [Resource]   -- 
//
//  Returns:    
//
//  History:    5-08-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void FindOrInsertStateList( PRTL_GENERIC_TABLE StateTable, NTFS_RESOURCE_NAME Resource )
{
    RESOURCE_STATE_LIST TemplateState;
    PRESOURCE_STATE_LIST NewState;

    TemplateState.Resource = Resource;
    if (!(RtlLookupElementGenericTable( StateTable, &TemplateState ))) {
        NewState = (PRESOURCE_STATE_LIST)RtlInsertElementGenericTable( StateTable, &TemplateState, sizeof( TemplateState ), NULL );
        InitializeListHead( &NewState->Links );
    }
} // FindOrInsertStateList


//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   
//
//  Arguments:  [argc] -- 
//              [argv] -- 
//
//  Returns:    
//
//  History:    3-16-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void __cdecl main (int argc, char *argv[])
{
    int NumTransitions;
    int Index;
    int Index2;
    
    PRESOURCE_LIST Entry;
    PRESOURCE_LIST Entry2;
    PRESOURCE_STATE_LIST EntryState;
    PRESOURCE_STATE_LIST EntryState2;
    BOOLEAN Skipped;
    BOOLEAN FoundState;
    BOOLEAN Verbose = FALSE;

    PRESOURCE_STATE_ORDER State;
    PRESOURCE_STATE_ORDER EndState;
    PRESOURCE_STATE_ORDER EndState2;
    
    RTL_GENERIC_TABLE StateTable;
    RTL_GENERIC_TABLE ResourceTable;
    RESOURCE_STATE_ORDER StateOrder;
    
    RESOURCE_STATE_LIST StateListOrderTemplate;
    PRESOURCE_STATE_LIST StateListOrder;

    PVOID Key;
    int StateCheck;
    

    if (argc > 1) {
        if (argv[1][0] == '-') {
            switch (argv[1][1]) {
            case 'v':
                Verbose = TRUE;
                break;
            default:
                printf( "Usage: analyze [-v]\nThis program analyzes ntfs's lock order state table\n");
                break;
            }
        }
    }

    //
    //  Discover transition states
    //  

    RtlInitializeGenericTable( &StateTable, CompareRoutine, AllocateRoutine, FreeRoutine, NULL );
    RtlInitializeGenericTable( &ResourceTable, CompareRoutine, AllocateRoutine, FreeRoutine, NULL );

    StateOrder.ReachedByRelease = FALSE;

    NumTransitions = sizeof( OwnershipTransitionTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTable[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTable[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTable[Index].End );
    }

    NumTransitions = sizeof( OwnershipTransitionTableRelease ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTableRelease[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableRelease[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableRelease[Index].End );
    }

    NumTransitions = sizeof( OwnershipTransitionTableAcquire ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTableAcquire[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableAcquire[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableAcquire[Index].End );
    }

    NumTransitions = sizeof( OwnershipTransitionTableUnsafe ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
    for (Index=0; Index < NumTransitions; Index++) {

        FindOrInsertStateList( &ResourceTable, OwnershipTransitionTableUnsafe[Index].Acquired );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableUnsafe[Index].Begin );
        FindOrInsertStateOrder( &StateTable, OwnershipTransitionTableUnsafe[Index].End );
    }

    printf( "%d states and %d resources referenced in transition tables\n\n", 
            StateTable.NumberGenericTableElements,
            ResourceTable.NumberGenericTableElements );

/*
    for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, TRUE );
         State != 0;
         State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, FALSE )) {
            
        printf("0x%x\n", State->State );

    }
*/

    //
    //  Visit each transition state until we know the full paths
    // 

    do {

        Skipped = FALSE;
        FoundState = FALSE;
        Key = NULL;
        
        for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key );
             State != 0;
             State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key )) {

//            printf( "State: 0x%x\n", State->State );

            //
            //  We don't know this state yet
            //  

            if ((State->State != None) && IsListEmpty( &State->Links)) {
                if (Verbose) {
                    printf( "skipping state 0x%x\n", State->State );
                }
                Skipped = TRUE;
                continue;
            }

            //
            //  Look in the release only paths 1st    
            //

            NumTransitions = sizeof( OwnershipTransitionTableRelease ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
            for (Index=0; Index < NumTransitions; Index++) {

                if (OwnershipTransitionTableRelease[Index].Begin == State->State &&
                    OwnershipTransitionTableRelease[Index].End != None) {

                    StateOrder.State = OwnershipTransitionTableRelease[Index].End;
                    EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                    //
                    //  Is this a new state?
                    //  
                    
                    if (EndState && IsListEmpty( &EndState->Links )) {

                        FoundState = TRUE;
                        EndState->ReachedByRelease = TRUE;

                        if (Verbose) {
                            printf( "removing resource: 0x%x to state: 0x%x from 0x%x during release\n", 
                                    OwnershipTransitionTableRelease[Index].Acquired, 
                                    OwnershipTransitionTableRelease[Index].End, 
                                    State->State );
                        }

                        //
                        //  Add the old state's resource except for the resource being released
                        //  

                        if (State->State != None) {
                            Entry = (PRESOURCE_LIST)&State->Links;
                            do {
                                Entry = (PRESOURCE_LIST)Entry->Links.Flink;

                                if (Entry->Resource != OwnershipTransitionTableRelease[Index].Acquired) {
                                    
                                    Entry2 = new RESOURCE_LIST;
                                    Entry2->Resource = Entry->Resource;
                                    
                                    InsertTailList( &EndState->Links, &Entry2->Links );
                                }
                            } while ( Entry->Links.Flink != &State->Links );
                        }
                    }  //  endif the new state is unknown
                }  //  endif rule beginning matches the state
            }  // endfor over rules
        
            //  
            //  Then look in the acquire paths
            // 
         
            NumTransitions = sizeof( OwnershipTransitionTable ) / sizeof( NTFS_OWNERSHIP_TRANSITION );
            for (Index=0; Index < NumTransitions; Index++) {

                if (OwnershipTransitionTable[Index].Begin == State->State) {

                    StateOrder.State = OwnershipTransitionTable[Index].End;
                    EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                    EndState->ReachedByRelease = FALSE;

                    //
                    //  If we already know this state - then doublecheck this is an identical path
                    //  

                    if (EndState && !IsListEmpty( &EndState->Links )) {

                        Entry = (PRESOURCE_LIST)EndState->Links.Flink;
                        if (Entry->Resource != NtfsResourceExVcb) {
                            Entry = (PRESOURCE_LIST)EndState->Links.Blink;
                            if (OwnershipTransitionTable[Index].Acquired != Entry->Resource ) {
                                printf( "2 paths to state: 0x%x 0x%x 0x%x\n", OwnershipTransitionTable[Index].End, Entry->Resource, OwnershipTransitionTable[Index].Acquired );
                            } 
                        }

                    } else {

                        FoundState = TRUE;

                        if (Verbose) {
                            printf( "adding resource: 0x%x to state: 0x%x from 0x%x\n", 
                                    OwnershipTransitionTable[Index].Acquired, 
                                    OwnershipTransitionTable[Index].End, 
                                    State->State );
                        }
                        
                        //
                        //  Add the old state's resource
                        //  

                        if (State->State != None) {
                            Entry = (PRESOURCE_LIST)&State->Links;
                            do {
                                Entry = (PRESOURCE_LIST)Entry->Links.Flink;

                                Entry2 = new RESOURCE_LIST;
                                Entry2->Resource = Entry->Resource;

                                InsertTailList( &EndState->Links, &Entry2->Links );

                            } while ( Entry->Links.Flink != &State->Links );
                        }

                        //
                        //  Finally add the transition resource into this state
                        //  

                        Entry = new RESOURCE_LIST;
                        Entry->Resource = OwnershipTransitionTable[Index].Acquired;

                        InsertTailList( &EndState->Links, &Entry->Links );

                    }
                }
            }
        }
        
        if (Verbose) {
            printf( "pass done\n" );
        }

    } while (FoundState && Skipped);

    //
    //  Printout state maps
    // 
        
    printf( "State Map\n" );

    for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, TRUE );
         State != 0;
         State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTable( &StateTable, FALSE )) {

        StateCheck = 0;
        
        if (!IsListEmpty( &State->Links )) {

            Entry = (PRESOURCE_LIST)&State->Links;
            do {
                Entry = (PRESOURCE_LIST)Entry->Links.Flink;
                        
                StateCheck |= Entry->Resource;
                printf( "%x -> ", Entry->Resource );
        
            } while ( Entry->Links.Flink != &State->Links );
            printf( "state %x\n", State->State );

            if ((int)State->State != StateCheck) {
                printf( "State transistions do not make sense, check the state definition\n" );
            }

        }  else {
            printf( "unreachable state: 0x%x\n", State->State );
        }
    }

    //
    //  Now build up individual transitions
    // 

    printf( "Subtransitions\n" );

    
    Key = NULL;

    for (State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key );
         State != 0;
         State = (PRESOURCE_STATE_ORDER) RtlEnumerateGenericTableWithoutSplaying( &StateTable, &Key )) {
    
        if (!IsListEmpty( &State->Links )) {

  //          printf( "State: 0x%x\n", State->State );

            Entry = (PRESOURCE_LIST)&State->Links;
            do {
                Entry = (PRESOURCE_LIST)Entry->Links.Flink;
                        
                Entry2 = Entry;
                while (Entry2->Links.Flink != &State->Links) {
                    BOOLEAN Found;

                    Entry2 = (PRESOURCE_LIST)Entry2->Links.Flink;

                    //
                    //  First search if transition exists already from Entry->Resource to Entry2->Resource
                    //  
                    
                    Found = FALSE;
                    StateListOrderTemplate.Resource = Entry->Resource;
                    StateListOrder = (PRESOURCE_STATE_LIST)RtlLookupElementGenericTable( &ResourceTable, &StateListOrderTemplate );
                    
                    if (!IsListEmpty( &StateListOrder->Links )) {

//                        printf( "FirstLink: 0x%x\n", StateListOrder->Links.Flink );

                        EntryState2 = StateListOrder;
                        do {
                            EntryState2 = CONTAINING_RECORD( EntryState2->Links.Flink, RESOURCE_STATE_LIST, Links );
                            if (EntryState2->Resource == Entry2->Resource) {

                                PRESOURCE_LIST OldEntry;

                                //
                                //  Always choose state that started without vcb
                                //

                                StateOrder.State = EntryState2->EndState;
                                EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                                OldEntry = (PRESOURCE_LIST)EndState->Links.Flink;

                                if ((OldEntry->Resource == NtfsResourceSharedVcb) ||
                                    (OldEntry->Resource == NtfsResourceExVcb)) {

                                    EntryState2->EndState = State->State;
                                }

                                Found = TRUE;
                                break;
                            }

                        } while ( EntryState2->Links.Flink != &StateListOrder->Links );
                    }

                    if (!Found) {
                        
                        //
                        //  Look for conflicts since its new
                        //  

                        StateListOrderTemplate.Resource = Entry2->Resource;
                        StateListOrder = (PRESOURCE_STATE_LIST)RtlLookupElementGenericTable( &ResourceTable, &StateListOrderTemplate );

//                        printf( "Resource: 0x%x, empty: %d\n", StateListOrder->Resource, IsListEmpty( &StateListOrder->Links ) );

                        if (StateListOrder && !IsListEmpty( &StateListOrder->Links )) {

                            EntryState2 = StateListOrder;

                            do {
                                EntryState2 = CONTAINING_RECORD( EntryState2->Links.Flink, RESOURCE_STATE_LIST, Links );

                                if ((EntryState2->Resource == Entry->Resource)) {
                                    printf( "possible conflict from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State, EntryState2->EndState );
                                }

//                              printf( "check from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State, EntryState2->EndState );                                

                                StateOrder.State = EntryState2->EndState;
                                EndState = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                                StateOrder.State = State->State;
                                EndState2 = (PRESOURCE_STATE_ORDER)RtlLookupElementGenericTable( &StateTable, &StateOrder );

                                if ((EntryState2->Resource == Entry->Resource) &&
                                    !EndState->ReachedByRelease && 
                                    !EndState2->ReachedByRelease) {

                                    //
                                    //  Now check if vcb locks it out
                                    // 

                                    if (!(((((PRESOURCE_LIST)(EndState2->Links.Flink))->Resource == NtfsResourceSharedVcb) ||
                                         ((PRESOURCE_LIST)(EndState2->Links.Flink))->Resource == NtfsResourceExVcb) &&

                                        ((((PRESOURCE_LIST)(EndState->Links.Flink))->Resource == NtfsResourceSharedVcb) ||
                                         ((PRESOURCE_LIST)(EndState->Links.Flink))->Resource == NtfsResourceExVcb))) {
                                        
                                        printf( "Suborder conflict from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State->State, EntryState2->EndState );
                                        break;
                                    } else {
//                                        printf( "NonSuborder conflict from 0x%x to 0x%x in state 0x%x and state 0x%x\n", Entry->Resource, Entry2->Resource, State, EntryState2->EndState );
                                    }
                                }

                            } while ( EntryState2->Links.Flink != &StateListOrder->Links );
                        } else {
    //                        printf ("Unfound resource: 0x%x 0x%x\n", Entry2->Resource, StateListOrder );
                        }

                        StateListOrderTemplate.Resource = Entry->Resource;
                        StateListOrder = (PRESOURCE_STATE_LIST)RtlLookupElementGenericTable( &ResourceTable, &StateListOrderTemplate );

                        EntryState = new RESOURCE_STATE_LIST;
                        EntryState->Resource = Entry2->Resource;
                        EntryState->EndState = State->State;

      //                  printf( "Adding 0x%x to list for resource 0x%x\n", EntryState, Entry->Resource );
                        
                        InsertTailList( &StateListOrder->Links, &EntryState->Links );
                    }
                }
                
            } while ( Entry->Links.Flink != &State->Links );
        }
    }

    //
    //  Dump the inidivual transitions
    // 

    Key = NULL;
    for (StateListOrder = (PRESOURCE_STATE_LIST) RtlEnumerateGenericTableWithoutSplaying( &ResourceTable, &Key );
         StateListOrder != 0;
         StateListOrder = (PRESOURCE_STATE_LIST) RtlEnumerateGenericTableWithoutSplaying( &ResourceTable, &Key )) {

        if (!IsListEmpty( &StateListOrder->Links )) {
            EntryState = StateListOrder;
            do {
                EntryState = CONTAINING_RECORD( EntryState->Links.Flink, RESOURCE_STATE_LIST, Links );
                printf( "0x%x -> 0x%x endstate:0x%x\n ", StateListOrder->Resource, EntryState->Resource, EntryState->EndState );

            } while ( EntryState->Links.Flink != &StateListOrder->Links );
        }
    }
    
} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tcancel.c ===
#include "brian.h"

VOID
CancelIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    );


VOID
InputCancelIndex (
    IN PCHAR ParamBuffer
    )
{
    BOOLEAN Verbose;
    BOOLEAN HandleFound;
    BOOLEAN DisplayParms;
    ULONG ThisHandleIndex;

    //
    //  Set the defaults.
    //
    Verbose = TRUE;
    DisplayParms = FALSE;
    HandleFound = FALSE;

    //
    //  While there is more input, analyze the parameter and update the
    //  open flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Recover a handle.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ThisHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HandleFound = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        Verbose = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        Verbose = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

            } else {

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

            }

        //
        //  Else break.
        //
        } else {

            break;

        }

    }

    //
    //  If the file name wasn't found, then display the syntax message
    //  and set verbose to FALSE.
    //

    if( !HandleFound ) {

        printf( "\n    Usage:  can [options]*\n" );
        printf( "\n          Options:" );
        printf( "\n                    -i<index number>   Input a index to cancel" );
        printf( "\n                    -v[t|f]            Verbose mode for subsequent handles" );
        printf( "\n                    -y                 Display parameters before call" );
        printf( "\n\n" );

    } else {

        CancelIndex( (USHORT) ThisHandleIndex,
                     DisplayParms,
                     Verbose );
    }

    return;
}


VOID
CancelIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    Iosb.Status = 0;
    Iosb.Information = 0;

    //
    //  Display parameters if requested.
    //

    if (DisplayParameters) {

        printf( "\nCancel Index Parameters" );
        printf( "\n\tIndex      -> %04x", Index );
        printf( "\n\n" );
    }

    if (Index >= MAX_HANDLES) {

        printf( "\n\tCancel Index:  Invalid index value" );
        Status = STATUS_INVALID_HANDLE;

    } else if (!Handles[Index].Used) {

        printf( "\n\tCancelIndex:   Index is unused" );
        Status = STATUS_INVALID_HANDLE;

    } else {

        Status = NtCancelIoFile( Handles[Index].Handle, &Iosb );
        if (VerboseResults) {

            printf( "\nCancelIndex:   Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                printf( "\nCancelIndex:   Iosb.Information  -> %08lx", Iosb.Information );
                printf( "\nCancelIndex:   Iosb.Status       -> %08lx", Iosb.Status );
            }

            printf( "\n" );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tdevctrl.c ===
#include "brian.h"

typedef struct _ASYNC_DEVCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_DEVCTRL, *PASYNC_DEVCTRL;


VOID
RequestDevCtrl (
    IN PASYNC_DEVCTRL DevCtrl
    );

//
//  Local procedures
//


VOID
InputDevctrl (
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputDevCtrl:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputDevCtrl:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = IOCTL_CDROM_DISK_TYPE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = IOCTL_CDROM_READ_TOC;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = IOCTL_DISK_EJECT_MEDIA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            IoControlCode = IOCTL_STORAGE_EJECT_MEDIA;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: ioctl -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         DevCtrl operation" );
        printf( "\n                 -oa             Cdrom disk type" );
        printf( "\n                 -ob             Cdrom read TOC" );
        printf( "\n                 -oc             Disk eject media" );
        printf( "\n                 -od             Storage eject media" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_DEVCTRL AsyncDevCtrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_DEVCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputDevCtrl:  Unable to allocate async structure" );

        } else {

            AsyncDevCtrl = (PASYNC_DEVCTRL) Buffers[AsyncIndex].Buffer;

            AsyncDevCtrl->FileIndex = FileIndex;
            AsyncDevCtrl->UseEvent = UseEvent;
            AsyncDevCtrl->ApcRoutine = ApcRoutine;
            AsyncDevCtrl->ApcContext = ApcContext;
            AsyncDevCtrl->IoControlCode = IoControlCode;
            AsyncDevCtrl->InputBuffer = InputBuffer;
            AsyncDevCtrl->InputBufferLength = InputBufferLength;
            AsyncDevCtrl->OutputBuffer = OutputBuffer;
            AsyncDevCtrl->OutputBufferLength = OutputBufferLength;
            AsyncDevCtrl->VerboseResults = VerboseResults;
            AsyncDevCtrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nDevCtrl Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   DevCtrl operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestDevCtrl,
                                             AsyncDevCtrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputDevCtrl:  Spawning thread fails -> %d\n", GetLastError() );
                }
            } else {

                RequestDevCtrl( AsyncDevCtrl );
            }
        }
    }

    return;
}

VOID
RequestDevCtrl (
    IN PASYNC_DEVCTRL DevCtrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (DevCtrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestDevCtrl:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        Status = NtDeviceIoControlFile( Handles[DevCtrl->FileIndex].Handle,
                                        ThisEvent,
                                        DevCtrl->ApcRoutine,
                                        DevCtrl->ApcContext,
                                        &IoSb,
                                        DevCtrl->IoControlCode,
                                        DevCtrl->InputBuffer,
                                        DevCtrl->InputBufferLength,
                                        DevCtrl->OutputBuffer,
                                        DevCtrl->OutputBufferLength );

        if (DevCtrl->VerboseResults) {

            bprint  "\nRequestDevCtrl:  Status            -> %08lx\n", Status );

            if (DevCtrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tDevctrl:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestDevCtrl:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestDevCtrl:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( DevCtrl->AsyncIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestDevCtrl:  Thread not terminated\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tbuffer.c ===
#include "brian.h"

//
//  Local constants and procedure declarations.
//
#define CHAR_POSITION               51
#define COPY_BUFF_SRC_DEFAULT       0
#define COPY_BUFF_DST_DEFAULT       0
#define COPY_BUFF_SRC_OFF_DEFAULT   0
#define COPY_BUFF_DST_OFF_DEFAULT   0
#define COPY_BUFF_LENGTH_DEFAULT    0

#define DISPLAY_INDEX_DEFAULT       0
#define DISPLAY_OFFSET_DEFAULT      0
#define DISPLAY_LENGTH_DEFAULT      0x100

#define ALLOC_ZERO_BITS_DEFAULT     0
#define ALLOC_REGION_SIZE_DEFAULT   0x100
#define ALLOC_VERBOSE_DEFAULT       TRUE
#define ALLOC_DISPLAY_PARMS_DEFAULT FALSE

ULONG
PrintDwords (
    IN PULONG BufferAddress,
    IN ULONG CountWords
    );

ULONG
PrintWords (
    IN PUSHORT BufferAddress,
    IN ULONG CountWords
    );

ULONG
PrintBytes (
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    );

VOID
PrintChars(
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    );

VOID
ClearBuffer(
    IN ULONG Index
    );

VOID
DisplayBuffer (
    IN ULONG Index,
    IN ULONG StartOffset,
    IN ULONG DisplayLength,
    IN ULONG DisplaySize
    );

VOID
CopyBuffer(
    IN ULONG SrcIndex,
    IN ULONG DstIndex,
    IN ULONG Length,
    IN ULONG SrcOffset,
    IN ULONG DstOffset
    );

VOID
FillBuffer (
    IN ULONG Index,
    IN PVOID Structure,
    IN ULONG Length
    );

NTSTATUS
FullAllocMem(
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );

NTSTATUS
FullDeallocMem(
    IN ULONG Index,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );


VOID
InitBuffers (
    )
{
    NtCreateEvent( &BufferEvent, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                   NULL, SynchronizationEvent, TRUE );

    RtlZeroMemory( Buffers, sizeof( Buffers ));
}


VOID
UninitBuffers (
    )
{
    USHORT Index;

    //
    //  Deallocate any buffers remaining.
    //

    for (Index = 0; Index < MAX_BUFFERS; Index++) {

        DeallocateBuffer( Index );
    }
}


NTSTATUS
AllocateBuffer (
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex
    )
{
    NTSTATUS Status;
    PVOID BufferAddress;
    ULONG Index;

    BufferAddress = NULL;

    //
    //  Wait for the buffer event.
    //

    if ((Status = NtWaitForSingleObject( BufferEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    try {

        //
        //  Find an available index.  Return STATUS_INSUFFICIENT_RESOURCES
        //  if not found.
        //
        for (Index = 0; Index < MAX_BUFFERS; Index++) {

            if (!Buffers[Index].Used) {

                break;
            }
        }

        if (Index >= MAX_BUFFERS) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        //  Otherwise allocate the virtual memory.  If no error occurs, then
        //  store the data in the buffer array.
        //

        } else if ((Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                                      &BufferAddress,
                                                      ZeroBits,
                                                      RegionSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE )) == STATUS_SUCCESS) {

            Buffers[Index].Buffer = BufferAddress;
            Buffers[Index].Length = (ULONG) *RegionSize;
            Buffers[Index].Used = TRUE;
        }

        //
        //  Set the buffer event back to the signalled state.
        //

        *BufferIndex = Index;


        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nAllocate Buffer:  Abnormal termination\n" );
        }

        NtSetEvent( BufferEvent, NULL );
    }
    return Status;
}


NTSTATUS
DeallocateBuffer (
    IN ULONG Index
    )
{
    NTSTATUS Status;

    //
    //  Wait for the buffer event.
    //
    if ((Status = NtWaitForSingleObject( BufferEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    try {

        if (Index <= MAX_BUFFERS
            && Buffers[Index].Used) {

            SIZE_T RegionSize = Buffers[Index].Length;

            Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                          (PVOID *) &Buffers[Index].Buffer,
                                          &RegionSize,
                                          MEM_RELEASE );

            Buffers[Index].Used = FALSE;
        }

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDeallocate Buffer:  Abnormal termination\n" );
        }

        NtSetEvent( BufferEvent, NULL );
    }

    return Status;
}


BOOLEAN
BufferInfo (
    IN ULONG Index,
    OUT PVOID *BufferAddress,
    OUT PULONG RegionSize
    )
{

    if (Index >= MAX_BUFFERS || !Buffers[Index].Used) {

        return FALSE;
    }

    *BufferAddress = Buffers[Index].Buffer;
    *RegionSize = Buffers[Index].Length;

    return TRUE;
}


VOID
InputClearBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG Index;
    BOOLEAN LastInput;
    BOOLEAN ParmSpecified;

    Index = 0;

    ParmSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {
        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Index = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParmSpecified) {

        printf( "\n   Usage: clb -b<digits> \n" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n\n" );


    //
    //  Else call our copy buffer routine.
    //
    } else {

        ClearBuffer( Index );
    }

    return;
}


VOID
ClearBuffer(
    IN ULONG Index
    )
{
    //
    //  Check for an invalid index.
    //

    if (!Buffers[Index].Used) {

        printf( "\nClearBuffer:  Invalid buffer" );

    } else {

        RtlZeroMemory( Buffers[Index].Buffer, Buffers[Index].Length );
    }

    return;
}


VOID
DisplayBuffer (
    IN ULONG Index,
    IN ULONG StartOffset,
    IN ULONG DisplayLength,
    IN ULONG DisplaySize
    )
{
    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[Index].Used) {

        printf( "\nDisplayBuffer: Index refers to invalid buffer" );

    //
    //  Else if the start offset is invalid, then display error
    //  message.
    //

    } else if (StartOffset >= Buffers[Index].Length) {

        printf( "\nDisplayBuffer: Start offset is invalid" );

    //
    //  Else compute the legal display length and output to the screen.
    //

    } else {

        ULONG LegalLength;
        ULONG FullLines;
        PCHAR BufferAddress;
        ULONG SpacesFilled;

        //
        //  The legal display length is the minimum of the remaining
        //  bytes in the buffer and the desired display length.
        //

        LegalLength = Buffers[Index].Length - StartOffset;
        LegalLength = min( LegalLength, DisplayLength );
        BufferAddress = Buffers[Index].Buffer;

        //
        //  Display the display information.
        //

        printf( "\nIndex -> %u, Buffer Base -> %p, ", Index, BufferAddress );
        printf( "Buffer Offset -> %08lx, Bytes -> %u", StartOffset, LegalLength );
        printf( "\n" );

        BufferAddress += StartOffset;

        //
        //  Compute the number and display the full lines.
        //

        FullLines = LegalLength / 16;

        while (FullLines--) {

            if (DisplaySize == sizeof( UCHAR )) {

                PrintBytes( BufferAddress, 16 );

            } else if (DisplaySize == sizeof( WCHAR )) {

                PrintWords( (PVOID) BufferAddress, 8 );

            } else {

                PrintDwords( (PVOID) BufferAddress, 4 );
            }

            printf( "  " );

            PrintChars( BufferAddress, 16 );
            BufferAddress += 16;
        }

        //
        //  Display the remaining bytes.
        //

        if (DisplaySize == sizeof( UCHAR )) {

            SpacesFilled = PrintBytes( BufferAddress, LegalLength % 16 );

        } else if (DisplaySize == sizeof( WCHAR )) {

            SpacesFilled = PrintWords( (PVOID) BufferAddress, LegalLength % 8 );

        } else {

            SpacesFilled = PrintDwords( (PVOID) BufferAddress, LegalLength % 4 );
        }

        if (SpacesFilled) {

            SpacesFilled = CHAR_POSITION - SpacesFilled;
            while ( SpacesFilled-- ) {

                printf( " " );
            }
        }

        PrintChars( BufferAddress, LegalLength % 16 );
        printf( "\n\n" );
    }

    return;
}


ULONG
PrintBytes (
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    )
{
    ULONG CountSpaces;
    ULONG RemainingChars;

    //
    //  Initialize the local variables.
    //

    CountSpaces = CountChars * 3 + (CountChars ? 1 : 0);
    RemainingChars = CountChars - min( CountChars, 8 );
    CountChars = min( CountChars, 8 );

    //
    //  Print the first 8 bytes (if possible).
    //

    if (CountChars) {

        printf( "\n" );

        while (CountChars--) {

            printf( "%02x ", *((PUCHAR) BufferAddress++) );
        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingChars--) {

            printf( "%02x ", *((PUCHAR) BufferAddress++) );
        }

    }

    //
    //  Return the number of spaces used.
    //

    return CountSpaces;
}


ULONG
PrintWords (
    IN PWCHAR BufferAddress,
    IN ULONG CountWords
    )
{
    ULONG CountSpaces;
    ULONG RemainingWords;

    //
    //  Initialize the local variables.
    //

    CountSpaces = CountWords * 5 + (CountWords ? 1 : 0);
    RemainingWords = CountWords - min( CountWords, 4 );
    CountWords = min( CountWords, 4 );

    //
    //  Print the first 4 words (if possible).
    //

    if (CountWords) {

        printf( "\n" );

        while (CountWords--) {

            printf( "%04x ", *((PWCHAR) BufferAddress++) );
        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingWords--) {

            printf( "%04x ", *((PWCHAR) BufferAddress++) );
        }
    }

    //
    //  Return the number of spaces used.
    //

    return CountSpaces;
}


ULONG
PrintDwords (
    IN PULONG BufferAddress,
    IN ULONG CountDwords
    )
{
    ULONG CountSpaces;
    ULONG RemainingDwords;

    //
    //  Initialize the local variables.
    //

    CountSpaces = CountDwords * 7 + (CountDwords ? 1 : 0);
    RemainingDwords = CountDwords - min( CountDwords, 8 );
    CountDwords = min( CountDwords, 8 );

    //
    //  Print the first 2 Dwords (if possible).
    //

    if (CountDwords) {

        printf( "\n" );

        while (CountDwords--) {

            printf( "%08x ", *((PULONG) BufferAddress++) );
        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingDwords--) {

            printf( "%08x ", *((PULONG) BufferAddress++) );
        }
    }

    //
    //  Return the number of spaces used.
    //

    return CountSpaces;
}


VOID
PrintChars(
    IN PCHAR BufferAddress,
    IN ULONG CountChars
    )
{
    ULONG RemainingChars;

    //
    //  Initialize the local variables.
    //

    RemainingChars = CountChars - min( CountChars, 8 );
    CountChars = min( CountChars, 8 );

    //
    //  Print the first 8 bytes (if possible).
    //

    if (CountChars) {

        while (CountChars--) {

            if (*BufferAddress > 31
                 && *BufferAddress != 127) {

                printf( "%c", *BufferAddress );

            } else {

                printf( "." );

            }

            BufferAddress++;

        }

        //
        //  If more bytes, then add a blank space and print the rest of the
        //  bytes.
        //

        printf( " " );

        while (RemainingChars--) {

            if (*BufferAddress > 31
                && *BufferAddress != 127) {

                printf( "%c", *BufferAddress );

            } else {

                printf( "." );
            }

            BufferAddress++;
        }
    }

    return;
}


VOID
InputDisplayBuffer(
    IN PCHAR ParamBuffer,
    IN ULONG DisplaySize
    )
{
    ULONG DisplayLength;
    ULONG DisplayOffset;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    ParamReceived = FALSE;
    LastInput = TRUE;
    BufferIndex = DISPLAY_INDEX_DEFAULT;
    BufferIndex = DISPLAY_INDEX_DEFAULT;
    DisplayOffset = DISPLAY_OFFSET_DEFAULT;
    DisplayLength = DISPLAY_LENGTH_DEFAULT;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check the display length.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DisplayLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check the display offset.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DisplayOffset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: db [options]* -i<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -l<digits>   Display length" );
        printf( "\n           -o<digits>   Display starting offset" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        DisplayBuffer( BufferIndex, DisplayOffset, DisplayLength, DisplaySize );
    }
}


VOID
InputCopyBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG SrcIndex;
    ULONG DstIndex;
    ULONG Length;
    ULONG SrcOffset;
    ULONG DstOffset;
    BOOLEAN DstSpecified;
    BOOLEAN SrcSpecified;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    SrcIndex = COPY_BUFF_SRC_DEFAULT;
    DstIndex = COPY_BUFF_DST_DEFAULT;
    Length = COPY_BUFF_SRC_OFF_DEFAULT;
    SrcOffset = COPY_BUFF_DST_OFF_DEFAULT;
    DstOffset = COPY_BUFF_LENGTH_DEFAULT;

    DstSpecified = FALSE;
    SrcSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if ( *ParamBuffer ) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the destination index.
                //
                case 'd' :
                case 'D' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DstIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    DstSpecified = TRUE;

                    break;

                //
                //  Check source starting offset.
                //

                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SrcOffset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check copy length.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check the source index.
                //
                case 's' :
                case 'S' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SrcIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    SrcSpecified = TRUE;

                    break;

                //
                //  Check destination offset.
                //
                case 't' :
                case 'T' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    DstOffset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!SrcSpecified || !DstSpecified) {

        printf( "\n   Usage: cb [options]* -d<digits> [options]* -s<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -d<digits>   Destination index" );
        printf( "\n           -f<digits>   Source offset" );
        printf( "\n           -l<digits>   Transfer length" );
        printf( "\n           -s<digits>   Source index" );
        printf( "\n           -t<digits>   Destination offset" );
        printf( "\n\n" );


    //
    //  Else call our copy buffer routine.
    //
    } else {

        CopyBuffer( SrcIndex,
                    DstIndex,
                    Length,
                    SrcOffset,
                    DstOffset );

    }
}


VOID
CopyBuffer(
    IN ULONG SrcIndex,
    IN ULONG DstIndex,
    IN ULONG Length,
    IN ULONG SrcOffset,
    IN ULONG DstOffset
    )
{
    //
    //  Check for an invalid source index.
    //

    if (!Buffers[SrcIndex].Used) {

        printf( "\nCopyBuffer:  Invalid source buffer" );

    //
    //  Otherwise check for an invalid destination index.
    //

    } else if (!Buffers[DstIndex].Used) {

        printf( "\nCopyBuffer:  Invalid destination buffer" );


    //
    //  Test for an invalid source offset.
    //

    } else if (SrcOffset >= Buffers[SrcIndex].Length) {

        printf( "\nCopyBuffer:  Source offset is invalid" );

    //
    //  Test for an invalid destination offset.
    //

    } else if (DstOffset >= Buffers[DstIndex].Length) {

        printf( "\nCopyBuffer:  Destination offset is invalid" );

    //
    //  This statement handles the case of two correct indexes and offsets.
    //

    } else {

        ULONG LegalLength;
        PCHAR SrcAddress;
        PCHAR DstAddress;

        //
        //  Adjust the length according to the source buffer size.
        //

        LegalLength = Buffers[SrcIndex].Length - SrcOffset;
        LegalLength = min( LegalLength, Length );
        Length = Buffers[DstIndex].Length - DstOffset;
        LegalLength = min( LegalLength, Length );

        SrcAddress = Buffers[SrcIndex].Buffer + SrcOffset;
        DstAddress = Buffers[DstIndex].Buffer + DstOffset;

        //
        //  Display the header information.
        //

        printf( "\nSource index -> %2u, Source base -> %p, Source offset -> %08lx, ",
                  SrcIndex, 
                  Buffers[SrcIndex].Buffer,
                  SrcOffset );

        printf( "\n  Dest index -> %2u,   Dest base -> %p,   Dest offset -> %08lx, ",
                  DstIndex, 
                  Buffers[DstIndex].Buffer, 
                  DstOffset );

        printf( "\nLength -> %u", Length );

        //
        //  Perform the transfer for non-zero lengths only.
        //

        if (Length) {

            RtlMoveMemory( DstAddress, SrcAddress, Length );
        }
    }

    return;
}


VOID
InputAllocMem(
    IN PCHAR ParamBuffer
    )
{
    ULONG ZeroBits;
    SIZE_T RegionSize;
    ULONG BufferIndex;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    ZeroBits = ALLOC_ZERO_BITS_DEFAULT;
    RegionSize = ALLOC_REGION_SIZE_DEFAULT;
    VerboseResults = ALLOC_VERBOSE_DEFAULT;
    DisplayParms = ALLOC_DISPLAY_PARMS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if ( *ParamBuffer ) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update zero bits.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ZeroBits = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the region size.
                //
                case 'r' :
                case 'R' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    RegionSize = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;
                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;
                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: am [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Zero bits" );
        printf( "\n           -r<digits>   Region size" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n\n" );


    //
    //  Else call our allocation routine.
    //
    } else {

        FullAllocMem(
                ZeroBits,
                &RegionSize,
                &BufferIndex,
                VerboseResults,
                DisplayParms
                );

    }
}

NTSTATUS
FullAllocMem(
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    OUT PULONG BufferIndex,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    if (DisplayParms) {

        printf( "\nAlloc Memory Parameters" );
        printf( "\n   Zero Bits               -> %ld", ZeroBits );
        printf( "\n   Region Size             -> %ld", *RegionSize );
        printf( "\n\n" );
    }

    //
    //  Try to get the next buffer.
    //

    Status = AllocateBuffer( ZeroBits, RegionSize, BufferIndex );

    //
    //  Print the results if verbose.
    //

    if (VerboseResults) {

        printf( "\nAllocMem:    Status           -> %08lx", Status );
        printf( "\n             RegionSize       -> %08lx", *RegionSize );
        printf( "\n             BufferIndex      -> %ld", *BufferIndex );
        printf( "\n\n" );
    }

    return Status;
}


VOID
InputDeallocMem(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;

    //
    //  Set the defaults.
    //

    VerboseResults = ALLOC_VERBOSE_DEFAULT;
    DisplayParms = ALLOC_DISPLAY_PARMS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Find the Index value.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;
                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;
                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dm [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer Index number" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n\n" );


    //
    //  Else call our allocation routine.
    //
    } else {

        FullDeallocMem(
                BufferIndex,
                VerboseResults,
                DisplayParms );
    }
}


NTSTATUS
FullDeallocMem(
    IN ULONG Index,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    if (DisplayParms) {

        printf( "\nDealloc Memory Parameters" );
        printf( "\n   Buffer Index             -> %ld", Index );
        printf( "\n\n" );
    }

    //
    //  Try to free the desired buffer.
    //

    Status = DeallocateBuffer( Index );

    //
    //  Print the results if verbose.
    //

    if (VerboseResults) {

        printf( "\nDeallocMem:    Status           -> %08lx", Status );
        printf( "\n\n" );
    }

    return Status;
}


VOID InputFillBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN HaveStructure = FALSE;

    MFT_ENUM_DATA EnumUsnData;
    READ_USN_JOURNAL_DATA ReadUsnJournal;
    CREATE_USN_JOURNAL_DATA CreateUsnJournal;
    LARGE_INTEGER LargeIntegerInput;
    FILE_ALLOCATED_RANGE_BUFFER AllocatedRangeBuffer;

    PVOID StructurePointer;
    ULONG StructureSize;

    ParamReceived = FALSE;
    LastInput = TRUE;
    BufferIndex = DISPLAY_INDEX_DEFAULT;

    RtlZeroMemory( &EnumUsnData, sizeof( MFT_ENUM_DATA ));
    RtlZeroMemory( &ReadUsnJournal, sizeof( READ_USN_JOURNAL_DATA ));
    RtlZeroMemory( &CreateUsnJournal, sizeof( CREATE_USN_JOURNAL_DATA ));
    RtlZeroMemory( &LargeIntegerInput, sizeof( LARGE_INTEGER ));
    RtlZeroMemory( &AllocatedRangeBuffer, sizeof( FILE_ALLOCATED_RANGE_BUFFER ));

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                BOOLEAN SwitchBool;

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check the structure to fill.
                //
                case 's' :
                case 'S' :


                    SwitchBool = TRUE;
                    ParamBuffer++;
                    if (*ParamBuffer
                        && *ParamBuffer != ' '
                        && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                        case 'b' :
                        case 'B' :

                            HaveStructure = TRUE;

                            StructurePointer = &LargeIntegerInput;
                            StructureSize = sizeof( LARGE_INTEGER );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    LargeIntegerInput.QuadPart = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'c' :
                        case 'C' :

                            HaveStructure = TRUE;

                            StructurePointer = &AllocatedRangeBuffer;
                            StructureSize = sizeof( FILE_ALLOCATED_RANGE_BUFFER );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    AllocatedRangeBuffer.FileOffset.QuadPart = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    AllocatedRangeBuffer.Length.QuadPart = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        default :

                            NOTHING;
                        }
                    }

                    break;

                default :

                    NOTHING;
                }

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: fb -b<digits> -s<struct>[options]* \n" );
        printf( "\n           -sa[options]      Get Volume Bitmap" );
        printf( "\n                 a<digits>       Starting lcn" );
        printf( "\n           -sb[options]      Query Retrieval Pointers" );
        printf( "\n                 a<digits>       Starting vcn" );
        printf( "\n           -sc[options]      Query Allocated Ranges" );
        printf( "\n                 a<digits>       FileOffset" );
        printf( "\n                 b<digits>       Length" );

        printf( "\n\n" );

    //
    //  Else fill the buffer.
    //
    } else if (HaveStructure) {

        FillBuffer( BufferIndex, StructurePointer, StructureSize );
    }
}


VOID InputFillBufferUsn(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN HaveStructure = FALSE;

    MFT_ENUM_DATA EnumUsnData;
    READ_USN_JOURNAL_DATA ReadUsnJournal;
    CREATE_USN_JOURNAL_DATA CreateUsnJournal;
    DELETE_USN_JOURNAL_DATA DeleteUsnJournal;

    PVOID StructurePointer;
    ULONG StructureSize;

    ParamReceived = FALSE;
    LastInput = TRUE;
    BufferIndex = DISPLAY_INDEX_DEFAULT;

    RtlZeroMemory( &EnumUsnData, sizeof( MFT_ENUM_DATA ));
    RtlZeroMemory( &ReadUsnJournal, sizeof( READ_USN_JOURNAL_DATA ));
    RtlZeroMemory( &CreateUsnJournal, sizeof( CREATE_USN_JOURNAL_DATA ));
    RtlZeroMemory( &DeleteUsnJournal, sizeof( DELETE_USN_JOURNAL_DATA ));

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                BOOLEAN SwitchBool;

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check the structure to fill.
                //
                case 's' :
                case 'S' :


                    SwitchBool = TRUE;
                    ParamBuffer++;
                    if (*ParamBuffer
                        && *ParamBuffer != ' '
                        && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        //
                        //  ENUM_USN_DATA
                        //

                        case 'a' :
                        case 'A' :

                            HaveStructure = TRUE;

                            StructurePointer = &EnumUsnData;
                            StructureSize = sizeof( MFT_ENUM_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    EnumUsnData.LowUsn = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    EnumUsnData.HighUsn = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'c' :
                                case 'C' :

                                    ParamBuffer++;
                                    EnumUsnData.StartFileReferenceNumber = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'b' :
                        case 'B' :

                            HaveStructure = TRUE;

                            StructurePointer = &ReadUsnJournal;
                            StructureSize = sizeof( READ_USN_JOURNAL_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    ReadUsnJournal.StartUsn = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    ReadUsnJournal.ReasonMask = AsciiToInteger( ParamBuffer );
                                    break;

                                case 'c' :
                                case 'C' :

                                    ParamBuffer++;
                                    ReadUsnJournal.ReturnOnlyOnClose = AsciiToInteger( ParamBuffer );
                                    break;

                                case 'd' :
                                case 'D' :

                                    ParamBuffer++;
                                    ReadUsnJournal.Timeout = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'e' :
                                case 'E' :

                                    ParamBuffer++;
                                    ReadUsnJournal.BytesToWaitFor = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'f' :
                                case 'F' :

                                    ParamBuffer++;
                                    ReadUsnJournal.UsnJournalID = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'c' :
                        case 'C' :

                            HaveStructure = TRUE;

                            StructurePointer = &CreateUsnJournal;
                            StructureSize = sizeof( CREATE_USN_JOURNAL_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    CreateUsnJournal.MaximumSize = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                case 'b' :
                                case 'B' :

                                    ParamBuffer++;
                                    CreateUsnJournal.AllocationDelta = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        case 'd' :
                        case 'D' :

                            HaveStructure = TRUE;

                            StructurePointer = &DeleteUsnJournal;
                            StructureSize = sizeof( DELETE_USN_JOURNAL_DATA );

                            ParamBuffer++;
                            if (*ParamBuffer
                                && *ParamBuffer != ' '
                                && *ParamBuffer != '\t') {

                                switch (*ParamBuffer) {

                                case 'a' :
                                case 'A' :

                                    ParamBuffer++;
                                    DeleteUsnJournal.UsnJournalID = AsciiToLargeInteger( ParamBuffer );
                                    break;

                                default :

                                    NOTHING;
                                }
                            }

                            break;

                        default :

                            NOTHING;
                        }
                    }

                    break;

                default :

                    NOTHING;
                }

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: fbusn -b<digits> -s<struct>[options]* \n" );
        printf( "\n           -sa[options]      Enum Usn Data" );
        printf( "\n                 a<digits>       Low usn" );
        printf( "\n                 b<digits>       High usn" );
        printf( "\n                 c<digits>       File ref" );
        printf( "\n           -sb[options]      Read Usn Data" );
        printf( "\n                 a<digits>       Start usn" );
        printf( "\n                 b<digits>       Reason mask" );
        printf( "\n                 c<digits>       Return only on close" );
        printf( "\n                 d<digits>       Timeout" );
        printf( "\n                 e<digits>       Bytes to wait for" );
        printf( "\n                 f<digits>       Journal id" );
        printf( "\n           -sc[options]      Create Usn Data" );
        printf( "\n                 a<digits>       Maximum size" );
        printf( "\n                 b<digits>       Allocation delta" );
        printf( "\n           -sd[options]      Delete Usn Journal Data" );
        printf( "\n                 a<digits>       Usn journal id" );

        printf( "\n\n" );

    //
    //  Else fill the buffer.
    //
    } else if (HaveStructure) {

        FillBuffer( BufferIndex, StructurePointer, StructureSize );
    }
}


VOID
FillBuffer (
    IN ULONG Index,
    IN PVOID Structure,
    IN ULONG Length
    )
{
    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[Index].Used) {

        printf( "\nFillBuffer: Index refers to invalid buffer" );

    //
    //  Else copy as much of the data as will fit into the buffer.
    //

    } else {

        if (Length > Buffers[Index].Length) {

            Length = Buffers[Index].Length;
        }

        RtlCopyMemory( Buffers[Index].Buffer, Structure, Length );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tclose.c ===
#include "brian.h"

VOID
CloseIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    );


VOID
InputCloseIndex (
    IN PCHAR ParamBuffer
    )
{
    BOOLEAN Verbose;
    BOOLEAN HandleFound;
    BOOLEAN DisplayParms;
    ULONG ThisHandleIndex;

    //
    //  Set the defaults.
    //
    Verbose = TRUE;
    DisplayParms = FALSE;
    HandleFound = FALSE;

    //
    //  While there is more input, analyze the parameter and update the
    //  open flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Recover a handle.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ThisHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HandleFound = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        Verbose = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        Verbose = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

            } else {

                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

            }

        //
        //  Else break.
        //
        } else {

            break;

        }

    }

    //
    //  If the file name wasn't found, then display the syntax message
    //  and set verbose to FALSE.
    //

    if( !HandleFound ) {

        printf( "\n    Usage:  cl [options]*\n" );
        printf( "\n          Options:" );
        printf( "\n                    -i<index number>   Input a index to close" );
        printf( "\n                    -v[t|f]            Verbose mode for subsequent handles" );
        printf( "\n                    -y                 Display parameters before call" );
        printf( "\n\n" );

    } else {

        CloseIndex( (USHORT) ThisHandleIndex,
                    DisplayParms,
                    Verbose );
    }

    return;
}


VOID
CloseIndex (
    IN USHORT Index,
    IN BOOLEAN DisplayParameters,
    IN BOOLEAN VerboseResults
    )
{
    NTSTATUS Status;

    //
    //  Display parameters if requested.
    //

    if (DisplayParameters) {

        printf( "\nClose Index Parameters" );
        printf( "\n\tIndex      -> %04x", Index );
        printf( "\n\n" );
    }

    if (Index >= MAX_HANDLES) {

        printf( "\n\tClose Index:  Invalid index value" );
        Status = STATUS_INVALID_HANDLE;

    } else if (!Handles[Index].Used) {

        printf( "\n\tCloseIndex:   Index is unused" );
        Status = STATUS_INVALID_HANDLE;

    } else {

        Status = FreeIndex( Index );
        if (VerboseResults) {

            printf( "\n  FreeIndex:                  Status   -> %08lx\n\n", Status );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tea.c ===
#include "brian.h"

#define PEAN_INDEX_DEFAULT          0
#define PEAN_OFFSET_DEFAULT         0
#define PEAN_NEXT_OFFSET_DEFAULT    NULL
#define PEAN_ACT_NEXT_OFF_DEFAULT   0
#define PEAN_NAME_DEFAULT           NULL
#define PEAN_VERBOSE_DEFAULT        TRUE
#define PEAN_DISPLAY_PARMS_DEFAULT  FALSE
#define PEAN_MORE_EAS_DEFAULT       FALSE

#define FEA_INDEX_DEFAULT               0
#define FEA_OFFSET_DEFAULT              0
#define FEA_NEXT_OFFSET_DEFAULT         NULL
#define FEA_ACT_NEXT_OFF_DEFAULT        0
#define FEA_NAME_DEFAULT                NULL
#define FEA_VALUE_DEFAULT               NULL
#define FEA_FLAGS_DEFAULT               NULL
#define FEA_ACTUAL_FLAGS_DEFAULT        0
#define FEA_VERBOSE_DEFAULT             TRUE
#define FEA_DISPLAY_PARMS_DEFAULT       FALSE
#define FEA_MORE_EAS_DEFAULT            FALSE

#define QEA_FILE_HANDLE_DEFAULT         0
#define QEA_BUFFER_INDEX_DEFAULT        0
#define QEA_BUFFER_LENGTH_DEFAULT       NULL
#define QEA_RETURN_SINGLE_DEFAULT       FALSE
#define QEA_EA_NAME_BUFFER_DEFAULT      NULL
#define QEA_EA_NAME_BUFFER_LEN_DEFAULT  NULL
#define QEA_EA_INDEX_DEFAULT            NULL
#define QEA_RESTART_SCAN_DEFAULT        FALSE
#define QEA_VERBOSE_DEFAULT             TRUE

#define SEA_FILE_HANDLE_DEFAULT         0
#define SEA_BUFFER_INDEX_DEFAULT        0
#define SEA_BUFFER_LENGTH_DEFAULT       NULL
#define SEA_VERBOSE_DEFAULT             FALSE

NTSTATUS
PutEaName(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PSTRING Name,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms,
    IN BOOLEAN MoreEas
    );

NTSTATUS
FillEaBuffer(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PUCHAR Flags,
    IN PSTRING Name,
    IN PSTRING Value,
    IN BOOLEAN MoreEas,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms
    );

NTSTATUS
QueryEa(
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN ReturnSingleEntry,
    IN PULONG EaNameBuffer OPTIONAL,
    IN PULONG EaNameBufferLength OPTIONAL,
    IN PULONG EaIndex,
    IN BOOLEAN RestartScan,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );

NTSTATUS
SetEa(
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    );


VOID
InputPutEaName(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    ULONG Offset;
    PULONG NextOffset;
    ULONG ActualNextOffset;
    PSTRING Name;
    STRING ActualName;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    PCHAR EaNameTemp;
    BOOLEAN MoreEas;

    BufferIndex = PEAN_INDEX_DEFAULT;
    Offset = PEAN_OFFSET_DEFAULT;
    NextOffset = PEAN_NEXT_OFFSET_DEFAULT;
    ActualNextOffset = PEAN_ACT_NEXT_OFF_DEFAULT;
    Name = PEAN_NAME_DEFAULT;
    VerboseResults = PEAN_VERBOSE_DEFAULT;
    DisplayParms = PEAN_DISPLAY_PARMS_DEFAULT;
    MoreEas = PEAN_MORE_EAS_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check if we're adding more eas.
                //

                case 'm' :
                case 'M' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        MoreEas = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        MoreEas = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Get the Ea name.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    EaNameTemp = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    //
                    //  If the name length is 0, then ignore this entry.
                    //
                    if (DummyCount) {

                        ActualName.Buffer = EaNameTemp;
                        ActualName.Length = (SHORT) DummyCount;
                        ActualName.MaximumLength = (SHORT) DummyCount;
                        Name = &ActualName;

                    } else {

                        Name = NULL;
                    }

                    ParamReceived = TRUE;
                    break;

                //
                //  Update offset to store the information.
                //
                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Offset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the next offset field.
                //
                case 'x' :
                case 'X' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualNextOffset = AsciiToInteger( ParamBuffer );

                    NextOffset = &ActualNextOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if( !ParamReceived ) {

        printf( "\n   Usage: pea [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -n<ea name>  EaName to store in buffer" );
        printf( "\n           -o<digits>   Offset in buffer to store data" );
        printf( "\n           -x<digits>   Value for next offset field" );
        printf( "\n           -m[t|f]      More Eas coming (Fills next offset field)" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our put ea name routine.
    //
    } else {

        PutEaName( BufferIndex,
                   Offset,
                   NextOffset,
                   Name,
                   VerboseResults,
                   DisplayParms,
                   MoreEas );

    }


}

NTSTATUS
PutEaName(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PSTRING Name,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms,
    IN BOOLEAN MoreEas
    )
{
    NTSTATUS Status;
    ULONG DataLength;

    //
    //  Display parameters if requested.
    //

    if (DisplayParms) {

        printf( "\nPut Ea Name Parameters" );
        printf( "\n   Buffer index            -> %ld", BufferIndex );
        printf( "\n   Buffer offset           -> %08lx", Offset );
        if (NextOffset) {

            printf( "\n   Next offset             -> %08lx", *NextOffset );

        }
        if (Name) {

            printf( "\n   Ea name                 -> %S", &Name );
        }

        printf( "\n   MoreEas                 -> %d", MoreEas );
        printf( "\n\n" );
    }

    if (Name) {

        DataLength = 6 + Name->Length;

    } else {

        DataLength = 5;
    }

    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nPutEaName: Index refers to invalid buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if the start offset is invalid, then display error
    //  message.
    //

    } else if (Offset >= Buffers[BufferIndex].Length) {

        printf( "\nPutEaName: Start offset is invalid" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if length is insufficient to store all of the data
    //  display message.
    //

    } else if (DataLength >= Buffers[BufferIndex].Length) {

        printf( "\nPutEaName: Data won't fit in buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else store the data in the buffer.
    //

    } else {

        PFILE_GET_EA_INFORMATION EaNameBuffer;

        EaNameBuffer = (PFILE_GET_EA_INFORMATION)
                        (Buffers[BufferIndex].Buffer + Offset);

        //
        //  Store the next offset if specified.
        //

        if (NextOffset) {

            EaNameBuffer->NextEntryOffset = *NextOffset;
        }

        //
        //  Store the name and name length if specified.
        //

        if (Name) {

            EaNameBuffer->EaNameLength = (UCHAR) Name->Length;
            RtlMoveMemory( EaNameBuffer->EaName, Name->Buffer, Name->Length );
        }

        if (MoreEas) {

            EaNameBuffer->NextEntryOffset = (DataLength + 3) & ~3;
        }

        Status = STATUS_SUCCESS;
    }

    if (Verbose) {

        printf( "\nPutEaName:   Status           -> %08lx\n", Status );
        printf( "             Following offset -> %ld\n",
                  (DataLength + Offset + 3) & ~3 );
    }

    return Status;
}


VOID
InputFillEaBuffer(
    IN PCHAR ParamBuffer
    )
{
    ULONG BufferIndex;
    ULONG Offset;
    PULONG NextOffset;
    ULONG ActualNextOffset;
    PSTRING Name;
    STRING ActualName;
    PSTRING Value;
    STRING ActualValue;
    PUCHAR Flags;
    UCHAR ActualFlags;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN MoreEas;
    PCHAR StringTemp;

    BufferIndex = FEA_INDEX_DEFAULT;
    Offset = FEA_OFFSET_DEFAULT;
    NextOffset = FEA_NEXT_OFFSET_DEFAULT;
    ActualNextOffset = FEA_ACT_NEXT_OFF_DEFAULT;
    Name = FEA_NAME_DEFAULT;
    Value = FEA_VALUE_DEFAULT;
    Flags = FEA_FLAGS_DEFAULT;
    ActualFlags = FEA_ACTUAL_FLAGS_DEFAULT;
    MoreEas = FEA_MORE_EAS_DEFAULT;
    VerboseResults = FEA_VERBOSE_DEFAULT;
    DisplayParms = FEA_DISPLAY_PARMS_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the flags field.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while( *ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t' ) {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            ActualFlags |= FILE_NEED_EA;

                            Flags = &ActualFlags;

                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;

                        }

                        if (!SwitchBool) {

                            break;
                        }


                        ParamBuffer++;
                    }

                    break;

                //
                //  Get the Ea name.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    StringTemp = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ActualName.Buffer = StringTemp;
                    ActualName.Length = (SHORT) DummyCount;
                    ActualName.MaximumLength = (SHORT) DummyCount;
                    Name = &ActualName;

                    break;

                //
                //  Get the Ea value.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Remember the buffer offset and get the value.
                    //
                    ParamBuffer++;
                    StringTemp = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ActualValue.Buffer = StringTemp;
                    ActualValue.Length = (SHORT) DummyCount;
                    ActualValue.MaximumLength = (SHORT) DummyCount;
                    Value = &ActualValue;

                    break;

                //
                //  Check if we're adding more eas.
                //

                case 'm' :
                case 'M' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        MoreEas = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        MoreEas = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update offset to store the information.
                //
                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Offset = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the next offset field.
                //
                case 'x' :
                case 'X' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualNextOffset = AsciiToInteger( ParamBuffer );

                    NextOffset = &ActualNextOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: fea [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -f<chars>    Ea flags to store in buffer" );
        printf( "\n           -n<chars>    EaName to store in buffer" );
        printf( "\n           -l<chars>    Ea value to store in buffer" );
        printf( "\n           -m[t|f]      More Eas coming (Fills next offset field)" );
        printf( "\n           -o<digits>   Offset in buffer to store data" );
        printf( "\n           -x<digits>   Value for next offset field" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our put ea name routine.
    //
    } else {

        FillEaBuffer( BufferIndex,
                      Offset,
                      NextOffset,
                      Flags,
                      Name,
                      Value,
                      MoreEas,
                      VerboseResults,
                      DisplayParms );

    }

    return;
}

NTSTATUS
FillEaBuffer(
    IN ULONG BufferIndex,
    IN ULONG Offset,
    IN PULONG NextOffset,
    IN PUCHAR Flags,
    IN PSTRING Name,
    IN PSTRING Value,
    IN BOOLEAN MoreEas,
    IN BOOLEAN Verbose,
    IN BOOLEAN DisplayParms
    )
{

    NTSTATUS Status;
    ULONG DataLength;

    //
    //  Display parameters if requested.
    //

    if (DisplayParms) {

        printf( "\nFill Ea Buffer Parameters" );
        printf( "\n   Buffer index            -> %ld", BufferIndex );
        printf( "\n   Buffer offset           -> %08lx", Offset );
        if (NextOffset) {

            printf( "\n   Next offset             -> %08lx", *NextOffset );
        }

        if (Flags) {

            printf( "\n   Flags                   -> %02x", *Flags );
        }

        if (Name) {

            printf( "\n   Ea name                 -> %S", Name );
        }

        if (Value) {

            printf( "\n   Value                   -> %S", Value );
        }

        printf( "\n   MoreEas                 -> %d", MoreEas );
        printf( "\n\n" );

    }

    DataLength = 0;

    if (NextOffset) {

	DataLength = 4;
    }

    if (Flags) {

        DataLength = 5;
    }

    if (Name) {

        DataLength = 9 + Name->Length;

        if (Value) {

            if (Value->Length) {

                DataLength += (Value->Length + 4);
            }
        }

    } else if (Value) {

        DataLength = 9;

        if (Value->Length) {

            DataLength = 9 + (Value->Length + 4);
        }
    }

    //
    //  If the index is unused, display message but take no action.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nFillEaBuffer: Index refers to invalid buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if the start offset is invalid, then display error
    //  message.
    //

    } else if (Offset >= Buffers[BufferIndex].Length) {

        printf( "\nFillEaBuffer: Start offset is invalid" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else if length is insufficient to store all of the data
    //  display message.
    //

    } else if (DataLength >= Buffers[BufferIndex].Length) {

        printf( "\nFillEaBuffer: Data won't fit in buffer" );
        Status = STATUS_INVALID_HANDLE;

    //
    //  Else store the data in the buffer.
    //

    } else {

	PFILE_FULL_EA_INFORMATION EaBuffer;

	EaBuffer = (PFILE_FULL_EA_INFORMATION)
                   (Buffers[BufferIndex].Buffer + Offset);

        //
        //  Store the next offset if specified.
        //

        if (NextOffset) {

            EaBuffer->NextEntryOffset = *NextOffset;
        }

        //
        //  Store the flags if specified.
        //

        if (Flags) {

            EaBuffer->Flags = *Flags;
        }

        //
        //  Store the name and name length if specified.
        //

        if (Name) {

            EaBuffer->EaNameLength = (UCHAR) Name->Length;
            RtlMoveMemory( EaBuffer->EaName, Name->Buffer, Name->Length );
            EaBuffer->EaName[Name->Length] = '\0';

        }

        //
        //  Store the value if specified.
        //

        if (Value) {

            ULONG Index;
            USHORT ValueLength;
            PUSHORT ActualValueLength;

            ValueLength = (USHORT) (Value->Length ? Value->Length + 4 : 0);

            Index = DataLength - 8 - Value->Length - 4;

            EaBuffer->EaValueLength = ValueLength;

            if (ValueLength) {

                EaBuffer->EaName[Index++] = (CHAR) 0xFD;
                EaBuffer->EaName[Index++] = (CHAR) 0xFF;

                ActualValueLength = (PUSHORT) &EaBuffer->EaName[Index++];

                *ActualValueLength = Value->Length;

                Index++;

                RtlMoveMemory( &EaBuffer->EaName[Index],
                            Value->Buffer,
                            Value->Length );
            }
        }

        //
        //  Update the next entry field automatically.
        //

        if (MoreEas && !NextOffset) {

            EaBuffer->NextEntryOffset = (DataLength + 3) & ~3;
        }

        Status = STATUS_SUCCESS;
    }

    if (Verbose) {

        printf( "\nFillEaBuffer:   Status           -> %08lx\n", Status );
        printf( "                Following offset -> %ld\n",
                  (DataLength + Offset + 3) & ~3 );

    }

    return Status;
}


VOID
InputQueryEa(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileHandleIndex;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG BufferIndex;
    PULONG BufferLength;
    ULONG ActualBufferLength;
    BOOLEAN ReturnSingleEntry;
    PULONG EaNameBuffer;
    ULONG ActualEaNameBuffer;
    PULONG EaNameBufferLength;
    ULONG ActualEaNameBufferLength;
    PULONG EaIndex;
    ULONG ActualEaIndex;
    BOOLEAN RestartScan;

    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Initialize to the default value.
    //

    FileHandleIndex = QEA_FILE_HANDLE_DEFAULT;
    BufferIndex = QEA_BUFFER_INDEX_DEFAULT;
    BufferLength = QEA_BUFFER_LENGTH_DEFAULT;
    ReturnSingleEntry = QEA_RETURN_SINGLE_DEFAULT;
    EaNameBuffer = QEA_EA_NAME_BUFFER_DEFAULT;
    EaNameBufferLength = QEA_EA_NAME_BUFFER_LEN_DEFAULT;
    EaIndex = QEA_EA_INDEX_DEFAULT;
    RestartScan = QEA_RESTART_SCAN_DEFAULT;
    VerboseResults = QEA_VERBOSE_DEFAULT;

    //
    //  Initialize the other interesting values.
    //

    ActualBufferLength = 0;
    ActualEaNameBuffer = 0;
    ActualEaNameBufferLength = 0;
    ActualEaIndex = 0;
    DisplayParms = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the length of the Ea name buffer.
                //

                case 'g' :
                case 'G' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualEaNameBufferLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    EaNameBufferLength = &ActualEaNameBufferLength;

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the file handle index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the EA index to start from.
                //
                case 'e' :
                case 'E' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualEaIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    EaIndex = &ActualEaIndex;

                    ParamReceived = TRUE;

                    break;

                //
                //  Update buffer length to pass.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualBufferLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    BufferLength = &ActualBufferLength;

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the ea name buffer to use.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualEaNameBuffer = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    EaNameBuffer = &ActualEaNameBuffer;

                    ParamReceived = TRUE;

                    break;

                //
                //  Set or clear the restart flag
                //

                case 'r' :
                case 'R' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        RestartScan = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        RestartScan = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;

                    break;

                //
                //  Set or clear the single ea flag.
                //

                case 's' :
                case 'S' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        ReturnSingleEntry = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        ReturnSingleEntry = FALSE;
                        ParamBuffer++;

                    }

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qea [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   Open file handle" );
        printf( "\n           -b<digits>   Output buffer index" );
        printf( "\n           -l<digits>   Declared length of output buffer (Optional)" );
        printf( "\n           -n<digits>   Ea name buffer index" );
        printf( "\n           -g<digits>   Declared length of ea name buffer (Optional)" );
        printf( "\n           -e<digits>   Ea index to start from" );
        printf( "\n           -r[t|f]      Restart scan" );
        printf( "\n           -s[t|f]      Return single entry" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our query ea routine.
    //
    } else {

        QueryEa( FileHandleIndex,
                 &IoStatusBlock,
                 BufferIndex,
                 BufferLength,
                 ReturnSingleEntry,
                 EaNameBuffer,
                 EaNameBufferLength,
                 EaIndex,
                 RestartScan,
                 VerboseResults,
                 DisplayParms );
    }

    return;
}


NTSTATUS
QueryEa (
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN ReturnSingleEntry,
    IN PULONG EaNameBuffer OPTIONAL,
    IN PULONG EaNameBufferLength OPTIONAL,
    IN PULONG EaIndex,
    IN BOOLEAN RestartScan,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )

{
    NTSTATUS Status;

    //
    //  Perform initialization.
    //

    IoStatusBlock->Status = STATUS_SUCCESS;
    IoStatusBlock->Information = 0;

    //
    //  If the buffer index is unused, display an error message.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nQueryEa: Index refers to invalid buffer" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  Else if the ea name buffer is specified but unused, display
    //  an error message.
    //

    } else if (EaNameBuffer && !Buffers[*EaNameBuffer].Used) {

        printf( "\nQueryEa: Index refers to invalid buffer" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  Display the parameters if requested, then call the query Ea
    //  routine.  Display the results if requested.
    //

    } else {

        if (DisplayParms) {

            printf( "\nQuery Ea Parameters" );
            printf( "\n   Handle index            -> %ld", FileHandleIndex );
            printf( "\n   Buffer index length     -> %lx",
                      BufferLength ? *BufferLength : Buffers[BufferIndex].Length );
            printf( "\n   Return single entry     -> %ld", ReturnSingleEntry );
            if (EaNameBuffer) {

                printf( "\n   Ea name buffer index    -> %ld",
                          *EaNameBuffer );

                printf( "\n   Ea name buffer length   -> %lx",
                          EaNameBufferLength ? *EaNameBufferLength : Buffers[*EaNameBuffer].Length );

            }

            if (EaIndex) {

                printf( "\n   Ea index to start at    -> %ld", *EaIndex );

            }
            printf( "\n   Restart scan            -> %ld", RestartScan );
            printf( "\n\n" );

        }

        Status = NtQueryEaFile( Handles[FileHandleIndex].Handle,
                                IoStatusBlock,
                                Buffers[BufferIndex].Buffer,
                                BufferLength
                                ? *BufferLength
                                : Buffers[BufferIndex].Length,
                                ReturnSingleEntry,
                                EaNameBuffer
                                ? Buffers[*EaNameBuffer].Buffer
                                : NULL,
                                EaNameBuffer
                                ? (EaNameBufferLength
                                   ? *EaNameBufferLength
                                   : Buffers[*EaNameBuffer].Length)
                                : 0,
                                EaIndex,
                                RestartScan );
    }

    if (VerboseResults) {

        printf( "\nQuery Ea:  Status           -> %08lx\n", Status );

        if (NT_SUCCESS( Status )) {

            printf( "           Iosb.Information   -> %08lx\n", IoStatusBlock->Information );
            printf( "           Iosb.Status        -> %08lx", IoStatusBlock->Status );
        }

        printf( "\n" );
    }

    return Status;
}


VOID
InputSetEa(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileHandleIndex;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG BufferIndex;
    PULONG BufferLength;
    ULONG ActualBufferLength;

    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Initialize to the default value.
    //

    FileHandleIndex = SEA_FILE_HANDLE_DEFAULT;
    BufferIndex = SEA_BUFFER_INDEX_DEFAULT;
    BufferLength = SEA_BUFFER_LENGTH_DEFAULT;
    VerboseResults = SEA_VERBOSE_DEFAULT;

    //
    //  Initialize the other interesting values.
    //

    ActualBufferLength = 0;
    DisplayParms = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the file handle index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived =TRUE;

                    break;

                //
                //  Update buffer length to pass.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualBufferLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    BufferLength = &ActualBufferLength;

                    ParamReceived = TRUE;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

               case 'z' :
               case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: sea [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   Open file handle" );
        printf( "\n           -b<digits>   Output buffer index" );
        printf( "\n           -l<digits>   Declared length of output buffer (Optional)" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our query ea routine.
    //
    } else {

        SetEa( FileHandleIndex,
               &IoStatusBlock,
               BufferIndex,
               BufferLength,
               VerboseResults,
               DisplayParms );

    }

    return;
}

NTSTATUS
SetEa(
    IN ULONG FileHandleIndex,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG BufferIndex,
    IN PULONG BufferLength OPTIONAL,
    IN BOOLEAN VerboseResults,
    IN BOOLEAN DisplayParms
    )
{
    NTSTATUS Status;

    if (DisplayParms) {

        printf( "\nSet Ea Parameters" );
        printf( "\n   Handle index            -> %ld", FileHandleIndex );
        printf( "\n   Buffer index            -> %ld", BufferIndex );
        printf( "\n   Buffer index length     -> %lx",
                  BufferLength ? *BufferLength : Buffers[BufferIndex].Length );
        printf( "\n\n" );
    }

    //
    //  Perform initialization.
    //

    Status = STATUS_SUCCESS;
    IoStatusBlock->Status = STATUS_SUCCESS;
    IoStatusBlock->Information = 0;

    //
    //  If the buffer index is unused, display an error message.
    //

    if (!Buffers[BufferIndex].Used) {

        printf( "\nSetEa: Index refers to invalid buffer" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  If the handle index is unused, display an error message.
    //

    } else if (!Handles[FileHandleIndex].Used) {

        printf( "\nSetEa: Index refers to invalid file handle" );
        IoStatusBlock->Status = STATUS_INVALID_HANDLE;

    //
    //  Display the parameters if requested, then call the query Ea
    //  routine.  Display the results if requested.
    //

    } else {

        Status = NtSetEaFile( Handles[FileHandleIndex].Handle,
                              IoStatusBlock,
                              Buffers[BufferIndex].Buffer,
                              BufferLength
                              ? *BufferLength
                              : Buffers[BufferIndex].Length );
    }

    if (VerboseResults) {

        printf( "\nSet Ea:  Status           -> %08lx\n", Status );

        if (NT_SUCCESS( Status )) {

            printf( "         Iosb.Information   -> %08lx\n", IoStatusBlock->Information );
            printf( "         Iosb.Status        -> %08lx", IoStatusBlock->Status );
        }

        printf( "\n" );
    }

    return IoStatusBlock->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tevent.c ===
#include "brian.h"


VOID
InitEvents (
    )
{
    NtCreateEvent( &EventEvent, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                   NULL, SynchronizationEvent, TRUE );

    RtlZeroMemory( Events, sizeof( Events ));
}


VOID
UninitEvents (
    )
{
    USHORT Index;

    //
    //  Release any current events.
    //

    for (Index = 0; Index < MAX_EVENTS; Index++) {

        if (Events[Index].Used) {

            NtSetEvent( Events[Index].Handle, NULL );
        }
    }
}


NTSTATUS
ObtainEvent (
    OUT PUSHORT NewIndex
    )
{
    NTSTATUS Status;
    USHORT Index;

    //
    //  Wait for the handle event
    //

    if ((Status = NtWaitForSingleObject( EventEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Find an available index.  Return STATUS_INSUFFICIENT_RESOURCES
    //  if not found.
    //

    for (Index = 0; Index < MAX_EVENTS; Index++) {

        if (!Events[Index].Used) {

            break;
        }
    }

    if (Index >= MAX_EVENTS) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    //
    //  Otherwise reserve this event index.
    //

    } else {

        Status = NtCreateEvent( &Events[Index].Handle,
                                SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if (NT_SUCCESS( Status )) {

            Events[Index].Used = TRUE;
            *NewIndex = Index;
        }
    }

    NtSetEvent( EventEvent, NULL );

    return Status;
}


VOID
FreeEvent (
    IN USHORT Index
    )
{
    //
    //  Return immediately if beyond the end of the valid events.
    //

    if (Index >= MAX_EVENTS) {

        return;
    }

    //
    //  Grab the event for the events.
    //

    if (NtWaitForSingleObject( EventEvent, FALSE, NULL ) != STATUS_SUCCESS) {

        return;
    }

    //
    //  Mark the index as unused and release the event if held.
    //

    if (Events[Index].Used) {

        Events[Index].Used = FALSE;
        NtSetEvent( Events[Index].Handle, NULL );
    }

    NtSetEvent( EventEvent, NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tfsctrl.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestFsctrl (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputFsctrl(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputFsctrl:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputFsctrl:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_LOCK_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_UNLOCK_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_DISMOUNT_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            IoControlCode = FSCTL_MARK_VOLUME_DIRTY;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'e' :
                        case 'E' :
                            IoControlCode = FSCTL_IS_PATHNAME_VALID;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'f' :
                        case 'F' :
                            IoControlCode = FSCTL_QUERY_RETRIEVAL_POINTERS;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'g' :
                        case 'G' :
                            IoControlCode = FSCTL_GET_COMPRESSION;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'h' :
                        case 'H' :
                            IoControlCode = FSCTL_SET_COMPRESSION;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'i' :
                        case 'I' :
                            IoControlCode = FSCTL_MARK_AS_SYSTEM_HIVE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'j' :
                        case 'J' :
                            IoControlCode = FSCTL_FILESYSTEM_GET_STATISTICS;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'k' :
                        case 'K' :
                            IoControlCode = FSCTL_IS_VOLUME_DIRTY;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'l' :
                        case 'L' :
                            IoControlCode = FSCTL_GET_NTFS_VOLUME_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'm' :
                        case 'M' :
                            IoControlCode = FSCTL_GET_VOLUME_BITMAP;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'n' :
                        case 'N' :
                            IoControlCode = FSCTL_GET_NTFS_FILE_RECORD;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'o' :
                        case 'O' :
                            IoControlCode = FSCTL_MOVE_FILE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'p' :
                        case 'P' :
                            IoControlCode = FSCTL_ALLOW_EXTENDED_DASD_IO;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'q' :
                        case 'Q' :
                            IoControlCode = FSCTL_GET_RETRIEVAL_POINTERS;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'r' :
                        case 'R' :

                            IoControlCode = FSCTL_SET_ENCRYPTION;
                            HaveIoControlCode = TRUE;
                            break;

                        case 's' :
                        case 'S' :
                            IoControlCode = FSCTL_EXTEND_VOLUME;
                            HaveIoControlCode = TRUE;
                            break;

                        case 't' :
                        case 'T' :
                            IoControlCode = FSCTL_FIND_FILES_BY_SID;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'u' :
                        case 'U' :
                            IoControlCode = FSCTL_MARK_HANDLE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'v' :
                        case 'V' :
                            IoControlCode = FSCTL_FILE_PREFETCH;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: fsct -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Fsctrl operation" );
        printf( "\n                 -oa             Lock volume" );
        printf( "\n                 -ob             Unlock volume" );
        printf( "\n                 -oc             Dismount volume" );
        printf( "\n                 -od             Mark volume dirty" );
        printf( "\n                 -oe             Is pathname valid" );
        printf( "\n                 -of             Query retrieval pointers" );
        printf( "\n                 -og             Get compression" );
        printf( "\n                 -oh             Set compression" );
        printf( "\n                 -oi             Mark as system hive" );
        printf( "\n                 -oj             Get statistics" );
        printf( "\n                 -ok             Is volume dirty" );
        printf( "\n                 -ol             Get Ntfs volume data" );
        printf( "\n                 -om             Get volume bitmap" );
        printf( "\n                 -on             Get Ntfs file record" );
        printf( "\n                 -oo             Move file" );
        printf( "\n                 -op             Set Dasd IO" );
        printf( "\n                 -oq             Get retrieval pointers" );
        printf( "\n                 -or             Set encryption" );
        printf( "\n                 -os             Extend volume" );
        printf( "\n                 -ot             Query files by SID" );
        printf( "\n                 -ou             Mark handle" );
        printf( "\n                 -ov             File prefetch" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputFsctrl:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nFsctrl Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Fsctrl operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {
             
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestFsctrl,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputFsctrl:  Spawning thread fails -> %d\n", GetLastError() );
                }
            } else {

                RequestFsctrl( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestFsctrl (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestFsctrl:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestFsctrl:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tFsctrl:  Wait for event failed -> %08lx", Status );
                }
            }

            if (!NT_ERROR( Status )) {

                bprint  "\nRequestFsctrl:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestFsctrl:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestFsctrl:  Thread not terminated\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tmisc.c ===
#include "brian.h"

VOID
PrintLargeInteger (
    IN PLARGE_INTEGER LargeInt
    )
{
    printf( "%08lx:%08lx", LargeInt->HighPart, LargeInt->LowPart );
    return;
}

ULONG
AsciiToInteger (
    IN PCHAR Ascii
    )
{
    BOOLEAN DoHex = FALSE;
    LONG Integer = 0;
    PCHAR c;

    while (*Ascii) {

        if (Integer == 0 &&
            (*Ascii == 'x' || *Ascii == 'X')) {

            DoHex = TRUE;

        } else {
        
            if (DoHex) {

                *Ascii = (CHAR) toupper( *Ascii );

                if (*Ascii < '0' ||
                    (*Ascii > '9' &&
                     (*Ascii < 'A' || *Ascii > 'F'))) {

                    break;
                }

                Integer *= 16;
                Integer += ( *Ascii - ( *Ascii > '9' ? ('A' - 10) : '0' ));
                
            } else {

                if (*Ascii < '0' || *Ascii > '9') {

                    break;
                }

                Integer *= 10;
                Integer += (*Ascii - '0');
            }
        }

        Ascii++;
    }

    return Integer;
}

ULONGLONG
AsciiToLargeInteger (
    IN PCHAR Ascii
    )
{
    BOOLEAN DoHex = FALSE;
    ULONGLONG Integer = 0;
    PCHAR c;

    while (*Ascii) {

        if (Integer == 0 &&
            (*Ascii == 'x' || *Ascii == 'X')) {

            DoHex = TRUE;

        } else {
        
            if (DoHex) {

                *Ascii = (CHAR) toupper( *Ascii );

                if (*Ascii < '0' ||
                    (*Ascii > '9' &&
                     (*Ascii < 'A' || *Ascii > 'F'))) {

                    break;
                }

                Integer *= 16;
                Integer += ( *Ascii - ( *Ascii > '9' ? ('A' - 10) : '0' ));
                
            } else {

                if (*Ascii < '0' || *Ascii > '9') {

                    break;
                }

                Integer *= 10;
                Integer += (*Ascii - '0');
            }
        }

        Ascii++;
    }

    return Integer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\toplock.c ===
#include "brian.h"

#define OPLOCK_VERBOSES_DEFAULT         TRUE

typedef struct _OPLOCK {

    ULONG FileHandleIndex;
    BOOLEAN VerboseResults;
    USHORT BufferIndex;

} OPLOCK, *POPLOCK;

//
//  Local procedures
//

VOID
RequestOplockI (
    IN POPLOCK Oplock
    );

VOID
RequestBatchOplock (
    IN POPLOCK Oplock
    );

VOID
RequestFilterOplock (
    IN POPLOCK Oplock
    );

VOID
RequestOplockII (
    IN POPLOCK Oplock
    );

VOID
AcknowledgeOplockBreak (
    IN POPLOCK Oplock
    );

VOID
AcknowledgeOplockBreakNo2 (
    IN POPLOCK Oplock
    );

VOID
AcknowledgeOpBatchBreakPending (
    IN POPLOCK Oplock
    );

VOID
OplockBreakNotify (
    IN POPLOCK Oplock
    );


VOID
InputOplock(
    IN PCHAR ParamBuffer
    )

{
    ULONG  Operation;
    BOOLEAN VerboseResults;
    BOOLEAN DisplayParms;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    POPLOCK Oplock;
    ULONG FileHandleIndex;

    VerboseResults = OPLOCK_VERBOSES_DEFAULT;
    DisplayParms = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;
    FileHandleIndex = 0;

    Operation = (ULONG) -1;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            Operation = FSCTL_REQUEST_OPLOCK_LEVEL_1;
                            ParamReceived = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            Operation = FSCTL_REQUEST_OPLOCK_LEVEL_2;
                            ParamReceived = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            Operation = FSCTL_REQUEST_BATCH_OPLOCK;
                            ParamReceived = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            Operation = FSCTL_REQUEST_FILTER_OPLOCK;
                            ParamReceived = TRUE;
                            break;

                        case 'e' :
                        case 'E' :
                            Operation = FSCTL_OPLOCK_BREAK_ACKNOWLEDGE;
                            ParamReceived = TRUE;
                            break;

                        case 'f' :
                        case 'F' :
                            Operation = FSCTL_OPBATCH_ACK_CLOSE_PENDING;
                            ParamReceived = TRUE;
                            break;

                        case 'g' :
                        case 'G' :
                            Operation = FSCTL_OPLOCK_BREAK_NOTIFY;
                            ParamReceived = TRUE;
                            break;

                        case 'h' :
                        case 'H' :
                            Operation = FSCTL_OPLOCK_BREAK_ACK_NO_2;
                            ParamReceived = TRUE;
                            break;

                        case 'z' :
                        case 'Z' :
                            ParamReceived = FALSE;
                            Operation = (ULONG) -1;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;

                        }

                        if (!SwitchBool) {

                            break;

                        }


                        ParamBuffer++;

                    }

                    break;

                //
                //  Update the file handle index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileHandleIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: oplk -i<digits> -o<char> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   Open file handle" );
        printf( "\n           -o<chars>    Oplock operation" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //
    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;
        USHORT BufferIndex;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( OPLOCK );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputOplock:  Unable to allocate async structure" );

        } else {

            Oplock = (POPLOCK) Buffers[BufferIndex].Buffer;

            Oplock->FileHandleIndex = FileHandleIndex;
            Oplock->VerboseResults = VerboseResults;
            Oplock->BufferIndex = BufferIndex;

            if (DisplayParms) {

                printf( "\nOplock Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileHandleIndex );
                printf( "\n   Oplock operation        -> %ld", Operation );
                printf( "\n   Structure buffer index  -> %d", BufferIndex );
                printf( "\n\n" );
            }

            switch (Operation) {

            case FSCTL_REQUEST_OPLOCK_LEVEL_1 :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestOplockI,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_REQUEST_OPLOCK_LEVEL_2 :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestOplockII,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_REQUEST_BATCH_OPLOCK :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestBatchOplock,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_REQUEST_FILTER_OPLOCK :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestFilterOplock,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             AcknowledgeOplockBreak,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPBATCH_ACK_CLOSE_PENDING :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             AcknowledgeOpBatchBreakPending,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPLOCK_BREAK_NOTIFY :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             OplockBreakNotify,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            case FSCTL_OPLOCK_BREAK_ACK_NO_2 :

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             AcknowledgeOplockBreakNo2,
                                             Oplock,
                                             0,
                                             &ThreadId );

                break;

            default :

                printf( "\nInputOplock:  Invalid operation\n" );
                return;
            }


            if (ThreadHandle == 0) {

                printf( "\nInputOplock:  Spawning thread fails -> %d\n", GetLastError() );
            }
        }
    }
    return;
}

VOID
RequestOplockI (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestOplockI:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_OPLOCK_LEVEL_1,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestOplockI:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestOplockI:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestOplockI:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestOplockI:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestOplockI:  Thread not terminated\n" );
    }
}

VOID
RequestBatchOplock (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestBatchOplock:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_BATCH_OPLOCK,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestBatchOplock:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestBatchOplock:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestBatchOplock:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestBatchOplock:  IoSb.Information  -> %08lx", IoSb.Information );
            }

            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestBatchOplock:  Thread not terminated\n" );
    }
}

VOID
RequestFilterOplock (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestFilterOplock:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_FILTER_OPLOCK,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestFilterOplock:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestFilterOplock:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nRequestFilterOplock:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nRequestFilterOplock:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestFilterOplock:  Thread not terminated\n" );
    }
}

VOID
RequestOplockII (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nRequestOplockII:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_REQUEST_OPLOCK_LEVEL_2,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nRequestOplockII:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestOplockII:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nRequestOplockII:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nRequestOplockII:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestOplockII:  Thread not terminated\n" );
    }
}


VOID
AcknowledgeOplockBreak (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nAcknowledgeOplockBreak:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPLOCK_BREAK_ACKNOWLEDGE,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nAcknowledgeOplockBreak:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tAcknowledgeOplockBreak:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nAcknowledgeOplockBreak:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nAcknowledgeOplockBreak:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nAcknowledgeOplockBreak:  Thread not terminated\n" );
    }
}

VOID
AcknowledgeOplockBreakNo2 (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nAcknowledgeOplockBreakNo2:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPLOCK_BREAK_ACK_NO_2,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nAcknowledgeOplockBreakNo2:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tAcknowledgeOplockBreakNo2:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nAcknowledgeOplockBreakNo2:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nAcknowledgeOplockBreakNo2:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nAcknowledgeOplockBreak:  Thread not terminated\n" );
    }
}

VOID
AcknowledgeOpBatchBreakPending (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nAcknowledgeOpBatchBreakPending:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPBATCH_ACK_CLOSE_PENDING,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nAcknowledgeOpBatchBreakPending:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tAcknowledgeOpBatchBreakPending:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nAcknowledgeOpBatchBreakPending:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nAcknowledgeOpBatchBreakPending:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nAcknowledgeOpBatchBreakPending:  Thread not terminated\n" );
    }
}


VOID
OplockBreakNotify (
    IN POPLOCK Oplock
    )
{
    HANDLE Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    Status = NtCreateEvent( &Event,
                            SYNCHRONIZE
                            | GENERIC_READ
                            | GENERIC_WRITE,
                            NULL,
                            NotificationEvent,
                            FALSE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nOplockBreakNotify:  NtCreateEvent failed -> %08lx\n", Status );

    } else {

        Status = NtFsControlFile( Handles[Oplock->FileHandleIndex].Handle,
                                  Event,
                                  NULL,
                                  NULL,
                                  &IoSb,
                                  FSCTL_OPLOCK_BREAK_NOTIFY,
                                  NULL,
                                  0,
                                  NULL,
                                  0 );

        if (Oplock->VerboseResults) {

            bprint  "\nOplockBreakNotify:  Status            -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( Event,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tOplockBreakNotify:  Wait for event failed -> %08lx", Status );
                }

                if (NT_SUCCESS( Status )) {

                    bprint  "\nOplockBreakNotify:  IoSb.Status       -> %08lx", IoSb.Status );
                    bprint  "\nOplockBreakNotify:  IoSb.Information  -> %08lx", IoSb.Information );
                }
            }
            bprint "\n" );
        }
    }

    DeallocateBuffer( Oplock->BufferIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nOplockBreakNotify:  Thread not terminated\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tnotify.c ===
#include "brian.h"

typedef struct _ASYNC_NOTIFY {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_NOTIFY, *PASYNC_NOTIFY;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define LENGTH_DEFAULT              0
#define FILTER_DEFAULT              FILE_NOTIFY_CHANGE_FILE_NAME
#define WATCH_TREE_DEFAULT          FALSE
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     FALSE

VOID
FullNotify(
    IN OUT PASYNC_NOTIFY AsyncNotify
    );


VOID
InputNotifyChange(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = LENGTH_DEFAULT;
    CompletionFilter = FILTER_DEFAULT;
    WatchTree = WATCH_TREE_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Check whether we should watch the tree.
                //

                case 'w' :
                case 'W' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        WatchTree = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        WatchTree = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the completion filter.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_FILE_NAME;
                            break;

                        case 'b' :
                        case 'B' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_DIR_NAME;
                            break;

                        case 'c' :
                        case 'C' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
                            break;

                        case 'd' :
                        case 'D' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_SIZE;
                            break;

                        case 'e' :
                        case 'E' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;
                            break;

                        case 'f' :
                        case 'F' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;
                            break;

                        case 'g' :
                        case 'G' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_CREATION;
                            break;

                        case 'h' :
                        case 'H' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_EA;
                            break;

                        case 'i' :
                        case 'I' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_SECURITY;
                            break;

                        case 'j' :
                        case 'J' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_STREAM_NAME;
                            break;

                        case 'k' :
                        case 'K' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_STREAM_SIZE;
                            break;

                        case 'l' :
                        case 'L' :

                            CompletionFilter |= FILE_NOTIFY_CHANGE_STREAM_WRITE;
                            break;

                        case 'y' :
                        case 'Y' :

                            CompletionFilter = FILE_NOTIFY_VALID_MASK;
                            break;

                        case 'z' :
                        case 'Z' :

                            CompletionFilter = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: ncd [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -b<digits>   Buffer to store results" );
        printf( "\n           -l<digits>   Stated length of buffer" );
        printf( "\n           -f<chars>    Completion filter" );
        printf( "\n           -w[t|f]      Watch directory tree" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our notify routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_NOTIFY AsyncNotify;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_NOTIFY );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputRead:  Unable to allocate async structure" );

        } else {

            AsyncNotify = (PASYNC_NOTIFY) Buffers[AsyncIndex].Buffer;

            AsyncNotify->FileIndex = (USHORT) FileIndex;
            AsyncNotify->UseEvent = UseEvent;
            AsyncNotify->ApcRoutine = ApcRoutine;
            AsyncNotify->ApcContext = ApcContext;


            AsyncNotify->BufferIndex = BufferIndex;
            AsyncNotify->BufferIndexPtr = BufferIndexPtr
                                          ? &AsyncNotify->BufferIndex
                                          : BufferIndexPtr;
            AsyncNotify->Length = Length;

            AsyncNotify->CompletionFilter = CompletionFilter;
            AsyncNotify->WatchTree = WatchTree;

            AsyncNotify->DisplayParms = DisplayParms;
            AsyncNotify->VerboseResults = VerboseResults;
            AsyncNotify->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullNotify,
                                             AsyncNotify,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputNotify:  Spawning thread fails -> %d\n", GetLastError() );
                    return;
                }
            } else {

                FullNotify( AsyncNotify );
            }
        }
    }
    return;
}


VOID
FullNotify(
    IN OUT PASYNC_NOTIFY AsyncNotify
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindNotifyBuffer = FALSE;

    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncNotify->DisplayParms) {

        bprint  "\nNotify Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncNotify->FileIndex );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncNotify->BufferIndexPtr );
        if (AsyncNotify->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncNotify->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncNotify->Length );

        bprint  "\n   CompletionFilter        -> %08lx", AsyncNotify->CompletionFilter );
        bprint  "\n   WatchTree               -> %d", AsyncNotify->WatchTree );
        bprint  "\n   UseEvent                -> %d", AsyncNotify->UseEvent );
        bprint  "\n   ApcRoutine              -> %08lx", AsyncNotify->ApcRoutine );
        bprint  "\n   ApcContext              -> %08lx", AsyncNotify->ApcContext );

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncNotify->BufferIndexPtr == NULL ) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullNotify:  Unable to allocate a notify buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullNotify:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );

            UnwindNotifyBuffer = TRUE;

            AsyncNotify->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncNotify->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullNotify:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncNotify->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullNotify:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncNotify->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullNotify:  Unable to allocate an event" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the read routine.
        //

        Status = NtNotifyChangeDirectoryFile( Handles[AsyncNotify->FileIndex].Handle,
                                              ThisEvent,
                                              AsyncNotify->ApcRoutine,
                                              AsyncNotify->ApcContext,
                                              &Iosb,
                                              Buffers[ThisBufferIndex].Buffer,
                                              AsyncNotify->Length,
                                              AsyncNotify->CompletionFilter,
                                              AsyncNotify->WatchTree );

        if (AsyncNotify->VerboseResults) {

            bprint  "\nNotifyChangeDir:  Status            -> %08lx\n", Status );

            if (AsyncNotify->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tNotifyChangeDir:  Wait for event failed -> %08lx\n", Status );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nNotifyChangeDir:  Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\nNotifyChangeDir:  Iosb.Status       -> %08lx", Iosb.Status );
            }

            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        DeallocateBuffer( AsyncNotify->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tpause.c ===
#include "brian.h"

#define DEFAULT_SECONDS     3


VOID
InputPause (
    IN PCHAR ParamBuffer
    )
{
    TIME Time;

    Time.HighTime = -1;
    Time.LowTime = DEFAULT_SECONDS * -10000000;

    NtDelayExecution( FALSE, &Time );

    return;

    UNREFERENCED_PARAMETER( ParamBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tqdir.c ===
#include "brian.h"

typedef struct _ASYNC_QDIR {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    PUNICODE_STRING FileNamePtr;
    UNICODE_STRING FileName;
    BOOLEAN SingleEntry;
    BOOLEAN Restart;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;
    USHORT NameIndex;

} ASYNC_QDIR, *PASYNC_QDIR;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define QDIR_LENGTH_DEFAULT         100
#define FILE_INFO_CLASS_DEFAULT     FileBothDirectoryInformation
#define SINGLE_ENTRY_DEFAULT        FALSE
#define RESTART_DEFAULT             FALSE
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

#define DISPLAY_INDEX_DEFAULT     0

VOID
FullQDir(
    IN OUT PASYNC_QDIR AsyncQDir
    );


VOID
InputQDir (
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    PUNICODE_STRING FileNamePtr;
    UNICODE_STRING FileName;
    USHORT FileNameIndex;
    BOOLEAN SingleEntry;
    BOOLEAN Restart;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;
    PUCHAR FileNamePChar;
    BOOLEAN NameIndexAllocated;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = QDIR_LENGTH_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    FileNamePtr = NULL;
    FileNameIndex = 0;
    SingleEntry = SINGLE_ENTRY_DEFAULT;
    Restart = RESTART_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    AsyncIndex = 0;

    NameIndexAllocated = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    {
        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        RegionSize = 256;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        if (!NT_SUCCESS( Status )) {

            printf("\nInputQdir:  Can't allocate name index buffer" );
            return;
        }

        NameIndexAllocated = TRUE;
        FileNameIndex = (USHORT) TempIndex;
        FileName.Length = 256;
        FileName.MaximumLength = 256;
        FileName.Buffer = (PWSTR) Buffers[FileNameIndex].Buffer;
    }

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Check whether we want only a single entry.
                //

                case 's' :
                case 'S' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        SingleEntry = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        SingleEntry = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Check whether we want to restart the scan.
                //

                case 'r' :
                case 'R' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        Restart = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        Restart = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Get the filename.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    FileNamePChar = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    //
                    //  If the name length is 0, then ignore this entry.
                    //
                    if (DummyCount) {

                        ANSI_STRING AnsiString;

                        AnsiString.Length = (USHORT) DummyCount;
                        AnsiString.Buffer = FileNamePChar;

                        RtlAnsiStringToUnicodeString( &FileName,
                                                      &AnsiString,
                                                      FALSE );

                        FileNamePtr = (PUNICODE_STRING) &FileName;
                    }

                    break;


                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileNamesInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileDirectoryInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFullDirectoryInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileIdFullDirectoryInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileBothDirectoryInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileIdBothDirectoryInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FileObjectIdInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileQuotaInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileReparsePointInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }
    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qd [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Buffer length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -f<chars>    Search expression" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n             a            FileNamesInformation" );
        printf( "\n             b            FileDirectoryInformation" );
        printf( "\n             c            FileFullDirectoryInformation" );
        printf( "\n             d            FileIdFullDirectoryInformation" );
        printf( "\n             e            FileBothDirectoryInformation" );
        printf( "\n             f            FileIdBothObjectIdInformation" );
        printf( "\n             g            FileObjectIdInformation" );
        printf( "\n             h            FileQuotaInformation" );
        printf( "\n             i            FileReparsePointInformation" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -r[t|f]      Restart the search" );
        printf( "\n           -s[t|f]      Return single entry" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_QDIR AsyncQDir;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_QDIR );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputQDir:  Unable to allocate async structure" );

        } else {

            AsyncQDir = (PASYNC_QDIR) Buffers[AsyncIndex].Buffer;

            AsyncQDir->FileIndex = (USHORT) FileIndex;
            AsyncQDir->UseEvent = UseEvent;
            AsyncQDir->ApcRoutine = ApcRoutine;
            AsyncQDir->ApcContext = ApcContext;

            AsyncQDir->BufferIndex = BufferIndex;
            AsyncQDir->BufferIndexPtr = BufferIndexPtr
                                        ? &AsyncQDir->BufferIndex
                                        : BufferIndexPtr;
            AsyncQDir->Length = Length;
            AsyncQDir->FileInfoClass = FileInfoClass;
            AsyncQDir->FileName = FileName;
            AsyncQDir->FileNamePtr = FileNamePtr
                                     ? &AsyncQDir->FileName
                                     : NULL;
            AsyncQDir->SingleEntry = SingleEntry;
            AsyncQDir->Restart = Restart;
            AsyncQDir->DisplayParms = DisplayParms;
            AsyncQDir->VerboseResults = VerboseResults;
            AsyncQDir->AsyncIndex = AsyncIndex;
            AsyncQDir->NameIndex = FileNameIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullQDir,
                                             AsyncQDir,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputQDir:  Spawning thread fails -> %d\n", GetLastError() );

                    if (AsyncQDir->FileNamePtr) {

                        DeallocateBuffer( FileNameIndex );
                    }

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullQDir( AsyncQDir );
            }
        }
    }

    return;
}


VOID
FullQDir(
    IN OUT PASYNC_QDIR AsyncQDir
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindQDirBuffer = FALSE;
    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncQDir->DisplayParms) {

        bprint  "\n" );
        bprint  "    QDir Parameters\n" );
        bprint  "       File Handle Index       -> %d\n", AsyncQDir->FileIndex );
        bprint  "       UseEvent                -> %d\n", AsyncQDir->UseEvent );
        bprint  "       ApcRoutine              -> %08lx\n", AsyncQDir->ApcRoutine );
        bprint  "       ApcContext              -> %08lx\n", AsyncQDir->ApcContext );
        bprint  "       Buffer Index Ptr        -> %08lx\n", AsyncQDir->BufferIndexPtr );
        if (AsyncQDir->BufferIndexPtr) {

            bprint  "       BufferIndex value       -> %04x\n", AsyncQDir->BufferIndex );
        }

        bprint  "       Length                  -> %08lx\n", AsyncQDir->Length );

        bprint  "       FileInfoClass           -> %08lx\n", AsyncQDir->FileInfoClass );

        bprint  "       FileNamePtr             -> %08lx\n", AsyncQDir->FileNamePtr );
        if (AsyncQDir->FileNamePtr) {

            bprint  "       Filename                -> %s\n", AsyncQDir->FileName.Buffer );
        }

        bprint  "       Single Entry            -> %04x\n", AsyncQDir->SingleEntry );
        bprint  "       Restart Scan            -> %04x\n", AsyncQDir->SingleEntry );

        bprint  "\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncQDir->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n" );
                bprint  "\tFullQDir:  Unable to allocate a query buffer\n" );
                try_return( Status );
            }

            bprint  "\tFullQDir:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );
            bprint  "\n" );

            UnwindQDirBuffer = TRUE;

            AsyncQDir->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncQDir->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n" );
            bprint  "\tFullQDir:  The read buffer index is invalid\n" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncQDir->FileIndex >= MAX_HANDLES) {

            bprint  "\n" );
            bprint  "\tFullQDir:  The file index is invalid\n" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncQDir->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n" );
                bprint  "\tFullQDir:  Unable to allocate an event\n" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the read routine.
        //

        Status = NtQueryDirectoryFile( Handles[AsyncQDir->FileIndex].Handle,
                                       ThisEvent,
                                       AsyncQDir->ApcRoutine,
                                       AsyncQDir->ApcContext,
                                       &Iosb,
                                       Buffers[ThisBufferIndex].Buffer,
                                       AsyncQDir->Length,
                                       AsyncQDir->FileInfoClass,
                                       AsyncQDir->SingleEntry,
                                       AsyncQDir->FileNamePtr,
                                       AsyncQDir->Restart );

        UnwindQDirBuffer = FALSE;

        if (AsyncQDir->VerboseResults) {

            bprint  "\n" );
            bprint  "   Query Dir:  Status            -> %08lx\n", Status );

            if (AsyncQDir->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint "\n" );
                    bprint "\tQuery Dir:  Wait for event failed -> %08lx", Status );
                    bprint "\n" );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\n" );
                bprint  "            Iosb.Information  -> %08lx\n", Iosb.Information );
                bprint  "            Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindQDirBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        if (AsyncQDir->FileNamePtr) {

            DeallocateBuffer( AsyncQDir->NameIndex );
        }

        DeallocateBuffer( AsyncQDir->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}


VOID
InputDisplayQDir (
    IN PCHAR ParamBuffer
    )
{
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = DISPLAY_INDEX_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileNamesInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileDirectoryInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFullDirectoryInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileIdFullDirectoryInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileBothDirectoryInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileIdBothDirectoryInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqd [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        switch (FileInfoClass) {

            case FileNamesInformation:

                DisplayQDirNames( (USHORT) BufferIndex );
                break;

            case FileDirectoryInformation:

                DisplayQDirDirs( (USHORT) BufferIndex );
                break;

            case FileFullDirectoryInformation:

                DisplayQDirFullDirs( (USHORT) BufferIndex );
                break;

            case FileIdFullDirectoryInformation:

                DisplayQDirIdFullDirs( (USHORT) BufferIndex );
                break;

            case FileBothDirectoryInformation:

                DisplayQBothDirs( (USHORT) BufferIndex );
                break;

            case FileIdBothDirectoryInformation:

                DisplayQIdBothDirs( (USHORT) BufferIndex );
                break;
        }
    }

}



VOID
DisplayQDirNames (
    IN USHORT BufferIndex
    )
{
    PFILE_NAMES_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirNames:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nNames Information" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_NAMES_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirNames:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQDirDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_DIRECTORY_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nDirectory Information" );

        do {
            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_DIRECTORY_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\t                            " );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );
            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );
            printf( "\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQDirFullDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_FULL_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirFullDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nFull Directory Information" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_FULL_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );

            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirFullDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQDirIdFullDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_ID_FULL_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQDirIDFullDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nFull Directory Information with ID" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_ID_FULL_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );
            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );
            printf( "\n\tFile ID          -> " );
            PrintLargeInteger( &FileInfo->FileId );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQDirIdFullDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQBothDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_BOTH_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQBothDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nBoth Directory Information" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_BOTH_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );

            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            printf( "\n\tShrt Name Length -> %04x", FileInfo->ShortNameLength );

            UnicodeString.MaximumLength = (USHORT) FileInfo->ShortNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->ShortNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->ShortName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\tShort Name       -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );


            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQBothDirs:  AbnormalTermination\n" );
        }
    }

    return;
}


VOID
DisplayQIdBothDirs (
    IN USHORT BufferIndex
    )
{
    PFILE_ID_BOTH_DIR_INFORMATION FileInfo;
    PUCHAR BufferStart;
    ULONG Offset;
    ULONG AvailLength;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQIdBothDirs:  Invalid buffer\n" );
        return;
    }

    BufferStart = Buffers[BufferIndex].Buffer;
    AvailLength = Buffers[BufferIndex].Length;
    Offset = 0;

    try {

        printf( "\n\nBoth Directory Information with ID" );

        do {

            ANSI_STRING AnsiString;
            UNICODE_STRING UnicodeString;

            FileInfo = (PFILE_ID_BOTH_DIR_INFORMATION) ((PUCHAR) BufferStart + Offset);

            UnicodeString.MaximumLength = (USHORT) FileInfo->FileNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\n\tFile Name        -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );

            printf( "\n\tNext Offset      -> %08lx", FileInfo->NextEntryOffset );
            printf( "\tCreation Time    -> " );
            PrintTime( &FileInfo->CreationTime );
            printf( "\n\tFile Index       -> %08lx", FileInfo->FileIndex );
            printf( "\tLast Access Time -> " );
            PrintTime( &FileInfo->LastAccessTime );
            printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
            printf( "\tLast Write Time  -> " );
            PrintTime( &FileInfo->LastWriteTime );
            printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );
            printf( "\tChange Time      -> " );
            PrintTime( &FileInfo->ChangeTime );

            printf( "\n\tEnd Of File      -> " );
            PrintLargeInteger( &FileInfo->EndOfFile );
            printf( "\n\tAllocation Size  -> " );
            PrintLargeInteger( &FileInfo->AllocationSize );
            printf( "\n\tFile ID          -> " );
            PrintLargeInteger( &FileInfo->FileId );

            printf( "\n\tFile Name Length -> %08lx", FileInfo->FileNameLength );

            printf( "\n\tShrt Name Length -> %04x", FileInfo->ShortNameLength );

            UnicodeString.MaximumLength = (USHORT) FileInfo->ShortNameLength + 2;
            UnicodeString.Length = (USHORT) FileInfo->ShortNameLength;
            UnicodeString.Buffer = (PWSTR) &FileInfo->ShortName;

            RtlUnicodeStringToAnsiString( &AnsiString,
                                          &UnicodeString,
                                          TRUE );

            printf( "\n\tShort Name       -> %s", AnsiString.Buffer );
            RtlFreeAnsiString( &AnsiString );


            Offset += FileInfo->NextEntryOffset;

        } while (FileInfo->NextEntryOffset > 0
                 && Offset < AvailLength);

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQIdBothDirs:  AbnormalTermination\n" );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\thandle.c ===
#include "brian.h"

VOID
DisplayHandle (
    IN USHORT Index
    );


VOID
InitHandles (
    )
{
    NtCreateEvent( &HandleEvent, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                   NULL, SynchronizationEvent, TRUE );

    RtlZeroMemory( Handles, sizeof( Handles ));
}


VOID
UninitHandles (
    )
{
    USHORT Index;

    //
    //  Close any handles.
    //

    for (Index = 0; Index < MAX_HANDLES; Index++) {

        if (Handles[Index].Used) {

            NtClose( Handles[Index].Handle );
        }
    }
}


NTSTATUS
ObtainIndex (
    OUT PUSHORT NewIndex
    )
{
    NTSTATUS Status;
    USHORT Index;

    //
    //  Wait for the handle event
    //

    if ((Status = NtWaitForSingleObject( HandleEvent,
                                         FALSE,
                                         NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Find an available index.  Return STATUS_INSUFFICIENT_RESOURCES
    //  if not found.
    //

    for (Index = 0; Index < MAX_HANDLES; Index++) {

        if (!Handles[Index].Used) {

            break;
        }
    }

    if (Index >= MAX_HANDLES) {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    //
    //  Otherwise reserve this handle index.
    //

    } else {

        Handles[Index].Used = TRUE;
        *NewIndex = Index;

        Status = STATUS_SUCCESS;
    }

    NtSetEvent( HandleEvent, NULL );

    return Status;
}


NTSTATUS
FreeIndex (
    IN USHORT Index
    )

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  Return immediately if beyond the end of the valid handles.
    //

    if (Index >= MAX_HANDLES) {

        return Status;
    }

    //
    //  Grab the event for the handles.
    //

    if ((Status = NtWaitForSingleObject( HandleEvent, FALSE, NULL )) != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Mark the index as unused and close the file object if present.
    //

    if (Handles[Index].Handle) {

        Status = NtClose( Handles[Index].Handle );
    }

    if (Handles[Index].Used) {

        Handles[Index].Used = FALSE;
    }

    NtSetEvent( HandleEvent, NULL );

    return Status;
}


VOID
InputDisplayHandle (
    IN PCHAR ParamBuffer
    )
{
    ULONG Index;
    BOOLEAN LastInput;
    BOOLEAN ParmSpecified;

    Index = 0;

    ParmSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check buffer index.
                //
                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Index = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParmSpecified) {

        printf( "\n   Usage: di -i<digits> \n" );
        printf( "\n           -i<digits>   Handle index" );
        printf( "\n\n" );

    //
    //  Else call our copy buffer routine.
    //
    } else {

        DisplayHandle( (USHORT) Index );
    }

    return;
}


VOID
DisplayHandle (
    IN USHORT Index
    )

{
    printf( "\n" );
    printf( "\nIndex -> %04x,  Handle -> %p, Used -> %04x",
            Index,
            Handles[Index].Handle,
            Handles[Index].Used );
    printf( "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tqfile.c ===
#include "brian.h"

typedef struct _ASYNC_QFILE {

    USHORT FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_QFILE, *PASYNC_QFILE;

#define QFILE_LENGTH_DEFAULT        100
#define FILE_INFO_CLASS_DEFAULT     FileAllInformation
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

#define DISPLAY_INDEX_DEFAULT       0

VOID
FullQFile(
    IN OUT PASYNC_QFILE AsyncQFile
    );

VOID
DisplayQFileBasicInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileStandardInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileInternalInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileEaInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAccessInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileNameInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFilePositionInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileModeInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAlignmentInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAllInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileStreamInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileAlternateNameInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayQFileNetworkQueryInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayBasicInformation (
    IN PFILE_BASIC_INFORMATION FileInfo
    );

VOID
DisplayStandardInformation (
    IN PFILE_STANDARD_INFORMATION FileInfo
    );

VOID
DisplayInternalInformation (
    IN PFILE_INTERNAL_INFORMATION FileInfo
    );

VOID
DisplayEaInformation (
    IN PFILE_EA_INFORMATION FileInfo
    );

VOID
DisplayAccessInformation (
    IN PFILE_ACCESS_INFORMATION FileInfo
    );

VOID
DisplayNameInformation (
    IN PFILE_NAME_INFORMATION FileInfo
    );

VOID
DisplayPositionInformation (
    IN PFILE_POSITION_INFORMATION FileInfo
    );

VOID
DisplayModeInformation (
    IN PFILE_MODE_INFORMATION FileInfo
    );

VOID
DisplayAlignmentInformation (
    IN PFILE_ALIGNMENT_INFORMATION FileInfo
    );

VOID
DisplayStreamInformation (
    IN PFILE_STREAM_INFORMATION FileInfo
    );

VOID
DisplayNetworkOpenInformation (
    IN PFILE_NETWORK_OPEN_INFORMATION FileInfo
    );


VOID
InputQFile (
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = QFILE_LENGTH_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the information class.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileBasicInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileStandardInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileInternalInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileEaInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileAccessInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileNameInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FilePositionInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileModeInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileAlignmentInformation;
                            break;

                        case 'j' :
                        case 'J' :

                            FileInfoClass = FileAllInformation;
                            break;

                        case 'k' :
                        case 'K' :

                            FileInfoClass = FileStreamInformation;
                            break;

                        case 'l' :
                        case 'L' :

                            FileInfoClass = FileAlternateNameInformation;
                            break;

                        case 'm' :
                        case 'M' :

                            FileInfoClass = FileNetworkOpenInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qf [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Buffer length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_QFILE AsyncQFile;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_QFILE );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputQFile:  Unable to allocate async structure" );

        } else {

            AsyncQFile = (PASYNC_QFILE) Buffers[AsyncIndex].Buffer;

            AsyncQFile->FileIndex = (USHORT) FileIndex;

            AsyncQFile->BufferIndex = BufferIndex;
            AsyncQFile->BufferIndexPtr = BufferIndexPtr
                                        ? &AsyncQFile->BufferIndex
                                        : BufferIndexPtr;
            AsyncQFile->Length = Length;
            AsyncQFile->FileInfoClass = FileInfoClass;
            AsyncQFile->DisplayParms = DisplayParms;
            AsyncQFile->VerboseResults = VerboseResults;
            AsyncQFile->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullQFile,
                                             AsyncQFile,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputQFile:  Spawning thread fails -> %d\n", GetLastError() );

                    DeallocateBuffer( AsyncIndex );

                    return;
                }
            } else {

                FullQFile( AsyncQFile );
            }
        }
    }

    return;
}


VOID
FullQFile(
    IN OUT PASYNC_QFILE AsyncQFile
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    USHORT ThisBufferIndex;

    BOOLEAN UnwindQFileBuffer = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncQFile->DisplayParms) {

        bprint  "\nQFile Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncQFile->FileIndex );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncQFile->BufferIndexPtr );
        if (AsyncQFile->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncQFile->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncQFile->Length );

        bprint  "\n   FileInfoClass           -> %08lx", AsyncQFile->FileInfoClass );

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncQFile->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullQFile:  Unable to allocate a query buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullQFile:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );

            UnwindQFileBuffer = TRUE;

            AsyncQFile->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncQFile->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullQFile:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncQFile->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullQFile:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Call the query file routine.
        //

        Status = NtQueryInformationFile( Handles[AsyncQFile->FileIndex].Handle,
                                         &Iosb,
                                         Buffers[ThisBufferIndex].Buffer,
                                         AsyncQFile->Length,
                                         AsyncQFile->FileInfoClass );

        UnwindQFileBuffer = FALSE;

        if (AsyncQFile->VerboseResults) {

            bprint  "\nQuery File:  Status            -> %08lx", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "\n             Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n             Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindQFileBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        DeallocateBuffer( AsyncQFile->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}


VOID
InputDisplayQFile (
    IN PCHAR ParamBuffer
    )
{
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = DISPLAY_INDEX_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileBasicInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileStandardInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileInternalInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileEaInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FileAccessInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileNameInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FilePositionInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileModeInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileAlignmentInformation;
                            break;

                        case 'j' :
                        case 'J' :

                            FileInfoClass = FileAllInformation;
                            break;

                        case 'k' :
                        case 'K' :

                            FileInfoClass = FileStreamInformation;
                            break;

                        case 'l' :
                        case 'L' :

                            FileInfoClass = FileAlternateNameInformation;
                            break;

                        case 'm' :
                        case 'M' :

                            FileInfoClass = FileNetworkOpenInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqf [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        switch (FileInfoClass) {

            case FileBasicInformation:

                DisplayQFileBasicInformation( (USHORT) BufferIndex );
                break;

            case FileStandardInformation:

                DisplayQFileStandardInformation( (USHORT) BufferIndex );
                break;

            case FileInternalInformation:

                DisplayQFileInternalInformation( (USHORT) BufferIndex );
                break;

            case FileEaInformation:

                DisplayQFileEaInformation( (USHORT) BufferIndex );
                break;

            case FileAccessInformation:

                DisplayQFileAccessInformation( (USHORT) BufferIndex );
                break;

            case FileNameInformation:

                DisplayQFileNameInformation( (USHORT) BufferIndex );
                break;

            case FilePositionInformation:

                DisplayQFilePositionInformation( (USHORT) BufferIndex );
                break;

            case FileModeInformation:

                DisplayQFileModeInformation( (USHORT) BufferIndex );
                break;

            case FileAlignmentInformation:

                DisplayQFileAlignmentInformation( (USHORT) BufferIndex );
                break;

            case FileAllInformation:

                DisplayQFileAllInformation( (USHORT) BufferIndex );
                break;

            case FileStreamInformation:

                DisplayQFileStreamInformation( (USHORT) BufferIndex );
                break;

            case FileAlternateNameInformation:

                DisplayQFileAlternateNameInformation( (USHORT) BufferIndex );
                break;

            case FileNetworkOpenInformation:

                DisplayQFileNetworkQueryInformation( (USHORT) BufferIndex );
                break;
        }
    }

}

VOID
DisplayQFileBasicInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_BASIC_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileBasicInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_BASIC_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nBasic File Information\n" );

        DisplayBasicInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileBasicInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileStandardInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_STANDARD_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileStandardInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_STANDARD_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nStandard File Information\n" );

        DisplayStandardInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileStandardInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileInternalInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_INTERNAL_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileInternalInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_INTERNAL_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nInternal File Information\n" );

        DisplayInternalInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileInternalInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileEaInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_EA_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileEaInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_EA_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nEa File Information\n" );

        DisplayEaInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileEaInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAccessInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_ACCESS_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAccessInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_ACCESS_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAccess File Information\n" );

        DisplayAccessInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileAccessInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileNameInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_NAME_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileNameInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_NAME_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nName File Information\n" );

        DisplayNameInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileNameInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFilePositionInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_POSITION_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFilePositionInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_POSITION_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nPosition File Information\n" );

        DisplayPositionInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFilePositionInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileModeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_MODE_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileModeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_MODE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nMode File Information\n" );

        DisplayModeInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileModeInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAlignmentInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_ALIGNMENT_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAlignmentInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_ALIGNMENT_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAlignment File Information\n" );

        DisplayAlignmentInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileAlignmentInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAllInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_ALL_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAllInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_ALL_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAll File Information\n" );

        DisplayNameInformation( &FileInfo->NameInformation );
        DisplayBasicInformation( &FileInfo->BasicInformation );
        DisplayStandardInformation( &FileInfo->StandardInformation );
        DisplayInternalInformation( &FileInfo->InternalInformation );
        DisplayEaInformation( &FileInfo->EaInformation );
        DisplayAccessInformation( &FileInfo->AccessInformation );
        DisplayPositionInformation( &FileInfo->PositionInformation );
        DisplayModeInformation( &FileInfo->ModeInformation );
        DisplayAlignmentInformation( &FileInfo->AlignmentInformation );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileBasicInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileStreamInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_STREAM_INFORMATION FileInfo;
    ULONG NextOffset;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileStreamInformation:  Invalid buffer\n" );
        return;
    }

    try {

        NextOffset = 0;
        FileInfo = (PFILE_STREAM_INFORMATION) Buffers[BufferIndex].Buffer;


        printf( "\n\nStream File Information\n" );

        do {

            FileInfo = (PFILE_STREAM_INFORMATION) ((PUCHAR) FileInfo + NextOffset);

            DisplayStreamInformation( FileInfo );

            NextOffset = FileInfo->NextEntryOffset;

        } while ( NextOffset );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileStreamInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileAlternateNameInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_NAME_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileAlternateNameInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_NAME_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nAlternate Name File Information\n" );

        DisplayNameInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileAlternateNameInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayQFileNetworkQueryInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_NETWORK_OPEN_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayQFileNetworkQueryInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_NETWORK_OPEN_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nNetwork Open File Information\n" );

        DisplayNetworkOpenInformation( FileInfo );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayQFileNetworkOpenInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayBasicInformation (
    IN PFILE_BASIC_INFORMATION FileInfo
    )
{
    printf( "\n\tCreation Time    -> " );
    PrintTime( &FileInfo->CreationTime );
    printf( "\n\tLast Access Time -> " );
    PrintTime( &FileInfo->LastAccessTime );
    printf( "\n\tLast Write Time  -> " );
    PrintTime( &FileInfo->LastWriteTime );
    printf( "\n\tChange Time      -> " );
    PrintTime( &FileInfo->ChangeTime );
    printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );

    return;
}

VOID
DisplayStandardInformation (
    IN PFILE_STANDARD_INFORMATION FileInfo
    )
{
    printf( "\n\tAllocation Size  -> " );
    PrintLargeInteger( &FileInfo->AllocationSize );
    printf( "\n\tEnd Of File      -> " );
    PrintLargeInteger( &FileInfo->EndOfFile );
    printf( "\n\tNumber of Links  -> %08lx", FileInfo->NumberOfLinks );
    printf( "\n\tDelete Pending   -> %04x", FileInfo->DeletePending );
    printf( "\n\tDirectory        -> %d", FileInfo->Directory );

    return;
}

VOID
DisplayInternalInformation (
    IN PFILE_INTERNAL_INFORMATION FileInfo
    )
{
    printf( "\n\tFile Index.LowPart     -> %08lx", FileInfo->IndexNumber.LowPart );
    printf( "\n\tFile Index.HighPart    -> %08lx", FileInfo->IndexNumber.HighPart );

    printf( "\n\n\tFile Index.LowPart     -> %ld", FileInfo->IndexNumber.LowPart );
    printf( "\n\tFile Index.HighPart    -> %ld", FileInfo->IndexNumber.HighPart );

    return;
}

VOID
DisplayEaInformation (
    IN PFILE_EA_INFORMATION FileInfo
    )
{
    printf( "\n\tEa Size          -> %08lx", FileInfo->EaSize );

    return;
}

VOID
DisplayAccessInformation (
    IN PFILE_ACCESS_INFORMATION FileInfo
    )
{
    printf( "\n\tAccess Flags     -> %08lx", FileInfo->AccessFlags );

    return;
}

VOID
DisplayNameInformation (
    IN PFILE_NAME_INFORMATION FileInfo
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    UnicodeString.MaximumLength =
    UnicodeString.Length = (USHORT) FileInfo->FileNameLength;
    UnicodeString.Buffer = (PWSTR) &FileInfo->FileName;

    UnicodeString.MaximumLength += 2;

    RtlUnicodeStringToAnsiString( &AnsiString,
                                  &UnicodeString,
                                  TRUE );

    printf( "\n\tFile Name        -> %s", AnsiString.Buffer );
    RtlFreeAnsiString( &AnsiString );

    return;
}

VOID
DisplayPositionInformation (
    IN PFILE_POSITION_INFORMATION FileInfo
    )
{
    printf( "\n\tFile Position    -> " );
    PrintLargeInteger( &FileInfo->CurrentByteOffset );

    return;
}

VOID
DisplayModeInformation (
    IN PFILE_MODE_INFORMATION FileInfo
    )
{
    printf( "\n\tFile Mode        -> %08lx", FileInfo->Mode );

    return;
}

VOID
DisplayAlignmentInformation (
    IN PFILE_ALIGNMENT_INFORMATION FileInfo
    )
{
    printf( "\n\tAlignment        -> %08lx", FileInfo->AlignmentRequirement );

    return;
}

VOID
DisplayStreamInformation (
    IN PFILE_STREAM_INFORMATION FileInfo
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    printf( "\n\tStreamSize           -> " );
    PrintLargeInteger( &FileInfo->StreamSize );
    printf( "\n\tStreamAllocationSize -> " );
    PrintLargeInteger( &FileInfo->StreamAllocationSize );
    printf( "\n\tStreamNameLength     -> %08lx", FileInfo->StreamNameLength );

    UnicodeString.MaximumLength = (USHORT) FileInfo->StreamNameLength + 2;
    UnicodeString.Length = (USHORT) FileInfo->StreamNameLength;
    UnicodeString.Buffer = (PWSTR) &FileInfo->StreamName;

    RtlUnicodeStringToAnsiString( &AnsiString,
                                  &UnicodeString,
                                  TRUE );

    printf( "\n\tStream Name          -> %s", AnsiString.Buffer );
    RtlFreeAnsiString( &AnsiString );
}

VOID
DisplayNetworkOpenInformation (
    IN PFILE_NETWORK_OPEN_INFORMATION FileInfo
    )
{
    printf( "\n\tCreation Time    -> " );
    PrintTime( &FileInfo->CreationTime );
    printf( "\n\tLast Access Time -> " );
    PrintTime( &FileInfo->LastAccessTime );
    printf( "\n\tLast Write Time  -> " );
    PrintTime( &FileInfo->LastWriteTime );
    printf( "\n\tChange Time      -> " );
    PrintTime( &FileInfo->ChangeTime );
    printf( "\n\tAllocation Size  -> " );
    PrintLargeInteger( &FileInfo->AllocationSize );
    printf( "\n\tEnd Of File      -> " );
    PrintLargeInteger( &FileInfo->EndOfFile );
    printf( "\n\tFile Attributes  -> %08lx", FileInfo->FileAttributes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\topen.c ===
#include "brian.h"

typedef struct _ASYNC_OPEN {

    ACCESS_MASK DesiredAccess;
    PLARGE_INTEGER AllocationSizePtr;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
    PVOID EaBuffer;
    ULONG EaLength;
    STRING ObjectName;
    PUSHORT RootDirIndexPtr;
    USHORT RootDirIndex;
    ULONG Attributes;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    BOOLEAN DisplayParameters;
    BOOLEAN VerboseResults;
    BOOLEAN AnsiName;
    USHORT AsyncIndex;
    USHORT NameIndex;

} ASYNC_OPEN, *PASYNC_OPEN;

#define DESIRED_ACCESS_DEFAULT      (SYNCHRONIZE | GENERIC_READ)
#define ALLOCATION_SIZE_DEFAULT     0L
#define FILE_ATTRIBUTES_DEFAULT     FILE_ATTRIBUTE_NORMAL
#define SHARE_ACCESS_DEFAULT        FILE_SHARE_READ
#define CREATE_DISP_DEFAULT         FILE_OPEN
#define CREATE_OPTIONS_DEFAULT      FILE_SYNCHRONOUS_IO_ALERT
#define EA_LENGTH_DEFAULT           0L
#define ATTRIBUTES_DEFAULT          OBJ_CASE_INSENSITIVE
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     TRUE
#define ANSI_NAME_DEFAULT           FALSE
#define EXACT_NAME_DEFAULT          FALSE

VOID
FullOpen (
    IN PASYNC_OPEN AsyncOpen
    );


VOID
InputOpenFile (
    IN PCHAR ParamBuffer
    )
{
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER AllocationSize;
    PLARGE_INTEGER AllocationSizePtr;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
    PVOID EaBuffer;
    USHORT BufferIndex;
    ULONG EaLength;
    STRING ObjectName;
    USHORT NameIndex;
    PUSHORT RootDirIndexPtr;
    USHORT RootDirIndex;
    ULONG Attributes;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    BOOLEAN DisplayParameters;
    BOOLEAN VerboseResults;
    BOOLEAN AnsiName;
    BOOLEAN ExactName;
    BOOLEAN FileNameFound;
    BOOLEAN LastInput;
    BOOLEAN NameIndexAllocated;
    PUCHAR FileName;
    USHORT AsyncIndex;

    //
    //  Set the defaults for the open and the return values.
    //

    DesiredAccess = DESIRED_ACCESS_DEFAULT;
    AllocationSize = RtlConvertUlongToLargeInteger( ALLOCATION_SIZE_DEFAULT );
    AllocationSizePtr = NULL;
    FileAttributes = FILE_ATTRIBUTES_DEFAULT;
    ShareAccess = SHARE_ACCESS_DEFAULT;
    CreateDisposition = CREATE_DISP_DEFAULT;
    CreateOptions = CREATE_OPTIONS_DEFAULT;
    EaBuffer = NULL;
    EaLength = EA_LENGTH_DEFAULT;
    ObjectName.MaximumLength = 256;
    ObjectName.Length = 256;
    RootDirIndexPtr = NULL;
    RootDirIndex = 0;
    Attributes = ATTRIBUTES_DEFAULT;
    SecurityDescriptor = NULL;
    SecurityQualityOfService = NULL;
    DisplayParameters = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AnsiName = ANSI_NAME_DEFAULT;
    ExactName = EXACT_NAME_DEFAULT;

    NameIndexAllocated = FALSE;
    FileNameFound = FALSE;
    LastInput = TRUE;

    {
        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        RegionSize = 1024;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        if (!NT_SUCCESS( Status )) {

            printf("InputOpenFile:  Can't allocate name index buffer\n" );
            return;
        }

        NameIndexAllocated = TRUE;
        NameIndex = (USHORT) TempIndex;
        ObjectName.Buffer = Buffers[NameIndex].Buffer;
    }

    //
    //  While there is more input, analyze the parameter and update the
    //  open flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the file attributes.
                //
                case 'a' :
                case 'A' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            FileAttributes |= FILE_ATTRIBUTE_READONLY;
                            break;

                        case 'b' :
                        case 'B' :
                            FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
                            break;

                        case 'c' :
                        case 'C' :
                            FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                            break;

                        case 'e' :
                        case 'E' :
                            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                            break;

                        case 'f' :
                        case 'F' :
                            FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                            break;

                        case 'g' :
                        case 'G' :
                            FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            break;

                        case 'h' :
                        case 'H' :
                            FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                            break;

                        case 'i' :
                        case 'I' :
                            FileAttributes |= FILE_ATTRIBUTE_TEMPORARY;
                            break;

                        case 'j' :
                        case 'J' :
                            FileAttributes |= FILE_ATTRIBUTE_SPARSE_FILE;
                            break;

                        case 'k' :
                        case 'K' :
                            FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
                            break;

                        case 'l' :
                        case 'L' :
                            FileAttributes |= FILE_ATTRIBUTE_COMPRESSED;
                            break;

                        case 'm' :
                        case 'M' :
                            FileAttributes |= FILE_ATTRIBUTE_OFFLINE;
                            break;

                        case 'n' :
                        case 'N' :
                            FileAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
                            break;

                        case 'z' :
                        case 'Z' :
                            FileAttributes = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update buffer to use.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    if (BufferIndex <= MAX_BUFFERS) {

                        EaBuffer = Buffers[BufferIndex].Buffer;
                        EaLength = Buffers[BufferIndex].Length;

                    }

                    break;

                //
                //  Update buffer length to pass.
                //
                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    EaLength = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the desired access.
                //
                case 'd' :
                case 'D' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            DesiredAccess |= FILE_READ_DATA;
                            break;

                        case 'b' :
                        case 'B' :

                            DesiredAccess |= FILE_WRITE_DATA;
                            break;

                        case 'c' :
                        case 'C' :

                            DesiredAccess |= FILE_APPEND_DATA;
                            break;

                        case 'd' :
                        case 'D' :

                            DesiredAccess |= FILE_READ_EA;
                            break;

                        case 'e' :
                        case 'E' :

                            DesiredAccess |= FILE_WRITE_EA;
                            break;

                        case 'f' :
                        case 'F' :

                            DesiredAccess |= FILE_EXECUTE;
                            break;

                        case 'g' :
                        case 'G' :

                            DesiredAccess |= FILE_DELETE_CHILD;
                            break;

                        case 'h' :
                        case 'H' :

                            DesiredAccess |= FILE_READ_ATTRIBUTES;
                            break;

                        case 'i' :
                        case 'I' :

                            DesiredAccess |= FILE_WRITE_ATTRIBUTES;
                            break;

                        case 'j' :
                        case 'J' :

                            DesiredAccess |= FILE_ALL_ACCESS;
                            break;

                        case 'k' :
                        case 'K' :

                            DesiredAccess |= SYNCHRONIZE;
                            break;

                        case 'l' :
                        case 'L' :

                            DesiredAccess |= DELETE;
                            break;

                        case 'm' :
                        case 'M' :

                            DesiredAccess |= READ_CONTROL;
                            break;

                        case 'n' :
                        case 'N' :

                            DesiredAccess |= WRITE_DAC;
                            break;

                        case 'o' :
                        case 'O' :

                            DesiredAccess |= WRITE_OWNER;
                            break;

                        case 'p' :
                        case 'P' :

                            DesiredAccess |= GENERIC_READ;
                            break;

                        case 'q' :
                        case 'Q' :

                            DesiredAccess |= GENERIC_WRITE;
                            break;

                        case 'r' :
                        case 'R' :

                            DesiredAccess |= GENERIC_EXECUTE;
                            break;

                        case 's' :
                        case 'S' :

                            DesiredAccess |= GENERIC_ALL;
                            break;

                        case 't' :

                            DesiredAccess |= MAXIMUM_ALLOWED;
                            break;

                        case 'z' :
                        case 'Z' :

                            DesiredAccess = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Get the filename.
                //
                case 'f' :
                case 'F' :

                    //
                    //  Remember the buffer offset and get the filename.
                    //
                    ParamBuffer++;
                    FileName = ParamBuffer;
                    DummyCount = 0;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    //
                    //  If the name length is 0, then ignore this entry.
                    //
                    if (DummyCount) {

                        ULONG ObjectNameIncrement = 0;

                        //
                        //  If the first character is a backslash then
                        //  we add the full 'dosdevices' prefix.
                        //

                        FileNameFound = TRUE;

                        if (!ExactName) {

                            if (*FileName == '\\') {

                                ObjectNameIncrement = sizeof( "DosDevices" );

                                RtlMoveMemory( ObjectName.Buffer,
                                               "\\DosDevices",
                                               sizeof( "\\DosDevices" ));
                            }
                        }

                        ObjectName.Length = (SHORT) (DummyCount + ObjectNameIncrement);

                        RtlMoveMemory( &ObjectName.Buffer[ObjectNameIncrement],
                                       FileName,
                                       DummyCount );

                    } else {

                        ULONG ObjectNameIncrement = 0;

                        FileNameFound = TRUE;

                        ObjectName.Length = (SHORT) (DummyCount + ObjectNameIncrement);
                    }

                    break;

                //
                //  Update the file Id.
                //

                case 'i' :
                case 'I' :

                    {
                        PLARGE_INTEGER FileId;
                        FileId = (PLARGE_INTEGER) ObjectName.Buffer;

                        //
                        //  Move to the next character, as long as there
                        //  are no white spaces continue analyzing letters.
                        //  On the first bad letter, skip to the next
                        //  parameter.
                        //

                        ParamBuffer++;

                        if (*ParamBuffer == '\0') {

                                break;
                        }

                        switch (*ParamBuffer) {

                        case 'l':
                        case 'L':

                            FileId->LowPart = AsciiToInteger( ++ParamBuffer );
                            ObjectName.Length = sizeof( LARGE_INTEGER );

                            break;

                        case 'h':
                        case 'H':

                            FileId->HighPart = AsciiToInteger( ++ParamBuffer );
                            ObjectName.Length = sizeof( LARGE_INTEGER );

                            break;
                        }

                        FileNameFound = TRUE;

                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        break;
                    }

                //
                //  Update the share access field.
                //
                case 'h' :
                case 'H' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            ShareAccess |= FILE_SHARE_READ;
                            break;

                        case 'b' :
                        case 'B' :

                            ShareAccess |= FILE_SHARE_WRITE;
                            break;

                        case 'c' :
                        case 'C' :

                            ShareAccess |= FILE_SHARE_DELETE;
                            break;

                        case 'z' :
                        case 'Z' :

                            ShareAccess = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;

                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the create options.
                //
                case 'n' :
                case 'N' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch( *ParamBuffer ) {

                        case 'a' :
                        case 'A' :

                            CreateOptions |= FILE_DIRECTORY_FILE;
                            break;

                        case 'b' :
                        case 'B' :

                            CreateOptions |= FILE_WRITE_THROUGH;
                            break;

                        case 'c' :
                        case 'C' :

                            CreateOptions |= FILE_SEQUENTIAL_ONLY;
                            break;

                        case 'd' :
                        case 'D' :

                            CreateOptions |= FILE_NO_INTERMEDIATE_BUFFERING;
                            break;

                        case 'e' :
                        case 'E' :

                            CreateOptions |= FILE_SYNCHRONOUS_IO_ALERT;
                            break;

                        case 'f' :
                        case 'F' :

                            CreateOptions |= FILE_SYNCHRONOUS_IO_NONALERT;
                            break;

                        case 'g' :
                        case 'G' :

                            CreateOptions |= FILE_NON_DIRECTORY_FILE;
                            break;

                        case 'h' :
                        case 'H' :

                            CreateOptions |= FILE_CREATE_TREE_CONNECTION;
                            break;

                        case 'i' :
                        case 'I' :

                            CreateOptions |= FILE_COMPLETE_IF_OPLOCKED;
                            break;

                        case 'j' :
                        case 'J' :

                            CreateOptions |= FILE_OPEN_BY_FILE_ID;
                            break;

                        case 'k' :
                        case 'K' :

                            CreateOptions |= FILE_NO_EA_KNOWLEDGE;
                            break;

                        case 'l' :
                        case 'L' :

                            CreateOptions |= FILE_DELETE_ON_CLOSE;
                            break;

                        case 'm' :
                        case 'M' :

                            CreateOptions |= FILE_RESERVE_OPFILTER;
                            break;

                        case 'n' :
                        case 'N' :

                            CreateOptions |= FILE_OPEN_REPARSE_POINT;
                            break;

                        case 'o' :
                        case 'O' :

                            CreateOptions |= FILE_NO_COMPRESSION;
                            break;

                        case 'p' :
                        case 'P' :

                            CreateOptions |= FILE_OPEN_FOR_BACKUP_INTENT;
                            break;

                        case 'q' :
                        case 'Q' :

                            CreateOptions |= FILE_OPEN_NO_RECALL;
                            break;

                        case 'z' :
                        case 'Z' :

                            CreateOptions = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            Attributes |= OBJ_INHERIT;
                            break;

                        case 'b' :
                        case 'B' :

                            Attributes |= OBJ_PERMANENT;
                            break;

                        case 'c' :
                        case 'C' :

                            Attributes |= OBJ_EXCLUSIVE;
                            break;

                        case 'd' :
                        case 'D' :

                            Attributes |= OBJ_CASE_INSENSITIVE;
                            break;

                        case 'e' :
                        case 'E' :

                            Attributes |= OBJ_OPENIF;
                            break;

                        case 'z' :
                        case 'Z' :

                            Attributes = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the create disposition.
                //
                case 'p' :
                case 'P' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            CreateDisposition |= FILE_SUPERSEDE;
                            break;

                        case 'b' :
                        case 'B' :

                            CreateDisposition |= FILE_OPEN;
                            break;

                        case 'c' :
                        case 'C' :

                            CreateDisposition |= FILE_CREATE;
                            break;

                        case 'd' :
                        case 'D' :

                            CreateDisposition |= FILE_OPEN_IF;
                            break;

                        case 'e' :
                        case 'E' :

                            CreateDisposition |= FILE_OVERWRITE;
                            break;

                        case 'f' :
                        case 'F' :

                            CreateDisposition |= FILE_OVERWRITE_IF;
                            break;

                        case 'z' :
                        case 'Z' :

                            CreateDisposition = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if( !SwitchBool ) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Get a root directory handle.
                //
                case 'r' :
                case 'R' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    RootDirIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    if( RootDirIndex <= MAX_HANDLES ) {

                        RootDirIndexPtr = &RootDirIndex;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the allocation size.
                //
                case 's' :
                case 'S' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    AllocationSize.QuadPart = AsciiToLargeInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    AllocationSizePtr = &AllocationSize;

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                //
                //  Check for using name exactly as given.
                //

                case 'x' :
                case 'X' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        ExactName = TRUE;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        ExactName = FALSE;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                //
                //  Check for unicode or ansi file names.
                //

                case 'u' :
                case 'U' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        AnsiName = FALSE;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        AnsiName = TRUE;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParameters = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If the file name wasn't found, then display the syntax message
    //  and set verbose to FALSE.
    //

    if( !FileNameFound ) {

        printf( "\n    Usage:  op [options]* -f<filename> | -i[l|h]<fileId> [options]*\n" );
        printf( "          Options:\n" );
        printf( "                    -f<filename>       Name of file to open\n" );
        printf( "                    -il<digits>        Low 32 bits of file id\n" );
        printf( "                    -ih<digits>        High 32 bits of file id\n" );
        printf( "                    -x[t|f]            Use name exactly (don't add \\DosDevices)\n" );
        printf( "                    -u[t|f]            Use unicode names \n" );
        printf( "                    -v[t|f]            Print out results\n" );
        printf( "                    -z                 Get additional input\n" );
        printf( "                    -y                 Display create parameters\n" );
        printf( "                    -b<digits>         Buffer index for Ea's\n" );
        printf( "                    -l<digits>         Stated length of Ea buffer\n" );
        printf( "                    -d<chars>          Modify Desired Access value\n" );
        printf( "                    -r<digits>         Relative directory handle index\n" );
        printf( "                    -o<chars>          Object Attributes\n" );
        printf( "                    -s<digits>         Allocation size\n" );
        printf( "                    -a<chars>          File Attribute values\n" );
        printf( "                    -h<chars>          Share Access values\n" );
        printf( "                    -p<chars>          Create Disposition values\n" );
        printf( "                    -n<chars>          Create Options values\n" );
        printf( "\n\n" );

        DeallocateBuffer( NameIndex );

    //
    //  Else return the status of opening the file.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_OPEN AsyncOpen;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_OPEN );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\tInputOpen:  Unable to allocate async structure\n" );
            DeallocateBuffer( NameIndex );

        } else {

            AsyncOpen = (PASYNC_OPEN) Buffers[AsyncIndex].Buffer;

            AsyncOpen->DesiredAccess = DesiredAccess;
            AsyncOpen->AllocationSize = AllocationSize;
            AsyncOpen->AllocationSizePtr = AllocationSizePtr
                                           ? &AsyncOpen->AllocationSize
                                           : NULL;
            AsyncOpen->FileAttributes = FileAttributes;
            AsyncOpen->ShareAccess = ShareAccess;
            AsyncOpen->CreateDisposition = CreateDisposition;
            AsyncOpen->CreateOptions = CreateOptions;
            AsyncOpen->EaBuffer = EaBuffer;
            AsyncOpen->EaLength = EaLength;
            AsyncOpen->ObjectName = ObjectName;
            AsyncOpen->RootDirIndex = RootDirIndex;
            AsyncOpen->RootDirIndexPtr = RootDirIndexPtr
                                         ? &AsyncOpen->RootDirIndex
                                         : NULL;
            AsyncOpen->Attributes = Attributes;
            AsyncOpen->SecurityDescriptor = SecurityDescriptor;
            AsyncOpen->SecurityQualityOfService = SecurityQualityOfService;
            AsyncOpen->DisplayParameters = DisplayParameters;
            AsyncOpen->VerboseResults = VerboseResults;
            AsyncOpen->AnsiName = AnsiName;
            AsyncOpen->AsyncIndex = AsyncIndex;
            AsyncOpen->NameIndex = NameIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullOpen,
                                             AsyncOpen,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputOpen:  Spawning thread fails -> %d\n", GetLastError() );
                    DeallocateBuffer( NameIndex );
                    DeallocateBuffer( AsyncIndex );
                    return;
                }

            } else {

                FullOpen( AsyncOpen );
            }
        }
    }

    return;
}


VOID
FullOpen (
    IN PASYNC_OPEN AsyncOpen
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeName;
    PUNICODE_STRING NameString;

    USHORT ThisIndex;

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = 0;

    //
    //  Check that the relative index is a valid value.
    //

    if (AsyncOpen->RootDirIndexPtr != NULL) {

        if (AsyncOpen->RootDirIndex >= MAX_HANDLES) {

            bprint  "\n" );
            bprint  "Relative index is invalid\n" );
            DeallocateBuffer( AsyncOpen->AsyncIndex );
            DeallocateBuffer( AsyncOpen->NameIndex );
            return;
        }

        ObjectAttributes.RootDirectory = Handles[AsyncOpen->RootDirIndex].Handle;

    } else {

        ObjectAttributes.RootDirectory = 0;
    }

    //
    //  Find a free index.
    //

    if (ObtainIndex( &ThisIndex ) != STATUS_SUCCESS) {

        bprint  "\n" );
        bprint  "Unable to get a new handle index \n" );
        return;
    }

    if (AsyncOpen->AnsiName
        || FlagOn( AsyncOpen->CreateOptions, FILE_OPEN_BY_FILE_ID )) {

        NameString = (PUNICODE_STRING) &AsyncOpen->ObjectName;

    } else {

        RtlAnsiStringToUnicodeString( &UnicodeName,
                                      &AsyncOpen->ObjectName,
                                      TRUE );

        NameString = &UnicodeName;
    }

    ObjectAttributes.Length = sizeof( OBJECT_ATTRIBUTES );
    ObjectAttributes.ObjectName = NameString;
    ObjectAttributes.SecurityDescriptor = AsyncOpen->SecurityDescriptor;
    ObjectAttributes.SecurityQualityOfService = AsyncOpen->SecurityQualityOfService;
    ObjectAttributes.Attributes = AsyncOpen->Attributes;

    if (AsyncOpen->DisplayParameters) {

        bprint  "\n" );
        bprint  "  CallOpenFile Parameters\n" );
        bprint  "\n" );
        bprint  "      DesiredAccess              -> %08lx\n", AsyncOpen->DesiredAccess );

        if (FlagOn( AsyncOpen->CreateOptions, FILE_OPEN_BY_FILE_ID )) {

            PLARGE_INTEGER FileId;

            FileId = (PLARGE_INTEGER) AsyncOpen->ObjectName.Buffer;

            bprint  "      FileId.LowPart             -> %08lx\n", FileId->LowPart );
            bprint  "      FileId.HighPart            -> %08lx\n", FileId->HighPart );

        } else {

            bprint  "      Filename                   -> %s\n", AsyncOpen->ObjectName.Buffer );
            bprint  "      FileNameLen                -> %ld\n", AsyncOpen->ObjectName.Length );
        }

        bprint  "      RootDirectoryIndexPtr      -> %ld\n", AsyncOpen->RootDirIndexPtr );
        if (AsyncOpen->RootDirIndexPtr != NULL) {

            bprint  "      RootDirectoryIndex         -> %ld\n", AsyncOpen->RootDirIndex );

        }
        bprint  "      SecurityDescriptor         -> %lx\n", AsyncOpen->SecurityDescriptor );
        bprint  "      SecurityQualityOfService   -> %lx\n", AsyncOpen->SecurityQualityOfService );
        bprint  "      Attributes                 -> %08lx\n", AsyncOpen->Attributes );
        bprint  "      AllocationSizePtr          -> %lx\n", AsyncOpen->AllocationSizePtr );

        if (AsyncOpen->AllocationSizePtr) {
            bprint  "      AllocationSize.LowPart     -> %lx\n", AsyncOpen->AllocationSize.LowPart );
            bprint  "      AllocationSize.HighPart    -> %lx\n", AsyncOpen->AllocationSize.HighPart );

        }
        bprint  "      FileAttributes             -> %08lx\n", AsyncOpen->FileAttributes );
        bprint  "      ShareAccess                -> %08lx\n", AsyncOpen->ShareAccess );
        bprint  "      CreateDisposition          -> %08lx\n", AsyncOpen->CreateDisposition );
        bprint  "      CreateOptions              -> %08lx\n", AsyncOpen->CreateOptions );
        bprint  "      EaBuffer                   -> %lx\n", AsyncOpen->EaBuffer );
        bprint  "      EaLength                   -> %ld\n", AsyncOpen->EaLength );
        bprint  "      AnsiName                   -> %04x\n", AsyncOpen->AnsiName );
        bprint  "\n" );
    }

    Status = NtCreateFile( &Handles[ThisIndex].Handle,
                           AsyncOpen->DesiredAccess,
                           &ObjectAttributes,
                           &Iosb,
                           AsyncOpen->AllocationSizePtr,
                           AsyncOpen->FileAttributes,
                           AsyncOpen->ShareAccess,
                           AsyncOpen->CreateDisposition,
                           AsyncOpen->CreateOptions,
                           AsyncOpen->EaBuffer,
                           AsyncOpen->EaLength );

    if (AsyncOpen->VerboseResults) {

        bprint  "\n" );
        bprint  "  OpenFile:                   Status   -> %08lx\n", Status );
        bprint  "\n" );
        bprint  "                      File Handle      -> 0x%lx\n", Handles[ThisIndex].Handle );
        bprint  "                      File HandleIndex -> %ld\n", ThisIndex );

        if (NT_SUCCESS( Status )) {

            bprint  "                      Io.Status        -> %08lx\n", Iosb.Status );
            bprint  "                      Io.Info          -> %08lx\n", Iosb.Information );
        }
        bprint "\n" );
    }

    if (!NT_SUCCESS( Status )) {

        FreeIndex( ThisIndex );
    }

    DeallocateBuffer( AsyncOpen->NameIndex );
    if (!AsyncOpen->AnsiName) {

        RtlFreeUnicodeString( &UnicodeName );
    }
    DeallocateBuffer( AsyncOpen->AsyncIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tsetfile.c ===
#include "brian.h"

typedef struct _ASYNC_SETFILE {

    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;
    USHORT CreateTimeIndex;
    PUSHORT CreateTimePtr;
    USHORT LastAccessIndex;
    PUSHORT LastAccessPtr;
    USHORT LastWriteIndex;
    PUSHORT LastWritePtr;
    USHORT ChangeTimeIndex;
    PUSHORT ChangeTimePtr;
    ULONG FileAttributes;
    PULONG FileAttributesPtr;

    ULONG RenameLength;
    PULONG RenameLengthPtr;
    BOOLEAN ReplaceIfExists;
    USHORT RootDirectoryIndex;
    PUSHORT RootDirectoryPtr;
    USHORT RenameIndex;
    BOOLEAN RenameBufferAllocated;

    ULONG NameLength;
    PULONG NameLengthPtr;
    USHORT NameIndex;
    BOOLEAN NameBufferAllocated;

    ULONG ShortNameLength;
    PULONG ShortNameLengthPtr;
    USHORT ShortNameIndex;
    BOOLEAN ShortNameBufferAllocated;

    BOOLEAN DeleteFile;

    LARGE_INTEGER NewOffset;

    ULONG FileMode;

    LARGE_INTEGER NewAllocation;

    LARGE_INTEGER NewEof;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_SETFILE, *PASYNC_SETFILE;

#define SETFILE_LENGTH_DEFAULT      100
#define FILE_INFO_CLASS_DEFAULT     FileBasicInformation
#define REPLACE_IF_EXISTS_DEFAULT   TRUE
#define DELETE_FILE_DEFAULT         TRUE
#define FILE_MODE_DEFAULT           FILE_SYNCHRONOUS_IO_NONALERT
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     TRUE

VOID
FullSetFile(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetBasicInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetRenameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetShortNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetDispositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetPositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetModeInformation (
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetAllocationInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );

VOID
SetEofInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    );


VOID
InputSetFile (
    IN PCHAR ParamBuffer
    )
{
    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;
    USHORT CreateTimeIndex;
    PUSHORT CreateTimePtr;
    USHORT LastAccessIndex;
    PUSHORT LastAccessPtr;
    USHORT LastWriteIndex;
    PUSHORT LastWritePtr;
    USHORT ChangeTimeIndex;
    PUSHORT ChangeTimePtr;
    ULONG FileAttributes;
    PULONG FileAttributesPtr;

    ANSI_STRING AnsiRenameString;
    ULONG RenameLength;
    PULONG RenameLengthPtr;
    BOOLEAN ReplaceIfExists;
    USHORT RootDirectoryIndex;
    PUSHORT RootDirectoryPtr;
    USHORT RenameIndex;
    BOOLEAN RenameBufferAllocated;
    PUCHAR FileRenamePtr;

    ANSI_STRING AnsiNameString;
    ULONG NameLength;
    PULONG NameLengthPtr;
    USHORT NameIndex = 0;
    BOOLEAN NameBufferAllocated;
    PUCHAR FileNamePtr;

    ULONG ShortNameLength;
    PULONG ShortNameLengthPtr;
    USHORT ShortNameIndex = 0;
    BOOLEAN ShortNameBufferAllocated;
    PUCHAR FileShortNamePtr;

    BOOLEAN DeleteFile;

    LARGE_INTEGER NewOffset;

    ULONG FileMode;

    LARGE_INTEGER NewAllocation;

    LARGE_INTEGER NewEof;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    BufferLengthPtr = NULL;
    CreateTimePtr = NULL;
    LastAccessPtr = NULL;
    LastWritePtr = NULL;
    ChangeTimePtr = NULL;
    FileAttributes = 0;
    FileAttributesPtr = NULL;

    RenameLengthPtr = NULL;
    ReplaceIfExists = REPLACE_IF_EXISTS_DEFAULT;
    RootDirectoryPtr = NULL;
    RenameBufferAllocated = FALSE;
    FileRenamePtr = NULL;

    NameLengthPtr = NULL;
    NameBufferAllocated = FALSE;
    FileNamePtr = NULL;

    ShortNameLengthPtr = NULL;
    ShortNameBufferAllocated = FALSE;
    FileShortNamePtr = NULL;

    DeleteFile = DELETE_FILE_DEFAULT;

    NewOffset = RtlConvertUlongToLargeInteger( 0L );

    FileMode = FILE_MODE_DEFAULT;

    NewAllocation = NewOffset;

    NewEof = NewOffset;

    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {


                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'b':
                    case 'B':

                            BufferLength = AsciiToInteger( ++ParamBuffer );
                            BufferLengthPtr = &BufferLength;

                            break;

                    case 'r':
                    case 'R':

                            RenameLength = AsciiToInteger( ++ParamBuffer );
                            RenameLengthPtr = &RenameLength;

                            break;

                    case 'n':
                    case 'N':

                            NameLength = AsciiToInteger( ++ParamBuffer );
                            NameLengthPtr = &NameLength;

                            break;

                    case 's':
                    case 'S':

                            ShortNameLength = AsciiToInteger( ++ParamBuffer );
                            ShortNameLengthPtr = &ShortNameLength;

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the allocation size.
                //

                case 'n' :
                case 'N' :

                    NewAllocation.QuadPart = AsciiToLargeInteger( ++ParamBuffer );
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                //
                //  Update the End of file size.
                //

                case 'e' :
                case 'E' :

                    NewEof.QuadPart = AsciiToLargeInteger( ++ParamBuffer );
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the filenames.
                //

                case 'f' :
                case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    PUCHAR TempPtr;

                    case 'r':
                    case 'R':

                        //
                        //  Remember the buffer offset and get the filename.
                        //

                        ParamBuffer++;
                        TempPtr = ParamBuffer;
                        DummyCount = 0;
                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        //
                        //  If the name length is 0, then ignore this entry.
                        //

                        if (DummyCount) {

                            AnsiRenameString.Length = (USHORT) DummyCount;
                            AnsiRenameString.Buffer = TempPtr;

                            FileRenamePtr = TempPtr;
                            RenameLength = RtlAnsiStringToUnicodeSize( &AnsiRenameString) - sizeof( WCHAR );
                            RenameLengthPtr = &RenameLength;
                        }

                        break;

                    case 'n':
                    case 'N':

                        //
                        //  Remember the buffer offset and get the filename.
                        //

                        ParamBuffer++;
                        TempPtr = ParamBuffer;
                        DummyCount = 0;
                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        //
                        //  If the name length is 0, then ignore this entry.
                        //

                        if (DummyCount) {

                            AnsiNameString.Length = (USHORT) DummyCount;
                            AnsiNameString.Buffer = TempPtr;

                            FileNamePtr = TempPtr;
                            NameLength = RtlAnsiStringToUnicodeSize( &AnsiNameString) - sizeof( WCHAR );
                            NameLengthPtr = &NameLength;
                        }

                        break;

                    case 's' :
                    case 'S' :

                        //
                        //  Remember the buffer offset and get the filename.
                        //

                        ParamBuffer++;
                        TempPtr = ParamBuffer;
                        DummyCount = 0;
                        ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                        //
                        //  If the name length is 0, then ignore this entry.
                        //

                        if (DummyCount) {

                            AnsiNameString.Length = (USHORT) DummyCount;
                            AnsiNameString.Buffer = TempPtr;

                            FileShortNamePtr = TempPtr;
                            ShortNameLength = RtlAnsiStringToUnicodeSize( &AnsiNameString) - sizeof( WCHAR );
                            ShortNameLengthPtr = &ShortNameLength;
                        }

                        break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the root directory index.
                //

                case 'r' :
                case 'R' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    RootDirectoryIndex = (USHORT) AsciiToInteger( ParamBuffer );
                    RootDirectoryPtr = &RootDirectoryIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the information class.
                //

                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileBasicInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileRenameInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileLinkInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileDispositionInformation;
                            break;

                        case 'e' :
                        case 'E' :

                            FileInfoClass = FilePositionInformation;
                            break;

                        case 'f' :
                        case 'F' :

                            FileInfoClass = FileModeInformation;
                            break;

                        case 'g' :
                        case 'G' :

                            FileInfoClass = FileAllocationInformation;
                            break;

                        case 'h' :
                        case 'H' :

                            FileInfoClass = FileEndOfFileInformation;
                            break;

                        case 'i' :
                        case 'I' :

                            FileInfoClass = FileShortNameInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the file mode information
                //

                case 'm' :
                case 'M' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileMode &= FILE_WRITE_THROUGH;
                            break;

                        case 'b' :
                        case 'B' :

                            FileMode &= FILE_SEQUENTIAL_ONLY;
                            break;

                        case 'c' :
                        case 'C' :

                            FileMode &= FILE_SYNCHRONOUS_IO_ALERT;
                            break;

                        case 'd' :
                        case 'D' :

                            FileMode &= FILE_SYNCHRONOUS_IO_NONALERT;
                            break;

                        case 'z' :
                        case 'Z' :

                            FileMode = 0;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the file attributes.
                //

                case 'a' :
                case 'A' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            FileAttributes |= FILE_ATTRIBUTE_READONLY;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'b' :
                        case 'B' :
                            FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'c' :
                        case 'C' :
                            FileAttributes |= FILE_ATTRIBUTE_SYSTEM;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'e' :
                        case 'E' :
                            FileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'f' :
                        case 'F' :
                            FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'g' :
                        case 'G' :
                            FileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'h' :
                        case 'H' :

                            FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'i' :
                        case 'I' :
                            FileAttributes |= FILE_ATTRIBUTE_TEMPORARY;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'j' :
                        case 'J' :
                            FileAttributes |= FILE_ATTRIBUTE_SPARSE_FILE;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'k' :
                        case 'K' :
                            FileAttributes |= FILE_ATTRIBUTE_REPARSE_POINT;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'l' :
                        case 'L' :
                            FileAttributes |= FILE_ATTRIBUTE_COMPRESSED;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'm' :
                        case 'M' :
                            FileAttributes |= FILE_ATTRIBUTE_OFFLINE;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'n' :
                        case 'N' :
                            FileAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
                            FileAttributesPtr = &FileAttributes;
                            break;

                        case 'z' :
                        case 'Z' :

                            FileAttributes = 0;
                            FileAttributesPtr = NULL;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                //
                //  Check for time or date modification.
                //

                case 't' :
                case 'T' :

                    //
                    //  Check that there is another character.
                    //

                    ParamBuffer++;
                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'c':
                    case 'C':

                            CreateTimeIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                            CreateTimePtr = &CreateTimeIndex;

                            break;

                    case 'a':
                    case 'A':

                        LastAccessIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                        LastAccessPtr = &LastAccessIndex;

                        break;

                    case 'w':
                    case 'W':

                        LastWriteIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                        LastWritePtr = &LastWriteIndex;

                        break;

                    case 'g':
                    case 'G':

                        ChangeTimeIndex = (USHORT) AsciiToInteger( ++ParamBuffer );
                        ChangeTimePtr = &ChangeTimeIndex;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                    break;

                case 'p' :
                case 'P' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                            || *ParamBuffer == 't') {

                        ReplaceIfExists = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        ReplaceIfExists = FALSE;
                        ParamBuffer++;
                    }

                    break;

                    case 'd' :
                    case 'D' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        DeleteFile = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        DeleteFile = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Update the lower offset of the large integer.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    NewOffset.LowPart = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the upper offset of the large integer.
                //

                case 'u' :
                case 'U' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    NewOffset.HighPart = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //

                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //

                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        bprint  "\n" );
        printf( "   Usage: sf [options]* -i<index> [options]*\n" );
        printf( "       Options:\n" );
        printf( "           -i<digits>   File index\n" );
        printf( "           -lb<digits>  Buffer length\n" );
        printf( "           -c<char>     File information class\n" );
        printf( "           -tc<digits>  CreateTime buffer index\n" );
        printf( "           -ta<digits>  LastAccess buffer index\n" );
        printf( "           -tw<digits>  LastWrite buffer index\n" );
        printf( "           -tg<digits>  ChangeTime buffer index\n" );
        printf( "           -a<chars>    File attributes\n" );
        printf( "           -p[t|f]      Replace existing file on rename\n" );
        printf( "           -r<digits>   Root directory index for rename\n" );
        printf( "           -fr<name>    Name for rename\n" );
        printf( "           -fn<name>    New link name\n" );
        printf( "           -fs<name>    New short name\n" );
        printf( "           -lr<digits>  Stated length of rename\n" );
        printf( "           -ln<digits>  Stated length of new name\n" );
        printf( "           -ls<digits>  Stated length of new short name\n" );
        printf( "           -d[t|f]      Delete file\n" );
        printf( "           -o<digits>   Low word of new position\n" );
        printf( "           -u<digits>   High word of new position\n" );
        printf( "           -m<chars>    File mode information\n" );
        printf( "           -n<digits>   Quad word of new allocation size\n" );
        printf( "           -e<digits>   Quad word of new end of file\n" );
        printf( "           -v[t|f]      Verbose results\n" );
        printf( "           -y           Display parameters to query\n" );
        printf( "           -z           Additional input line\n" );
        printf( "\n" );

        //
        //  Else call our read routine.
        //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_SETFILE AsyncSetFile;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_SETFILE );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\tInputSetFile:  Unable to allocate async structure\n" );

        } else {

            //
            //  If we need a buffer for the rename, allocate it now.
            //

            if (FileRenamePtr != NULL) {

                UNICODE_STRING UnicodeString;

                RegionSize = RenameLength;

                if (RegionSize == 0) {

                    RegionSize = 0x10;
                }

                Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

                if (!NT_SUCCESS( Status )) {

                    printf( "\tInputSetFile:  Unable to allocate rename structure\n" );

                    DeallocateBuffer( AsyncIndex );
                    return;
                }

                UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
                UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
                RenameIndex = (USHORT) TempIndex;
                RenameBufferAllocated = TRUE;

                //
                //  Store the name in the buffer.
                //

                RtlAnsiStringToUnicodeString( &UnicodeString,
                                              &AnsiRenameString,
                                              FALSE );
            }

            //
            //  If we need a buffer for the new name, allocate it now.
            //

            if (FileNamePtr != NULL) {

                UNICODE_STRING UnicodeString;

                RegionSize = NameLength;

                if (RegionSize == 0) {

                    RegionSize = 0x10;
                }

                Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

                if (!NT_SUCCESS( Status )) {

                    printf( "\tInputSetFile:  Unable to allocate new name structure\n" );

                    DeallocateBuffer( AsyncIndex );

                    if (NameBufferAllocated) {

                        DeallocateBuffer( NameIndex );
                    }
                    return;
                }

                UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
                UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
                NameIndex = (USHORT) TempIndex;
                NameBufferAllocated = TRUE;

                //
                //  Store the name in the buffer.
                //

                RtlAnsiStringToUnicodeString( &UnicodeString,
                                              &AnsiNameString,
                                              FALSE );
            }

            //
            //  If we need a buffer for the new short name, allocate it now.
            //

            if (FileShortNamePtr != NULL) {

                UNICODE_STRING UnicodeString;

                RegionSize = ShortNameLength;

                if (RegionSize == 0) {

                    RegionSize = 0x10;
                }

                Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

                if (!NT_SUCCESS( Status )) {

                    printf( "\tInputSetFile:  Unable to allocate new short name structure\n" );

                    DeallocateBuffer( AsyncIndex );

                    if (ShortNameBufferAllocated) {

                        DeallocateBuffer( ShortNameIndex );
                    }
                    return;
                }

                UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
                UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
                ShortNameIndex = (USHORT) TempIndex;
                ShortNameBufferAllocated = TRUE;

                //
                //  Store the name in the buffer.
                //

                RtlAnsiStringToUnicodeString( &UnicodeString,
                                              &AnsiNameString,
                                              FALSE );
            }

            AsyncSetFile = (PASYNC_SETFILE) Buffers[AsyncIndex].Buffer;

            AsyncSetFile->FileIndex = (USHORT) FileIndex;

            AsyncSetFile->BufferLength = BufferLength;
            AsyncSetFile->BufferLengthPtr = BufferLengthPtr
                                            ? &AsyncSetFile->BufferLength
                                            : NULL;

            AsyncSetFile->FileInfoClass = FileInfoClass;

            AsyncSetFile->CreateTimeIndex = CreateTimeIndex;
            AsyncSetFile->CreateTimePtr = CreateTimePtr
                                          ? &AsyncSetFile->CreateTimeIndex
                                          : NULL;

            AsyncSetFile->LastAccessIndex = LastAccessIndex;
            AsyncSetFile->LastAccessPtr = LastAccessPtr
                                          ? &AsyncSetFile->LastAccessIndex
                                          : NULL;

            AsyncSetFile->LastWriteIndex = LastWriteIndex;
            AsyncSetFile->LastWritePtr = LastWritePtr
                                         ? &AsyncSetFile->LastWriteIndex
                                         : NULL;

            AsyncSetFile->ChangeTimeIndex = ChangeTimeIndex;
            AsyncSetFile->ChangeTimePtr = ChangeTimePtr
                                          ? &AsyncSetFile->ChangeTimeIndex
                                          : NULL;

            AsyncSetFile->FileAttributes = FileAttributes;
            AsyncSetFile->FileAttributesPtr = FileAttributesPtr
                                              ? &AsyncSetFile->FileAttributes
                                              : NULL;

            AsyncSetFile->RenameLength = RenameLength;
            AsyncSetFile->RenameLengthPtr = RenameLengthPtr
                                            ? &AsyncSetFile->RenameLength
                                            : NULL;
            AsyncSetFile->ReplaceIfExists = ReplaceIfExists;
            AsyncSetFile->RootDirectoryIndex = RootDirectoryIndex;
            AsyncSetFile->RootDirectoryPtr = RootDirectoryPtr
                                                             ? &AsyncSetFile->RootDirectoryIndex
                                                             : NULL;
            AsyncSetFile->RenameIndex = RenameIndex;
            AsyncSetFile->RenameBufferAllocated = RenameBufferAllocated;

            AsyncSetFile->NameLength = NameLength;
            AsyncSetFile->NameLengthPtr = NameLengthPtr
                                          ? &AsyncSetFile->NameLength
                                          : NULL;
            AsyncSetFile->NameIndex = NameIndex;
            AsyncSetFile->NameBufferAllocated = NameBufferAllocated;

            AsyncSetFile->ShortNameLength = ShortNameLength;
            AsyncSetFile->ShortNameLengthPtr = ShortNameLengthPtr
                                               ? &AsyncSetFile->ShortNameLength
                                               : NULL;
            AsyncSetFile->ShortNameIndex = ShortNameIndex;
            AsyncSetFile->ShortNameBufferAllocated = ShortNameBufferAllocated;

            AsyncSetFile->DeleteFile = DeleteFile;

            AsyncSetFile->NewOffset = NewOffset;

            AsyncSetFile->FileMode = FileMode;

            AsyncSetFile->NewAllocation = NewAllocation;

            AsyncSetFile->NewEof = NewEof;

            AsyncSetFile->DisplayParms = DisplayParms;
            AsyncSetFile->VerboseResults = VerboseResults;
            AsyncSetFile->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullSetFile,
                                             AsyncSetFile,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "InputSetFile:  Spawning thread fails -> %d\n", GetLastError() );

                    if (RenameBufferAllocated) {

                        DeallocateBuffer( RenameIndex );
                    }

                    if (NameBufferAllocated) {

                        DeallocateBuffer( NameIndex );
                    }

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullSetFile( AsyncSetFile );
            }
        }
    }

    return;
}



VOID
FullSetFile(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    try {

        //
        //  Case on the information type and call the appropriate routine.
        //

        switch (AsyncSetFile->FileInfoClass) {

        case FileBasicInformation:

            SetBasicInformation( AsyncSetFile );
            break;

        case FileRenameInformation:

            SetRenameInformation( AsyncSetFile );
            break;

        case FileLinkInformation:

            SetNameInformation( AsyncSetFile );
            break;

        case FileShortNameInformation:

            SetShortNameInformation( AsyncSetFile );
            break;

        case FileDispositionInformation:

            SetDispositionInformation( AsyncSetFile );
            break;

        case FilePositionInformation:

            SetPositionInformation( AsyncSetFile );
            break;

        case FileModeInformation:

            SetModeInformation( AsyncSetFile );
            break;

        case FileAllocationInformation :

            SetAllocationInformation( AsyncSetFile );
            break;

        case FileEndOfFileInformation :

            SetEofInformation( AsyncSetFile );
            break;

        default:

            bprint  "FullSetInfo:  Unrecognized information class\n" );
        }

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AsyncSetFile->RenameBufferAllocated) {

            DeallocateBuffer( AsyncSetFile->RenameIndex );
        }

        if (AsyncSetFile->NameBufferAllocated) {

            DeallocateBuffer( AsyncSetFile->NameIndex );
        }

        DeallocateBuffer( AsyncSetFile->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}


VOID
SetBasicInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_BASIC_INFORMATION BasicInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    //
    //  Check the parameters for legality.  Void the pointers if the values
    //  are illegal.
    //

    if (AsyncSetFile->CreateTimePtr != NULL
        && (AsyncSetFile->CreateTimeIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->CreateTimeIndex].Used)) {

        bprint  "CreateTimeIndex %04d is invalid\n" );
        AsyncSetFile->CreateTimePtr = NULL;
    }

    if (AsyncSetFile->LastAccessPtr != NULL
        && (AsyncSetFile->LastAccessIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->LastAccessIndex].Used)) {

        bprint  "LastAccessIndex %04d is invalid\n" );
        AsyncSetFile->LastAccessPtr = NULL;
    }

    if (AsyncSetFile->LastWritePtr != NULL
        && (AsyncSetFile->LastWriteIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->LastWriteIndex].Used)) {

        bprint  "LastWriteIndex %04d is invalid\n" );
        AsyncSetFile->LastWritePtr = NULL;
    }

    if (AsyncSetFile->ChangeTimePtr != NULL
        && (AsyncSetFile->ChangeTimeIndex >= MAX_BUFFERS
            || !Buffers[AsyncSetFile->ChangeTimeIndex].Used)) {

        bprint  "ChangeTimeIndex %04d is invalid\n" );
        AsyncSetFile->ChangeTimePtr = NULL;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileBasicInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   CreateTimePtr           -> %08lx\n", AsyncSetFile->CreateTimePtr );

        if (AsyncSetFile->CreateTimePtr) {

            bprint  "   CreateTime              -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->CreateTimeIndex].Buffer );
        }

        bprint  "   LastAccessPtr           -> %08lx\n", AsyncSetFile->LastAccessPtr );

        if (AsyncSetFile->LastAccessPtr) {

            bprint  "   LastAccess              -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->LastAccessIndex].Buffer );
        }

        bprint  "   LastWritePtr            -> %08lx\n", AsyncSetFile->LastWritePtr );

        if (AsyncSetFile->LastWritePtr) {

            bprint  "   LastWrite               -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->LastWriteIndex].Buffer );
        }

        bprint  "   ChangeTimePtr           -> %08lx\n", AsyncSetFile->ChangeTimePtr );

        if (AsyncSetFile->ChangeTimePtr) {

            bprint  "   ChangeTime              -> \n" );
            BPrintTime( (PTIME) Buffers[AsyncSetFile->ChangeTimeIndex].Buffer );
        }

        bprint  "   FileAttributesPtr       -> %08lx\n", AsyncSetFile->FileAttributesPtr );
        if (AsyncSetFile->FileAttributesPtr) {

            bprint  "   FileAttributes value    -> %08x\n", AsyncSetFile->FileAttributes );
        }

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_BASIC_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            bprint  "\tSetBasicInformation:  Unable to allocate structure\n" );
            try_return( NOTHING );
        }

        UnwindBufferIndex = TRUE;

        BasicInformation = (PFILE_BASIC_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        if (AsyncSetFile->CreateTimePtr) {

            BasicInformation->CreationTime = *((PTIME) Buffers[AsyncSetFile->CreateTimeIndex].Buffer);

        } else {

            BasicInformation->CreationTime.LowPart = 0;
            BasicInformation->CreationTime.HighPart = 0;
        }

        if (AsyncSetFile->LastAccessPtr) {

            BasicInformation->LastAccessTime = *((PTIME) Buffers[AsyncSetFile->LastAccessIndex].Buffer);

        } else {

            BasicInformation->LastAccessTime.LowPart = 0;
            BasicInformation->LastAccessTime.HighPart = 0;
        }

        if (AsyncSetFile->LastWritePtr) {

            BasicInformation->LastWriteTime = *((PTIME) Buffers[AsyncSetFile->LastWriteIndex].Buffer);

        } else {

            BasicInformation->LastWriteTime.LowPart = 0;
            BasicInformation->LastWriteTime.HighPart = 0;
        }

        if (AsyncSetFile->ChangeTimePtr) {

            BasicInformation->ChangeTime = *((PTIME) Buffers[AsyncSetFile->ChangeTimeIndex].Buffer);

        } else {

            BasicInformation->ChangeTime.LowPart = 0;
            BasicInformation->ChangeTime.HighPart = 0;
        }

        if (AsyncSetFile->FileAttributesPtr) {

            BasicInformation->FileAttributes = AsyncSetFile->FileAttributes;

        } else {

            BasicInformation->FileAttributes = 0;
        }

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       BasicInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileBasicInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetBasicInformation:        Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetRenameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_RENAME_INFORMATION RenameInformation;
    USHORT BufferIndex;

    UNICODE_STRING UniRenameName;
    ANSI_STRING AnsiRenameName;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a rename specified.
    //

    if (!AsyncSetFile->RenameBufferAllocated) {

        bprint  "Set Rename Information:  No rename was specified\n" );
        return;
    }

    UniRenameName.Buffer = (PWSTR) Buffers[AsyncSetFile->RenameIndex].Buffer;
    UniRenameName.MaximumLength =
    UniRenameName.Length = (USHORT) AsyncSetFile->RenameLength;

    UniRenameName.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiRenameName,
                                           &UniRenameName,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "SetFileRenameInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetFile->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileRenameInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Replace existing file   -> %d\n", AsyncSetFile->ReplaceIfExists );

        bprint  "   Root directory pointer  -> %d\n", AsyncSetFile->RootDirectoryPtr );
        if (AsyncSetFile->RootDirectoryPtr) {

            bprint  "   Root directory index    -> %d\n", AsyncSetFile->RootDirectoryIndex );
        }

        bprint  "   Rename length           -> %d\n", AsyncSetFile->RenameLength );

        bprint  "   New file name           -> %s\n", AnsiRenameName.Buffer );
        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_RENAME_INFORMATION ) + AsyncSetFile->RenameLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetRenameInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        RenameInformation = (PFILE_RENAME_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        RenameInformation->ReplaceIfExists = AsyncSetFile->ReplaceIfExists;
        RenameInformation->RootDirectory = AsyncSetFile->RootDirectoryPtr
                                                           ? Handles[AsyncSetFile->RootDirectoryIndex].Handle
                                                           : 0;
        RenameInformation->FileNameLength = AsyncSetFile->RenameLength;
        RtlMoveMemory( RenameInformation->FileName,
                           UniRenameName.Buffer,
                           AsyncSetFile->RenameLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       RenameInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileRenameInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetRenameInformation:       Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiRenameName );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_RENAME_INFORMATION NameInformation;
    USHORT BufferIndex;

    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiName;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a Name specified.
    //

    if (!AsyncSetFile->NameBufferAllocated) {

        bprint  "Set Name Information:  No Name was specified\n" );
        return;
    }

    UnicodeName.Buffer = (PWSTR) Buffers[AsyncSetFile->NameIndex].Buffer;
    UnicodeName.MaximumLength =
    UnicodeName.Length = (USHORT) AsyncSetFile->NameLength;

    UnicodeName.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiName,
                                           &UnicodeName,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "SetFileNameInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetFile->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileNameInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Replace existing file   -> %d\n", AsyncSetFile->ReplaceIfExists );

        bprint  "   Root directory pointer  -> %d\n", AsyncSetFile->RootDirectoryPtr );
        if (AsyncSetFile->RootDirectoryPtr) {

            bprint  "   Root directory index    -> %d\n", AsyncSetFile->RootDirectoryIndex );
        }

        bprint  "   Name length             -> %d\n", AsyncSetFile->NameLength );

        bprint  "   New file name           -> %s\n", AnsiName.Buffer );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_RENAME_INFORMATION ) + AsyncSetFile->NameLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetNameInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        NameInformation = (PFILE_RENAME_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        NameInformation->ReplaceIfExists = AsyncSetFile->ReplaceIfExists;
        NameInformation->RootDirectory = AsyncSetFile->RootDirectoryPtr
                                         ? Handles[AsyncSetFile->RootDirectoryIndex].Handle
                                         : 0;

        NameInformation->FileNameLength = AsyncSetFile->NameLength;
        RtlMoveMemory( NameInformation->FileName,
                       UnicodeName.Buffer,
                       AsyncSetFile->NameLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       NameInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileLinkInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetNameInformation:         Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiName );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetShortNameInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_NAME_INFORMATION NameInformation;
    USHORT BufferIndex;

    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiName;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a Name specified.
    //

    if (!AsyncSetFile->ShortNameBufferAllocated) {

        bprint  "Set Short Name Information:  No Name was specified\n" );
        return;
    }

    UnicodeName.Buffer = (PWSTR) Buffers[AsyncSetFile->ShortNameIndex].Buffer;
    UnicodeName.MaximumLength =
    UnicodeName.Length = (USHORT) AsyncSetFile->ShortNameLength;

    UnicodeName.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiName,
                                           &UnicodeName,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "SetShortNameInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetFile->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileShortNameInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Name length           -> %d\n", AsyncSetFile->ShortNameLength );

        bprint  "   New short name           -> %s\n", AnsiName.Buffer );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_NAME_INFORMATION ) + AsyncSetFile->ShortNameLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetShortNameInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        NameInformation = (PFILE_NAME_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        NameInformation->FileNameLength = AsyncSetFile->ShortNameLength;
        RtlMoveMemory( NameInformation->FileName,
                       UnicodeName.Buffer,
                       AsyncSetFile->ShortNameLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       NameInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileShortNameInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetShortNameInformation:    Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiName );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetDispositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_DISPOSITION_INFORMATION DispositionInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileDispositionInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   Delete file             -> %d\n", AsyncSetFile->DeleteFile );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_DISPOSITION_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetDispositionInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        DispositionInformation = (PFILE_DISPOSITION_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        DispositionInformation->DeleteFile = AsyncSetFile->DeleteFile;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       DispositionInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileDispositionInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetDispositionInformation:  Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetPositionInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_POSITION_INFORMATION PositionInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FilePositionInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   New Offset High         -> %08lx\n", AsyncSetFile->NewOffset.HighPart );
        bprint  "   New Offset Low          -> %08lx\n", AsyncSetFile->NewOffset.LowPart );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_POSITION_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetPositionInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        PositionInformation = (PFILE_POSITION_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        PositionInformation->CurrentByteOffset = AsyncSetFile->NewOffset;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       PositionInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FilePositionInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetInformationFile:         Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetModeInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_MODE_INFORMATION ModeInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileModeInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   File Mode               -> %08lx\n", AsyncSetFile->FileMode );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_MODE_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetModeInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        ModeInformation = (PFILE_MODE_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        ModeInformation->Mode = AsyncSetFile->FileMode;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       ModeInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileModeInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetModelInformation:        Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetAllocationInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_ALLOCATION_INFORMATION AllocationInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileAllocationInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   New Allocation High     -> %08lx\n", AsyncSetFile->NewAllocation.HighPart );
        bprint  "   New Allocation Low      -> %08lx\n", AsyncSetFile->NewAllocation.LowPart );

        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_ALLOCATION_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetAllocationInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        AllocationInformation = (PFILE_ALLOCATION_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        AllocationInformation->AllocationSize = AsyncSetFile->NewAllocation;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                                       &Iosb,
                                                       AllocationInformation,
                                                       AsyncSetFile->BufferLengthPtr
                                                       ? AsyncSetFile->BufferLength
                                                       : Buffers[BufferIndex].Length,
                                                       FileAllocationInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetAllocationInformation:   Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}

VOID
SetEofInformation(
    IN OUT PASYNC_SETFILE AsyncSetFile
    )
{
    NTSTATUS Status;

    PFILE_END_OF_FILE_INFORMATION EofInformation;
    USHORT BufferIndex;

    BOOLEAN UnwindBufferIndex = FALSE;

    if (AsyncSetFile->DisplayParms) {

        bprint  "\n" );
        bprint  "Set FileEofInformation Parameters\n" );
        bprint  "   File Handle Index       -> %d\n", AsyncSetFile->FileIndex );

        bprint  "   BufferLengthPtr         -> %08lx\n", AsyncSetFile->BufferLengthPtr );
        if (AsyncSetFile->BufferLengthPtr) {

            bprint  "   BufferLength value      -> %08x\n", AsyncSetFile->BufferLength );
        }

        bprint  "   New Eof High            -> %08lx\n", AsyncSetFile->NewEof.HighPart );
        bprint  "   New Eof Low             -> %08lx\n", AsyncSetFile->NewEof.LowPart );
        bprint  "\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_END_OF_FILE_INFORMATION );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\tSetEofInformation:  Unable to allocate structure\n" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        EofInformation = (PFILE_END_OF_FILE_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        EofInformation->EndOfFile = AsyncSetFile->NewEof;

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetInformationFile( Handles[AsyncSetFile->FileIndex].Handle,
                                       &Iosb,
                                       EofInformation,
                                       AsyncSetFile->BufferLengthPtr
                                       ? AsyncSetFile->BufferLength
                                       : Buffers[BufferIndex].Length,
                                       FileEndOfFileInformation );

        if (AsyncSetFile->VerboseResults) {

            bprint  "\n" );
            bprint  "  SetEOFInformation:          Status   -> %08lx\n", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "                       Io.Status       -> %08lx\n", Iosb.Status );
                bprint  "                       Io.Information  -> %08lx\n", Iosb.Information );
            }
            bprint "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\treparse.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestReparse (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputReparse(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputReparse:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputReparse:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_GET_REPARSE_POINT;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_SET_REPARSE_POINT;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_DELETE_REPARSE_POINT;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: rp -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Reparse operation" );
        printf( "\n                 -oa             Get Reparse" );
        printf( "\n                 -ob             Set Reparse" );
        printf( "\n                 -oc             Delete Reparse" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputReparse:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nSparse Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Sparse operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestReparse,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputReparse:  Spawning thread fails -> %d\n", GetLastError() );
                }

            } else {

                RequestReparse( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestReparse (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestReparse:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestReparse:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestReparse:  Wait for event failed -> %08lx", Status );
                }
            }

            if (!NT_ERROR( Status )) {

                bprint  "\nRequestReparse:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestReparse:  IoSb.Information  -> %08lx", IoSb.Information );
            }
            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestSparse:  Thread not terminated\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tsetvol.c ===
#include "brian.h"

typedef struct _ASYNC_SET_VOLUME {

    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;

    ULONG LabelLength;
    PULONG LabelLengthPtr;
    USHORT LabelIndex;
    BOOLEAN LabelBufferAllocated;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_SET_VOLUME, *PASYNC_SET_VOLUME;

#define SET_VOLUME_LENGTH_DEFAULT       100
#define FILE_INFO_CLASS_DEFAULT     FileFsLabelInformation
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

VOID
FullSetVolume(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    );

VOID
SetFsLabelInformation(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    );


VOID
InputSetVolume (
    IN PCHAR ParamBuffer
    )
{
    USHORT FileIndex;
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferLength;
    PULONG BufferLengthPtr;

    ANSI_STRING AnsiLabelString;
    ULONG LabelLength;
    PULONG LabelLengthPtr;
    USHORT LabelIndex;
    BOOLEAN LabelBufferAllocated;
    PUCHAR LabelPtr;

    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    BufferLengthPtr = NULL;

    LabelLengthPtr = NULL;
    LabelBufferAllocated = FALSE;
    LabelPtr = NULL;

    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {


                        //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                            if (*ParamBuffer == '\0') {

                                    break;
                            }

                            switch (*ParamBuffer) {

                            case 'b':
                            case 'B':

                                    BufferLength = AsciiToInteger( ++ParamBuffer );
                                    BufferLengthPtr = &BufferLength;

                                    break;

                            case 'l':
                            case 'L':

                                    LabelLength = AsciiToInteger( ++ParamBuffer );
                                    LabelLengthPtr = &LabelLength;

                                    break;
                            }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                        //
                        //  Update the label name.
                //

                        case 'f' :
                        case 'F' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                            if (*ParamBuffer == '\0') {

                                    break;
                            }

                            switch (*ParamBuffer) {

                            PUCHAR TempPtr;

                            case 'l':
                            case 'L':

                                //
                                //  Remember the buffer offset and get the filename.
                                //

                                ParamBuffer++;
                                TempPtr = ParamBuffer;
                                DummyCount = 0;
                                ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                                //
                                //  If the name length is 0, then ignore this entry.
                                //

                                if (DummyCount) {

                            AnsiLabelString.Length = (USHORT) DummyCount;
                            AnsiLabelString.Buffer = TempPtr;

                                    LabelPtr = TempPtr;
                            LabelLength = (ULONG) RtlAnsiStringToUnicodeSize( &AnsiLabelString) - sizeof( WCHAR );
                                    LabelLengthPtr = &LabelLength;
                                }

                                break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                        //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                            FileIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                            break;

                        //
                //  Update the information class.
                        //

                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileFsLabelInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                            break;

                        case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //

                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //

                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //

                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: sv [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -lb<digits>  Buffer length" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n           -fl<name>    Name for label" );
        printf( "\n           -ll<digits>  Stated length of label" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_SET_VOLUME AsyncSetVolume;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_SET_VOLUME );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputSetFile:  Unable to allocate async structure" );

        } else {

            UNICODE_STRING UnicodeString;

            //
            //  If we need a buffer for the label, allocate it now.
            //

            if (LabelPtr == NULL) {

                RtlInitAnsiString( &AnsiLabelString, "" );
                LabelPtr = AnsiLabelString.Buffer;
                LabelLength = 100;
            }

            RegionSize = LabelLength;
            Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

            if (!NT_SUCCESS( Status )) {

                printf( "\n\tInputSetVolume:  Unable to allocate label structure" );

                DeallocateBuffer( AsyncIndex );
                return;
            }

            UnicodeString.Buffer = (PWSTR) Buffers[TempIndex].Buffer;
            UnicodeString.MaximumLength = (USHORT) Buffers[TempIndex].Length;
            LabelIndex = (USHORT) TempIndex;
            LabelBufferAllocated = TRUE;

            //
            //  Store the name in the buffer.
            //

            RtlAnsiStringToUnicodeString( &UnicodeString,
                                          &AnsiLabelString,
                                          FALSE );

            AsyncSetVolume = (PASYNC_SET_VOLUME) Buffers[AsyncIndex].Buffer;

            AsyncSetVolume->FileIndex = (USHORT) FileIndex;

            AsyncSetVolume->BufferLength = BufferLength;
            AsyncSetVolume->BufferLengthPtr = BufferLengthPtr ?
                                              &AsyncSetVolume->BufferLength :
                                              NULL;

            AsyncSetVolume->FileInfoClass = FileInfoClass;

            AsyncSetVolume->LabelLength = LabelLength;
            AsyncSetVolume->LabelLengthPtr = LabelLengthPtr
                                             ? &AsyncSetVolume->LabelLength
                                             : NULL;
            AsyncSetVolume->LabelIndex = LabelIndex;
            AsyncSetVolume->LabelBufferAllocated = LabelBufferAllocated;

            AsyncSetVolume->DisplayParms = DisplayParms;
            AsyncSetVolume->VerboseResults = VerboseResults;
            AsyncSetVolume->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullSetVolume,
                                             AsyncSetVolume,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputSetVolume:  Spawning thread fails -> %d\n", GetLastError() );

                    if (LabelBufferAllocated) {

                        DeallocateBuffer( LabelIndex );
                    }

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullSetVolume( AsyncSetVolume );
            }
        }
    }

    return;
}


VOID
FullSetVolume(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    )
{
    try {

        //
        //  Case on the information type and call the appropriate routine.
        //

        switch (AsyncSetVolume->FileInfoClass) {

        case FileFsLabelInformation:

            SetFsLabelInformation( AsyncSetVolume );
            break;

        default:

            bprint  "\nFullSetVolume:  Unrecognized information class\n" );
        }

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AsyncSetVolume->LabelBufferAllocated) {

            DeallocateBuffer( AsyncSetVolume->LabelIndex );
        }

        DeallocateBuffer( AsyncSetVolume->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}

VOID
SetFsLabelInformation(
    IN OUT PASYNC_SET_VOLUME AsyncSetVolume
    )
{
    NTSTATUS Status;

    PFILE_FS_LABEL_INFORMATION LabelInformation;
    USHORT BufferIndex;

    UNICODE_STRING UniLabel;
    ANSI_STRING AnsiLabel;
    BOOLEAN UnwindBufferIndex = FALSE;
    BOOLEAN UnwindFreeAnsiString = FALSE;

    //
    //  Check that there is a label specified.
    //

    if (!AsyncSetVolume->LabelBufferAllocated) {

            bprint  "\nSet Label Information:  No label was specified\n" );
            return;
    }

    UniLabel.Buffer = (PWSTR) Buffers[AsyncSetVolume->LabelIndex].Buffer;
    UniLabel.MaximumLength =
    UniLabel.Length = (USHORT) AsyncSetVolume->LabelLength;

    UniLabel.MaximumLength += 2;

    Status = RtlUnicodeStringToAnsiString( &AnsiLabel,
                                           &UniLabel,
                                           TRUE );

    if (!NT_SUCCESS( Status )) {

        bprint  "\nSetLabelInfo:  Can't allocate ansi buffer -> %08lx\n", Status );
        AsyncSetVolume->DisplayParms = FALSE;

    } else {

        UnwindFreeAnsiString = TRUE;
    }

    if (AsyncSetVolume->DisplayParms) {

            bprint  "\nSet LabelInformation Parameters" );
            bprint  "\n   File Handle Index       -> %d", AsyncSetVolume->FileIndex );

            bprint  "\n   BufferLengthPtr         -> %08lx", AsyncSetVolume->BufferLengthPtr );
            if (AsyncSetVolume->BufferLengthPtr) {

                bprint  "\n   BufferLength value      -> %08x", AsyncSetVolume->BufferLength );
            }

        bprint  "\n   Label length            -> %d", AsyncSetVolume->LabelLength );

        bprint  "\n   New label               -> %s", AnsiLabel.Buffer );

        bprint  "\n\n" );
    }

    try {

        SIZE_T RegionSize;
        ULONG TempIndex;
        IO_STATUS_BLOCK Iosb;

        RegionSize = sizeof( FILE_FS_LABEL_INFORMATION ) + AsyncSetVolume->LabelLength;

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

                bprint  "\n\tSetLabelInformation:  Unable to allocate structure" );
                try_return( NOTHING );
            }

        UnwindBufferIndex = TRUE;

        LabelInformation = (PFILE_FS_LABEL_INFORMATION) Buffers[BufferIndex].Buffer;

        //
        //  Fill in the new information.
        //

        LabelInformation->VolumeLabelLength = AsyncSetVolume->LabelLength;
        RtlMoveMemory( LabelInformation->VolumeLabel,
                           UniLabel.Buffer,
                           AsyncSetVolume->LabelLength );

        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = 0;

        Status = NtSetVolumeInformationFile( Handles[AsyncSetVolume->FileIndex].Handle,
                                                             &Iosb,
                                                             LabelInformation,
                                                             AsyncSetVolume->BufferLengthPtr
                                                             ? AsyncSetVolume->BufferLength
                                                             : Buffers[BufferIndex].Length,
                                                             FileFsLabelInformation );

        if (AsyncSetVolume->VerboseResults) {

            bprint  "\nSetInformationFile:  Status            -> %08lx", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "\n                     Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n                     Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint  "\n" );
        }

    try_exit: NOTHING;
    } finally {

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiLabel );
        }

        if (UnwindBufferIndex) {

            DeallocateBuffer( BufferIndex );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\ttime.c ===
#include "brian.h"

VOID
FullEnterTime(
    PUSHORT BufferPointer,
    CSHORT Year,
    CSHORT Month,
    CSHORT Day,
    CSHORT Hour,
    CSHORT Minute,
    CSHORT Second,
    CSHORT MSecond
    );

VOID
FullDisplayTime (
    USHORT BufferIndex
    );

VOID
PrintTime (
    IN PTIME Time
    )
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields( Time, &TimeFields );

    printf( "%02u-%02u-%02u  %02u:%02u:%02u",
            TimeFields.Month,
            TimeFields.Day,
            TimeFields.Year % 100,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second );

    return;
}

VOID
BPrintTime (
    IN PTIME Time
    )
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields( Time, &TimeFields );

    bprint  "%02u-%02u-%02u  %02u:%02u:%02u",
            TimeFields.Month,
            TimeFields.Day,
            ((USHORT) (TimeFields.Year - 1900)) > 100
            ? 0
            : TimeFields.Year - 1900,
            TimeFields.Hour,
            TimeFields.Minute,
            TimeFields.Second );

    return;
}

VOID
InputEnterTime (
    IN PCHAR ParamBuffer
    )
{
    USHORT ActualIndex;
    PUSHORT BufferPointer;

    CSHORT Year;
    CSHORT Month;
    CSHORT Day;
    CSHORT Hour;
    CSHORT Minute;
    CSHORT Second;
    CSHORT MSecond;

    BOOLEAN LastInput;
    BOOLEAN ParmSpecified;

    ActualIndex = 0;
    BufferPointer = NULL;

    Year = 1601;
    Month = 1;
    Day = 1;
    Hour = 0;
    Minute = 0;
    Second = 0;
    MSecond = 0;

    ParmSpecified = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {
        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ActualIndex = (USHORT) AsciiToInteger( ParamBuffer );
                    BufferPointer = &ActualIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the year value.
                //
                case 'y' :
                case 'Y' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Year = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Check the month value.
                //

                case 'm' :
                case 'M' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Month = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the day value.
                //

                case 'd' :
                case 'D' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Day = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the hour value.
                //

                case 'h' :
                case 'H' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Hour = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the minute value.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Minute = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Enter the second value.
                //

                case 's' :
                case 'S' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    Second = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                //
                //  Check the millesecond value.
                //

                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    MSecond = (CSHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParmSpecified = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {

        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParmSpecified) {

        printf( "\n   Usage: et [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -y<digits>   Year (1601...)" );
        printf( "\n           -m<digits>   Month (1..12)" );
        printf( "\n           -d<digits>   Day (1..31)" );
        printf( "\n           -h<digits>   Hour (0..23)" );
        printf( "\n           -i<digits>   Minute (0..59)" );
        printf( "\n           -s<digits>   Second (0..59)" );
        printf( "\n           -c<digits>   Milleseconds (0..999)" );
        printf( "\n\n" );


    //
    //  Else call the routine to enter the time.
    //

    } else {

        FullEnterTime( BufferPointer,
                       Year,
                       Month,
                       Day,
                       Hour,
                       Minute,
                       Second,
                       MSecond );
    }

   return;
}

VOID
FullEnterTime(
    IN PUSHORT BufferPointer,
    IN CSHORT Year,
    IN CSHORT Month,
    IN CSHORT Day,
    IN CSHORT Hour,
    IN CSHORT Minute,
    IN CSHORT Second,
    IN CSHORT MSecond
    )
{
    NTSTATUS Status;
    TIME_FIELDS TimeFields;
    USHORT BufferIndex;

    //
    //  If we need a buffer, allocate it now.
    //

    try {

        if (BufferPointer == NULL) {

            SIZE_T ThisLength;
            ULONG TempIndex;

            ThisLength = sizeof( TIME );

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );
            BufferIndex = (USHORT) TempIndex;

            BufferPointer = &BufferIndex;

            if (!NT_SUCCESS( Status )) {

                printf( "\n\tFullEnterTime:  Unable to allocate a buffer -> %08lx",
                        Status );

                try_return( NOTHING );
            }

            printf( "\n\tFullEnterTime:  Using buffer -> %04x", *BufferPointer );
            printf( "\n" );
        }

        //
        //  Check that the buffer index is valid.
        //

        if (*BufferPointer >= MAX_BUFFERS) {

            printf( "\n\tFullEnterTime:  The buffer index is invalid" );
            try_return( NOTHING );
        }

        //
        //  Enter the values in the time field structure.
        //

        TimeFields.Year = Year;
        TimeFields.Month = Month;
        TimeFields.Day = Day;
        TimeFields.Hour = Hour;
        TimeFields.Minute = Minute;
        TimeFields.Second = Second;
        TimeFields.Milliseconds = MSecond;

        //
        //  Convert the time field to TIME format for our buffer.
        //

        if (!RtlTimeFieldsToTime( &TimeFields,
                                  (PTIME) Buffers[*BufferPointer].Buffer )) {

            printf( "\n\tFullEnterTime:  Invalid time format" );
            try_return( NOTHING );
        }

    try_exit: NOTHING;
    } finally {

    }

    return;
}

VOID
InputDisplayTime (
    IN PCHAR ParamBuffer
    )
{
    USHORT BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = 0;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = (USHORT) AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqf [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        FullDisplayTime( BufferIndex );
    }

    return;
}


VOID
FullDisplayTime (
    USHORT BufferIndex
    )
{
    //
    //  Check that the buffer index is valid and the buffer is used.
    //

    if (BufferIndex >= MAX_BUFFERS
        || Buffers[BufferIndex].Used == FALSE) {

        bprint  "\n\tFullDisplayTime:  Invalid buffer index" );

    } else {

        printf( "\n\tFullDisplayTime:  Index %d    ", BufferIndex );
        PrintTime( (PTIME) Buffers[BufferIndex].Buffer );
    }

    printf( "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tqvolume.c ===
#include "brian.h"

typedef struct _ASYNC_QVOLUME {

    USHORT FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_QVOLUME, *PASYNC_QVOLUME;

#define QVOLUME_LENGTH_DEFAULT      100
#define FILE_INFO_CLASS_DEFAULT     FileFsVolumeInformation
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_DEFAULT             FALSE

#define DISPLAY_INDEX_DEFAULT       0

VOID
FullQVolume(
    IN OUT PASYNC_QVOLUME AsyncQVolume
    );

VOID
DisplayFsVolumeInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayFsSizeInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayFsDeviceInformation (
    IN USHORT BufferIndex
    );

VOID
DisplayFsAttributeInformation (
    IN USHORT BufferIndex
    );


VOID
InputQVolume (
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    FILE_INFORMATION_CLASS FileInfoClass;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = QVOLUME_LENGTH_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_DEFAULT;

    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    Length = Buffers[BufferIndex].Length;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the information class.
                //
                case 'c' :
                case 'C' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileFsVolumeInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileFsSizeInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFsDeviceInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileFsAttributeInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: qv [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Buffer length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     File information class" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_QVOLUME AsyncQVolume;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_QVOLUME );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputQVolume:  Unable to allocate async structure" );

        } else {

            AsyncQVolume = (PASYNC_QVOLUME) Buffers[AsyncIndex].Buffer;

            AsyncQVolume->FileIndex = (USHORT) FileIndex;

            AsyncQVolume->BufferIndex = BufferIndex;
            AsyncQVolume->BufferIndexPtr = BufferIndexPtr
                                           ? &AsyncQVolume->BufferIndex
                                           : BufferIndexPtr;
            AsyncQVolume->Length = Length;
            AsyncQVolume->FileInfoClass = FileInfoClass;
            AsyncQVolume->DisplayParms = DisplayParms;
            AsyncQVolume->VerboseResults = VerboseResults;
            AsyncQVolume->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullQVolume,
                                             AsyncQVolume,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputQVolume:  Spawning thread fails -> %d\n", GetLastError() );

                    DeallocateBuffer( AsyncIndex );

                    return;
                }

            } else {

                FullQVolume( AsyncQVolume );
            }
        }
    }

    return;
}


VOID
FullQVolume(
    IN OUT PASYNC_QVOLUME AsyncQVolume
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    USHORT ThisBufferIndex;

    BOOLEAN UnwindQVolumeBuffer = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncQVolume->DisplayParms) {

        bprint  "\nQVolume Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncQVolume->FileIndex );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncQVolume->BufferIndexPtr );
        if (AsyncQVolume->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncQVolume->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncQVolume->Length );

        bprint  "\n   FileInfoClass           -> %08lx", AsyncQVolume->FileInfoClass );

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncQVolume->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = 4096;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullQVolume:  Unable to allocate a query buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullQVolume:  Reading into buffer -> %04x\n", ThisBufferIndex );
            bprint  "\n" );

            UnwindQVolumeBuffer = TRUE;

            AsyncQVolume->Length = (ULONG) ThisLength;

        } else {

            ThisBufferIndex = AsyncQVolume->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullQVolume:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncQVolume->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullQVolume:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Call the query file routine.
        //

        Status = NtQueryVolumeInformationFile( Handles[AsyncQVolume->FileIndex].Handle,
                                               &Iosb,
                                               Buffers[ThisBufferIndex].Buffer,
                                               AsyncQVolume->Length,
                                               AsyncQVolume->FileInfoClass );

        UnwindQVolumeBuffer = FALSE;

        if (AsyncQVolume->VerboseResults) {

            bprint  "\nQuery File:  Status            -> %08lx", Status );

            if (NT_SUCCESS( Status )) {

                bprint  "\n             Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n             Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindQVolumeBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        DeallocateBuffer( AsyncQVolume->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}


VOID
InputDisplayQVolume (
    IN PCHAR ParamBuffer
    )
{
    FILE_INFORMATION_CLASS FileInfoClass;
    ULONG BufferIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    BufferIndex = DISPLAY_INDEX_DEFAULT;
    FileInfoClass = FILE_INFO_CLASS_DEFAULT;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                BOOLEAN SwitchBool;

                //
                //  Switch on the next character.
                //

                switch( *ParamBuffer ) {

                //
                //  Check the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    BufferIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the desired access.
                //
                case 'c' :
                case 'C' :


                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //
                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :

                            FileInfoClass = FileFsVolumeInformation;
                            break;

                        case 'b' :
                        case 'B' :

                            FileInfoClass = FileFsSizeInformation;
                            break;

                        case 'c' :
                        case 'C' :

                            FileInfoClass = FileFsDeviceInformation;
                            break;

                        case 'd' :
                        case 'D' :

                            FileInfoClass = FileFsAttributeInformation;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;
                        }

                        ParamBuffer++;
                    }

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                }
            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if ( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {
        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: dqv [options]* -b<digits> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -c<char>     Key to buffer format" );
        printf( "\n\n" );

    //
    //  Else call our display buffer routine.
    //
    } else {

        switch (FileInfoClass) {

            case FileFsVolumeInformation :

                DisplayFsVolumeInformation( (USHORT) BufferIndex );
                break;

            case FileFsSizeInformation:

                DisplayFsSizeInformation( (USHORT) BufferIndex );
                break;

            case FileFsDeviceInformation:

                DisplayFsDeviceInformation( (USHORT) BufferIndex );
                break;

            case FileFsAttributeInformation:

                DisplayFsAttributeInformation( (USHORT) BufferIndex );
                break;
        }
    }

}

VOID
DisplayFsVolumeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_VOLUME_INFORMATION FileInfo;
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    BOOLEAN UnwindFreeAnsiString = FALSE;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsVolumeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_VOLUME_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Volume Information\n" );

        printf( "\n\tVolume Creation Time       -> " );
        PrintTime( &FileInfo->VolumeCreationTime );
        printf( "\n\tVolume Serial Number       -> %08lx", FileInfo->VolumeSerialNumber );
        printf( "\n\tVolume Label Length        -> %08d", FileInfo->VolumeLabelLength );
        printf( "\n\tVolume Supports Objects    -> %01d", FileInfo->SupportsObjects );

        UnicodeString.MaximumLength =
        UnicodeString.Length = (USHORT) FileInfo->VolumeLabelLength;
        UnicodeString.Buffer = (PWSTR) &FileInfo->VolumeLabel;

        UnicodeString.MaximumLength += 2;

        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               TRUE );

        if (!NT_SUCCESS( Status )) {

            printf( "\nDisplay Volume Information: Unable to allocate Ansi -> %08lx\n", Status );
            try_return( NOTHING );
        }

        UnwindFreeAnsiString = TRUE;

        printf( "\n\tVolume Label               -> %s", AnsiString.Buffer );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsVolumeInformation:  AbnormalTermination\n" );
        }

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiString );
        }
    }

    return;
}

VOID
DisplayFsSizeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_SIZE_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsSizeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_SIZE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Size Information\n" );

        printf( "\n\tTotal Allocation Units -> " );
        PrintLargeInteger( &FileInfo->TotalAllocationUnits );
        printf( "\n\tAvail Allocation Units -> " );
        PrintLargeInteger( &FileInfo->AvailableAllocationUnits );
        printf( "\n\tSectors Per Alloc Unit -> %08lx", FileInfo->SectorsPerAllocationUnit );
        printf( "\n\tBytes Per Sector       -> %08lx", FileInfo->BytesPerSector );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsSizeInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayFsDeviceInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_DEVICE_INFORMATION FileInfo;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsDeviceInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_DEVICE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Device Information\n" );

        printf( "\n\tDevice Type     -> %08lx", FileInfo->DeviceType );
        printf( "\n\tCharacteristics -> %08lx", FileInfo->Characteristics );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsDeviceInformation:  AbnormalTermination\n" );
        }
    }

    return;
}

VOID
DisplayFsAttributeInformation (
    IN USHORT BufferIndex
    )
{
    PFILE_FS_ATTRIBUTE_INFORMATION FileInfo;
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    BOOLEAN UnwindFreeAnsiString = FALSE;

    if (!Buffers[BufferIndex].Used) {

        printf( "\nDisplayFsAttributeInformation:  Invalid buffer\n" );
        return;
    }

    try {

        FileInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) Buffers[BufferIndex].Buffer;

        printf( "\n\nFs Attribute Information\n" );

        printf( "\n\tFile System Attributes     -> %08lx", FileInfo->FileSystemAttributes );
        printf( "\n\tMax Component Name Length  -> %08d", FileInfo->MaximumComponentNameLength );
        printf( "\n\tFile System Name Length    -> %08d", FileInfo->FileSystemNameLength );

        UnicodeString.MaximumLength =
        UnicodeString.Length = (USHORT) FileInfo->FileSystemNameLength;
        UnicodeString.Buffer = (PWSTR) &FileInfo->FileSystemName;

        UnicodeString.MaximumLength += 2;

        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               TRUE );

        if (!NT_SUCCESS( Status )) {

            printf( "\nDisplay Fs Attribute Information: Unable to allocate Ansi -> %08lx\n", Status );
            try_return( NOTHING );
        }

        UnwindFreeAnsiString = TRUE;

        printf( "\n\tFile System Name           -> %s", AnsiString.Buffer );

        printf( "\n" );

        try_return( NOTHING );

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            printf( "\nDisplayFsAttributeInformation:  AbnormalTermination\n" );
        }

        if (UnwindFreeAnsiString) {

            RtlFreeAnsiString( &AnsiString );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tread.c ===
#include "brian.h"

typedef struct _ASYNC_READ {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_READ, *PASYNC_READ;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define READ_LENGTH_DEFAULT         100L
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     FALSE

VOID
FullRead(
    IN OUT PASYNC_READ AsyncRead
    );


VOID
InputRead(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    BOOLEAN ParamReceived;
    BOOLEAN LastInput;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = READ_LENGTH_DEFAULT;
    ByteOffsetPtr = NULL;
    ByteOffset = RtlConvertUlongToLargeInteger( 0L );
    KeyPtr = NULL;
    Key = 0;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AsyncIndex = 0;

    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;
        ULONG TempIndex;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the key value.
                //

                case 'k' :
                case 'K' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Key = AsciiToInteger( ParamBuffer );
                    KeyPtr = &Key;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the offset of the read.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ByteOffset.QuadPart = AsciiToLargeInteger( ParamBuffer );
                    ByteOffsetPtr = &ByteOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived) {

        printf( "\n   Usage: rd [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Read length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -k<digits>   Locked bytes key value" );
        printf( "\n           -o<digits>   Read offset" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our read routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_READ AsyncRead;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_READ );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputRead:  Unable to allocate async structure" );

        } else {

            AsyncRead = (PASYNC_READ) Buffers[AsyncIndex].Buffer;

            AsyncRead->FileIndex = (USHORT) FileIndex;
            AsyncRead->UseEvent = UseEvent;
            AsyncRead->ApcRoutine = ApcRoutine;
            AsyncRead->ApcContext = ApcContext;

            AsyncRead->BufferIndex = BufferIndex;
            AsyncRead->BufferIndexPtr = BufferIndexPtr
                                        ? &AsyncRead->BufferIndex
                                        : BufferIndexPtr;
            AsyncRead->Length = Length;
            AsyncRead->ByteOffset = ByteOffset;
            AsyncRead->ByteOffsetPtr = ByteOffsetPtr
                                       ? &AsyncRead->ByteOffset
                                       : ByteOffsetPtr;
            AsyncRead->Key = Key;
            AsyncRead->KeyPtr = KeyPtr
                                ? &AsyncRead->Key
                                : KeyPtr;

            AsyncRead->DisplayParms = DisplayParms;
            AsyncRead->VerboseResults = VerboseResults;
            AsyncRead->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullRead,
                                             AsyncRead,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputRead:  Spawning thread fails -> %d\n", GetLastError() );
                    return;
                }

            } else {

                FullRead( AsyncRead );
            }
        }
    }
    return;
}


VOID
FullRead(
    IN OUT PASYNC_READ AsyncRead
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindReadBuffer = FALSE;
    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncRead->DisplayParms) {

        bprint  "\nRead Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncRead->FileIndex );
        bprint  "\n   UseEvent                -> %d", AsyncRead->UseEvent );
        bprint  "\n   ApcRoutine              -> %08lx", AsyncRead->ApcRoutine );
        bprint  "\n   ApcContext              -> %08lx", AsyncRead->ApcContext );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncRead->BufferIndexPtr );
        if (AsyncRead->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncRead->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncRead->Length );

        bprint  "\n   Byte Offset Ptr         -> %08lx", AsyncRead->ByteOffsetPtr );
        if (AsyncRead->ByteOffsetPtr) {

            bprint  "\n   Byte Offset High        -> %08lx", AsyncRead->ByteOffset.HighPart );
            bprint  "\n   Byte Offset Low         -> %08lx", AsyncRead->ByteOffset.LowPart );
        }

        bprint  "\n   Key Ptr                 -> %08lx", AsyncRead->KeyPtr );

        if (AsyncRead->KeyPtr) {

            bprint  "\n   Key                     -> %ul", AsyncRead->Key );
        }

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncRead->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = AsyncRead->Length;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullRead:  Unable to allocate a read buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullRead:  Reading into buffer -> %04x", ThisBufferIndex );
            bprint  "\n" );

            UnwindReadBuffer = TRUE;

        } else {

            ThisBufferIndex = AsyncRead->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullRead:  The read buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncRead->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullRead:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncRead->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullRead:  Unable to allocate an event" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the read routine.
        //

        Status = NtReadFile( Handles[AsyncRead->FileIndex].Handle,
                             ThisEvent,
                             AsyncRead->ApcRoutine,
                             AsyncRead->ApcContext,
                             &Iosb,
                             Buffers[ThisBufferIndex].Buffer,
                             AsyncRead->Length,
                             AsyncRead->ByteOffsetPtr,
              AsyncRead->KeyPtr );

        UnwindReadBuffer = FALSE;

        if (AsyncRead->VerboseResults) {

            bprint  "\nReadFile:  Status            -> %08lx", Status );

            if (AsyncRead->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tReadFile:  Wait for event failed -> %08lx", Status );
                    bprint "\n" );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\n           Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n           Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindReadBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        DeallocateBuffer( AsyncRead->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tsparse.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestSparse (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputSparse(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputSparse:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputSparse:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_SET_SPARSE;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_SET_ZERO_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_QUERY_ALLOCATED_RANGES;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: Sparse -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Sparse operation" );
        printf( "\n                 -oa             Set Sparse" );
        printf( "\n                 -ob             Zero Range" );
        printf( "\n                 -oc             Query Allocated Ranges" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputSparse:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nSparse Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Sparse operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestSparse,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputSparse:  Spawning thread fails -> %d\n", GetLastError() );
                }

            } else {

                RequestSparse( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestSparse (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestSparse:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestSparse:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestSparse:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestSparse:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestSparse:  IoSb.Information  -> %08lx", IoSb.Information );
            }
            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestSparse:  Thread not terminated\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\tusn.c ===
#include "brian.h"

typedef struct _ASYNC_FSCTRL {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    ULONG IoControlCode;
    PULONG InputBuffer;
    ULONG InputBufferLength;
    PULONG OutputBuffer;
    ULONG OutputBufferLength;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_FSCTRL, *PASYNC_FSCTRL;


VOID
RequestUsn (
    IN PASYNC_FSCTRL Fsctrl
    );

//
//  Local procedures
//


VOID
InputUsn(
    IN PCHAR ParamBuffer
    )

{
    BOOLEAN HaveFileIndex = FALSE;
    BOOLEAN HaveIoControlCode = FALSE;

    USHORT FileIndex;
    BOOLEAN UseEvent = TRUE;
    PIO_APC_ROUTINE ApcRoutine = NULL;
    PVOID ApcContext = NULL;
    ULONG IoControlCode = 0;
    PULONG InputBuffer = NULL;
    ULONG InputBufferLength = 0;
    PULONG OutputBuffer = NULL;
    ULONG OutputBufferLength = 0;
    BOOLEAN VerboseResults = FALSE;
    BOOLEAN DisplayParms = FALSE;

    USHORT AsyncIndex;
    BOOLEAN LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while(TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //

        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            ULONG TempIndex;

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if((*ParamBuffer == '-'
                || *ParamBuffer == '/')
               && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                BOOLEAN SwitchBool;

                //
                //  Update buffers to use.
                //

                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputUsn:  Invalid Input buffer" );

                            } else {

                                InputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                InputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;

                    case 'o':
                    case 'O':

                            TempIndex = AsciiToInteger( ++ParamBuffer );

                            if (TempIndex >= MAX_BUFFERS) {

                                bprint  "\n\tInputUsn:  Invalid output buffer" );

                            } else {

                                OutputBuffer = (PULONG) Buffers[TempIndex].Buffer;
                                OutputBufferLength = Buffers[TempIndex].Length;
                            }

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update buffer lengths.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == '\0') {

                            break;
                    }

                    switch (*ParamBuffer) {

                    case 'i':
                    case 'I':

                            InputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;

                    case 'o':
                    case 'O':

                            OutputBufferLength = AsciiToInteger( ++ParamBuffer );

                            break;
                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //

                    ParamBuffer++;

                    FileIndex = (USHORT) (AsciiToInteger( ParamBuffer ));

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    HaveFileIndex = TRUE;

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                //
                //  Modify the operation
                //
                case 'o' :
                case 'O' :

                    ParamBuffer++;

                    SwitchBool = TRUE;
                    while (*ParamBuffer
                           && *ParamBuffer != ' '
                           && *ParamBuffer != '\t') {

                        //
                        //  Perform switch on character.
                        //

                        switch (*ParamBuffer) {

                        case 'a' :
                        case 'A' :
                            IoControlCode = FSCTL_ENUM_USN_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'b' :
                        case 'B' :
                            IoControlCode = FSCTL_READ_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'c' :
                        case 'C' :
                            IoControlCode = FSCTL_CREATE_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'd' :
                        case 'D' :
                            IoControlCode = FSCTL_READ_FILE_USN_DATA;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'e' :
                        case 'E' :
                            IoControlCode = FSCTL_WRITE_USN_CLOSE_RECORD;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'f' :
                        case 'F' :
                            IoControlCode = FSCTL_QUERY_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        case 'g' :
                        case 'G' :
                            IoControlCode = FSCTL_DELETE_USN_JOURNAL;
                            HaveIoControlCode = TRUE;
                            break;

                        default :

                            ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );
                            SwitchBool = FALSE;
                        }

                        if (!SwitchBool) {

                            break;

                        }

                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );


                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //

        } else if (LastInput) {

            break;

        //
        //  Else try to read another line for open parameters.
        //
        } else {



        }

    }


    if (!HaveFileIndex || !HaveIoControlCode) {

        printf( "\n   Usage: Usn -i<digits> -o<char> -b<i|o><digits> -l<i|o><digits>\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>        Open file handle" );
        printf( "\n           -o<chars>         Usn operation" );
        printf( "\n                 -oa             Enumerate Usn Data" );
        printf( "\n                 -ob             Read Usn Journal" );
        printf( "\n                 -oc             Create Usn Journal" );
        printf( "\n                 -od             Read File Usn Data" );
        printf( "\n                 -oe             Write Usn Close Record" );
        printf( "\n                 -of             Query Usn Journal" );
        printf( "\n                 -og             Delete Usn Journal" );
        printf( "\n           -b[i|o]<digits>   I/O buffers" );
        printf( "\n           -l[i|o]<digits>   I/O buffer lengths" );
        printf( "\n           -e[t|f]           Use event results" );
        printf( "\n           -v[t|f]           Verbose results" );
        printf( "\n           -y                Display parameters to query" );
        printf( "\n           -z                Additional input line" );
        printf( "\n\n" );

    //
    //  Else process the call.
    //

    } else {

        NTSTATUS  Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_FSCTRL AsyncFsctrl;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_FSCTRL );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );

        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputUsn:  Unable to allocate async structure" );

        } else {

            AsyncFsctrl = (PASYNC_FSCTRL) Buffers[AsyncIndex].Buffer;

            AsyncFsctrl->FileIndex = FileIndex;
            AsyncFsctrl->UseEvent = UseEvent;
            AsyncFsctrl->ApcRoutine = ApcRoutine;
            AsyncFsctrl->ApcContext = ApcContext;
            AsyncFsctrl->IoControlCode = IoControlCode;
            AsyncFsctrl->InputBuffer = InputBuffer;
            AsyncFsctrl->InputBufferLength = InputBufferLength;
            AsyncFsctrl->OutputBuffer = OutputBuffer;
            AsyncFsctrl->OutputBufferLength = OutputBufferLength;
            AsyncFsctrl->VerboseResults = VerboseResults;
            AsyncFsctrl->AsyncIndex = AsyncIndex;

            if (DisplayParms) {

                printf( "\nUsn Operation Parameters" );
                printf( "\n   Handle index            -> %ld", FileIndex );
                printf( "\n   Usn operation        -> %ld", IoControlCode );
                printf( "\n\n" );
            }

            if (!SynchronousCmds) {

                ThreadHandle = CreateThread( NULL,
                                             0,
                                             RequestUsn,
                                             AsyncFsctrl,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputUsn:  Spawning thread fails -> %d\n", GetLastError() );
                }

            } else {

                RequestUsn( AsyncFsctrl );
            }
        }
    }

    return;
}

VOID
RequestUsn (
    IN PASYNC_FSCTRL Fsctrl
    )
{
    HANDLE ThisEvent;
    USHORT ThisEventIndex = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoSb;

    IoSb.Status = 0;
    IoSb.Information = 0;

    if (Fsctrl->UseEvent) {

        Status = ObtainEvent( &ThisEventIndex );

        if (!NT_SUCCESS( Status )) {

            bprint  "\n\tRequestUsn:  Unable to allocate an event" );

        } else {

            ThisEvent = Events[ThisEventIndex].Handle;
        }
    }

    if (NT_SUCCESS( Status )) {

        IoSb.Status = 0;
        IoSb.Information = 0;
        Status = NtFsControlFile( Handles[Fsctrl->FileIndex].Handle,
                                  ThisEvent,
                                  Fsctrl->ApcRoutine,
                                  Fsctrl->ApcContext,
                                  &IoSb,
                                  Fsctrl->IoControlCode,
                                  Fsctrl->InputBuffer,
                                  Fsctrl->InputBufferLength,
                                  Fsctrl->OutputBuffer,
                                  Fsctrl->OutputBufferLength );

        if (Fsctrl->VerboseResults) {

            bprint  "\nRequestUsn:  Status            -> %08lx\n", Status );

            if (Fsctrl->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tRequestUsn:  Wait for event failed -> %08lx", Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\nRequestUsn:  IoSb.Status       -> %08lx", IoSb.Status );
                bprint  "\nRequestUsn:  IoSb.Information  -> %08lx", IoSb.Information );
            }
            bprint "\n" );
        }
    }

    if (ThisEventIndex != 0) {

        FreeEvent( ThisEventIndex );
    }

    DeallocateBuffer( Fsctrl->AsyncIndex );

    if (!SynchronousCmds) {

        NtTerminateThread( NtCurrentThread(), STATUS_SUCCESS );
        bprint  "\nRequestUsn:  Thread not terminated\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\bshell\twrite.c ===
#include "brian.h"

typedef struct _ASYNC_WRITE {

    USHORT FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

} ASYNC_WRITE, *PASYNC_WRITE;

#define USE_EVENT_DEFAULT           TRUE
#define APC_ROUTINE_DEFAULT         NULL
#define APC_CONTEXT_DEFAULT         NULL
#define WRITE_LENGTH_DEFAULT         100L
#define DISPLAY_PARMS_DEFAULT       FALSE
#define VERBOSE_RESULTS_DEFAULT     FALSE

VOID
FullWrite(
    IN OUT PASYNC_WRITE AsyncWrite
    );


VOID
InputWrite(
    IN PCHAR ParamBuffer
    )
{
    ULONG FileIndex;
    BOOLEAN UseEvent;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
    PUSHORT BufferIndexPtr;
    USHORT BufferIndex;
    ULONG Length;
    PLARGE_INTEGER ByteOffsetPtr;
    LARGE_INTEGER ByteOffset;
    PULONG KeyPtr;
    ULONG Key;
    BOOLEAN DisplayParms;
    BOOLEAN VerboseResults;
    USHORT AsyncIndex;

    ULONG TempIndex;
    BOOLEAN ParamReceived;
    BOOLEAN LastInput;
    BOOLEAN BufferReceived;

    //
    //  Set the defaults.
    //

    UseEvent = USE_EVENT_DEFAULT;
    ApcRoutine = APC_ROUTINE_DEFAULT;
    ApcContext = APC_CONTEXT_DEFAULT;
    BufferIndexPtr = NULL;
    BufferIndex = 0;
    Length = WRITE_LENGTH_DEFAULT;
    ByteOffsetPtr = NULL;
    ByteOffset = RtlConvertUlongToLargeInteger( 0L );
    KeyPtr = NULL;
    Key = 0;
    DisplayParms = DISPLAY_PARMS_DEFAULT;
    VerboseResults = VERBOSE_RESULTS_DEFAULT;
    AsyncIndex = 0;

    BufferReceived = FALSE;
    ParamReceived = FALSE;
    LastInput = TRUE;

    //
    //  While there is more input, analyze the parameter and update the
    //  query flags.
    //

    while (TRUE) {

        ULONG DummyCount;

        //
        //  Swallow leading white spaces.
        //
        ParamBuffer = SwallowWhite( ParamBuffer, &DummyCount );

        if (*ParamBuffer) {

            //
            //  If the next parameter is legal then check the paramter value.
            //  Update the parameter value.
            //
            if ((*ParamBuffer == '-'
                 || *ParamBuffer == '/')
                && (ParamBuffer++, *ParamBuffer != '\0')) {

                //
                //  Switch on the next character.
                //

                switch (*ParamBuffer) {

                //
                //  Update the buffer index.
                //
                case 'b' :
                case 'B' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    TempIndex = AsciiToInteger( ParamBuffer );
                    BufferIndex = (USHORT) TempIndex;
                    BufferIndexPtr = &BufferIndex;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    BufferReceived = TRUE;
                    break;

                //
                //  Update the byte count.
                //

                case 'l' :
                case 'L' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Length = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the file handle index.
                //

                case 'i' :
                case 'I' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    FileIndex = AsciiToInteger( ParamBuffer );

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    ParamReceived = TRUE;

                    break;

                //
                //  Update the key value.
                //

                case 'k' :
                case 'K' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    Key = AsciiToInteger( ParamBuffer );
                    KeyPtr = &Key;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Update the offset of the transfer.
                //

                case 'o' :
                case 'O' :

                    //
                    //  Move to the next character, as long as there
                    //  are no white spaces continue analyzing letters.
                    //  On the first bad letter, skip to the next
                    //  parameter.
                    //
                    ParamBuffer++;

                    ByteOffset.QuadPart = AsciiToLargeInteger( ParamBuffer );
                    ByteOffsetPtr = &ByteOffset;

                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                //
                //  Check whether we should use an event to signal
                //  completion.
                //

                case 'e' :
                case 'E' :

                    //
                    //  Legal values for use event are T/t or F/f.
                    //
                    ParamBuffer++;

                    if (*ParamBuffer == 'T'
                        || *ParamBuffer == 't') {

                        UseEvent = TRUE;
                        ParamBuffer++;

                    } else if (*ParamBuffer == 'F'
                               || *ParamBuffer == 'f') {

                        UseEvent = FALSE;
                        ParamBuffer++;
                    }

                    break;

                case 'v' :
                case 'V' :

                    //
                    //  Legal values for params are T/t or F/f.
                    //
                    ParamBuffer++;

                    if( *ParamBuffer == 'T'
                        || *ParamBuffer == 't' ) {

                        VerboseResults = TRUE;
                        ParamBuffer++;

                    } else if( *ParamBuffer == 'F'
                               || *ParamBuffer == 'f' ) {

                        VerboseResults = FALSE;
                        ParamBuffer++;

                    }

                    break;

                case 'y' :
                case 'Y' :

                    //
                    //  Set the display parms flag and jump over this
                    //  character.
                    //
                    DisplayParms = TRUE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                case 'z' :
                case 'Z' :

                    //
                    //  Set flag for more input and jump over this char.
                    //
                    LastInput = FALSE;
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                    break;

                default :

                    //
                    //  Swallow to the next white space and continue the
                    //  loop.
                    //
                    ParamBuffer = SwallowNonWhite( ParamBuffer, &DummyCount );

                }

            }

            //
            //  Else the text is invalid, skip the entire block.
            //
            //

        //
        //  Else if there is no input then exit.
        //
        } else if( LastInput ) {

            break;

        //
        //  Else try to write another line for open parameters.
        //
        } else {



        }

    }

    //
    //  If no parameters were received then display the syntax message.
    //
    if (!ParamReceived && !BufferReceived) {

        printf( "\n   Usage: wr [options]* -i<index> [options]*\n" );
        printf( "\n       Options:" );
        printf( "\n           -i<digits>   File index" );
        printf( "\n           -l<digits>   Write length" );
        printf( "\n           -b<digits>   Buffer index" );
        printf( "\n           -k<digits>   Locked bytes key value" );
        printf( "\n           -o<digits>   Start offset to write" );
        printf( "\n           -e[t|f]      Use event on completion" );
        printf( "\n           -v[t|f]      Verbose results" );
        printf( "\n           -y           Display parameters to query" );
        printf( "\n           -z           Additional input line" );
        printf( "\n\n" );

    //
    //  Else call our write routine.
    //

    } else {

        NTSTATUS Status;
        SIZE_T RegionSize;
        ULONG TempIndex;

        PASYNC_WRITE AsyncWrite;

        HANDLE ThreadHandle;
        ULONG ThreadId;

        RegionSize = sizeof( ASYNC_WRITE );

        Status = AllocateBuffer( 0, &RegionSize, &TempIndex );
        AsyncIndex = (USHORT) TempIndex;

        if (!NT_SUCCESS( Status )) {

            printf("\n\tInputWrite:  Unable to allocate async structure" );

        } else {

            AsyncWrite = (PASYNC_WRITE) Buffers[AsyncIndex].Buffer;

            AsyncWrite->FileIndex = (USHORT) FileIndex;
            AsyncWrite->UseEvent = UseEvent;
            AsyncWrite->ApcRoutine = ApcRoutine;
            AsyncWrite->ApcContext = ApcContext;
            AsyncWrite->BufferIndex = BufferIndex;
            AsyncWrite->BufferIndexPtr = BufferIndexPtr
                                         ? &AsyncWrite->BufferIndex
                                         : BufferIndexPtr;
            AsyncWrite->Length = Length;
            AsyncWrite->ByteOffset = ByteOffset;
            AsyncWrite->ByteOffsetPtr = ByteOffsetPtr
                                        ? &AsyncWrite->ByteOffset
                                        : ByteOffsetPtr;
            AsyncWrite->Key = Key;
            AsyncWrite->KeyPtr = KeyPtr
                                 ? &AsyncWrite->Key
                                 : KeyPtr;
            AsyncWrite->DisplayParms = DisplayParms;
            AsyncWrite->VerboseResults = VerboseResults;
            AsyncWrite->AsyncIndex = AsyncIndex;

            if (!SynchronousCmds) {
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             FullWrite,
                                             AsyncWrite,
                                             0,
                                             &ThreadId );

                if (ThreadHandle == 0) {

                    printf( "\nInputWrite:  Spawning thread fails -> %d\n", GetLastError() );
                    return;
                }
            } else  {

                FullWrite( AsyncWrite );
            }
        }
    }
    return;
}


VOID
FullWrite(
    IN OUT PASYNC_WRITE AsyncWrite
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    HANDLE ThisEvent;
    USHORT ThisEventIndex;
    USHORT ThisBufferIndex;

    BOOLEAN UnwindWriteBuffer = FALSE;
    BOOLEAN UnwindEvent = FALSE;

    Status = STATUS_SUCCESS;

    if (AsyncWrite->DisplayParms) {

        bprint  "\nWrite Parameters" );
        bprint  "\n   File Handle Index       -> %d", AsyncWrite->FileIndex );
        bprint  "\n   UseEvent                -> %d", AsyncWrite->UseEvent );
        bprint  "\n   ApcRoutine              -> %08lx", AsyncWrite->ApcRoutine );
        bprint  "\n   ApcContext              -> %08lx", AsyncWrite->ApcContext );
        bprint  "\n   Buffer Index Ptr        -> %08lx", AsyncWrite->BufferIndexPtr );
        if (AsyncWrite->BufferIndexPtr) {

            bprint  "\n   BufferIndex value       -> %04x", AsyncWrite->BufferIndex );
        }

        bprint  "\n   Length                  -> %08lx", AsyncWrite->Length );

        bprint  "\n   Byte Offset             -> %08lx", AsyncWrite->ByteOffsetPtr );
        if ( AsyncWrite->ByteOffsetPtr ) {

            bprint  "\n   Byte Offset High        -> %08lx", AsyncWrite->ByteOffset.HighPart );
            bprint  "\n   Byte Offset Low         -> %08lx", AsyncWrite->ByteOffset.LowPart );
        }

        bprint  "\n   Key Ptr                 -> %08lx", AsyncWrite->KeyPtr );

        if (AsyncWrite->KeyPtr) {

            bprint  "\n   Key                     -> %ul", AsyncWrite->Key );
        }

        bprint  "\n\n" );
    }

    try {

        SIZE_T ThisLength;

        //
        //  If we need a buffer, allocate it now.
        //

        if (AsyncWrite->BufferIndexPtr == NULL) {

            ULONG TempIndex;

            ThisLength = AsyncWrite->Length;

            Status = AllocateBuffer( 0L, &ThisLength, &TempIndex );

            ThisBufferIndex = (USHORT) TempIndex;

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullWrite:  Unable to allocate a Write buffer" );
                try_return( Status );
            }

            bprint  "\n\tFullWrite:  Writeing into buffer -> %04x", ThisBufferIndex );

            UnwindWriteBuffer = TRUE;

        } else {

            ThisBufferIndex = AsyncWrite->BufferIndex;
        }

        //
        //  Check that the buffer index is valid.
        //

        if (ThisBufferIndex >= MAX_BUFFERS) {

            bprint  "\n\tFullWrite:  The Write buffer index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  Check that the file index is valid.
        //

        if (AsyncWrite->FileIndex >= MAX_HANDLES) {

            bprint  "\n\tFullWrite:  The file index is invalid" );
            try_return( Status = STATUS_INVALID_HANDLE );
        }

        //
        //  If we need an event, allocate and set it now.
        //

        if (AsyncWrite->UseEvent == TRUE) {

            Status = ObtainEvent( &ThisEventIndex );

            if (!NT_SUCCESS( Status )) {

                bprint  "\n\tFullWrite:  Unable to allocate an event" );
                try_return( Status );
            }

            UnwindEvent = TRUE;
            ThisEvent = Events[ThisEventIndex].Handle;

        } else {

            ThisEvent = 0;
        }

        //
        //  Call the write routine.
        //

        Status = NtWriteFile( Handles[AsyncWrite->FileIndex].Handle,
                             ThisEvent,
                             AsyncWrite->ApcRoutine,
                             AsyncWrite->ApcContext,
                             &Iosb,
                             Buffers[ThisBufferIndex].Buffer,
                             AsyncWrite->Length,
                             AsyncWrite->ByteOffsetPtr,
              AsyncWrite->KeyPtr );

        UnwindWriteBuffer = FALSE;

        if (AsyncWrite->VerboseResults) {

            bprint  "\nWriteFIle:  Status            -> %08lx", Status );

            if (AsyncWrite->UseEvent && NT_SUCCESS( Status )) {

                if ((Status = NtWaitForSingleObject( ThisEvent,
                                                     FALSE,
                                                     NULL )) != STATUS_SUCCESS) {

                    bprint  "\n\tWriteFile:  Wait for event failed -> %08lx", Status );
                    bprint "\n" );
                    try_return( Status );
                }
            }

            if (NT_SUCCESS( Status )) {

                bprint  "\n           Iosb.Information  -> %08lx", Iosb.Information );
                bprint  "\n           Iosb.Status       -> %08lx", Iosb.Status );
            }
            bprint "\n" );
        }

        try_return( Status );

    try_exit: NOTHING;
    } finally {

        if (UnwindWriteBuffer) {

            DeallocateBuffer( ThisBufferIndex );
        }

        if (UnwindEvent) {

            FreeEvent( ThisEventIndex );
        }

        DeallocateBuffer( AsyncWrite->AsyncIndex );
    }

    if (!SynchronousCmds) {

        NtTerminateThread( 0, STATUS_SUCCESS );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\oidtst.c ===
//  oidtst.c

#include "oidtst.h"


int
FsTestDecipherStatus(
	IN NTSTATUS Status
	)
{
	int Error;

    printf( "Status %x -- ", Status );

	switch(Status) {

	    case STATUS_ACCESS_DENIED:
			printf( "STATUS_ACCESS_DENIED\n" );
			break;

	    case STATUS_NOT_IMPLEMENTED:
			printf( "STATUS_NOT_IMPLEMENTED\n" );
			break;			

	    case STATUS_NOT_LOCKED:
			printf( "STATUS_NOT_LOCKED\n" );
			break;			
			
		case STATUS_OBJECTID_EXISTS:
			printf( "STATUS_OBJECTID_EXISTS\n" );
			break;

		case STATUS_BUFFER_OVERFLOW:
			printf( "STATUS_BUFFER_OVERFLOW\n" );
			break;

		case STATUS_NO_MORE_FILES:
			printf( "STATUS_NO_MORE_FILES\n" );
			break;

		case STATUS_DUPLICATE_NAME:
			printf( "STATUS_DUPLICATE_NAME\n" );
			break;

		case STATUS_OBJECT_NAME_COLLISION:
			printf( "STATUS_OBJECT_NAME_COLLISION\n" );
			break;

		case STATUS_OBJECT_NAME_NOT_FOUND:
			printf( "STATUS_OBJECT_NAME_NOT_FOUND\n" );
			break;

		case STATUS_INVALID_ADDRESS:
			printf( "STATUS_INVALID_ADDRESS\n" );
			break;

		case STATUS_INVALID_PARAMETER:
			printf( "STATUS_INVALID_PARAMETER\n" );
			break;

		case STATUS_OBJECT_PATH_NOT_FOUND:
			printf( "STATUS_OBJECT_PATH_NOT_FOUND\n" );
			break;

		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			printf( "STATUS_OBJECT_PATH_SYNTAX_BAD\n" );
			break;

		case STATUS_SUCCESS:
			printf( "STATUS_SUCCESS\n" );
			break;

		default:	  
			printf( "(unknown status code)\n" );
			break;
	}

    if (Status != STATUS_SUCCESS) {

		Error = GetLastError();
        printf( "GetLastError returned (dec): %d\n", Error );

		return 1;
    }       

	return 0;
}

void
FsTestHexDump (
    IN UCHAR *Buffer,
    IN ULONG Size
    )
{
    ULONG idx;

    printf( "\n" );
    
    for (idx = 0; idx < Size; idx += 1) {
    
//        printf( "%02x %c  ", Buffer[idx], Buffer[idx] );
        printf( "%02x ", Buffer[idx] );
    }
}

void
FsTestHexDumpLongs (
    IN ULONG *Buffer,
    IN ULONG SizeInBytes
    )
{
    ULONG idx;
    ULONG Size = SizeInBytes / 4;

    printf( "\n" );
    
    for (idx = 0; idx < Size; idx += 1) {
    
        printf( "%08x ", Buffer[idx] );
    }
}
    
#if 0

void
FsTestDumpMenu(
		 void
		 )
{
    printf( "\n s -- Set object id" );	
    printf( "\n g -- Get object id" );	
    printf( "\n d -- Delete object id" );	
    printf( "\n o -- Open file by object id" );	
	printf( "\n q -- Quit" );	
}


int
FsTestDoCommand(
		   IN HANDLE hFile,
		   IN OUT OBJECTID *ObjectId
		  )

{
    char cmd[8];
	int retval = 0;
	HANDLE OpenedFile;
	
    printf( "\n -->" );

    scanf( "%s", cmd);

	switch(cmd[0]) {
	case 's':
		FsTestSetOid( hFile, *ObjectId );
		break;

	case 'g':
		FsTestGetOid( hFile, ObjectId );
		break;

	case 'd':
		FsTestDeleteOid( hFile, *ObjectId );
		break;

	case 'o':
		FsTestOpenByOid( *ObjectId, &OpenedFile );
		break;

	case 'q':
		retval = 1;
		break;

	default:
		printf( "\n Try again" );
    }

	return retval;
}


VOID
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
	OBJECTID ObjectId;

    //
    //  Get parameters 
    //

    if (argc < 3) {
        printf("This program tests object ids (ntfs only).\n\n");
        printf("usage: %s filename ObjectId\n", argv[0]);
        return;
    }

    hFile = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

	RtlZeroBytes( &ObjectId,
	 			  sizeof( ObjectId ) );

	sscanf( argv[2], "%d", &ObjectId.Lineage.Data1 );

	printf( "\nUsing file:%s, ObjectId:%d", argv[1], ObjectId.Lineage.Data1 );

	while (retval == 0) {

		FsTestDumpMenu();
		retval = FsTestDoCommand( hFile, &ObjectId );
	}

	CloseHandle( hFile );    

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\logfile\dumplog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       dumplog.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:
//
//  History:    8-24-1998   benl   Created
//
//----------------------------------------------------------------------------


#include "pch.hxx"
#include "utils.hxx"
#include "map.hxx"

typedef void * PSCB;
typedef bool (* PMATCH_FUNC)(PLFS_RECORD_HEADER pRecord, PVOID Context);

typedef struct {
    LONGLONG llFileRef;
    ULONG    AttrType;
} MYENTRY, *PMYENTRY;

typedef struct {
    VCN Vcn;
    int Offset;
} VCN_OFFSET, *PVCN_OFFSET;

typedef CMap<int, MYENTRY> OPEN_ATTR_MAP, *POPEN_ATTR_MAP;

//
//  Map of current lsn to start of transaction lsn
//  

typedef CMap<LONGLONG, ULONG> TRANSACTION_MAP, *PTRANSACTION_MAP;

typedef struct {
    LONGLONG        llFileRef;
    OPEN_ATTR_MAP * pAttrMap;
    INT             ClusterSize;
} FILEREF_MATCH_CTX, *PFILEREF_MATCH_CTX;

typedef struct {
    LONGLONG AddRecordLsn;
    LONGLONG AddRecordFileRef;
    LONGLONG AddRecordVcn;
    int      AddRecordClusterOffset;
} DEDUCE_CTX, *PDEDUCE_CTX;

#include <ntfslog.h>

typedef struct _LOGCB {
    LSN FirstLsn;
    LSN CurrentLsn;
} LOGCB, *PLOGCB;

#define WARNING_SIZE 50
#define LOG_PAGE 0x1000
#define TOTAL_PAGE_HEADER ALIGN(sizeof(LFS_RECORD_PAGE_HEADER) + ((LOG_PAGE / 0x200) * sizeof(USHORT)), sizeof(DWORD))

const char * gOpMap[] =
{
    "Noop",
    "CompensationLogRecord",
    "Init FRS",
    "Delete FRS",
    "Write EOF FRS",
    "CreateAttribute",
    "DeleteAttribute",
    "UpdateResidentValue",
    "UpdateNonresidentValue",
    "UpdateMappingPairs",
    "DeleteDirtyClusters",
    "SetNewAttributeSizes",
    "AddIndexEntryRoot",
    "DeleteIndexEntryRoot",
    "AddIndexEntryAllocation",
    "DeleteIndexEntryAllocation",
    "WriteEndOfIndexBuffer",
    "SetIndexEntryVcnRoot",
    "SetIndexEntryVcnAllocation",
    "UpdateFileNameRoot",
    "UpdateFileNameAllocation",
    "SetBitsInNonresidentBitMap",
    "ClearBitsInNonresidentBitMap",
    "HotFix",
    "EndTopLevelAction",
    "PrepareTransaction",
    "CommitTransaction",
    "ForgetTransaction",
    "OpenNonresidentAttribute",
    "OpenAttributeTableDump",
    "AttributeNamesDump",
    "DirtyPageTableDump",
    "TransactionTableDump",
    "UpdateRecordDataRoot",
    "UpdateRecordDataAllocation"
};

const char * gTransStateMap[] = {
    "TransactionUninitialized",
    "TransactionActive",
    "TransactionPrepared",
    "TransactionCommitted"
};

int gcOpMap = (sizeof(gOpMap) / sizeof(char *));
int gcTransStateMap = (sizeof(gTransStateMap) / sizeof(char *));
int gSeqNumberBits = 0;
int gLogFileSize = 0;

//flags
bool       gfDumpData = false;
int        giPagesBackToDump = 0;
bool       gfPrintHeaders = false;
LSN        gLsnToDump = {0,0};
VCN_OFFSET gVcnPairToMatch;
LCN        gLcnToMatch = 0;
LSN        gLsnToTrace = {0,0};
bool       gfDumpEverything = false;
LONG       glBitToMatch = -1; 
LONGLONG   gllFileToMatch = 0;
bool       gfScanForRestarts = false;
ULONG      gulClusterSize = 0;
LSN        gllRangeStart = {0,0};
LSN        gllRangeEnd = {0,0};
bool       gVerboseScan = false;
bool       gfScanTransactions = false;

//+---------------------------------------------------------------------------
//
//  Function:   LsnToOffset
//
//  Synopsis:   Transforms LSN to its offset in the logfile
//
//  Arguments:  [Lsn] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LONGLONG LsnToOffset(LONGLONG Lsn)
{
    return (ULONGLONG)(Lsn << gSeqNumberBits) >> (gSeqNumberBits - 3);
} // LsnToOffset


//+---------------------------------------------------------------------------
//
//  Function:   LsnToSequenceNumber
//
//  Synopsis:   Transforms LSN to its sequence number
//
//  Arguments:  [Lsn] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

ULONG LsnToSequenceNumber(LONGLONG Lsn)
{
    return (ULONG)(Lsn >> (sizeof(LONGLONG) * 8 - gSeqNumberBits));
} // LsnToOffset



//+---------------------------------------------------------------------------
//
//  Function:   MyReadFile
//
//  Synopsis:   Helper wrapper for ReadFile
//
//  Arguments:  [hFile]    --
//              [lpBuffer] --
//              [cbRange]  --
//              [pol]      --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MyReadFile(HANDLE hFile, BYTE * lpBuffer, DWORD cbRange, OVERLAPPED * pol)
{
    DWORD dwRead;

    if (!ReadFile(hFile, lpBuffer, cbRange, &dwRead, pol)) {
        printf("MyReadFile: ReadFile for 0x%x at 0x%x failed %d\n", cbRange, pol->Offset, GetLastError());
        return false;
    }

    if (dwRead != cbRange) {
        printf("MyReadFile: Only read: 0x%x\n", dwRead);
        return false;
    }

    return true;
} // MyReadFile

//+---------------------------------------------------------------------------
//
//  Function:   ApplySectorHdr
//
//  Synopsis:   Fixes up log record using multisector hdr
//
//  Arguments:  [pHdr] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool ApplySectorHdr(PMULTI_SECTOR_HEADER pHdr, ULONG LogOffset)
{
    int      iIndex;
    USHORT * pShort = NULL;
    USHORT   sKey;
    USHORT * pBuffer;

    if (*((DWORD *)pHdr->Signature) == 0xFFFFFFFF) {
        printf("Unused page!\n");
        return false;
    }

    if (*((DWORD *)pHdr->Signature) == 0x44414142) {
        printf("BAAD page!\n");
        return false;
    }


    if ((pHdr->UpdateSequenceArraySize != PAGE_SIZE / 0x200 + 1)) {
        printf("Bogus page!\n");
        return false;
    }

    pBuffer = (USHORT *)((BYTE *)pHdr + 0x1fe);
    pShort = (USHORT *) ((BYTE *)pHdr + pHdr->UpdateSequenceArrayOffset);
    sKey = *pShort;
    pShort++;

    //this should reflect the page size
    if (!(pHdr->UpdateSequenceArraySize == PAGE_SIZE / 0x200 + 1)) {
        
        printf( "BadSeqSize: 0x%x\n", pHdr->UpdateSequenceArraySize );
        return false;
    }

    for (iIndex=0; iIndex < pHdr->UpdateSequenceArraySize - 1; iIndex++) {

        if (sKey != *pBuffer) {
            printf( "USA Mismatch: 0x%x 0x%x at offset 0x%x\n", sKey, *pBuffer, LogOffset + (iIndex+1) * 0x200 );
        }

        *pBuffer = *pShort;
        pBuffer = (USHORT *)((BYTE *)pBuffer + 0x200);
        pShort++;
    }

    return true;
} // ApplySectorHdr


//+---------------------------------------------------------------------------
//
//  Function:   DumpSectorHdr
//
//  Synopsis:   Dump MultiSectorHdr
//
//  Arguments:  [pHdr] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpSectorHdr(PMULTI_SECTOR_HEADER pHdr)
{
    int      iIndex;
    USHORT * pShort = NULL;

    printf("Signature: %c%c%c%c\n", pHdr->Signature[0], pHdr->Signature[1],
           pHdr->Signature[2], pHdr->Signature[3]);
    printf("UpdateSequenceArrayOffset: 0x%x\n", pHdr->UpdateSequenceArrayOffset);
    printf("UpdateSequenceArraySize: 0x%x\n", pHdr->UpdateSequenceArraySize);

    pShort = (USHORT *) ((BYTE *)pHdr + pHdr->UpdateSequenceArrayOffset);

    for (iIndex=0; iIndex < pHdr->UpdateSequenceArraySize; iIndex++) {
        printf("0x%x ", *pShort);
        pShort++;
    }
    printf("\n");
} // DumpSectorHdr


//+---------------------------------------------------------------------------
//
//  Function:   DumpRestartPage
//
//  Synopsis: Dumps a lfs restart record page
//
//  Arguments:  [lpBuffer] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRestartPage(BYTE * lpBuffer)
{
    PLFS_RESTART_PAGE_HEADER pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpBuffer;
    PLFS_RESTART_AREA        pLfsRestart = 0;
    int                      iIndex;
    PLFS_CLIENT_RECORD       pClient = 0;

    printf("Restart Page\n");
    printf("ChkDskLsn: 0x%I64x\n", pRestartHdr->ChkDskLsn);
    printf("LogPageSize: 0x%x\n", pRestartHdr->LogPageSize);


    pLfsRestart = (PLFS_RESTART_AREA) (lpBuffer + pRestartHdr->RestartOffset);

    printf("\nLFS Restart Area\n");

    printf("CurrentLsn: 0x%I64x\n", pLfsRestart->CurrentLsn);
    printf("LogClients: %d\n", pLfsRestart->LogClients);
    printf("Flags: 0x%x\n", pLfsRestart->Flags);
    printf("LogPage RecordHeaderLength: 0x%x\n", pLfsRestart->RecordHeaderLength);
    printf("SeqNumberBits: 0x%x\n", pLfsRestart->SeqNumberBits);
    printf("LogFileSize: 0x%I64x\n", pLfsRestart->FileSize);

    printf("\nClients\n");

    pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart + pLfsRestart->ClientArrayOffset);

    for (iIndex=0; iIndex < pLfsRestart->LogClients; iIndex++) {
        printf("Name: %*S\n", pClient->ClientNameLength, pClient->ClientName);
        printf("OldestLsn: 0x%I64x\n", pClient->OldestLsn);
        printf("ClientRestartLsn: 0x%I64x\n", pClient->ClientRestartLsn);

        pClient = pClient++;
    }

} // DumpRestartPage



//+---------------------------------------------------------------------------
//
//  Function:   DumpOpenAttributeTable
//
//  Synopsis:   Dump the open attr table
//
//  Arguments:  [PRESTART_TABLE] --
//
//  Returns:
//
//  History:    8-28-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpOpenAttributeTable(PRESTART_TABLE pRestartTable)
{
    POPEN_ATTRIBUTE_ENTRY_V0 pEntry = 0;
    int                   iIndex;

    printf("\nOpenAttributeTable\n");
    printf("EntrySize: 0x%x\n", pRestartTable->EntrySize);
    printf("NumberEntries: 0x%x\n", pRestartTable->NumberEntries);
    printf("NumberAllocated: 0x%x\n\n", pRestartTable->NumberAllocated);

    pEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
    for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
        printf("Entry 0x%x\n", (BYTE *)pEntry - (BYTE *)pRestartTable);
        if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
            printf("FileRef: 0x%I64x\n", pEntry->FileReference);
            printf("LsnOfOpenRecord: 0x%I64x\n", pEntry->LsnOfOpenRecord);
            printf("AttributeTypeCode: 0x%x\n", pEntry->AttributeTypeCode);
//                    printf("AttributeName: 0x%x 0x%x\n\n",
//                           pEntry->AttributeName.Length,
//                           pEntry->AttributeName.Buffer);
        } else {
            printf("free\n");
        }
        pEntry++;
        printf("\n");

    }
} // DumpOpenAttributeTable


//+---------------------------------------------------------------------------
//
//  Function:   DumpAttributeNames
//
//  Synopsis:   Dump the attribute names
//
//  Arguments:  [pNameEntry] --
//
//  Returns:
//
//  History:    8-28-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpAttributeNames(PATTRIBUTE_NAME_ENTRY pNameEntry, int TableSize)
{
    int cTraversed = 0;

    printf("\nAttributeNames\n");
    while (pNameEntry->Index != 0 || pNameEntry->NameLength != 0) {
        if (cTraversed >= TableSize) {
            printf("Table appears invalid\n");
            break;
        }

        printf("Index: 0x%x\n", pNameEntry->Index);
        printf("Name: %.*S\n", pNameEntry->NameLength / 2, pNameEntry->Name);
        cTraversed += sizeof(ATTRIBUTE_NAME_ENTRY) + pNameEntry->NameLength;
        pNameEntry = (PATTRIBUTE_NAME_ENTRY) ((BYTE *) pNameEntry +
                                              sizeof(ATTRIBUTE_NAME_ENTRY) + pNameEntry->NameLength);
        printf("\n");
    }
} // DumpAttributeNames



//+---------------------------------------------------------------------------
//
//  Function:   DumpOpenAttribute
//
//  Synopsis:   
//
//  Arguments:  [pEntry]   -- 
//              [pName]    -- 
//              [cNameLen] -- 
//
//  Returns:    
//
//  History:    9-09-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void  DumpOpenAttribute(POPEN_ATTRIBUTE_ENTRY_V0 pEntry, WCHAR * pName, 
                        int cNameLen)
{  
    int iTemp = cNameLen / 2;

    printf("\n");
    if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
        printf("FileRef: 0x%I64x\n", pEntry->FileReference);
        printf("LsnOfOpenRecord: 0x%I64x\n", pEntry->LsnOfOpenRecord);
        printf("AttributeTypeCode: 0x%x\n", pEntry->AttributeTypeCode);
        if (cNameLen) {
            printf("Name: %.*S\n", iTemp, pName);
        }

    } else {
        printf("free\n");
    }
    printf("\n");
} // DumpOpenAttribute


//+---------------------------------------------------------------------------
//
//  Function:   DumpOpenAttributeTable
//
//  Synopsis:   Dump the open attr table
//
//  Arguments:  [PRESTART_TABLE] --
//
//  Returns:
//
//  History:    8-28-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpDirtyPageTable(PRESTART_TABLE pRestartTable)
{
    PDIRTY_PAGE_ENTRY_V0 pEntry = 0;
    int                  iIndex;
    DWORD                iIndex2;

    printf("\nDirtyPageTable\n");
    printf("EntrySize: 0x%x\n", pRestartTable->EntrySize);
    printf("NumberEntries: 0x%x\n", pRestartTable->NumberEntries);
    printf("NumberAllocated: 0x%x\n\n", pRestartTable->NumberAllocated);

    pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
    for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
        if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
            printf("Entry 0x%x\n", (BYTE *)pEntry - (BYTE *)pRestartTable);
            printf("TargetAttribute: 0x%x\n", pEntry->TargetAttribute);
            printf("LengthOfTransfer: 0x%x\n", pEntry->LengthOfTransfer);
            printf("VCN: 0x%I64x\n", pEntry->Vcn);
            printf("OldestLsn: 0x%I64x\n", pEntry->OldestLsn);
            printf("Lcns: ");
            for (iIndex2=0; iIndex2 < pEntry->LcnsToFollow; iIndex2++) {
                printf("0x%I64x ", pEntry->LcnsForPage[iIndex2]);
            }
            printf("\n\n");
            pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0) - sizeof(LCN) + 
                                            pEntry->LcnsToFollow * sizeof(LCN));
        } else {
            pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0));
//         printf("0x%x free: 0x%x\n\n", iIndex, pEntry->AllocatedOrNextFree);
        }
//      printf("\n");

    }
} // DumpOpenAttributeTable


//+---------------------------------------------------------------------------
//
//  Function:   DumpTransactionTable
//
//  Synopsis:   
//
//  Arguments:  [pRestartTable] -- 
//
//  Returns:    
//
//  History:    9-11-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void DumpTransactionTable(PRESTART_TABLE pRestartTable)
{
    PTRANSACTION_ENTRY   pEntry = 0;
    int                  iIndex;
    int                  iIndex2;

    printf("\nTransactionTable\n");
    printf("EntrySize: 0x%x\n", pRestartTable->EntrySize);
    printf("NumberEntries: 0x%x\n", pRestartTable->NumberEntries);
    printf("NumberAllocated: 0x%x\n\n", pRestartTable->NumberAllocated);

    pEntry = (PTRANSACTION_ENTRY)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
    for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
        if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {

            printf("Entry 0x%x\n", (BYTE *)pEntry - (BYTE *)pRestartTable);
            printf("TransactionState: 0x%x (%s)\n", pEntry->TransactionState,
                   pEntry->TransactionState < gcTransStateMap ? gTransStateMap[pEntry->TransactionState] : "");
            printf("FirstLsn: 0x%I64x\n", pEntry->FirstLsn.QuadPart);
            printf("PreviousLsn: 0x%I64x\n", pEntry->PreviousLsn.QuadPart);
            printf("UndoNextLsn: 0x%I64x\n", pEntry->UndoNextLsn.QuadPart);
            printf("UndoRecords: 0x%x\n", pEntry->UndoRecords);
            printf("\n");
            
        }
        pEntry = (PTRANSACTION_ENTRY)((BYTE *)pEntry + sizeof(TRANSACTION_ENTRY));
        //      printf("\n");

    }
} // DumpTransactionTable


//+---------------------------------------------------------------------------
//
//  Function:   DumpMappingPair
//
//  Synopsis:   
//
//  Arguments:  [Buffer] -- 
//              [Length] -- 
//
//  Returns:    
//
//  History:    5-02-2000   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void DumpMappingPairs(PVOID Buffer, ULONG Length)
{
    BYTE * TempByte;
    BYTE * OldStart = NULL;
    ULONG ChangedLCNBytes;
    ULONG ChangedVCNBytes;
    ULONG Increment;
    ULONG Index;
    ULONG Increment2;
    ULONG LCN = 0;
    ULONG VCN = 0;

    //
    //  Try To Find Start
    //  

    for (Index=0; Index < Length; Index++) {

        TempByte = ((BYTE *)Buffer) + Index;

        while ((TempByte <= (BYTE*)Buffer + Length)  && (*TempByte != 0)) {

            ChangedLCNBytes = *TempByte >> 4;
            ChangedVCNBytes = *TempByte & (0x0f);

            if ((ChangedVCNBytes > 3) ||
                (ChangedLCNBytes > sizeof( LONGLONG )) || (ChangedVCNBytes > sizeof( LONGLONG ))) {

                //
                //  set tempbyte so we'll loop again if possible
                //  

                TempByte = (BYTE*)Buffer + Length  + 1;
                break;
            }

            TempByte += (ChangedLCNBytes + ChangedVCNBytes + 1);
        }

        if ((TempByte <= (BYTE*)Buffer + Length) && ((TempByte - (BYTE *)Buffer) > (LONG)Length - 8 )) {
            break;
        }
    }

    if (Index >= Length) {
        return;
    }
    
    printf( "Starting at offset: 0x%x\n", Index );

    TempByte = (BYTE *)Buffer + Index;

    //
    // walk byte stream
    //

    while(*TempByte != 0)
    {
        ChangedLCNBytes = *TempByte >> 4;
        ChangedVCNBytes = *TempByte & (0x0f);

        TempByte++;

        for(Increment=0, Index=0; Index < ChangedVCNBytes; Index++)
        {
            Increment+= *TempByte++ << (8 * Index);
        }

        for(Increment2 =0, Index=0; Index < ChangedLCNBytes; Index++)
        {
            Increment2+= *TempByte++ << (8 * Index);
        }

        //
        // if last bit is set (this is a neg) extend with 0xff
        //

        if (0x80 & (*(TempByte-1)))
        {
            for(; Index < sizeof(Increment2) ; Index++)
            {
                Increment2 += 0xff << (8 * Index);
            }
        }

        LCN += Increment2;
        printf( "LCN delta: 0x%x  VCN delta: 0x%x ", Increment2, Increment );

        for (Index = ChangedLCNBytes + ChangedVCNBytes + 1; Index > 0; Index--) {
            printf( "%02x", *(TempByte - Index));
        }
        printf( "\n" );

        VCN += Increment;

    } //endwhile

    printf("Total LcnDelta: 0x%x Total VCNDelta: 0x%x\n", LCN, VCN );

} // DumpMappingPair


//+---------------------------------------------------------------------------
//
//  Function:   DumpLogRecord
//
//  Synopsis: Dumps log records
//
//  Arguments:  [pRecord]  -- record to dump
//              [pAttrMap] -- ptr to open attribute table to use to translate
//                            TargetAttribute - if null no translation is done
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//              9-09-1998   benl   modified
//
//  Notes: either is a regular client record or a client restart area
//
//----------------------------------------------------------------------------

void DumpLogRecord(PLFS_RECORD_HEADER pRecord, OPEN_ATTR_MAP * pAttrMap)
{
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    BYTE *                   pData = 0;
    PRESTART_TABLE           pRestartTable = 0;
    PATTRIBUTE_NAME_ENTRY    pNameEntry = 0;
    POPEN_ATTRIBUTE_ENTRY_V0 pAttrEntry;
    LPWSTR                   lpName;
    MYENTRY *                pEntry;
    PRESTART_AREA            pRestartArea;

    printf("ThisLsn, PrevLsn, UndoLsn: 0x%I64x 0x%I64x 0x%I64x\n",
           pRecord->ThisLsn, pRecord->ClientPreviousLsn,
           pRecord->ClientUndoNextLsn);
    printf("Flags: 0x%x %s\n", pRecord->Flags, pRecord->Flags & LOG_RECORD_MULTI_PAGE ? "(multi-page)" : "");
    printf("ClientDataLength: 0x%x\n", pRecord->ClientDataLength);
    printf("TransactionId: 0x%x\n", pRecord->TransactionId);


    if (pRecord->RecordType == LfsClientRecord) {
        
        if (pRecord->ClientDataLength) {
            pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                                 sizeof(LFS_RECORD_HEADER));
    
            printf("Redo, Undo: (0x%x, 0x%x) (", pNtfsLog->RedoOperation,
                   pNtfsLog->UndoOperation);
            if (pNtfsLog->RedoOperation < gcOpMap ) {
                printf("%s, ", gOpMap[pNtfsLog->RedoOperation]);
            } else {
                printf("unknown, ");
            }
            if (pNtfsLog->UndoOperation < gcOpMap ) {
                printf("%s)\n", gOpMap[pNtfsLog->UndoOperation]);
            } else {
                printf("unknown)\n");
            }
    
            printf("RedoOffset RedoLength: (0x%x 0x%x)\n",
                   pNtfsLog->RedoOffset, pNtfsLog->RedoLength);
            printf("UndoOffset UndoLength: (0x%x 0x%x)\n",
                   pNtfsLog->UndoOffset, pNtfsLog->UndoLength);
    
    //        printf("0x%x 0x%x 0x%x 0x%x\n",pNtfsLog->RedoOffset,
    //               pNtfsLog->RedoLength, pNtfsLog->UndoLength, pNtfsLog->UndoOffset);
    
    
            printf("TargetAttribute: 0x%x\n", pNtfsLog->TargetAttribute);
            printf("RecordOffset: 0x%x\n", pNtfsLog->RecordOffset);
            printf("AttributeOffset: 0x%x\n", pNtfsLog->AttributeOffset);
            printf("ClusterBlockOffset: 0x%x\n", pNtfsLog->ClusterBlockOffset);
            printf("TargetVcn: 0x%I64x\n", pNtfsLog->TargetVcn);
    
            //
            //  If we were given an open attr map attempt to get the fileref from the
            //  target attribute
            //
    
            if (pAttrMap) {
                pEntry = pAttrMap->Lookup(pNtfsLog->TargetAttribute);
                if (pEntry) {
                    printf("FileRef: 0x%I64x\n", pEntry->llFileRef);
                    printf("Attribute: 0x%x\n", pEntry->AttrType);
                }
            }
    
    
            //
            //  Dump open-attr table
            //
    
    
            if (pNtfsLog->RedoOperation == OpenAttributeTableDump) {
                pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpOpenAttributeTable(pRestartTable);
            }
    
            if (pNtfsLog->RedoOperation == AttributeNamesDump) {
                pNameEntry = (PATTRIBUTE_NAME_ENTRY)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpAttributeNames(pNameEntry, pNtfsLog->RedoLength);
            }
    
            if (pNtfsLog->RedoOperation == OpenNonresidentAttribute) {
                pAttrEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                lpName = (LPWSTR)((BYTE *)pNtfsLog + pNtfsLog->UndoOffset);
                DumpOpenAttribute(pAttrEntry, lpName, pNtfsLog->UndoLength);
            }
    
            if (pNtfsLog->RedoOperation == DirtyPageTableDump) {
                pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpDirtyPageTable(pRestartTable);
            }
    
            if (pNtfsLog->RedoOperation == TransactionTableDump) {
                pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
                DumpTransactionTable(pRestartTable);
            }
    
    
    
            if (pNtfsLog->LcnsToFollow > WARNING_SIZE) {
                printf("LcnsToFollow: 0x%x is abnormally high probably not a valid record\n",
                       pNtfsLog->LcnsToFollow);
            } else {
                printf("LcnsForPage: ");
                for (iIndex=0; iIndex < pNtfsLog->LcnsToFollow; iIndex++) {
                    printf("0x%I64x ", pNtfsLog->LcnsForPage[iIndex]);
                }
            }
            printf("\n");
    
            if (gfDumpData) {

                //
                //  Its usually more useful to dump dwords except for the update
                //  filemappings case where its better to dump as bytes. If more
                //  exceptions popup make this logic a little nicer
                //
                
                if (pNtfsLog->RedoOperation && pNtfsLog->RedoLength) {
                    printf("Redo bytes\n");
                    pData = (BYTE *)pNtfsLog + pNtfsLog->RedoOffset;
                    if (pNtfsLog->RedoOperation == UpdateMappingPairs ) {
                        DumpRawBytes(pData, pNtfsLog->RedoLength);
                    } else {
                        DumpRawDwords((DWORD *)pData, pNtfsLog->RedoLength);
                    }
/*                    
                    if (pNtfsLog->RedoOperation == UpdateMappingPairs) {
                        printf("\n");
                        DumpMappingPairs( pData, pNtfsLog->RedoLength );
                        printf("\n");
                    }
*/                    
                }
                if (pNtfsLog->UndoOperation && pNtfsLog->UndoLength) {
                    printf("Undo bytes\n");
                    pData = (BYTE *)pNtfsLog + pNtfsLog->UndoOffset;
                    if (pNtfsLog->RedoOperation == UpdateMappingPairs ) { 
                        DumpRawBytes(pData, pNtfsLog->UndoLength);
                    } else {
                        DumpRawDwords((DWORD *)pData, pNtfsLog->UndoLength);
                    }
  /*
                    if (pNtfsLog->UndoOperation == UpdateMappingPairs) {
                        printf("\n");
                        DumpMappingPairs( pData, pNtfsLog->UndoLength );
                        printf("\n");
                    }
*/                    
                }
            }

        }
    } else if (pRecord->RecordType == LfsClientRestart) {
        printf("\nClient Restart Record\n");
        pRestartArea = (PRESTART_AREA) ( (BYTE *)pRecord + sizeof(LFS_RECORD_HEADER) );

        printf( "Major, Minor Version: 0x%x,0x%x\n", 
                pRestartArea->MajorVersion, 
                pRestartArea->MinorVersion
              );
        printf( "StartOfCheckpoint: 0x%8I64x\n\n", pRestartArea->StartOfCheckpoint );
        printf( "OpenAttributeTableLsn: 0x%08I64x 0x%x bytes\n", 
                pRestartArea->OpenAttributeTableLsn,
                pRestartArea->OpenAttributeTableLength
              );
        printf( "AttributeNamesLsn:     0x%08I64x 0x%x bytes\n", 
                pRestartArea->AttributeNamesLsn,
                pRestartArea->AttributeNamesLength
              );
        printf( "DirtyPageTableLsn:     0x%08I64x 0x%x bytes\n", 
                pRestartArea->DirtyPageTableLsn,
                pRestartArea->DirtyPageTableLength
              );
        printf( "TransactionTableLsn:   0x%08I64x 0x%x bytes\n", 
                pRestartArea->TransactionTableLsn,
                pRestartArea->TransactionTableLength 
              );
        printf( "\nLowestOpenUsn: 0x%I64x\n", pRestartArea->LowestOpenUsn );

        //
        //  Older logs don't have these 2 fields
        //


        if (pRecord->ClientDataLength >= FIELD_OFFSET(RESTART_AREA, CurrentLsnAtMount)) {
            printf( "CurrentLsnAtMount: 0x%I64x\n", pRestartArea->CurrentLsnAtMount );
            printf( "BytesPerCluster: 0x%x\n", pRestartArea->BytesPerCluster );
        }

    }
} // DumpLogRecord


//+---------------------------------------------------------------------------
//
//  Function:   DumpRecordPage
//
//  Synopsis:   Dump page header for a record page
//
//  Arguments:  [lpBuffer] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRecordPage(BYTE * lpBuffer)
{
    PLFS_RECORD_PAGE_HEADER pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
    PLFS_RECORD_HEADER      pRecord = 0;
    INT                     iNextRecord;

    printf("Record Page\n");
//    printf("LastLsn: 0x%I64x\n", pHdr->Copy.LastLsn);
    printf("Flags: 0x%x %s\n", pHdr->Flags, pHdr->Flags & LOG_PAGE_LOG_RECORD_END ?
           "(record end in page)" : "");
    printf("LastEndLsn: 0x%I64x (0x%x)\n", pHdr->Header.Packed.LastEndLsn,
           ((pHdr->Header.Packed.LastEndLsn.LowPart << 3) & 0xfff));

//    printf("0x%x\n", (pHdr->Header.Packed.LastEndLsn.QuadPart << gSeqNumberBits) >> (gSeqNumberBits - 3));

    printf("NextRecordOffset: 0x%x\n", pHdr->Header.Packed.NextRecordOffset);

    iNextRecord = (pHdr->Header.Packed.LastEndLsn.LowPart << 3) & (LOG_PAGE - 1);

    pRecord = (PLFS_RECORD_HEADER)(lpBuffer + iNextRecord);

    DumpLogRecord(pRecord, NULL);

} // DumpRecordPage



//+---------------------------------------------------------------------------
//
//  Function:   DumpPage
//
//  Synopsis:   Dump out the given page of the logfile
//
//  Arguments:  [lpBuffer] -- page sized buffer in log
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//              8-24-1998   benl   modified
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpPage(BYTE * lpBuffer)
{
    PMULTI_SECTOR_HEADER  pMultiHdr = (PMULTI_SECTOR_HEADER) lpBuffer;

//    DumpSectorHdr(pMultiHdr);

    //
    //  Determine the record type
    //

    if (strncmp((char *)(pMultiHdr->Signature), "RSTR", 4) == 0) {
        DumpRestartPage(lpBuffer);
    } else if (strncmp((char *)(pMultiHdr->Signature), "RCRD", 4) == 0) {
        DumpRecordPage(lpBuffer);
    }
} // DumpPage


//+---------------------------------------------------------------------------
//
//  Function:   DumpPageLastLsns
//
//  Synopsis: Dump the last LSN in all the pages in the logfile
//
//  Arguments:  [hFile] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:  Used for debug purposes only right now
//
//----------------------------------------------------------------------------

void DumpPageLastLsns(HANDLE hFile)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_PAGE_HEADER pNextHdr;
    PLFS_RECORD_HEADER      pRecord;
    int                     cbOffset;
    LSN                     lsn;
    int                     cbOffsetNext;

    memset(&ol, 0, sizeof(ol));

    ol.Offset = LOG_PAGE * 4;

    while (ol.Offset) {
        if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
            printf("ReadFile failed %d\n", GetLastError());
            return;
        }

        if (dwRead != LOG_PAGE) {
            printf("Only read: 0x%x\n", dwRead);
            return;
        }

        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

//        DumpPage(lpBuffer);


        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
        MYASSERT(pHdr->Header.Packed.NextRecordOffset <= LOG_PAGE);

        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) != 0) {
            printf("Not record at 0x%x!\n", ol.Offset);
        } else {
            printf("0x%x: LastEndLsn: 0x%I64x NextFreeOffset: 0x%x Flags: 0x%x \n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart, pHdr->Header.Packed.NextRecordOffset,
                   pHdr->Flags);
        }
        ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
    }

} // DumpLastLsns



//+---------------------------------------------------------------------------
//
//  Function:   ScanForLastLsn
//
//  Synopsis:   Starting from the current lsn hint walk fwd until we find the
//              the last lsn
//
//  Arguments:  [CurrentLsnHint] -- hint on where to start looking from
//
//  Returns: last lsn in logfile
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

LSN ScanForLastLsn(HANDLE hFile, LSN CurrentLsnHint)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    LSN                     LsnMax;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_HEADER      pNextRecord = 0;

    LsnMax.QuadPart = 0;
    memset(&ol, 0, sizeof(ol));

    //
    //  Start 1 page before the hint
    //

    if (CurrentLsnHint.QuadPart) {
        ol.Offset = (ULONG)((LsnToOffset(CurrentLsnHint.QuadPart) & (~(LOG_PAGE - 1))) - LOG_PAGE);
    } else {
        ol.Offset = LOG_PAGE * 4;
    }

//    printf("Starting at: Lsn: 0x%I64x Offset: 0x%x\n", CurrentLsnHint, ol.Offset);

    while (true) {
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            LsnMax.QuadPart = 0;
            return LsnMax;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

//        DumpPage(lpBuffer);

        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) != 0) {
            //          printf("Not record at 0x%x!\n", ol.Offset);
            ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
        } else {

            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
//                printf("0x%x: LastEndLsn: 0x%I64x\n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart);

                if (pHdr->Header.Packed.LastEndLsn.QuadPart >= LsnMax.QuadPart) {
                    ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
                    LsnMax.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;

                    //check the next one if there is one in this page
                    if (pHdr->Header.Packed.NextRecordOffset < LOG_PAGE - sizeof(LFS_RECORD_HEADER)) {
                        pNextRecord = (PLFS_RECORD_HEADER)(lpBuffer + pHdr->Header.Packed.NextRecordOffset);
                        if (pNextRecord->ThisLsn.QuadPart > LsnMax.QuadPart) {
                            LsnMax.QuadPart = pNextRecord->ThisLsn.QuadPart;
                        }
                    }
                } else {
                    break;
                }
            } else {
//                printf("0x%x: NoEndingLsn\n", ol.Offset);
                ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
            }
        }
    }
    return LsnMax;
} // ScanForLast



//+---------------------------------------------------------------------------
//
//  Function:   ScanForFirstLsn
//
//  Synopsis: Returns earliest LSN in file
//
//  Arguments:  [hFile]   -- logfile handle
//              [Verbose] -- 
//
//  Returns: lsn or 0 if failure occurs
//
//  History:    8-25-1998   benl   Created
//              7-29-1999   benl   modified
//
//  Notes: Be ca
//
//----------------------------------------------------------------------------

LSN ScanForFirstLsn(HANDLE hFile, bool Verbose)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_PAGE_HEADER pNextHdr;
    PLFS_RECORD_HEADER      pRecord;
    int                     cbOffset;
    LSN                     LsnMin;
    int                     cbOffsetNext;

    memset(&ol, 0, sizeof(ol));
    ol.Offset = LOG_PAGE * 4;
    LsnMin.QuadPart = 0;

    while (ol.Offset) {
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            LsnMin.QuadPart = 0;
            return LsnMin;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
/*
        if (pHdr->Header.Packed.NextRecordOffset > LOG_PAGE) {
            printf("0x%x 0x%x\n", pHdr->Header.Packed.NextRecordOffset,
                   ol.Offset );
        }

        MYASSERT(pHdr->Header.Packed.NextRecordOffset <= LOG_PAGE);
*/
        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) == 0) {
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END && Verbose) {
                printf( "0x%x: LastEndLsn: 0x%I64x NextFreeOffset: 0x%x Flags: 0x%x SeqNum: 0x%x \n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart, pHdr->Header.Packed.NextRecordOffset,
                       pHdr->Flags, LsnToSequenceNumber( pHdr->Header.Packed.LastEndLsn.QuadPart ) );
            }
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                if (LsnMin.QuadPart) {
                    if (LsnMin.QuadPart > pHdr->Header.Packed.LastEndLsn.QuadPart) {

                        //
                        //  If the last end lsn started before this page then its gone
                        //  since the page before this must have had a larger min lsn
                        //  so use the next lsn we find instead
                        //

                        if (LsnToOffset( pHdr->Header.Packed.LastEndLsn.QuadPart ) > ol.Offset ) {
                            LsnMin.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                        }
                    }
//                    LsnMin.QuadPart = min(LsnMin.QuadPart, pHdr->Header.Packed.LastEndLsn.QuadPart);
                } else {
                    LsnMin.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                }
            }

        }
        ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
    }                                                          

    return LsnMin;
} // ScanForFirstLsn


//+---------------------------------------------------------------------------
//
//  Function:   ScanForFirstLsn
//
//  Synopsis: Returns earliest LSN in file
//
//  Arguments:  [hFile]          -- logfile handle
//
//  Returns: lsn or 0 if failure occurs
//
//  History:    8-25-1998   benl   Created
//
//  Notes: Be ca
//
//----------------------------------------------------------------------------

LSN ScanForNextLsn(HANDLE hFile, LSN LsnStart )
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    PLFS_RECORD_PAGE_HEADER pNextHdr;
    PLFS_RECORD_HEADER      pRecord;
    int                     cbOffset;
    LSN                     LsnMin;
    int                     cbOffsetNext;

    memset(&ol, 0, sizeof(ol));
    ol.Offset = LOG_PAGE * 4;
    LsnMin.QuadPart = 0x7fffffffffffffffL;
    

    while (ol.Offset) {
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            LsnMin.QuadPart = LsnStart.QuadPart;        
            return LsnMin;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }

        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
/*
        if (pHdr->Header.Packed.NextRecordOffset > LOG_PAGE) {
            printf("0x%x 0x%x\n", pHdr->Header.Packed.NextRecordOffset,
                   ol.Offset );
        }

        MYASSERT(pHdr->Header.Packed.NextRecordOffset <= LOG_PAGE);
*/
        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) == 0) {
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
//                printf( "0x%x: LastEndLsn: 0x%I64x NextFreeOffset: 0x%x Flags: 0x%x SeqNum: 0x%x \n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart, pHdr->Header.Packed.NextRecordOffset,
//                       pHdr->Flags, LsnToSequenceNumber( pHdr->Header.Packed.LastEndLsn.QuadPart ) );
            }
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                
                if (LsnMin.QuadPart > pHdr->Header.Packed.LastEndLsn.QuadPart &&
                    LsnStart.QuadPart < pHdr->Header.Packed.LastEndLsn.QuadPart) {

                    //
                    //  If the last end lsn started before this page then its gone
                    //  since the page before this must have had a larger min lsn
                    //  so use the next lsn we find instead
                    //

                    if (LsnToOffset( pHdr->Header.Packed.LastEndLsn.QuadPart ) > ol.Offset ) {
                        LsnMin.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                    }
                }
            }

        }
        ol.Offset = (ol.Offset + LOG_PAGE) % gLogFileSize;
    }                                                          

    return LsnMin;
} // ScanForFirstLsn


//+---------------------------------------------------------------------------
//
//  Function:   ScanBackPagesForLastLsn
//
//  Synopsis:   Given an end LSN find an LSN on n pages before it
//
//  Arguments:  [hFile]      -- logfile handle
//              [CurrentLsn] -- ending lsn
//              [iPageRange] -- how many pages earlier we want an lsn from
//
//  Returns: LSN iPageRange pages earlier in the log from CurrentLsn
//
//  History:    8-25-1998   benl   Created
//
//  Notes: iPageRange is treated like a hint the precise distance will vary
//
//----------------------------------------------------------------------------

LSN ScanBackPagesForLastLsn(HANDLE hFile, LSN CurrentLsn, int iPageRange)
{
    BYTE                    lpBuffer[LOG_PAGE];
    DWORD                   dwRead;
    OVERLAPPED              ol;
    PLFS_RECORD_PAGE_HEADER pHdr;
    LSN                     Lsn;

    Lsn.QuadPart = 0;
    memset(&ol, 0, sizeof(ol));

    //
    //  Start iPageRange before the hint
    //
    ol.Offset = (ULONG)((LsnToOffset(CurrentLsn.QuadPart) & (~(LOG_PAGE - 1))) - (LOG_PAGE * iPageRange));

    printf("Starting at: Offset: 0x%x\n", ol.Offset);

    while (iPageRange) {
        if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
            printf("ReadFile failed %d\n", GetLastError());
            Lsn.QuadPart = 0;
            return Lsn;
        }

        if (dwRead != LOG_PAGE) {
            printf("Only read: 0x%x\n", dwRead);
            Lsn.QuadPart = 0;
            return Lsn;
        }

        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }
        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

        if (strncmp((CHAR *)(pHdr->MultiSectorHeader.Signature), "RCRD", 4) != 0) {
            printf("Not record at 0x%x!\n", ol.Offset);
        } else {
            if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                printf("0x%x: LastEndLsn: 0x%I64x\n", ol.Offset, pHdr->Header.Packed.LastEndLsn.QuadPart);
                Lsn.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                iPageRange--;
            } else {
                printf("0x%x: NoEndingLsn\n", ol.Offset);
            }
        }
        ol.Offset = (ol.Offset - LOG_PAGE) % gLogFileSize;
    }
    return Lsn;
} // ScanBackPagesForLastLsn


//+---------------------------------------------------------------------------
//
//  Function:   AddNewAttributes
//
//  Synopsis:   Add any new attributes from a dump or open to the table
//
//  Arguments:  [pRecord] -- 
//              [int]     -- 
//              [AttrMap] -- 
//
//  Returns:    
//
//  History:    9-09-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

void AddNewAttributes(PLFS_RECORD_HEADER pRecord, CMap<int, MYENTRY>  & AttrMap)
{  
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    PRESTART_TABLE           pRestartTable = 0;
    PATTRIBUTE_NAME_ENTRY    pNameEntry = 0;
    POPEN_ATTRIBUTE_ENTRY_V0 pAttrEntry;
    POPEN_ATTRIBUTE_ENTRY    pNewAttrEntry;
    LPWSTR                   lpName;
    int                      iEntry;
    MYENTRY                  MyEntry;

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));

        if (pNtfsLog->RedoOperation == OpenAttributeTableDump) {

            //
            //  Walk table adding allocated entries
            //

            pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);

            pAttrEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
            pNewAttrEntry = (POPEN_ATTRIBUTE_ENTRY)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));

            for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {

                if (pRestartTable->EntrySize == sizeof( OPEN_ATTRIBUTE_ENTRY_V0 )) {
                    
                    if (pAttrEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                        iEntry = (ULONG)((BYTE *)pAttrEntry - (BYTE *)pRestartTable);
                        memcpy(&(MyEntry.llFileRef), &(pAttrEntry->FileReference), sizeof(MyEntry.llFileRef));
                        MyEntry.AttrType = pAttrEntry->AttributeTypeCode;

                        if (AttrMap.Lookup(iEntry)) {
                            AttrMap.Replace(iEntry, MyEntry);
                        } else {
                            AttrMap.Insert(iEntry, MyEntry);
                        }
                    }
                    pAttrEntry++;

                } else {

                    if (pNewAttrEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                        iEntry = (ULONG)((BYTE *)pNewAttrEntry - (BYTE *)pRestartTable);
                        memcpy(&(MyEntry.llFileRef), &(pNewAttrEntry->FileReference), sizeof(MyEntry.llFileRef));
                        MyEntry.AttrType = pNewAttrEntry->AttributeTypeCode;

                        if (AttrMap.Lookup(iEntry)) {
                            AttrMap.Replace(iEntry, MyEntry);
                        } else {
                            AttrMap.Insert(iEntry, MyEntry);
                        }
                    }
                    pNewAttrEntry++;
                }

            }
        }

        if (pNtfsLog->RedoOperation == AttributeNamesDump) {
            pNameEntry = (PATTRIBUTE_NAME_ENTRY)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
//         DumpAttributeNames(pNameEntry, pNtfsLog->RedoLength);
        }

        if (pNtfsLog->RedoOperation == OpenNonresidentAttribute) {
            pAttrEntry = (POPEN_ATTRIBUTE_ENTRY_V0)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
            lpName = (LPWSTR)((BYTE *)pNtfsLog + pNtfsLog->UndoOffset);
            memcpy(&(MyEntry.llFileRef), &(pAttrEntry->FileReference), sizeof(MyEntry.llFileRef));
            MyEntry.AttrType = pAttrEntry->AttributeTypeCode;

            if (AttrMap.Lookup(pNtfsLog->TargetAttribute)) {
                AttrMap.Replace(pNtfsLog->TargetAttribute, MyEntry);
            } else {
                AttrMap.Insert(pNtfsLog->TargetAttribute, MyEntry);
            }
        }
    }
} // AddNewAttributes


//+---------------------------------------------------------------------------
//
//  Function:   MatchVcn
//
//  Synopsis:   Simple function to match a record against a VCN
//
//  Arguments:  [pRecord] -- ptr to head of record
//              [Context] -- actually vcn ptr to match
//
//  Returns: true if match
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchVcn(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    VCN_OFFSET *               pVcnPair = (VCN_OFFSET *) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    bool                     fRet = false;

    MYASSERT(pVcnPair);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));
        if (pNtfsLog->TargetVcn == pVcnPair->Vcn) {
            if ((pVcnPair->Offset == -1) || 
                (pVcnPair->Offset == pNtfsLog->ClusterBlockOffset)) {
                fRet = true;
            }
        }
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   MatchFileRef
//
//  Synopsis:   Match a given file ref
//
//  Arguments:  [pRecord] -- record to test
//              [Context] -- fileref to match
//
//  Returns:    
//
//  History:    9-11-1998   benl   Created
//
//  Notes:      Ignore SequenceNumber
//
//----------------------------------------------------------------------------

bool MatchFileRef(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PFILEREF_MATCH_CTX       pFileRefCtx = (PFILEREF_MATCH_CTX) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    bool                     fRet = false;
    MYENTRY *                pEntry;
    PFILE_REFERENCE          pFileRef1;
    PFILE_REFERENCE          pFileRef2;
    LONGLONG                 llFileRef;

    MYASSERT(pFileRefCtx);

    pFileRef1 = (PFILE_REFERENCE) (&(pFileRefCtx->llFileRef));

    AddNewAttributes(pRecord, *(pFileRefCtx->pAttrMap));

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));

        //
        //  Check directly using attribute table
        //


        pEntry = pFileRefCtx->pAttrMap->Lookup(pNtfsLog->TargetAttribute);
        if (pEntry)
        {
            pFileRef2 = (PFILE_REFERENCE) (&(pEntry->llFileRef));
            if ((pFileRef2->SegmentNumberLowPart == pFileRef1->SegmentNumberLowPart) &&
                (pFileRef2->SegmentNumberHighPart == pFileRef1->SegmentNumberHighPart)) {
                fRet = true;
            }
        }

        //
        //  Also check for someone with an equivalent vcn
        //

        if (pFileRefCtx->ClusterSize) {
            llFileRef = (LONGLONG)(pFileRef1->SegmentNumberLowPart) + 
                ((LONGLONG)(pFileRef1->SegmentNumberHighPart) << 32);

            //
            //  ClusterRatio is number of sector per cluster. FileRecord is 2 sectors big 0x400
            //

            if (pNtfsLog->TargetVcn ==  (llFileRef * 0x400 / pFileRefCtx->ClusterSize)) {
                if (pNtfsLog->ClusterBlockOffset * 0x200  == ((llFileRef * 0x400) % pFileRefCtx->ClusterSize)) {
                    fRet = true;
                }

            }

        }



    }

    return fRet;
} // MatchFileRef



//+---------------------------------------------------------------------------
//
//  Function:   MatchLcn
//
//  Synopsis:
//
//  Arguments:  [pRecord] --
//              [Context] --
//
//  Returns:
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchLcn(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    LCN *                    pLCN = (LCN *) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    bool                     fRet = false;

    MYASSERT(pLCN);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));
        if (pNtfsLog->LcnsToFollow) {
            for (iIndex=0; iIndex < pNtfsLog->LcnsToFollow; iIndex++) {
                if (pNtfsLog->LcnsForPage[iIndex] == *pLCN) {
                    fRet = true;
                    break;
                }
            }
        }

        if (pNtfsLog->RedoOperation == SetBitsInNonresidentBitMap) {

            PBITMAP_RANGE Range;

            Range = (PBITMAP_RANGE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset );
            if (Range->BitMapOffset == *pLCN % 0x8000) {
                fRet = true;
            }
        }

        if (pNtfsLog->RedoOperation == DirtyPageTableDump) {
            
            PRESTART_TABLE       pRestartTable;                
            PDIRTY_PAGE_ENTRY_V0 pEntry;
            ULONG                iIndex2;

            pRestartTable = (PRESTART_TABLE)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);

            pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pRestartTable + sizeof(RESTART_TABLE));
            for (iIndex=0; iIndex < pRestartTable->NumberEntries; iIndex++) {
                if (pEntry->AllocatedOrNextFree == RESTART_ENTRY_ALLOCATED) {
                    
                    for (iIndex2=0; iIndex2 < pEntry->LcnsToFollow; iIndex2++) {
                        if (pEntry->LcnsForPage[iIndex2] == *pLCN) {
                            fRet = true;
                            break;
                        }
                    }
                    pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0) - sizeof(LCN) + 
                                                    pEntry->LcnsToFollow * sizeof(LCN));
                } else {
                    pEntry = (PDIRTY_PAGE_ENTRY_V0)((BYTE *)pEntry + sizeof(DIRTY_PAGE_ENTRY_V0));
                }
            }
        }
    }

    return fRet;
} // MatchLcn


//+---------------------------------------------------------------------------
//
//  Function:   MatchAll
//
//  Synopsis:   Used to dump all lsns in range
//
//  Arguments:  [pRecord] --
//              [Context] --
//
//  Returns:
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchAll(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    return true;
} // MatchAll


//+---------------------------------------------------------------------------
//
//  Function:   MatchRestartDumps
//
//  Synopsis:   Match if part of a restart table dump
//
//  Arguments:  [pRecord] -- 
//              [Context] -- 
//
//  Returns:    
//
//  History:    9-16-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchRestartDumps(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    int                      iIndex;
    bool                     fRet = false;


    if (pRecord->RecordType == LfsClientRecord) {
        if (pRecord->ClientDataLength) {
            pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                                 sizeof(LFS_RECORD_HEADER));
            if (pNtfsLog->RedoOperation == OpenAttributeTableDump ||
                pNtfsLog->RedoOperation == AttributeNamesDump ||
                pNtfsLog->RedoOperation == DirtyPageTableDump ||
                pNtfsLog->RedoOperation == TransactionTableDump ) {
                    fRet = true;
            }
        }
    } else {

        //
        //  Always dump a restart area record
        //

        fRet = true;
    }
    return fRet;
} // MatchRestartDumps


//+---------------------------------------------------------------------------
//
//  Function:   MatchRecordNewAttributes
//
//  Synopsis:   Used to record open attributes during traversal
//
//  Arguments:  [pRecord] --  current record
//              [Context] --  an open attribute map
//
//  Returns:
//
//  History:       benl   Created
//              9-09-1998   benl   modified
//              9-09-1998   benl   modified
//
//  Notes: always returns false so nothing is printed
//
//----------------------------------------------------------------------------

bool MatchRecordNewAttributes(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    OPEN_ATTR_MAP * pMap = (OPEN_ATTR_MAP *) Context;

    AddNewAttributes(pRecord, *pMap);
    return false;
} // MatchRecordNewAttributes



//+---------------------------------------------------------------------------
//
//  Function:   MatchRecordNewAttributes
//
//  Synopsis:   Used to record open attributes during traversal
//
//  Arguments:  [pRecord] --  current record
//              [Context] --  an open attribute map
//
//  Returns:
//
//  History:       benl   Created
//              9-09-1998   benl   modified
//              9-09-1998   benl   modified
//
//  Notes: always returns false so nothing is printed
//
//----------------------------------------------------------------------------

bool MatchDeduceClusterSize(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PDEDUCE_CTX              DeduceCtx = (PDEDUCE_CTX) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    PINDEX_ENTRY             pEntry = NULL;
    
    MYASSERT(Context);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));

        if ((pNtfsLog->RedoOperation == AddIndexEntryAllocation) &&
            (pNtfsLog->RedoLength > 0)) {
            
            pEntry = (PINDEX_ENTRY)((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
            DeduceCtx->AddRecordFileRef = (LONGLONG)(pEntry->FileReference.SegmentNumberLowPart) +
                ((LONGLONG)(pEntry->FileReference.SegmentNumberHighPart) << 32);
            DeduceCtx->AddRecordLsn = pRecord->ThisLsn.QuadPart;

//            printf( "Found fileref add 0x%I64x at Lsn: 0x%I64x\n", DeduceCtx->AddRecordFileRef,
//                    DeduceCtx->AddRecordLsn );

        } else if ((pNtfsLog->RedoOperation == InitializeFileRecordSegment) &&
                   (pNtfsLog->RedoLength > 0) &&
                   (DeduceCtx->AddRecordLsn == pRecord->ClientPreviousLsn.QuadPart)) {

            DeduceCtx->AddRecordVcn = pNtfsLog->TargetVcn;
            DeduceCtx->AddRecordClusterOffset = pNtfsLog->ClusterBlockOffset;

            
//            printf( "Found file: 0x%I64x at VCN: 0x%I64x offset: 0x%x\n",
//                    DeduceCtx->AddRecordFileRef,
//                    DeduceCtx->AddRecordVcn, 
//                    DeduceCtx->AddRecordClusterOffset );

        }

    }

    return false;
} // MatchRecordNewAttributes


//+---------------------------------------------------------------------------
//
//  Function:   MatchGetClusterSize
//
//  Synopsis:   
//
//  Arguments:  [pRecord] -- 
//              [Context] -- 
//
//  Returns:    
//
//  History:    12-30-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchGetClusterSize(PLFS_RECORD_HEADER pRecord, 
                         PVOID Context)
{
    PULONG          pClusterSize = (PULONG) Context;
    PRESTART_AREA   pRestartArea;
    
    MYASSERT(Context);

    if (pRecord->RecordType == LfsClientRestart) {
        pRestartArea = (PRESTART_AREA) ( (BYTE *)pRecord + sizeof(LFS_RECORD_HEADER) );

        *pClusterSize = pRestartArea->BytesPerCluster;

    } else {
        printf( "MatchGetClusterSize: not a client restart area\n" );
    }

    //
    //  Never print the match
    //
    return false;
} // MatchGetClusterSize


//+---------------------------------------------------------------------------
//
//  Function:   MatchBit
//
//  Synopsis:   Match nonres bitmap involving the given bit
//
//  Arguments:  [pRecord] --
//              [Context] --
//
//  Returns:
//
//  History:       benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

bool MatchBit(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    ULONG *                  plBit = (ULONG *) Context;
    PNTFS_LOG_RECORD_HEADER  pNtfsLog;
    PBITMAP_RANGE            pRange;
    bool                     fRet = false;

    MYASSERT(plBit);

    if (pRecord->ClientDataLength) {
        pNtfsLog = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord +
                                             sizeof(LFS_RECORD_HEADER));
        if (pNtfsLog->RedoOperation == SetBitsInNonresidentBitMap ||
            pNtfsLog->RedoOperation == ClearBitsInNonresidentBitMap) {
            MYASSERT(pNtfsLog->RedoLength == sizeof(BITMAP_RANGE));
            pRange = (PBITMAP_RANGE) ((BYTE *)pNtfsLog + pNtfsLog->RedoOffset);
            if (pRange->BitMapOffset <= *plBit &&
                pRange->BitMapOffset + pRange->NumberOfBits >= *plBit) {
                fRet = true;
            }
        }
    }

    return fRet;
} // MatchBit


//+---------------------------------------------------------------------------
//
//  Function:   MatchTrace
//
//  Synopsis:   Function used to trace forward
//
//  Arguments:  [pRecord] -- record to check
//              [Context] -- prev. lsn to look for 
//
//  Returns:    
//
//  History:    7-29-1999   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchTrace(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PLSN LsnMatch = (PLSN) Context;

    if (pRecord->ClientPreviousLsn.QuadPart == LsnMatch->QuadPart) {
        LsnMatch->QuadPart = pRecord->ThisLsn.QuadPart;
        return true;
    } else {
        return false;
    }
} // MatchTrace


//+---------------------------------------------------------------------------
//
//  Function:   MatchTrackTransactions
//
//  Synopsis:   
//
//  Arguments:  [pRecord] -- 
//              [Context] -- 
//
//  Returns:    
//
//  History:    5-09-2001   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

bool MatchTrackTransactions(PLFS_RECORD_HEADER pRecord, PVOID Context)
{
    PTRANSACTION_MAP Map = (PTRANSACTION_MAP) Context;
    PNTFS_LOG_RECORD_HEADER NtfsRecord = NULL;
    LONGLONG StartLsn;

    if (pRecord->ClientDataLength) {

        //
        //  If commit remove the transaction from the log
        // 
                 
        NtfsRecord = (PNTFS_LOG_RECORD_HEADER)((BYTE *)pRecord + sizeof(LFS_RECORD_HEADER));
    }

    //
    //  leave quickly for checkpoint records
    //

    if ((pRecord->RecordType == LfsClientRestart) ||
        (NtfsRecord->RedoOperation == OpenAttributeTableDump) ||
        (NtfsRecord->RedoOperation == AttributeNamesDump) ||
        (NtfsRecord->RedoOperation == DirtyPageTableDump) ||
        (NtfsRecord->RedoOperation == TransactionTableDump)) {

        return false;
    }

    //
    //  Update the current state of the transaction - if its new the prev lsn will == 0
    //  which won't be present and we'll add a new record - this also happens for partial transactions
    //  at the start of the log
    //  

    if (Map->Lookup( pRecord->ClientPreviousLsn.QuadPart ) != NULL) {
        if (!Map->Remove( pRecord->ClientPreviousLsn.QuadPart )){
            printf( "problem\n" );
        }
        Map->Insert( pRecord->ThisLsn.QuadPart,  NtfsRecord ? NtfsRecord->RedoOperation : -1 );

//        printf( "replaced %I64x\n", pRecord->ThisLsn.QuadPart );
    } else {
//        printf( "added %I64x\n", pRecord->ThisLsn.QuadPart );
        Map->Insert( pRecord->ThisLsn.QuadPart,  NtfsRecord ? NtfsRecord->RedoOperation : -1 );
    }
    
    if (NtfsRecord) {

        //
        //  If commit remove the transaction from the log
        // 
                 
        if (NtfsRecord->RedoOperation == ForgetTransaction) {
                                            
            
            if (!Map->Remove( pRecord->ThisLsn.QuadPart )) {
                printf( "remove %I64x failed\n", pRecord->ThisLsn.QuadPart );
            } else {
//                printf( "remove %I64x\n", pRecord->ThisLsn.QuadPart );
            }
        }
    } 
    
    return false;
} // MatchTrackTransactions



//+---------------------------------------------------------------------------
//
//  Function:   ScanLsnRangeForMatch
//
//  Synopsis:   Walk the range of LSN records and dump any that have to
//              do with the given VCN
//
//  Arguments:  [hFile]    -- logfile handle
//              [LsnFirst] -- beginning of LSN range
//              [LsnMax]   -- end of LSN range
//              [Vcn]      -- vcn to search
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:     VCN is the TargetVcn in the NTFS_LOG_RECORD_HEADER
//
//----------------------------------------------------------------------------

void ScanLsnRangeForMatch(HANDLE hFile, LSN LsnFirst, LSN LsnMax,
                          PMATCH_FUNC pMatchFunc, PVOID MatchContext)
{
    BYTE                    lpBuffer[LOG_PAGE];
    BYTE *                  pLargeBuffer = 0;
    INT                     cbOffset;
    INT                     cbPage;
    INT                     cbPageOffset;
    OVERLAPPED              ol;
    DWORD                   dwRead;
    PLFS_RECORD_HEADER      pRecord;
    PLFS_RECORD_HEADER      pNextRecord;
    bool                    fStartNextPage = false;
    int                     iIndex;
    LSN                     LsnNext = LsnFirst;
    int                     cbToRead;
    PNTFS_LOG_RECORD_HEADER pNtfsLog;
    int                     cbLargeBuf;
    CMap<int, MYENTRY>      AttrMap;
    PLFS_RECORD_PAGE_HEADER pHdr;
    ULONG                   ulTemp;
    ULONG                   SeqNum;
    bool                    ValidRecord = TRUE;


    memset(&ol, 0, sizeof(ol));

    do {

        cbOffset = (ULONG) LsnToOffset(LsnNext.QuadPart);
        cbPage = cbOffset & ~(LOG_PAGE - 1);

        //
        // Load the 1st page its in
        //

        ol.Offset = cbPage;
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            return;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            printf( "Failed to resolve USA sequence in page: 0x%x\n", cbPage );
            return;
        }
        fStartNextPage = false;

        do {
            LsnFirst = LsnNext;

            SeqNum = LsnToSequenceNumber( LsnFirst.QuadPart );
            cbOffset = (ULONG) LsnToOffset(LsnFirst.QuadPart);
            cbPageOffset = cbOffset & (LOG_PAGE - 1);
            pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset);


            if (pRecord->ThisLsn.QuadPart != LsnFirst.QuadPart) {

                //
                //  Let check the ping pong pages
                //  

                ulTemp = ol.Offset;
                ol.Offset = 0x2000;

                if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                    printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                    return;
                }
                ol.Offset = ulTemp;
                if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                {
                    break;
                }

                pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset) ;

                //
                //  If the ping-pong is no good go back to the old buffer and do
                //  a seq number jump
                //

                if (pRecord->ThisLsn.QuadPart != LsnFirst.QuadPart) {
                    
                    ValidRecord = FALSE;

                    if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                        printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                        return;
                    }
                    if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                    {
                        break;
                    }
                    pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset) ;

                    printf("Warning: Lsn in record 0x%I64x doesn't match Lsn: 0x%I64x!!\n\n", pRecord->ThisLsn,
                           LsnFirst);

                    //
                    //  Start next page
                    // 
                    
                    pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;
                    if (pHdr->Flags & LOG_PAGE_LOG_RECORD_END) {
                        LsnNext.QuadPart = pHdr->Header.Packed.LastEndLsn.QuadPart;
                    } else {
                        fStartNextPage = true;
                    }

                } else {
                    ValidRecord = TRUE;
                }
            } else {
                ValidRecord = TRUE;
            }

            //
            //   If its in the page dump it directly o.w get the complete multipage record
            //

            if (ValidRecord) {
                if (!(pRecord->Flags & LOG_RECORD_MULTI_PAGE)) {

                    //
                    //  Add to OpenAttributeTable if necc.
                    //

                    AddNewAttributes(pRecord, AttrMap);

                    if (pMatchFunc(pRecord, MatchContext)) {
                        
                        printf("Offset: 0x%x\n", cbOffset);
                        DumpLogRecord(pRecord, &AttrMap);
                        printf("\n");

                    }
                    //advance to next
                    pNextRecord = (PLFS_RECORD_HEADER)((BYTE *)pRecord +
                                                       pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER));
                    if ((BYTE *)pNextRecord > &lpBuffer[LOG_PAGE - sizeof(LFS_RECORD_HEADER)]) {
                        fStartNextPage = true;
                    } else {
                        LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;

                        if (LsnNext.QuadPart == 0) {
                            fStartNextPage = true;
                        }
                    }
                } else {
                    //
                    //  Brute force scatter-gather
                    //


                    cbLargeBuf = 2 * sizeof(LFS_RECORD_HEADER) + pRecord->ClientDataLength;
                    if (LOG_PAGE - cbPageOffset > cbLargeBuf) {
                        printf("ClientDataLength 0x%x is invalid!\n", 
                               pRecord->ClientDataLength);
                        return;
                    }
                    pLargeBuffer = new BYTE[cbLargeBuf];
                    memcpy(pLargeBuffer, pRecord, LOG_PAGE - cbPageOffset);
                    pRecord = (PLFS_RECORD_HEADER) pLargeBuffer;
                    pLargeBuffer += LOG_PAGE - cbPageOffset;

                    for (iIndex = pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER) -
                         (LOG_PAGE - cbPageOffset);
                        iIndex > 0;
                        iIndex -= (LOG_PAGE - TOTAL_PAGE_HEADER)) {
                        ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
                        if (ol.Offset == 0) {
                            ol.Offset = LOG_PAGE * 4;
                        }

                        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                            printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                            return;
                        }
                        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                        {
                            break;
                        }
                        pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

                        //check if really need the ping-pong page
                        if ((pHdr->Flags & LOG_PAGE_LOG_RECORD_END) &&
                            (pHdr->Header.Packed.LastEndLsn.QuadPart < LsnFirst.QuadPart)) {

                            printf("At ping-pong\n");

                            ulTemp = ol.Offset;
                            ol.Offset = 0x2000;

                            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                                printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                                return;
                            }
                            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                            {
                                printf( "Invalid USA sequence\n" );
                                break;
                            }
                            pHdr = (PLFS_RECORD_PAGE_HEADER) lpBuffer;

                            ol.Offset = ulTemp;
                        }

                        cbToRead = min(LOG_PAGE - TOTAL_PAGE_HEADER,
                                       iIndex + sizeof(LFS_RECORD_HEADER));
                        memcpy(pLargeBuffer, lpBuffer + TOTAL_PAGE_HEADER, cbToRead);
                        pLargeBuffer += cbToRead;
                    }

                    if (pRecord->ClientDataLength) {

                        //
                        //  Add to OpenAttributeTable if necc.
                        //

                        AddNewAttributes(pRecord, AttrMap);

                        if (pMatchFunc(pRecord, MatchContext)) {
                            printf("Offset: 0x%x\n", cbOffset);
                            DumpLogRecord(pRecord, &AttrMap);
                            printf("\n");
                        }
                    }

                    pNextRecord = (PLFS_RECORD_HEADER)(pLargeBuffer - sizeof(LFS_RECORD_HEADER));
                    if (-1 * iIndex < sizeof(LFS_RECORD_HEADER)) {
                        fStartNextPage = true;
                    } else {
                        LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;
                    }
                    //remove the temp buffer and then restore the regular buffer
                    pLargeBuffer = (BYTE *)pRecord;
                    delete[] pLargeBuffer;
                }
            }

            if (fStartNextPage) {
                ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
                if (ol.Offset == 0) {
                    ol.Offset = LOG_PAGE * 4;
                }

                if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                    return;
                }
                if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
                {
                    break;
                }
                pRecord = (PLFS_RECORD_HEADER) (lpBuffer + TOTAL_PAGE_HEADER);
                LsnNext.QuadPart = pRecord->ThisLsn.QuadPart;
                fStartNextPage = false;
            }

            //  Check for a sequence jump 
            //  if so then we need to rescam if it  has changed by 
            //  more than 1
            //  

            if (LsnToSequenceNumber( LsnNext.QuadPart ) != SeqNum ) {

                printf( "Sequence number jump 0x%x to 0x%x for LSN: 0x%I64x!\n\n", SeqNum, LsnToSequenceNumber( LsnNext.QuadPart ), LsnNext.QuadPart );

                if (LsnToSequenceNumber( LsnNext.QuadPart ) != SeqNum + 1) {

                    //  
                    //  Set to current so we exit this loop and scan for the next 
                    //  LSN
                    // 

                    LsnNext = LsnFirst;
                }
            }

        } while (LsnFirst.QuadPart < LsnMax.QuadPart && LsnFirst.QuadPart < LsnNext.QuadPart );
        
        LsnNext = ScanForNextLsn( hFile, LsnFirst );
        printf( "skip to 0x%I64x\n", LsnNext );

    } while ( LsnNext.QuadPart != LsnFirst.QuadPart && LsnNext.QuadPart < LsnMax.QuadPart );

    printf("At end page, Lsn: 0x%x 0x%I64x 0x%I64x\n", ol.Offset, LsnFirst, LsnNext);

} // ScanLsnRangeForMatch


//+---------------------------------------------------------------------------
//
//  Function:   TraceTransaction
//
//  Synopsis:   Given an lsn show the transaction its involved in
//
//  Arguments:  [hFile]    -- logfile handle
//              [Lsn]      -- lsn to check
//              [LsnFirst] -- 
//              [LsnMax]   -- ending lsn in the logfile
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//              7-29-1999   benl   modified
//
//  Notes: First use prev back pointers to find the beginning of the transaction
//         then just scan forwards for all pieces
//
//----------------------------------------------------------------------------

void TraceTransaction(HANDLE hFile, LSN Lsn, LSN LsnFirst, LSN LsnMax)                                       
{
    BYTE                    lpBuffer[LOG_PAGE];
    BYTE *                  pLargeBuffer = 0;
    INT                     cbOffset;
    INT                     cbPage;
    INT                     cbPageOffset;
    OVERLAPPED              ol;
    DWORD                   dwRead;
    PLFS_RECORD_HEADER      pRecord;
    PLFS_RECORD_HEADER      pNextRecord;
    bool                    fStartNextPage = false;
    int                     iIndex;
    LSN                     LsnTemp;
    LSN                     LsnNext;
    int                     cbToRead;
    CMap<int, MYENTRY>      AttrMap;


    memset(&ol, 0, sizeof(ol));

    do {
        cbOffset = (ULONG)(LsnToOffset(Lsn.QuadPart));
        cbPage = cbOffset & ~(LOG_PAGE - 1);
        cbPageOffset = cbOffset & (LOG_PAGE - 1);

        //
        // Load the 1st page its in
        //

        ol.Offset = cbPage;
        if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
            return;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, ol.Offset))
        {
            break;
        }
        pRecord = (PLFS_RECORD_HEADER)(lpBuffer + cbPageOffset);
        printf("ThisLsn, PrevLsn, UndoLsn: 0x%I64x 0x%I64x 0x%I64x\n",
               pRecord->ThisLsn, pRecord->ClientPreviousLsn,
               pRecord->ClientUndoNextLsn);
        fflush( stdout );

        MYASSERT(pRecord->ThisLsn.QuadPart == Lsn.QuadPart);
        if (pRecord->ClientPreviousLsn.QuadPart) {
            Lsn.QuadPart = pRecord->ClientPreviousLsn.QuadPart;
        }
    } while (pRecord->ClientPreviousLsn.QuadPart);

    printf("\n");

    //
    //  Buildup attribute names
    //
//    ScanLsnRangeForMatch(hFile, LsnFirst, Lsn, MatchRecordNewAttributes, &AttrMap);

    LsnTemp.QuadPart = 0;

    ScanLsnRangeForMatch( hFile, Lsn, LsnMax, MatchTrace, &LsnTemp );

    /*
    //
    //  Now Scan Forward dumping pieces - Lsn is set to LSN to match 0 to start and
    //  LsnNext is the next lsn to look at 
    //
    
    LsnNext = Lsn;
    Lsn.QuadPart = 0;
    
    do {
        LsnTemp = LsnNext;

        cbOffset = (ULONG)(LsnToOffset(LsnTemp.QuadPart));
        cbPageOffset = cbOffset & (LOG_PAGE - 1);
        pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset);

        if (pRecord->ThisLsn.QuadPart != LsnTemp.QuadPart) {
            ULONG ulTemp;

            //
            //  Let check the ping pong pages
            //  

            ulTemp = ol.Offset;
            ol.Offset = 0x2000;

            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                return;
            }
            ol.Offset = ulTemp;
            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer))
            {
                break;
            }

            pRecord = (PLFS_RECORD_HEADER) (lpBuffer + cbPageOffset) ;

            //
            //  If the ping-pong is no good go back to the old buffer and do
            //  a seq number jump
            //

            if (pRecord->ThisLsn.QuadPart != LsnFirst.QuadPart) {

                printf("Warning: Lsn in record 0x%I64x doesn't match Lsn: 0x%I64x!!\n\n", pRecord->ThisLsn,
                       LsnFirst);
                break;
            }
        }

        //
        //   If its in the page dump it directly o.w get the complete multipage record
        //

        if (!(pRecord->Flags & LOG_RECORD_MULTI_PAGE)) {
            //
            //  Check for matching Lsn prev
            //

            AddNewAttributes(pRecord, AttrMap);

            if (pRecord->ClientPreviousLsn.QuadPart == Lsn.QuadPart) {
                printf("Offset: 0x%x\n", cbOffset);
                DumpLogRecord(pRecord, &AttrMap);
                printf("\n");
                Lsn = pRecord->ThisLsn;
            }
            //advance to next
            pNextRecord = (PLFS_RECORD_HEADER)((BYTE *)pRecord +
                                               pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER));
            if ((BYTE *)pNextRecord > &lpBuffer[LOG_PAGE - sizeof(LFS_RECORD_HEADER)]) {
                fStartNextPage = true;
            } else {
                LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;
            }
        } else {
            //
            //  Brute force scatter-gather
            //

            pLargeBuffer = new BYTE[2 * sizeof(LFS_RECORD_HEADER) + pRecord->ClientDataLength];
            memcpy(pLargeBuffer, pRecord, LOG_PAGE - cbPageOffset);
            pRecord = (PLFS_RECORD_HEADER) pLargeBuffer;
            pLargeBuffer += LOG_PAGE - cbPageOffset;

            for (iIndex = pRecord->ClientDataLength + sizeof(LFS_RECORD_HEADER) -
                 (LOG_PAGE - cbPageOffset);
                iIndex > 0;
                iIndex -= (LOG_PAGE - TOTAL_PAGE_HEADER)) {
                ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
                if (ol.Offset == 0) {
                    ol.Offset = LOG_PAGE * 4;
                }

                if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                    printf("0x%x 0x%x\n", pRecord, pLargeBuffer);
                    return;
                }
                if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer))
                {
                    break;
                }
                cbToRead = min(LOG_PAGE - TOTAL_PAGE_HEADER,
                               iIndex + sizeof(LFS_RECORD_HEADER));
                memcpy(pLargeBuffer, lpBuffer + TOTAL_PAGE_HEADER, cbToRead);
                pLargeBuffer += cbToRead;
            }

            AddNewAttributes(pRecord, AttrMap);

            if (pRecord->ClientPreviousLsn.QuadPart == Lsn.QuadPart) {
                printf("Offset: 0x%x\n", cbOffset);
                DumpLogRecord(pRecord, &AttrMap);
                printf("\n");
                Lsn = pRecord->ThisLsn;
            }

            pNextRecord = (PLFS_RECORD_HEADER)(pLargeBuffer - sizeof(LFS_RECORD_HEADER));
            if (-1 * iIndex < sizeof(LFS_RECORD_HEADER)) {
                fStartNextPage = true;
            } else {
                LsnNext.QuadPart = pNextRecord->ThisLsn.QuadPart;
            }

            //remove the temp buffer and then restore the regular buffer
            pLargeBuffer = (BYTE *)pRecord;
            delete[] pLargeBuffer;
        }

        if (fStartNextPage) {
            ol.Offset =  (ol.Offset + LOG_PAGE) % gLogFileSize;
            if (ol.Offset == 0) {
                ol.Offset = LOG_PAGE * 4;
            }

            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, &ol)) {
                return;
            }
            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer))
            {
                break;
            }
            pRecord = (PLFS_RECORD_HEADER) (lpBuffer + TOTAL_PAGE_HEADER);
            LsnNext.QuadPart = pRecord->ThisLsn.QuadPart;
            fStartNextPage = false;
        }
    } while (LsnTemp.QuadPart < LsnMax.QuadPart  );

    printf("At end page, Lsn: 0x%x 0x%I64x\n", ol.Offset, LsnTemp);
*/
} // TraceTransaction


//+---------------------------------------------------------------------------
//
//  Function:   FindClusterRatio
//
//  Synopsis:   
//
//  Arguments:  (none)
//
//  Returns:    
//
//  History:    12-30-1998   benl   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

ULONG FindClusterRatio(HANDLE hFile)
{
    BYTE                        lpRestartPage1[LOG_PAGE];
    BYTE                        lpRestartPage2[LOG_PAGE];
    LSN                         LsnRestart = {0,0};
    PLFS_RESTART_PAGE_HEADER    pRestartHdr;
    PLFS_RESTART_AREA           pLfsRestart1 = 0;
    PLFS_RESTART_AREA           pLfsRestart2 = 0;
    int                         iIndex;
    PLFS_CLIENT_RECORD          pClient = 0;
    ULONG                       ulClusterSize = 0;
    LSN                         LsnEnd;
    LSN                         LsnStart;
    DEDUCE_CTX                  DeduceCtx;


    __try {
        if (0xFFFFFFFF == SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) {
            printf("SetFilePtr failed %d\n", GetLastError());
            __leave;
        }

        //
        //  Read the two restart pages
        //

        if (!MyReadFile(hFile, lpRestartPage1, LOG_PAGE, NULL)) {
            __leave;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpRestartPage1, 0)) {
            __leave;
        }

        if (!MyReadFile(hFile, lpRestartPage2, LOG_PAGE, NULL)) {
            __leave;
        }
        if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpRestartPage2, 0x1000)) {
            __leave;
        }

        //
        //  Use the newer one of the two restart areas
        //

        pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpRestartPage1;
        pLfsRestart1 = (PLFS_RESTART_AREA) (lpRestartPage1 + pRestartHdr->RestartOffset);
        pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpRestartPage2;
        pLfsRestart2 = (PLFS_RESTART_AREA) (lpRestartPage2 + pRestartHdr->RestartOffset);

        if (pLfsRestart2->CurrentLsn.QuadPart > pLfsRestart1->CurrentLsn.QuadPart ) {
            pLfsRestart1 = pLfsRestart2;
        }

        //
        //  Find the Lsn for the current restart area
        //

        pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart1 + pLfsRestart1->ClientArrayOffset);

        for (iIndex=0; iIndex < pLfsRestart1->LogClients; iIndex++) {
            if (wcsncmp( pClient->ClientName, L"NTFS", 4 ) == 0) {
                LsnRestart.QuadPart = pClient->ClientRestartLsn.QuadPart;
            }
            pClient = pClient++;
        }

        if (LsnRestart.QuadPart == 0) {
            __leave;
        }

        printf( "Client restart area LSN: 0x%I64x\n", LsnRestart );
        ScanLsnRangeForMatch( hFile, LsnRestart, LsnRestart, MatchGetClusterSize, &ulClusterSize );

        //
        //  If this was an old logfile try to infer the cluster size anyway 
        //

        if (0 == ulClusterSize) {
            LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
            if (LsnStart.QuadPart == 0) {
                __leave;
            }
            LsnEnd = ScanForLastLsn(hFile, LsnStart);
            if (LsnEnd.QuadPart == 0) {
                __leave;
            }

            printf( "Scanning for cluster size\n" );
            memset( &DeduceCtx, 0, sizeof( DeduceCtx ) );
            ScanLsnRangeForMatch( hFile, LsnStart, LsnEnd, MatchDeduceClusterSize, &DeduceCtx );
            if (DeduceCtx.AddRecordVcn != 0 ) {
                ulClusterSize = (ULONG)(DeduceCtx.AddRecordFileRef / DeduceCtx.AddRecordVcn * 2);
            }
        }
    } __finally
    {
    }

    return ulClusterSize;
} // FindClusterRatio

//+---------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis: Reads restart pages determines more current one and records
//            global values
//
//  Arguments:  [hFile] --  handle to logfile
//              [Lcb]   --  lcb for log
//
//  Returns: true if successfule
//
//  History:    8-24-1998   benl   Created
//              8-25-1998   benl   modified
//
//  Notes: TODO: move all data from globals into lcb
//
//----------------------------------------------------------------------------

bool InitGlobals(HANDLE hFile, LOGCB & Logcb)
{
    BYTE                     lpBuffer[LOG_PAGE];
    PLFS_RESTART_PAGE_HEADER pRestartHdr = (PLFS_RESTART_PAGE_HEADER) lpBuffer;
    PLFS_RESTART_AREA        pLfsRestart = 0;
    int                      iIndex;
    PLFS_CLIENT_RECORD       pClient = 0;
    DWORD                    dwRead;
    OVERLAPPED               ol;

    memset(&ol, 0, sizeof(ol));

    //
    //  Read 1st restart area
    //

    if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
        printf("ReadFile failed %d\n", GetLastError());
        return false;
    }

    MYASSERT(strncmp((char *)(pRestartHdr->MultiSectorHeader.Signature), "RSTR", 4) == 0);

    pLfsRestart = (PLFS_RESTART_AREA) (lpBuffer + pRestartHdr->RestartOffset);
    gSeqNumberBits = pLfsRestart->SeqNumberBits;
    gLogFileSize = (ULONG)pLfsRestart->FileSize;
    Logcb.CurrentLsn = pLfsRestart->CurrentLsn;

    pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart + pLfsRestart->ClientArrayOffset);
    MYASSERT(1 == pLfsRestart->LogClients);
    Logcb.FirstLsn = pClient->OldestLsn;
    //
    //  Read 2nd restart area
    //

    ol.Offset += LOG_PAGE;

    if (!ReadFile(hFile, lpBuffer, LOG_PAGE, &dwRead, &ol)) {
        printf("ReadFile failed %d\n", GetLastError());
        return false;
    }

    MYASSERT(strncmp((char *)(pRestartHdr->MultiSectorHeader.Signature), "RSTR", 4) == 0);

    pLfsRestart = (PLFS_RESTART_AREA) (lpBuffer + pRestartHdr->RestartOffset);
    if (pLfsRestart->CurrentLsn.QuadPart > Logcb.CurrentLsn.QuadPart) {
        gSeqNumberBits = pLfsRestart->SeqNumberBits;
        gLogFileSize = (ULONG)(pLfsRestart->FileSize);
        Logcb.CurrentLsn = pLfsRestart->CurrentLsn;

        pClient = (PLFS_CLIENT_RECORD)((BYTE *)pLfsRestart + pLfsRestart->ClientArrayOffset);
        MYASSERT(1 == pLfsRestart->LogClients);
        Logcb.FirstLsn = pClient->OldestLsn;
    }

    return true;
} // InitGlobals


//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void Usage()
{
    printf("Usage: dumplog logname [-l lsn] [-h] [-d] [-r] [-p pages] [-v vcn [clusterblockoffset]] [-t lsn] [-a]  [-L lcn] [-f fileref]\n");
    printf("    -p dumps the given number of pages of lsn records from the end \n");
    printf("       of the log\n");
    printf("    -h dumps the headers of the log including the 2 ping-pong pages\n");
    printf("    -d dumps the redo/undo data\n");
    printf("    -l lsn dumps the log record for the given lsn, the lsn should be in hex\n");
    printf("    -v vcn search for log records dealing with the given vcn in hex optionally\n");
    printf("       a cluster block offset can also be given\n");
    printf("    -t lsn dumps the transaction containing the given lsn which\n");
    printf("       should be in hex\n");
    printf("    -a dump the entire log\n");
    printf("    -L lcn searchs for log records containing the given lcn in hex\n");
    printf("    -f fileref seearchs for log records containing the given fileref \n");
    printf("       [ignores seq number]\n");
    printf("    -r scan for restart table dumps\n");
    printf("    -c [cluster size in hex] override cluster size rather than finding it\n");
    printf("    -R [start stop] dump records in range\n");
    printf("    -s verbose output during scans (shows last lsn for all pages) \n" );
    printf("    -T scan for uncommited transactions in the log\n" );
} // Usage


//+---------------------------------------------------------------------------
//
//  Function:   ParseParams
//
//  Synopsis:   Parse params and print a usage message
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:      Sets globals flags
//
//----------------------------------------------------------------------------

bool ParseParams(int argc, TCHAR * argv[])
{
    int         iIndex;
    bool        fRet = false;
    LONGLONG    llTemp;

    __try
    {
        if (argc < 2 || _tcscmp(argv[1], _T("-?")) == 0) {
            Usage();
            __leave;
        }

        //
        //   init globals
        //

        gVcnPairToMatch.Vcn = 0;
        gVcnPairToMatch.Offset = -1;



        for (iIndex=2; iIndex < argc; iIndex++) {
            if ((_tcslen(argv[iIndex]) > 1) &&  argv[iIndex][0] == _T('-')) {
                if (argv[iIndex][1] == _T('p') && iIndex < argc - 1) {
                    giPagesBackToDump = _ttoi(argv[iIndex+1]);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('l') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gLsnToDump.QuadPart);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('v') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gVcnPairToMatch.Vcn);
                    iIndex++;
                    if ((iIndex + 1 < argc) && (argv[iIndex+1][0] != _T('-'))) {
                        HexStrToInt64(argv[iIndex+1], llTemp);
                        gVcnPairToMatch.Offset = (ULONG)llTemp;
                        iIndex++;
                    }
                } else if (argv[iIndex][1] == _T('t') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gLsnToTrace.QuadPart);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('L') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], gLcnToMatch);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('b') && iIndex < argc - 1) {
                    HexStrToInt64(argv[iIndex+1], llTemp);
                    glBitToMatch = (ULONG)llTemp;
                    iIndex++;
                } else if (argv[iIndex][1] == _T('h')) {
                    gfPrintHeaders = true;
                } else if (argv[iIndex][1] == _T('a')) {
                    gfDumpEverything = true;
                } else if (argv[iIndex][1] == _T('d')) {
                    gfDumpData = true;
                } else if (argv[iIndex][1] == _T('r')) {
                    gfScanForRestarts = true;
                } else if (argv[iIndex][1] == _T('f') && iIndex < argc - 1)  {
                    HexStrToInt64(argv[iIndex+1], gllFileToMatch);
                    iIndex++;
                } else if (argv[iIndex][1] == _T('c') && (iIndex < argc - 1)) {
                    HexStrToInt64(argv[iIndex+1], llTemp);
                    iIndex++;
                    gulClusterSize = (ULONG)llTemp;
                } else if (argv[iIndex][1] == _T('R') && (iIndex < argc - 2)) {
                    HexStrToInt64(argv[iIndex+1], gllRangeStart.QuadPart);
                    HexStrToInt64(argv[iIndex+2], gllRangeEnd.QuadPart);
                    iIndex+=2;
                } else  if (argv[iIndex][1] == _T('s')) {
                    gVerboseScan = true;
                } else  if (argv[iIndex][1] == _T('T')) {
                    gfScanTransactions = true;
                } else {
                    Usage();
                    __leave;
                }
            } else {
                Usage();
                __leave;
            }
        }

        fRet = true;

    } __finally
    {
    }

    return fRet;
} // ParseParams


//+---------------------------------------------------------------------------
//
//  Function:   _tmain
//
//  Synopsis:
//
//  Arguments:  [argc] --
//              [argv] --
//
//  Returns:
//
//  History:    8-24-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

extern "C" {
int __cdecl _tmain (int argc, TCHAR *argv[])
{
    HANDLE              hFile;
    BYTE                lpBuffer[LOG_PAGE];
    DWORD               dwRead;
    int                 iIndex;
    LOGCB               Logcb;
    LSN                 LsnEnd;
    LSN                 LsnStart;
    LONGLONG            llOffset;
    FILEREF_MATCH_CTX   FileRefMatchCtx;
    OPEN_ATTR_MAP       AttrMap;
    ULONG               ulClusterSize = 0;

    if (!ParseParams(argc, argv)) {
        return 1;
    }


    hFile = CreateFile(argv[1], GENERIC_READ, 0, NULL, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        _tprintf(_T("Failed to open %s, GLE=%d\n"), argv[1], GetLastError());
        return 1;
    }
    
    if (!InitGlobals(hFile, Logcb)) {
        return 1;
    }
    
    //
    //  Try to find the sectors per cluster which are in the restart pages
    //
    
    ulClusterSize = FindClusterRatio( hFile );    
    printf("Cluster Size: 0x%x\n", ulClusterSize );

    //
    //  Scan for partial transaction
    // 
    
    if (gfScanTransactions) {
        TRANSACTION_MAP Map;
        CMapIter< LONGLONG, ULONG > *Iter;
        LONGLONG Lsn1;
        ULONG Op;


        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN's between 0x%I64x and 0x%I64x for partial transactions\n\n", LsnStart,
               LsnEnd);
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchTrackTransactions, &Map);

        printf( "Uncommited transactions\n\n" );

        Iter = Map.Enum();
        while (Iter->Next( Lsn1, Op )) {
            printf( "LSN: %I64x operation %s\n", Lsn1, (Op == -1) ? "Unknown" : gOpMap[ Op ] );
        }
        delete Iter;

    }

    //
    //  read front pages from the log
    //

    if (gfPrintHeaders) {
        if (0xFFFFFFFF == SetFilePointer(hFile, 0, NULL, FILE_BEGIN)) {
            printf("SetFilePtr failed %d\n", GetLastError());
        }

        for (iIndex=0; iIndex < 4; iIndex++) {
            if (!MyReadFile(hFile, lpBuffer, LOG_PAGE, NULL)) {
                return 1;
            }
            if (!ApplySectorHdr((PMULTI_SECTOR_HEADER)lpBuffer, LOG_PAGE * iIndex))
            {
                break;
            }
            DumpPage(lpBuffer);
            printf("\n");
        }
    }

    //
    //  Dump Back Pages
    //

    if (giPagesBackToDump) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanBackPagesForLastLsn(hFile, LsnEnd, giPagesBackToDump);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Printing LSN's between 0x%I64x and 0x%I64x\n\n", LsnStart,
               LsnEnd);
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchAll, NULL);
    }

    if (gLsnToDump.QuadPart) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        
        printf("Scanning LSN records for LSN: 0x%I64x  between 0x%I64x and 0x%I64x\n\n",
               gLsnToDump.QuadPart, LsnStart, LsnEnd);
        ScanLsnRangeForMatch(hFile, gLsnToDump, gLsnToDump, MatchAll, NULL);
    }

    if (gVcnPairToMatch.Vcn) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for VCN: 0x%I64x  between 0x%I64x and 0x%I64x\n\n",
               gVcnPairToMatch.Vcn, LsnStart, LsnEnd);
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchVcn, &gVcnPairToMatch);
    }

    if (gLcnToMatch) {

        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for LCN: 0x%I64x  between 0x%I64x and 0x%I64x\n\n",
               gLcnToMatch, LsnStart, LsnEnd);

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchLcn, &gLcnToMatch);
    }

    if (gLsnToTrace.QuadPart) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        printf("Scanning LSN records for transaction contain LSN: 0x%I64x\n",
               gLsnToTrace);

        if ((gLsnToTrace.QuadPart < LsnStart.QuadPart) || (gLsnToTrace.QuadPart > LsnEnd.QuadPart )) {
            printf( "LSN out of range for the logfile\n" );
            return 1;
        }

        TraceTransaction(hFile, gLsnToTrace, LsnStart, LsnEnd);
    }

    if (gllFileToMatch) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        printf("Scanning LSN records for transaction contain file: 0x%I64x between 0x%I64x and 0x%I64x\n",
               gllFileToMatch, LsnStart, LsnEnd);

        FileRefMatchCtx.llFileRef = gllFileToMatch;
        FileRefMatchCtx.pAttrMap = &AttrMap;
        FileRefMatchCtx.ClusterSize = ulClusterSize;

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchFileRef, &FileRefMatchCtx);
        
    }

    if (gfDumpEverything) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }
        printf("Printing LSN records between 0x%I64x and 0x%I64x\n",
               LsnStart, LsnEnd );
        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchAll, NULL);
    }

    if (glBitToMatch != -1) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for Bit: 0x%x  between 0x%I64x and 0x%I64x\n\n",
               glBitToMatch, LsnStart, LsnEnd);

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchBit, &glBitToMatch);
    }

    if (gfScanForRestarts == TRUE) {
        LsnEnd = ScanForLastLsn(hFile, Logcb.CurrentLsn);
        if (LsnEnd.QuadPart == 0) {
            return 1;
        }
        LsnStart = ScanForFirstLsn(hFile, gVerboseScan);
        if (LsnStart.QuadPart == 0) {
            return 1;
        }

        printf("Scanning LSN records for Restarts  between 0x%I64x and 0x%I64x\n\n",
               LsnStart, LsnEnd);

        ScanLsnRangeForMatch(hFile, LsnStart, LsnEnd, MatchRestartDumps, NULL);
    }


    if (gllRangeStart.QuadPart != 0) {
        printf("Printing LSN records between 0x%I64x and 0x%I64x\n\n",
               gllRangeStart, gllRangeEnd);

        ScanLsnRangeForMatch(hFile, gllRangeStart, gllRangeEnd, MatchAll, NULL);
    }

    printf("\n");

    CloseHandle(hFile);
    
    return 0;
} // _tmain
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\dismount\dismount.c ===
//  dismount.c

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];


    //
    //  Get parameter
    //

    if (argc < 2) {
    
        printf("This program dismounts a volume.\n\n");
        printf("usage: %s <driveletter>:\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtOpenFile( &Volume,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjAttr,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if (Volume == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    Status = NtFsControlFile( Volume,                          // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_DISMOUNT_VOLUME,           // FsControlCode
                              NULL,                            // input buffer
                              0,                               // input buffer length
                              NULL,                            // OutputBuffer for data from the FS
                              0);                              // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nDismount succeeded." );

    } else {

        printf( "\nDismount failed with status %x", Status );
    }

    CloseHandle( Volume );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\fastfind\fastfind.c ===
//  fastfind.c

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>
#include <myntfs.h>

#define VOLUME_PATH  L"\\\\.\\H:"
#define VOLUME_DRIVE_LETTER_INDEX 4
#define FULL_PATH    L"\\??\\H:\\1234567890123456"
#define FULL_DRIVE_LETTER_INDEX 4
#define DEVICE_PREFIX_LEN 14

typedef struct _EXTENT {

    LONGLONG Vcn;
    LONGLONG Lcn;
    LONGLONG Length;

} EXTENT, *PEXTENT;

#define MAX_EXTENTS 64

//
//  Some globals.
//

LARGE_INTEGER MftStart;
ULONG ClusterSize;
ULONG FrsSize;
EXTENT Extents[MAX_EXTENTS];
ULONG DebugLevel;
UCHAR CacheBuffer[0x10000];   // max cluster size
LONGLONG CachedOffset = -1;
char mybuffer[32768];

LONGLONG
ComputeFileRecordLbo (
    IN ULONG MftIndex
    )
{
    LONGLONG vcn;
    LONGLONG lcn = 0;
    ULONG extentIndex;
    ULONG offsetWithinCluster;

    vcn = (MftIndex * FrsSize) / ClusterSize;

    for (extentIndex = 0; extentIndex < MAX_EXTENTS; extentIndex += 1) {

        if ((vcn >= Extents[extentIndex].Vcn) &&
            (vcn < Extents[extentIndex].Vcn + Extents[extentIndex].Length)) {

            lcn = Extents[extentIndex].Lcn + (vcn - Extents[extentIndex].Vcn);
        }
    }

    if (ClusterSize >= FrsSize ) {

        offsetWithinCluster = (MftIndex % (ClusterSize / FrsSize)) * FrsSize;        
        return (lcn * ClusterSize + offsetWithinCluster); 

    } else {

        //
        //  BUGBUG keithka 4/28/00 Handle old fashioned big frs and/or big
        //  clusters someday.
        //

        ASSERT( FALSE );
        return 0;
    }
}

VOID
FindAttributeInFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ATTRIBUTE_TYPE_CODE TypeCode,
    IN PATTRIBUTE_RECORD_HEADER PreviousAttribute OPTIONAL,
    OUT PATTRIBUTE_RECORD_HEADER *Attribute
    )
// Attribute set to NULL if not found.
{
    PATTRIBUTE_RECORD_HEADER attr;

    *Attribute = NULL;
    
    if (FileRecord->Pad0[0] != 'F' ||
        FileRecord->Pad0[1] != 'I' ||
        FileRecord->Pad0[2] != 'L' ||
        FileRecord->Pad0[3] != 'E') {

        if (DebugLevel >= 1) {
        
            printf( "\nBad MFT record %c%c%c%c", 
                    FileRecord->Pad0[0],
                    FileRecord->Pad0[1],
                    FileRecord->Pad0[2],
                    FileRecord->Pad0[3] );
        }

        //
        //  This isn't a good file record, but that doesn't make this a corrupt volume.
        //  It's possible that this file record has never been used.  Since we don't look
        //  at the MFT bitmap, we don't know if this was expected to be a valid filerecord.
        //  The output Attribute is set to NULL already, so we can exit now.
        //

        return;
    }

    if (0 == (FileRecord->Flags & FILE_RECORD_SEGMENT_IN_USE)) {

        //
        //  File record not in use, skip it.
        //

        return;
    }

    if (NULL == PreviousAttribute) {

        attr = (PATTRIBUTE_RECORD_HEADER) ((PUCHAR)FileRecord + FileRecord->FirstAttributeOffset);

    } else {

        attr = (PATTRIBUTE_RECORD_HEADER) ((PUCHAR) PreviousAttribute + PreviousAttribute->RecordLength);

        if (((PUCHAR)attr - (PUCHAR)FileRecord) > (LONG) FrsSize) {

            ASSERT (FALSE);
            return;
        }
    }

    while (attr->TypeCode < TypeCode &&
           attr->TypeCode != $END) {

        ASSERT( attr->RecordLength < FrsSize );

        attr = (PATTRIBUTE_RECORD_HEADER) ((PUCHAR) attr + attr->RecordLength);

        //
        //  BUGBUG keitha 4/20/00 need to handle attribute list case someday...
        //  It's relativley rare that an MFT gets so fragmented it needs an 
        //  attribute list.  Certainly rare enough to skip it for now in a 
        //  piece of test code.
        //
    }

    if (attr->TypeCode == TypeCode) {

        *Attribute = attr;
    }

    return;
}

BOOLEAN
FindNameInFileRecord (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN PWCHAR FileName,
    IN ULONG FileNameLength
    )
{
    PATTRIBUTE_RECORD_HEADER attr;
    PFILE_NAME fileNameAttr;
    ULONG cmpResult;

    FindAttributeInFileRecord( FileRecord,
                               $FILE_NAME,
                               NULL,
                               &attr );

    while (NULL != attr) {

        if (((PUCHAR)attr - (PUCHAR)FileRecord) > (LONG) FrsSize) {

            ASSERT( FALSE );
            return FALSE;
        }

        //
        //  Names shouldn't go nonresident.
        //

        if (attr->FormCode != RESIDENT_FORM) {

            ASSERT( FALSE );
            return FALSE;
        }

        fileNameAttr = (PFILE_NAME) ((PUCHAR)attr + attr->Form.Resident.ValueOffset);

        if (fileNameAttr->FileNameLength == FileNameLength) {
        
            cmpResult = wcsncmp( FileName,
                                 (PWCHAR) fileNameAttr->FileName,
                                 fileNameAttr->FileNameLength );

            if (0 == cmpResult) {

                return TRUE;
            }

        } else if (DebugLevel >= 3) {

            printf( "\nNot a match %S,%S", FileName, fileNameAttr->FileName );
        }

        //
        //  Find the next filename, if any.
        //

        FindAttributeInFileRecord( FileRecord,
                                   $FILE_NAME,
                                   attr,
                                   &attr );
    }

    return FALSE;
}


int
FsTestOpenById (
    IN UCHAR *ObjectId,
    IN HANDLE VolumeHandle
    )
{
    HANDLE File;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    NTSTATUS GetNameStatus;
    NTSTATUS CloseStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;
    WCHAR nameBuffer[MAX_PATH];
    PFILE_NAME_INFORMATION FileName;
    WCHAR Full[] = FULL_PATH;        // Arrays of WCHAR's aren't constants

    RtlInitUnicodeString( &str, Full );

    str.Length = 8;
    RtlCopyMemory( &str.Buffer[0],  //  no device prefix for relative open.
                   ObjectId,
                   8 );

    InitializeObjectAttributes( &ObjectAttributes,
                                &str,
                                OBJ_CASE_INSENSITIVE,
                                VolumeHandle,
                                NULL );

    Status = NtCreateFile( &File,
                           GENERIC_READ, 
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_BY_FILE_ID,
                           NULL,
                           0 );

    if (NT_SUCCESS( Status )) {

        RtlZeroMemory( nameBuffer, sizeof(nameBuffer) );
        FileName = (PFILE_NAME_INFORMATION) &nameBuffer[0];
        FileName->FileNameLength = sizeof(nameBuffer) - sizeof(ULONG);

        GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                sizeof(nameBuffer),
                                                FileNameInformation );

        printf( "%S\n", FileName->FileName );

        CloseStatus = NtClose( File );

        if (!NT_SUCCESS( CloseStatus )) {

            printf( "\nCloseStatus %x", CloseStatus );
        }
    }

    return Status;
}

NTSTATUS
ReadFileRecord (
    IN HANDLE VolumeHandle,
    IN ULONG RecordIndex,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS status;
    LARGE_INTEGER byteOffset;
    IO_STATUS_BLOCK ioStatusBlock;    
    ULONG offsetWithinBuffer;

    byteOffset.QuadPart = ComputeFileRecordLbo( RecordIndex );

    if (FrsSize >= ClusterSize) {

        status = NtReadFile( VolumeHandle,
                             NULL,            //  Event
                             NULL,            //  ApcRoutine
                             NULL,            //  ApcContext
                             &ioStatusBlock,
                             Buffer,
                             FrsSize,
                             &byteOffset,    //  ByteOffset
                             NULL );         //  Key

    } else {

        //
        //  Clusters bigger than filerecords, do cluster
        //  size reads and dice up the returns.
        //

        if ((-1 == CachedOffset) ||
            (byteOffset.QuadPart < CachedOffset) ||
            ((byteOffset.QuadPart + FrsSize) > (CachedOffset + ClusterSize))) {

            if (DebugLevel >= 1) {

                printf( "\nCache miss at %I64x", byteOffset.QuadPart );
            }

            status = NtReadFile( VolumeHandle,
                                 NULL,            //  Event
                                 NULL,            //  ApcRoutine
                                 NULL,            //  ApcContext
                                 &ioStatusBlock,
                                 CacheBuffer,
                                 ClusterSize,
                                 &byteOffset,    //  ByteOffset
                                 NULL );         //  Key

            if (STATUS_SUCCESS != status) {

                //
                //  The cache buffer may be junk now, reread it next time.
                //

                CachedOffset = -1;
                return status;
            }

            CachedOffset = byteOffset.QuadPart;
            offsetWithinBuffer = 0;

        } else {

            if (DebugLevel >= 1) {

                printf( "\nCache hit at %I64x", byteOffset.QuadPart );
            }
            offsetWithinBuffer = (ULONG) (byteOffset.QuadPart % CachedOffset);
            status = STATUS_SUCCESS;
        }

        RtlCopyMemory( Buffer, CacheBuffer + offsetWithinBuffer, FrsSize );
    }

    return status;
}


int
FastFind (
    IN PWCHAR FileName,
    IN PWCHAR DriveLetter
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING str;
    NTSTATUS Status;
    NTSTATUS ReadStatus;
    NTSTATUS CloseStatus;
    LARGE_INTEGER byteOffset;
    LONGLONG mftBytesRead;
    HANDLE volumeHandle;
    DWORD WStatus;
    WCHAR Full[] = FULL_PATH;        // Arrays of WCHAR's aren't constants
    WCHAR Volume[] = VOLUME_PATH;
    BIOS_PARAMETER_BLOCK bpb;
    PPACKED_BOOT_SECTOR bootSector;
    PFILE_RECORD_SEGMENT_HEADER fileRecord;
    PATTRIBUTE_RECORD_HEADER attr;
    VCN nextVcn;
    VCN currentVcn;
    VCN vcnDelta;
    LCN currentLcn;
    LCN lcnDelta;
    PUCHAR bsPtr;
    UCHAR v;
    UCHAR l;
    UCHAR i;
    ULONG extentCount;
    ULONG recordIndex;
    ULONG mftRecords;
    ULONG fileNameLength;
    MFT_SEGMENT_REFERENCE segRef;

    RtlInitUnicodeString( &str, Full );

    RtlCopyMemory( &str.Buffer[FULL_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    str.Length = 0x1E;

    //
    //  Open the volume for relative opens.
    //

    RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    printf( "\nOpening volume handle, this may take a while..." );
    volumeHandle = CreateFileW( (PUSHORT) &Volume,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL );

    if (volumeHandle == INVALID_HANDLE_VALUE) {

        WStatus = GetLastError();
        printf( "Unable to open %ws volume\n", &Volume );
        printf( "Error from CreateFile", WStatus );
        return WStatus;
    }

    printf( "\nVolume handle opened, starting MFT scan" );
    byteOffset.QuadPart = 0;

    ReadStatus = NtReadFile( volumeHandle,
                             NULL,            //  Event
                             NULL,            //  ApcRoutine
                             NULL,            //  ApcContext
                             &IoStatusBlock,
                             mybuffer,
                             0x200,
                             &byteOffset,    //  ByteOffset
                             NULL );         //  Key

    if (STATUS_SUCCESS != ReadStatus) {

        printf( "\nBoot sector read failed with status %x", ReadStatus );
        goto exit;
    }

    bootSector = (PPACKED_BOOT_SECTOR) mybuffer;

    if (bootSector->Oem[0] != 'N' ||
        bootSector->Oem[1] != 'T' ||
        bootSector->Oem[2] != 'F' ||
        bootSector->Oem[3] != 'S') {

        printf( "\nNot an NTFS volume" );
        goto exit;
    }

    NtfsUnpackBios( &bpb, &bootSector->PackedBpb );

    ClusterSize = bpb.BytesPerSector * bpb.SectorsPerCluster;
    if (bootSector->ClustersPerFileRecordSegment < 0) {

        FrsSize = 1 << (-1 * bootSector->ClustersPerFileRecordSegment);

    } else {

        FrsSize = bootSector->ClustersPerFileRecordSegment * ClusterSize;
    }
    
    MftStart.QuadPart = ClusterSize * bootSector->MftStartLcn;

    mftBytesRead = 0;

    ReadStatus = NtReadFile( volumeHandle,
                             NULL,            //  Event
                             NULL,            //  ApcRoutine
                             NULL,            //  ApcContext
                             &IoStatusBlock,
                             mybuffer,
                             FrsSize,
                             &MftStart,      //  ByteOffset
                             NULL );         //  Key

    if (STATUS_SUCCESS != ReadStatus) {

        printf( "\nMFT record 0 read failed with status %x", ReadStatus );
        goto exit;
    }

    mftBytesRead += IoStatusBlock.Information;

    FindAttributeInFileRecord( (PFILE_RECORD_SEGMENT_HEADER) mybuffer,
                               $DATA,
                               NULL,
                               &attr );
    
    if (NULL == attr) {

        printf( "\nMFT record 0 has no $DATA attribute" );
        goto exit;
    }

    if (attr->FormCode == RESIDENT_FORM) {

        printf( "\nVolume has very few files, use dir /s" );
        goto exit;        
    }

    //
    //  BUGBUG keithka 4/28/00 Handle MFT with more than 4billion entries.
    //

    ASSERT (attr->Form.Nonresident.FileSize <= MAXULONG);
    mftRecords = (ULONG) (attr->Form.Nonresident.FileSize / FrsSize);
    
    //
    //  Crack mapping pairs, read those clusters in a few big trnasfers, 
    //  seek out given filename in those buffers.
    //

    nextVcn = attr->Form.Nonresident.LowestVcn;
    currentLcn = 0;
    extentCount = 0;
    RtlZeroMemory( Extents, sizeof(Extents) );

    bsPtr = ((PUCHAR) attr) + attr->Form.Nonresident.MappingPairsOffset;

    while (*bsPtr != 0) {

        currentVcn = nextVcn;

        //
        //  Variable names v and l used for consistency with comments in 
        //  ATTRIBUTE_RECORD_HEADER struct explaining how to decompress
        //  mapping pair information.
        //
        
        v = (*bsPtr) & 0xf;
        l = ((*bsPtr) & 0xf0) >> 4;

        bsPtr += 1;

        for (vcnDelta = 0, i = 0; i < v; i++) {

            vcnDelta += *(bsPtr++) << (8 * i);
        }

        for (lcnDelta = 0, i = 0; i < l; i++) {

            lcnDelta += *(bsPtr++) << (8 * i);
        }

        //
        //  Sign extend.
        //

        if (0x80 & (*(bsPtr - 1))) {
        
            for(; i < sizeof(lcnDelta); i++) {

                lcnDelta += 0xff << (8 * i);
            }
        }

        currentLcn += lcnDelta;
        // printf( "\nVcn %I64x, Lcn %I64x, Length %I64x", currentVcn, currentLcn, vcnDelta );

        if (extentCount < MAX_EXTENTS) {

            Extents[extentCount].Vcn    = currentVcn;
            Extents[extentCount].Lcn    = currentLcn;
            Extents[extentCount].Length = vcnDelta;

            extentCount += 1;

        } else {

            printf( "\nExcessive MFT fragmentation, redefine MAX_EXTENTS and recompile" );
        }

        currentVcn += vcnDelta;
    }

    //
    //  Now we know where the MFT is, let's go read it.
    //

    fileNameLength = wcslen( FileName );

    for (recordIndex = 0; recordIndex <= mftRecords; recordIndex++) {

        ReadStatus = ReadFileRecord( volumeHandle,
                                     recordIndex,
                                     mybuffer );
                        
        if (STATUS_SUCCESS != ReadStatus) {

            printf( "\nMFT record read failed with status %x", ReadStatus );
            goto exit;
        }

        if (FindNameInFileRecord( (PFILE_RECORD_SEGMENT_HEADER) mybuffer,
                                  FileName,
                                  fileNameLength )) {

            //
            //  Found a match, open by id and retrieve name.
            //

            if (DebugLevel >= 1) {

                printf( "\nFound match in file %08x %08x\n", 
                        ((PFILE_RECORD_SEGMENT_HEADER) mybuffer)->SequenceNumber,
                        recordIndex );

            } else {

                printf( "\n" );
            }

            segRef.SegmentNumberLowPart = recordIndex;
            segRef.SegmentNumberHighPart = 0;
            segRef.SequenceNumber = ((PFILE_RECORD_SEGMENT_HEADER) mybuffer)->SequenceNumber;

            FsTestOpenById( (PUCHAR) &segRef, volumeHandle );
        }

        //
        //  The number 0x400 is completely arbitrary.  It's a reasonable interval
        //  of work to do before printing another period to tell the user we're 
        //  making progress still.
        //

        if (0 == (recordIndex % 0x400)) {

            printf( "." );
        }
    }

exit:
    if (volumeHandle != NULL) {

        CloseHandle( volumeHandle );
    }

    return 0;
}

VOID
FastFindHelp (
    char *ExeName
    )
{

    printf( "This program finds a file by scanning the MFT (ntfs only).\n\n" );
    printf( "usage: %s x: filename\n", ExeName );

    printf( "Where x: is the drive letter\n" );
    printf( "example:\n" );
    printf( "%s d: windows.h", ExeName );
}

VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    WCHAR drive;
    ANSI_STRING fileName;
    WCHAR uniBuff[MAX_PATH];
    UNICODE_STRING uniFileName;

    //
    //  Get parameters.
    //

    if (argc < 3) {

        FastFindHelp( argv[0] );
        return;
    }

    if (argc >= 4) {

        sscanf( argv[3], "%x", &DebugLevel );

    } else {

        DebugLevel = 0;
    }

    drive = *argv[1];

    RtlInitAnsiString( &fileName, argv[2] );
    uniFileName.Buffer = uniBuff;
    RtlAnsiStringToUnicodeString( &uniFileName, &fileName, FALSE );
    
    FastFind( uniFileName.Buffer, &drive );
 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\logfile\utils.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       utils.cxx
//
//  Contents:   general purpose utility functions
//
//  Classes:
//
//  Functions:
//
//  Coupling:
//
//  Notes:      right now only operator<< for different types
//              must init crit sec for rand on your own
//
//  History:    9-11-1996   benl   Created
//
//----------------------------------------------------------------------------


#include "pch.hxx"

#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include "mydebug.hxx"
#include "utils.hxx"
#include "randpeak.hxx"

static CRITICAL_SECTION gcsRand;
static BOOLEAN gfInit;

//+---------------------------------------------------------------------------
//
//  Function:   PrintGuid
//
//  Synopsis:
//
//  Arguments:  [file] --
//              [guid] --
//
//  Returns:
//
//  History:    1-27-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintGuid(FILE * file, const GUID & guid)
{
    INT iIndex;

    fprintf(file, "%08x-%04hx-%04hx-", guid.Data1, guid.Data2, guid.Data3);
    for (iIndex=0;iIndex < 8; iIndex++)
    {
        fprintf(file,"%01x", guid.Data4[iIndex]);
    }
} //PrintGuid


//+---------------------------------------------------------------------------
//
//  Function:   MyRand
//
//  Synopsis:   simple rand function
//
//  Arguments:  [dwLimit] --
//
//  Returns:    values btwn 0 and dwLimit inclusively
//
//  History:    10-23-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INT MyRand(INT iLimit)
{
    return RandomInRange(0, iLimit);
} //MyRand


//+---------------------------------------------------------------------------
//
//  Function:   MyRand64
//
//  Synopsis:   like above but for 64 bit integers
//
//  Arguments:  [llLimit] --
//
//  Returns:
//
//  History:    2-12-1997   benl   Created
//
//  Notes:      This works poorly - need a true 64bit random number generator
//
//----------------------------------------------------------------------------

LONGLONG MyRand64(LONGLONG llLimit)
{
    LARGE_INTEGER liTemp;

    liTemp.LowPart = Random32();
    liTemp.HighPart = Random32();

    return liTemp.QuadPart % llLimit;
} //MyRand64


//+---------------------------------------------------------------------------
//
//  Function:   MyRand16
//
//  Synopsis:   like above but for 16 bit integers
//
//  Arguments:  [sLimit] --
//
//  Returns:
//
//  History:    5-15-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SHORT MyRand16(SHORT sLimit)
{
    return (SHORT) RandomInRange(0, sLimit);
} // MyRand16


//+---------------------------------------------------------------------------
//
//  Function:   MySRand
//
//  Synopsis:   srand for threads
//
//  Arguments:  [dwBase] --
//
//  Returns:
//
//  History:    10-30-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID MySRand(DWORD & dwBase)
{
    if (!gfInit)
    {
        InitializeCriticalSection(&gcsRand);
        gfInit = TRUE;
    }

    EnterCriticalSection(&gcsRand);
    dwBase++;
    SeedRandom32(dwBase);
    LeaveCriticalSection(&gcsRand);
} //MySRand



//+---------------------------------------------------------------------------
//
//  Function:   SwapBuffers
//
//  Synopsis:   Swap two differently sized buffers such that
//              the info is split correctly between them
//              i.e if one is 40 bytes and the second 60 bytes
//              after its done the first one contains 40 bytes from the orig 2nd buffer
//              and the 2nd one contains the following orig 20 bytes of the 2nd buffer and
//              then the orig 40. bytes of the first buffer
//
//  Arguments:  [cbBuf1]   -- len of pBuffer1
//              [pBuffer1] -- buffer1
//              [cbBuf2]   -- len of pBuffer2
//              [pBuffer2] -- buffer2
//
//  Returns:
//
//  History:    9-29-1997   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void SwapBuffers(INT cbBuf1, BYTE * pBuffer1, INT cbBuf2, BYTE * pBuffer2)
{
    BYTE * pTemp = new BYTE[cbBuf1];
    INT    iFirst;
    INT    iSecond;
    INT    iThird;

    memcpy(pTemp, pBuffer1, cbBuf1);

    iFirst = min(cbBuf1, cbBuf2);
    memcpy(pBuffer1, pBuffer2, iFirst);
    if (iFirst < cbBuf1)
    {
        memcpy(pBuffer1 + iFirst, pTemp, cbBuf1 - iFirst);
        iSecond = 0;
        iThird = cbBuf1 + iFirst;
    } else
    {
        memcpy(pBuffer2, pBuffer1 + iFirst, cbBuf2 - iFirst);
        iSecond = cbBuf2 - iFirst;
        iThird = 0;
    }
    memcpy(pBuffer2 + iSecond, pTemp + iThird, cbBuf2 - iSecond);

    if (pTemp)
    {
        delete[] pTemp;
    }
} // SwapBuffers



//+---------------------------------------------------------------------------
//
//  Function:   PrintByte
//
//  Synopsis:
//
//  Arguments:  [byte] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintByte(BYTE byte)
{
    printf("%02hx", byte);

} //PrintByte



//+---------------------------------------------------------------------------
//
//  Function:   PrintWord
//
//  Synopsis:
//
//  Arguments:  [bytes] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintWord(LPBYTE bytes)
{
    PrintByte(bytes[0]);
    printf(" ");
    PrintByte(bytes[1]);
} //PrintWord


//+---------------------------------------------------------------------------
//
//  Function:   PrintDWord
//
//  Synopsis:
//
//  Arguments:  [bytes] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void PrintDWord(LPBYTE bytes)
{
    PrintWord(bytes);
    printf(" ");
    PrintWord(bytes + 2);
} //PrintDWord


//+---------------------------------------------------------------------------
//
//  Function:   DumpRawBytes
//
//  Synopsis:   Helper output function
//
//  Arguments:  [pBytes] --
//              [cBytes] --
//
//  Returns:
//
//  History:    11-14-1996   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRawBytes(BYTE * pBytes, UINT cBytes)
{
    UINT iIndex;
    UINT iIndex2;

    if (0 == cBytes)
    {
        printf("Empty Buffer\n");
    }

/*
    if (cBytes < 16)
    {
        printf("%04x  ",iIndex * 16);
        for(iIndex=0; iIndex < cBytes; iIndex++)
        {
            PrintByte(*(pBytes + iIndex));
            printf(" ");
        }
    }
*/

    for (iIndex=0;iIndex < cBytes / 16; iIndex++)
    {
        printf("%04x  ",iIndex * 16);
        PrintDWord(pBytes + (iIndex * 16));
        printf(" ");
        PrintDWord(pBytes + (iIndex * 16 + 4));
        printf("  ");
        PrintDWord(pBytes + (iIndex * 16 + 8));
        printf(" ");
        PrintDWord(pBytes + (iIndex * 16 + 12));

        printf("  ");

        for (iIndex2=0;iIndex2 < 16; iIndex2++)
        {
            if (isgraph(pBytes[(iIndex*16) + iIndex2]))
            {
                printf("%c", pBytes[(iIndex*16) + iIndex2]);
            } else
            {
                printf(".");
            }

        }

        printf("\n");
    }

    //print trailing bytes
    printf("%04x  ", ((cBytes / 16) * 16));

    for (iIndex=0; iIndex < 16; iIndex++)
    {
        if (iIndex < cBytes % 16)
        {
            PrintByte(*(pBytes + ((cBytes / 16) * 16) + iIndex));
            printf(" ");
        } else
        {
            printf("   ");
        }
        //add byte separator if necc.
        if (iIndex && (iIndex % 7 == 0))
        {
            printf(" ");
        }

    }

    for (iIndex2=0; iIndex2 < cBytes % 16; iIndex2++)
    {
        if (isgraph(*(pBytes + ((cBytes / 16) * 16) + iIndex2)))
        {
            printf("%c", *(pBytes + ((cBytes / 16) * 16) + iIndex2));
        } else
        {
            printf(".");
        }
    }


    printf("\n");
} //DumpRawBytes


//+---------------------------------------------------------------------------
//
//  Function:   DumpRawDwords
//
//  Synopsis:
//
//  Arguments:  [pDwords] --
//              [cBytes]  --
//
//  Returns:
//
//  History:    8-25-1998   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void DumpRawDwords(DWORD * pDwords, UINT cBytes)
{
    UINT   iIndex;
    UINT   iIndex2;
    BYTE * pBytes;

    if (0 == cBytes)
    {
        printf("Empty Buffer\n");
    }

    for (iIndex=0; iIndex < cBytes / 16; iIndex++)
    {
        printf("%04x  ",iIndex * 16);

        printf("%08x ", pDwords[iIndex * 4]);
        printf("%08x ", pDwords[iIndex * 4 + 1]);
        printf("%08x ", pDwords[iIndex * 4 + 2]);
        printf("%08x ", pDwords[iIndex * 4 + 3]);

        printf("  ");

        pBytes = (BYTE *) (pDwords + (iIndex * 4));
        for (iIndex2=0; iIndex2 < 16; iIndex2++)
        {
            if (isgraph(pBytes[iIndex2]))
            {
                printf("%c", pBytes[iIndex2]);
            } else
            {
                printf(".");
            }
        }

        printf("\n");
    }

    //print trailing dwords
    printf("%04x  ", ((cBytes / 16) * 16));

    for (iIndex=0; iIndex < 4; iIndex++)
    {
        if (iIndex * 4 < cBytes % 16)
        {
            printf("%08x", pDwords[((cBytes / 16) * 4) +iIndex]);
            printf(" ");
        } else
        {
            printf("         ");
        }
    }

    printf("  ");

    pBytes = (BYTE *) (pDwords + ((cBytes / 16) * 4));
    for (iIndex2=0; iIndex2 < cBytes % 16; iIndex2++)
    {
        if (isgraph(*(pBytes + iIndex2)))
        {
            printf("%c", *(pBytes + iIndex2));
        } else
        {
            printf(".");
        }
    }


    printf("\n");
} // DumpRawDwords



//+---------------------------------------------------------------------------
//
//  Function:   HexStrToInt64
//
//  Synopsis:
//
//  Arguments:  [szIn]   --
//                   [i64Out] --
//
//  Returns:
//
//  History:    5-30-96   benl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void HexStrToInt64(LPCTSTR szIn, __int64 & i64Out)
{
    int i;
    const TCHAR * szTmp = szIn;

    i64Out = 0;

/*
    if (szTmp[0] != '0' && szTmp[1] != 'x') {
        return;
    }
    //move past prefix
    szTmp+=2;
*/
    while (*szTmp != _T('\0') &&
           (_istdigit(*szTmp) ||  (_totlower(*szTmp) >= 'a' && _totlower(*szTmp) <= 'f')))
    {
        i64Out *= 16;
        if (_istdigit(*szTmp))
        {
            i64Out +=  *szTmp - _T('0');
        } else
        {
            i64Out += _totlower(*szTmp) - _T('a') + 10;
        }
        szTmp++;
    } //endwhile
} //HexStrToInt64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\fastfind\myntfs.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MyNtfs.h

Current Version Numbers:

    Major.Minor Version:  1.2

Abstract:

    This module defines some on-disk structure of the Ntfs file system as 
    needed by findfast.exe.

*/

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(D,S) {                                \
    *((UCHAR1 *)(D)) = *((UNALIGNED UCHAR1 *)(S)); \
}

#define CopyUchar2(D,S) {                                \
    *((UCHAR2 *)(D)) = *((UNALIGNED UCHAR2 *)(S)); \
}

#define CopyUchar4(D,S) {                                \
    *((UCHAR4 *)(D)) = *((UNALIGNED UCHAR4 *)(S)); \
}


typedef LONGLONG LCN;
typedef LCN *PLCN;

typedef LONGLONG VCN;
typedef VCN *PVCN;

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {

    UCHAR  BytesPerSector[2];                               //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                            //  offset = 0x002
    UCHAR  ReservedSectors[2];                              //  offset = 0x003 (zero)
    UCHAR  Fats[1];                                         //  offset = 0x005 (zero)
    UCHAR  RootEntries[2];                                  //  offset = 0x006 (zero)
    UCHAR  Sectors[2];                                      //  offset = 0x008 (zero)
    UCHAR  Media[1];                                        //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                                //  offset = 0x00B (zero)
    UCHAR  SectorsPerTrack[2];                              //  offset = 0x00D
    UCHAR  Heads[2];                                        //  offset = 0x00F
    UCHAR  HiddenSectors[4];                                //  offset = 0x011 (zero)
    UCHAR  LargeSectors[4];                                 //  offset = 0x015 (zero)

} PACKED_BIOS_PARAMETER_BLOCK;                              //  sizeof = 0x019

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {

    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;

} BIOS_PARAMETER_BLOCK;

typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;

//
//  This macro takes a Packed BIOS and fills in its Unpacked
//  equivalent
//

#define NtfsUnpackBios(Bios,Pbios) {                                       \
    CopyUchar2(&((Bios)->BytesPerSector),    &(Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), &(Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   &(Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              &(Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       &(Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           &(Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             &(Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     &(Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   &(Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             &(Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     &(Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      &(Pbios)->LargeSectors     ); \
}

typedef ULONG ATTRIBUTE_TYPE_CODE;
typedef ATTRIBUTE_TYPE_CODE *PATTRIBUTE_TYPE_CODE;

//
//  System-defined Attribute Type Codes.  For the System-defined
//  attributes, the Unicode Name is exactly equal to the name of the
//  following symbols.  For this reason, all of the system-defined
//  attribute names start with "$", to always distinguish them when
//  attribute names are listed, and to reserve a namespace for
//  attributes defined in the future.  I.e., a User-Defined
//  attribute name will never collide with a current or future
//  system-defined attribute name if it does not start with "$".
//  User attribute numbers should not start until
//  $FIRST_USER_DEFINED_ATTRIBUTE, to allow the potential for
//  upgrading existing volumes with new user-defined attributes in
//  future versions of NTFS.  The tagged attribute list is
//  terminated with a lone-standing 0 ($END) - the rest of the
//  attribute record does not exist.
//
//  The type code value of 0 is reserved for convenience of the
//  implementation.
//

#define $UNUSED                          (0X0)

#define $STANDARD_INFORMATION            (0x10)
#define $ATTRIBUTE_LIST                  (0x20)
#define $FILE_NAME                       (0x30)
#define $OBJECT_ID                       (0x40)
#define $SECURITY_DESCRIPTOR             (0x50)
#define $VOLUME_NAME                     (0x60)
#define $VOLUME_INFORMATION              (0x70)
#define $DATA                            (0x80)
#define $INDEX_ROOT                      (0x90)
#define $INDEX_ALLOCATION                (0xA0)
#define $BITMAP                          (0xB0)
#define $REPARSE_POINT                   (0xC0)
#define $EA_INFORMATION                  (0xD0)
#define $EA                              (0xE0)
// #define $LOGGED_UTILITY_STREAM           (0x100) // defined in ntfsexp.h
#define $FIRST_USER_DEFINED_ATTRIBUTE    (0x1000)
#define $END                             (0xFFFFFFFF)

//
//  Define the boot sector.  Note that MFT2 is exactly three file
//  record segments long, and it mirrors the first three file record
//  segments from the MFT, which are MFT, MFT2 and the Log File.
//
//  The Oem field contains the ASCII characters "NTFS    ".
//
//  The Checksum field is a simple additive checksum of all of the
//  ULONGs which precede the Checksum ULONG.  The rest of the sector
//  is not included in this Checksum.
//

typedef struct _PACKED_BOOT_SECTOR {

    UCHAR Jump[3];                                                              //  offset = 0x000
    UCHAR Oem[8];                                                               //  offset = 0x003
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;                                      //  offset = 0x00B
    UCHAR Unused[4];                                                            //  offset = 0x024
    LONGLONG NumberSectors;                                                     //  offset = 0x028
    LCN MftStartLcn;                                                            //  offset = 0x030
    LCN Mft2StartLcn;                                                           //  offset = 0x038
    CHAR ClustersPerFileRecordSegment;                                          //  offset = 0x040
    UCHAR Reserved0[3];
    CHAR DefaultClustersPerIndexAllocationBuffer;                               //  offset = 0x044
    UCHAR Reserved1[3];
    LONGLONG SerialNumber;                                                      //  offset = 0x048
    ULONG Checksum;                                                             //  offset = 0x050
    UCHAR BootStrap[0x200-0x054];                                               //  offset = 0x054

} PACKED_BOOT_SECTOR;                                                           //  sizeof = 0x200

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
//  The MFT Segment Reference is an address in the MFT tagged with
//  a circularly reused sequence number set at the time that the MFT
//  Segment Reference was valid.  Note that this format limits the
//  size of the Master File Table to 2**48 segments.  So, for
//  example, with a 1KB segment size the maximum size of the master
//  file would be 2**58 bytes, or 2**28 gigabytes.
//

typedef struct _MFT_SEGMENT_REFERENCE {

    //
    //  First a 48 bit segment number.
    //

    ULONG SegmentNumberLowPart;                                    //  offset = 0x000
    USHORT SegmentNumberHighPart;                                  //  offset = 0x004

    //
    //  Now a 16 bit nonzero sequence number.  A value of 0 is
    //  reserved to allow the possibility of a routine accepting
    //  0 as a sign that the sequence number check should be
    //  repressed.
    //

    USHORT SequenceNumber;                                          //  offset = 0x006

} MFT_SEGMENT_REFERENCE, *PMFT_SEGMENT_REFERENCE;                   //  sizeof = 0x008

//
//  A file reference in NTFS is simply the MFT Segment Reference of
//  the Base file record.
//

typedef MFT_SEGMENT_REFERENCE FILE_REFERENCE, *PFILE_REFERENCE;

//
//  File Record Segment.  This is the header that begins every File
//  Record Segment in the Master File Table.
//

typedef struct _FILE_RECORD_SEGMENT_HEADER {

    //
    //  Multi-Sector Header as defined by the Cache Manager.  This
    //  structure will always contain the signature "FILE" and a
    //  description of the location and size of the Update Sequence
    //  Array.
    //

    UCHAR Pad0[0x10];                                               //  offset = 0x000

    //
    //  Sequence Number.  This is incremented each time that a File
    //  Record segment is freed, and 0 is not used.  The
    //  SequenceNumber field of a File Reference must match the
    //  contents of this field, or else the File Reference is
    //  incorrect (presumably stale).
    //

    USHORT SequenceNumber;                                          //  offset = 0x010

    //
    //  This is the count of the number of references which exist
    //  for this segment, from an INDEX_xxx attribute.  In File
    //  Records Segments other than the Base File Record Segment,
    //  this field is 0.
    //

    USHORT ReferenceCount;                                          //  offset = 0x012

    //
    //  Offset to the first Attribute record in bytes.
    //

    USHORT FirstAttributeOffset;                                    //  offset = 0x014

    //
    //  FILE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x016

    //
    //  First free byte available for attribute storage, from start
    //  of this header.  This value should always be aligned to a
    //  quad-word boundary, since attributes are quad-word aligned.
    //

    ULONG FirstFreeByte;                                            //  offset = x0018

    //
    //  Total bytes available in this file record segment, from the
    //  start of this header.  This is essentially the file record
    //  segment size.
    //

    ULONG BytesAvailable;                                           //  offset = 0x01C

    //
    //  This is a File Reference to the Base file record segment for
    //  this file.  If this is the Base, then the value of this
    //  field is all 0's.
    //

    UCHAR Pad1[8];                                                  //  offset = 0x020

    //
    //  This is the attribute instance number to be used when
    //  creating an attribute.  It is zeroed when the base file
    //  record is created, and captured for each new attribute as it
    //  is created and incremented afterwards for the next
    //  attribute.  Instance numbering must also occur for the
    //  initial attributes.  Zero is a valid attribute instance
    //  number, and typically used for standard information.
    //

    USHORT NextAttributeInstance;                                   //  offset = 0x028

    //
    //  Current FRS record - this is here for recovery alone and added in 5.1
    //  Note: this is not aligned
    // 

    USHORT SegmentNumberHighPart;                                  //  offset = 0x02A
    ULONG SegmentNumberLowPart;                                    //  offset = 0x02C

    //
    //  Update Sequence Array to protect multi-sector transfers of
    //  the File Record Segment.  Accesses to already initialized
    //  File Record Segments should go through the offset above, for
    //  upwards compatibility.
    //

    UCHAR Pad2[1];                                                  //  offset = 0x030

} FILE_RECORD_SEGMENT_HEADER;
typedef FILE_RECORD_SEGMENT_HEADER *PFILE_RECORD_SEGMENT_HEADER;

//
//  FILE_xxx flags.
//

#define FILE_RECORD_SEGMENT_IN_USE       (0x0001)
#define FILE_FILE_NAME_INDEX_PRESENT     (0x0002)
#define FILE_SYSTEM_FILE                 (0x0004)
#define FILE_VIEW_INDEX_PRESENT          (0x0008)

//
//  Attribute Record.  Logically an attribute has a type, an
//  optional name, and a value, however the storage details make it
//  a little more complicated.  For starters, an attribute's value
//  may either be resident in the file record segment itself, on
//  nonresident in a separate data stream.  If it is nonresident, it
//  may actually exist multiple times in multiple file record
//  segments to describe different ranges of VCNs.
//
//  Attribute Records are always aligned on a quad word (64-bit)
//  boundary.
//

typedef struct _ATTRIBUTE_RECORD_HEADER {

    //
    //  Attribute Type Code.
    //

    ATTRIBUTE_TYPE_CODE TypeCode;                                   //  offset = 0x000

    //
    //  Length of this Attribute Record in bytes.  The length is
    //  always rounded to a quad word boundary, if necessary.  Also
    //  the length only reflects the size necessary to store the
    //  given record variant.
    //

    ULONG RecordLength;                                             //  offset = 0x004

    //
    //  Attribute Form Code (see below)
    //

    UCHAR FormCode;                                                 //  offset = 0x008

    //
    //  Length of the optional attribute name in characters, or 0 if
    //  there is none.
    //

    UCHAR NameLength;                                               //  offset = 0x009

    //
    //  Offset to the attribute name from start of attribute record,
    //  in bytes, if it exists.  This field is undefined if
    //  NameLength is 0.
    //

    USHORT NameOffset;                                              //  offset = 0x00A

    //
    //  ATTRIBUTE_xxx flags.
    //

    USHORT Flags;                                                   //  offset = 0x00C

    //
    //  The file-record-unique attribute instance number for this
    //  attribute.
    //

    USHORT Instance;                                                //  offset = 0x00E

    //
    //  The following union handles the cases distinguished by the
    //  Form Code.
    //

    union {

        //
        //  Resident Form.  Attribute resides in file record segment.
        //

        struct {

            //
            //  Length of attribute value in bytes.
            //

            ULONG ValueLength;                                      //  offset = 0x010

            //
            //  Offset to value from start of attribute record, in
            //  bytes.
            //

            USHORT ValueOffset;                                     //  offset = 0x014

            //
            //  RESIDENT_FORM_xxx Flags.
            //

            UCHAR ResidentFlags;                                    //  offset = 0x016

            //
            //  Reserved.
            //

            UCHAR Reserved;                                         //  offset = 0x017

        } Resident;

        //
        //  Nonresident Form.  Attribute resides in separate stream.
        //

        struct {

            //
            //  Lowest VCN covered by this attribute record.
            //

            VCN LowestVcn;                                          //  offset = 0x010

            //
            //  Highest VCN covered by this attribute record.
            //

            VCN HighestVcn;                                         //  offset = 0x018

            //
            //  Offset to the Mapping Pairs Array  (defined below),
            //  in bytes, from the start of the attribute record.
            //

            USHORT MappingPairsOffset;                              //  offset = 0x020

            //
            //  Unit of Compression size for this stream, expressed
            //  as a log of the cluster size.
            //
            //      0 means file is not compressed
            //      1, 2, 3, and 4 are potentially legal values if the
            //          stream is compressed, however the implementation
            //          may only choose to use 4, or possibly 3.  Note
            //          that 4 means cluster size time 16.  If convenient
            //          the implementation may wish to accept a
            //          reasonable range of legal values here (1-5?),
            //          even if the implementation only generates
            //          a smaller set of values itself.
            //

            UCHAR CompressionUnit;                                  //  offset = 0x022

            //
            //  Reserved to get to quad word boundary.
            //

            UCHAR Reserved[5];                                      //  offset = 0x023

            //
            //  Allocated Length of the file in bytes.  This is
            //  obviously an even multiple of the cluster size.
            //  (Not present if LowestVcn != 0.)
            //

            LONGLONG AllocatedLength;                               //  offset = 0x028

            //
            //  File Size in bytes (highest byte which may be read +
            //  1).  (Not present if LowestVcn != 0.)
            //

            LONGLONG FileSize;                                      //  offset = 0x030

            //
            //  Valid Data Length (highest initialized byte + 1).
            //  This field must also be rounded to a cluster
            //  boundary, and the data must always be initialized to
            //  a cluster boundary. (Not present if LowestVcn != 0.)
            //

            LONGLONG ValidDataLength;                               //  offset = 0x038

            //
            //  Totally allocated.  This field is only present for the first
            //  file record of a compressed stream.  It represents the sum of
            //  the allocated clusters for a file.
            //

            LONGLONG TotalAllocated;                                //  offset = 0x040

            //
            //
            //  Mapping Pairs Array, starting at the offset stored
            //  above.
            //
            //  The Mapping Pairs Array is stored in a compressed
            //  form, and assumes that this information is
            //  decompressed and cached by the system.  The reason
            //  for compressing this information is clear, it is
            //  done in the hopes that all of the retrieval
            //  information always fits in a single file record
            //  segment.
            //
            //  Logically, the MappingPairs Array stores a series of
            //  NextVcn/CurrentLcn pairs.  So, for example, given
            //  that we know the first Vcn (from LowestVcn above),
            //  the first Mapping Pair tells us what the next Vcn is
            //  (for the next Mapping Pair), and what Lcn the
            //  current Vcn is mapped to, or 0 if the Current Vcn is
            //  not allocated.  (This is exactly the FsRtl MCB
            //  structure).
            //
            //  For example, if a file has a single run of 8
            //  clusters, starting at Lcn 128, and the file starts
            //  at LowestVcn=0, then the Mapping Pairs array has
            //  just one entry, which is:
            //
            //    NextVcn = 8
            //    CurrentLcn = 128
            //
            //  The compression is implemented with the following
            //  algorithm.  Assume that you initialize two "working"
            //  variables as follows:
            //
            //    NextVcn = LowestVcn (from above)
            //    CurrentLcn = 0
            //
            //  The MappingPairs array is byte stream, which simply
            //  store the changes to the working variables above,
            //  when processed sequentially.  The byte stream is to
            //  be interpreted as a zero-terminated stream of
            //  triples, as follows:
            //
            //    count byte = v + (l * 16)
            //
            //      where v = number of changed low-order Vcn bytes
            //            l = number of changed low-order Lcn bytes
            //
            //    v Vcn change bytes
            //    l Lcn change bytes
            //
            //  The byte stream terminates when a count byte of 0 is
            //  encountered.
            //
            //  The decompression algorithm goes as follows,
            //  assuming that Attribute is a pointer to the
            //  attribute record.
            //
            //  1.  Initialize:
            //          NextVcn = Attribute->LowestVcn;
            //          CurrentLcn = 0;
            //
            //  2.  Initialize byte stream pointer to: (PCHAR)Attribute +
            //      Attribute->AttributeForm->Nonresident->MappingPairsOffset
            //
            //  3.  CurrentVcn = NextVcn;
            //
            //  4.  Read next byte from stream.  If it is 0, then
            //      break, else extract v and l (see above).
            //
            //  5.  Interpret the next v bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to NextVcn.
            //      (It can really only be positive, but the Lcn
            //      change can be positive or negative.)
            //
            //  6.  Interpret the next l bytes as a signed quantity,
            //      with the low-order byte coming first.  Unpack it
            //      sign-extended into 64 bits and add it to
            //      CurrentLcn.  Remember, if this produces a
            //      CurrentLcn of 0, then the Vcns from the
            //      CurrentVcn to NextVcn-1 are unallocated.
            //
            //  7.  Update cached mapping information from
            //      CurrentVcn, NextVcn and CurrentLcn.
            //
            //  8.  Loop back to 3.
            //
            //  The compression algorithm should now be obvious, as
            //  it is the reverse of the above.  The compression and
            //  decompression algorithms will be available as common
            //  RTL routines, available to NTFS and file utilities.
            //
            //  In defense of this algorithm, not only does it
            //  provide compression of the on-disk storage
            //  requirements, but it results in a single
            //  representation, independent of disk size and file
            //  size.  Contrast this with solutions which are in use
            //  which define multiple sizes for virtual and logical
            //  cluster sizes, depending on the size of the disk,
            //  etc.  For example, two byte cluster numbers might
            //  suffice for a floppy, while four bytes would be
            //  required for most hard disks today, and five or six
            //  bytes are required after a certain number of
            //  gigabytes, etc.  This eventually results in more
            //  complex code than above (because of the cases) and
            //  worse yet - untested cases.  So, more important than
            //  the compression, the above algorithm provides one
            //  case which efficiently handles any size disk.
            //

        } Nonresident;

    } Form;

} ATTRIBUTE_RECORD_HEADER;
typedef ATTRIBUTE_RECORD_HEADER *PATTRIBUTE_RECORD_HEADER;

//
//  Attribute Form Codes
//

#define RESIDENT_FORM                    (0x00)
#define NONRESIDENT_FORM                 (0x01)

//
//  File Name attribute.  A file has one File Name attribute for
//  every directory it is entered into (hard links).
//

typedef struct _FILE_NAME {

    //
    //  This is a File Reference to the directory file which indexes
    //  to this name.
    //

    FILE_REFERENCE ParentDirectory;                                 //  offset = 0x000

    //
    //  Information for faster directory operations.
    //

    UCHAR Pad0[0x38];                                               //  offset = 0x008

    //
    //  Length of the name to follow, in (Unicode) characters.
    //

    UCHAR FileNameLength;                                           //  offset = 0x040

    //
    //  FILE_NAME_xxx flags
    //

    UCHAR Flags;                                                    //  offset = 0x041

    //
    //  First character of Unicode File Name
    //

    WCHAR FileName[1];                                              //  offset = 0x042

} FILE_NAME;
typedef FILE_NAME *PFILE_NAME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\logfile\randpeak.cxx ===
#include "pch.hxx"
#include "randpeak.hxx"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  randpeak.c  --  Functions to provide 32-bit random numbers, including  //
//                  a linear distribution (Random32 and RandomInRange),    //
//                  and a peaked distribution (RandomPeaked).              //
//                                                                         //
//                  Assumptions: ULONG is 32-bit unsigned data type, and   //
//                               BOOL is an integral boolean type.         //
//                                                                         //
//                               If MULTITHREADED is defined, critical     //
//                               section primitives must be defined and    //
//                               supported.                                //
//                                                                         //
//                               Two's complement wraparound (mod 2^32)    //
//                               occurs on addition and multiplication     //
//                               where result is greater than (2^32-1)     //
//                                                                         //
//                  Author: Tom McGuire (tommcg), 03/29/94                 //
//                                                                         //
//                  (C) Copyright 1994, Microsoft Corporation              //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#define MULTIPLIER ((ULONG) 1664525 )   // From Knuth.  Guarantees 2^32 non-
                                        // repeating values.

ULONG ulInternalSeed;
ULONG ulInternalAdder;

#ifdef MULTITHREADED
    CRITICAL_SECTION ulInternalSeedCritSect;
    BOOL bInternalSeedCritSectInitialized;
#endif


ULONG BitReverse32( ULONG ulNumber ) {

    ULONG ulNewValue = 0;
    ULONG ulReadMask = 0x00000001;
    ULONG ulWriteBit = 0x80000000;

    do {
        if ( ulNumber & ulReadMask )
            ulNewValue |= ulWriteBit;
        ulReadMask <<= 1;
        ulWriteBit >>= 1;
        }
    while ( ulWriteBit );

    return ulNewValue;
    }


void SeedRandom32( ULONG ulSeed ) {

    //
    //  Assume this is called from a single thread only before any calls
    //  to Random32(), RandomInRange(), or RandomPeaked().
    //

#ifdef MULTITHREADED
    if ( ! bInternalSeedCritSectInitialized ) {
        InitializeCriticalSection( &ulInternalSeedCritSect );
        bInternalSeedCritSectInitialized = TRUE;
        }
#endif

    ulInternalSeed  = ulSeed;
    ulInternalAdder = ((( ulSeed ^ 0xFFFFFFFF ) | 0x00000001 ) & 0x7FFFFFFF );

    }


ULONG Random32( void ) {

    ULONG ulRand;

#ifdef MULTITHREADED
    EnterCriticalSection( &ulInternalSeedCritSect );
#endif

    ulRand = ( ulInternalSeed * MULTIPLIER ) + ulInternalAdder;
    ulInternalSeed = ulRand;

#ifdef MULTITHREADED
    LeaveCriticalSection( &ulInternalSeedCritSect );
#endif

    return BitReverse32( ulRand );
    }


ULONG RandomInRange( ULONG ulMinInclusive, ULONG ulMaxInclusive ) {

    ULONG ulRange = ( ulMaxInclusive - ulMinInclusive + 1 );
    ULONG ulRand  = Random32();

    if ( ulRange )
        ulRand %= ulRange;

    return ( ulRand + ulMinInclusive );
    }


ULONG RandomPeaked( ULONG ulMaxInclusive,
                    ULONG ulPeakFrequency,
                    ULONG ulPeakWidth,
                    ULONG ulPeakDensity,
                    ULONG ulPeakDecay ) {

    ULONG ulWhichPeak, ulPeakValue, ulRange, ulHigh, ulLow;

    ulWhichPeak = ( ulMaxInclusive / ulPeakFrequency );

    do {
        ulWhichPeak = RandomInRange( 0, ulWhichPeak );
        }
    while ( ulPeakDecay-- );

    ulPeakValue = ulWhichPeak * ulPeakFrequency;

    ulRange = ( ulPeakFrequency * ( ulPeakDensity + 1 )) / ( ulPeakDensity + 2 );

    while ( ulPeakDensity-- )
        ulRange = RandomInRange( ulPeakWidth / 2, ulRange );

    ulLow  = ( ulPeakValue > ulRange ) ? ( ulPeakValue - ulRange ) : 0;
    ulHigh = ( ulPeakValue + ulRange );

    if ( ulHigh > ulMaxInclusive )
        ulHigh = ulMaxInclusive;

    ulPeakValue = RandomInRange( ulLow, ulHigh );

    return ulPeakValue;

    }


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//   |                      Peaked Distribution                      |     //
//   |_                                                              |     //
//   | \                                                             |     //
//   |  \             _                                              |     //
//   |   \           / \              _                              |     //
//   |    \         /   \            / \            _                |     //
//   |     \       /     \          /   \          / \              _|     //
//   |      \_____/       \________/     \__    __/   \____________/ |     //
//   |_______________________________________________________________|     //
//   0                P              2P            nP               Max    //
//                                                                         //
//   The center of each peak occurs at ulPeakFreq intervals starting       //
//   from zero, and the tops of the peaks are linear-distributed across    //
//   ulPeakWidth (ie, +/- ulPeakWidth/2).  ulPeakDensity controls the      //
//   slope of the distribution off each peak with higher numbers causing   //
//   steeper slopes (and hence wider, lower valleys).  ulPeakDecay         //
//   controls the declining peak-to-peak slope with higher numbers         //
//   causing higher peaks near zero and lower peaks toward ulMax.          //
//   Note that ulPeakDensity and ulPeakDecay are computationally           //
//   expensive with higher values (they represent internal iteration       //
//   counts), so moderate numbers such as 3-5 for ulPeakDensity and        //
//   1-2 for ulPeakDecay are recommended.                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\enumq\enumq.c ===
//  enumq.c

#include "oidtst.h"


void
FsTestDumpQuotaIndexEntries (
    IN PFILE_QUOTA_INFORMATION QuotaInfo,
    IN ULONG_PTR LengthInBytes
    )

{
    ULONG RemainingBytesToDump = (ULONG) LengthInBytes;
    ULONG Idx;
    ULONG CurrentEntrySize;

    PFILE_QUOTA_INFORMATION Ptr;

    printf( "\n\nFound %x quota index bytes", LengthInBytes );

    Ptr = QuotaInfo;

    Idx = 0;

    while (RemainingBytesToDump > 0) {

        printf( "\n\nEntry %x", Idx );

        printf( "\nQuotaUsed %i64", Ptr->QuotaUsed.QuadPart );
        printf( "\nQuotaLimit %i64", Ptr->QuotaLimit.QuadPart );
        printf( "\nSidLength %x", Ptr->SidLength );
        printf( "\nSid bytes are: " );
        FsTestHexDumpLongs( (PVOID) &Ptr->Sid, Ptr->SidLength );

        // why 0x38?  it's SIZEOF_QUOTA_USER_DATA (which isn't exported to this test) + 8 for quad alignment

        CurrentEntrySize = Ptr->SidLength + 0x38;
        Ptr = (PFILE_QUOTA_INFORMATION) ((PUCHAR)Ptr + CurrentEntrySize);

        RemainingBytesToDump -= CurrentEntrySize;

        Idx += 1;
    }
}


int
FsTestEnumerateQuota (
	IN HANDLE hFile
	)
{
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS Status;
    FILE_QUOTA_INFORMATION QuotaInfo[4];
    BOOLEAN ReturnSingleEntry = FALSE;
    FILE_INFORMATION_CLASS InfoClass = FileQuotaInformation;

    //
    //  Init with garbage so we can make sure Ntfs is doing its job.
    //

    RtlFillMemory( QuotaInfo, sizeof(QuotaInfo), 0x51 );

	Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event
                                   NULL,     //  ApcRoutine
                                   NULL,     //  ApcContext
                                   &IoStatusBlock,
                                   &QuotaInfo[0],
                                   sizeof(QuotaInfo),
                                   InfoClass,
                                   ReturnSingleEntry,
                                   NULL,     //  FileName
                                   TRUE );   //  RestartScan

    if (Status == STATUS_SUCCESS) {

        FsTestDumpQuotaIndexEntries( &QuotaInfo[0], IoStatusBlock.Information );
    }

    while (Status == STATUS_SUCCESS) {

        //
        //  Init with garbage so we can make sure Ntfs is doing its job.
        //

        RtlFillMemory( QuotaInfo, sizeof(QuotaInfo), 0x51 );

	    Status = NtQueryDirectoryFile( hFile,
                                       NULL,     //  Event
                                       NULL,     //  ApcRoutine
                                       NULL,     //  ApcContext
                                       &IoStatusBlock,
                                       &QuotaInfo[0],
                                       sizeof(QuotaInfo),
                                       InfoClass,
                                       ReturnSingleEntry,
                                       NULL,     //  FileName
                                       FALSE );  //  RestartScan

        if (Status == STATUS_SUCCESS) {

            FsTestDumpQuotaIndexEntries( &QuotaInfo[0], IoStatusBlock.Information );
        }
    }

    printf( "\n" );

	return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    char Buffer[80];
    char Buff2[4];

    //
    //  Get parameters
    //

    if (argc < 2) {
        printf("This program enumerates the quota (if any) for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$Quota:$Q:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {

        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

	printf( "\nUsing directory:%s\n", Buffer );

	FsTestEnumerateQuota( hFile );

	CloseHandle( hFile );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\enumoid\enumoid.c ===
//  enumoid.c

#include "oidtst.h"


void
FsTestDumpObjIdIndexEntries (
    IN PFILE_OBJECTID_INFORMATION ObjIdInfo,
    IN ULONG_PTR LengthInBytes
    )

{
    ULONG ReturnedCount;
    ULONG Idx;

    ReturnedCount = (ULONG) LengthInBytes / sizeof( FILE_OBJECTID_INFORMATION );

    printf( "\n\nFound %x object id index entries", ReturnedCount );

    for (Idx = 0; Idx < ReturnedCount; Idx += 1) {

        printf( "\nEntry %x", Idx );
        FsTestHexDump( (UCHAR *)&ObjIdInfo[Idx].ObjectId, 16 );
        FsTestHexDump( (UCHAR *)&ObjIdInfo[Idx].ExtendedInfo, 16 );
    }
}


int
FsTestEnumerateOids (
	IN HANDLE hFile
	)
{
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS Status;
    FILE_OBJECTID_INFORMATION ObjIdInfo[4];
    BOOLEAN ReturnSingleEntry = TRUE;
    FILE_INFORMATION_CLASS InfoClass = FileObjectIdInformation;

	Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event
                                   NULL,     //  ApcRoutine
                                   NULL,     //  ApcContext
                                   &IoStatusBlock,
                                   &ObjIdInfo[0],
                                   sizeof(ObjIdInfo),
                                   InfoClass,
                                   ReturnSingleEntry,
                                   NULL,     //  FileName
                                   TRUE );   //  RestartScan

    if (Status == STATUS_SUCCESS) {

        FsTestDumpObjIdIndexEntries( &ObjIdInfo[0], IoStatusBlock.Information );
    }

    while (Status == STATUS_SUCCESS) {

        RtlFillMemory( ObjIdInfo, sizeof(ObjIdInfo), 0x51 );

	    Status = NtQueryDirectoryFile( hFile,
                                       NULL,     //  Event
                                       NULL,     //  ApcRoutine
                                       NULL,     //  ApcContext
                                       &IoStatusBlock,
                                       &ObjIdInfo[0],
                                       sizeof(ObjIdInfo),
                                       InfoClass,
                                       ReturnSingleEntry,
                                       NULL,     //  FileName
                                       FALSE );  //  RestartScan

        if (Status == STATUS_SUCCESS) {

            FsTestDumpObjIdIndexEntries( &ObjIdInfo[0], IoStatusBlock.Information );
        }
    }

    printf( "\n" );

	return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    char Buffer[80];
    char Buff2[4];

    //
    //  Get parameters
    //

    if (argc < 2) {
        printf("This program enumerates the object ids (if any) for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {

        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

	printf( "\nUsing directory:%s\n", Buffer );

	FsTestEnumerateOids( hFile );

	CloseHandle( hFile );

    return;
}

#if 0
////  graveyard
void
foobar() {

    UNICODE_STRING FakeFileName;
    UCHAR Buffer[16];

    FakeFileName.Length = FakeFileName.MaximumLength = 16;
    FakeFileName.Buffer = &Buffer[0];
    RtlZeroMemory( FakeFileName.Buffer, 16 );
    strcpy( FakeFileName.Buffer, "oidC" );

    printf( "\nWe'll restart from oid:" );
    FsTestHexDump( FakeFileName.Buffer, 16 );

    RtlFillMemory( ObjIdInfo, sizeof(ObjIdInfo), 0x51 );

    Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event
                                   NULL,     //  ApcRoutine
                                   NULL,     //  ApcContext
                                   &IoStatusBlock,
                                   &ObjIdInfo[0],
                                   sizeof(ObjIdInfo),
                                   InfoClass,
                                   ReturnSingleEntry,
                                   &FakeFileName,     //  FileName
                                   FALSE );  //  RestartScan

    if (Status == STATUS_SUCCESS) {

        FsTestDumpQuotaIndexEntries( QuotaInfo[0], IoStatusBlock.Information );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\enumr\enumr.c ===
//  enumr.c

#include "oidtst.h"


void
FsTestDumpReparsePointIndexEntries (
    IN PFILE_REPARSE_POINT_INFORMATION ReparsePointInfo,
    IN ULONG LengthInBytes
    )

{
    ULONG ReturnedCount;
    ULONG Idx;
    
    ReturnedCount = LengthInBytes / sizeof( FILE_REPARSE_POINT_INFORMATION );
    
    printf( "\n\nFound %x reparse point index entries", ReturnedCount );

    for (Idx = 0; Idx < ReturnedCount; Idx += 1) {

        printf( "\nEntry %x", Idx );
        printf( "\nTag %x", ReparsePointInfo[Idx].Tag );
        printf( "\nFileReference " );
        FsTestHexDumpLongs( &ReparsePointInfo[Idx].FileReference, 8 );
        printf( "\n" );
    }
}
   

int
FsTestEnumerateReparsePoints ( 
    IN HANDLE hFile
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    FILE_REPARSE_POINT_INFORMATION ReparsePointInfo[4];
    BOOLEAN ReturnSingleEntry = FALSE;
    FILE_INFORMATION_CLASS InfoClass = FileReparsePointInformation; 
    
    Status = NtQueryDirectoryFile( hFile,
                                   NULL,     //  Event 
                                   NULL,     //  ApcRoutine 
                                   NULL,     //  ApcContext 
                                   &IoStatusBlock,
                                   &ReparsePointInfo[0],
                                   sizeof(ReparsePointInfo),
                                   InfoClass, 
                                   ReturnSingleEntry,   
                                   NULL,     //  FileName 
                                   TRUE );   //  RestartScan 

    if (Status == STATUS_SUCCESS) {

        FsTestDumpReparsePointIndexEntries( &ReparsePointInfo[0], IoStatusBlock.Information );
    }

    while (Status == STATUS_SUCCESS) {     
        
        RtlFillMemory( ReparsePointInfo, sizeof(ReparsePointInfo), 0x51 );

        Status = NtQueryDirectoryFile( hFile,
                                       NULL,     //  Event 
                                       NULL,     //  ApcRoutine 
                                       NULL,     //  ApcContext 
                                       &IoStatusBlock,
                                       &ReparsePointInfo[0],
                                       sizeof(ReparsePointInfo),
                                       InfoClass, 
                                       ReturnSingleEntry,    
                                       NULL,     //  FileName 
                                       FALSE );  //  RestartScan 
        
        if (Status == STATUS_SUCCESS) {

            FsTestDumpReparsePointIndexEntries( &ReparsePointInfo[0], IoStatusBlock.Information );
        }
    }

    printf( "\n" );
    
    return FsTestDecipherStatus( Status ); 
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;    
    char Buffer[80];

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program enumerates the reparse points (if any) for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$Reparse:$R:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
    
        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

    printf( "\nUsing directory:%s\n", Buffer );

    FsTestEnumerateReparsePoints( hFile );

    CloseHandle( hFile );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\deloid\deloid.c ===
//  deloid.c

#include "oidtst.h"


int
FsTestDeleteOid( 
    IN HANDLE File
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( File,                     // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_DELETE_OBJECT_ID,   // FsControlCode
                              NULL,                     // input buffer
                              0,                        // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0                         // OutputBuffer Length
                             );

    return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    if (argc < 2) {
        printf("This program deletes the object id (if any) from a file (ntfs only).\n\n");
        printf("usage: %s filename\n", argv[0]);
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtCreateFile( &File,
                           GENERIC_WRITE | GENERIC_ALL | STANDARD_RIGHTS_ALL, 
                           &ObjAttr,
                           &IoStatusBlock,
                           NULL,                  
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,                  
                           0 );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error opening file %s %x\n", argv[1], Status );
        return;
    }

    printf( "\nUsing file:%s", argv[1] );

    FsTestDeleteOid( File );

    CloseHandle( File );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\inc\oidtst.h ===
// oidtst.h


#ifndef _OIDTST_H_
#define _OIDTST_H_

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>


int
FsTestDecipherStatus(
	IN NTSTATUS Status
	);

void
FsTestHexDump (
    IN UCHAR *Buffer,
    IN ULONG Size
    );
    
void
FsTestHexDumpLongs (
    IN ULONG *Buffer,
    IN ULONG SizeInBytes
    );
    
int
FsTestSetOid( 
	IN HANDLE hFile, 
	IN FILE_OBJECTID_BUFFER ObjectIdBuffer 
	);

int
FsTestGetOid( 
	IN HANDLE hFile, 
	IN FILE_OBJECTID_BUFFER *ObjectIdBuffer 
	);

int
FsTestOpenByOid ( 
    IN UCHAR *ObjectId,
    IN ULONG ArgLength,
    IN PWCHAR DriveLetter
    );

int
FsTestDeleteOid( 
	IN HANDLE hFile
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\genoid\genoid.c ===
//  genoid.c

#include "oidtst.h"


int
FsTestGenOid( 
    IN HANDLE hFile, 
    IN FILE_OBJECTID_BUFFER *ObjectIdBuffer 
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                           // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_CREATE_OR_GET_OBJECT_ID,   // FsControlCode
                              &hFile,                          // input buffer
                              sizeof(HANDLE),                  // input buffer length
                              ObjectIdBuffer,                  // OutputBuffer for data from the FS
                              sizeof(FILE_OBJECTID_BUFFER) );  // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nOid for this file is %s", ObjectIdBuffer->ObjectId );
        
        FsTestHexDump( ObjectIdBuffer->ObjectId, 16 );
        
        printf( "\nExtended info is %s\n", ObjectIdBuffer->ExtendedInfo );
    }

    return FsTestDecipherStatus( Status );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    char mybuffer[100];
    NTSTATUS GetNameStatus;

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program finds the object id of a file and generates one if necessary (ntfs only).\n\n");
        printf("usage: %s filename\n", argv[0]);
        return;
    }

    File = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( File == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    GetNameStatus = NtQueryInformationFile( File,
                                            &IoStatusBlock,
                                            mybuffer, 
                                            sizeof(mybuffer),
                                            FileNameInformation );
                                            
    printf( "\nGetNameStatus %x, Filename is:", GetNameStatus );        
    printf( "%S", (mybuffer + 4) );

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    printf( "\nUsing file:%s", argv[1] );

    FsTestGenOid( File, &ObjectIdBuffer );

    CloseHandle( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\getvid\getvid.c ===
//  getvid.c

#include "oidtst.h"


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

	FILE_OBJECTID_BUFFER ObjectIdBuffer;

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program finds the object id of a volume (ntfs only).\n\n");
        printf("usage: %s <drive letter>:\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtOpenFile( &Volume,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjAttr,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if (Volume == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    // RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    Status = NtQueryVolumeInformationFile( Volume,
                                           &IoStatusBlock,
                                           &ObjectIdBuffer, 
                                           sizeof(ObjectIdBuffer),
                                           FileFsObjectIdInformation );

    if (Status == STATUS_SUCCESS) {

        printf( "\nVolume Object Id is: " );
        FsTestHexDump( (UCHAR *)&ObjectIdBuffer.ObjectId, 16 );
        
        printf( "\nExtended info: " );
        FsTestHexDump( (UCHAR *)&ObjectIdBuffer.ExtendedInfo, 48 );
        
    } else {
    
        FsTestDecipherStatus( Status );
    }        
    
    CloseHandle( Volume );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\getoid\getoid.c ===
//  getoid.c

#include "oidtst.h"


int
FsTestGetOid(
    IN HANDLE hFile,
    IN FILE_OBJECTID_BUFFER *ObjectIdBuffer
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                           // file handle
                              NULL,                            // event
                              NULL,                            // apc routine
                              NULL,                            // apc context
                              &IoStatusBlock,                  // iosb
                              FSCTL_GET_OBJECT_ID,             // FsControlCode
                              &hFile,                          // input buffer
                              sizeof(HANDLE),                  // input buffer length
                              ObjectIdBuffer,                  // OutputBuffer for data from the FS
                              sizeof(FILE_OBJECTID_BUFFER) );  // OutputBuffer Length

    if (Status == STATUS_SUCCESS) {

        printf( "\nOid for this file is %s", ObjectIdBuffer->ObjectId );

        FsTestHexDump( ObjectIdBuffer->ObjectId, 16 );

        printf( "\nObjectId:%08x %08x %08x %08x\n",
                *((PULONG)&ObjectIdBuffer->ObjectId[12]),
                *((PULONG)&ObjectIdBuffer->ObjectId[8]),
                *((PULONG)&ObjectIdBuffer->ObjectId[4]),
                *((PULONG)&ObjectIdBuffer->ObjectId[0]) );

        printf( "\nExtended info is %s\n", ObjectIdBuffer->ExtendedInfo );

        FsTestHexDump( ObjectIdBuffer->ExtendedInfo, 48 );
    }

    return FsTestDecipherStatus( Status );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    char mybuffer[100];
    NTSTATUS GetNameStatus;
    NTSTATUS GetFrsStatus;
    FILE_INTERNAL_INFORMATION InternalInfo;

    //
    //  Get parameters
    //

    if (argc < 2) {
        printf("This program finds the object id of a file (ntfs only).\n\n");
        printf("usage: %s filename\n", argv[0]);
        return;
    }

    File = CreateFile( argv[1],
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( File == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    GetNameStatus = NtQueryInformationFile( File,
                                            &IoStatusBlock,
                                            mybuffer,
                                            sizeof(mybuffer),
                                            FileNameInformation );

    printf( "\nGetNameStatus %x, Filename is:", GetNameStatus );
    printf( "%S", (mybuffer + 4) );

    GetFrsStatus = NtQueryInformationFile( File,
                                           &IoStatusBlock,
                                           &InternalInfo,
                                           sizeof(InternalInfo),
                                           FileInternalInformation );

    printf( "\nGetFrsStatus %x, FRS is: (highpart lowpart )", GetFrsStatus );
    printf( "\n                         %08x %08x", InternalInfo.IndexNumber.HighPart, InternalInfo.IndexNumber.LowPart );

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    printf( "\nGetting object id for file:%s\n", argv[1] );

    FsTestGetOid( File, &ObjectIdBuffer );

    CloseHandle( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\setext\setext.c ===
// setext.c

#include "oidtst.h"


int
FsTestSetExtendedInfo( 
    IN HANDLE hFile, 
    IN PUCHAR ExtInfoBuffer
    )
{

    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                    // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_SET_OBJECT_ID_EXTENDED,  // FsControlCode
                              ExtInfoBuffer,            // input buffer
                              48,                       // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0 );                      // OutputBuffer Length

    return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    UCHAR ExtInfoBuffer[48];
    int retval = 0;

    //
    //  Get parameters 
    //

    if (argc < 3) {
        printf("This program sets the object id extended info for a file (ntfs only).\n\n");
        printf("usage: %s filename ExtendedInfo\n", argv[0]);
        return;
    }

    hFile = CreateFile( argv[1],
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    RtlZeroBytes( ExtInfoBuffer, sizeof( ExtInfoBuffer ) );

    sscanf( argv[2], "%s", &ExtInfoBuffer );    

    printf( "\nUsing file:%s, ExtendedInfo:%s", 
            argv[1], 
            ExtInfoBuffer );

    FsTestSetExtendedInfo( hFile, ExtInfoBuffer );

    CloseHandle( hFile );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\setoid\setoid.c ===
// setoid.c

#include "oidtst.h"


int
FsTestSetOid( 
    IN HANDLE hFile, 
    IN FILE_OBJECTID_BUFFER ObjectIdBuffer
    )
{

    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    Status = NtFsControlFile( hFile,                    // file handle
                              NULL,                     // event
                              NULL,                     // apc routine
                              NULL,                     // apc context
                              &IoStatusBlock,           // iosb
                              FSCTL_SET_OBJECT_ID,      // FsControlCode
                              &ObjectIdBuffer,          // input buffer
                              sizeof(ObjectIdBuffer),   // input buffer length
                              NULL,                     // OutputBuffer for data from the FS
                              0                         // OutputBuffer Length
                             );

    return FsTestDecipherStatus( Status );
}


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_OBJECTID_BUFFER ObjectIdBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

    //
    //  Get parameters.
    //

    if (argc < 4) {
    
        printf("This program sets an object id for a file (ntfs only).\n\n");
        printf("usage: %s filename ObjectId ExtendedInfo\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtCreateFile( &File,
                           GENERIC_WRITE | GENERIC_ALL | STANDARD_RIGHTS_ALL, 
                           &ObjAttr,
                           &IoStatusBlock,
                           NULL,                  
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,                  
                           0 );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error opening file %s %x\n", argv[1], Status );
        return;
    }

    RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    sscanf( argv[2], "%s", &ObjectIdBuffer.ObjectId );
    sscanf( argv[3], "%s", &ObjectIdBuffer.ExtendedInfo );    

    printf( "\nUsing file:%s, ObjectId:%s, ExtendedInfo:%s", 
            argv[1], 
            ObjectIdBuffer.ObjectId,
            ObjectIdBuffer.ExtendedInfo );

    FsTestSetOid( File, ObjectIdBuffer );

    CloseHandle( File );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\setvid\setvid.c ===
// setvid.c

#include "oidtst.h"


VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE Volume;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjAttr;
    ANSI_STRING AnsiName;
    UNICODE_STRING UnicodeName;
    char DriveNameBuffer[32];

	FILE_OBJECTID_BUFFER ObjectIdBuffer;

    //
    //  Get parameters 
    //

    if (argc < 4) {
        printf("This program sets the object id for a volume (ntfs only).\n\n");
        printf("usage: %s <drive letter>: ObjectId ExtendedInfo\n", argv[0]);
        return;
    }

    strcpy( DriveNameBuffer, "\\DosDevices\\" );
    strcat( DriveNameBuffer, argv[1] );
    RtlInitAnsiString( &AnsiName, DriveNameBuffer );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS(Status)) {
    
        printf( "Error initalizing strings" );
        return;
    }

    RtlZeroMemory( &ObjAttr, sizeof(OBJECT_ATTRIBUTES) );
    ObjAttr.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjAttr.ObjectName = &UnicodeName;
    ObjAttr.Attributes = OBJ_CASE_INSENSITIVE;
    
    Status = NtOpenFile( &Volume,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjAttr,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if (Volume == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    // RtlZeroBytes( &ObjectIdBuffer, sizeof( ObjectIdBuffer ) );

    sscanf( argv[2], "%s", &ObjectIdBuffer.ObjectId );
    sscanf( argv[3], "%s", &ObjectIdBuffer.ExtendedInfo );	

    printf( "\nUsing ObjectId:%s, ExtendedInfo:%s\n", 
			ObjectIdBuffer.ObjectId,
			ObjectIdBuffer.ExtendedInfo );

    Status = NtSetVolumeInformationFile( Volume, 
                                         &IoStatusBlock,
                                         &ObjectIdBuffer,
                                         sizeof( ObjectIdBuffer ),
                                         FileFsObjectIdInformation );

    FsTestDecipherStatus( Status );
    
    CloseHandle( Volume );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\rootattr\rootattr.c ===
//  rootattr.c

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntioapi.h>


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_BASIC_INFORMATION basicInfo;
    HANDLE hFile;
    NTSTATUS status;
    char buffer[260];

    //
    //  Get parameters
    //

    if (argc < 2) {

        printf("This program returns or sets the attributes for the root directory.\n\n");
        printf("usage: %s driveletter [new value]\n", argv[0]);
        return;
    }

    strcpy( buffer, argv[1] );
    strcat( buffer, "\\" );

    hFile = CreateFile( buffer,
                        MAXIMUM_ALLOWED,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {

        printf( "Error opening directory %s, error %d (decimal)\n", buffer, GetLastError() );
        return;
    }

    status = NtQueryInformationFile( hFile,
                                     &ioStatusBlock,
                                     &basicInfo,
                                     sizeof( basicInfo ),
                                     FileBasicInformation );

    if (!NT_SUCCESS( status )) {
    
    	printf( "Couldn't get attributes, error status %x\n", status );
    	CloseHandle( hFile );
        return;
    }

    printf( "Attributes for %s are currently: %0x\n", buffer, basicInfo.FileAttributes );

    if (argc >= 3) {

        //
        //  Third argument present, must be setting attributes.
        //

        sscanf( argv[2], "%02x", &basicInfo.FileAttributes );

        printf( "Setting attributes for %s to: %0x\n", buffer, basicInfo.FileAttributes );

        status = NtSetInformationFile( hFile,
                                       &ioStatusBlock,
                                       &basicInfo,
                                       sizeof( basicInfo ),
                                       FileBasicInformation );
        if (NT_SUCCESS( status )) {

            printf( "Set attributes succesfully\n" );

        } else {

        	printf( "Couldn't set attributes, error status %x\n", status );
    	}
    }

	CloseHandle( hFile );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\oboid\oboid.c ===
//  oboid.c

#include "oidtst.h"

//
//  Build with USE_RELATIVE_OPEN set to one to use relative opens for
//  object IDs.  Build with USE_RELATIVE_OPEN set to zero to use a device
//  path open for object IDs.
//  Opens by File ID always use a relative open.
//

#define USE_RELATIVE_OPEN 1

#define VOLUME_PATH  L"\\\\.\\H:"
#define VOLUME_DRIVE_LETTER_INDEX 4
#define FULL_PATH    L"\\??\\H:\\1234567890123456"
#define FULL_DRIVE_LETTER_INDEX 4
#define DEVICE_PREFIX_LEN 14


int
FsTestOpenByOid (
    IN UCHAR *ObjectId,
    IN ULONG ArgLength,
    IN PWCHAR DriveLetter
    )
{
    HANDLE File;
    HANDLE DumpFile;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    NTSTATUS ReadStatus;
    NTSTATUS WriteStatus;
    NTSTATUS GetNameStatus;
    NTSTATUS CloseStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING str;
    char mybuffer[32768];
    PFILE_NAME_INFORMATION FileName;
    LARGE_INTEGER ByteOffset;
    HANDLE VolumeHandle;
    DWORD WStatus;
    WCHAR Full[] = FULL_PATH;        // Arrays of WCHAR's aren't constants
    WCHAR Volume[] = VOLUME_PATH;
    ULONG BytesToWrite;

    RtlInitUnicodeString( &str, Full );

    RtlCopyMemory( &str.Buffer[FULL_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
    str.Length = 0x1E;

    if (ArgLength == 32) {

        //
        //  Open by Object ID.
        //

#if USE_RELATIVE_OPEN

        //
        //  Open the volume for relative opens.
        //

        RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
        printf( "\nOpening volume handle, this may take a while..." );
        VolumeHandle = CreateFileW( (PUSHORT) &Volume,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        if (VolumeHandle == INVALID_HANDLE_VALUE) {

            WStatus = GetLastError();
            printf( "Unable to open %ws volume\n", &Volume );
            printf( "Error from CreateFile", WStatus );
            return WStatus;
        }

        str.Length = 16;
        RtlCopyMemory( &str.Buffer[0],  //  no device prefix for relative open.
                       ObjectId,
                       16 );

#else

        //
        //  Form open path using a device prefix string.
        //

        str.Length = DEVICE_PREFIX_LEN+16;
        RtlCopyMemory( &str.Buffer[DEVICE_PREFIX_LEN/2],  //  DEVICE_PREFIX_LEN/2 goes past "\??\D:\"
                       ObjectId,
                       16 );

        VolumeHandle = NULL;

#endif

    } else if (ArgLength == 16) {

        //
        //  Open by File Reference Number (FileID),
        //  Relative opens from the Volume Handle.
        //

        RtlCopyMemory( &Volume[VOLUME_DRIVE_LETTER_INDEX], DriveLetter, sizeof(WCHAR) );
        printf( "\nOpening volume handle, this may take a while..." );
        VolumeHandle = CreateFileW( (PUSHORT) &Volume,
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL );

        if (VolumeHandle == INVALID_HANDLE_VALUE ) {

            WStatus = GetLastError();
            printf( "Unable to open %ws volume\n", &Volume );
            printf( "Error from CreateFile", WStatus );
            return WStatus;
        }

        str.Length = 8;
        RtlCopyMemory( &str.Buffer[0],  //  no device prefix for relative open.
                       ObjectId,
                       8 );

    } else {

        return 0;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                &str,
                                OBJ_CASE_INSENSITIVE,
                                VolumeHandle,
                                NULL );

    Status = NtCreateFile( &File,
                           GENERIC_READ, // GENERIC_ALL | STANDARD_RIGHTS_ALL,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,                  // AllocationSize
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_BY_FILE_ID,
                           NULL,                  // EaBuffer
                           0 );

    if (NT_SUCCESS( Status )) {

        printf( "\nOpened file succesfully" );
#if 0
        ByteOffset.HighPart = ByteOffset.LowPart = 0;

        ReadStatus = NtReadFile( File,
                                 NULL,            //  Event
                                 NULL,            //  ApcRoutine
                                 NULL,            //  ApcContext
                                 &IoStatusBlock,
                                 mybuffer,
                                 sizeof(mybuffer),
                                 &ByteOffset,    //  ByteOffset
                                 NULL );         //  Key

        printf( "\nReadstatus %x, read %x bytes.  Here they are: ",
                ReadStatus,
                IoStatusBlock.Information );

        printf( "\n%s", mybuffer );

        printf( "\nThat's it" );
#endif

#if 1
        FileName = (PFILE_NAME_INFORMATION) &mybuffer[0];
        FileName->FileNameLength = sizeof(mybuffer) - sizeof(ULONG);

        GetNameStatus = NtQueryInformationFile( File,
                                                &IoStatusBlock,
                                                FileName,
                                                sizeof(mybuffer),
                                                FileNameInformation );

        printf( "\nGetNameStatus %x, Filename is ", GetNameStatus );
        printf( "%S\n", FileName->FileName );
#endif

#if 0

        DumpFile = CreateFile( "c:\\dumpfile",
                               GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               0,
                               NULL );

        if (DumpFile == INVALID_HANDLE_VALUE) {

            printf( "Error opening dump file %x\n", GetLastError() );
            return FALSE;
        }

        ByteOffset.HighPart = ByteOffset.LowPart = 0;

        while(TRUE) {

            ReadStatus = NtReadFile( File,
                                     NULL,            //  Event
                                     NULL,            //  ApcRoutine
                                     NULL,            //  ApcContext
                                     &IoStatusBlock,
                                     mybuffer,
                                     sizeof(mybuffer),
                                     &ByteOffset,    //  ByteOffset
                                     NULL );         //  Key

            BytesToWrite = IoStatusBlock.Information;

            if (NT_SUCCESS( ReadStatus) &&
                BytesToWrite > 0) {

                WriteStatus = NtWriteFile( DumpFile,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &IoStatusBlock,
                                           mybuffer,
                                           BytesToWrite,
                                           &ByteOffset,
                                           NULL );

                printf( "\nOffset %x", ByteOffset.LowPart );
                ByteOffset.LowPart += BytesToWrite;

            } else {

                break;
            }
        }

        printf( "\n" );
        CloseStatus = NtClose( DumpFile );
#endif
        CloseStatus = NtClose( File );

        if (!NT_SUCCESS( CloseStatus )) {

            printf( "\nCloseStatus %x", CloseStatus );
        }
    }

    if (VolumeHandle != NULL) {

        CloseHandle( VolumeHandle );
    }

    return FsTestDecipherStatus( Status );
}

VOID
StrToGuid(
    IN PCHAR  s,
    OUT GUID  *pGuid
    )
/*++

Routine Description:

    Convert a string in GUID display format to an object ID that
    can be used to lookup a file.

    based on a routine by Mac McLain

Arguments:

    pGuid - ptr to the GUID.

    s - The input character buffer in display guid format.
        e.g.:  b81b486b-c338-11d0-ba4f0000f80007df

        Must be at least GUID_CHAR_LEN (35 bytes) long.

Function Return Value:

    None.

--*/
{
#define DEBSUB "GuidToStr:"

    if (pGuid != NULL) {

        sscanf( s, "%08lx-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                &pGuid->Data1,
                &pGuid->Data2,
                &pGuid->Data3,
                &pGuid->Data4[0],
                &pGuid->Data4[1],
                &pGuid->Data4[2],
                &pGuid->Data4[3],
                &pGuid->Data4[4],
                &pGuid->Data4[5],
                &pGuid->Data4[6],
                &pGuid->Data4[7] );
    } else {

        sprintf( s, "<ptr-null>" );
    }
}

VOID
FsTestObOidHelp(
    char *ExeName
    )
{

    printf( "This program opens a file by its file id or object id (ntfs only).\n\n" );
    printf( "usage: %s x: [FileID | Raw ObjectId | Guid Display Format ObjectID]\n", ExeName );

    printf( "Where x: is the drive letter\n" );

    printf( "A FileID is a string of 16 hex digits with a space between each\n"
            "group of 8.  E.G. oboid 00010000 00000024\n\n" );

    printf( "A raw object ID is a string of 32 hex digits with a space\n"
            "between each group of 8\n"
            "E.G. ObjectId:df0700f8 00004fba 11d0c338 b81b485f\n\n" );

    printf( "A GUID display format object ID is a string of the form \n"
            "b81b486b-c338-11d0-ba4f0000f80007df\n"
            "See the struct def for GUID in sdk\\inc\\winnt.h for byte layout.\n" );
}

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG ObjectId[4];
    ULONG Length;
    WCHAR Drive;

    //
    //  Get parameters.
    //

    if (argc < 3) {

        FsTestObOidHelp( argv[0] );
        return;
    }

    RtlZeroBytes( ObjectId,
                  sizeof( ObjectId ) );

    Length = strlen( argv[2] );

    if ((argc == 3) && (Length == 35) && (argv[2][8] == '-')) {

        StrToGuid( argv[2], (GUID *)ObjectId );
        printf( "\nUsing ObjectId: %08x %08x %08x %08x\n",
                ObjectId[3], ObjectId[2], ObjectId[1], ObjectId[0] );
        Length = 32;

    } else if (argc == 6) {

        sscanf( argv[2], "%08x", &ObjectId[3] );
        sscanf( argv[3], "%08x", &ObjectId[2] );
        sscanf( argv[4], "%08x", &ObjectId[1] );
        sscanf( argv[5], "%08x", &ObjectId[0] );
        printf( "\nUsing ObjectId: %08x %08x %08x %08x\n",
                ObjectId[3], ObjectId[2], ObjectId[1], ObjectId[0] );
        Length = 32;

    } else if (argc == 4) {

        sscanf( argv[2], "%08x", &ObjectId[1] );
        sscanf( argv[3], "%08x", &ObjectId[0] );
        printf( "\nUsing FileId: %08x %08x\n", ObjectId[1], ObjectId[0] );
        Length = 16;

    } else {

        printf("Arg (%s) invalid format.\n\n", argv[2]);
        FsTestObOidHelp( argv[0] );
    }

    Drive = *argv[1];
    FsTestOpenByOid( (PUCHAR) ObjectId, Length, &Drive );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\notify\notify.c ===
//  notify.c

#include "oidtst.h"


int
FsTestNotifyOidChange ( 
    IN HANDLE hFile
    )
{
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UCHAR Buffer1[128];
    UCHAR Buffer2[128];
    PFILE_NOTIFY_INFORMATION NotifyBuffer1;
    PFILE_NOTIFY_INFORMATION NotifyBuffer2;
//    KEVENT Event1;
//    KEVENT Event2;

    RtlZeroMemory( &Buffer1[0], sizeof(Buffer1) );
    RtlZeroMemory( &Buffer2[0], sizeof(Buffer2) );

//    KeInitializeEvent( &Event1, NotificationEvent, FALSE );
//    KeInitializeEvent( &Event2, NotificationEvent, FALSE );
    
    Status = NtNotifyChangeDirectoryFile( hFile,
                                          NULL,     // Event 
                                          NULL,       // ApcRoutine 
                                          NULL,       // ApcContext 
                                          &IoStatusBlock,
                                          &Buffer1[0],
                                          sizeof(Buffer1),
                                          FILE_NOTIFY_CHANGE_FILE_NAME,
                                          TRUE );
#if 0
    Status = NtNotifyChangeDirectoryFile( hFile,
                                          NULL,     // Event 
                                          NULL,       // ApcRoutine 
                                          NULL,       // ApcContext 
                                          &IoStatusBlock,
                                          &Buffer2[0],
                                          sizeof(Buffer2),
                                          FILE_NOTIFY_CHANGE_FILE_NAME,
                                          TRUE );
#endif
    NotifyBuffer1 = (PFILE_NOTIFY_INFORMATION) &Buffer1[0];

    // NextEntryOffset
    printf( "\nAction %d", NotifyBuffer1->Action );
    printf( "\nLength %d", NotifyBuffer1->FileNameLength );
    
    printf( "\nObjectId " );
    FsTestHexDump( NotifyBuffer1->FileName, NotifyBuffer1->FileNameLength );
    printf( "\n" );

    return FsTestDecipherStatus( Status ); 
}


VOID
_cdecl
main (
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;    
    char Buffer[80];
    char Buff2[4];

    //
    //  Get parameters 
    //

    if (argc < 2) {
        printf("This program watches for changes to the object id index for a volume (ntfs only).\n\n");
        printf("usage: %s driveletter\n", argv[0]);
        return;
    }

    strcpy( Buffer, argv[1] );
    strcat( Buffer, "\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION" );

    hFile = CreateFile( Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ, 
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE ) {
    
        printf( "Error opening directory %s (dec) %d\n", Buffer, GetLastError() );
        return;
    }

    printf( "\nUsing directory:%s\n", Buffer );

    FsTestNotifyOidChange( hFile );

    CloseHandle( hFile );    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\objectid\offline\offline.c ===
//  offline.c

#include "oidtst.h"

VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE File;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UCHAR ArgStr[2];

    if (argc < 3) {
        printf( "This program finds the object id of a file (ntfs only).\n\n" );
        printf( "usage: %s filename [+ | -]\n", argv[0] );
        printf( "example: %s foo.dll +\n", argv[0] );
        return;
    }

    File = CreateFile( argv[1],
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if (File == INVALID_HANDLE_VALUE) {
    
        printf( "Error opening file %s %x\n", argv[1], GetLastError() );
        return;
    }

    Status = NtQueryInformationFile( File,
                                     &IoStatusBlock,
                                     &BasicInfo, 
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (*argv[2] == '+') {

        BasicInfo.FileAttributes |= FILE_ATTRIBUTE_OFFLINE;
        
    } else if (*argv[2] == '-') {

        BasicInfo.FileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;
        
    } else {

        printf( "Invalid parameter %s, use either + or -\n", argv[2] );
        Status = STATUS_INVALID_PARAMETER;
    }    
    
    if (NT_SUCCESS(Status)) {
    
        printf( "\nAdjusting offline attribute for file %s", argv[1] );
        
        Status = NtSetInformationFile( File,
                                       &IoStatusBlock,
                                       &BasicInfo, 
                                       sizeof(BasicInfo),
                                       FileBasicInformation );

        if (!NT_SUCCESS(Status)) {

            printf( "Error setting info%x\n", Status );
        }
    }

    CloseHandle( File );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\syscache\dumplog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       dumplog.cxx
//
//  Contents:   
//
//  Classes:    
//
//  Functions:  
//
//  Coupling:   
//
//  Notes:      
//
//  History:    2-05-2000   benl   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

typedef struct _SYSCACHE_LOG {
    int Event;
    int Flags;
    LONGLONG Start;
    LONGLONG Range;
    LONGLONG Result;
//    ULONG          ulDump;
} SYSCACHE_LOG, *PSYSCACHE_LOG;

typedef struct _ON_DISK_SYSCACHE_LOG {
    ULONG SegmentNumberUnsafe;    
    ULONG Reserved;
    int Event;
    int Flags;
    LONGLONG Start;
    LONGLONG Range;
    LONGLONG Result;
} ON_DISK_SYSCACHE_LOG, *PON_DISK_SYSCACHE_LOG;

#define SCE_VDL_CHANGE          0
#define SCE_ZERO_NC             1
#define SCE_ZERO_C              2
#define SCE_READ                3
#define SCE_WRITE               4
#define SCE_ZERO_CAV            5
#define SCE_ZERO_MF             6
#define SCE_ZERO_FST            7
#define SCE_CC_FLUSH            8
#define SCE_CC_FLUSH_AND_PURGE  9
#define SCE_WRITE_FILE_SIZES   10

#define SCE_MAX_EVENT           11


#define SCE_FLAG_WRITE 0x1
#define SCE_FLAG_READ  0x2
#define SCE_FLAG_PAGING 0x4
#define SCE_FLAG_ASYNC  0x8
#define SCE_FLAG_SET_ALLOC 0x10
#define SCE_FLAG_SET_EOF   0x20
#define SCE_FLAG_CANT_WAIT 0x40
#define SCE_FLAG_SYNC_PAGING 0x80
#define SCE_FLAG_LAZY_WRITE 0x100
#define SCE_FLAG_CACHED 0x200
#define SCE_FLAG_ON_DISK_READ 0x400
#define SCE_FLAG_RECURSIVE  0x800
#define SCE_FLAG_NON_CACHED  0x1000
#define SCE_FLAG_UPDATE_FROM_DISK  0x2000

#define SCE_MAX_FLAG   0x4000


char * LogEvent[] =
{
    "SCE_VDL_CHANGE",
    "SCE_ZERO_NC",
    "SCE_ZERO_C",
    "SCE_READ",
    "SCE_WRITE",
    "SCE_ZERO_CAV",
    "SCE_ZERO_MF",
    "SCE_ZERO_FST",
	"SCE_CC_FLUSH",
    "SCE_CC_FLUSH_AND_PURGE",
    "SCE_WRITE_FILE_SIZES",
    "SCE_MAX_EVENT"
};


void __cdecl main (int argc, char *argv[])
{
    HANDLE hFile;
    TCHAR szName[] = "c:\\$ntfs.log"; 
    UCHAR szBuffer[ 0x1000 ];
    PON_DISK_SYSCACHE_LOG pEntry;
    ULONG ulRet;
    int iIndex;

    if (argc < 2 || argv[1][0] == '\0') {
        printf( "Utility to dump $ntfs.log\n" );
        printf( "Usage: dumpsyscachelog drive:\n" );
        return;
    }
    
    szName[0] = argv[1][0];
    hFile = CreateFile( szName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "Open of %s failed %d\n", szName, GetLastError() );
        return;
    }

    do {
        if (!ReadFile( hFile,
                       &szBuffer,
                       sizeof( szBuffer ),
                       &ulRet,
                       NULL )) {

            printf( "ReadFile failed %d\n", GetLastError() );
            return;
        }

        pEntry = (PON_DISK_SYSCACHE_LOG)szBuffer;

        for (iIndex=0; iIndex < 0x1000 / sizeof( ON_DISK_SYSCACHE_LOG ); iIndex++)  {
            
            //
            //  Breakout if the segref is 0, we're at the end of the log
            //  

            if (pEntry->SegmentNumberUnsafe == 0) {
                return;
            } else {
                printf( "File: 0x%x ", pEntry->SegmentNumberUnsafe ); 
            }

            if (pEntry->Event < SCE_MAX_EVENT) {
                printf( "(%s)\n", LogEvent[pEntry->Event] );
            } else {
                printf( "\n" );
            }

            printf( "Flags: 0x%x (", pEntry->Flags);
            if (pEntry->Flags & SCE_FLAG_WRITE) {
                printf( "write " );
            }
            if (pEntry->Flags & SCE_FLAG_READ) {
                printf( "read " );
            }
            if (pEntry->Flags & SCE_FLAG_PAGING) {
                printf( "paging io " );
            }
            if (pEntry->Flags & SCE_FLAG_ASYNC) {
                printf( "asyncfileobj " );
            }
            if (pEntry->Flags & SCE_FLAG_SET_ALLOC) {
                printf( "setalloc " );
            }
            if (pEntry->Flags & SCE_FLAG_SET_EOF) {
                printf( "seteof " );
            }
            if (pEntry->Flags & SCE_FLAG_CANT_WAIT) {
                printf( "cantwait ");
            }
            if (pEntry->Flags & SCE_FLAG_SYNC_PAGING) {
                printf( "synchpaging " );
            }
            if (pEntry->Flags & SCE_FLAG_LAZY_WRITE) {
                printf( "lazywrite " );
            }
            if (pEntry->Flags & SCE_FLAG_CACHED) {
                 printf( "cached " );
            }
            if (pEntry->Flags & SCE_FLAG_ON_DISK_READ) {
                 printf( "fromdisk " );
            }
            if (pEntry->Flags & SCE_FLAG_RECURSIVE) {
                 printf( "recursive " );
            }
            if (pEntry->Flags & SCE_FLAG_NON_CACHED) {
                 printf( "noncached " );
            }

            if (pEntry->Flags & SCE_FLAG_UPDATE_FROM_DISK) {
                printf( "updatefromdisk " );
            }

            printf(")\n");
            printf("Start: 0x%I64x Range: 0x%I64x Result: 0x%I64x\n\n",
                    pEntry->Start, pEntry->Range, pEntry->Result);

            pEntry++;

        } //  endfor


    } while ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\usntest\usntest.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    UsnTest.c

Abstract:

    This is the main module for the UsnJournal test.

Author:

    Tom Miller 14-Jan-1997

Revision History:

--*/

#include "UsnTest.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <windows.h>

//
//  Current delay is 10 seconds
//

#define DELAY_TIME                       ((LONGLONG)(-100000000))

void
UsnTest(
    IN PCHAR DrivePath,
    IN ULONG Async
    );

CHAR *
FileTimeToString(
    FILETIME *pft
    );


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    char *p;
    int i;
    char c;
    char DrivePath[ 4 ];
    ULONG Async = FALSE;

    if ( argc > 1 ) {
        if (argc > 2) {
            Async = TRUE;
        }
        while (--argc) {
            p = *++argv;
            if ( isalpha(*p) ) {
                sprintf( DrivePath, "%c:", *p );
                UsnTest( DrivePath, Async );
                break;
            }
        }
    } else {
        printf( "UsnTest <DriveLetter> [A](for asyncmode)" );
    }

    return( 0 );
}

void
UsnTest(
    IN PCHAR DrivePath,
    IN ULONG Async
    )

{
    UCHAR VolumePath[16];
    HANDLE VolumeHandle;
    HANDLE Event;
    DWORD ReturnedByteCount;
    CREATE_USN_JOURNAL_DATA CreateUsnJournalData = {0x800000, 0x100000};
    READ_USN_JOURNAL_DATA ReadUsnJournalData = {0, MAXULONG, 0, DELAY_TIME, 1};
    ULONGLONG Buffer[1024];
    PUSN_RECORD UsnRecord;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    //
    //  Create the event.
    //

    Status = NtCreateEvent( &Event, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );

    if (!NT_SUCCESS(Status)) {
        printf( "NtCreateEvent failed with %08lx\n", Status );
        return;
    }

    //
    //  Get a volume handle.
    //

    _strupr( DrivePath );
    sprintf( VolumePath, "\\\\.\\%s", DrivePath );
    VolumeHandle = CreateFile( VolumePath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               (Async ? FILE_FLAG_OVERLAPPED : 0),
                               NULL );

    if (VolumeHandle == INVALID_HANDLE_VALUE ) {
        fprintf( stderr, "UsnTest: Unable to open %s volume (%u)\n", &VolumePath, GetLastError() );
        return;
    }

    //
    //  Create the Usn Journal if it does not exist.
    //

    printf( "Creating UsnJournal on %s\n", DrivePath );

    if (!NT_SUCCESS( Status = NtFsControlFile( VolumeHandle,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &Iosb,
                                               FSCTL_CREATE_USN_JOURNAL,
                                               &CreateUsnJournalData,
                                               sizeof(CreateUsnJournalData),
                                               NULL,
                                               0 ))) {

        printf( "Create Usn Journal failed (%08lx)\n", Status );
        return;

    } else {

        while (TRUE) {

            Status = NtFsControlFile( VolumeHandle,
                                      Async ? Event : NULL,
                                      NULL,
                                      NULL,
                                      &Iosb,
                                      FSCTL_READ_USN_JOURNAL,
                                      &ReadUsnJournalData,
                                      sizeof(ReadUsnJournalData),
                                      &Buffer,
                                      sizeof(Buffer) );

            if (Status == STATUS_PENDING) {
                NtWaitForSingleObject( Event, TRUE, NULL );
            }

            if (NT_SUCCESS(Status)) {
                Status = Iosb.Status;
            }

            if (Status == STATUS_KEY_DELETED) {
                printf( "\n\nUsn %08lx, %08lx has been deleted, seeking to new journal start\n\n\n",
                        (ULONG)ReadUsnJournalData.StartUsn,
                        (ULONG)(ReadUsnJournalData.StartUsn >> 32) );
                ReadUsnJournalData.StartUsn = 0;
                continue;
            }

            if (!NT_SUCCESS(Status)) {
                printf( "Read Usn Journal failed (%08lx)\n", Status );
                return;
            }

            ReturnedByteCount = Iosb.Information;
            if (ReturnedByteCount != 0) {

                UsnRecord = (PUSN_RECORD)((PCHAR)&Buffer + sizeof(USN));
                ReturnedByteCount -= sizeof(USN);
                ReadUsnJournalData.StartUsn = *(USN *)&Buffer;
                printf( "Next Usn will be: %08lx, %08lx\n",
                        (ULONG)ReadUsnJournalData.StartUsn,
                        (ULONG)(ReadUsnJournalData.StartUsn >> 32) );
            }


            while (ReturnedByteCount != 0) {

                printf( "Usn: %08lx, %08lx, RecordLength: %lx, FileRef: %08lx, %08lx, ParentRef: %08lx, %08lx\n",
                        (ULONG)UsnRecord->Usn,
                        (ULONG)(UsnRecord->Usn >> 32),
                        UsnRecord->RecordLength,
                        (ULONG)UsnRecord->FileReferenceNumber,
                        (ULONG)(UsnRecord->FileReferenceNumber >> 32),
                        (ULONG)UsnRecord->ParentFileReferenceNumber,
                        (ULONG)(UsnRecord->ParentFileReferenceNumber >> 32) );
                printf( "    Reason: %08lx, SecurityId: %08lx, TimeStamp: %s\n    FileName: %S\n",
                        UsnRecord->Reason,
                        UsnRecord->SecurityId,
                        FileTimeToString((FILETIME *)&UsnRecord->TimeStamp),
                        &UsnRecord->FileName );

                if (UsnRecord->RecordLength <= ReturnedByteCount) {
                    ReturnedByteCount -= UsnRecord->RecordLength;
                    UsnRecord = (PUSN_RECORD)((PCHAR)UsnRecord + UsnRecord->RecordLength);
                } else {
                    printf( "********Bogus ReturnedByteCount: %08lx\n", UsnRecord->RecordLength );
                    ReturnedByteCount = 0;
                }
            }

            //
            //  Show the end of the request.
            //

            printf( "\n" );

            //
            //  Keep growing the data we will wait for, just to try some different cases.
            //  Basically this converges quickly to always waiting for a full buffer, or
            //  else the timeout.
            //

            if (ReadUsnJournalData.BytesToWaitFor < sizeof(Buffer)) {
                if (!Async || (ReadUsnJournalData.BytesToWaitFor < 512)) {
                    ReadUsnJournalData.BytesToWaitFor << 2;
                }
            }
        }
    }

    CloseHandle( VolumeHandle );
    return;
}


char *Days[] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

char *Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

CHAR *
FileTimeToString(FILETIME *FileTime)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;
    static char Buffer[32];

    Buffer[0] = '\0';
    if (FileTime->dwHighDateTime != 0 || FileTime->dwLowDateTime != 0)
    {
        if (!FileTimeToLocalFileTime(FileTime, &LocalFileTime) ||
            !FileTimeToSystemTime(&LocalFileTime, &SystemTime))
        {
            return("Time???");
        }
        sprintf(
            Buffer,
            "%s %s %2d, %4d %02d:%02d:%02d",
            Days[SystemTime.wDayOfWeek],
            Months[SystemTime.wMonth - 1],
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
    }
    return(Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\announce.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    announce.h

Abstract:

    This module defines the structures for the bowsers server announcement
    table


Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#ifndef _ANNOUNCE_
#define _ANNOUNCE_

//
//  The ANNOUNCE_ENTRY structure is used to hold a server announcement
//  inside the bowser FSP announcement database.  This structure is allocated
//  out of paged pool.
//

//
//  Note that text strings are kept internally as unicode, not ANSI in the
//  announcement database.
//

#define ANNOUNCE_OLD_BACKUP 0x00000001

typedef struct _ANNOUNCE_ENTRY {
    CSHORT  Signature;
    CSHORT  Size;
    ULONG   ExpirationTime;                     // Time server was last seen.
    ULONG   SerialId;                           // Serial resume key.
    LIST_ENTRY BackupLink;                      // Link if backup browser.
    PBOWSER_NAME Name;                          // The domain this is on.
    USHORT  ServerBrowserVersion;               // Browser version of server.
    WCHAR   ServerName[NETBIOS_NAME_LEN+1];     // Server's name (UNICODE)
    ULONG   ServerType;                         // Bitmask of server type
    UCHAR   ServerVersionMajor;                 // Server's software version.
    UCHAR   ServerVersionMinor;                 // Server's software version II
    USHORT  ServerPeriodicity;                  // Server's announcement frequency in sec.
    ULONG   Flags;                              // Flags for server.
    ULONG   NumberOfPromotionAttempts;          // Number of times we tried to promote.
    WCHAR   ServerComment[LM20_MAXCOMMENTSZ+1]; // Servers comment (UNICODE).
} ANNOUNCE_ENTRY, *PANNOUNCE_ENTRY;

//
//  The VIEWBUFFER structure is a structure that is used to hold the contents
//  of a server announcement between the announcement being received in the
//  bowser's receive datagram indication routine and the announcement being
//  actually being placed into the announcement database.
//

typedef struct _VIEW_BUFFER {
    CSHORT  Signature;
    CSHORT  Size;
    union {
        LIST_ENTRY  NextBuffer;                 // Pointer to next buffer.
        WORK_QUEUE_ITEM WorkHeader;             // Executive worker item header.
    } Overlay;

    PTRANSPORT_NAME TransportName;

    BOOLEAN IsMasterAnnouncement;
    UCHAR   ServerName[NETBIOS_NAME_LEN+1];     // Server's name (ANSI).
    USHORT  ServerBrowserVersion;               // Browser version of server.
    UCHAR   ServerVersionMajor;                 // Server's software version.
    UCHAR   ServerVersionMinor;                 // Server's software version II
    USHORT  ServerPeriodicity;                  // Announcement freq. in sec.

    ULONG   ServerType;                         // Bitmask of server type

    UCHAR   ServerComment[LM20_MAXCOMMENTSZ+1]; // Servers comment (ANSI).
} VIEW_BUFFER, *PVIEW_BUFFER;


//
//  Specify the maximum number of threads that will be used to
//  process server announcements.
//
//
//  Since there is never any parallelism that can be gained from having
//  multiple threads, we limit this to 1 thread.
//

#define BOWSER_MAX_ANNOUNCE_THREADS 1

DATAGRAM_HANDLER(
    BowserHandleServerAnnouncement);

DATAGRAM_HANDLER(
    BowserHandleDomainAnnouncement);

RTL_GENERIC_COMPARE_RESULTS
BowserCompareAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    );

PVOID
BowserAllocateAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    );

VOID
BowserFreeAnnouncement (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );

PVIEW_BUFFER
BowserAllocateViewBuffer(
    VOID
    );

VOID
BowserFreeViewBuffer(
    IN PVIEW_BUFFER Buffer
    );

VOID
BowserProcessHostAnnouncement(
    IN PVOID Context
    );

VOID
BowserProcessDomainAnnouncement(
    IN PVOID Context
    );

VOID
BowserAgeServerAnnouncements(
    VOID
    );

NTSTATUS
BowserEnumerateServers(
    IN ULONG Level,
    IN PLUID LogonId OPTIONAL,
    IN OUT PULONG ResumeKey,
    IN ULONG ServerTypeMask,
    IN PUNICODE_STRING TransportName OPTIONAL,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    );

VOID
BowserAnnouncementDispatch (
    PVOID Context
    );


VOID
BowserDeleteGenericTable(
    IN PRTL_GENERIC_TABLE GenericTable
    );

NTSTATUS
BowserpInitializeAnnounceTable(
    VOID
    );

NTSTATUS
BowserpUninitializeAnnounceTable(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\ntfs\tests\usntest\usntest.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    UsnTest.h

Abstract:

    This is the main header file for the UsnTest.

Author:

    Tom Miller 14-Jan-1997

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>


int
ProcessParameters(
    int argc,
    char *argv[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowdata.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowdata.c

Abstract:

    Redirector Data Variables

    This module contains all of the definitions of the redirector data
    structures.

Author:

    Larry Osterman (LarryO) 30-May-1990

Revision History:

    30-May-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop

//
//  Paging out these pagable variables actually GROWS the browser by 512 bytes
//  so it's not worth doing it.
//

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

LIST_ENTRY
BowserNameHead = {0};

LIST_ENTRY
BowserTransportHead = {0};

LARGE_INTEGER
BowserStartTime = {0};

PEPROCESS
BowserFspProcess = {0};

BOOLEAN
BowserLogElectionPackets = {0};

//
//  Time out FindMaster requests after 30 seconds.
//

ULONG
BowserFindMasterTimeout = 30;


ULONG
BowserMinimumConfiguredBrowsers = MIN_CONFIGURED_BROWSERS;

ULONG
BowserMaximumBrowseEntries = MAX_BROWSE_ENTRIES;


#if DBG
ULONG
BowserMailslotDatagramThreshold = 10;

ULONG
BowserGetBrowserListThreshold = 10;

ULONG
BowserServerDeletionThreshold = 20;

ULONG
BowserDomainDeletionThreshold = 50;

#else

ULONG
BowserMailslotDatagramThreshold = 0xffffffff;

ULONG
BowserGetBrowserListThreshold = 0xffffffff;

ULONG
BowserServerDeletionThreshold = 0xffffffff;

ULONG
BowserDomainDeletionThreshold = 0xffffffff;
#endif

ULONG
BowserRandomSeed = {0};

LONG
BowserNumberOfOpenFiles = {0};


//
//  A pointer to the browser's device object
//

PBOWSER_FS_DEVICE_OBJECT
BowserDeviceObject = {0};

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
//  The redirector name and other initialization parameters are protected
//  by the BowserDataResource.  All reads of the initialization variables
//  should acquire the name resource before they continue.
//
//

ERESOURCE
BowserDataResource = {0};

//
//      Browser static data protected by BowserDataResource.
//

BOWSERDATA
BowserData = {0};

ULONG BowserOperationCount = 0;

ULONG
BowserCurrentTime = {0};

KSPIN_LOCK
BowserTransportMasterNameSpinLock = {0};

LONG
BowserEventLogResetFrequency = {0};

LONG
BowserIllegalDatagramCount = {0};

BOOLEAN
BowserIllegalDatagramThreshold = {0};

LONG
BowserIllegalNameCount = {0};

BOOLEAN
BowserIllegalNameThreshold = {0};

ULONG
BowserNumberOfMissedMailslotDatagrams = {0};

ULONG
BowserNumberOfMissedGetBrowserServerListRequests = {0};

BOWSER_STATISTICS
BowserStatistics = {0};

KSPIN_LOCK
BowserStatisticsLock = {0};

BOOLEAN
BowserRefuseReset = FALSE;

#ifdef PAGED_DBG
ULONG ThisCodeCantBePaged = 0;
#endif

#if     DBG

LONG BowserDebugTraceLevel = /* DPRT_ERROR | DPRT_DISPATCH */
                /*DPRT_FSDDISP | DPRT_FSPDISP | DPRT_CREATE | DPRT_READWRITE |*/
                /*DPRT_CLOSE | DPRT_FILEINFO | DPRT_VOLINFO | DPRT_DIRECTORY |*/
                /*DPRT_FILELOCK | DPRT_CACHE | DPRT_EAFUNC | */
                /*DPRT_ACLQUERY | DPRT_CLEANUP | DPRT_CONNECT | DPRT_FSCTL |*/
                /*DPRT_TDI | DPRT_SMBBUF | DPRT_SMB | DPRT_SECURITY | */
                /*DPRT_SCAVTHRD | DPRT_QUOTA | DPRT_FCB | DPRT_OPLOCK | */
                /*DPRT_SMBTRACE | DPRT_INIT |*/0;

LONG BowserDebugLogLevel = /* DPRT_ERROR | DPRT_DISPATCH */
                /*DPRT_FSDDISP | DPRT_FSPDISP | DPRT_CREATE | DPRT_READWRITE |*/
                /*DPRT_CLOSE | DPRT_FILEINFO | DPRT_VOLINFO | DPRT_DIRECTORY |*/
                /*DPRT_FILELOCK | DPRT_CACHE | DPRT_EAFUNC | */
                /*DPRT_ACLQUERY | DPRT_CLEANUP | DPRT_CONNECT | DPRT_FSCTL |*/
                /*DPRT_TDI | DPRT_SMBBUF | DPRT_SMB | DPRT_SECURITY | */
                /*DPRT_SCAVTHRD | DPRT_QUOTA | DPRT_FCB | DPRT_OPLOCK | */
                /*DPRT_SMBTRACE | DPRT_INIT |*/0;

#endif                                  // BOWSERDBG

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

BOWSER_CONFIG_INFO
BowserConfigEntries[] = {
    { BOWSER_CONFIG_IRP_STACK_SIZE, &BowserIrpStackSize, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_MAILSLOT_THRESHOLD, &BowserMailslotDatagramThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_GETBLIST_THRESHOLD, &BowserGetBrowserListThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_SERVER_DELETION_THRESHOLD, &BowserServerDeletionThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_DOMAIN_DELETION_THRESHOLD, &BowserDomainDeletionThreshold, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_FIND_MASTER_TIMEOUT, &BowserFindMasterTimeout, REG_DWORD, sizeof(DWORD) },
    { BOWSER_CONFIG_MINIMUM_CONFIGURED_BROWSER, &BowserMinimumConfiguredBrowsers, REG_DWORD, sizeof(DWORD) },
    { BROWSER_CONFIG_MAXIMUM_BROWSE_ENTRIES, &BowserMaximumBrowseEntries, REG_DWORD, sizeof(DWORD) },
    { BROWSER_CONFIG_REFUSE_RESET, &BowserRefuseReset, REG_BOOLEAN, sizeof(DWORD) },
#if DBG
    { L"BowserDebugTraceLevel", &BowserDebugTraceLevel, REG_DWORD, sizeof(DWORD) },
    { L"BowserDebugLogLevel", &BowserDebugLogLevel, REG_DWORD, sizeof(DWORD) },
#endif
    { NULL, NULL, REG_NONE, 0}
};

ULONG
BowserIrpStackSize = BOWSER_DEFAULT_IRP_STACK_SIZE;

//
//      STRING containing name of bowser device
//

UNICODE_STRING
BowserNameString = {0};

#ifdef  ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowbackp.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowbackp.h

Abstract:

    This module implements all of the backup browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/

#ifndef _BOWBACKP_
#define _BOWBACKP_

DATAGRAM_HANDLER(
BowserHandleBecomeBackup
    );

DATAGRAM_HANDLER(
    BowserResetState
    );

VOID
BowserResetStateForTransport(
    IN PTRANSPORT TransportName,
    IN UCHAR NewState
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\announce.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    announce.c

Abstract:

    This module implements the routines needed to manage the bowser's
announcement table.


Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#include "precomp.h"
#pragma hdrstop


//
//  List containing the chain of server announcement buffers.  These structures
//  are allocated out of paged pool and are used to while transfering the
//  contents of the server announcement from the datagram reception indication
//  routine to the Bowser's FSP where they will be added to the announcement
//  database.
//

LIST_ENTRY
BowserViewBufferHead = {0};

KSPIN_LOCK
BowserViewBufferListSpinLock = {0};

LONG
BowserNumberOfServerAnnounceBuffers = {0};

BOOLEAN
PackServerAnnouncement (
    IN ULONG Level,
    IN ULONG ServerTypeMask,
    IN OUT LPTSTR *BufferStart,
    IN OUT LPTSTR *BufferEnd,
    IN ULONG_PTR BufferDisplacment,
    IN PANNOUNCE_ENTRY Announcement,
    OUT PULONG TotalBytesNeeded
    );


NTSTATUS
AgeServerAnnouncements(
    PTRANSPORT Transport,
    PVOID Context
    );

VOID
BowserPromoteToBackup(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    );

VOID
BowserShutdownRemoteBrowser(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    );

typedef struct _ENUM_SERVERS_CONTEXT {
    ULONG Level;
    PLUID LogonId;
    ULONG ServerTypeMask;
    PUNICODE_STRING DomainName OPTIONAL;
    PVOID OutputBuffer;
    PVOID OutputBufferEnd;
    ULONG OutputBufferSize;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    ULONG_PTR OutputBufferDisplacement;
    ULONG ResumeKey;
    ULONG OriginalResumeKey;
} ENUM_SERVERS_CONTEXT, *PENUM_SERVERS_CONTEXT;

NTSTATUS
EnumerateServersWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserCompareAnnouncement)
#pragma alloc_text(PAGE, BowserAllocateAnnouncement)
#pragma alloc_text(PAGE, BowserFreeAnnouncement)
#pragma alloc_text(PAGE, BowserProcessHostAnnouncement)
#pragma alloc_text(PAGE, BowserProcessDomainAnnouncement)
#pragma alloc_text(PAGE, BowserAgeServerAnnouncements)
#pragma alloc_text(PAGE, AgeServerAnnouncements)
#pragma alloc_text(PAGE, BowserPromoteToBackup)
#pragma alloc_text(PAGE, BowserShutdownRemoteBrowser)
#pragma alloc_text(PAGE, BowserEnumerateServers)
#pragma alloc_text(PAGE, EnumerateServersWorker)
#pragma alloc_text(PAGE, PackServerAnnouncement)
#pragma alloc_text(PAGE, BowserDeleteGenericTable)
#pragma alloc_text(PAGE, BowserpInitializeAnnounceTable)
#pragma alloc_text(PAGE, BowserpUninitializeAnnounceTable)
#pragma alloc_text(PAGE4BROW, BowserFreeViewBuffer)
#pragma alloc_text(PAGE4BROW, BowserAllocateViewBuffer)
#pragma alloc_text(PAGE4BROW, BowserHandleServerAnnouncement)
#pragma alloc_text(PAGE4BROW, BowserHandleDomainAnnouncement)
#endif


INLINE
ULONG
BowserSafeStrlen(
    IN PSZ String,
    IN ULONG MaximumStringLength
    )
{
    ULONG Length = 0;

    while (MaximumStringLength-- && *String++) {
        Length += 1;
    }

    return Length;
}

DATAGRAM_HANDLER(
    BowserHandleServerAnnouncement
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN ULONG BytesAvailable     - number of bytes in complete Tsdu
    IN PHOST_ANNOUNCE_PACKET_1 HostAnnouncement - the server announcement.
    IN ULONG BytesAvailable     - The number of bytes in the announcement.
    OUT ULONG *BytesTaken       - number of bytes used
    IN UCHAR Opcode             - the mailslot write opcode.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER ViewBuffer;
    ULONG HostNameLength                     = 0;
    ULONG CommentLength                      = 0;
    ULONG NameCommentMaxLength               = 0;
    PHOST_ANNOUNCE_PACKET_1 HostAnnouncement = Buffer;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BowserData.PseudoServerLevel == BROWSER_PSEUDO ) {
        // no-op for black hole server
        return STATUS_SUCCESS;
    }
#endif

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfServerAnnouncements, 1);

    ViewBuffer = BowserAllocateViewBuffer();

    //
    //  If we are unable to allocate a view buffer, ditch this datagram on
    //  the floor.
    //

    if (ViewBuffer == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    if ((TransportName->NameType == MasterBrowser) ||
        (TransportName->NameType == BrowserElection)) {
        ULONG ServerElectionVersion;
        //
        //  If this server announcement is sent to the master name, then
        //  it is a BROWSE_ANNOUNCE packet, not a HOST_ANNOUNCE (ie, it's an
        //  NT/WinBALL server, not a Lan Manager server.
        //
        //  We need to grovel the bits out of the packet in an appropriate
        //  manner.
        //

        PBROWSE_ANNOUNCE_PACKET_1 BrowseAnnouncement = (PBROWSE_ANNOUNCE_PACKET_1)HostAnnouncement;

        //
        //  If this packet was smaller than a minimal server announcement,
        //  ignore the request, it cannot be a legal request.
        //

        if (BytesAvailable < FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) {

            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        //  This is a Lan Manager style server announcement.
        //

#if DBG
        ViewBuffer->ServerType = 0xffffffff;
#endif

        //
        //  Verify that this announcement is not going to blow away the view
        // buffer.
        //

        HostNameLength = BowserSafeStrlen(BROWSE_ANNC_NAME(BrowseAnnouncement),
                                        BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName));
        if (HostNameLength > NETBIOS_NAME_LEN-1) {
            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        if (BowserSafeStrlen(BROWSE_ANNC_COMMENT(BrowseAnnouncement),
                BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) > LM20_MAXCOMMENTSZ) {
            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        strncpy(ViewBuffer->ServerName, BROWSE_ANNC_NAME(BrowseAnnouncement),
                min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName),
                    NETBIOS_NAME_LEN));

        ViewBuffer->ServerName[NETBIOS_NAME_LEN] = '\0';

        strncpy(ViewBuffer->ServerComment, BROWSE_ANNC_COMMENT(BrowseAnnouncement),
                min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment), LM20_MAXCOMMENTSZ));

        ViewBuffer->ServerComment[LM20_MAXCOMMENTSZ] = '\0';

        ServerElectionVersion = SmbGetUlong(&BrowseAnnouncement->CommentPointer);

        //
        //  Save away the election version of this server.
        //

        if ((ServerElectionVersion >> 16) == 0xaa55) {
            ViewBuffer->ServerBrowserVersion = (USHORT)(ServerElectionVersion & 0xffff);
        } else {
            if (!(BrowseAnnouncement->Type & SV_TYPE_NT)) {
                ViewBuffer->ServerBrowserVersion = (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR;
            } else {
                ViewBuffer->ServerBrowserVersion = 0;
            }
        }

        ViewBuffer->ServerType = SmbGetUlong(&BrowseAnnouncement->Type);

        dprintf(DPRT_ANNOUNCE, ("Received announcement from %s on transport %lx.  Server type: %lx\n", ViewBuffer->ServerName, TransportName->Transport, ViewBuffer->ServerType));

        ViewBuffer->ServerVersionMajor = BrowseAnnouncement->VersionMajor;

        ViewBuffer->ServerVersionMinor = BrowseAnnouncement->VersionMinor;

        ViewBuffer->ServerPeriodicity = (USHORT)((SmbGetUlong(&BrowseAnnouncement->Periodicity) + 999) / 1000);

    } else {

        //
        //  If this packet was smaller than a minimal server announcement,
        //  ignore the request, it cannot be a legal request.
        //

        if (BytesAvailable < FIELD_OFFSET(HOST_ANNOUNCE_PACKET_1, NameComment)) {

            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        //  This is a Lan Manager style server announcement.
        //

#if DBG
        ViewBuffer->ServerType = 0xffffffff;
#endif

        //
        //  Verify that this announcement is not going to blow away the view
        // buffer.
        //

        NameCommentMaxLength = BytesAvailable - FIELD_OFFSET(HOST_ANNOUNCE_PACKET_1, NameComment);

        HostNameLength = BowserSafeStrlen(HOST_ANNC_NAME(HostAnnouncement),
                                          NameCommentMaxLength);

        if (HostNameLength > NETBIOS_NAME_LEN) {
            BowserFreeViewBuffer(ViewBuffer);

            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        //  We need to make sure that the hostname string was properly terminated
        //     before using HOST_ANNC_COMMENT (which calls strlen on the hostname string).
        //     The BowserSafeStrlen call above may have been terminated by the end of the
        //     input buffer.  If the length was terminated by the end of the buffer, the
        //     conditional below will fail.
        //

        if (HostNameLength < NameCommentMaxLength) {
            CommentLength = BowserSafeStrlen(HOST_ANNC_COMMENT(HostAnnouncement),
                                             NameCommentMaxLength - HostNameLength - 1);

            if (CommentLength > LM20_MAXCOMMENTSZ) {
                BowserFreeViewBuffer(ViewBuffer);

                return STATUS_REQUEST_NOT_ACCEPTED;
            }
        }

        if (HostNameLength) {
            RtlCopyMemory(ViewBuffer->ServerName,HOST_ANNC_NAME(HostAnnouncement),HostNameLength);
        }
        ViewBuffer->ServerName[HostNameLength] = '\0';
        if (CommentLength) {
            RtlCopyMemory(ViewBuffer->ServerComment,HOST_ANNC_COMMENT(HostAnnouncement),CommentLength);
        }
        ViewBuffer->ServerComment[CommentLength] = '\0';

        ViewBuffer->ServerBrowserVersion = (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR;

        ViewBuffer->ServerType = SmbGetUlong(&HostAnnouncement->Type);

        dprintf(DPRT_ANNOUNCE, ("Received announcement from %s on transport %lx.  Server type: %lx\n", ViewBuffer->ServerName, TransportName->Transport, ViewBuffer->ServerType));

        ViewBuffer->ServerVersionMajor = HostAnnouncement->VersionMajor;

        ViewBuffer->ServerVersionMinor = HostAnnouncement->VersionMinor;

        ViewBuffer->ServerPeriodicity = SmbGetUshort(&HostAnnouncement->Periodicity);

    }
    ViewBuffer->TransportName = TransportName;

    BowserReferenceTransportName(TransportName);
    dprintf(DPRT_REF, ("Call Reference transport %lx from BowserHandlerServerAnnouncement.\n", TransportName->Transport));
    BowserReferenceTransport( TransportName->Transport );

    ExInitializeWorkItem(&ViewBuffer->Overlay.WorkHeader, BowserProcessHostAnnouncement, ViewBuffer);

    BowserQueueDelayedWorkItem( &ViewBuffer->Overlay.WorkHeader );

    *BytesTaken = BytesAvailable;

    return STATUS_SUCCESS;
}

DATAGRAM_HANDLER(
    BowserHandleDomainAnnouncement
    )

/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN ULONG BytesAvailable,    - number of bytes in complete Tsdu
    IN PBROWSE_ANNOUNCE_PACKET_1 HostAnnouncement - the server announcement.
    IN ULONG BytesAvailable     - The number of bytes in the announcement.
    OUT ULONG *BytesTaken,      - number of bytes used


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER ViewBuffer;
    PBROWSE_ANNOUNCE_PACKET_1 DomainAnnouncement = Buffer;
    ULONG HostNameLength;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BowserData.PseudoServerLevel == BROWSER_PSEUDO ) {
        // no-op for black hole server
        return STATUS_SUCCESS;
    }
#endif

    //
    //  If we are not processing host announcements for this
    //  name, ignore this request.
    //

    if (!TransportName->ProcessHostAnnouncements) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfDomainAnnouncements, 1);

    //
    //  If this packet was smaller than a minimal server announcement,
    //  ignore the request, it cannot be a legal request.
    //

    if (BytesAvailable < FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) {

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    //  Verify that this announcement is not going to blow away the view
    // buffer.
    //

    HostNameLength = BowserSafeStrlen(BROWSE_ANNC_NAME(DomainAnnouncement),
             BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName));

    if (HostNameLength > NETBIOS_NAME_LEN) {

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    ViewBuffer = BowserAllocateViewBuffer();

    //
    //  If we are unable to allocate a view buffer, ditch this datagram on
    //  the floor.
    //

    if (ViewBuffer == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

#if DBG
    ViewBuffer->ServerType = 0xffffffff;
#endif

    strncpy(ViewBuffer->ServerName, BROWSE_ANNC_NAME(DomainAnnouncement),
            min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, ServerName),
                NETBIOS_NAME_LEN));

    ViewBuffer->ServerName[CNLEN] = '\0';

    //
    //  The comment on a server announcement is the computer name.
    //

//    ASSERT (strlen(BROWSE_ANNC_COMMENT(DomainAnnouncement)) <= CNLEN);

    strncpy(ViewBuffer->ServerComment, BROWSE_ANNC_COMMENT(DomainAnnouncement),
            min(BytesAvailable - FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment),
            CNLEN));

    //
    //  Force a null termination at the appropriate time.
    //

    ViewBuffer->ServerComment[CNLEN] = '\0';

    ViewBuffer->TransportName = TransportName;

    if (SmbGetUlong(&DomainAnnouncement->Type) & SV_TYPE_DOMAIN_ENUM) {
        ViewBuffer->ServerType = SmbGetUlong(&DomainAnnouncement->Type);
    } else {
        ViewBuffer->ServerType = SV_TYPE_DOMAIN_ENUM;
    }

    ViewBuffer->ServerVersionMajor = DomainAnnouncement->VersionMajor;

    ViewBuffer->ServerVersionMinor = DomainAnnouncement->VersionMinor;

    ViewBuffer->ServerPeriodicity = (USHORT)((SmbGetUlong(&DomainAnnouncement->Periodicity) + 999) / 1000);

    BowserReferenceTransportName(TransportName);
    dprintf(DPRT_REF, ("Call Reference transport %lx from BowserHandlerDomainAnnouncement.\n", TransportName->Transport));
    BowserReferenceTransport( TransportName->Transport );

    ExInitializeWorkItem(&ViewBuffer->Overlay.WorkHeader, BowserProcessDomainAnnouncement, ViewBuffer);

    BowserQueueDelayedWorkItem( &ViewBuffer->Overlay.WorkHeader );

    *BytesTaken = BytesAvailable;

    return STATUS_SUCCESS;
}


RTL_GENERIC_COMPARE_RESULTS
BowserCompareAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )
/*++

Routine Description:

    This routine will compare two server announcements to see how they compare

Arguments:

    IN PRTL_GENERIC_TABLE - Supplies the table containing the announcements
    IN PVOID FirstStuct - The first structure to compare.
    IN PVOID SecondStruct - The second structure to compare.

Return Value:

    Result of the comparison.

--*/
{
    UNICODE_STRING ServerName1, ServerName2;
    PANNOUNCE_ENTRY Server1 = FirstStruct;
    PANNOUNCE_ENTRY Server2 = SecondStruct;
    LONG CompareResult;

    PAGED_CODE();

    RtlInitUnicodeString(&ServerName1, Server1->ServerName);

    RtlInitUnicodeString(&ServerName2, Server2->ServerName);

    CompareResult = RtlCompareUnicodeString(&ServerName1, &ServerName2, FALSE);

    if (CompareResult < 0) {
        return GenericLessThan;
    } else if (CompareResult > 0) {
        return GenericGreaterThan;
    } else {
        return GenericEqual;
    }

    UNREFERENCED_PARAMETER(Table);

}

PVOID
BowserAllocateAnnouncement(
    IN PRTL_GENERIC_TABLE Table,
    IN CLONG ByteSize
    )
/*++

Routine Description:

    This routine will allocate space to hold an entry in a generic table.

Arguments:

    IN PRTL_GENERIC_TABLE Table - Supplies the table to allocate entries for.
    IN CLONG ByteSize - Supplies the number of bytes to allocate for the entry.


Return Value:

    None.

--*/
{
    PAGED_CODE();
    return ALLOCATE_POOL(PagedPool, ByteSize, POOL_ANNOUNCEMENT);
    UNREFERENCED_PARAMETER(Table);
}

VOID
BowserFreeAnnouncement (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine will free an entry in a generic table that is too old.

Arguments:

    IN PRTL_GENERIC_TABLE Table - Supplies the table to allocate entries for.
    IN PVOID Buffer - Supplies the buffer to free.



Return Value:

    None.

--*/
{
    PAGED_CODE();

    FREE_POOL(Buffer);
    UNREFERENCED_PARAMETER(Table);
}

INLINE
BOOLEAN
BowserIsLegalBackupBrowser(
    IN PANNOUNCE_ENTRY Announcement,
    IN PUNICODE_STRING ComputerName
    )
{
    //
    //  If we received this announcement on an "otherdomain", we will ignore
    //  it.
    //

    if (Announcement->Name->NameType == OtherDomain) {
        return FALSE;
    }

    //
    //  If the server doesn't indicate that it's a legal backup browser, we
    //  want to ignore it.
    //

    if (!FlagOn(Announcement->ServerType, SV_TYPE_BACKUP_BROWSER)) {
        return FALSE;
    }

    //
    //  If the server is the master browser, then we want to ignore it.
    //

    if (FlagOn(Announcement->ServerType, SV_TYPE_MASTER_BROWSER)) {
        return FALSE;
    }

    //
    //  If the server is too old, we want to ignore it.
    //

    if (Announcement->ServerBrowserVersion < (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR) {
        return FALSE;
    }

    //
    //  If the machine we're looking at is the current machine, then it cannot
    //  be a legal backup - it must be a stale announcement sent before we
    //  actually became the master.
    //

    if (RtlCompareMemory(Announcement->ServerName,
                         ComputerName->Buffer,
                         ComputerName->Length) == ComputerName->Length) {
        return FALSE;
    }

    return TRUE;
}

VOID
BowserProcessHostAnnouncement(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will put a server announcement into the server announcement
    table

Arguments:

    IN PWORK_HEADER Header - Supplies a pointer to a work header in a view buffer

Return Value:

    None.

--*/
{
    PVIEW_BUFFER ViewBuffer = Context;
    ANNOUNCE_ENTRY ProtoEntry;
    UNICODE_STRING TempUString;
    OEM_STRING TempAString;
    PANNOUNCE_ENTRY Announcement;
    BOOLEAN NewElement = FALSE;
    ULONG Periodicity;
    ULONG ExpirationTime;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport;
    PTRANSPORT_NAME TransportName = ViewBuffer->TransportName;
    PTRANSPORT Transport = TransportName->Transport;

    PAGED_CODE();
//    DbgBreakPoint();

    ASSERT (ViewBuffer->Signature == STRUCTURE_SIGNATURE_VIEW_BUFFER);

    //
    //  If we're not a master browser on this transport, don't process the
    //  announcement.
    //  Or no-op for black hole server
    //

#ifdef ENABLE_PSEUDO_BROWSER
    ASSERT( BowserData.PseudoServerLevel != BROWSER_PSEUDO );
#endif

    if (Transport->PagedTransport->Role != Master) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    //
    //  Convert the computername to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerName;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerName);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerName);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, TempAString.Buffer, TempAString.Length );

        BowserFreeViewBuffer(ViewBuffer);

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);

        return;
    }

    //
    //  Convert the comment to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerComment;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerComment);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerComment);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, TempAString.Buffer, TempAString.Length );

        BowserFreeViewBuffer(ViewBuffer);

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    ProtoEntry.Signature = STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY;

    ProtoEntry.Size = sizeof(ProtoEntry) -
                      sizeof(ProtoEntry.ServerComment) +
                      TempUString.Length + sizeof(WCHAR);

    ProtoEntry.ServerType = ViewBuffer->ServerType;

    ProtoEntry.ServerVersionMajor = ViewBuffer->ServerVersionMajor;

    ProtoEntry.ServerVersionMinor = ViewBuffer->ServerVersionMinor;

    ProtoEntry.Name = ViewBuffer->TransportName->PagedTransportName->Name;

    //
    //  Initialize the forward and backward link to NULL.
    //

    ProtoEntry.BackupLink.Flink = NULL;

    ProtoEntry.BackupLink.Blink = NULL;

    ProtoEntry.ServerPeriodicity = ViewBuffer->ServerPeriodicity;

    ProtoEntry.Flags = 0;

    ProtoEntry.ServerBrowserVersion = ViewBuffer->ServerBrowserVersion;


    PagedTransport = Transport->PagedTransport;

    //
    //  We're done with the view buffer, now free it.
    //

    BowserFreeViewBuffer(ViewBuffer);

    LOCK_ANNOUNCE_DATABASE(Transport);

    try {

        //
        //  If this guy isn't a server, then we're supposed to remove this
        //  guy from our list of servers.  We do this because the server (NT,
        //  WfW, and OS/2) will issue a dummy announcement with the
        //  appropriate bit turned off when they stop.
        //

        if (!FlagOn(ProtoEntry.ServerType, SV_TYPE_SERVER)) {

            //
            //  Look up this entry in the table.
            //

            Announcement = RtlLookupElementGenericTable(&PagedTransport->AnnouncementTable, &ProtoEntry);

            //
            //  The entry wasn't found, so just return, we got rid of it
            //  some other way (maybe from a timeout scan, etc).
            //

            if (Announcement == NULL) {
                try_return(NOTHING);
            }

            //
            //  If this element is on the backup list, remove it from the
            //  backup list.
            //

            if (Announcement->BackupLink.Flink != NULL) {
                ASSERT (Announcement->BackupLink.Blink != NULL);

                RemoveEntryList(&Announcement->BackupLink);

                PagedTransport->NumberOfBackupServerListEntries -= 1;

                Announcement->BackupLink.Flink = NULL;

                Announcement->BackupLink.Blink = NULL;
            }

            //
            //  Now delete the element from the announcement table.
            //

            BowserDereferenceName( Announcement->Name );
            if (!RtlDeleteElementGenericTable(&PagedTransport->AnnouncementTable, Announcement)) {
                KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
            }

            try_return(NOTHING);
        }

        Announcement = RtlInsertElementGenericTable(&PagedTransport->AnnouncementTable,
                            &ProtoEntry, ProtoEntry.Size, &NewElement);

        if (Announcement == NULL) {
            //
            //  We couldn't allocate pool for this announcement.  Skip it.
            //

            BowserStatistics.NumberOfMissedServerAnnouncements += 1;
            try_return(NOTHING);

        }

        // Indicate the name is referenced by the announce entry we just inserted.
        BowserReferenceName( ProtoEntry.Name );

        if (!NewElement) {

            ULONG NumberOfPromotionAttempts = Announcement->NumberOfPromotionAttempts;

            //
            //  If this announcement was a backup browser, remove it from the
            //  list of backup browsers.
            //

            if (Announcement->BackupLink.Flink != NULL) {
                ASSERT (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER);

                ASSERT (Announcement->BackupLink.Blink != NULL);

                RemoveEntryList(&Announcement->BackupLink);

                PagedTransport->NumberOfBackupServerListEntries -= 1;

                Announcement->BackupLink.Flink = NULL;

                Announcement->BackupLink.Blink = NULL;

            }

            //
            //  If this is not a new announcement, copy the announcement entry
            //  with the new information.
            //

            // The Previous entry no longer references the name
            BowserDereferenceName( Announcement->Name );
            if ( Announcement->Size >= ProtoEntry.Size ) {
                CSHORT TempSize;
                TempSize = Announcement->Size;
                RtlCopyMemory( Announcement, &ProtoEntry, ProtoEntry.Size );
                Announcement->Size = TempSize;
            } else {
                if (!RtlDeleteElementGenericTable(
                                        &PagedTransport->AnnouncementTable,
                                        Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                } else {
                    Announcement = RtlInsertElementGenericTable(
                                        &PagedTransport->AnnouncementTable,
                                        &ProtoEntry,
                                        ProtoEntry.Size,
                                        &NewElement);

                    if (Announcement == NULL) {
                        BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                        try_return(NOTHING);
                    }
                    ASSERT( NewElement );
                }
            }

            if (ProtoEntry.ServerType & SV_TYPE_BACKUP_BROWSER) {
                Announcement->NumberOfPromotionAttempts = 0;
            } else {
                Announcement->NumberOfPromotionAttempts = NumberOfPromotionAttempts;
            }

        } else {

            //
            //  This is a new entry.  Initialize the number of promotion
            //  attempts to 0.
            //

            Announcement->NumberOfPromotionAttempts = 0;

            dlog( DPRT_MASTER,
                  ("%s: %ws: New server: %ws.  Periodicity: %ld\n",
                  Transport->DomainInfo->DomOemDomainName,
                  PagedTransport->TransportName.Buffer,
                  Announcement->ServerName,
                  Announcement->ServerPeriodicity));


            //
            // If there are too many entries,
            //  ditch this one.
            //

            if ( RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) > BowserMaximumBrowseEntries ) {

                dlog( DPRT_MASTER,
                      ("%s: %ws: New server (Deleted because too many): %ws.  Periodicity: %ld\n",
                      Transport->DomainInfo->DomOemDomainName,
                      PagedTransport->TransportName.Buffer,
                      Announcement->ServerName,
                      Announcement->ServerPeriodicity));

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->AnnouncementTable, Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                }

                //
                // Chaulk it up as a missed announcement
                //
                BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                try_return(NOTHING);
            }
        }

        //
        //  If this new server is a legal backup browser (but not a master
        //  browser, link it into the announcement database).
        //
        //

        ASSERT (Announcement->BackupLink.Flink == NULL);
        ASSERT (Announcement->BackupLink.Blink == NULL);

        if (BowserIsLegalBackupBrowser(Announcement, &Transport->DomainInfo->DomUnicodeComputerName)) {

            InsertHeadList(&PagedTransport->BackupBrowserList, &Announcement->BackupLink);

            PagedTransport->NumberOfBackupServerListEntries += 1;

        }

        Periodicity = Announcement->ServerPeriodicity;

        ExpirationTime = BowserCurrentTime+(Periodicity*HOST_ANNOUNCEMENT_AGE);

        Announcement->ExpirationTime = ExpirationTime;
try_exit:NOTHING;
    } finally {

        UNLOCK_ANNOUNCE_DATABASE(Transport);

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
    }

    return;

}

VOID
BowserProcessDomainAnnouncement(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine will put a server announcement into the server announcement
    table

Arguments:

    IN PWORK_HEADER Header - Supplies a pointer to a work header in a view buffer

Return Value:

    None.

--*/
{
    PVIEW_BUFFER ViewBuffer = Context;
    ANNOUNCE_ENTRY ProtoEntry;
    UNICODE_STRING TempUString;
    OEM_STRING TempAString;
    PANNOUNCE_ENTRY Announcement;
    BOOLEAN NewElement = FALSE;
    ULONG Periodicity;
    ULONG ExpirationTime;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport;
    PTRANSPORT_NAME TransportName = ViewBuffer->TransportName;
    PTRANSPORT Transport = TransportName->Transport;

    PAGED_CODE();
//    DbgBreakPoint();

    ASSERT (ViewBuffer->Signature == STRUCTURE_SIGNATURE_VIEW_BUFFER);

    //
    //  If we're not a master browser on this transport, don't process the
    //  announcement.
    //  Or no-op for black hole server
    //

#ifdef ENABLE_PSEUDO_BROWSER
    ASSERT( BowserData.PseudoServerLevel != BROWSER_PSEUDO );
#endif
    if (ViewBuffer->TransportName->Transport->PagedTransport->Role != Master) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    //
    //  Convert the computername to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerName;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerName);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerName);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    //
    //  Convert the comment to unicode.
    //

    TempUString.Buffer = ProtoEntry.ServerComment;
    TempUString.MaximumLength = sizeof(ProtoEntry.ServerComment);

    RtlInitAnsiString(&TempAString, ViewBuffer->ServerComment);

    Status = RtlOemStringToUnicodeString(&TempUString, &TempAString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserFreeViewBuffer(ViewBuffer);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
        return;
    }

    ProtoEntry.Signature = STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY;

    ProtoEntry.Size = sizeof(ProtoEntry) -
                      sizeof(ProtoEntry.ServerComment) +
                      TempUString.Length + sizeof(WCHAR);

    ProtoEntry.ServerType = ViewBuffer->ServerType;

    ProtoEntry.ServerVersionMajor = ViewBuffer->ServerVersionMajor;

    ProtoEntry.ServerVersionMinor = ViewBuffer->ServerVersionMinor;

    ProtoEntry.Name = ViewBuffer->TransportName->PagedTransportName->Name;

    ProtoEntry.ServerPeriodicity = ViewBuffer->ServerPeriodicity;

    ProtoEntry.BackupLink.Flink = NULL;

    ProtoEntry.BackupLink.Blink = NULL;

    ProtoEntry.Flags = 0;


    PagedTransport = Transport->PagedTransport;

    //
    //  We're done with the view buffer, now free it.
    //

    BowserFreeViewBuffer(ViewBuffer);

    LOCK_ANNOUNCE_DATABASE(Transport);

    try {

        Announcement = RtlInsertElementGenericTable(&PagedTransport->DomainTable,
                        &ProtoEntry, ProtoEntry.Size, &NewElement);

        if (Announcement == NULL) {
            //
            //  We couldn't allocate pool for this announcement.  Skip it.
            //

            BowserStatistics.NumberOfMissedServerAnnouncements += 1;
            try_return(NOTHING);

        }

        // Indicate the name is referenced by the announce entry we just inserted.
        BowserReferenceName( ProtoEntry.Name );

        if (!NewElement) {

            //
            //  If this is not a new announcement, copy the announcement entry
            //  with the new information.
            //

            // The Previous entry no longer references the name
            BowserDereferenceName( Announcement->Name );
            if ( Announcement->Size >= ProtoEntry.Size ) {
                CSHORT TempSize;
                TempSize = Announcement->Size;
                RtlCopyMemory( Announcement, &ProtoEntry, ProtoEntry.Size );
                Announcement->Size = TempSize;
            } else {
                if (!RtlDeleteElementGenericTable(
                                        &PagedTransport->DomainTable,
                                        Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                } else {
                    Announcement = RtlInsertElementGenericTable(
                                        &PagedTransport->DomainTable,
                                        &ProtoEntry,
                                        ProtoEntry.Size,
                                        &NewElement);

                    if (Announcement == NULL) {
                        BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                        try_return(NOTHING);
                    }
                    ASSERT( NewElement );
                }
            }
            dlog( DPRT_MASTER,
                  ("%s: %ws Domain:%ws P: %ld\n",
                  Transport->DomainInfo->DomOemDomainName,
                  PagedTransport->TransportName.Buffer,
                  Announcement->ServerName,
                  Announcement->ServerPeriodicity));

        } else {
            dlog( DPRT_MASTER,
                  ("%s: %ws New domain:%ws P: %ld\n",
                  Transport->DomainInfo->DomOemDomainName,
                  PagedTransport->TransportName.Buffer,
                  Announcement->ServerName,
                  Announcement->ServerPeriodicity));

            //
            // If there are too many entries,
            //  ditch this one.
            //

            if ( RtlNumberGenericTableElements(&PagedTransport->DomainTable) > BowserMaximumBrowseEntries ) {

                dlog( DPRT_MASTER,
                      ("%s: %ws New domain (deleted because too many):%ws P: %ld\n",
                      Transport->DomainInfo->DomOemDomainName,
                      PagedTransport->TransportName.Buffer,
                      Announcement->ServerName,
                      Announcement->ServerPeriodicity));

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->DomainTable, Announcement)) {
//                    KdPrint(("Unable to delete element %ws\n", Announcement->ServerName));
                }

                //
                // Chaulk it up as a missed announcement
                //
                BowserStatistics.NumberOfMissedServerAnnouncements += 1;
                try_return(NOTHING);
            }
        }

        Periodicity = Announcement->ServerPeriodicity;

        ExpirationTime = BowserCurrentTime+(Periodicity*HOST_ANNOUNCEMENT_AGE);

        Announcement->ExpirationTime = ExpirationTime;

try_exit:NOTHING;
    } finally {
        UNLOCK_ANNOUNCE_DATABASE(Transport);
        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
    }

    return;

}

VOID
BowserAgeServerAnnouncements(
    VOID
    )
/*++

Routine Description:

    This routine will age server announcements in the server announce table.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    BowserForEachTransport(AgeServerAnnouncements, NULL);

}

INLINE
BOOLEAN
BowserIsValidPotentialBrowser(
    IN PTRANSPORT Transport,
    IN PANNOUNCE_ENTRY Announcement
    )
{
    if (Announcement->Name->NameType != MasterBrowser) {
        return FALSE;
    }

    //
    //  If this guy is a potential browser, and is not
    //  currently a backup or master browser, promote
    //  him to a browser.
    //

    if (!(Announcement->ServerType & SV_TYPE_POTENTIAL_BROWSER)) {
        return FALSE;
    }

    //
    //  And this guy isn't either a master or backup browser already
    //

    if (Announcement->ServerType & (SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER)) {
        return FALSE;
    }

    //
    //  If this guy is running a current version of the browser.
    //

    if (Announcement->ServerBrowserVersion < (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR) {
        return FALSE;
    }

    //
    //  If this machine is ourselves, and we've not yet announced ourselves as
    //  a master, don't promote ourselves.
    //

    if (!_wcsicmp(Announcement->ServerName, Transport->DomainInfo->DomUnicodeComputerNameBuffer)) {
        return FALSE;
    }

    //
    //  If we've tried to promote this machine more than # of ignored promotions,
    //  we don't want to consider it either.
    //

    if (Announcement->NumberOfPromotionAttempts >= NUMBER_IGNORED_PROMOTIONS) {
        return FALSE;
    }

    return TRUE;
}

INLINE
BOOLEAN
BowserIsValidBackupBrowser(
    IN PTRANSPORT Transport,
    IN PANNOUNCE_ENTRY Announcement
    )
/*++

Routine Description:

    This routine determines if a server is eligable for demotion.

Arguments:

    PTRANSPORT Transport - Transport we are scanning.
    PANNOUNCE_ENTRY Announcement - Announce entry for server to check.

Return Value:

    BOOLEAN - True if browser is eligable for demotion

--*/

{
    PUNICODE_STRING PagedComputerName = &Transport->DomainInfo->DomUnicodeComputerName;
    //
    //  If the name came in on the master browser name
    //

    if (Announcement->Name->NameType != MasterBrowser) {
        return FALSE;
    }

    //
    //  And this guy is currently a backup browser,
    //

    if (!(Announcement->ServerType & SV_TYPE_BACKUP_BROWSER)) {
        return FALSE;
    }

    //
    //  And this guy was a promoted browser,
    //

    if (!(Announcement->ServerType & SV_TYPE_POTENTIAL_BROWSER)) {
        return FALSE;
    }

    //
    //  And this guy isn't an NTAS machine,
    //

    if (Announcement->ServerType & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL)) {
        return FALSE;
    }

    //
    //  And this isn't ourselves.
    //

    if (RtlCompareMemory(Announcement->ServerName,
                         PagedComputerName->Buffer,
                         PagedComputerName->Length) == PagedComputerName->Length) {
        return FALSE;
    }

    //
    //  Then it's a valid backup browser to demote.
    //

    return TRUE;
}



NTSTATUS
AgeServerAnnouncements(
    PTRANSPORT Transport,
    PVOID Context
    )
/*++

Routine Description:

    This routine is the worker routine for BowserAgeServerAnnouncements.

    It is called for each of the serviced transports in the bowser and
    ages the servers received on each transport.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PANNOUNCE_ENTRY Announcement;
    ULONG BackupsNeeded;
    ULONG BackupsFound;
    ULONG NumberOfConfiguredBrowsers;
    PVOID ResumeKey = NULL;
    PVOID PreviousResumeKey = NULL;
    ULONG NumberOfServersDeleted = 0;
    ULONG NumberOfDomainsDeleted = 0;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    //
    // If we're not a master, don't bother.
    //

    if (PagedTransport->Role != Master) {
        UNLOCK_TRANSPORT(Transport);

        return STATUS_SUCCESS;
    }

    UNLOCK_TRANSPORT(Transport);

    LOCK_ANNOUNCE_DATABASE(Transport);

    try {

        BackupsFound = 0;
        NumberOfConfiguredBrowsers = 0;

        dlog(DPRT_MASTER,
             ("%s: %ws: Scavenge Servers:",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer));

        for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ;
             Announcement != NULL ;
             Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ) {

            if (BowserCurrentTime > Announcement->ExpirationTime) {

                if (Announcement->Name->NameType != OtherDomain) {

                    if (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER) {
                        //
                        //  This guy was a backup - indicate that we're not tracking
                        //  him any more.
                        //

                        PagedTransport->NumberOfBrowserServers -= 1;
                    }
                }

                dlog(DPRT_MASTER, ("%ws ", Announcement->ServerName));

                // Continue the search from where we found this entry.
                ResumeKey = PreviousResumeKey;

                BackupsFound = 0;

                NumberOfConfiguredBrowsers = 0;

                NumberOfServersDeleted += 1;

                //
                //  If this announcement was a backup browser, remove it from the
                //  list of backup browsers.
                //

                if (Announcement->BackupLink.Flink != NULL) {
                    ASSERT (Announcement->BackupLink.Blink != NULL);

                    ASSERT (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER);

                    RemoveEntryList(&Announcement->BackupLink);

                    PagedTransport->NumberOfBackupServerListEntries -= 1;

                    Announcement->BackupLink.Flink = NULL;

                    Announcement->BackupLink.Blink = NULL;
                }

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->AnnouncementTable, Announcement)) {
                    KdPrint(("Unable to delete server element %ws\n", Announcement->ServerName));
                }

            } else {

                if (BowserIsLegalBackupBrowser(Announcement, &Transport->DomainInfo->DomUnicodeComputerName )) {

                    //
                    //  This announcement should be on the backup list.
                    //

                    ASSERT (Announcement->BackupLink.Flink != NULL);

                    ASSERT (Announcement->BackupLink.Blink != NULL);

                    //
                    // Found a backup that has not timed out.
                    //

                    BackupsFound++;

                }

                //
                //  If this machine is a DC or BDC and is an NT machine, then
                //  assume it's a Lanman/NT machine.
                //

                if (Announcement->ServerType & (SV_TYPE_DOMAIN_CTRL|SV_TYPE_DOMAIN_BAKCTRL)) {

                    //
                    //  If this DC is an NT DC, it is running the browser
                    //  service, and it is NOT the master, we consider it a
                    //  configured browser.
                    //

                    if ((Announcement->ServerType & SV_TYPE_NT)

                                    &&

                        (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER)

                                    &&

                        !(Announcement->ServerType & SV_TYPE_MASTER_BROWSER)) {

                        NumberOfConfiguredBrowsers += 1;
                    }
                } else {
                    //
                    //  If this guy isn't a DC, then if it is a backup browser
                    //  but not a potential browser, then it's a configured
                    //  browser (non-configured browsers get promoted).
                    //


                    if ((Announcement->ServerType & SV_TYPE_BACKUP_BROWSER) &&
                        !(Announcement->ServerType & SV_TYPE_POTENTIAL_BROWSER)) {
                        NumberOfConfiguredBrowsers += 1;
                    }
                }

                //
                // Remember where this valid entry was found.
                //

                PreviousResumeKey = ResumeKey;

            }
        }

        dlog(DPRT_MASTER, ("\n"));

        //
        //  If we've found enough configured backup servers, we don't need to
        //  promote any more backups.
        //
        //  Also don't attempt a promotion scan for the first MASTER_TIME_UP
        //  milliseconds (15 minutes) we are the master.
        //

        if ((BowserTimeUp() - PagedTransport->TimeMaster) > MASTER_TIME_UP) {

            //
            //  If there are fewer than the minimum configured browsers,
            //  rely only on the configured browsers.
            //

            if (NumberOfConfiguredBrowsers < BowserMinimumConfiguredBrowsers) {

                //
                //  We will need 1 backup for every SERVERS_PER_BACKUP servers in the domain.
                //

                PagedTransport->NumberOfBrowserServers = BackupsFound;

                BackupsNeeded = (RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) + (SERVERS_PER_BACKUP-1)) / SERVERS_PER_BACKUP;

                dlog(DPRT_MASTER,
                     ("%s: %ws: We need %lx backups, and have %lx.\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     BackupsNeeded,
                     PagedTransport->NumberOfBrowserServers));

                if (PagedTransport->NumberOfBrowserServers < BackupsNeeded) {

                    //
                    // We only need this many more backup browsers.
                    //

                    BackupsNeeded = BackupsNeeded - PagedTransport->NumberOfBrowserServers;

                    //
                    //  We need to promote a machine to a backup if possible.
                    //

                    ResumeKey = NULL;

                    for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ;
                         Announcement != NULL ;
                         Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ) {

                        //
                        //  If this announcement came from the master browser name
                        //

                        if (BowserIsValidPotentialBrowser(Transport, Announcement)) {

                            dlog(DPRT_MASTER,
                                 ("%s: %ws: Found browser to promote: %ws.\n",
                                 Transport->DomainInfo->DomOemDomainName,
                                 PagedTransport->TransportName.Buffer,
                                 Announcement->ServerName));

                            BowserPromoteToBackup(Transport, Announcement->ServerName);

                            //
                            //  Flag that we've attempted to promote this
                            //  browser.
                            //

                            Announcement->NumberOfPromotionAttempts += 1;

                            BackupsNeeded -= 1;

                            //
                            //  If we've promoted all the people we need to promote,
                            //  we're done, and can stop looping now.
                            //

                            if (BackupsNeeded == 0) {
                                    break;
                            }

                        } else if ((Announcement->ServerType & SV_TYPE_BACKUP_BROWSER) &&
                            (Announcement->ServerBrowserVersion < (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR)) {

                            //
                            //  If this guy is out of revision, shut him down.
                            //

                            BowserShutdownRemoteBrowser(Transport, Announcement->ServerName);
                        }
                    }
                }

            } else {

                //
                //  If we have enough configured browsers that we won't have
                //  any more backups, then demote all the non-configured
                //  browsers.
                //

                ResumeKey = NULL;

                for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ;
                     Announcement != NULL ;
                     Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->AnnouncementTable, &ResumeKey) ) {

                    //
                    //  If this machine is a valid machine to demote, do it.
                    //

                    if (BowserIsValidBackupBrowser(Transport, Announcement)) {

                       //
                       //  This machine shouldn't be a backup, since we
                       //  already have enough machines to be backups.
                       //  Demote this backup browser.
                       //

                       BowserShutdownRemoteBrowser(Transport, Announcement->ServerName);
                    }
                }
            }
        }

        ResumeKey = NULL;
        PreviousResumeKey = NULL;

        dlog(DPRT_MASTER,
              ("%s: %ws: Scavenge Domains:",
              Transport->DomainInfo->DomOemDomainName,
              PagedTransport->TransportName.Buffer));

        for (Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->DomainTable, &ResumeKey) ;
             Announcement != NULL ;
             Announcement = RtlEnumerateGenericTableWithoutSplaying(&PagedTransport->DomainTable, &ResumeKey) ) {

            if (BowserCurrentTime > Announcement->ExpirationTime) {

                NumberOfDomainsDeleted += 1;

                // Continue the search from where we found this entry.
                ResumeKey = PreviousResumeKey;

                dlog(DPRT_MASTER, ("%ws ", Announcement->ServerName));

                BowserDereferenceName( Announcement->Name );
                if (!RtlDeleteElementGenericTable(&PagedTransport->DomainTable, Announcement)) {
//                    KdPrint(("Unable to delete element %ws\n", Announcement->ServerName));
                }
            } else {

                //
                // Remember where this valid entry was found.
                //

                PreviousResumeKey = ResumeKey;
            }
        }

        dlog(DPRT_MASTER, ("\n", Announcement->ServerName));

    } finally {

#if DBG
        //
        //  Log an indication that we might have deleted too many servers.
        //

        if (NumberOfServersDeleted > BowserServerDeletionThreshold) {
            dlog(DPRT_MASTER,
                 ("%s: %ws: Aged out %ld servers.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer,
                 NumberOfServersDeleted ));
        }

        if (NumberOfDomainsDeleted > BowserDomainDeletionThreshold) {
            dlog(DPRT_MASTER,
                 ("%s: %ws: Aged out %ld domains.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer,
                 NumberOfDomainsDeleted ));
        }
#endif

        UNLOCK_ANNOUNCE_DATABASE(Transport);
    }

    UNREFERENCED_PARAMETER(Context);
    return STATUS_SUCCESS;
}


VOID
BowserShutdownRemoteBrowser(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    )
/*++

Routine Description:

    This routine will send a request to the remote machine to make it become
    a browser server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RESET_STATE ResetStateRequest;
    UNICODE_STRING Name;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    dlog(DPRT_BROWSER,
         ("%s: %ws: Demoting server %ws\n",
         Transport->DomainInfo->DomOemDomainName,
         PagedTransport->TransportName.Buffer,
         ServerName ));

    RtlInitUnicodeString(&Name, ServerName);

    ResetStateRequest.Type = ResetBrowserState;

    ResetStateRequest.ResetStateRequest.Options = RESET_STATE_CLEAR_ALL;

    //
    //  Send this reset state (tickle) packet to the computer specified.
    //

    BowserSendSecondClassMailslot(Transport,
                                &Name,
                                ComputerName,
                                &ResetStateRequest,
                                sizeof(ResetStateRequest),
                                TRUE,
                                MAILSLOT_BROWSER_NAME,
                                NULL);

}

VOID
BowserPromoteToBackup(
    IN PTRANSPORT Transport,
    IN PWSTR ServerName
    )
/*++

Routine Description:

    This routine will send a request to the remote machine to make it become
    a browser server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR Buffer[LM20_CNLEN+1+sizeof(BECOME_BACKUP)];
    PBECOME_BACKUP BecomeBackup = (PBECOME_BACKUP)Buffer;
    UNICODE_STRING UString;
    OEM_STRING AString;
    NTSTATUS Status;
    ULONG BufferSize;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    dlog(DPRT_BROWSER,
         ("%s: %ws: Promoting server %ws to backup on %wZ\n",
         Transport->DomainInfo->DomOemDomainName,
         PagedTransport->TransportName.Buffer,
         ServerName ));

    BecomeBackup->Type = BecomeBackupServer;

    RtlInitUnicodeString(&UString, ServerName);

    AString.Buffer = BecomeBackup->BecomeBackup.BrowserToPromote;
    AString.MaximumLength = (USHORT)(sizeof(Buffer)-FIELD_OFFSET(BECOME_BACKUP, BecomeBackup.BrowserToPromote));

    Status = RtlUnicodeStringToOemString(&AString, &UString, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, UString.Buffer, UString.Length );
        return;
    }

    BufferSize = FIELD_OFFSET(BECOME_BACKUP, BecomeBackup.BrowserToPromote) +
                    AString.Length + sizeof(CHAR);

    BowserSendSecondClassMailslot(Transport,
                                NULL,
                                BrowserElection,
                                BecomeBackup,
                                BufferSize,
                                TRUE,
                                MAILSLOT_BROWSER_NAME,
                                NULL);

}


NTSTATUS
BowserEnumerateServers(
    IN ULONG Level,
    IN PLUID LogonId OPTIONAL,
    IN OUT PULONG ResumeKey,
    IN ULONG ServerTypeMask,
    IN PUNICODE_STRING TransportName OPTIONAL,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferSize,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    )
/*++

Routine Description:

    This routine will enumerate the servers in the bowsers current announcement
    table.

Arguments:

    Level - The level of information to return

    LogonId - An optional logon id to indicate which user requested this info

    ResumeKey - The resume key (we return all entries after this one)

    ServerTypeMask - Mask of servers to return.

    TransportName - Name of the transport to enumerated on

    EmulatedDomainName - Name of the domain being emulated.

    DomainName OPTIONAL - Domain to filter (all if not specified)

    OutputBuffer - Buffer to fill with server info.

    OutputBufferSize - Filled in with size of buffer.

    EntriesRead - Filled in with the # of entries returned.

    TotalEntries - Filled in with the total # of entries.

    TotalBytesNeeded - Filled in with the # of bytes needed.

Return Value:

    None.

--*/

{
    LPTSTR               OutputBufferEnd;
    NTSTATUS             Status;
    ENUM_SERVERS_CONTEXT Context;
    PVOID                OriginalOutputBuffer = OutputBuffer;

    PAGED_CODE();

    OutputBuffer = ALLOCATE_POOL(PagedPool,OutputBufferSize,POOL_SERVER_ENUM_BUFFER);
    if (OutputBuffer == NULL) {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }

    OutputBufferEnd = (LPTSTR)((PCHAR)OutputBuffer+OutputBufferSize);

    Context.EntriesRead = 0;
    Context.TotalEntries = 0;
    Context.TotalBytesNeeded = 0;

    Context.Level = Level;
    Context.LogonId = LogonId;
    Context.OriginalResumeKey = *ResumeKey;
    Context.ServerTypeMask = ServerTypeMask;
    Context.DomainName = DomainName;

    Context.OutputBufferSize = OutputBufferSize;
    Context.OutputBuffer = OutputBuffer;
    Context.OutputBufferDisplacement =
        ((PCHAR)OutputBuffer - ((PCHAR)OriginalOutputBuffer - OutputBufferDisplacement));
    Context.OutputBufferEnd = OutputBufferEnd;

    dlog(DPRT_SRVENUM, ("Enumerate Servers: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
        OutputBuffer, OutputBufferSize, OutputBufferEnd));

    if (TransportName == NULL) {
        Status = STATUS_INVALID_PARAMETER;
    } else {
        PTRANSPORT Transport;

        Transport = BowserFindTransport(TransportName, EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from BowserEnumerateServers.\n", Transport));

        if (Transport == NULL) {
			FREE_POOL(OutputBuffer);
            return(STATUS_OBJECT_NAME_NOT_FOUND);
        }

        dlog(DPRT_SRVENUM,
            ("%s: %ws: Enumerate Servers: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
            Transport->DomainInfo->DomOemDomainName,
            Transport->PagedTransport->TransportName.Buffer,
            OutputBuffer, OutputBufferSize, OutputBufferEnd));

        Status = EnumerateServersWorker(Transport, &Context);

        //
        //  Dereference the transport..

        BowserDereferenceTransport(Transport);

    }


    *EntriesRead = Context.EntriesRead;
    *TotalEntries = Context.TotalEntries;
    *TotalBytesNeeded = Context.TotalBytesNeeded;
    *ResumeKey = Context.ResumeKey;

    try {
        RtlCopyMemory(OriginalOutputBuffer,OutputBuffer,OutputBufferSize);
    } except (BR_EXCEPTION) {
        FREE_POOL(OutputBuffer);
        return(GetExceptionCode());
    }

    FREE_POOL(OutputBuffer);

    dlog(DPRT_SRVENUM, ("TotalEntries: %lx EntriesRead: %lx, TotalBytesNeeded: %lx\n", *TotalEntries, *EntriesRead, *TotalBytesNeeded));

    if (*EntriesRead == *TotalEntries) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_MORE_ENTRIES;
    }

}


NTSTATUS
EnumerateServersWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for GowserGetAnnounceTableSize.

    It is called for each of the serviced transports in the bowser and
    returns the size needed to enumerate the servers received on each transport.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PENUM_SERVERS_CONTEXT Context = Ctx;
    PANNOUNCE_ENTRY Announcement;
    NTSTATUS Status;
    ULONG AnnouncementIndex;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PUNICODE_STRING DomainName;

    PAGED_CODE();
    LOCK_ANNOUNCE_DATABASE_SHARED(Transport);

    if (Context->DomainName == NULL) {
        DomainName = &Transport->DomainInfo->DomUnicodeDomainName;
    } else {
        DomainName = Context->DomainName;
    }
    try {

        PVOID ResumeKey = NULL;

        for (AnnouncementIndex = 1,
             Announcement = RtlEnumerateGenericTableWithoutSplaying((Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ?
                                                        &PagedTransport->DomainTable :
                                                        &PagedTransport->AnnouncementTable),
                                                        &ResumeKey) ;

             Announcement != NULL ;

             AnnouncementIndex += 1,
             Announcement = RtlEnumerateGenericTableWithoutSplaying((Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ?
                                                        &PagedTransport->DomainTable :
                                                        &PagedTransport->AnnouncementTable),
                                                        &ResumeKey) ) {

            //
            //  If the type mask matches, check the domain supplied to make sure
            //  that this announcement is acceptable to the caller.
            //

            //
            //  If we are doing a domain enumeration, we want to use domains
            //  received on all names, otherwise we want to use names only
            //  seen on the domain being queried.
            //
            if ((AnnouncementIndex > Context->OriginalResumeKey) &&

                ((Announcement->ServerType & Context->ServerTypeMask) != 0) &&

                (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ||
                 RtlEqualUnicodeString(DomainName, &Announcement->Name->Name, TRUE))
               ) {

                try {

                    //
                    //  We have an entry we can return to the user.
                    //

                    Context->TotalEntries += 1;

                    if (PackServerAnnouncement(Context->Level,
                                            Context->ServerTypeMask,
                                            (LPTSTR *)&Context->OutputBuffer,
                                            (LPTSTR *)&Context->OutputBufferEnd,
                                            Context->OutputBufferDisplacement,
                                            Announcement,
                                            &Context->TotalBytesNeeded)) {

                        Context->EntriesRead += 1;

                        //
                        //  Set the resume key in the structure to point to
                        //  the last entry we returned.
                        //

                        Context->ResumeKey = AnnouncementIndex;
                    }

                } except (BR_EXCEPTION) {

                    try_return(Status = GetExceptionCode());

                }
#if 0
            } else {
                if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ||
                    Context->ServerTypeMask == SV_TYPE_ALL ) {
                    KdPrint(("Skipping Announce entry %ws.  Index: %ld, ResumeKey: %ld, Domain: %wZ, %wZ\n",
                                Announcement->ServerName,
                                AnnouncementIndex,
                                Context->OriginalResumeKey,
                                &Announcement->Name->Name,
                                DomainName));
                }
#endif
            }
        }

        try_return(Status = STATUS_SUCCESS);

try_exit: {

#if 0

        if (Context->ServerTypeMask == SV_TYPE_ALL) {
            if (AnnouncementIndex-1 != RtlNumberGenericTableElements(&Transport->AnnouncementTable) ) {
                KdPrint(("Bowser: Announcement index != Number of elements in table (%ld, %ld) on transport %wZ\n", AnnouncementIndex-1, RtlNumberGenericTableElements(&Transport->AnnouncementTable), &Transport->TransportName ));

            }
        } else if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM) {
            if (AnnouncementIndex-1 != RtlNumberGenericTableElements(&Transport->DomainTable) ) {
                KdPrint(("Bowser: Announcement index != Number of domains in table (%ld, %ld) on transport %wZ\n", AnnouncementIndex-1, RtlNumberGenericTableElements(&Transport->DomainTable), &Transport->TransportName ));

            }
        }


        if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM) {
            if (Context->TotalEntries != RtlNumberGenericTableElements(&Transport->DomainTable)) {
                KdPrint(("Bowser: Returned EntriesRead == %ld, But %ld entries in table on transport %wZ\n", Context->TotalEntries, RtlNumberGenericTableElements(&Transport->DomainTable), &Transport->TransportName ));

            }
        } else if (Context->ServerTypeMask == SV_TYPE_ALL) {
            if (Context->TotalEntries != RtlNumberGenericTableElements(&Transport->AnnouncementTable)) {
               KdPrint(("Bowser: Returned EntriesRead == %ld, But %ld entries in table on transport %wZ\n", Context->TotalEntries, RtlNumberGenericTableElements(&Transport->AnnouncementTable), &Transport->TransportName ));

            }
        }

        if (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM || Context->ServerTypeMask == SV_TYPE_ALL) {
            if (Context->EntriesRead <= 20) {
                KdPrint(("Bowser: Returned %s: EntriesRead == %ld (%ld/%ld) on transport %wZ. Resume handle: %lx, %lx\n",
                                (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ? "domain" : "server"),
                                Context->EntriesRead,
                                RtlNumberGenericTableElements(&Transport->AnnouncementTable),
                                RtlNumberGenericTableElements(&Transport->DomainTable),
                                &Transport->TransportName,
                                Context->ResumeKey,
                                Context->OriginalResumeKey ));
            }

            if (Context->TotalEntries <= 20) {
                KdPrint(("Bowser: Returned %s: TotalEntries == %ld (%ld/%ld) on transport %wZ. Resume handle: %lx, %lx\n",
                                (Context->ServerTypeMask == SV_TYPE_DOMAIN_ENUM ? "domain" : "server"),
                                Context->TotalEntries,
                                RtlNumberGenericTableElements(&Transport->AnnouncementTable),
                                RtlNumberGenericTableElements(&Transport->DomainTable),
                                &Transport->TransportName,
                                Context->ResumeKey,
                                Context->OriginalResumeKey ));
            }
        }
#endif

    }

    } finally {

        UNLOCK_ANNOUNCE_DATABASE(Transport);
    }


    return(Status);

}


BOOLEAN
PackServerAnnouncement (
    IN ULONG Level,
    IN ULONG ServerTypeMask,
    IN OUT LPTSTR *BufferStart,
    IN OUT LPTSTR *BufferEnd,
    IN ULONG_PTR BufferDisplacment,
    IN PANNOUNCE_ENTRY Announcement,
    OUT PULONG TotalBytesNeeded
    )

/*++

Routine Description:

    This routine packs a server announcement into the buffer provided updating
    all relevant pointers.


Arguments:

    IN ULONG Level - Level of information requested.

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                            Updated to point to the next buffer
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                                            point before the start of the
                                            strings being packed.
    IN PVOID UsersBufferStart - Supplies the start of the buffer in the users
                                            address space
    IN PANNOUNCE_ENTRY Announcement - Supplies the announcement to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                        entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.


--*/

{
    ULONG BufferSize;
    UNICODE_STRING UnicodeNameString, UnicodeCommentString;

    PSERVER_INFO_101 ServerInfo = (PSERVER_INFO_101 )*BufferStart;

    PAGED_CODE();

    switch (Level) {
    case 100:
        BufferSize = sizeof(SERVER_INFO_100);
        break;
    case 101:
        BufferSize = sizeof(SERVER_INFO_101);
        break;
    default:
        return FALSE;
    }

    *BufferStart = (LPTSTR)(((PUCHAR)*BufferStart) + BufferSize);

    dlog(DPRT_SRVENUM, ("Pack Announcement %ws (%lx) - %ws :", Announcement->ServerName, Announcement, Announcement->ServerComment));

    dlog(DPRT_SRVENUM, ("BufferStart: %lx, BufferEnd: %lx\n", ServerInfo, *BufferEnd));

    //
    //  Compute the length of the name.
    //

    RtlInitUnicodeString(&UnicodeNameString, Announcement->ServerName);

    ASSERT (UnicodeNameString.Length <= CNLEN*sizeof(WCHAR));

    RtlInitUnicodeString(&UnicodeCommentString, Announcement->ServerComment);

    ASSERT (UnicodeCommentString.Length <= LM20_MAXCOMMENTSZ*sizeof(WCHAR));

#if DBG
    if (ServerTypeMask == SV_TYPE_DOMAIN_ENUM) {
        ASSERT (UnicodeCommentString.Length <= CNLEN*sizeof(WCHAR));
    }
#endif
    //
    //  Update the total number of bytes needed for this structure.
    //

    *TotalBytesNeeded += UnicodeNameString.Length  + BufferSize + sizeof(WCHAR);

    if (Level == 101) {
        *TotalBytesNeeded += UnicodeCommentString.Length + sizeof(WCHAR);

        if (ServerTypeMask == SV_TYPE_BACKUP_BROWSER) {
            *TotalBytesNeeded += 2;
        }

    }

    if (*BufferStart >= *BufferEnd) {
        return FALSE;
    }

    //
    //  Assume an OS/2 platform ID, unless an NT server
    //

    if (Announcement->ServerType & SV_TYPE_NT) {
        ServerInfo->sv101_platform_id = PLATFORM_ID_NT;
    } else {
        ServerInfo->sv101_platform_id = PLATFORM_ID_OS2;
    }

    ServerInfo->sv101_name = UnicodeNameString.Buffer;

    ASSERT (UnicodeNameString.Length / sizeof(WCHAR) <= CNLEN);

    if (!BowserPackUnicodeString(
                            &ServerInfo->sv101_name,
                            UnicodeNameString.Length,
                            BufferDisplacment,
                            *BufferStart,
                            BufferEnd)) {

        dlog(DPRT_SRVENUM, ("Unable to pack name %ws into buffer\n", Announcement->ServerName));
        return FALSE;
    }

    if (Level > 100) {
        PUSHORT VersionPointer;

        ServerInfo->sv101_version_major = Announcement->ServerVersionMajor;
        ServerInfo->sv101_version_minor = Announcement->ServerVersionMinor;
        ServerInfo->sv101_type = Announcement->ServerType;

        ServerInfo->sv101_comment = UnicodeCommentString.Buffer;

        ASSERT (UnicodeCommentString.Length / sizeof(WCHAR) <= LM20_MAXCOMMENTSZ);

        if (!BowserPackUnicodeString(
                            &ServerInfo->sv101_comment,
                            UnicodeCommentString.Length,
                            BufferDisplacment,
                            *BufferStart,
                            BufferEnd)) {

            dlog(DPRT_SRVENUM, ("Unable to pack comment %ws into buffer\n", Announcement->ServerComment));
            return FALSE;
        }

        if (ServerTypeMask == SV_TYPE_BACKUP_BROWSER) {

            //
            //  If we can't fit a ushort into the buffer, return an error.
            //

            if ((*BufferEnd - *BufferStart) <= sizeof(USHORT)) {
                return FALSE;

            }

            //
            //  Back the buffer end by the size of a USHORT (to make room for
            //  this value).
            //

            (ULONG_PTR)*BufferEnd -= sizeof(USHORT);

            VersionPointer = (PUSHORT)*BufferEnd;

            *VersionPointer = Announcement->ServerBrowserVersion;


        }

    }

    return TRUE;
}




PVIEW_BUFFER
BowserAllocateViewBuffer(
    VOID
    )
/*++

Routine Description:

    This routine will allocate a view buffer from the view buffer pool.

    If it is unable to allocate a buffer, it will allocate the buffer from
    non-paged pool (up to the maximum configured by the user).


Arguments:

    None.


Return Value:

    ViewBuffr - The allocated buffer.

--*/
{
    KIRQL OldIrql;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserViewBufferListSpinLock, &OldIrql);

    if (!IsListEmpty(&BowserViewBufferHead)) {
        PLIST_ENTRY Entry = RemoveHeadList(&BowserViewBufferHead);

        RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

        return CONTAINING_RECORD(Entry, VIEW_BUFFER, Overlay.NextBuffer);
    }

    if (BowserNumberOfServerAnnounceBuffers <=
        BowserData.NumberOfServerAnnounceBuffers) {
        PVIEW_BUFFER ViewBuffer = NULL;

        BowserNumberOfServerAnnounceBuffers += 1;

        RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

        ViewBuffer = ALLOCATE_POOL(NonPagedPool, sizeof(VIEW_BUFFER), POOL_VIEWBUFFER);

        if (ViewBuffer == NULL) {
            ACQUIRE_SPIN_LOCK(&BowserViewBufferListSpinLock, &OldIrql);

            BowserNumberOfServerAnnounceBuffers -= 1;

            BowserStatistics.NumberOfFailedServerAnnounceAllocations += 1;
            RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

            return NULL;
        }

        ViewBuffer->Signature = STRUCTURE_SIGNATURE_VIEW_BUFFER;

        ViewBuffer->Size = sizeof(VIEW_BUFFER);

        return ViewBuffer;
    }

    RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

    BowserStatistics.NumberOfMissedServerAnnouncements += 1;

    // run out of buffers.
    return NULL;
}

VOID
BowserFreeViewBuffer(
    IN PVIEW_BUFFER Buffer
    )
/*++

Routine Description:

    This routine will return a view buffer to the view buffer pool.

Arguments:

    IN PVIEW_BUFFER Buffer - Supplies the buffer to free

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ASSERT (Buffer->Signature == STRUCTURE_SIGNATURE_VIEW_BUFFER);

    ACQUIRE_SPIN_LOCK(&BowserViewBufferListSpinLock, &OldIrql);

    InsertTailList(&BowserViewBufferHead, &Buffer->Overlay.NextBuffer);

    RELEASE_SPIN_LOCK(&BowserViewBufferListSpinLock, OldIrql);

}

NTSTATUS
BowserpInitializeAnnounceTable(
    VOID
    )
/*++

Routine Description:

    This routine will allocate a transport descriptor and bind the bowser
    to the transport.

Arguments:


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PAGED_CODE();

    InitializeListHead(&BowserViewBufferHead);

    //
    //  Allocate a spin lock to protect the view buffer chain.
    //

    KeInitializeSpinLock(&BowserViewBufferListSpinLock);

    BowserNumberOfServerAnnounceBuffers = 0;

    return STATUS_SUCCESS;

}
NTSTATUS
BowserpUninitializeAnnounceTable(
    VOID
    )
/*++

Routine Description:

Arguments:


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER Buffer;

    PAGED_CODE();

    //
    //  Note: We don't need to protect this list while stopping because
    //  we have already unbound from all the loaded transports, thus no
    //  other announcements are being processed.
    //

    while (!IsListEmpty(&BowserViewBufferHead)) {
        PLIST_ENTRY Entry = RemoveHeadList(&BowserViewBufferHead);
        Buffer = CONTAINING_RECORD(Entry, VIEW_BUFFER, Overlay.NextBuffer);

        FREE_POOL(Buffer);
    }

    ASSERT (IsListEmpty(&BowserViewBufferHead));

    BowserNumberOfServerAnnounceBuffers = 0;

    return STATUS_SUCCESS;

}

VOID
BowserDeleteGenericTable(
    IN PRTL_GENERIC_TABLE GenericTable
    )
{
    PVOID TableElement;

    PAGED_CODE();

    //
    //  Enumerate the elements in the table, deleting them as we go.
    //

//    KdPrint("Delete Generic Table %lx\n", GenericTable));

    for (TableElement = RtlEnumerateGenericTable(GenericTable, TRUE) ;
         TableElement != NULL ;
         TableElement = RtlEnumerateGenericTable(GenericTable, TRUE)) {
        PANNOUNCE_ENTRY Announcement = TableElement;

        if (Announcement->BackupLink.Flink != NULL) {
            ASSERT (Announcement->BackupLink.Blink != NULL);

            ASSERT (Announcement->ServerType & SV_TYPE_BACKUP_BROWSER);

            RemoveEntryList(&Announcement->BackupLink);

            Announcement->BackupLink.Flink = NULL;

            Announcement->BackupLink.Blink = NULL;

        }

        BowserDereferenceName( Announcement->Name );
        RtlDeleteElementGenericTable(GenericTable, TableElement);
    }

    ASSERT (RtlNumberGenericTableElements(GenericTable) == 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowbackp.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowbackp.c

Abstract:

    This module implements all of the backup browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop

#define INCLUDE_SMB_TRANSACTION


typedef struct _BECOME_BACKUP_CONTEXT {
    WORK_QUEUE_ITEM WorkHeader;
    PTRANSPORT_NAME TransportName;
    PBECOME_BACKUP_1 BecomeBackupRequest;
    ULONG BytesAvailable;
} BECOME_BACKUP_CONTEXT, *PBECOME_BACKUP_CONTEXT;

VOID
BowserBecomeBackupWorker(
    IN PVOID WorkItem
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserBecomeBackupWorker)
#endif


DATAGRAM_HANDLER(
    BowserHandleBecomeBackup
    )
/*++

Routine Description:
    Indicate that a machine should become a backup browser server.

    This routine is called on receipt of a BecomeBackup frame.

Arguments:
    IN PTRANSPORT Transport - The transport for the net we're on.
    IN PUCHAR MasterName - The name of the new master browser server.

Return Value
    None.

--*/
{
    // PTA_NETBIOS_ADDRESS Address = SourceAddress;
    return BowserPostDatagramToWorkerThread(
                TransportName,
                Buffer,
                BytesAvailable,
                BytesTaken,
                SourceAddress,
                SourceAddressLength,
                SourceName,
                SourceNameLength,
                BowserBecomeBackupWorker,
                NonPagedPool,
                DelayedWorkQueue,
                ReceiveFlags,
                FALSE                               // No response will be sent
                );
}

VOID
BowserBecomeBackupWorker(
    IN PVOID WorkItem
    )

{
    PPOST_DATAGRAM_CONTEXT Context = WorkItem;
    PIRP Irp = NULL;
    PTRANSPORT Transport = Context->TransportName->Transport;
    UNICODE_STRING UPromoteeName;
    OEM_STRING APromoteeName;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PBECOME_BACKUP_1 BecomeBackupRequest = Context->Buffer;

    PAGED_CODE();

    UPromoteeName.Buffer = NULL;

    LOCK_TRANSPORT(Transport);

    try {
        NTSTATUS Status;

        //
        //  If this packet was smaller than a minimal packet,
        //      ignore the packet.
        //

        if (Context->BytesAvailable <= FIELD_OFFSET(BECOME_BACKUP_1, BrowserToPromote)) {
            try_return(NOTHING);
        }

        //
        // If the packet doesn't have a zero terminated BrowserToPromote,
        //  ignore the packet.
        //

        if ( !IsZeroTerminated(
                BecomeBackupRequest->BrowserToPromote,
                Context->BytesAvailable - FIELD_OFFSET(BECOME_BACKUP_1, BrowserToPromote) ) ) {
            try_return(NOTHING);
        }


        RtlInitAnsiString(&APromoteeName, BecomeBackupRequest->BrowserToPromote);

        Status = RtlOemStringToUnicodeString(&UPromoteeName, &APromoteeName, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, APromoteeName.Buffer, APromoteeName.Length );
            try_return(NOTHING);
        }

        if (RtlEqualUnicodeString(&UPromoteeName, &Transport->DomainInfo->DomUnicodeComputerName, TRUE)) {

            if (PagedTransport->Role == Master) {

                BowserWriteErrorLogEntry(EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER,
                                        STATUS_UNSUCCESSFUL,
                                        NULL,
                                        0,
                                        0);

                try_return(NOTHING);

            }


            //
            //  Ignore become backup requests on point-to-point (RAS) links and
            //      transports which are actually duplicates of others.
            //

            if (PagedTransport->DisabledTransport) {
                try_return(NOTHING);
            }

            //
            //  Complete any the first become backup request outstanding against this
            //  workstation.
            //

            Irp = BowserDequeueQueuedIrp(&Transport->BecomeBackupQueue);

            if (Irp != NULL) {
                Irp->IoStatus.Information = 0;

                BowserCompleteRequest(Irp, STATUS_SUCCESS);
            }
        }


try_exit:NOTHING;
    } finally {

        UNLOCK_TRANSPORT(Transport);

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        if (UPromoteeName.Buffer != NULL) {
            RtlFreeUnicodeString(&UPromoteeName);
        }

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

    }

}

VOID
BowserResetStateForTransport(
    IN PTRANSPORT Transport,
    IN UCHAR NewState
    )
{
    PIRP Irp = NULL;
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    //
    //  Complete a reset state IRP outstanding on this transport.
    //

    Irp = BowserDequeueQueuedIrp(&Transport->ChangeRoleQueue);

    if (Irp != NULL) {
        PLMDR_REQUEST_PACKET RequestPacket = Irp->AssociatedIrp.SystemBuffer;

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            RequestPacket->Parameters.ChangeRole.RoleModification = NewState;

            Irp->IoStatus.Information = sizeof(LMDR_REQUEST_PACKET);

            Status = STATUS_SUCCESS;
        }

        BowserCompleteRequest(Irp, Status);
    }

}

DATAGRAM_HANDLER(
    BowserResetState
    )
{
    PTRANSPORT Transport = TransportName->Transport;
    UCHAR NewState = (UCHAR)((PRESET_STATE_1)(Buffer))->Options;

    if (!BowserRefuseReset) {
        BowserResetStateForTransport(Transport, NewState);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowdata.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowdata.h

Abstract:

    Redirector global data structure definition

Author:

    Larry Osterman (LarryO) 30-May-1990

Revision History:

    30-May-1990 LarryO

        Created

--*/
#ifndef _BOWDATA_
#define _BOWDATA_


#define SERVERS_PER_BACKUP          32
#define MIN_CONFIGURED_BROWSERS     1
#define MAX_BROWSE_ENTRIES          (100000)
#define MASTER_TIME_UP              15*60*1000
#define NUMBER_IGNORED_PROMOTIONS   10

#define HOST_ANNOUNCEMENT_AGE 3

//
//
//
typedef struct _BowserData {
    BOOLEAN Initialized;                    // True iff redirector has been started
    LONG    NumberOfMailslotBuffers;        // Number of buffers to receive mailslots
    LONG    NumberOfServerAnnounceBuffers;  // Number of buffers for server announcements
    LONG    IllegalDatagramThreshold;       // Max number of illegal datagrams/frequency
    LONG    EventLogResetFrequency;         // Number of seconds between resetting counter.
    BOOLEAN ProcessHostAnnouncements;
    BOOLEAN MaintainServerList;
    BOOLEAN IsLanmanNt;
#ifdef ENABLE_PSEUDO_BROWSER
    DWORD   PseudoServerLevel;
#endif
} BOWSERDATA, *PBOWSERDATA;

typedef struct _BOWSER_CONFIG_INFO {
    LPWSTR      ConfigParameterName;
    PVOID       ConfigValue;
    ULONG       ConfigValueType;
    ULONG       ConfigValueSize;
} BOWSER_CONFIG_INFO, *PBOWSER_CONFIG_INFO;

extern
BOWSER_CONFIG_INFO
BowserConfigEntries[];

//
//  Private boolean type used by redirector only.
//
//  Maps to REG_DWORD, with value != 0
//

#define REG_BOOLEAN (0xffffffff)
#define REG_BOOLEAN_SIZE (sizeof(DWORD))

//
//
//
//  Bowser Data variables
//
//
//

extern
ERESOURCE
BowserNameResource;

extern
UNICODE_STRING
BowserNameString;

extern
LIST_ENTRY
BowserNameHead;

extern
KSPIN_LOCK
BowserTimeSpinLock;

extern
KSPIN_LOCK
BowserMailslotSpinLock;

extern
PKEVENT
BowserServerAnnouncementEvent;

extern
struct _BOWSER_FS_DEVICE_OBJECT *
BowserDeviceObject;

extern
ERESOURCE
BowserDataResource;                     // Resource controlling Bowser data.

extern
BOWSERDATA
BowserData;                             // Structure protected by resource

extern ULONG BowserOperationCount;

#define BOWSER_DEFAULT_IRP_STACK_SIZE 4

extern
ULONG
BowserIrpStackSize;

extern
ULONG
BowserCurrentTime;

extern
LARGE_INTEGER
BowserStartTime;

extern
KSPIN_LOCK
BowserTransportMasterNameSpinLock;

extern
PEPROCESS
BowserFspProcess;

extern
LONG
BowserEventLogResetFrequency;

extern
LONG
BowserIllegalDatagramCount;

extern
BOOLEAN
BowserIllegalDatagramThreshold;

extern
LONG
BowserIllegalNameCount;

extern
BOOLEAN
BowserIllegalNameThreshold;

extern
BOOLEAN
BowserLogElectionPackets;

extern
BOWSER_STATISTICS
BowserStatistics;

extern
KSPIN_LOCK
BowserStatisticsLock;

extern
ULONG
BowserNumberOfMissedMailslotDatagrams;

extern
ULONG
BowserNumberOfMissedGetBrowserServerListRequests;


extern
ULONG
BowserMailslotDatagramThreshold;

extern
ULONG
BowserGetBrowserListThreshold;

extern
ULONG
BowserServerDeletionThreshold;

extern
ULONG
BowserDomainDeletionThreshold;

extern
ULONG
BowserFindMasterTimeout;

extern
ULONG
BowserMinimumConfiguredBrowsers;

extern
ULONG
BowserMaximumBrowseEntries;

extern
BOOLEAN
BowserRefuseReset;

extern
ULONG
BowserRandomSeed;

extern
LONG
BowserNumberOfOpenFiles;

#endif          // _BOWDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowipx.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowipx.h

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/

#ifndef _BOWIPX_
#define _BOWIPX_

NTSTATUS
BowserIpxNameDatagramHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
BowserIpxClaimBrowserName (
    IN PTRANSPORT_NAME TransportName
    );

//
// Transport Receive Datagram indication handlers
//

NTSTATUS
BowserIpxDatagramHandler (
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

//
// IPX packet types used by the browser
//

#define IPX_BROADCAST_PACKET 0x14
#define IPX_DIRECTED_PACKET 0x4

#endif  // _BOWIPX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowelect.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowelect.c

Abstract:

    This module implements all of the election related routines for the NT
    browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop

#define INCLUDE_SMB_TRANSACTION


NTSTATUS
BowserStartElection(
    IN PTRANSPORT Transport
    );

LONG
BowserSetElectionCriteria(
    IN PPAGED_TRANSPORT Transport
    );

NTSTATUS
BowserElectMaster(
    IN PTRANSPORT Transport
    );

VOID
HandleElectionWorker(
    IN PVOID Ctx
    );


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, GetMasterName)
#pragma alloc_text(PAGE, HandleElectionWorker)
#pragma alloc_text(PAGE, BowserSetElectionCriteria)
#pragma alloc_text(PAGE, BowserStartElection)
#pragma alloc_text(PAGE, BowserElectMaster)
#pragma alloc_text(PAGE, BowserLoseElection)
#pragma alloc_text(PAGE, BowserFindMaster)
#pragma alloc_text(PAGE, BowserSendElection)
#endif


NTSTATUS
GetMasterName (
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )
{
    NTSTATUS           Status;
    PTRANSPORT         Transport       = NULL;
    PPAGED_TRANSPORT   PagedTransport;
    PIO_STACK_LOCATION IrpSp           = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name)+3*sizeof(WCHAR)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from GetMasterName.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        PagedTransport = Transport->PagedTransport;

        dlog(DPRT_FSCTL,
             ("%s: %ws: NtDeviceIoControlFile: GetMasterName\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer ));

        PagedTransport->ElectionCount = ELECTION_COUNT;

        Status = BowserQueueNonBufferRequest(Irp,
                                         &Transport->FindMasterQueue,
                                         BowserCancelQueuedRequest
                                         );
        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        Status = BowserFindMaster(Transport);

        //
        //  If we couldn't initiate the find master process, complete all the
        //  queued find master requests.
        //

        if (!NT_SUCCESS(Status)) {
            BowserCompleteFindMasterRequests(Transport, &PagedTransport->MasterName, Status);
        }

        //
        //  Since we marked the IRP as pending, we need to return pending
        //  now.
        //

        try_return(Status = STATUS_PENDING);


try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return(Status);

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);

}


DATAGRAM_HANDLER(BowserHandleElection)
{
    // PTA_NETBIOS_ADDRESS Address = SourceAddress;

    return BowserPostDatagramToWorkerThread(
                TransportName,
                Buffer,
                BytesAvailable,
                BytesTaken,
                SourceAddress,
                SourceAddressLength,
                SourceName,
                SourceNameLength,
                HandleElectionWorker,
                NonPagedPool,
                CriticalWorkQueue,
                ReceiveFlags,
                FALSE                       // Response will be sent, but...
                );

}

VOID
HandleElectionWorker(
    IN PVOID Ctx
    )
{
    PPOST_DATAGRAM_CONTEXT Context = Ctx;
    PTRANSPORT_NAME TransportName = Context->TransportName;
    PREQUEST_ELECTION_1 ElectionResponse = Context->Buffer;
    ULONG BytesAvailable = Context->BytesAvailable;
    ULONG TimeUp;
    BOOLEAN Winner;
    PTRANSPORT Transport = TransportName->Transport;
    NTSTATUS Status;
    LONG ElectionDelay, NextElection;
    OEM_STRING ClientNameO;
    UNICODE_STRING ClientName;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    ClientName.Buffer = NULL;

    try {

        //
        //  If this packet was smaller than a minimal packet,
        //      ignore the packet.
        //

        if (BytesAvailable <= FIELD_OFFSET(REQUEST_ELECTION_1, ServerName)) {
            try_return(NOTHING);
        }

        //
        // If the packet doesn't have a zero terminated ServerName,
        //  ignore the packet.
        //

        if ( !IsZeroTerminated(
                ElectionResponse->ServerName,
                BytesAvailable - FIELD_OFFSET(REQUEST_ELECTION_1, ServerName) ) ) {
            try_return(NOTHING);
        }

        BowserStatistics.NumberOfElectionPackets += 1;

        //
        //  Remember the last time we heard an election packet.
        //

        PagedTransport->LastElectionSeen = BowserTimeUp();

        if (Transport->ElectionState == DeafToElections) {
            try_return(NOTHING);
        }

        //
        // If we've disable the transport for any reason,
        //  then we disregard all elections.
        //

        if (PagedTransport->DisabledTransport) {
            try_return(NOTHING);
        }

        //
        //  Convert the client name in the election packet to unicode so we can
        //  log it.
        //

        RtlInitString(&ClientNameO, ElectionResponse->ServerName);

        Status = RtlOemStringToUnicodeString(&ClientName, &ClientNameO, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, ClientNameO.Buffer, ClientNameO.Length );

            try_return(NOTHING);
        }

        if (BowserLogElectionPackets) {
            BowserWriteErrorLogEntry(EVENT_BOWSER_ELECTION_RECEIVED, STATUS_SUCCESS, ElectionResponse, (USHORT)BytesAvailable, 2, ClientName.Buffer, PagedTransport->TransportName.Buffer);
        }

        dlog(DPRT_ELECT,
             ("%s: %ws: Received election packet from machine %s.  Version: %lx; Criteria: %lx; TimeUp: %lx\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer,
             ElectionResponse->ServerName,
             ElectionResponse->Version,
             SmbGetUlong(&ElectionResponse->Criteria),
             SmbGetUlong(&ElectionResponse->TimeUp)));



        //
        //  Figure out our time up for the election compare.
        //
        //  If we're running an election, we'll use our advertised time, else
        //  we'll use our actual uptime. Also, if we're running an election
        //  we'll check to see if we sent this. If we're not running an election
        //  and we receive this, it's because the redirector didn't find a
        //  master, so we want to continue the election and become master.
        //

        if (Transport->ElectionState == RunningElection) {
            if (!strcmp(Transport->DomainInfo->DomOemComputerNameBuffer, ElectionResponse->ServerName)) {
                try_return(NOTHING);
            }

            //
            //  If this request was initiated from a client, ignore it.
            //
            if ((SmbGetUlong(&ElectionResponse->Criteria) == 0) &&
                (ElectionResponse->ServerName[0] == '\0')) {
                dlog(DPRT_ELECT,
                     ("%s: %ws: Dummy election request ignored during election.\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));
                try_return(NOTHING);
            }

            if (PagedTransport->Role == Master) {
                ElectionDelay = BowserRandom(MASTER_ELECTION_DELAY);
            } else {
                ElectionDelay = ELECTION_RESPONSE_MIN + BowserRandom(ELECTION_RESPONSE_MAX-ELECTION_RESPONSE_MIN);
            }

        } else {

            //
            //  Starting a new election - set various election criteria
            //  including Uptime.
            //

            ElectionDelay = BowserSetElectionCriteria(PagedTransport);

        }

        TimeUp = PagedTransport->Uptime;

        if (ElectionResponse->Version != BROWSER_ELECTION_VERSION) {
            Winner = (ElectionResponse->Version < BROWSER_ELECTION_VERSION);
        } else if (SmbGetUlong(&ElectionResponse->Criteria) != PagedTransport->ElectionCriteria) {
            Winner = (SmbGetUlong(&ElectionResponse->Criteria) < PagedTransport->ElectionCriteria);
        } else if (TimeUp != SmbGetUlong(&ElectionResponse->TimeUp)) {
            Winner = TimeUp > SmbGetUlong(&ElectionResponse->TimeUp);
        } else {
            Winner = (strcmp(Transport->DomainInfo->DomOemDomainName, ElectionResponse->ServerName) <= 0);
        }

        //
        //  If we lost, we stop our timer and turn off our election flag, just
        //  in case we had an election or find master going. If we're a backup,
        //  we want to find out who the new master is, either from this election
        //  frame or waiting awhile and querying.
        //

        if (!Winner) {

            //
            //  Remember if we legitimately lost the last election, and if
            //  so, don't force an election if we see server announcements
            //  from a non DC, just give up.
            //

            PagedTransport->Flags |= ELECT_LOST_LAST_ELECTION;
        }

        if (!Winner || (PagedTransport->ElectionsSent > ELECTION_MAX)) {

            if (PagedTransport->IsPrimaryDomainController) {

                DWORD ElectionInformation[6];

                ElectionInformation[0] = ElectionResponse->Version;
                ElectionInformation[1] = SmbGetUlong(&ElectionResponse->Criteria);
                ElectionInformation[2] = SmbGetUlong(&ElectionResponse->TimeUp);
                ElectionInformation[3] = BROWSER_ELECTION_VERSION;
                ElectionInformation[4] = PagedTransport->ElectionCriteria;
                ElectionInformation[5] = TimeUp;

                //
                //  Write this information into the event log.
                //

                BowserWriteErrorLogEntry(EVENT_BOWSER_PDC_LOST_ELECTION,
                                            STATUS_SUCCESS,
                                            ElectionInformation,
                                            sizeof(ElectionInformation),
                                            2,
                                            ClientName.Buffer,
                                            PagedTransport->TransportName.Buffer);

                KdPrint(("HandleElectionWorker: Lose election, but we're the PDC.  Winner: Version: %lx; Criteria: %lx; Time Up: %lx; Name: %s\n",
                                ElectionResponse->Version,
                                SmbGetUlong(&ElectionResponse->Criteria),
                                SmbGetUlong(&ElectionResponse->TimeUp),
                                ElectionResponse->ServerName));

            }

            BowserLoseElection(Transport);

        } else {
            //
            //  We won this election, make sure that we don't think that we
            //  lost it.
            //

            PagedTransport->Flags &= ~ELECT_LOST_LAST_ELECTION;

            //
            //  If we won and we're not running an election, we'll start one.
            //  If we are running, we don't do anything because our timer will
            //  take care of it. If the NET_ELECTION flag is clear, we know
            //  timeup is approx. equal to time_up() because we set it above,
            //  so we'll use that. This algorithm includes a damping constant
            //  (we won't start an election  if we've just lost one in the
            //  last 1.5 seconds) to avoid election storms.
            //


            if (Transport->ElectionState != RunningElection) {

                //
                //  If we recently lost an election, then ignore the fact
                //  that we won, and pretend we lost this one.
                //

                if ((PagedTransport->TimeLastLost != 0) &&
                    ((BowserTimeUp() - PagedTransport->TimeLastLost) < ELECTION_EXEMPT_TIME)) {

                    dlog(DPRT_ELECT,
                         ("%s: %ws: Browser is exempt from election\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer ));

                    try_return(NOTHING);
                }

                dlog(DPRT_ELECT,
                     ("%s: %ws: Better criteria, calling elect_master in %ld milliseconds.\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     ElectionDelay));

                //
                // Ensure the timer is running.
                //  We don't actually win the election until the timer expires.
                //

                Transport->ElectionState = RunningElection;

                PagedTransport->NextElection = 0;
            }

            PagedTransport->ElectionCount = ELECTION_COUNT;

            //
            //  Note: the next elect time must be computed into a signed
            //  integer in case the expiration time has already passed so
            //  don't try to optimize this code too much.
            //

            NextElection = PagedTransport->NextElection - (TimeUp - BowserTimeUp());

            if ((PagedTransport->NextElection == 0) || NextElection > ElectionDelay) {
                BowserStopTimer(&Transport->ElectionTimer);

                PagedTransport->NextElection = TimeUp + ElectionDelay;

                dlog(DPRT_ELECT,
                     ("%s: %ws: Calling ElectMaster in %ld milliseconds\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     ElectionDelay));

                BowserStartTimer(&Transport->ElectionTimer, ElectionDelay, BowserElectMaster, Transport);
            }
        }

try_exit:NOTHING;
    } finally {

        UNLOCK_TRANSPORT(Transport);

        InterlockedDecrement( &BowserPostedCriticalDatagramCount );
        FREE_POOL(Context);

        if (ClientName.Buffer != NULL) {
            RtlFreeUnicodeString(&ClientName);
        }

        BowserDereferenceTransportName(TransportName);
        BowserDereferenceTransport(Transport);
    }

    return;

}

LONG
BowserSetElectionCriteria(
    IN PPAGED_TRANSPORT PagedTransport
    )

/*++

Routine Description:
    Set election criteria for a network.

    Prepare for an election by setting Transport->ElectionCriteria based upon the local
    browser state.  Set Transport->Uptime to the current local up time.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    Number of milliseconds to delay before sending the election packet.

--*/
{
    LONG Delay;

    PAGED_CODE();

    PagedTransport->ElectionsSent = 0;   // clear bid counter
    PagedTransport->Uptime = BowserTimeUp();

    if (BowserData.IsLanmanNt) {
        PagedTransport->ElectionCriteria = ELECTION_CR_LM_NT;
    } else {
        PagedTransport->ElectionCriteria = ELECTION_CR_WIN_NT;
    }

    PagedTransport->ElectionCriteria |=
            ELECTION_MAKE_REV(BROWSER_VERSION_MAJOR, BROWSER_VERSION_MINOR);

    if (BowserData.MaintainServerList &&
            ((PagedTransport->NumberOfServersInTable +
             RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable)+
             RtlNumberGenericTableElements(&PagedTransport->DomainTable)) != 0)) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_CFG_BKP;
    }

    if (PagedTransport->IsPrimaryDomainController) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_PDC;
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_DOMMSTR;
    }

#ifdef ENABLE_PSEUDO_BROWSER
    if (BowserData.PseudoServerLevel == BROWSER_PSEUDO ||
        BowserData.PseudoServerLevel == BROWSER_SEMI_PSEUDO_NO_DMB ) {
        // Pseudo or Semi-Pseudo will win elections over peers
        // & in case of semi-pseudo except no DMB communications
        // all other functionality will remain on.
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_PSEUDO;
    }
#endif

    if (PagedTransport->Role == Master) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_MASTER;

        Delay = MASTER_ELECTION_DELAY;

    } else if (PagedTransport->IsPrimaryDomainController) {

        //
        //  If we are the PDC, we want to set our timeouts
        //  as if we were already the master.
        //
        //  This prevents us from getting into a situation where it takes
        //  more than ELECTION_DELAY_MAX to actually send out our response
        //  to an election.
        //

        Delay = MASTER_ELECTION_DELAY;

    } else if ((PagedTransport->Role == Backup) ||
               BowserData.IsLanmanNt) {
        //
        //  Likewise, if we are NTAS machines, we want to set out delay
        //  to match that of backup browsers (even if we're not a backup
        //  quite yet).
        //

        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_AM_BACKUP;
        Delay = BACKUP_ELECTION_DELAY_MIN + BowserRandom(BACKUP_ELECTION_DELAY_MAX-BACKUP_ELECTION_DELAY_MIN);

    } else {
        Delay = ELECTION_DELAY_MIN + BowserRandom(ELECTION_DELAY_MAX-ELECTION_DELAY_MIN);
    }

    //
    // Assume for now that all wannish transports are running the WINS client.
    //
    if ( PagedTransport->Wannish ) {
        PagedTransport->ElectionCriteria |= ELECTION_DESIRE_WINS_CLIENT;
    }

    return Delay;
}

NTSTATUS
BowserStartElection(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Initiate a browser election

    This routine is called when we are unable to find a master, and we want to
    elect one.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    try {

        //
        // If we've disable the transport for any reason,
        //  then we disregard all elections.
        //

        if (PagedTransport->DisabledTransport) {
            try_return(Status = STATUS_UNSUCCESSFUL);
        }

        //
        // If we're deaf to elections, or aren't any kind of
        //  browser then we can't start elections either.
        //

        if (Transport->ElectionState == DeafToElections ||
            PagedTransport->Role == None) {
            try_return(Status = STATUS_UNSUCCESSFUL);
        }

        PagedTransport->ElectionCount = ELECTION_COUNT;

        Transport->ElectionState = RunningElection;

        BowserSetElectionCriteria(PagedTransport);

        Status = BowserElectMaster(Transport);
try_exit:NOTHING;
    } finally {
        UNLOCK_TRANSPORT(Transport);

    }

    return Status;
}


NTSTATUS
BowserElectMaster(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Elect a master browser server.

    This routine is called when we think there is no master and we need to
    elect one.  We check our retry count, and if it's non-zero we send an
    elect datagram to the group name. Otherwise we become the master ourselves.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    None.

--*/
{
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    try {

        //
        //  If we're not running the election at this time, it means that
        //  between the time that we decided we were going to win the election
        //  and now, someone else announced with better criteria.  It is
        //  possible that this could happen if the announcement came in just
        //  before we ran (ie. if the announcement occured between when the
        //  timer DPC was queued and when the DPC actually fired).
        //

        if (Transport->ElectionState != RunningElection) {

            KdPrint(("BowserElectMaster: Lose election because we are no longer running the election\n"));

            BowserLoseElection(Transport);

        } else if (PagedTransport->ElectionCount != 0) {

            BowserStopTimer(&Transport->ElectionTimer);

            PagedTransport->ElectionCount -= 1;

            PagedTransport->ElectionsSent += 1;

            PagedTransport->NextElection = BowserTimeUp() + ELECTION_RESEND_DELAY;

            Status = BowserSendElection(&Transport->DomainInfo->DomUnicodeDomainName, BrowserElection, Transport, TRUE);

            // Lose the election if we can't send a datagram.
            if (!NT_SUCCESS(Status)) {
                BowserLoseElection(Transport);
                try_return(Status);
            }

            //
            //  If we were able to send the election,
            //  start the timer running.
            //

            BowserStartTimer(&Transport->ElectionTimer,
                    ELECTION_RESEND_DELAY,
                    BowserElectMaster,
                    Transport);


        } else {
            Transport->ElectionState = Idle;

            //
            //  If we're already the master we just return. This can happen if
            //  somebody starts an election (which we win) while we're already
            //  the master.
            //

            if (PagedTransport->Role != Master) {

                //
                //  We're the new master - we won!
                //

                BowserNewMaster(Transport, Transport->DomainInfo->DomOemComputerNameBuffer );

            } else {

                //
                // Were already the master. Make sure that all the backups
                // know this by sending an announcent
                //

                //
                //  This one's easy - simply set the servers announcement event to the
                //  signalled state.  If the server is running, this will force an
                //  announcement
                //

                KeSetEvent(BowserServerAnnouncementEvent, IO_NETWORK_INCREMENT, FALSE);
            }
        }

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {
        UNLOCK_TRANSPORT(Transport);
    }

    return Status;
}


VOID
BowserLoseElection(
    IN PTRANSPORT Transport
    )
{
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();


    LOCK_TRANSPORT(Transport);

    BowserStopTimer(&Transport->ElectionTimer);

    dlog(DPRT_ELECT,
        ("We lost the election\n",
        Transport->DomainInfo->DomOemDomainName,
        PagedTransport->TransportName.Buffer ));

    PagedTransport->TimeLastLost = BowserTimeUp();

    //
    //  We lost the election - we re-enter the idle state.
    //

    Transport->ElectionState = Idle;

    if (PagedTransport->Role == Master) {

        //
        //  If we lost, and we are currently a master, then tickle
        //  the browser service and stop being a master.
        //

        BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);

        //
        //  Remove all the entries on the server list for this
        //  transport.
        //

        LOCK_ANNOUNCE_DATABASE(Transport);

        //
        //  Flag that there should be no more announcements received on
        //  this name.
        //

        BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

//        KdPrint(("Deleting entire table on transport %wZ because we lost the election\n", &Transport->TransportName));

        BowserDeleteGenericTable(&PagedTransport->AnnouncementTable);

        BowserDeleteGenericTable(&PagedTransport->DomainTable);

        UNLOCK_ANNOUNCE_DATABASE(Transport);

#if 0
    } else if (Transport->Role == Backup) { // If we're a backup, find master
        dlog(DPRT_ELECT, ("We're a backup - Find the new master\n"));

        //
        //  If this guy is not the master, then we want to
        //  find a master at some later time.
        //

        Transport->ElectionCount = FIND_MASTER_COUNT;
        Transport->Uptime = Transport->TimeLastLost;
        BowserStopTimer(&Transport->FindMasterTimer);
        BowserStartTimer(&Transport->FindMasterTimer,
                                    FIND_MASTER_WAIT-(FIND_MASTER_WAIT/8)+ BowserRandom(FIND_MASTER_WAIT/4),
                                    BowserFindMaster,
                                    Transport);
#endif

    }

    UNLOCK_TRANSPORT(Transport);

}

NTSTATUS
BowserFindMaster(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Find the master browser server.

    This routine attempts to find the master browser server by
    sending a request announcement message to the master. If no response is
    heard after a while, we assume the master isn't present and run and
    election.

Arguments:
    Transport - The transport for the net we're on.

Return Value
    None.

--*/

{
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();

    LOCK_TRANSPORT(Transport);

    try {

        //
        //  If our count hasn't gone to 0 yet, we'll send a find master PDU.
        //

        if (PagedTransport->ElectionCount != 0) {

            PagedTransport->ElectionCount -= 1;       // Update count, and set timer

            BowserStopTimer(&Transport->FindMasterTimer);

            Status = BowserSendRequestAnnouncement(
                            &Transport->DomainInfo->DomUnicodeDomainName,
                            MasterBrowser,
                            Transport);

            if (NT_SUCCESS(Status) ||
                Status == STATUS_BAD_NETWORK_PATH) {
                //
                // We will retry on the following cases:
                //  - netbt returns success. Meaning I'll be looking for it.
                //  - nwlnknb returns STATUS_BAD_NETWORK_PATH meaning I can't find it.
                // In either case, we would try for ElectionCount times & then move
                // fwd to initiate elections. Otherwise we may end up in a state where because
                // we didn't find a master browser, we won't attempt to elect one & we'll fail
                // to become one. This will result w/ a domain w/ no master browser.
                //
                BowserStartTimer(&Transport->FindMasterTimer,
                        FIND_MASTER_DELAY,
                        BowserFindMaster,
                        Transport);
            } else {
                try_return(Status);
            }

        } else {
            ULONG CurrentTime;
            LONG TimeTilNextElection;

            //
            //  Count has expired, so we'll try to elect a new master.
            //

            dlog(DPRT_ELECT,
                 ("%s: %ws: Find_Master: Master not found, forcing election.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            if (BowserLogElectionPackets) {
                BowserWriteErrorLogEntry(EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED, STATUS_SUCCESS, NULL, 0, 1, PagedTransport->TransportName.Buffer);
            }

            //
            //  If it's been more than a reasonable of time since the last
            //  election, force a new election, otherwise set a timer to
            //  start an election after a reasonable amount of time.
            //
            //
            //  Calculate the time until the next election only once
            //  since it is possible that we might cross over the ELECTION_TIME
            //  threshold while performing these checks.
            //

            CurrentTime = BowserTimeUp();
            if   ( CurrentTime >= PagedTransport->LastElectionSeen) {
                TimeTilNextElection = (ELECTION_TIME - (CurrentTime - PagedTransport->LastElectionSeen));
            } else {
                TimeTilNextElection = ELECTION_TIME;
            }

            if ( TimeTilNextElection <= 0 ) {

                dlog(DPRT_ELECT,
                     ("%s: %ws: Last election long enough ago, forcing election\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));

                Status = BowserStartElection(Transport);

                //
                //  If we couldn't start the election, complete the find
                //  master requests with the appropriate error.
                //

                if (!NT_SUCCESS(Status)) {

                    //
                    //  Complete the requests with the current master name - it's
                    //  as good as anyone.
                    //

                    BowserCompleteFindMasterRequests(Transport, &PagedTransport->MasterName, Status);
                }

            } else {

                dlog(DPRT_ELECT,
                     ("%s: %ws: Last election too recent, delay %ld before forcing election\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     TimeTilNextElection ));

                BowserStartTimer(&Transport->FindMasterTimer,
                     TimeTilNextElection,
                     BowserStartElection,
                     Transport);
            }


        }

        try_return(Status = STATUS_SUCCESS);
try_exit:NOTHING;
    } finally {
        UNLOCK_TRANSPORT(Transport);
    }

    return Status;
}


NTSTATUS
BowserSendElection(
    IN PUNICODE_STRING NameToSend OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport,
    IN BOOLEAN SendActualBrowserInfo
    )
{
    UCHAR Buffer[sizeof(REQUEST_ELECTION)+LM20_CNLEN+1];
    PREQUEST_ELECTION ElectionRequest = (PREQUEST_ELECTION) Buffer;
    ULONG ComputerNameSize;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    ElectionRequest->Type = Election;

    //
    // If this transport is disabled,
    //  don't send any election packets.
    //

    if ( PagedTransport->DisabledTransport ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    //  If we are supposed to send the actual browser info, and we are
    //  running the browser send a real election packet, otherwise we
    //  just want to send a dummy packet.
    //

    if (SendActualBrowserInfo &&
        (PagedTransport->ServiceStatus & (SV_TYPE_POTENTIAL_BROWSER | SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER))) {
        dlog(DPRT_ELECT,
             ("%s: %ws: Send true election.\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer ));

        //
        //  If this request comes as a part of an election, we want to send
        //  the accurate browser information.
        //

        ElectionRequest->ElectionRequest.Version = BROWSER_ELECTION_VERSION;

        ElectionRequest->ElectionRequest.TimeUp = PagedTransport->Uptime;

        ElectionRequest->ElectionRequest.Criteria = PagedTransport->ElectionCriteria;

        ElectionRequest->ElectionRequest.MustBeZero = 0;

        ComputerNameSize = Transport->DomainInfo->DomOemComputerName.Length;
        strcpy( ElectionRequest->ElectionRequest.ServerName,
                Transport->DomainInfo->DomOemComputerName.Buffer );

    } else {
        dlog(DPRT_ELECT,
             ("%s: %ws: Send dummy election.\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer ));

        //
        //  If we are forcing the election because we can't get a backup list,
        //  send only dummy information.
        //

        ElectionRequest->ElectionRequest.Version = 0;
        ElectionRequest->ElectionRequest.Criteria = 0;
        ElectionRequest->ElectionRequest.TimeUp = 0;
        ElectionRequest->ElectionRequest.ServerName[0] = '\0';
        ElectionRequest->ElectionRequest.MustBeZero = 0;
        ComputerNameSize = 0;
    }

    return BowserSendSecondClassMailslot(Transport,
                                NameToSend,
                                NameType,
                                ElectionRequest,
                                FIELD_OFFSET(REQUEST_ELECTION, ElectionRequest.ServerName)+ComputerNameSize+sizeof(UCHAR),
                                TRUE,
                                MAILSLOT_BROWSER_NAME,
                                NULL
                                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowipx.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtdi.c

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#include <isnkrnl.h>
#include <smbipx.h>
#pragma hdrstop

NTSTATUS
BowserHandleIpxDomainAnnouncement(
    IN PTRANSPORT Transport,
    IN PSMB_IPX_NAME_PACKET NamePacket,
    IN PBROWSE_ANNOUNCE_PACKET_1 DomainAnnouncement,
    IN DWORD RequestLength,
    IN ULONG ReceiveFlags
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE4BROW, BowserHandleIpxDomainAnnouncement)
#endif

NTSTATUS
BowserIpxDatagramHandler (
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PVOID DatagramData;
    PINTERNAL_TRANSACTION InternalTransaction = NULL;
    ULONG DatagramDataSize;
    PTRANSPORT Transport = TdiEventContext;
    MAILSLOTTYPE Opcode;
    PSMB_IPX_NAME_PACKET NamePacket = Tsdu;
    PSMB_HEADER Smb = (PSMB_HEADER)(NamePacket+1);
    PCHAR ComputerName;
    PCHAR DomainName;
    PTRANSPORT_NAME TransportName = Transport->ComputerName;
    ULONG SmbLength = BytesIndicated - sizeof(SMB_IPX_NAME_PACKET);


    if (BytesAvailable > Transport->DatagramSize) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    if (BytesIndicated <= sizeof(SMB_IPX_NAME_PACKET)) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    // If we're not fully initialized yet,
    //  simply ignore the packet.
    //
    if (Transport->ComputerName == NULL ) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }


    ComputerName = ((PTA_NETBIOS_ADDRESS)(Transport->ComputerName->TransportAddress.Buffer))->Address[0].Address->NetbiosName;
    DomainName = Transport->DomainInfo->DomNetbiosDomainName;

    //
    //  It's not for us, ignore the announcement.
    //

    if (NamePacket->NameType == SMB_IPX_NAME_TYPE_MACHINE) {

        // Mailslot messages are always sent as TYPE_MACHINE even when they're
        // to the DomainName (so allow both).
        if (!RtlEqualMemory(ComputerName, NamePacket->Name, SMB_IPX_NAME_LENGTH) &&
            !RtlEqualMemory(DomainName, NamePacket->Name, SMB_IPX_NAME_LENGTH)) {
            return STATUS_REQUEST_NOT_ACCEPTED;
        }
    } else if (NamePacket->NameType == SMB_IPX_NAME_TYPE_WORKKGROUP) {
        if (!RtlEqualMemory(DomainName, NamePacket->Name, SMB_IPX_NAME_LENGTH)) {
            return STATUS_REQUEST_NOT_ACCEPTED;
        }
    } else if (NamePacket->NameType != SMB_IPX_NAME_TYPE_BROWSER) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    //  Classify the incoming packet according to it's type.  Depending on
    //  the type, either process it as:
    //
    //  1) A server announcement
    //  2) An incoming mailslot
    //

    Opcode = BowserClassifyIncomingDatagram(Smb, SmbLength,
                                            &DatagramData,
                                            &DatagramDataSize);
    if (Opcode == MailslotTransaction) {

        //
        // BowserHandleMailslotTransaction will always receive the indicated bytes
        // expecting to find the SMB.  Tell the TDI driver we've already consumed
        // the IPX_NAME_PACKET to keep that assumption constant.
        //

        *BytesTaken = sizeof(SMB_IPX_NAME_PACKET);
        return BowserHandleMailslotTransaction(
                    Transport->ComputerName,
                    NamePacket->SourceName,
                    0,                              // No IP address
                    sizeof(SMB_IPX_NAME_PACKET),    // SMB offset into TSDU
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket );

    } else if (Opcode == Illegal) {

        //
        //  This might be illegal because it's a short packet.  In that
        //  case, handle it as if it were a short packet and deal with any
        //  other failures when we have the whole packet.
        //

        if (BytesAvailable != BytesIndicated) {
            return BowserHandleShortBrowserPacket(Transport->ComputerName,
                                                TdiEventContext,
                                                SourceAddressLength,
                                                SourceAddress,
                                                OptionsLength,
                                                Options,
                                                ReceiveDatagramFlags,
                                                BytesAvailable,
                                                BytesTaken,
                                                IoRequestPacket,
                                                BowserIpxDatagramHandler
                                                );
        }

        BowserLogIllegalDatagram( Transport->ComputerName,
                                  Smb,
                                  (USHORT)(SmbLength & 0xffff),
                                  NamePacket->SourceName,
                                  ReceiveDatagramFlags);
        return STATUS_REQUEST_NOT_ACCEPTED;

    } else {
        // PTA_NETBIOS_ADDRESS NetbiosAddress = SourceAddress;

        if (BowserDatagramHandlerTable[Opcode] == NULL) {
            return STATUS_SUCCESS;
        }

        //
        //  If this isn't the full packet, post a receive for it and
        //  handle it when we finally complete the receive.
        //

        if (BytesIndicated != BytesAvailable) {
            return BowserHandleShortBrowserPacket(Transport->ComputerName,
                                                    TdiEventContext,
                                                    SourceAddressLength,
                                                    SourceAddress,
                                                    OptionsLength,
                                                    Options,
                                                    ReceiveDatagramFlags,
                                                    BytesAvailable,
                                                    BytesTaken,
                                                    IoRequestPacket,
                                                    BowserIpxDatagramHandler
                                                    );
        }

        InternalTransaction = DatagramData;

        //
        //  If this is a workgroup announcement (a server announcement for another
        //  workgroup), handle it specially - regardless of the opcode, it's
        //  really a workgroup announcement.
        //

        if (NamePacket->NameType == SMB_IPX_NAME_TYPE_BROWSER) {

            if (Opcode == LocalMasterAnnouncement ) {

                NTSTATUS status;

                //
                //  If we're processing these announcements, then handle this
                //  as a domain announcement.
                //

                if (Transport->MasterBrowser &&
                    Transport->MasterBrowser->ProcessHostAnnouncements) {

                    status = BowserHandleIpxDomainAnnouncement(Transport,
                                            NamePacket,
                                            (PBROWSE_ANNOUNCE_PACKET_1)&InternalTransaction->Union.Announcement,
                                            SmbLength-(ULONG)((PCHAR)&InternalTransaction->Union.Announcement - (PCHAR)Smb),
                                            ReceiveDatagramFlags);
                } else {
                    status = STATUS_REQUEST_NOT_ACCEPTED;
                }

                //
                //  If this request isn't for our domain, we're done with it, if
                //  it's for our domain, then we need to do some more work.
                //

                if (!RtlEqualMemory(DomainName, NamePacket->Name, SMB_IPX_NAME_LENGTH)) {
                    return status;
                }
            } else {

                //
                //  This isn't a master announcement, so ignore it.
                //

                return STATUS_REQUEST_NOT_ACCEPTED;
            }

        }

        //
        //  Figure out which transportname is appropriate for the request:
        //
        //  There are basically 3 choices:
        //
        //      ComputeName (The default)
        //      MasterBrowser (if this is a server announcement)
        //      PrimaryDomain (if this is a request announcement)
        //      Election (if this is a local master announcement)

        if ((Opcode == WkGroupAnnouncement) ||
            (Opcode == HostAnnouncement)) {
            if (Transport->MasterBrowser == NULL ||
                !Transport->MasterBrowser->ProcessHostAnnouncements) {
                return STATUS_REQUEST_NOT_ACCEPTED;
            } else {
                TransportName = Transport->MasterBrowser;
            }

        } else if (Opcode == AnnouncementRequest) {
            TransportName = Transport->PrimaryDomain;

        } else if (Opcode == LocalMasterAnnouncement) {
            if (Transport->BrowserElection != NULL) {
                TransportName = Transport->BrowserElection;
            } else {
                return STATUS_REQUEST_NOT_ACCEPTED;
            }
        }

        ASSERT (DatagramDataSize == (SmbLength - ((PCHAR)InternalTransaction - (PCHAR)Smb)));

        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BrowseAnnouncement));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.RequestElection));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BecomeBackup));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListRequest));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListResp));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.ResetState));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.MasterAnnouncement));

        return BowserDatagramHandlerTable[Opcode](TransportName,
                                            &InternalTransaction->Union.Announcement,
                                            SmbLength-(ULONG)((PCHAR)&InternalTransaction->Union.Announcement - (PCHAR)Smb),
                                            BytesTaken,
                                            SourceAddress,
                                            SourceAddressLength,
                                            &NamePacket->SourceName,
                                            SMB_IPX_NAME_LENGTH,
                                            ReceiveDatagramFlags);
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(OptionsLength);
    UNREFERENCED_PARAMETER(Options);
    UNREFERENCED_PARAMETER(ReceiveDatagramFlags);
}

NTSTATUS
BowserHandleIpxDomainAnnouncement(
    IN PTRANSPORT Transport,
    IN PSMB_IPX_NAME_PACKET NamePacket,
    IN PBROWSE_ANNOUNCE_PACKET_1 DomainAnnouncement,
    IN DWORD RequestLength,
    IN ULONG ReceiveFlags
    )

/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN PSMB_IPX_NAME_PACKET NamePacket    - The name packet for this request.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PVIEW_BUFFER ViewBuffer;

    DISCARDABLE_CODE(BowserDiscardableCodeSection);

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BowserData.PseudoServerLevel == BROWSER_PSEUDO ) {
        // no-op for black hole server
        return STATUS_SUCCESS;
    }
#endif

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfDomainAnnouncements, 1);

    ViewBuffer = BowserAllocateViewBuffer();

    //
    //  If we are unable to allocate a view buffer, ditch this datagram on
    //  the floor.
    //

    if (ViewBuffer == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    BowserCopyOemComputerName(ViewBuffer->ServerName, NamePacket->Name, SMB_IPX_NAME_LENGTH, ReceiveFlags);

    BowserCopyOemComputerName(ViewBuffer->ServerComment, NamePacket->SourceName, SMB_IPX_NAME_LENGTH, ReceiveFlags);

    if ( DomainAnnouncement->Type & SV_TYPE_NT ) {
        ViewBuffer->ServerType = SV_TYPE_DOMAIN_ENUM | SV_TYPE_NT;
    } else {
        ViewBuffer->ServerType = SV_TYPE_DOMAIN_ENUM;
    }

    ASSERT (Transport->MasterBrowser != NULL);

    ViewBuffer->TransportName = Transport->MasterBrowser;

    ViewBuffer->ServerVersionMajor = DomainAnnouncement->VersionMajor;

    ViewBuffer->ServerVersionMinor = DomainAnnouncement->VersionMinor;

    ViewBuffer->ServerPeriodicity = (USHORT)((SmbGetUlong(&DomainAnnouncement->Periodicity) + 999) / 1000);

    BowserReferenceTransportName(Transport->MasterBrowser);
    BowserReferenceTransport( Transport );

    ExInitializeWorkItem(&ViewBuffer->Overlay.WorkHeader, BowserProcessDomainAnnouncement, ViewBuffer);

    BowserQueueDelayedWorkItem( &ViewBuffer->Overlay.WorkHeader );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowelect.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowelect.h

Abstract:

    This module

Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/
#ifndef _BOWELECT_
#define _BOWELECT_

//
//  Timer values to respond to election requests.
//

#define MASTER_ELECTION_DELAY        100        // Master waits this long.
#define BACKUP_ELECTION_DELAY_MIN    200        // Backup waits at least this long
#define BACKUP_ELECTION_DELAY_MAX    600        // but no longer than this.
#define ELECTION_DELAY_MIN           800        // Others wait at least this long
#define ELECTION_DELAY_MAX          3000        // but no longer than this.
#define ELECTION_RESPONSE_MIN        200        // Election response delay.
#define ELECTION_RESPONSE_MAX        900        // Max electionresponse delay

#define ELECTION_RESEND_DELAY       1000        // Resend election at this interval

#define ELECTION_COUNT                 4        // We must win election this many times.
#define ELECTION_MAX                  30        // Don't send more than 30 election
                                                // responses in an election
#define ELECTION_EXEMPT_TIME    (ELECTION_DELAY_MAX + (ELECTION_RESEND_DELAY*ELECTION_COUNT)*2)

#define FIND_MASTER_WAIT        (ELECTION_DELAY_MAX + ELECTION_RESEND_DELAY*(ELECTION_COUNT+2))
#define FIND_MASTER_DELAY       1500            //  Retry find master delay.
#define FIND_MASTER_COUNT       6               //  Number of times to retry FM


#define TRANSPORT_BIND_TIME     3*1000          // Number of milliseconds to bind to transport.

//
//  The reasonable amount of time that it would take for an election.
//

#define ELECTION_TIME ((ELECTION_DELAY_MAX * ELECTION_COUNT) + TRANSPORT_BIND_TIME)

DATAGRAM_HANDLER(
    BowserHandleElection
    );

NTSTATUS
BowserSendElection(
    IN PUNICODE_STRING NameToSend,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport,
    IN BOOLEAN SendActualBrowserInfo
    );

NTSTATUS
GetMasterName (
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

//NTSTATUS
//BowserBackupFindMaster(
//    IN PTRANSPORT Transport,
//    IN PREQUEST_ELECTION_1 ElectionResponse,
//    IN ULONG BytesAvailable
//    );

NTSTATUS
BowserFindMaster(
    IN PTRANSPORT Transport
    );

VOID
BowserLoseElection(
    IN PTRANSPORT Transport
    );

#endif // _BOWELECT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowmastr.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowmastr.c

Abstract:

    This module implements all of the master browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop

#define INCLUDE_SMB_TRANSACTION

NTSTATUS
StartProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    );

VOID
BowserMasterAnnouncementWorker(
    IN PVOID Ctx
    );

NTSTATUS
TimeoutFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PVOID Context

    );
NTSTATUS
BowserPrimeDomainTableWithOtherDomains(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserBecomeMaster)
#pragma alloc_text(PAGE, StartProcessingAnnouncements)
#pragma alloc_text(PAGE, BowserPrimeDomainTableWithOtherDomains)
#pragma alloc_text(PAGE, BowserNewMaster)
#pragma alloc_text(PAGE, BowserCompleteFindMasterRequests)
#pragma alloc_text(PAGE, BowserTimeoutFindMasterRequests)
#pragma alloc_text(PAGE, TimeoutFindMasterRequests)
#pragma alloc_text(PAGE, BowserMasterAnnouncementWorker)
#endif


NTSTATUS
BowserBecomeMaster(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:
    Make this machine a master browser.

    This routine is called when we are changing the state of a machine from
    backup to master browser.

Arguments:
    Transport - The transport on which to become a master.

Return Value
    NTSTATUS - The status of the upgrade operation.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    try {

        LOCK_TRANSPORT(Transport);

        BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

        //
        //  Post the addname on this transport for the master name..
        //

        Status = BowserAllocateName(
                    &Transport->DomainInfo->DomUnicodeDomainName,
                    MasterBrowser,
                    Transport,
                    Transport->DomainInfo );

        if (NT_SUCCESS(Status)) {

            //
            //  Post the addname on this transport for the domain announcement.
            //

			// set the status to unsuccessful
			// so that we dont think we succeeded if an exception occurs later in the function
			Status = STATUS_UNSUCCESSFUL;	
            Status = BowserAllocateName(&Transport->DomainInfo->DomUnicodeDomainName,
                                            DomainAnnouncement,
                                            Transport,
                                            Transport->DomainInfo );
        }

        //
        //  The addition of the name failed - we can't be a master any
        //  more.
        //

        if (!NT_SUCCESS(Status)) {

            try_return(Status);

        }

        PagedTransport->Role = Master;

        //
        //  Start processing host announcements on each of
        //  the names associated with the server.
        //

        BowserForEachTransportName(Transport, StartProcessingAnnouncements, NULL);

        //
        //  If we don't have any elements in our announcement table,
        //  send a request announcement packet to all the servers to
        //  allow ourselves to populate the table as quickly as possible.
        //


#ifdef ENABLE_PSEUDO_BROWSER
        if ((RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0 &&
            BowserData.PseudoServerLevel != BROWSER_PSEUDO) {
#else
        if ((RtlNumberGenericTableElements(&PagedTransport->AnnouncementTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0) {
#endif
            BowserSendRequestAnnouncement(&Transport->DomainInfo->DomUnicodeDomainName,
                                            PrimaryDomain,
                                            Transport);

        }


        //
        //  If we don't have any elements in our domain table,
        //  send a request announcement packet to all the servers to
        //  allow ourselves to populate the table as quickly as possible.
        //

#ifdef ENABLE_PSEUDO_BROWSER
        if ((RtlNumberGenericTableElements(&PagedTransport->DomainTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0 &&
            BowserData.PseudoServerLevel != BROWSER_PSEUDO) {
#else
        if ((RtlNumberGenericTableElements(&PagedTransport->DomainTable) == 0) &&
            PagedTransport->NumberOfServersInTable == 0) {
#endif
            BowserSendRequestAnnouncement(&Transport->DomainInfo->DomUnicodeDomainName,
                                            DomainAnnouncement,
                                            Transport);
        }

        PagedTransport->TimeMaster = BowserTimeUp();


        //
        //  Now walk the transport names associated with this transport and
        //  seed all the "otherdomains" into the browse list.
        //

        BowserForEachTransportName(
                Transport,
                BowserPrimeDomainTableWithOtherDomains,
                NULL);

        //
        //  Now complete any and all find master requests outstanding on this
        //  transport.
        //

        BowserCompleteFindMasterRequests(Transport, &Transport->DomainInfo->DomUnicodeComputerName, STATUS_REQUEST_NOT_ACCEPTED);

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {

        if (!NT_SUCCESS(Status)) {

            dlog(DPRT_ELECT|DPRT_MASTER,
                 ("%s: %ws: There's already a master on this net - we need to find who it is",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            //
            //  We couldn't become a master.  Reset our state and fail the
            //  promotion request.
            //

            PagedTransport->Role = PotentialBackup;

            PagedTransport->ElectionCount = ELECTION_COUNT;

            PagedTransport->Uptime = BowserTimeUp();

            Transport->ElectionState = Idle;

            //
            //  Stop processing host announcements on each of
            //  the names associated with the server.
            //

            BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

            //
            //  Stop any timers that are running (ie. if there's an election
            //  in progress)
            //

            BowserStopTimer(&Transport->ElectionTimer);

            //
            //  Delete the names we added above.
            //

            BowserDeleteTransportNameByName(Transport,
                                NULL,
                                MasterBrowser);

            BowserDeleteTransportNameByName(Transport,
                                NULL,
                                DomainAnnouncement);


            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        }

        UNLOCK_TRANSPORT(Transport);
    }

    return Status;
}
NTSTATUS
StartProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    )
{
    PAGED_CODE();

    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (TransportName->NameType == TransportName->PagedTransportName->Name->NameType);

    if ((TransportName->NameType == OtherDomain) ||
        (TransportName->NameType == MasterBrowser) ||
        (TransportName->NameType == PrimaryDomain) ||
        (TransportName->NameType == BrowserElection) ||
        (TransportName->NameType == DomainAnnouncement)) {

        if (!TransportName->ProcessHostAnnouncements) {
            BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

            DISCARDABLE_CODE( BowserDiscardableCodeSection );

            TransportName->ProcessHostAnnouncements = TRUE;
        }

    }

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(Context);
}

NTSTATUS
BowserPrimeDomainTableWithOtherDomains(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    )
{
    PAGED_CODE();

    if (TransportName->NameType == OtherDomain) {
        PPAGED_TRANSPORT PagedTransport = TransportName->Transport->PagedTransport;
        PTRANSPORT Transport = TransportName->Transport;
        ANNOUNCE_ENTRY OtherDomainPrototype;
        PANNOUNCE_ENTRY Announcement;
        BOOLEAN NewElement;

        RtlZeroMemory( &OtherDomainPrototype, sizeof(OtherDomainPrototype) );
        OtherDomainPrototype.Signature = STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY;
        OtherDomainPrototype.Size = sizeof(OtherDomainPrototype) -
                                    sizeof(OtherDomainPrototype.ServerComment) +
                                    Transport->DomainInfo->DomUnicodeComputerName.Length + sizeof(WCHAR);

        RtlCopyMemory(OtherDomainPrototype.ServerName, TransportName->PagedTransportName->Name->Name.Buffer, TransportName->PagedTransportName->Name->Name.Length);
        OtherDomainPrototype.ServerName[TransportName->PagedTransportName->Name->Name.Length / sizeof(WCHAR)] = UNICODE_NULL;

        RtlCopyMemory(OtherDomainPrototype.ServerComment, Transport->DomainInfo->DomUnicodeComputerName.Buffer, Transport->DomainInfo->DomUnicodeComputerName.Length);

        OtherDomainPrototype.ServerComment[Transport->DomainInfo->DomUnicodeComputerName.Length / sizeof(WCHAR)] = UNICODE_NULL;

        OtherDomainPrototype.ServerType = SV_TYPE_DOMAIN_ENUM;

        OtherDomainPrototype.ServerVersionMajor = 2;

        OtherDomainPrototype.ServerVersionMinor = 0;

        OtherDomainPrototype.ServerPeriodicity = 0xffff;
        OtherDomainPrototype.ExpirationTime = 0xffffffff;

        OtherDomainPrototype.SerialId = 0;

        OtherDomainPrototype.Name = TransportName->PagedTransportName->Name;

        //
        //  Make sure that no-one else is messing with the domain list.
        //

        LOCK_ANNOUNCE_DATABASE(Transport);

        Announcement = RtlInsertElementGenericTable(&PagedTransport->DomainTable,
                        &OtherDomainPrototype, OtherDomainPrototype.Size, &NewElement);

        if (Announcement != NULL && NewElement ) {
            // Indicate the name is referenced by the announce entry we just inserted.
            BowserReferenceName( OtherDomainPrototype.Name );
        }

        UNLOCK_ANNOUNCE_DATABASE(Transport);

    }

    return(STATUS_SUCCESS);
}
VOID
BowserNewMaster(
    IN PTRANSPORT Transport,
    IN PUCHAR MasterName
    )
/*++

Routine Description:
    Flag that a machine is the new master browser server.

    This routine is called to register a new master browser server.

Arguments:
    IN PTRANSPORT Transport - The transport for the net we're on.
    IN PUCHAR MasterName - The name of the new master browser server.

Return Value
    None.

--*/
{
    PIRP Irp = NULL;
    WCHAR MasterNameBuffer[LM20_CNLEN+1];

    UNICODE_STRING UMasterName;
    OEM_STRING OMasterName;
    NTSTATUS Status;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    UMasterName.Buffer = MasterNameBuffer;
    UMasterName.MaximumLength = (LM20_CNLEN+1)*sizeof(WCHAR);

    RtlInitAnsiString(&OMasterName, MasterName);

    Status = RtlOemStringToUnicodeString(&UMasterName, &OMasterName, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, OMasterName.Buffer, OMasterName.Length );
        return;
    }

    LOCK_TRANSPORT(Transport);

    try {

        //
        //  There's a new master, we can stop our election timers.
        //

        PagedTransport->ElectionCount = 0;

        Transport->ElectionState = Idle;

        BowserStopTimer(&Transport->ElectionTimer);

        //
        //  Check to see if we are the winner of the election.  If we are
        //  we want to complete any BecomeMaster requests that are outstanding.
        //

        if (RtlEqualUnicodeString(&UMasterName, &Transport->DomainInfo->DomUnicodeComputerName, TRUE)) {

            //
            //  We're the new master for this domain.  Complete any BecomeMaster
            //  requests.
            //

            Irp = BowserDequeueQueuedIrp(&Transport->BecomeMasterQueue);

            if (Irp != NULL) {

                //
                //  Don't copy anything into the users buffer.
                //

                Irp->IoStatus.Information = 0;

                BowserCompleteRequest(Irp, STATUS_SUCCESS);
            } else {

                //
                //  Go deaf to elections until we can become a master.
                //

                Transport->ElectionState = DeafToElections;

                //
                //  If we're the master browser, stop being a master browser.
                //
                //

                if (PagedTransport->Role == MasterBrowser) {

                    //
                    //  Delete the names that make us a master.
                    //

                    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                MasterBrowser);

                    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                DomainAnnouncement);

                }

                dlog(DPRT_MASTER,
                     ("%s: %ws: Unable to find a BecomeMasterIrp\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));
            }

            //
            //  Complete any outstanding find master requests with the special error MORE_PROCESSING_REQUIRED.
            //
            //  This will cause the browser service to promote itself.
            //

            BowserCompleteFindMasterRequests(Transport, &UMasterName, STATUS_MORE_PROCESSING_REQUIRED);

        } else {

            BowserCompleteFindMasterRequests(Transport, &UMasterName, STATUS_SUCCESS);

        }

    } finally {
        UNLOCK_TRANSPORT(Transport);
    }
}

VOID
BowserCompleteFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING MasterName,
    IN NTSTATUS Status
    )
{
    PIO_STACK_LOCATION IrpSp;
    PIRP Irp = NULL;
    BOOLEAN MasterNameChanged;
    WCHAR MasterNameBuffer[CNLEN+1];
    UNICODE_STRING MasterNameCopy;
    NTSTATUS UcaseStatus;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    MasterNameCopy.Buffer = MasterNameBuffer;
    MasterNameCopy.MaximumLength = sizeof(MasterNameBuffer);

    UcaseStatus = RtlUpcaseUnicodeString(&MasterNameCopy, MasterName, FALSE);

    if (!NT_SUCCESS(UcaseStatus)) {
        BowserLogIllegalName( UcaseStatus, MasterName->Buffer, MasterName->Length );

        return;
    }

    LOCK_TRANSPORT(Transport);

    MasterNameChanged = !RtlEqualUnicodeString(&MasterNameCopy, &PagedTransport->MasterName, FALSE);

    if (MasterNameChanged) {
       //
       //  If the master name changed, update the masters name in
       //  the transport structure.
       //

       RtlCopyUnicodeString(&PagedTransport->MasterName, &MasterNameCopy);

    }

    UNLOCK_TRANSPORT(Transport);

    do {

        //
        //  Complete any the find master requests outstanding against this
        //  workstation.
        //

        Irp = BowserDequeueQueuedIrp(&Transport->FindMasterQueue);

        if (MasterNameChanged &&
            (Irp == NULL)) {

            Irp = BowserDequeueQueuedIrp(&Transport->WaitForNewMasterNameQueue);

        }

        if (Irp != NULL) {
            PLMDR_REQUEST_PACKET RequestPacket = Irp->AssociatedIrp.SystemBuffer;

            if (NT_SUCCESS(Status)) {

                IrpSp = IoGetCurrentIrpStackLocation(Irp);

                if (MasterName->Length > (USHORT)(IrpSp->Parameters.DeviceIoControl.OutputBufferLength-
                                                          (FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name))+3*sizeof(WCHAR)) ) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    RequestPacket->Parameters.GetMasterName.Name[0] = L'\\';
                    RequestPacket->Parameters.GetMasterName.Name[1] = L'\\';
                    RtlCopyMemory(&RequestPacket->Parameters.GetMasterName.Name[2], MasterName->Buffer, MasterName->Length);
                    RequestPacket->Parameters.GetMasterName.Name[2+(MasterName->Length/sizeof(WCHAR))] = UNICODE_NULL;
                }

                dlog(DPRT_MASTER,
                     ("%s: %ws: Completing a find master request with new master %ws\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     RequestPacket->Parameters.GetMasterName.Name));

                RequestPacket->Parameters.GetMasterName.MasterNameLength = MasterName->Length+2*sizeof(WCHAR);

                Irp->IoStatus.Information = FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name)+MasterName->Length+3*sizeof(WCHAR);

            }

            BowserCompleteRequest(Irp, Status);
        }

    } while ( Irp != NULL );
}


DATAGRAM_HANDLER(BowserMasterAnnouncement)
{
    PUCHAR  MasterName = ((PMASTER_ANNOUNCEMENT_1)Buffer)->MasterName;
    ULONG   i;

    //
    //  We need to make sure that the incoming packet contains a properly
    //     terminated ASCII string.
    //

    for (i = 0; i < BytesAvailable; i++) {
        if (MasterName[i] == '\0') {
            break;
        }
    }

    if (i == BytesAvailable) {
        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    return BowserPostDatagramToWorkerThread(
                TransportName,
                Buffer,
                BytesAvailable,
                BytesTaken,
                SourceAddress,
                SourceAddressLength,
                SourceName,
                SourceNameLength,
                BowserMasterAnnouncementWorker,
                NonPagedPool,
                DelayedWorkQueue,
                ReceiveFlags,
                FALSE                   // No response will be sent.
                );
}

VOID
BowserMasterAnnouncementWorker(
    IN PVOID Ctx
    )
{
    PPOST_DATAGRAM_CONTEXT Context = Ctx;
    PTRANSPORT Transport = Context->TransportName->Transport;
    PCHAR LocalMasterName = (PCHAR)((PMASTER_ANNOUNCEMENT_1)Context->Buffer)->MasterName;
    size_t cbLocalMasterName;
    PIRP Irp;
    NTSTATUS Status;

    PAGED_CODE();

    Irp = BowserDequeueQueuedIrp(&Transport->WaitForMasterAnnounceQueue);

    if (Irp != NULL) {
        PIO_STACK_LOCATION IrpSp;
        PLMDR_REQUEST_PACKET RequestPacket = Irp->AssociatedIrp.SystemBuffer;

        IrpSp = IoGetCurrentIrpStackLocation(Irp);

        cbLocalMasterName = strlen(LocalMasterName);

        if (0 == cbLocalMasterName) {

            // ensure we didn't get an invalid NULL announcement
            // see bug 440813
            // The request completed successfully, but the data is trash.
            //  - we won't fail the IRP (another one is posted immediately
            //    upon completion anyway), but not process further this one.

            Irp->IoStatus.Information = 0;
            Status = STATUS_SUCCESS;
        }
        else if ((cbLocalMasterName + 1) * sizeof(WCHAR) >
                 (IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
                    FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name))) {
            //
            // ensure there's enough buffer space to return name. If not,
            // return error.
            //

            Irp->IoStatus.Information = 0;

            Status = STATUS_BUFFER_TOO_SMALL;
        } else {

            //
            // All is well. Fill info.
            //

            OEM_STRING MasterName;
            UNICODE_STRING MasterNameU;

            RtlInitString(&MasterName, LocalMasterName);

            Status = RtlOemStringToUnicodeString(&MasterNameU, &MasterName, TRUE);

            if ( NT_SUCCESS(Status) ) {
                RequestPacket->Parameters.WaitForMasterAnnouncement.MasterNameLength = MasterNameU.Length;

                RtlCopyMemory(RequestPacket->Parameters.WaitForMasterAnnouncement.Name, MasterNameU.Buffer, MasterNameU.Length);

                RequestPacket->Parameters.WaitForMasterAnnouncement.Name[MasterNameU.Length/sizeof(WCHAR)] = UNICODE_NULL;

                Irp->IoStatus.Information = FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name)+MasterNameU.Length + sizeof(UNICODE_NULL);

                RtlFreeUnicodeString(&MasterNameU);

                Status = STATUS_SUCCESS;
            }
        }

        BowserCompleteRequest(Irp, Status);

    }

    BowserDereferenceTransportName(Context->TransportName);
    BowserDereferenceTransport(Transport);

    InterlockedDecrement( &BowserPostedDatagramCount );
    FREE_POOL(Context);

}


NTSTATUS
TimeoutFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{

    PAGED_CODE();

    //
    //  Perform an unprotected early out to prevent our calling into
    //  discardable code section during the scavenger.  Since the discardable
    //  code section is <4K, touching the code would have the effect of
    //  bringing the entire page into memory, which is a waste - since the
    //  scavenger runs every 30 seconds, this would cause the discardable
    //  code section to be a part of the browsers working set.
    //

    if (BowserIsIrpQueueEmpty(&Transport->FindMasterQueue)) {
        return STATUS_SUCCESS;
    }

    BowserTimeoutQueuedIrp(&Transport->FindMasterQueue, BowserFindMasterTimeout);

    return STATUS_SUCCESS;
}

VOID
BowserTimeoutFindMasterRequests(
    VOID
    )
{
    PAGED_CODE();

    BowserForEachTransport(TimeoutFindMasterRequests, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowname.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowname.h

Abstract:

    This module defines the name related structures for the NT datagram browser

Author:

    Larry Osterman (LarryO) 1-Jun-1990

Revision History:

    4-Sep-1991  LarryO

        Created

--*/

#ifndef _BOWNAME_
#define _BOWNAME_

struct _TRANSPORT;

typedef struct _BOWSER_NAME {
    CSHORT Signature;
    CSHORT Size;
    ULONG ReferenceCount;
    LIST_ENTRY GlobalNext;
    LIST_ENTRY NameChain;
    UNICODE_STRING Name;                // Text version of this name
    DGRECEIVER_NAME_TYPE NameType;      // Type of this name.
} BOWSER_NAME, *PBOWSER_NAME;


typedef
NTSTATUS
(*PNAME_ENUM_ROUTINE) (
    IN PBOWSER_NAME Name,
    IN OUT PVOID Context
    );

NTSTATUS
BowserForEachName (
    IN PNAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserAllocateName(
    IN PUNICODE_STRING NameToAdd,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN struct _TRANSPORT *Transport OPTIONAL,
    IN PDOMAIN_INFO DomainInfo
    );

NTSTATUS
BowserDeleteName(
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserDeleteNameByName(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType
    );

VOID
BowserReferenceName(
    IN PBOWSER_NAME Name
    );

VOID
BowserDereferenceName(
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserDeleteNameAddresses(
    IN PBOWSER_NAME Name
    );

PBOWSER_NAME
BowserFindName (
    IN PUNICODE_STRING NameToFind,
    IN DGRECEIVER_NAME_TYPE NameType
    );

NTSTATUS
BowserEnumerateNamesInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN struct _TRANSPORT *Transport,
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
BowserpInitializeNames(
    VOID
    );

VOID
BowserpUninitializeNames(
    VOID
    );

#endif  // _BOWNAME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowmastr.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowmastr.h

Abstract:

    This module implements all of the master browser related routines for the
    NT browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#ifndef _BOWMASTR_
#define _BOWMASTR_

typedef struct _QUEUED_GET_BROWSER_REQUEST {
    LIST_ENTRY Entry;
    ULONG Token;
    USHORT RequestedCount;
    USHORT ClientNameLength;
    LARGE_INTEGER TimeReceived;
#if DBG
    LARGE_INTEGER TimeQueued;
    LARGE_INTEGER TimeQueuedToBrowserThread;
#endif
    WCHAR  ClientName[1];
} QUEUED_GET_BROWSER_REQUEST, *PQUEUED_GET_BROWSER_REQUEST;


NTSTATUS
BowserBecomeMaster(
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserMasterFindMaster(
    IN PTRANSPORT Transport,
    IN PREQUEST_ELECTION_1 ElectionRequest,
    IN ULONG BytesAvailable
    );

VOID
BowserNewMaster(
    IN PTRANSPORT Transport,
    IN PUCHAR MasterName
    );

VOID
BowserCompleteFindMasterRequests(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING MasterName,
    IN NTSTATUS Status
    );

DATAGRAM_HANDLER(
    BowserMasterAnnouncement
    );

VOID
BowserTimeoutFindMasterRequests(
    VOID
    );


#endif // _BOWMASTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowpub.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bowser.h

Abstract:

    This module is the main header file for the NT redirector file
    system.

Author:

    Darryl Havens (darrylh) 29-Jun-1989
    Larry Osterman (larryo) 06-May-1991


Revision History:


--*/


#ifndef _BOWPUB_
#define _BOWPUB_

struct _BOWSER_FS_DEVICE_OBJECT;

extern
struct _BOWSER_FS_DEVICE_OBJECT *
BowserDeviceObject;

NTSTATUS
BowserDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
BowserUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#include "fsddisp.h"

#endif // _BOWPUB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowsecur.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bowipx.h

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Eyal Schwartz (EyalS) 9-Dec-1998

Revision History:


--*/

#ifndef _BOWSECUR_
#define _BOWSECUR_

extern
SECURITY_DESCRIPTOR
*g_pBowSecurityDescriptor;


NTSTATUS
BowserInitializeSecurity(
    IN      PDEVICE_OBJECT      pDevice
    );

BOOLEAN
BowserSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    );



#endif          // _BOWSECUR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowname.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowname.c

Abstract:

    This module implements all of the routines to manage the NT bowser name
    manipulation routines

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct _ENUM_NAMES_CONTEXT {
    PDGRECEIVE_NAMES OutputBuffer;
    PDGRECEIVE_NAMES NextOutputBuffer;
    PVOID OutputBufferEnd;
    ULONG OutputBufferSize;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    ULONG_PTR OutputBufferDisplacement;
} ENUM_NAMES_CONTEXT, *PENUM_NAMES_CONTEXT;

typedef struct _ADD_TRANSPORT_NAME_CONTEXT {
    LIST_ENTRY ListHead;
    UNICODE_STRING NameToAdd;
    DGRECEIVER_NAME_TYPE NameType;
} ADD_TRANSPORT_NAME_CONTEXT, *PADD_TRANSPORT_NAME_CONTEXT;

typedef struct _ADD_TRANSPORT_NAME_STRUCTURE {
    LIST_ENTRY Link;
    HANDLE ThreadHandle;
    PTRANSPORT Transport;
    UNICODE_STRING NameToAdd;
    DGRECEIVER_NAME_TYPE NameType;
    NTSTATUS Status;
} ADD_TRANSPORT_NAME_STRUCTURE, *PADD_TRANSPORT_NAME_STRUCTURE;


NTSTATUS
AddTransportName(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );


VOID
AsyncCreateTransportName(
    IN PVOID Ctx
    );

NTSTATUS
WaitForAddNameOperation(
    IN PADD_TRANSPORT_NAME_CONTEXT Context
    );

NTSTATUS
BowserDeleteNamesInDomain(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING Name OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType
    );

NTSTATUS
BowserDeleteNamesWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

NTSTATUS
EnumerateNamesTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

NTSTATUS
EnumerateNamesTransportNameWorker(
    IN PTRANSPORT_NAME TransportName,
    IN OUT PVOID Ctx
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserAllocateName)
#pragma alloc_text(PAGE, BowserAddDefaultNames)
#pragma alloc_text(PAGE, BowserDeleteDefaultDomainNames)
#pragma alloc_text(PAGE, AddTransportName)
#pragma alloc_text(PAGE, AsyncCreateTransportName)
#pragma alloc_text(PAGE, WaitForAddNameOperation)
#pragma alloc_text(PAGE, BowserDeleteNameByName)
#pragma alloc_text(PAGE, BowserDereferenceName)
#pragma alloc_text(PAGE, BowserReferenceName)
#pragma alloc_text(PAGE, BowserForEachName)
#pragma alloc_text(PAGE, BowserDeleteName)
#pragma alloc_text(PAGE, BowserDeleteNamesInDomain)
#pragma alloc_text(PAGE, BowserDeleteNamesWorker)
#pragma alloc_text(PAGE, BowserFindName)
#pragma alloc_text(PAGE, BowserEnumerateNamesInDomain)
#pragma alloc_text(PAGE, EnumerateNamesTransportWorker)
#pragma alloc_text(PAGE, EnumerateNamesTransportNameWorker)
#pragma alloc_text(INIT, BowserpInitializeNames)
#pragma alloc_text(PAGE, BowserpUninitializeNames)
#endif

NTSTATUS
BowserAllocateName(
    IN PUNICODE_STRING NameToAdd,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport OPTIONAL,
    IN PDOMAIN_INFO DomainInfo OPTIONAL
    )
/*++

Routine Description:

    This routine creates a browser name

Arguments:

    NameToAdd - Netbios name to add to one or more transports

    NameType - Type of the added name

    Transport - if specified, the name is added to this transport.
        If not specified, the name is added to all transports in the domain.

    DomainInfo - Specifies the emulated domain to add the name to.
        If not specified, the name is added to the specified transport.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PBOWSER_NAME NewName=NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    OEM_STRING OemName;
    BOOLEAN ResourceLocked = FALSE;

    PAGED_CODE();

	//
	// If the passed name is not a valid unicode string, return error
	//
	if ( !BowserValidUnicodeString(NameToAdd) ) {
		Status = STATUS_INVALID_PARAMETER;
		goto ReturnStatus;
	}

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    ResourceLocked = TRUE;

    //
    // If the name doesn't already exist,
    //  allocate one and fill it in.
    //

    NewName = BowserFindName(NameToAdd, NameType);

    if (NewName == NULL) {

        NewName = ALLOCATE_POOL( PagedPool,
                                 sizeof(BOWSER_NAME) +
                                    NameToAdd->Length+sizeof(WCHAR),
                                 POOL_BOWSERNAME);

        if (NewName == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

            goto ReturnStatus;
        }

        NewName->Signature = STRUCTURE_SIGNATURE_BOWSER_NAME;

        NewName->Size = sizeof(BOWSER_NAME);

        // This reference matches the one FindName would have done
        // above had it succeeded.
        NewName->ReferenceCount = 1;

        InitializeListHead(&NewName->NameChain);

        NewName->NameType = NameType;

        InsertHeadList(&BowserNameHead, &NewName->GlobalNext);

        NewName->Name.Buffer = (LPWSTR)(NewName+1);
        NewName->Name.MaximumLength = NameToAdd->Length + sizeof(WCHAR);
        RtlCopyUnicodeString(&NewName->Name, NameToAdd);

        //
        //  Null terminate the name in the buffer just in case.
        //

        NewName->Name.Buffer[NewName->Name.Length/sizeof(WCHAR)] = L'\0';

        //
        //  Uppercase the name.
        //

        Status = RtlUpcaseUnicodeStringToOemString(&OemName, &NewName->Name, TRUE);

        if (!NT_SUCCESS(Status)) {
            goto ReturnStatus;
        }

        Status = RtlOemStringToUnicodeString(&NewName->Name, &OemName, FALSE);

        RtlFreeOemString(&OemName);
        if (!NT_SUCCESS(Status)) {
            goto ReturnStatus;
        }
    }


    if (ARGUMENT_PRESENT(Transport)) {

        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        ResourceLocked = FALSE;

        Status = BowserCreateTransportName(Transport, NewName);
    } else {
        ADD_TRANSPORT_NAME_CONTEXT context;

        context.NameToAdd = *NameToAdd;
        context.NameType = NameType;

        InitializeListHead(&context.ListHead);

        Status = BowserForEachTransportInDomain( DomainInfo, AddTransportName, &context);

        //
        //  Since we will reference this name and transport while we
        //  are processing the list, we want to release the database resource
        //  now.
        //

        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        ResourceLocked = FALSE;

        if (!NT_SUCCESS(Status)) {
            WaitForAddNameOperation(&context);
            goto ReturnStatus;
        }

        Status = WaitForAddNameOperation(&context);

    }

ReturnStatus:

    if (ResourceLocked) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    if (!NT_SUCCESS(Status)) {

        //
        //  Delete this transport.
        //

        if (NewName != NULL) {

            if (!ARGUMENT_PRESENT(Transport)) {

                //
                //  Clean out any names that we may have added already.
                //

                BowserDeleteNamesInDomain( DomainInfo, &NewName->Name, NewName->NameType );
            }

        }

    }

    if (NewName != NULL) {
        BowserDereferenceName(NewName);
    }

    return Status;

}

NTSTATUS
BowserAddDefaultNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
/*++

Routine Description:

    Add the default names for a newly created transport.

    Add the ComputerName<00>, Domain<00>, Domain<1C>, and other domains.

    All of the newly added names are added in parallel to increase performance.

Arguments:

    Transport - The names are added to this transport.

    Context - If specified, a pointer to the UNICODE_STRING structure specifying
        the domain name to register.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    NTSTATUS Status;
    NTSTATUS TempStatus;

    PLIST_ENTRY NameEntry;

    ADD_TRANSPORT_NAME_CONTEXT AddNameContext;
    PDOMAIN_INFO DomainInfo = Transport->DomainInfo;

    UNICODE_STRING EmulatedComputerName;
    UNICODE_STRING EmulatedDomainName;

    PAGED_CODE();


    //
    // Build the domain name and computer name to add.
    //

    EmulatedComputerName = DomainInfo->DomUnicodeComputerName;

    if ( Context == NULL ) {
        EmulatedDomainName = DomainInfo->DomUnicodeDomainName;
    } else {
        EmulatedDomainName = *((PUNICODE_STRING)Context);
    }

    //
    // Initialize the queue of threads
    //

    InitializeListHead(&AddNameContext.ListHead);

    //
    // Add the computer<00> name
    //

    AddNameContext.NameToAdd = EmulatedComputerName;
    AddNameContext.NameType = ComputerName;

    Status = AddTransportName( Transport, &AddNameContext);

    if ( !NT_SUCCESS(Status) ) {
        goto ReturnStatus;
    }

    //
    // Add the domain<00> name
    //

    AddNameContext.NameToAdd = EmulatedDomainName;
    AddNameContext.NameType = PrimaryDomain;

    Status = AddTransportName( Transport, &AddNameContext);

    if ( !NT_SUCCESS(Status) ) {
        goto ReturnStatus;
    }

    //
    // Add the domain<1C> name
    //

    if (BowserData.IsLanmanNt) {
        AddNameContext.NameToAdd = EmulatedDomainName;
        AddNameContext.NameType = DomainName;

        Status = AddTransportName( Transport, &AddNameContext);

        if ( !NT_SUCCESS(Status) ) {
            goto ReturnStatus;
        }
    }

    //
    // Add each of the OtherDomain<00> names
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    for (NameEntry = BowserNameHead.Flink;
         NameEntry != &BowserNameHead ;
         NameEntry = NameEntry->Flink) {

        PBOWSER_NAME Name = CONTAINING_RECORD(NameEntry, BOWSER_NAME, GlobalNext);

        //
        // Only add the OtherDomains
        //

        if ( Name->NameType == OtherDomain ) {
            AddNameContext.NameToAdd = Name->Name;
            AddNameContext.NameType = OtherDomain;

            Status = AddTransportName( Transport, &AddNameContext);

            if ( !NT_SUCCESS(Status) ) {
                ExReleaseResourceLite(&BowserTransportDatabaseResource);
                goto ReturnStatus;
            }
        }

    }
    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    Status = STATUS_SUCCESS;


ReturnStatus:

    //
    // Wait for any started threads to complete.
    //

    TempStatus = WaitForAddNameOperation(&AddNameContext);

    if ( NT_SUCCESS(Status) ) {
        Status = TempStatus;
    }

    return Status;

}

NTSTATUS
BowserDeleteDefaultDomainNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )

/*++

Routine Description:

    Worker routine to re-add all of the default names for the transport.

    This routine will be called when the domain is renamed.  All of the previous
    default names should be removed and the new default names should be added.

Arguments:

    Transport - Transport to add the names on.

    Context - Pointer to UNICODE_STRING identifying the domain name to remove

Return Value:

    NTSTATUS - Status of resulting operation.

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING NameToRemove = (PUNICODE_STRING) Context;
    PAGED_CODE();

    //
    // This is a cleanup operation.  Don't fail if we can't remove the name.
    //
    (VOID) BowserDeleteTransportNameByName( Transport, NameToRemove, PrimaryDomain );
    (VOID) BowserDeleteTransportNameByName( Transport, NameToRemove, DomainName );

    return STATUS_SUCCESS;
}

NTSTATUS
WaitForAddNameOperation(
    IN PADD_TRANSPORT_NAME_CONTEXT Context
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS LocalStatus;

    PAGED_CODE();

    while (!IsListEmpty(&Context->ListHead)) {
        PLIST_ENTRY Entry;
        PADD_TRANSPORT_NAME_STRUCTURE addNameStruct;

        Entry = RemoveHeadList(&Context->ListHead);
        addNameStruct = CONTAINING_RECORD(Entry, ADD_TRANSPORT_NAME_STRUCTURE, Link);

        //
        //  We need to call the Nt version of this API, since we only have
        //  the handle to the thread.
        //
        //  Also note that we call the Nt version of the API.  This works
        //  because we are running in the FSP, and thus PreviousMode is Kernel.
        //

        LocalStatus = ZwWaitForSingleObject(addNameStruct->ThreadHandle,
                                    FALSE,
                                    NULL);

        ASSERT (NT_SUCCESS(LocalStatus));

        LocalStatus = ZwClose(addNameStruct->ThreadHandle);

        ASSERT (NT_SUCCESS(LocalStatus));

        //
        //  We've waited for this name to be added, now check its status.
        //

        if (!NT_SUCCESS(addNameStruct->Status)) {
            status = addNameStruct->Status;
        }

        FREE_POOL(addNameStruct);
    }

    //
    //  If we were able to successfully add all the names, then Status will
    //  still be STATUS_SUCCESS, however if any of the addnames failed,
    //  Status will be set to the status of whichever one of them failed.
    //

    return status;

}
NTSTATUS
AddTransportName(
    IN PTRANSPORT Transport,
    IN PVOID Ctx
    )
{
    PADD_TRANSPORT_NAME_CONTEXT context = Ctx;
    PADD_TRANSPORT_NAME_STRUCTURE addNameStructure;
    NTSTATUS status;
    PAGED_CODE();

    addNameStructure = ALLOCATE_POOL(PagedPool, sizeof(ADD_TRANSPORT_NAME_STRUCTURE), POOL_ADDNAME_STRUCT);

    if (addNameStructure == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    addNameStructure->ThreadHandle = NULL;

    addNameStructure->Transport = Transport;

    if ( Transport )
    {
        // reference transport so it doesn't get deleted under us.
        BowserReferenceTransport(Transport);
    }

    addNameStructure->NameToAdd = context->NameToAdd;
    addNameStructure->NameType = context->NameType;

    status = PsCreateSystemThread(&addNameStructure->ThreadHandle,
                                    THREAD_ALL_ACCESS,
                                    NULL,
                                    NULL,
                                    NULL,
                                    AsyncCreateTransportName,
                                    addNameStructure);

    if (!NT_SUCCESS(status)) {

        if ( Transport )
        {
            // dereference transport upon failure
            BowserDereferenceTransport(Transport);
        }

        FREE_POOL(addNameStructure);
        return status;
    }

    InsertTailList(&context->ListHead, &addNameStructure->Link);

    return STATUS_SUCCESS;

}

VOID
AsyncCreateTransportName(
    IN PVOID Ctx
    )
{
    PADD_TRANSPORT_NAME_STRUCTURE context = Ctx;

    PAGED_CODE();

    context->Status = BowserAllocateName(
                          &context->NameToAdd,
                          context->NameType,
                          context->Transport,
                          NULL );

    if ( context->Transport )
    {
        // referenced in calling AddTransportName()
        BowserDereferenceTransport(context->Transport);
    }
    //
    //  We're all done with this thread, terminate now.
    //

    PsTerminateSystemThread(STATUS_SUCCESS);

}


NTSTATUS
BowserDeleteNameByName(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING NameToDelete,
    IN DGRECEIVER_NAME_TYPE NameType
    )

/*++

Routine Description:

    This routine deletes a browser name

Arguments:

    IN PBOWSER_NAME Name - Supplies a transport structure describing the
                                transport address object to be created.


Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PBOWSER_NAME Name = NULL;
    NTSTATUS Status;

    PAGED_CODE();
//    DbgBreakPoint();


    //
    // If the caller is deleting a specific name,
    //  ensure it exists.
    //

    if ( NameToDelete != NULL && NameToDelete->Length != 0 ) {
        Name = BowserFindName(NameToDelete, NameType);

        if (Name == NULL) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    //
    //  If there are still any names associated with this name,
    //  delete them.
    //

    Status = BowserDeleteNamesInDomain( DomainInfo, NameToDelete, NameType );

    //
    //  Remove the reference from the FindName.
    //

    if ( Name != NULL ) {
        BowserDereferenceName(Name);
    }

    return(Status);
}

VOID
BowserDereferenceName (
    IN PBOWSER_NAME Name
    )
{
    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    Name->ReferenceCount -= 1;

    if (Name->ReferenceCount == 0) {
        BowserDeleteName(Name);
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

}


VOID
BowserReferenceName (
    IN PBOWSER_NAME Name
    )
{
    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    Name->ReferenceCount += 1;

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

}


NTSTATUS
BowserForEachName (
    IN PNAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the names and call back the enum
    routine provided with each names.

Arguments:

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY NameEntry, NextEntry;
    PBOWSER_NAME Name = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (NameEntry = BowserNameHead.Flink ;
        NameEntry != &BowserNameHead ;
        NameEntry = NextEntry) {

        Name = CONTAINING_RECORD(NameEntry, BOWSER_NAME, GlobalNext);

        BowserReferenceName(Name);

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        Status = (Routine)(Name, Context);

        if (!NT_SUCCESS(Status)) {
            BowserDereferenceName(Name);

            return Status;
        }

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        NextEntry = Name->GlobalNext.Flink;

        BowserDereferenceName(Name);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}


NTSTATUS
BowserDeleteName(
    IN PBOWSER_NAME Name
    )
/*++

Routine Description:

    This routine deletes a browser name

Arguments:

    IN PBOWSER_NAME Name - Supplies a transport structure describing the
                                transport address object to be created.


Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PAGED_CODE();
    RemoveEntryList(&Name->GlobalNext);

    FREE_POOL(Name);

    return STATUS_SUCCESS;
}

NTSTATUS
BowserDeleteNamesInDomain(
    IN PDOMAIN_INFO DomainInfo,
    IN PUNICODE_STRING Name OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType
    )
/*++

Routine Description:

    This routine deletes all the transport names associated with a browser name

Arguments:

    DomainInfo - Identifies the emulated domain to have the specified names removed.

    Name - Specifies the transport name to delete.
        If not specified, all names of the specified name type are deleted.

    NameType - Specifies the name type of the name.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/
{
    NTSTATUS Status;
    BOWSER_NAME BowserName;

    PAGED_CODE();

    BowserName.Name = *Name;
    BowserName.NameType = NameType;

    Status = BowserForEachTransportInDomain( DomainInfo, BowserDeleteNamesWorker, &BowserName );

    return(Status);
}

NTSTATUS
BowserDeleteNamesWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserDeleteNamesInDomain.

    Delete all the specified name for the specified transport.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PBOWSER_NAME Name = (PBOWSER_NAME) Ctx;
    // Note the caller doesn't pass a real PBOWSER_NAME.

    PAGED_CODE();

    //
    // Delete all the specified names for the specified transport.
    //

    Status = BowserDeleteTransportNameByName( Transport, &Name->Name, Name->NameType );

    return Status;

}

PBOWSER_NAME
BowserFindName (
    IN PUNICODE_STRING NameToFind,
    IN DGRECEIVER_NAME_TYPE NameType
    )
/*++

Routine Description:

    This routine scans the bowser name database to find a particular bowser name

Arguments:

    NameToFind - Supplies the name to find.

    NameType - Type of name to find


Return Value:

    PBOWSER_NAME - Returns the name found.

--*/
{
    PLIST_ENTRY NameEntry;
    PBOWSER_NAME Name;
    NTSTATUS Status;
    OEM_STRING OemName;
    UNICODE_STRING UpcasedName;

    PAGED_CODE();

	//
	// If the passed name is not a valid unicode string, return NULL
	//
	if ( !BowserValidUnicodeString(NameToFind) ) {
		return NULL;
	}

	//
    //  Uppercase the name.
    //

    Status = RtlUpcaseUnicodeStringToOemString(&OemName, NameToFind, TRUE);

    if (!NT_SUCCESS(Status)) {
        return NULL;
    }

    Status = RtlOemStringToUnicodeString(&UpcasedName, &OemName, TRUE);

    RtlFreeOemString(&OemName);
    if (!NT_SUCCESS(Status)) {
        return NULL;
    }


    //
    // Loop through the list of names finding this one.
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    Name = NULL;
    for (NameEntry = BowserNameHead.Flink ;
        NameEntry != &BowserNameHead ;
        NameEntry = NameEntry->Flink) {

        Name = CONTAINING_RECORD(NameEntry, BOWSER_NAME, GlobalNext);

        if ( Name->NameType == NameType &&
             RtlEqualUnicodeString( &Name->Name, &UpcasedName, FALSE ) ) {

            Name->ReferenceCount += 1;
            break;

        }

        Name = NULL;

    }

    RtlFreeUnicodeString( &UpcasedName );
    ExReleaseResourceLite(&BowserTransportDatabaseResource);
    return Name;

}


NTSTATUS
BowserEnumerateNamesInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN PTRANSPORT Transport,
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement
    )
/*++

Routine Description:

    This routine will enumerate all the names currently registered by any
    transport.

Arguments:

    DomainInfo - Emulated domain the names are to be enumerated for.
    Transport - Transport names are registered on
            NULL - Any transport.
    OutputBuffer - Buffer to fill with name info.
    OutputBufferSize - Filled in with size of buffer.
    EntriesRead - Filled in with the # of entries returned.
    TotalEntries - Filled in with the total # of entries.
    TotalBytesNeeded - Filled in with the # of bytes needed.

Return Value:

    None.

--*/

{
    PVOID              OutputBufferEnd;
    NTSTATUS           Status;
    ENUM_NAMES_CONTEXT Context;
    PVOID              TempOutputBuffer;

    PAGED_CODE();

    TempOutputBuffer = ALLOCATE_POOL(PagedPool,OutputBufferLength,POOL_NAME_ENUM_BUFFER);
    if (TempOutputBuffer == NULL) {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }

    OutputBufferEnd = (PCHAR)TempOutputBuffer+OutputBufferLength;

    Context.EntriesRead = 0;
    Context.TotalEntries = 0;
    Context.TotalBytesNeeded = 0;

    try {
        Context.OutputBufferSize = OutputBufferLength;
        Context.NextOutputBuffer = Context.OutputBuffer = (PDGRECEIVE_NAMES) TempOutputBuffer;
        Context.OutputBufferDisplacement = (ULONG_PTR)((PCHAR)TempOutputBuffer - ((PCHAR)OutputBuffer - OutputBufferDisplacement));
        Context.OutputBufferEnd = OutputBufferEnd;

//        DbgPrint("Enumerate Names: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
//            TempOutputBuffer, OutputBufferLength, OutputBufferEnd);

        if ( Transport == NULL ) {
            Status = BowserForEachTransportInDomain(DomainInfo, EnumerateNamesTransportWorker, &Context);
        } else {
            Status = EnumerateNamesTransportWorker( Transport, &Context);
        }

        *EntriesRead = Context.EntriesRead;
        *TotalEntries = Context.TotalEntries;
        *TotalBytesNeeded = Context.TotalBytesNeeded;

        // Copy the fixed data
        RtlCopyMemory( OutputBuffer,
                       TempOutputBuffer,
                       (ULONG)(((LPBYTE)Context.NextOutputBuffer)-((LPBYTE)Context.OutputBuffer)) );

        // Copy the strings
        RtlCopyMemory( ((LPBYTE)OutputBuffer)+(ULONG)(((LPBYTE)Context.OutputBufferEnd)-((LPBYTE)Context.OutputBuffer)),
                       Context.OutputBufferEnd,
                       (ULONG)(((LPBYTE)OutputBufferEnd)-((LPBYTE)Context.OutputBufferEnd)) );

        if (*EntriesRead == *TotalEntries) {
            try_return(Status = STATUS_SUCCESS);
        } else {
            try_return(Status = STATUS_MORE_ENTRIES);
        }


try_exit:NOTHING;
    } except (BR_EXCEPTION) {

        Status = GetExceptionCode();
    }

    if (TempOutputBuffer != NULL ) {
       FREE_POOL(TempOutputBuffer);
    }

    return Status;

}

NTSTATUS
EnumerateNamesTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserEnumerateNamesInDomain.

    This routine is executed for each transport in the domain.
    It simply calls EnumerateNamesTransportNameWorker for each transport name on the
        transport.

Arguments:

    Transport - Transport whose names are to be added to the context.

    Ctx - Cumulative list of names.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;

    Status = BowserForEachTransportName( Transport, EnumerateNamesTransportNameWorker, Ctx);
    return Status;
}

NTSTATUS
EnumerateNamesTransportNameWorker(
    IN PTRANSPORT_NAME TransportName,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for EnumerateNamesTransportWorker.

    It is called for each of the transport name for each transport in the domain.
    It returns that name (supressing duplicates) in the buffer described in the context.

Arguments:

    TransportName - Transport name to be added to the context.

    Ctx - Cumulative list of names.

Return Value:

    Status of the operation.

--*/
{
    PENUM_NAMES_CONTEXT Context = Ctx;
    PBOWSER_NAME Name = TransportName->PagedTransportName->Name;
    ULONG i;

    PAGED_CODE();

    //
    // Skip Nameless transports
    //
    if ( Name->Name.Length == 0) {
        // Adding an empty name to the list can result w/ AV
        // on client end (see bug 377078).
        return ( STATUS_SUCCESS );
    }

    //
    // Check to see if this name has been packed yet.
    //
    //

    for ( i=0; i<Context->EntriesRead; i++ ) {

        if ( Name->NameType == Context->OutputBuffer[i].Type ) {
            UNICODE_STRING RelocatedString = Context->OutputBuffer[i].DGReceiverName;

            RelocatedString.Buffer = (LPWSTR)
                ((LPBYTE)RelocatedString.Buffer + Context->OutputBufferDisplacement);

            if ( RtlEqualUnicodeString( &RelocatedString, &Name->Name, FALSE ) ) {
                return(STATUS_SUCCESS);
            }
        }

    }

    //
    // This names hasn;t been packed yet,
    //  pack it.
    //

    Context->TotalEntries += 1;

    if ((ULONG_PTR)Context->OutputBufferEnd - (ULONG_PTR)Context->NextOutputBuffer >
                sizeof(DGRECEIVE_NAMES)+Name->Name.Length) {

        PDGRECEIVE_NAMES NameEntry = Context->NextOutputBuffer;

        Context->NextOutputBuffer += 1;
        Context->EntriesRead += 1;

        NameEntry->DGReceiverName = Name->Name;

        BowserPackNtString( &NameEntry->DGReceiverName,
                            Context->OutputBufferDisplacement,
                            (PCHAR)Context->NextOutputBuffer,
                            (PCHAR *)&Context->OutputBufferEnd
                            );

        NameEntry->Type = Name->NameType;

    }

    Context->TotalBytesNeeded += sizeof(DGRECEIVE_NAMES)+Name->Name.Length;


    return(STATUS_SUCCESS);

}

NTSTATUS
BowserpInitializeNames(
    VOID
    )
{
    PAGED_CODE();
    InitializeListHead(&BowserNameHead);

    return STATUS_SUCCESS;
}

VOID
BowserpUninitializeNames(
    VOID
    )
{
    PAGED_CODE();
    ASSERT (IsListEmpty(&BowserNameHead));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowser.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bowser.h

Abstract:

    This module is the main header file for the NT redirector file
    system.

Author:

    Darryl Havens (darrylh) 29-Jun-1989
    Larry Osterman (larryo) 06-May-1991


Revision History:


--*/


#ifndef _BOWSER_
#define _BOWSER_

#ifndef BOWSERDBG
#define BOWSERDBG 0
#endif
//
//
//  Global include file definitions
//
//


#include <ntddbrow.h>                   // Browser FSCTL defs.

#include <lmcons.h>                     // Include global network constants

#include <tdikrnl.h>

#include <tdi.h>

#include <smbtypes.h>
#include <smb.h>
#include <smbtrans.h>
#include <smbgtpt.h>
#include <smbipx.h>

#include <hostannc.h>                   // Host announcement structures.
#include <lmserver.h>



//
//
//  Separate include file definitions
//
//
//

#include "bowpub.h"                     // Public bowser definitions.

#include "bowtypes.h"                   // Bowser structure type definitions.

#include <bowdbg.h>                      // Debugging definitions.

#include "workque.h"                    // FSP/FSD worker queue functions.

#include "bowdata.h"                    // Global data variables.

#include "fspdisp.h"                    // Global FSP dispatch definitions.

#include "fsddisp.h"                    // Global FSP dispatch definitions.

#include "domain.h"                     // Domain emulation specific definitions.

#include "bowname.h"                    // Bowser name structure definitions.

#include "bowtimer.h"                   // Timer related routines

#include "bowtdi.h"                     // Bowser TDI specific definitions.

#include "receive.h"                    // Bowser receive engine code.

#include "announce.h"                   // Announcement related stuff

#include "mailslot.h"                   // Mailslot specific routines

#include "bowelect.h"                   // Election routines

#include "bowmastr.h"                   // Master related routines.

#include "bowbackp.h"                   // Backup related routines.

#include "brsrvlst.h"                   // Definitions for browser server list.

#include "bowipx.h"

#include "bowsecur.h"                   // definitions for security

#include <wchar.h>                      // CRT wide character routines

#include "..\rdbss\smb.mrx\ntbowsif.h"

//++
//
//  VOID
//  BowserCompleteRequest (
//      IN PIRP Irp,
//      IN NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.  It does the necessary raise and lower of IRQL.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--

#define BowserCompleteRequest(IRP,STATUS) {       \
    (IRP)->IoStatus.Status = (STATUS);            \
    if (NT_ERROR((STATUS))) {                     \
        (IRP)->IoStatus.Information = 0;          \
    }                                             \
    IoCompleteRequest( (IRP), 0 );                \
}



//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
      #define try_return(S)  { S; goto try_exit; }
//

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise.  It is followed by two macros for setting and clearing
//  flags
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

#ifdef  _M_IX86
#define INLINE _inline
#else
#define INLINE
#endif

_inline BOOLEAN
IsZeroTerminated(
    IN PSZ String,
    IN ULONG MaximumStringLength
    )
//  Return TRUE if a zero terminator exists on String.
{
    while ( MaximumStringLength-- ) {
        if (*String++ == 0 ) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
BowserStopProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    );

BOOLEAN
BowserMapUsersBuffer (
    IN PIRP Irp,
    OUT PVOID *UserBuffer,
    IN ULONG Length
    );

NTSTATUS
BowserLockUsersBuffer (
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

NTSTATUS
BowserConvertType3IoControlToType2IoControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

ULONG
BowserPackNtString(
    PUNICODE_STRING string,
    ULONG_PTR BufferDisplacement,
    PCHAR dataend,
    PCHAR * laststring
    );

ULONG
BowserPackUnicodeString(
    IN OUT PWSTR * string,     // pointer by reference: string to be copied.
    IN ULONG StringLength,      // Length of this string.
    IN ULONG_PTR OutputBufferDisplacement,  // Amount to subtract from output buffer
    IN PVOID dataend,          // pointer to end of fixed size data.
    IN OUT PVOID * laststring  // pointer by reference: top of string data.
    );

ULONG
BowserTimeUp(
    VOID
    );

ULONG
BowserRandom(
    ULONG MaxValue
    );

VOID
_cdecl
BowserWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    );

VOID
BowserLogIllegalName(
    IN NTSTATUS NtStatusCode,
    IN PVOID NameBuffer,
    IN USHORT NameBufferSize
    );

VOID
BowserInitializeFsd(
    VOID
    );

VOID
BowserReferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    );

VOID
BowserDereferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    );
VOID
BowserInitializeDiscardableCode(
    VOID
    );

VOID
BowserUninitializeDiscardableCode(
    VOID
    );

NTSTATUS
BowserStartElection(
    IN PTRANSPORT Transport
    );

BOOL
BowserValidUnicodeString(
	IN PUNICODE_STRING Str
	);

#endif // _BOWSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowsecur.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the NtDeviceIoControlFile API's for the NT datagram
receiver (bowser).


Author:

    Eyal Schwartz (EyalS) Dec-9-1998

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop


//
// Extern defined from #include <ob.h>.
// Couldn't include ob.h due to redefinition conflicts. We had attempted to change ntos\makefil0
// so as to include it in ntsrv.h, but decided we shouldn't expose it. This does the job.
//

NTSTATUS
ObGetObjectSecurity(
    IN PVOID Object,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PBOOLEAN MemoryAllocated
    );

VOID
ObReleaseObjectSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN MemoryAllocated
    );



// defines //

// pool tag
#define BOW_SECURITY_POOL_TAG           ( (ULONG)'seLB' )

// local prototypes //
NTSTATUS
BowserBuildDeviceAcl(
    OUT PACL *DeviceAcl
    );
NTSTATUS
BowserCreateAdminSecurityDescriptor(
    IN      PDEVICE_OBJECT      pDevice
    );




#ifdef  ALLOC_PRAGMA
#pragma alloc_text(SECUR, BowserBuildDeviceAcl)
#pragma alloc_text(SECUR, BowserCreateAdminSecurityDescriptor)
#pragma alloc_text(SECUR, BowserInitializeSecurity)
#pragma alloc_text(SECUR, BowserSecurityCheck )
#endif


SECURITY_DESCRIPTOR
*g_pBowSecurityDescriptor = NULL;





// function implementation //
NTSTATUS
BowserBuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators and LocalSystem
    principals full access. All other principals have no access.

    Lifted form \nt\private\ntos\afd\init.c!AfdBuildDeviceAcl()
Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid;
    PSID SystemSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );

    // SeEnableAccessToExports();

    AdminsSid = SeExports->SeAliasAdminsSid;
    SystemSid = SeExports->SeLocalSystemSid;

    AclLength = sizeof( ACL )                    +
                2 * sizeof( ACCESS_ALLOWED_ACE ) +
                RtlLengthSid( AdminsSid )         +
                RtlLengthSid( SystemSid )         -
                2 * sizeof( ULONG );

    NewAcl = ExAllocatePoolWithTag(
                 PagedPool,
                 AclLength,
                 BOW_SECURITY_POOL_TAG
                 );

    if (NewAcl == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status = RtlCreateAcl (NewAcl, AclLength, ACL_REVISION );

    if (!NT_SUCCESS( Status )) {
        ExFreePool(
            NewAcl
            );
        return( Status );
    }

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION,
                 AccessMask,
                 AdminsSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION,
                 AccessMask,
                 SystemSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    *DeviceAcl = NewAcl;

    return( STATUS_SUCCESS );

} // BowBuildDeviceAcl


NTSTATUS
BowserCreateAdminSecurityDescriptor(
    IN      PDEVICE_OBJECT      pDevice
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to Administrtors and LocalSystem. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.
    LIfted form \nt\private\ntos\afd\init.c!AfdCreateAdminSecurityDescriptor()

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  rawAcl = NULL;
    NTSTATUS              status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  BowSecurityDescriptor;
    ULONG                 BowSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR) &buffer;
    PSECURITY_DESCRIPTOR  localBowAdminSecurityDescriptor;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;


#if 1
//
// this is the way AFD gets the object SD (the preferred way).
//
    status = ObGetObjectSecurity(
                 pDevice,
                 &BowSecurityDescriptor,
                 &memoryAllocated
                 );

    if (!NT_SUCCESS(status)) {
        KdPrint((
            "Bowser: Unable to get security descriptor, error: %x\n",
            status
            ));
        ASSERT(memoryAllocated == FALSE);
        return(status);
    }
#else
    //
    // Get a pointer to the security descriptor from the our device object.
    // If we can't access ob api's due to include dependencies, we'll use it directly.
    // ** Need to verify it is legal (I doubt it)**
    // Need to dump this as soon as we can fix ntos\makefil0 to include ob.h in
    // the generated ntsrv.h

    //
    BowSecurityDescriptor = pDevice->SecurityDescriptor;

    if ( !BowSecurityDescriptor )
    {
        KdPrint((
            "Bowser: Unable to get security descriptor, error: %x\n",
            status
            ));
        return  STATUS_INVALID_SECURITY_DESCR;
    }
#endif


    //
    // Build a local security descriptor with an ACL giving only
    // administrators and system access.
    //
    status = BowserBuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        KdPrint(("Bowser: Unable to create Raw ACL, error: %x\n", status));
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
                localSecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );

    (VOID) RtlSetDaclSecurityDescriptor(
                localSecurityDescriptor,
                TRUE,
                rawAcl,
                FALSE
                );

    //
    // Make a copy of the Bow descriptor. This copy will be the raw descriptor.
    //
    BowSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                      BowSecurityDescriptor
                                      );

    localBowAdminSecurityDescriptor = ExAllocatePoolWithTag (
                                        PagedPool,
                                        BowSecurityDescriptorLength,
                                        BOW_SECURITY_POOL_TAG
                                        );

    if (localBowAdminSecurityDescriptor == NULL) {
        KdPrint(("Bowser: couldn't allocate security descriptor\n"));
        goto error_exit;
    }

    RtlMoveMemory(
        localBowAdminSecurityDescriptor,
        BowSecurityDescriptor,
        BowSecurityDescriptorLength
        );

    g_pBowSecurityDescriptor = localBowAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                 NULL,
                 &securityInformation,
                 localSecurityDescriptor,
                 &g_pBowSecurityDescriptor,
                 PagedPool,
                 IoGetFileObjectGenericMapping()
                 );

    if (!NT_SUCCESS(status)) {
        KdPrint(("Bowser: SeSetSecurity failed, %lx\n", status));
        ASSERT (g_pBowSecurityDescriptor==localBowAdminSecurityDescriptor);
        ExFreePool (g_pBowSecurityDescriptor);
        g_pBowSecurityDescriptor = NULL;
        goto error_exit;
    }

    if (g_pBowSecurityDescriptor!=localBowAdminSecurityDescriptor) {
        ExFreePool (localBowAdminSecurityDescriptor);
    }

    status = STATUS_SUCCESS;

error_exit:

#if 1
//
// see remark above
//
    ObReleaseObjectSecurity(
        BowSecurityDescriptor,
        memoryAllocated
        );
#endif

    if (rawAcl!=NULL) {
        ExFreePool(
            rawAcl
            );
    }

    return(status);
}




NTSTATUS
BowserInitializeSecurity(
    IN      PDEVICE_OBJECT      pDevice
    )
/*++

Routine Description (BowserInitializeSecurity):

    Initialize Bowser security.

    - Create default bowser security descriptor based on device sercurity

Arguments:

    device:  opened device


Return Value:




Remarks:
    None.


--*/
{

    NTSTATUS Status;

    if ( g_pBowSecurityDescriptor )
    {
        return STATUS_SUCCESS;
    }

    ASSERT(pDevice);

    Status =  BowserCreateAdminSecurityDescriptor ( pDevice );

    return Status;
}




BOOLEAN
BowserSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    )
/*++

Routine Description:

    Lifted as is from \\index1\src\nt\private\ntos\afd\create.c!AfdPerformSecurityCheck

    Compares security context of the endpoint creator to that
    of the administrator and local system.

    Note: This is currently called only on IOCTL Irps. IOCRTLs don't have a create security
    context (only creates...), thus we should always capture the security context rather
    then attempting to extract it from the IrpSp.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    SECURITY_SUBJECT_CONTEXT SubjectContext;
    PSECURITY_SUBJECT_CONTEXT pSubjectContext = &SubjectContext;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;

    PAGED_CODE();

    ASSERT (g_pBowSecurityDescriptor);

    //
    // Get security context from process.
    //

    SeCaptureSubjectContext(&SubjectContext);
    SeLockSubjectContext(pSubjectContext);

    //
    // Build access evaluation:
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();
    RtlMapGenericMask( &AccessMask, GenericMapping );


    //
    // AccessCheck test
    //
    accessGranted = SeAccessCheck(
                        g_pBowSecurityDescriptor,
                        pSubjectContext,
                        TRUE,
                        AccessMask,
                        0,
                        NULL,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );


    //
    // Verify consistency.
    //
#if DBG
    if (accessGranted) {
        ASSERT (NT_SUCCESS (*Status));
    }
    else {
        ASSERT (!NT_SUCCESS (*Status));
    }
#endif

    //
    // Unlock & Release security subject context
    //
    SeUnlockSubjectContext(pSubjectContext);
    SeReleaseSubjectContext(pSubjectContext);

    return accessGranted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowtimer.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtimer.c

Abstract:

    This module implements all of the timer related routines for the NT
    browser

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#pragma hdrstop


BOOL bEnableExceptionBreakpoint = FALSE;



VOID
BowserTimerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
BowserTimerDispatcher (
    IN PVOID Context
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserInitializeTimer)
#pragma alloc_text(PAGE4BROW, BowserUninitializeTimer)
#pragma alloc_text(PAGE4BROW, BowserStartTimer)
#pragma alloc_text(PAGE4BROW, BowserStopTimer)
#pragma alloc_text(PAGE4BROW, BowserTimerDispatcher)
#endif

LONG
BrExceptionFilter( EXCEPTION_POINTERS *    pException)
{
    //
    // Note: BrExceptionFilter is defined only for checked builds (ifdef DBG)
    //

    DbgPrint("[Browser] exception 0x%lx.\n", pException->ExceptionRecord->ExceptionCode );
    if ( bEnableExceptionBreakpoint &&
         pException->ExceptionRecord->ExceptionCode != STATUS_INSUFFICIENT_RESOURCES &&
         pException->ExceptionRecord->ExceptionCode != STATUS_WORKING_SET_QUOTA ) {
        DbgBreakPoint();
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
BowserInitializeTimer(
    IN PBOWSER_TIMER Timer
    )
{
    PAGED_CODE();

    KeInitializeTimer(&Timer->Timer);

    KeInitializeEvent(&Timer->TimerInactiveEvent, NotificationEvent, TRUE);

    KeInitializeSpinLock(&Timer->Lock);

    ExInitializeWorkItem(&Timer->WorkItem, BowserTimerDispatcher, Timer);

    Timer->AlreadySet = FALSE;
    Timer->Canceled = FALSE;
    Timer->SetAgain = FALSE;

    Timer->Initialized = TRUE;
}

VOID
BowserUninitializeTimer(
    IN PBOWSER_TIMER Timer
    )
/*++

Routine Description:
    Prepare the timer for being uninitialized.

Arguments:
    IN PBOWSER_TIMER Timer - Timer to stop

Return Value
    None.

--*/

{
    KIRQL OldIrql;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

    Timer->Initialized = FALSE;

    RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

    //
    //  First stop the timer.
    //

    BowserStopTimer(Timer);

    //
    //  Now wait to make sure that any the timer routine that is currently
    //  executing the timer completes.  This allows us to make sure that we
    //  never delete a transport while a timer routine is executing.
    //

    KeWaitForSingleObject(&Timer->TimerInactiveEvent, Executive, KernelMode, FALSE, NULL);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

}

//  Notes for stopping a timer
//  ==========================
//
//  Timers run through various states. During some of them they cannot be
//  cancelled.  In order to guarantee that we can reliably stop and start
//  timers, they can only be started or stopped at LOW_LEVEL (ie, not from
//  DPC_LEVEL.
//
//  If the timer is not running then StopTimer does nothing.
//
//  If queued inside the kernel timer package then KeCancelTimer will work
//  and the timer contents cleaned up.
//
//  If the kernel timer package has queued the dpc routine then KeCancelTimer
//  will fail. We can flag the timer as canceled. BowserTimerDispatcher will
//  cleanup the timer when it fires.
//


//  Notes for starting a timer
//  ==========================
//
//  If StartTimer is called on a clean timer then it sets the contents
//  appropriately and gives the timer to the kernel timer package.
//
//  If the timer is canceled but not cleaned up then StartTimer will update
//  the contents of the timer to show where the new TimerRoutine and TimerContext.
//  it will indicate that the timer is no longer canceled and is now SetAgain.
//
//  If the timer is already SetAgain then StartTimer will update the contents
//  of the timer to hold the new TimerRoutine and TimerContext.
//
//  When BowserTimerDispatcher is called on a SetAgain timer, it sets the timer
//  to its normal state and gives the timer to the kernel timer package.
//


BOOLEAN
BowserStartTimer(
    IN PBOWSER_TIMER Timer,
    IN ULONG MillisecondsToExpireTimer,
    IN PBOWSER_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    )
/*++

Routine Description:
    Set Timer to call TimerRoutine after MillisecondsToExpire. TimerRoutine
    is to be called at normal level.

Arguments:

    IN PBOWSER_TIMER Timer
    IN ULONG MillisecondsToExpireTimer
    IN PBOWSER_TIMER_ROUTINE TimerRoutine
    IN PVOID Context - Parameter to TimerRoutine

Return Value
    BOOLEAN - TRUE if timer set.

--*/
{
    LARGE_INTEGER Timeout;
    BOOLEAN ReturnValue;
    KIRQL OldIrql;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

    Timeout.QuadPart = (LONGLONG)MillisecondsToExpireTimer * (LONGLONG)(-10000);
//    Timeout = LiNMul(MillisecondsToExpireTimer, -10000);

    ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

    if (!Timer->Initialized) {
        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        return(FALSE);
    }

    dprintf(DPRT_TIMER, ("BowserStartTimer %lx, TimerRoutine %x.  Set to expire at %lx%lx (%ld/%ld ms)\n", Timer, TimerRoutine, Timeout.HighPart, Timeout.LowPart, -1 * Timeout.LowPart, MillisecondsToExpireTimer));

    //
    //  We shouldn't be able to start the timer while it is
    //  already running unless its also cancelled.
    //


    if (Timer->AlreadySet == TRUE) {

        if (Timer->Canceled) {

            //
            //  This timer has been canceled, but the canceled routine
            //  hasn't run yet.
            //
            //  Flag that the timer has been re-set, and return to
            //  the caller.  When the BowserTimerDispatch is finally
            //  executed, the new timer will be set.
            //

            Timer->Timeout = Timeout;

            Timer->TimerRoutine = TimerRoutine;

            Timer->SetAgain = TRUE;

            RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            return(TRUE);

        }

        InternalError(("Timer started without already being set"));

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        return(FALSE);

    }

    ASSERT (!Timer->Canceled);

    ASSERT (!Timer->SetAgain);

    Timer->Timeout = Timeout;

    Timer->TimerRoutine = TimerRoutine;

    Timer->TimerContext = Context;

    Timer->AlreadySet = TRUE;

    Timer->Canceled = FALSE;

    Timer->SetAgain = FALSE;

    //
    //  Set the inactive event to the not signalled state to indicate that
    //  there is timer activity outstanding.
    //

    KeResetEvent(&Timer->TimerInactiveEvent);

    //
    //  We are now starting the timer.  Initialize the DPC and
    //  set the timer.
    //

    KeInitializeDpc(&Timer->Dpc,
                    BowserTimerDpc,
                    Timer);

    ReturnValue = KeSetTimer(&Timer->Timer, Timeout, &Timer->Dpc);

    RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return ReturnValue;
}


VOID
BowserStopTimer(
    IN PBOWSER_TIMER Timer
    )
/*++

Routine Description:
    Stop the timer from calling the TimerRoutine.

Arguments:
    IN PBOWSER_TIMER Timer - Timer to stop

Return Value
    None.

--*/
{
    KIRQL OldIrql;

    //
    //  Do an unsafe test to see if the timer is already set, we can return.
    //

    if (!Timer->AlreadySet) {
        return;
    }

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    //  You can only stop a timer at LOW_LEVEL
    //

    ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

    ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

    dprintf(DPRT_TIMER, ("BowserStopTimer %lx\n", Timer));

    //
    //  If the timer isn't running, just early out.
    //

    if (!Timer->AlreadySet) {

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

        return;
    }

    Timer->Canceled = TRUE;

    if (!KeCancelTimer(&Timer->Timer)) {

        //
        //  The timer has already fired. It could be in the dpc queue or
        //  the work queue. The timer is marked as canceled.
        //

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

        return;
    }

    //
    //  The timer was still in the kernel timer package so we cancelled the
    //  timer completely. Return timer to initial state.
    //

    Timer->AlreadySet = FALSE;

    //
    //  The timer isn't canceled, so it can't be reset.
    //

    Timer->SetAgain = FALSE;

    Timer->Canceled = FALSE;

    KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);

    RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
//    DbgPrint("Cancel timer %lx complete\n", Timer);
}

VOID
BowserTimerDpc(
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:
    This routine is called when the timeout expires. It is called at Dpc level
    to queue a WorkItem to a system worker thread.

Arguments:

    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2

Return Value
    None.

--*/
{
    PBOWSER_TIMER Timer = Context;

    ASSERT (Dpc == &Timer->Dpc);

    //    DbgPrint("Timer %lx fired\n", Timer);

    //
    // Due to bug 245645 we need to queue in delayed worker queue rather then execute timed tasks.
    // OLD WAY: ExQueueWorkItem(&Timer->WorkItem, DelayedWorkQueue);
    //

    BowserQueueDelayedWorkItem( &Timer->WorkItem );


    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

}

VOID
BowserTimerDispatcher (
    IN PVOID Context
    )
/*++

Routine Description:

    Call the TimerRoutine and cleanup.

Arguments:

    IN PVOID Context - Original parameter supplied to BowserStartTimer

Return Value
    None.

--*/
{
    IN PBOWSER_TIMER Timer = Context;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    try {
        KIRQL OldIrql;
        PBOWSER_TIMER_ROUTINE RoutineToCall;
        PVOID ContextForRoutine;

        ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);

        //
        //  If the timer was uninitialized, return right away.
        //

        if (!Timer->Initialized) {

            dprintf(DPRT_TIMER, ("Timer %lx was uninitialized. Returning.\n", Timer));

            //
            //  Set the inactive event to the signalled state to indicate that
            //  the outstanding timer activity has completed.
            //

            KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);
            RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            return;
        }

        if (Timer->Canceled) {

            dprintf(DPRT_TIMER, ("Timer %lx was cancelled\n", Timer));

            //
            //  If the timer was reset, this indicates that the timer was
            //  canceled, but the timer was in the DPC (or executive worker)
            //  queue.  We want to re-run the timer routine.
            //

            if (Timer->SetAgain) {

                ASSERT (Timer->AlreadySet);

                Timer->SetAgain = FALSE;

                dprintf(DPRT_TIMER, ("Timer %lx was re-set. Re-setting timer\n", Timer));

                //
                //  We are now starting the timer.  Initialize the DPC and
                //  set the timer.
                //

                KeInitializeDpc(&Timer->Dpc,
                                BowserTimerDpc,
                                Timer);

                KeSetTimer(&Timer->Timer, Timer->Timeout, &Timer->Dpc);

                RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            } else {

                dprintf(DPRT_TIMER, ("Timer %lx was successfully canceled.\n", Timer));

                Timer->AlreadySet = FALSE;

                Timer->Canceled = FALSE;

                //
                //  Set the inactive event to the signalled state to indicate that
                //  the outstanding timer activity has completed.
                //

                KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);
                RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

            }

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            return;
        }

        ASSERT (Timer->AlreadySet);

        ASSERT (!Timer->SetAgain);

        Timer->AlreadySet = FALSE;

        dprintf(DPRT_TIMER, ("Timer %lx fired. Calling %lx\n", Timer, Timer->TimerRoutine));

        //
        //  We release the spinlock so save timer contents locally.
        //

        RoutineToCall = Timer->TimerRoutine;

        ContextForRoutine = Timer->TimerContext;

        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        RoutineToCall(ContextForRoutine);

        ACQUIRE_SPIN_LOCK(&Timer->Lock, &OldIrql);
        if ( !Timer->AlreadySet ) {
            KeSetEvent(&Timer->TimerInactiveEvent, IO_NETWORK_INCREMENT, FALSE);
        }
        RELEASE_SPIN_LOCK(&Timer->Lock, OldIrql);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    } except (BR_EXCEPTION) {
#if DBG
        KdPrint(("BOWSER: Timer routine %lx faulted: %X\n", Timer->TimerRoutine, GetExceptionCode()));
        DbgBreakPoint();
#else
        KeBugCheck(9999);
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowtimer.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowtimer.h

Abstract:

    This module declares definitions dealing with bowser timers.

Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/
#ifndef _BOWTIMER_
#define _BOWTIMER_

struct _TRANSPORT;

typedef
NTSTATUS
(*PBOWSER_TIMER_ROUTINE)(
    IN struct _TRANSPORT *Transport
    );

//  BOWSER_TIMER flags:
//      Canceled is TRUE when a timer is cancelled but is already in
//      the dpc queue.
//
//      AlreadySet is used to ensure we stop the timer before restarting it.
//
//      Reset is set to TRUE when a timer has been stopped and restarted while
//      in the dpc queue. The Lock is used to ensure ordered access.
//      Note: a timer can be stopped and reset multiple times before it gets
//      to the front of the dpc queue.
//

typedef struct _BOWSER_TIMER {
    KDPC                    Dpc;
    KTIMER                  Timer;
    KSPIN_LOCK              Lock;
    KEVENT                  TimerInactiveEvent;
    PBOWSER_TIMER_ROUTINE   TimerRoutine;
    PVOID                   TimerContext;
    LARGE_INTEGER           Timeout;
    WORK_QUEUE_ITEM         WorkItem;
    BOOLEAN                 AlreadySet;
    BOOLEAN                 Initialized;
    BOOLEAN                 Canceled;
    BOOLEAN                 SetAgain;

} BOWSER_TIMER, *PBOWSER_TIMER;

VOID
BowserInitializeTimer(
    IN PBOWSER_TIMER Timer
    );

VOID
BowserStopTimer (
    IN PBOWSER_TIMER Timer
    );

VOID
BowserUninitializeTimer(
    IN PBOWSER_TIMER Timer
    );

BOOLEAN
BowserStartTimer (
    IN PBOWSER_TIMER Timer,
    IN ULONG MillisecondsToExpireTimer,
    IN PBOWSER_TIMER_ROUTINE TimerExpirationRoutine,
    IN PVOID Context
    );

#endif // _BOWTIMER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowtypes.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtypes.h

Abstract:

    This module contains all of the structure signature definitions for the
    NT datagram browser

Author:

    Larry Osterman (LarryO) 06-May-1991

Revision History:

    06-May-1991 LarryO

        Created

--*/

#ifndef _BOWSERTYPES_
#define _BOWSERTYPES_

#define STRUCTURE_SIGNATURE_WORK_QUEUE          0x0001
#define STRUCTURE_SIGNATURE_TRANSPORT           0x0002
#define STRUCTURE_SIGNATURE_TRANSPORTNAME       0x0003
#define STRUCTURE_SIGNATURE_VIEW_BUFFER         0x0004
#define STRUCTURE_SIGNATURE_ANNOUNCE_ENTRY      0x0005
#define STRUCTURE_SIGNATURE_BOWSER_NAME         0x0006
#define STRUCTURE_SIGNATURE_MAILSLOT_BUFFER     0x0007
#define STRUCTURE_SIGNATURE_PAGED_TRANSPORT     0x0008
#define STRUCTURE_SIGNATURE_PAGED_TRANSPORTNAME 0x0009

#endif  // _BOWSERTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowtdi.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    bowtdi.c

Abstract:

    This module implements all of the routines that interface with the TDI
    transport for NT

Author:

    Larry Osterman (LarryO) 21-Jun-1990

Revision History:

    21-Jun-1990 LarryO

        Created

--*/


#include "precomp.h"
#include <isnkrnl.h>
#include <smbipx.h>
#include <nbtioctl.h>
#pragma hdrstop

typedef struct _ENUM_TRANSPORTS_CONTEXT {
    PVOID OutputBuffer;
    PVOID OutputBufferEnd;
    PVOID LastOutputBuffer;         //  Points to the last entry in the list.
    ULONG OutputBufferSize;
    ULONG EntriesRead;
    ULONG TotalEntries;
    ULONG TotalBytesNeeded;
    ULONG_PTR OutputBufferDisplacement;
} ENUM_TRANSPORTS_CONTEXT, *PENUM_TRANSPORTS_CONTEXT;

NTSTATUS
EnumerateTransportsWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

VOID
BowserFreeBrowserServerList (
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength
    );

ERESOURCE
BowserTransportDatabaseResource = {0};

//
// Code for tracking missing frees.
//

#define BR_ONE_D_STACK_SIZE 5
typedef struct _BrOneD {
    ULONG NameAdded;
    ULONG NameFreed;
    ULONG NameAddFailed;
    ULONG NameFreeFailed;
    ULONG NameAddStack[BR_ONE_D_STACK_SIZE];
    ULONG NameFreeStack[BR_ONE_D_STACK_SIZE];
} BR_ONE_D;
BR_ONE_D BrOneD;

//
//
//  Forward definitions of local routines.
//



NTSTATUS
BowserpTdiSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID TransportName
    );


NTSTATUS
BowserDetermineProviderInformation(
    IN PUNICODE_STRING TransportName,
    OUT PTDI_PROVIDER_INFO ProviderInfo,
    OUT PULONG IpSubnetNumber
    );

NTSTATUS
UnbindTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    );

NTSTATUS
BowserpTdiRemoveAddresses(
    IN PTRANSPORT Transport
    );

VOID
BowserDeleteTransport(
    IN PTRANSPORT Transport
    );

VOID
BowserpFreeTransport(
    IN PTRANSPORT Transport
    );



NTSTATUS
BowserSubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    );


NTSTATUS
BowserCompleteTdiRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CompleteSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    );

NTSTATUS
BowserEnableIpxDatagramSocket(
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserOpenNetbiosAddress(
    IN PPAGED_TRANSPORT_NAME PagedTransportName,
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    );

VOID
BowserCloseNetbiosAddress(
    IN PTRANSPORT_NAME TransportName
    );

VOID
BowserCloseAllNetbiosAddresses(
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserSendDatagram (
    IN PTRANSPORT Transport,
    IN PVOID RecipientAddress,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WaitForCompletion,
    IN PSTRING DestinationAddress OPTIONAL,
    IN BOOLEAN IsHostAnnouncment
    );

NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PUNICODE_STRING DeviceName,
    IN USHORT Socket
    );

NTSTATUS
BowserIssueTdiAction (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PVOID Action,
    IN ULONG ActionSize
    );

NTSTATUS
GetNetworkAddress (
    IN PTRANSPORT_NAME TransportName
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserTdiAllocateTransport)
#pragma alloc_text(PAGE, BowserUnbindFromAllTransports)
#pragma alloc_text(PAGE, UnbindTransportWorker)
#pragma alloc_text(PAGE, BowserFreeTransportByName)
#pragma alloc_text(PAGE, BowserTransportFlags)
#pragma alloc_text(PAGE, BowserEnumerateTransports)
#pragma alloc_text(PAGE, EnumerateTransportsWorker)
#pragma alloc_text(PAGE, BowserDereferenceTransport)
#pragma alloc_text(PAGE, BowserpTdiRemoveAddresses)
#pragma alloc_text(PAGE, BowserFindTransportName)
#pragma alloc_text(PAGE, BowserFreeTransportName)
#pragma alloc_text(PAGE, BowserDeleteTransport)
#pragma alloc_text(PAGE, BowserpFreeTransport)
#pragma alloc_text(PAGE, BowserpTdiSetEventHandler)
#pragma alloc_text(PAGE, BowserBuildTransportAddress)
#pragma alloc_text(PAGE, BowserUpdateProviderInformation)
#pragma alloc_text(PAGE, BowserDetermineProviderInformation)
#pragma alloc_text(PAGE, BowserFindTransport)
#pragma alloc_text(PAGE, BowserForEachTransport)
#pragma alloc_text(PAGE, BowserForEachTransportName)
#pragma alloc_text(PAGE, BowserDeleteTransportNameByName)
#pragma alloc_text(PAGE, BowserSubmitTdiRequest)
#pragma alloc_text(PAGE, BowserSendDatagram)
#pragma alloc_text(PAGE, BowserSendSecondClassMailslot)
#pragma alloc_text(PAGE, BowserSendRequestAnnouncement)
#pragma alloc_text(INIT, BowserpInitializeTdi)
#pragma alloc_text(PAGE, BowserpUninitializeTdi)
#pragma alloc_text(PAGE, BowserDereferenceTransportName)
#pragma alloc_text(PAGE, BowserEnableIpxDatagramSocket)
#pragma alloc_text(PAGE, BowserOpenNetbiosAddress)
#pragma alloc_text(PAGE, BowserCloseNetbiosAddress)
#pragma alloc_text(PAGE, BowserCloseAllNetbiosAddresses)
#pragma alloc_text(PAGE, OpenIpxSocket)
#pragma alloc_text(PAGE, BowserIssueTdiAction)

#pragma alloc_text(PAGE4BROW, BowserCompleteTdiRequest)
//#pragma alloc_text(PAGE4BROW, CompleteSendDatagram)
#endif

//
// Flag to indicate that a network isn't an IP network
//
#define BOWSER_NON_IP_SUBNET 0xFFFFFFFF


NTSTATUS
BowserTdiAllocateTransport (
    PUNICODE_STRING TransportName,
    PUNICODE_STRING EmulatedDomainName,
    PUNICODE_STRING EmulatedComputerName
    )

/*++

Routine Description:

    This routine will allocate a transport descriptor and bind the bowser
    to the transport.

Arguments:

    TransportName - Supplies the name of the transport provider

    EmulatedDomainName - Supplies the name of the domain being emulated

    EmulatedComputerName - Supplies the name of the computer in the emulated domain.


Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    PTRANSPORT NewTransport;
    BOOLEAN ResourceAcquired = FALSE;

    PAGED_CODE();

//    DbgBreakPoint();

    dlog(DPRT_TDI, ("%wZ: %wZ: BowserTdiAllocateTransport\n", EmulatedDomainName, TransportName));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    ResourceAcquired = TRUE;


    NewTransport = BowserFindTransport(TransportName, EmulatedDomainName );
    dprintf(DPRT_REF, ("Called Find transport %lx from BowserTdiAllocateTransport.\n", NewTransport));

    if (NewTransport == NULL) {
        PLIST_ENTRY NameEntry;
        PPAGED_TRANSPORT PagedTransport = NULL;
        PCHAR Where;
        ULONG PagedTransportSize;

        //
        // Allocate and initialize the constant parts of the transport structure.
        //

        NewTransport = ALLOCATE_POOL(NonPagedPool, sizeof(TRANSPORT), POOL_TRANSPORT);

        if (NewTransport == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

            goto ReturnStatus;
        }

        RtlZeroMemory( NewTransport, sizeof(TRANSPORT) );

        NewTransport->Signature = STRUCTURE_SIGNATURE_TRANSPORT;
        NewTransport->Size = sizeof(TRANSPORT);

        //
        // One reference for the rest of this procedure.
        //
        // We increment it later when we insert it in the global list.
        //
        NewTransport->ReferenceCount = 1;


        ExInitializeResourceLite(&NewTransport->BrowserServerListResource);

        KeInitializeEvent(&NewTransport->GetBackupListComplete, NotificationEvent, TRUE);

        ExInitializeResourceLite(&NewTransport->Lock);

        BowserInitializeIrpQueue(&NewTransport->BecomeBackupQueue);

        BowserInitializeIrpQueue(&NewTransport->BecomeMasterQueue);

        BowserInitializeIrpQueue(&NewTransport->FindMasterQueue);

        BowserInitializeIrpQueue(&NewTransport->WaitForMasterAnnounceQueue);

        BowserInitializeIrpQueue(&NewTransport->WaitForNewMasterNameQueue);

        BowserInitializeIrpQueue(&NewTransport->ChangeRoleQueue);

        BowserInitializeTimer(&NewTransport->ElectionTimer);

        BowserInitializeTimer(&NewTransport->FindMasterTimer);

        INITIALIZE_ANNOUNCE_DATABASE(NewTransport);



        //
        // Allocate and initialize the constant parts of the paged transport structure.
        //

        PagedTransportSize =sizeof(PAGED_TRANSPORT) +
                            max(sizeof(TA_IPX_ADDRESS), sizeof(TA_NETBIOS_ADDRESS)) +
                            sizeof(WCHAR) +     // alignment
                            (LM20_CNLEN+1)*sizeof(WCHAR) +
                            TransportName->Length + sizeof(WCHAR);


        PagedTransport = NewTransport->PagedTransport =
            ALLOCATE_POOL(PagedPool, PagedTransportSize, POOL_PAGED_TRANSPORT);

        if (PagedTransport == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;

            goto ReturnStatus;
        }

        RtlZeroMemory( PagedTransport, PagedTransportSize );

        PagedTransport->NonPagedTransport = NewTransport;


        PagedTransport->Signature = STRUCTURE_SIGNATURE_PAGED_TRANSPORT;
        PagedTransport->Size = sizeof(PAGED_TRANSPORT);

        InitializeListHead(&PagedTransport->GlobalNext);
        InitializeListHead(&PagedTransport->NameChain);

        PagedTransport->Role = None;

        PagedTransport->IpSubnetNumber = BOWSER_NON_IP_SUBNET;

        PagedTransport->DisabledTransport = TRUE;
        PagedTransport->PointToPoint = FALSE;


        RtlInitializeGenericTable(&PagedTransport->AnnouncementTable,
                            BowserCompareAnnouncement,
                            BowserAllocateAnnouncement,
                            BowserFreeAnnouncement,
                            NULL);

        RtlInitializeGenericTable(&PagedTransport->DomainTable,
                            BowserCompareAnnouncement,
                            BowserAllocateAnnouncement,
                            BowserFreeAnnouncement,
                            NULL);

        InitializeListHead(&PagedTransport->BackupBrowserList);

        PagedTransport->NumberOfBackupServerListEntries = 0;


        // Put the MasterBrowserAddress at the end of the allocated buffer
        Where = (PCHAR)(PagedTransport+1);
        PagedTransport->MasterBrowserAddress.Buffer = Where;
        PagedTransport->MasterBrowserAddress.MaximumLength = max(sizeof(TA_IPX_ADDRESS),
                                                                 sizeof(TA_NETBIOS_ADDRESS));
        Where += PagedTransport->MasterBrowserAddress.MaximumLength;


        // Put the MasterName at the end of the allocated buffer
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        PagedTransport->MasterName.Buffer = (LPWSTR) Where;
        PagedTransport->MasterName.MaximumLength = (LM20_CNLEN+1)*sizeof(WCHAR);
        Where += PagedTransport->MasterName.MaximumLength;


        // Put the TransportName at the end of the allocated buffer
        PagedTransport->TransportName.Buffer = (LPWSTR) Where;
        PagedTransport->TransportName.MaximumLength = TransportName->Length + sizeof(WCHAR);
        RtlCopyUnicodeString(&PagedTransport->TransportName, TransportName);
        Where += PagedTransport->TransportName.MaximumLength;


        //
        // Make this transport a part of a domain.
        //

        NewTransport->DomainInfo = BowserCreateDomain( EmulatedDomainName, EmulatedComputerName );

        if ( NewTransport->DomainInfo == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto ReturnStatus;
        }

        //
        // Get info from the provider
        //  (e.g., RAS, Wannish, DatagramSize)

        Status= BowserUpdateProviderInformation( PagedTransport );

        if (!NT_SUCCESS(Status)) {
            goto ReturnStatus;
        }

        PagedTransport->Flags = 0;


        //
        //  We ignore any and all errors that occur when we open the IPX socket.
        //


        //
        // Open the IPX mailslot socket.
        //

        Status = OpenIpxSocket(
                    &PagedTransport->IpxSocketHandle,
                    &NewTransport->IpxSocketFileObject,
                    &NewTransport->IpxSocketDeviceObject,
                    &PagedTransport->TransportName,
                    SMB_IPX_MAILSLOT_SOCKET
                    );

        if ( NT_SUCCESS(Status) ) {
            PagedTransport->Flags |= DIRECT_HOST_IPX;
            // We'll use type 20 packets to increase the reach of broadcasts
            // so don't treat this as a wannish protocol.
            PagedTransport->Wannish = FALSE;
        }

        //
        // Create the names for this transport.
        //  (Only if the caller asked us to)
        //
        // Being in the global list constitutes a reference.
        //

        InsertTailList(&BowserTransportHead, &PagedTransport->GlobalNext);
        BowserReferenceTransport( NewTransport );

        //
        // The names are added asynchronously in other threads that require this
        // resource.
        //
        if ( ResourceAcquired ) {
            ExReleaseResourceLite(&BowserTransportDatabaseResource);
            ResourceAcquired = FALSE;
        }

        Status = BowserAddDefaultNames( NewTransport, NULL );

        if ( !NT_SUCCESS(Status) ) {
            goto ReturnStatus;
        }


        //
        // Start receiving broadcasts on IPX now that the names exist.
        //

        if ( PagedTransport->Flags & DIRECT_HOST_IPX ) {
            //
            // Acquire the lock while referencing IpxSocket*
            ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
            ResourceAcquired = TRUE;
            BowserEnableIpxDatagramSocket(NewTransport);
        }

        //
        // Notify services that this transport is now bound
        //

        BowserSendPnp( NlPnpTransportBind,
                       NULL,    // All hosted domains
                       &PagedTransport->TransportName,
                       BowserTransportFlags(PagedTransport) );

    }

    Status = STATUS_SUCCESS;

ReturnStatus:

    if ( ResourceAcquired ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    if (!NT_SUCCESS(Status)) {

        //
        //  Delete the transport.
        //

        if ( NewTransport != NULL ) {
            // Remove the global reference if in global list
            BowserDeleteTransport (NewTransport);
        }

    }

    // Remove the local reference
    if ( NewTransport != NULL ) {
        BowserDereferenceTransport( NewTransport );
    }

    return Status;
}

NTSTATUS
BowserUnbindFromAllTransports(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserForEachTransport(UnbindTransportWorker, NULL);

#if DBG
    if (NT_SUCCESS(Status)) {
        ASSERT (IsListEmpty(&BowserTransportHead));
    }
#endif
    return Status;
}


NTSTATUS
UnbindTransportWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserUnbindFromAllTransports.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    //  Dereference the reference caused by the transport bind.
    //

    BowserDeleteTransport(Transport);

    //
    //  Return success.  We're done.
    //

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(Ctx);
}




NTSTATUS
BowserFreeTransportByName (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName
    )

/*++

Routine Description:

    This routine will deallocate an allocated transport

Arguments:

    TransportName - Supplies a pointer to the name of the transport to free

    EmulatedDomainName - Name of the emulated domain whose transport is to be freed

Return Value:

    None.

--*/
{
    PTRANSPORT Transport;

    PAGED_CODE();
    dlog(DPRT_TDI, ("%wZ: %wZ: BowserFreeTransportByName: Remove transport\n", EmulatedDomainName, TransportName));

    Transport = BowserFindTransport(TransportName, EmulatedDomainName );
    dprintf(DPRT_REF, ("Called Find transport %lx from BowserFreeTransportByName.\n", Transport));

    if (Transport == NULL) {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Remove the reference from the binding.
    //

    BowserDeleteTransport(Transport);

    //
    //  Remove the reference from the FindTransport.
    //

    BowserDereferenceTransport(Transport);

    return STATUS_SUCCESS;
}


NTSTATUS
BowserEnumerateTransports (
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement)
/*++

Routine Description:

    This routine will enumerate the servers in the bowsers current announcement
    table.

Arguments:

    IN ULONG ServerTypeMask - Mask of servers to return.
    IN PUNICODE_STRING DomainName OPTIONAL - Domain to filter (all if not specified)
    OUT PVOID OutputBuffer - Buffer to fill with server info.
    IN  ULONG OutputBufferSize - Filled in with size of buffer.
    OUT PULONG EntriesRead - Filled in with the # of entries returned.
    OUT PULONG TotalEntries - Filled in with the total # of entries.
    OUT PULONG TotalBytesNeeded - Filled in with the # of bytes needed.

Return Value:

    None.

--*/

{
    PVOID OutputBufferEnd;
    NTSTATUS Status;
    ENUM_TRANSPORTS_CONTEXT Context;
    PDOMAIN_INFO DomainInfo = NULL;
    PAGED_CODE();

    OutputBufferEnd = (PCHAR)OutputBuffer+OutputBufferLength;

    Context.EntriesRead = 0;
    Context.TotalEntries = 0;
    Context.TotalBytesNeeded = 0;

    try {
        Context.OutputBufferSize = OutputBufferLength;
        Context.OutputBuffer = OutputBuffer;
        Context.OutputBufferDisplacement = OutputBufferDisplacement;
        Context.OutputBufferEnd = OutputBufferEnd;
        Context.LastOutputBuffer = OutputBuffer;

        dlog(DPRT_FSCTL, ("Enumerate Transports: Buffer: %lx, BufferSize: %lx, BufferEnd: %lx\n",
            OutputBuffer, OutputBufferLength, OutputBufferEnd));

        try {
            //
            // Find the primary domain.
            //
            // This call is intended to return the actual transport names and not the
            // network structure which are duplicated for each emulated domain.
            //

            DomainInfo = BowserFindDomain( NULL );
            // Failure case handled below

            //
            // Enumerate the transports.
            //
            if ( DomainInfo != NULL ) {
                Status = BowserForEachTransportInDomain( DomainInfo, EnumerateTransportsWorker, &Context);
            }

            *EntriesRead = Context.EntriesRead;
            *TotalEntries = Context.TotalEntries;
            *TotalBytesNeeded = Context.TotalBytesNeeded;

            if (*EntriesRead != 0) {
                ((PLMDR_TRANSPORT_LIST )Context.LastOutputBuffer)->NextEntryOffset = 0;
            }

            dlog(DPRT_FSCTL, ("TotalEntries: %lx EntriesRead: %lx, TotalBytesNeeded: %lx\n", *TotalEntries, *EntriesRead, *TotalBytesNeeded));

            if (*EntriesRead == *TotalEntries) {
                try_return(Status = STATUS_SUCCESS);
            } else {
                try_return(Status = STATUS_MORE_ENTRIES);
            }
try_exit:NOTHING;
        } finally {
            if ( DomainInfo != NULL ) {
                BowserDereferenceDomain( DomainInfo );
            }
        }
    }
    except ( BR_EXCEPTION ) {
        Status = GetExceptionCode();
    }

    return Status;

}

ULONG
BowserTransportFlags(
    IN PPAGED_TRANSPORT PagedTransport
    )
/*++

Routine Description:

    Return the user mode transport flags for this transport.

Arguments:

    PageTransport - Transport to return the flags for.

Return Value:


    The appropriate of the following flags:
        LMDR_TRANSPORT_WANNISH
        LMDR_TRANSPORT_RAS
        LMDR_TRANSPORT_IPX

--*/
{
    ULONG TransportFlags = 0;
    PAGED_CODE();

    if (PagedTransport->Wannish) {
        TransportFlags |= LMDR_TRANSPORT_WANNISH;
    }

    if (PagedTransport->IsPrimaryDomainController) {
        TransportFlags |= LMDR_TRANSPORT_PDC;
    }

    if (PagedTransport->PointToPoint) {
        TransportFlags |= LMDR_TRANSPORT_RAS;
    }

    if (PagedTransport->Flags & DIRECT_HOST_IPX) {
        TransportFlags |= LMDR_TRANSPORT_IPX;
    }

    return TransportFlags;
}


NTSTATUS
EnumerateTransportsWorker(
    IN PTRANSPORT Transport,
    IN OUT PVOID Ctx
    )
/*++

Routine Description:

    This routine is the worker routine for BowserEnumerateTransports.

    It is called for each of the serviced transports in the bowser and
    returns the size needed to enumerate the servers received on each transport.

Arguments:

    None.

Return Value:


    None.

--*/
{
    PENUM_TRANSPORTS_CONTEXT Context        = Ctx;
    PPAGED_TRANSPORT         PagedTransport = Transport->PagedTransport;
    ULONG                    SizeNeeded     = sizeof(LMDR_TRANSPORT_LIST);

    PAGED_CODE();

    SizeNeeded += PagedTransport->TransportName.Length+sizeof(WCHAR);
    SizeNeeded =  ROUND_UP_COUNT(SizeNeeded,ALIGN_DWORD);

    Context->TotalEntries += 1;

    if ((ULONG_PTR)Context->OutputBufferEnd - (ULONG_PTR)Context->OutputBuffer > SizeNeeded) {
        PLMDR_TRANSPORT_LIST TransportEntry = (PLMDR_TRANSPORT_LIST)Context->OutputBuffer;

        Context->LastOutputBuffer = Context->OutputBuffer;

        Context->EntriesRead += 1;

        RtlCopyMemory(TransportEntry->TransportName, PagedTransport->TransportName.Buffer, PagedTransport->TransportName.Length+sizeof(WCHAR));

        //
        //  Null terminate the transport name.
        //

        TransportEntry->TransportName[PagedTransport->TransportName.Length/sizeof(WCHAR)] = '\0';

        TransportEntry->TransportNameLength = PagedTransport->TransportName.Length;

        TransportEntry->Flags |= BowserTransportFlags( PagedTransport );

        TransportEntry->NextEntryOffset = SizeNeeded;
        (PUCHAR)(Context->OutputBuffer) += SizeNeeded;
    }

    Context->TotalBytesNeeded += SizeNeeded;
    return(STATUS_SUCCESS);

}

VOID
BowserReferenceTransport(
    IN PTRANSPORT Transport
    )
{

    InterlockedIncrement(&Transport->ReferenceCount);
    dprintf(DPRT_REF, ("Reference transport %lx.  Count now %lx\n", Transport, Transport->ReferenceCount));

}

VOID
BowserDereferenceTransport(
    IN PTRANSPORT Transport
    )
{
    LONG Result;
    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);


    if (Transport->ReferenceCount == 0) {
        InternalError(("Transport Reference Count mismatch\n"));
    }

    Result = InterlockedDecrement(&Transport->ReferenceCount);


    dlog(DPRT_REF, ("Dereference transport %lx.  Count now %lx\n", Transport, Transport->ReferenceCount));

    if (Result == 0) {
        //
        //  And free up the transport itself.
        //

        BowserpFreeTransport(Transport);
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

}



NTSTATUS
BowserCreateTransportName (
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    )

/*++

Routine Description:

    This routine creates a transport address object.

Arguments:

    IN PTRANSPORT Transport - Supplies a transport structure describing the
                                transport address object to be created.


Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PTRANSPORT_NAME TransportName = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = NULL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    BOOLEAN ResourceAcquired = FALSE;

    PAGED_CODE();
    ASSERT(Transport->Signature == STRUCTURE_SIGNATURE_TRANSPORT);

    dlog(DPRT_TDI,
         ("%s: %ws: BowserCreateTransportName.  Name %wZ (%ld)\n",
         Transport->DomainInfo->DomOemDomainName,
         PagedTransport->TransportName.Buffer,
         &Name->Name,
         Name->NameType ));

    //
    //  Link the transport_name structure into the transport list.
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    ResourceAcquired = TRUE;

    TransportName = BowserFindTransportName(Transport, Name);

    if (TransportName != NULL) {

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        return(STATUS_SUCCESS);
    }

#ifdef notdef
    //
    // Simply don't allocate certain names if the transport is disabled
    //

    if ( PagedTransport->DisabledTransport ) {
        if ( Name->NameType == PrimaryDomainBrowser ) {
            ExReleaseResourceLite(&BowserTransportDatabaseResource);
            return STATUS_SUCCESS;
        }
    }
#endif // notdef

    // s.b. assertion that we're attached to the system process
    // ASSERT (IoGetCurrentProcess() == BowserFspProcess);

    //
    //  Allocate a structure to refer to this name on the transport
    //

    TransportName = ALLOCATE_POOL(NonPagedPool, sizeof(TRANSPORT_NAME) +
                                                max(sizeof(TA_NETBIOS_ADDRESS),
                                                    sizeof(TA_IPX_ADDRESS)), POOL_TRANSPORTNAME);

    if (TransportName == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto error_cleanup;
    }

    TransportName->PagedTransportName = PagedTransportName =
                                    ALLOCATE_POOL(PagedPool,
                                                  sizeof(PAGED_TRANSPORT_NAME),
                                                  POOL_PAGED_TRANSPORTNAME);

    if (PagedTransportName == NULL) {
        FREE_POOL( TransportName );
        TransportName = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;

        goto error_cleanup;
    }

    TransportName->Signature = STRUCTURE_SIGNATURE_TRANSPORTNAME;

    TransportName->Size = sizeof(TRANSPORT_NAME);

    TransportName->PagedTransportName = PagedTransportName;

    // This TransportName is considered to be referenced by the transport via
    // Transport->PagedTransport->NameChain.  The Name->NameChain isn't
    // considered to be a reference.
    //
    // The second reference is a local reference for the lifetime of this routine.
    //
    TransportName->ReferenceCount = 2;

    PagedTransportName->NonPagedTransportName = TransportName;

    PagedTransportName->Signature = STRUCTURE_SIGNATURE_PAGED_TRANSPORTNAME;

    PagedTransportName->Size = sizeof(PAGED_TRANSPORT_NAME);

    PagedTransportName->Name = Name;

    BowserReferenceName(Name);

    TransportName->Transport = Transport;

    // Don't reference the Transport.  When the transport is unbound, we'll
    // make sure all the transport names are removed first.
    // BowserReferenceTransport(Transport);

    PagedTransportName->Handle = NULL;

    TransportName->FileObject = NULL;

    TransportName->DeviceObject = NULL;

    InsertHeadList(&Transport->PagedTransport->NameChain, &PagedTransportName->TransportNext);

    InsertHeadList(&Name->NameChain, &PagedTransportName->NameNext);

    //
    //  If this is an OTHERDOMAIN, we want to process host announcements for
    //  the domain, if it isn't, we want to wait until we become a master.
    //

    if (Name->NameType == OtherDomain) {
		TransportName->ProcessHostAnnouncements = TRUE;
    } else {
        TransportName->ProcessHostAnnouncements = FALSE;
    }

    //
    //  If this name is one of our special names, we want to remember it in
    //  the transport block.
    //

    switch (Name->NameType) {
    case ComputerName:
        Transport->ComputerName = TransportName;
        break;

    case PrimaryDomain:
        //
        // During domain rename we can temporarily have two primary names assigned.
        //  keep track of both names.
        //
        if ( Transport->PrimaryDomain != NULL ) {
//            ASSERT( Transport->AltPrimaryDomain == NULL );
            Transport->AltPrimaryDomain = Transport->PrimaryDomain;
        }
        Transport->PrimaryDomain = TransportName;
        break;


    case MasterBrowser:
        Transport->MasterBrowser = TransportName;
        break;

    case BrowserElection:
        Transport->BrowserElection = TransportName;
        break;

    case PrimaryDomainBrowser:
        PagedTransport->IsPrimaryDomainController = TRUE;

        //
        // Notify services we are now a PDC.
        //

        BowserSendPnp(
            NlPnpNewRole,
            &Transport->DomainInfo->DomUnicodeDomainName,
            &Transport->PagedTransport->TransportName,
            BowserTransportFlags(Transport->PagedTransport) );

        break;
    }

    TransportName->TransportAddress.Buffer = (PCHAR)(TransportName+1);
    TransportName->TransportAddress.MaximumLength = max(sizeof(TA_NETBIOS_ADDRESS),
                                                        sizeof(TA_IPX_ADDRESS));

    //
    //  Figure out what this name is, so we can match against it when
    //  a datagram is received.
    //

    Status = BowserBuildTransportAddress(&TransportName->TransportAddress, &Name->Name, Name->NameType, Transport);

    if (!NT_SUCCESS(Status)) {
        goto error_cleanup;
    }

    TransportName->NameType = (CHAR)Name->NameType;

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    ResourceAcquired = FALSE;

    //
    //  On non direct host IPX transports, we need to add the name now.
    //

    if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
        Status = BowserOpenNetbiosAddress(PagedTransportName, Transport, Name);

        if (!NT_SUCCESS(Status)) {
            goto error_cleanup;
        }
    }

error_cleanup:
    if ( !NT_SUCCESS(Status) ) {
        dlog(DPRT_TDI,
             ("%s: %ws: BowserCreateTransportName fail.  Name %wZ (%ld) Status:%lx\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer,
             &Name->Name,
             Name->NameType,
             Status ));

        //
        // Remove Transport->PagedTransport->NameChain reference
        //  (Unless another routine already has done that behind our back)
        //
        if (TransportName != NULL) {
            if ( PagedTransportName->TransportNext.Flink != NULL ) {
                BowserDereferenceTransportName(TransportName);
            }
        }
    }

    // Remove the local reference
    if (TransportName != NULL) {
        BowserDereferenceTransportName(TransportName);
    }

    if (ResourceAcquired) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }



    return Status;
}

NTSTATUS
BowserOpenNetbiosAddress(
    IN PPAGED_TRANSPORT_NAME PagedTransportName,
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    )
{
    NTSTATUS Status;
    PFILE_FULL_EA_INFORMATION EABuffer = NULL;
    PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle = NULL;
    PFILE_OBJECT FileObject = NULL;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE( );

    try {
        //
        //  Now create the address object for this name.
        //

        EABuffer = ALLOCATE_POOL(PagedPool,
                                 sizeof(FILE_FULL_EA_INFORMATION)-1 +
                                        TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                        max(sizeof(TA_NETBIOS_EX_ADDRESS), sizeof(TA_NETBIOS_ADDRESS)),
                                 POOL_EABUFFER);


        if (EABuffer == NULL) {
            try_return(Status = STATUS_INSUFFICIENT_RESOURCES)

        }

        EABuffer->NextEntryOffset = 0;
        EABuffer->Flags = 0;
        EABuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;

        RtlCopyMemory(EABuffer->EaName, TdiTransportAddress, EABuffer->EaNameLength+1);

        EABuffer->EaValueLength = sizeof(TA_NETBIOS_ADDRESS);

        ASSERT (TransportName->TransportAddress.Length == sizeof(TA_NETBIOS_ADDRESS));
        RtlCopyMemory( &EABuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH+1],
                       TransportName->TransportAddress.Buffer,
                       EABuffer->EaValueLength );

        dlog(DPRT_TDI,
            ("%s: %ws: Create endpoint of %wZ (%ld) @(%lx)\n",
            Transport->DomainInfo->DomOemDomainName,
            Transport->PagedTransport->TransportName.Buffer,
            &PagedTransportName->Name->Name,
            PagedTransportName->Name->NameType,
            TransportName));

        InitializeObjectAttributes (&AddressAttributes,
                                            &Transport->PagedTransport->TransportName,    // Name
                                            OBJ_CASE_INSENSITIVE,// Attributes
                                            NULL,           // RootDirectory
                                            NULL);          // SecurityDescriptor

        Status = IoCreateFile( &Handle, // Handle
                                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                    &AddressAttributes, // Object Attributes
                                    &IoStatusBlock, // Final I/O status block
                                    NULL,           // Allocation Size
                                    FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                    FILE_SHARE_READ,// Sharing attributes
                                    FILE_OPEN_IF,   // Create disposition
                                    0,              // CreateOptions
                                    EABuffer,       // EA Buffer
                                    FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName) +
                                    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                    sizeof(TA_NETBIOS_ADDRESS), // EA length
                                    CreateFileTypeNone,
                                    NULL,
                                    IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                                    IO_CHECK_CREATE_PARAMETERS);// But double check parameter consistancy

        FREE_POOL(EABuffer);

        EABuffer = NULL;

        if (!NT_SUCCESS(Status)) {

            try_return(Status);

        }

        if (!NT_SUCCESS(Status = IoStatusBlock.Status)) {

            try_return(Status);

        }

        //
        //  Obtain a referenced pointer to the file object.
        //
        Status = ObReferenceObjectByHandle (
                                    Handle,
                                    0,
                                    *IoFileObjectType,
                                    KernelMode,
                                    (PVOID *)&FileObject,
                                    NULL
                                    );

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }



        //
        // Get another reference that lasts for the life of the TransportName
        //
        ObReferenceObject( FileObject );

        //
        //  Get the address of the device object for the endpoint.
        //
        DeviceObject = IoGetRelatedDeviceObject( FileObject );

        //
        // Note: due to bug 140751 we'll first set nbt's handler
        // to get it going & only then we would asign the handles
        // to the global structure. This is in order to prevent
        // execution of BowserCloseNetbiosAddress before setting
        // this handler. Otherwise, we can end up using closed
        // handles.
        //

        //
        // Enable receiving datagrams on this device.
        //
        Status = BowserpTdiSetEventHandler( DeviceObject,
                                            FileObject,
                                            TDI_EVENT_RECEIVE_DATAGRAM,
                                            (PVOID) BowserTdiReceiveDatagramHandler,
                                            TransportName);

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        //
        // Tell Netbt to tell us the IP Address of the client.
        //

        if ( Transport->PagedTransport->Wannish ) {
            IO_STATUS_BLOCK IoStatusBlock;

            Status = ZwDeviceIoControlFile(
                            Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_NETBT_ENABLE_EXTENDED_ADDR,
                            NULL,
                            0,
                            NULL,
                            0 );

            if ( !NT_SUCCESS(Status) ) {
                dlog(DPRT_TDI, ("%lx: Can't request extended status from netbt\n", TransportName));
                try_return(Status);
            }

            ASSERT(Status != STATUS_PENDING);
        }

        //
        // Save the handles
        //
        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        TransportName->FileObject = FileObject;
        TransportName->DeviceObject = DeviceObject;
        PagedTransportName->Handle = Handle;
        Handle = NULL;

        ExReleaseResourceLite(&BowserTransportDatabaseResource);


        dlog(DPRT_TDI, ("BowserCreateTransportName Succeeded.  Name: %lx, Handle: %lx\n", TransportName, PagedTransportName->Handle));
try_exit:NOTHING;
    } finally {
        if (EABuffer != NULL) {
            FREE_POOL(EABuffer);
        }

        if ( FileObject != NULL ) {
            ObDereferenceObject( FileObject );
        }

        if ( Handle != NULL ) {
            (VOID) ZwClose( Handle );
        }

        if (!NT_SUCCESS(Status)) {

            //
            // Count Number of failed adds of 1D name.
            //

            if ( TransportName->NameType == MasterBrowser ) {
                if (BrOneD.NameAddFailed < BR_ONE_D_STACK_SIZE ) {
                    BrOneD.NameAddStack[BrOneD.NameAddFailed] = Status;
                }
                BrOneD.NameAddFailed ++;
            }

            BowserCloseNetbiosAddress( TransportName );
        } else {

            //
            // Count Number of adds of 1D name.
            //

            if ( TransportName->NameType == MasterBrowser ) {
                BrOneD.NameAdded ++;
            }
        }
    }

    return Status;
}

VOID
BowserCloseNetbiosAddress(
    IN PTRANSPORT_NAME TransportName
    )

/*++

Routine Description:

    Closes the Netbios Address for a transport name.

Arguments:

    TransportName - Transport Name whose Netbios address is to be closed.


Return Value:

    None.

--*/

{
    NTSTATUS Status;
    // PTRANSPORT Transport = TransportName->Transport;
    PPAGED_TRANSPORT_NAME PagedTransportName = TransportName->PagedTransportName;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    if (PagedTransportName) {

        if ( PagedTransportName->Handle != NULL ) {
            BOOLEAN ProcessAttached = FALSE;

            if (IoGetCurrentProcess() != BowserFspProcess) {
                KeStackAttachProcess(BowserFspProcess, &ApcState );

                ProcessAttached = TRUE;
            }

            Status = ZwClose( PagedTransportName->Handle );

            if (ProcessAttached) {
                KeUnstackDetachProcess( &ApcState );
            }

            if (!NT_SUCCESS(Status)) {
                dlog(DPRT_TDI, ("BowserCloseNetbiosAddress: Free name %lx failed: %X, %lx Handle: %lx\n", TransportName, Status, PagedTransportName->Handle));

                //
                // Count Number of failed frees of 1D name.
                //

                if ( TransportName->NameType == MasterBrowser ) {
                    if (BrOneD.NameFreeFailed < BR_ONE_D_STACK_SIZE ) {
                        BrOneD.NameFreeStack[BrOneD.NameFreeFailed] = Status;
                    }
                    BrOneD.NameFreeFailed ++;
                }
            } else {

                //
                // Count Number of frees of 1D name.
                //

                if ( TransportName->NameType == MasterBrowser ) {
                    BrOneD.NameFreed ++;
                }
            }

            PagedTransportName->Handle = NULL;
        }
    }

    //
    // Dereference the FileObject ONLY after the handle is closed.
    //  The indication routine references FileObject with no synchronization.
    //  By closing the handle first, I know the TDI driver is out of the
    //  indication routine before I dereference the FileObject.
    //
    if ( TransportName->FileObject != NULL ) {
        ObDereferenceObject( TransportName->FileObject );
        TransportName->FileObject = NULL;
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);
}




VOID
BowserCloseAllNetbiosAddresses(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    This routine closes all the Netbios address this transport has open
    to the TDI driver.

Arguments:

    Transport - The transport whose Netbios addresses are to be closed.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    PLIST_ENTRY NameEntry;
    PLIST_ENTRY NextEntry;

    PAGED_CODE();
    dlog(DPRT_TDI,
         ("%s: %ws: BowserCloseAllNetbiosAddresses: Close addresses for transport %lx\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         Transport));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (NameEntry = Transport->PagedTransport->NameChain.Flink;
         NameEntry != &Transport->PagedTransport->NameChain;
         NameEntry = NextEntry) {

        PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
        PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;

        NextEntry = NameEntry->Flink;

        BowserCloseNetbiosAddress(TransportName);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return;
}

NTSTATUS
BowserEnableIpxDatagramSocket(
    IN PTRANSPORT Transport
    )
{
    NTSTATUS status;
    NWLINK_ACTION action;

    PAGED_CODE( );

    //
    //  Put the endpoint in broadcast reception mode.
    //

    action.Header.TransportId = 'XPIM'; // "MIPX"
    action.Header.ActionCode = 0;
    action.Header.Reserved = 0;
    action.OptionType = TRUE;
    action.BufferLength = sizeof(action.Option);
    action.Option = MIPX_RCVBCAST;

    status = BowserIssueTdiAction(
                Transport->IpxSocketDeviceObject,
                Transport->IpxSocketFileObject,
                (PCHAR)&action,
                sizeof(action)
                );

    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Set the default packet type to 20 to force all browser packets
    // through routers.
    //

    action.Header.TransportId = 'XPIM'; // "MIPX"
    action.Header.ActionCode = 0;
    action.Header.Reserved = 0;
    action.OptionType = TRUE;
    action.BufferLength = sizeof(action.Option);
    action.Option = MIPX_SETSENDPTYPE;
    action.Data[0] = IPX_BROADCAST_PACKET;

    status = BowserIssueTdiAction(
                Transport->IpxSocketDeviceObject,
                Transport->IpxSocketFileObject,
                (PCHAR)&action,
                sizeof(action)
                );

    if ( !NT_SUCCESS(status) ) {
        goto cleanup;
    }

    //
    // Register the browser Receive Datagram event handler.
    //

    status = BowserpTdiSetEventHandler(
                Transport->IpxSocketDeviceObject,
                Transport->IpxSocketFileObject,
                TDI_EVENT_RECEIVE_DATAGRAM,
                BowserIpxDatagramHandler,
                Transport
                );

    if ( !NT_SUCCESS(status) ) {
//        INTERNAL_ERROR(
//            ERROR_LEVEL_EXPECTED,
//            "OpenNonNetbiosAddress: set receive datagram event handler failed: %X",
//            status,
//            NULL
//            );
//        SrvLogServiceFailure( SRV_SVC_NT_IOCTL_FILE, status );
        goto cleanup;
    }


    return STATUS_SUCCESS;

    //
    // Out-of-line error cleanup.
    //

cleanup:

    //
    // Something failed.  Clean up as appropriate.
    //

    if ( Transport->IpxSocketFileObject != NULL ) {
        ObDereferenceObject( Transport->IpxSocketFileObject );
        Transport->IpxSocketFileObject = NULL;
    }
    if ( Transport->PagedTransport->IpxSocketHandle != NULL ) {
        ZwClose( Transport->PagedTransport->IpxSocketHandle );
        Transport->PagedTransport->IpxSocketHandle = NULL;
    }

    return status;
}

NTSTATUS
OpenIpxSocket (
    OUT PHANDLE Handle,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject,
    IN PUNICODE_STRING DeviceName,
    IN USHORT Socket
    )
{
    NTSTATUS status;
    ULONG length;
    PFILE_FULL_EA_INFORMATION ea;
    TA_IPX_ADDRESS ipxAddress;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;

    CHAR buffer[sizeof(FILE_FULL_EA_INFORMATION) +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof(TA_IPX_ADDRESS)];

    PAGED_CODE( );

    //
    // Build the IPX socket address.
    //

    length = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                                TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                                sizeof(TA_IPX_ADDRESS);
    ea = (PFILE_FULL_EA_INFORMATION)buffer;

    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = sizeof (TA_IPX_ADDRESS);

    RtlCopyMemory( ea->EaName, TdiTransportAddress, ea->EaNameLength + 1 );

    //
    // Create a copy of the NETBIOS address descriptor in a local
    // first, in order to avoid alignment problems.
    //

    ipxAddress.TAAddressCount = 1;
    ipxAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    ipxAddress.Address[0].AddressLength = sizeof (TDI_ADDRESS_IPX);
    ipxAddress.Address[0].Address[0].NetworkAddress = 0;
    RtlZeroMemory(ipxAddress.Address[0].Address[0].NodeAddress, sizeof(ipxAddress.Address[0].Address[0].NodeAddress));
    ipxAddress.Address[0].Address[0].Socket = Socket;

    RtlCopyMemory(
        &ea->EaName[ea->EaNameLength + 1],
        &ipxAddress,
        sizeof(TA_IPX_ADDRESS)
        );

    InitializeObjectAttributes( &objectAttributes, DeviceName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = IoCreateFile (
                 Handle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &objectAttributes,     // object attributes
                 &iosb,                 // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 buffer,                // EA buffer
                 length,                // EA length
                 CreateFileTypeNone,
                 NULL,
                 IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                 IO_CHECK_CREATE_PARAMETERS);// But double check parameter consistancy

    if ( !NT_SUCCESS(status) ) {
//        KdPrint(( "Status of opening ipx socket %x on %wZ is %x\n",
//                    Socket, DeviceName, status ));
        return status;
    }

//    KdPrint(( "IPX socket %x opened!\n", Socket ));

    status = ObReferenceObjectByHandle (
                                *Handle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)FileObject,
                                NULL
                                );
    if (!NT_SUCCESS(status)) {
        ZwClose(*Handle);
        *Handle = NULL;
        *DeviceObject = NULL;
    }
    else {
        *DeviceObject = IoGetRelatedDeviceObject(*FileObject);
    }

    return status;

} // OpenIpxSocket


VOID
BowserReferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    )
{
    InterlockedIncrement(&TransportName->ReferenceCount);
}

NTSTATUS
BowserDereferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    )
{
    NTSTATUS Status;
    LONG Result;
    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);


    if (TransportName->ReferenceCount == 0) {
        InternalError(("Transport Name Reference Count mismatch\n"));
    }

    Result = InterlockedDecrement(&TransportName->ReferenceCount);

    if (Result == 0) {
        Status = BowserFreeTransportName(TransportName);
    } else {
        Status = STATUS_SUCCESS;
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}




NTSTATUS
BowserpTdiRemoveAddresses(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    This routine removes all the transport names associated with a transport

Arguments:

    IN PTRANSPORT Transport - Supplies a transport structure describing the
                                transport address object to be created.

Return Value:

    NTSTATUS - Status of resulting operation.

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY NameEntry;
    PLIST_ENTRY NextEntry;

    PAGED_CODE();
    dlog(DPRT_TDI,
         ("%s: %ws: BowserpTdiRemoveAddresses: Remove addresses for transport %lx\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         Transport));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (NameEntry = Transport->PagedTransport->NameChain.Flink;
         NameEntry != &Transport->PagedTransport->NameChain;
         NameEntry = NextEntry) {

        PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
        PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;
        NextEntry = NameEntry->Flink;

        //
        // Remove the TransportName from the list of transport names for
        // this transport.
        //
        ASSERT(PagedTransportName->TransportNext.Flink != NULL);
        RemoveEntryList(&PagedTransportName->TransportNext);
        PagedTransportName->TransportNext.Flink = NULL;
        PagedTransportName->TransportNext.Blink = NULL;


        //
        // Since we delinked it, we need to dereference it.
        //
        Status = BowserDereferenceTransportName(TransportName);

        if (!NT_SUCCESS(Status)) {
            ExReleaseResourceLite(&BowserTransportDatabaseResource);
            return(Status);
        }

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return STATUS_SUCCESS;
}

PTRANSPORT_NAME
BowserFindTransportName(
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    )
/*++

Routine Description:

    This routine looks up a given browser name to find its associated
    transport address.

Arguments:

    IN PTRANSPORT Transport - Supplies a transport structure describing the
                                transport address object to be created.

    IN PBOWSER_NAME Name - Supplies the name to look up.

Return Value:

    The transport address found, or null.

--*/

{
    PLIST_ENTRY NameEntry;
    PTRANSPORT_NAME RetValue = NULL;
    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {
        for (NameEntry = Transport->PagedTransport->NameChain.Flink;
             NameEntry != &Transport->PagedTransport->NameChain;
             NameEntry = NameEntry->Flink) {

            PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
            PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;

            if (PagedTransportName->Name == Name) {

                try_return(RetValue = TransportName);
            }

try_exit:NOTHING;
        }
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return RetValue;
}

NTSTATUS
BowserFreeTransportName(
    IN PTRANSPORT_NAME TransportName
    )
{
    PTRANSPORT Transport = TransportName->Transport;
    PBOWSER_NAME Name = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = TransportName->PagedTransportName;

    PAGED_CODE();
    dlog(DPRT_TDI,
         ("%s: %ws: BowserFreeTransportName: Free name %lx\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         TransportName));

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    //
    // Close the handle to the TDI driver.
    //
    BowserCloseNetbiosAddress( TransportName );

    //
    // If we received a message which re-referenced this transport name,
    //  just return now.  We'll be back when the reference count gets
    //  re-dereferenced to zero.
    //

    if ( TransportName->ReferenceCount != 0 ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        return STATUS_SUCCESS;
    }

    ASSERT (TransportName->ReferenceCount == 0);



    if (PagedTransportName) {


        //
        // If this transport name has not yet been delinked,
        //  delink it.
        //

        if ( PagedTransportName->TransportNext.Flink != NULL ) {
            // This should only happen on a failed transport name creation.
            RemoveEntryList(&PagedTransportName->TransportNext);
            PagedTransportName->TransportNext.Flink = NULL;
            PagedTransportName->TransportNext.Blink = NULL;
        }
        RemoveEntryList(&PagedTransportName->NameNext);


        Name = PagedTransportName->Name;

        FREE_POOL(PagedTransportName);
    }

    if (Name != NULL) {
        switch ( Name->NameType ) {
        case ComputerName:
            Transport->ComputerName = NULL;
            break;

        case PrimaryDomain:
            if ( Transport->PrimaryDomain == TransportName ) {
                Transport->PrimaryDomain = Transport->AltPrimaryDomain;
                Transport->AltPrimaryDomain = NULL;
            }
            if ( Transport->AltPrimaryDomain == TransportName ) {
                Transport->AltPrimaryDomain = NULL;
            }
            break;

        case MasterBrowser:
            Transport->MasterBrowser = NULL;
            break;

        case BrowserElection:
            Transport->BrowserElection = NULL;
            break;

        case PrimaryDomainBrowser:
            Transport->PagedTransport->IsPrimaryDomainController = FALSE;

            //
            // Notify services we are no longer a PDC
            //

            BowserSendPnp(
                NlPnpNewRole,
                &Transport->DomainInfo->DomUnicodeDomainName,
                &Transport->PagedTransport->TransportName,
                BowserTransportFlags(Transport->PagedTransport) );

            break;
        }

        BowserDereferenceName(Name);

    }

    FREE_POOL(TransportName);

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    dlog(DPRT_TDI,
         ("%s: %ws: BowserFreeTransportName: Free name %lx completed\n",
         Transport->DomainInfo->DomOemDomainName,
         Transport->PagedTransport->TransportName.Buffer,
         TransportName));

    return(STATUS_SUCCESS);
}

VOID
BowserDeleteTransport(
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    Delete a transport.

    The caller should have a single reference to the transport.  The actual
    transport structure will be deleted when that reference goes away.
    This routine will decrement the global reference made in
    BowserTdiAllocateTransport

Arguments:

    IN Transport - Supplies a transport structure to be deleted.

Return Value:

    None.

--*/

{
    LARGE_INTEGER Interval;
    PPAGED_TRANSPORT PagedTransport;
    PAGED_CODE();

    //
    // Do cleanup of the PagedTransport structure
    //

    PagedTransport = Transport->PagedTransport;
    if ( PagedTransport != NULL ) {

        //
        // Notify services that this transport is now unbound
        //

        BowserSendPnp(
                NlPnpTransportUnbind,
                NULL,    // All hosted domains
                &PagedTransport->TransportName,
                BowserTransportFlags(PagedTransport) );


        //
        // Prevent BowserFindTransport from adding any new references to the transport
        //

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        if (!PagedTransport->DeletedTransport ) {

            //
            // Don't actually delink the entry since routines like
            //  BowserForEachTransport expect a reference to this transport
            //  to be enough to keep the GlobalNext list intact.
            //
            PagedTransport->DeletedTransport = TRUE;

            //
            // Remove the global reference to the transport.
            //
            // Avoid removing the global reference if we aren't in the global list.
            //

            if ( !IsListEmpty( &PagedTransport->GlobalNext) ) {
                BowserDereferenceTransport( Transport );
            }
        }

        //
        // Close all handles to the TDI driver so we won't get any indications after
        //  we start cleaning up the Transport structure in BowserpFreeTransport.
        //

        BowserCloseAllNetbiosAddresses( Transport );

        if ( PagedTransport->IpxSocketHandle != NULL) {

            NTSTATUS LocalStatus;
            BOOLEAN ProcessAttached = FALSE;
            KAPC_STATE ApcState;

            if (IoGetCurrentProcess() != BowserFspProcess) {
                KeStackAttachProcess(BowserFspProcess, &ApcState );

                ProcessAttached = TRUE;
            }

            LocalStatus = ZwClose(PagedTransport->IpxSocketHandle);
            ASSERT(NT_SUCCESS(LocalStatus));

            if (ProcessAttached) {
                KeUnstackDetachProcess( &ApcState );
            }

            PagedTransport->IpxSocketHandle = NULL;

            if ( Transport->IpxSocketFileObject != NULL ) {
                ObDereferenceObject( Transport->IpxSocketFileObject );
                Transport->IpxSocketFileObject = NULL;
            }
            Transport->IpxSocketDeviceObject = NULL;
        }
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    //
    // Uninitialize the timers to ensure we aren't in a timer routine while
    // we are cleaning up.
    //

    BowserUninitializeTimer(&Transport->ElectionTimer);

    BowserUninitializeTimer(&Transport->FindMasterTimer);


    //
    // Delete any mailslot messages queued to the netlogon service.
    //

    BowserNetlogonDeleteTransportFromMessageQueue ( Transport );

    //
    // Loop until this transport has the last reference to each of the transport
    //  names.  Above, we prevented any new references.  Here we ensure that
    //  all of the existing references go away.
    //
    // If there is an existing reference to the transport name, the holder
    //  of that reference can feel free to add a reference to
    //  TRANSPORT_NAME->Transport.
    //


    if ( PagedTransport != NULL ) {

        PLIST_ENTRY NameEntry;
        PLIST_ENTRY NextEntry;

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        for (NameEntry = Transport->PagedTransport->NameChain.Flink;
             NameEntry &&
             (NameEntry != &Transport->PagedTransport->NameChain);
             NameEntry = NextEntry) {

            PPAGED_TRANSPORT_NAME PagedTransportName = CONTAINING_RECORD(NameEntry, PAGED_TRANSPORT_NAME, TransportNext);
            PTRANSPORT_NAME TransportName = PagedTransportName->NonPagedTransportName;

            NextEntry = NameEntry->Flink;

            if ( TransportName->ReferenceCount != 1 ) {
                ExReleaseResourceLite(&BowserTransportDatabaseResource);
                Interval.QuadPart = -1000*1000; // .1 second
                KeDelayExecutionThread( KernelMode, FALSE, &Interval );
                ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
                NextEntry = Transport->PagedTransport->NameChain.Flink;
            }

        }

        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }


    //
    // Loop until our caller has the last outstanding reference.
    //  This loop is the only thing preventing the driver from unloading while there
    //  are still references outstanding.
    //

    while ( Transport->ReferenceCount != 1) {
        Interval.QuadPart = -1000*1000; // .01 second
        KeDelayExecutionThread( KernelMode, FALSE, &Interval );
    }

}



VOID
BowserpFreeTransport(
    IN PTRANSPORT Transport
    )
{
    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    //
    // Free the Paged transport, if necessary.
    //

    if (Transport->PagedTransport != NULL) {
        PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

        //
        // Remove the entry from the global list if it is in it.
        //
        if ( !IsListEmpty( &PagedTransport->GlobalNext ) ) {
            ASSERT( PagedTransport->DeletedTransport );
            RemoveEntryList(&PagedTransport->GlobalNext);
        }

        //
        // Remove the Adresses.
        //
        //  Do this in a separate step from the Close in BowserDeleteTransport
        //  above to ensure the PrimaryDomain and ComputerName fields don't
        //  get cleared until all possible references are removed.
        //

        if (!IsListEmpty( &PagedTransport->NameChain)) {
            BowserpTdiRemoveAddresses(Transport);
        }

        BowserDeleteGenericTable(&PagedTransport->AnnouncementTable);

        BowserDeleteGenericTable(&PagedTransport->DomainTable);

        if (PagedTransport->BrowserServerListBuffer != NULL) {

            BowserFreeBrowserServerList(
                PagedTransport->BrowserServerListBuffer,
                PagedTransport->BrowserServerListLength
                );
        }

        FREE_POOL(PagedTransport);
    }

    if ( Transport->DomainInfo != NULL ) {
        BowserDereferenceDomain( Transport->DomainInfo );
    }


    ExDeleteResourceLite(&Transport->BrowserServerListResource);

    UNINITIALIZE_ANNOUNCE_DATABASE(Transport);

    ExDeleteResourceLite(&Transport->Lock);

    BowserUninitializeIrpQueue(&Transport->BecomeBackupQueue);

    BowserUninitializeIrpQueue(&Transport->BecomeMasterQueue);

    BowserUninitializeIrpQueue(&Transport->FindMasterQueue);

    BowserUninitializeIrpQueue(&Transport->WaitForMasterAnnounceQueue);

    BowserUninitializeIrpQueue(&Transport->ChangeRoleQueue);
    BowserUninitializeIrpQueue(&Transport->WaitForNewMasterNameQueue );

    FREE_POOL(Transport);

    ExReleaseResourceLite(&BowserTransportDatabaseResource);
}



NTSTATUS
BowserpTdiSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS Status;
    PIRP Irp;

    PAGED_CODE();
    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (Irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler(Irp, DeviceObject, FileObject,
                            NULL, NULL,
                            EventType, EventHandler, Context);

    Status = BowserSubmitTdiRequest(FileObject, Irp);

    IoFreeIrp(Irp);

    return Status;
}

NTSTATUS
BowserIssueTdiAction (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PVOID Action,
    IN ULONG ActionSize
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject - Supplies the address object's file object.
    IN ULONG EventType, - Supplies the type of event.
    IN PVOID EventHandler - Supplies the event handler.

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS status;
    PIRP irp;
//    PIO_STACK_LOCATION irpSp;
    PMDL mdl;


    PAGED_CODE();

    irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate and build an MDL that we'll use to describe the output
    // buffer for the request.
    //

    mdl = IoAllocateMdl( Action, ActionSize, FALSE, FALSE, NULL );

    if ( mdl == NULL ) {
        IoFreeIrp( irp );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool( mdl );

    TdiBuildAction(
        irp,
        DeviceObject,
        FileObject,
        NULL,
        NULL,
        mdl
        );

    irp->AssociatedIrp.SystemBuffer = Action;

    if (irp == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = BowserSubmitTdiRequest(FileObject, irp);

    IoFreeIrp(irp);

    IoFreeMdl(mdl);

    return status;
}


NTSTATUS
BowserBuildTransportAddress (
    IN OUT PANSI_STRING Address,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    )
/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and converts it into an
    acceptable form for passing in as transport address.

Arguments:

    OUT PTA_NETBIOS_ADDRESS RemoteAddress, - Supplies the structure to fill in
    IN PUNICODE_STRING Name - Supplies the name to put into the transport

    Please note that it is CRITICAL that the TA_NETBIOS_ADDRESS pointed to by
    RemoteAddress be of sufficient size to hold the full network name.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    OEM_STRING NetBiosName;
    PTRANSPORT_ADDRESS RemoteAddress = (PTRANSPORT_ADDRESS)Address->Buffer;
    PTDI_ADDRESS_NETBIOS NetbiosAddress = (PTDI_ADDRESS_NETBIOS)&RemoteAddress->Address[0].Address[0];

    PAGED_CODE();


    //
    // Ensure there is room for this address.
    //
    if ( Address->MaximumLength < sizeof(TA_NETBIOS_ADDRESS) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RemoteAddress->TAAddressCount = 1;
    RemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    RemoteAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
    Address->Length = sizeof(TA_NETBIOS_ADDRESS);

    NetBiosName.Length = 0;
    NetBiosName.MaximumLength = NETBIOS_NAME_LEN;
    NetBiosName.Buffer = NetbiosAddress->NetbiosName;

    //
    // Domain announcements are to a constant Netbios name address.
    //
    switch (NameType) {
    case DomainAnnouncement:
        ASSERT (strlen(DOMAIN_ANNOUNCEMENT_NAME) == NETBIOS_NAME_LEN);
        RtlCopyMemory(NetBiosName.Buffer, DOMAIN_ANNOUNCEMENT_NAME, strlen(DOMAIN_ANNOUNCEMENT_NAME));

        NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
        break;


    //
    // All other names are upper case, OEM, and trailing blank filled.
    //
    default:

        if (RtlUnicodeStringToOemSize(Name) > NETBIOS_NAME_LEN) {
            return STATUS_BAD_NETWORK_PATH;
        }

        Status = RtlUpcaseUnicodeStringToOemString(&NetBiosName, Name, FALSE);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        RtlCopyMemory(&NetBiosName.Buffer[NetBiosName.Length], "                ",
                                    NETBIOS_NAME_LEN-NetBiosName.Length);

        switch (NameType) {

        case ComputerName:
        case AlternateComputerName:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = WORKSTATION_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case DomainName:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = DOMAIN_CONTROLLER_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            break;

        case BrowserServer:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = SERVER_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case MasterBrowser:
            if (Transport->PagedTransport->Flags & DIRECT_HOST_IPX) {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = WORKSTATION_SIGNATURE;
            } else {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = MASTER_BROWSER_SIGNATURE;
            }
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case PrimaryDomain:
        case OtherDomain:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = PRIMARY_DOMAIN_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            break;

        case PrimaryDomainBrowser:
            NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = PRIMARY_CONTROLLER_SIGNATURE;
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
            break;

        case BrowserElection:
            if (Transport->PagedTransport->Flags & DIRECT_HOST_IPX) {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = WORKSTATION_SIGNATURE;
            } else {
                NetbiosAddress->NetbiosName[NETBIOS_NAME_LEN-1] = BROWSER_ELECTION_SIGNATURE;
            }
            NetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
            break;


        }

        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
BowserUpdateProviderInformation(
    IN OUT PPAGED_TRANSPORT PagedTransport
    )
/*++

Routine Description:

    This routine updates status bits in the PagedTransport based on querying
    the TDI driver.

    Most importantly, the transport will be disabled if the provider is RAS or
    doesn't yet have an IP address.

    A goal of this routine is to handle the case where there are multiple IP
    net cards on the same subnet.  In that case, we want only one such net
    card enabled for each emulated domain.

Arguments:

    PagedTransport - Transport to update

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    TDI_PROVIDER_INFO ProviderInfo;
    ULONG OldIpSubnetNumber;
    BOOLEAN DisableThisTransport = FALSE;

    PLIST_ENTRY TransportEntry;
    PPAGED_TRANSPORT CurrentPagedTransport;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    //
    // Find out about the transport.
    //

    OldIpSubnetNumber = PagedTransport->IpSubnetNumber;

    Status = BowserDetermineProviderInformation(
                        &PagedTransport->TransportName,
                        &ProviderInfo,
                        &PagedTransport->IpSubnetNumber );

    if (!NT_SUCCESS(Status)) {
        goto ReturnStatus;
    }

    //
    //  We can only talk to transports that support a max datagram size.
    //

    if (ProviderInfo.MaxDatagramSize == 0) {
        Status = STATUS_BAD_REMOTE_ADAPTER;
        goto ReturnStatus;
    }

    PagedTransport->NonPagedTransport->DatagramSize = ProviderInfo.MaxDatagramSize;


    //
    // Remember various attributes of the provider
    //  (Never disable the PointToPoint bit.  NetBt forgets it when the
    //  RAS phone is hung up.)

    PagedTransport->Wannish = (BOOLEAN)((ProviderInfo.ServiceFlags & TDI_SERVICE_ROUTE_DIRECTED) != 0);
    if (ProviderInfo.ServiceFlags & TDI_SERVICE_POINT_TO_POINT) {
        PagedTransport->PointToPoint = TRUE;
    }


    //
    // If this is a RAS transport or the IP Address is not yet known,
    //  disable browsing on the transport.
    //

    if ( PagedTransport->PointToPoint ||
         PagedTransport->IpSubnetNumber == 0 ) {
        DisableThisTransport = TRUE;
    }


    //
    // If this isn't an IP transport, we're done.
    //

    if ( PagedTransport->IpSubnetNumber == BOWSER_NON_IP_SUBNET ) {
        goto ReturnStatus;
    }

    //
    // In the loop below, we use OldIpSubnetNumber to determine if another
    //  transport should be enabled on that subnet.  If that will NEVER be
    //  appropriate, flag OldIpSubnetNumber now.
    //

    if ( OldIpSubnetNumber == 0 ||
         PagedTransport->DisabledTransport ||
         PagedTransport->IpSubnetNumber == OldIpSubnetNumber ) {
        OldIpSubnetNumber = BOWSER_NON_IP_SUBNET;
    }


    //
    // Loop through the transports enabling/disabling them as indicated by
    //  the comments below.
    //

    for (TransportEntry = BowserTransportHead.Flink ;
        TransportEntry != &BowserTransportHead ;
        TransportEntry = CurrentPagedTransport->GlobalNext.Flink ) {

        CurrentPagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);

        //
        // Ignore deleted transports.
        //
        if ( CurrentPagedTransport->DeletedTransport ) {
            continue;
        }

        //
        // If this transport isn't an IP transport,
        //  or this transport is a RAS transport,
        //  or this transport is the transport passed in,
        //  skip it and go on to the next one.
        //
        if ( CurrentPagedTransport->IpSubnetNumber == BOWSER_NON_IP_SUBNET ||
             CurrentPagedTransport->PointToPoint ||
             CurrentPagedTransport == PagedTransport ) {
            continue;
        }

        //
        // Special case this transport if it's currently disabled
        //

        if ( CurrentPagedTransport->DisabledTransport ) {

            //
            // If this transport is disabled and the transport passed in
            // used to be the enabled transport for the subnet,
            //  enable the transport
            //

            if ( CurrentPagedTransport->IpSubnetNumber == OldIpSubnetNumber ) {
                CurrentPagedTransport->DisabledTransport = FALSE;
            }

            //
            // In any case,
            //  that's all we need to do for a disabled transport.
            //

            continue;
        }


        //
        // If this transport is an enabled transport for the subnet of the one
        //  passed in,
        //  And this transport is for the same emulated domain as the one
        //  passed in,
        //  then disable the one passed in.
        //

        if ( CurrentPagedTransport->IpSubnetNumber ==
             PagedTransport->IpSubnetNumber &&
             CurrentPagedTransport->NonPagedTransport->DomainInfo == PagedTransport->NonPagedTransport->DomainInfo ) {
             DisableThisTransport = TRUE;
        }


    }



    //
    // Cleanup
    //
ReturnStatus:

    //
    // If we're disabling a previously enabled transport,
    //  ensure we're not the master browser.
    //
    if ( DisableThisTransport && !PagedTransport->DisabledTransport ) {
        PagedTransport->DisabledTransport = DisableThisTransport;
        BowserLoseElection( PagedTransport->NonPagedTransport );
    } else {
        PagedTransport->DisabledTransport = DisableThisTransport;
    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);
    return Status;
}

NTSTATUS
BowserDetermineProviderInformation(
    IN PUNICODE_STRING TransportName,
    OUT PTDI_PROVIDER_INFO ProviderInfo,
    OUT PULONG IpSubnetNumber
    )
/*++

Routine Description:

    This routine will determine provider information about a transport.

Arguments:

    TransportName - Supplies the name of the transport provider

    ProviderInfo - Returns information about the provider

    IpSubnetNumber - returns the Ip Subnet Number of this transport.
        BOWSER_NON_IP_SUBNET - If this isn't an IP transport
        0 - If the IP address isn't yet set
        Otherwise - the IP address anded with the subnet mask

Return Value:

    Status of operation.

--*/
{
    HANDLE TransportHandle = NULL;
    PFILE_OBJECT TransportObject = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;
    PMDL Mdl = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    InitializeObjectAttributes (&ObjAttributes,
                                    TransportName, // Name
                                    OBJ_CASE_INSENSITIVE, // Attributes
                                    NULL, // RootDirectory
                                    NULL); // SecurityDescriptor


    Status = IoCreateFile(&TransportHandle, // Handle
                                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                &ObjAttributes, // Object Attributes
                                &IoStatusBlock, // Final I/O status block
                                NULL,   // Allocation Size
                                FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                FILE_SHARE_READ, // Sharing attributes
                                FILE_OPEN_IF, // Create disposition
                                0,      // CreateOptions
                                NULL,   // EA Buffer
                                0,      // EA Buffer Length
                                CreateFileTypeNone,
                                NULL,
                                IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                                IO_CHECK_CREATE_PARAMETERS);// But double check parameter consistancy


    if (!NT_SUCCESS(Status)) {

        goto ReturnStatus;
    }

    Status = ObReferenceObjectByHandle (
                                TransportHandle,
                                0,
                                *IoFileObjectType,
                                KernelMode,
                                (PVOID *)&TransportObject,
                                NULL
                                );
    if (!NT_SUCCESS(Status)) {
        goto ReturnStatus;
    }

    DeviceObject = IoGetRelatedDeviceObject(TransportObject);

    Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (Irp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReturnStatus;
    }

    //
    //  Allocate an MDL to hold the provider info.
    //

    Mdl = IoAllocateMdl(ProviderInfo, sizeof(TDI_PROVIDER_INFO),
                        FALSE,
                        FALSE,
                        NULL);


    if (Mdl == NULL) {
        IoFreeIrp(Irp);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReturnStatus;
    }

    MmBuildMdlForNonPagedPool(Mdl);

    TdiBuildQueryInformation(Irp, DeviceObject, TransportObject,
                            NULL, NULL,
                            TDI_QUERY_PROVIDER_INFORMATION, Mdl);

    Status = BowserSubmitTdiRequest(TransportObject, Irp);

    IoFreeIrp(Irp);

    //
    // Get the IP address for this Transport.
    //

    if ( (ProviderInfo->ServiceFlags & TDI_SERVICE_ROUTE_DIRECTED) == 0) {
        *IpSubnetNumber = BOWSER_NON_IP_SUBNET;
    } else {
        NTSTATUS TempStatus;
        IO_STATUS_BLOCK IoStatusBlock;
        ULONG IpAddressBuffer[2];   // IpAddress followed by subnet mask

        TempStatus = ZwDeviceIoControlFile(
                        TransportHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_NETBT_GET_IP_SUBNET,
                        NULL,
                        0,
                        &IpAddressBuffer,
                        sizeof(IpAddressBuffer) );

        if ( !NT_SUCCESS(TempStatus) ) {
            *IpSubnetNumber = BOWSER_NON_IP_SUBNET;
        } else {
            ASSERT(TempStatus != STATUS_PENDING);
            *IpSubnetNumber = IpAddressBuffer[0] & IpAddressBuffer[1];
        }
    }


ReturnStatus:
    if (Mdl != NULL) {
        IoFreeMdl(Mdl);
    }

    if (TransportObject != NULL) {
        ObDereferenceObject(TransportObject);
    }


    if (TransportHandle != NULL) {
        ZwClose(TransportHandle);
    }

    return(Status);
}




PTRANSPORT
BowserFindTransport (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName OPTIONAL
    )

/*++

Routine Description:

    This routine will locate a transport in the bowsers transport list.

Arguments:

    TransportName - Supplies the name of the transport provider

    EmulatedDomainName - Specifies the emulated domain whose transport is to be found.


Return Value:

    PTRANSPORT - NULL if no transport was found, TRUE if transport was found.

--*/
{
    PLIST_ENTRY TransportEntry;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport = NULL;
    PDOMAIN_INFO DomainInfo = NULL;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {

		//
		// If the passed transport name is not a valid unicode string, return NULL
		//
		if ( !BowserValidUnicodeString(TransportName) ) {
			try_return( NULL);
		}

        //
        // Find the requested domain.
        //

        DomainInfo = BowserFindDomain( EmulatedDomainName );

        if ( DomainInfo != NULL ) {
            for (TransportEntry = BowserTransportHead.Flink ;
                TransportEntry != &BowserTransportHead ;
                TransportEntry = TransportEntry->Flink) {

                PagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);

                //
                // Ignore deleted transports.
                //
                if ( PagedTransport->DeletedTransport ) {
                    continue;
                }

                if ( PagedTransport->NonPagedTransport->DomainInfo == DomainInfo &&
                     RtlEqualUnicodeString(TransportName,
                                           &PagedTransport->TransportName, TRUE)) {

                    Transport = PagedTransport->NonPagedTransport;

                    dprintf(DPRT_REF, ("Call Reference transport %lx from BowserFindTransport.\n", Transport));
                    BowserReferenceTransport( Transport );

                    try_return(Transport);
                }
            }
        }


        try_return(Transport = NULL);

try_exit:NOTHING;
    } finally {
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }
        ExReleaseResourceLite (&BowserTransportDatabaseResource);
    }

    return Transport;

}

NTSTATUS
BowserForEachTransportInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the transports and call back the enum
    routine provided with each transport.

Arguments:

    DomainInfo - Only call 'Routine' for transport in this domain.

    Routine - Routine to call for each transport

    Context - Parameter to pass to 'Routine'

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (TransportEntry = BowserTransportHead.Flink ;
        TransportEntry != &BowserTransportHead ;
        TransportEntry = NextEntry) {

        PagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);
        Transport = PagedTransport->NonPagedTransport;

        //
        // Ignore deleted transports.
        //
        if ( PagedTransport->DeletedTransport ) {
            NextEntry = PagedTransport->GlobalNext.Flink;
            continue;
        }

        //
        // If transport isn't in the specified domain,
        //  ignore it.
        //

        if ( Transport->DomainInfo != DomainInfo ) {
            NextEntry = PagedTransport->GlobalNext.Flink;
            continue;
        }


        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserForEachTransportInDomain.\n", Transport));
        BowserReferenceTransport(Transport);

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        Status = (Routine)(Transport, Context);

        if (!NT_SUCCESS(Status)) {
            BowserDereferenceTransport(Transport);

            return Status;
        }

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        NextEntry = PagedTransport->GlobalNext.Flink;

        BowserDereferenceTransport(Transport);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}

NTSTATUS
BowserForEachTransport (
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the transports and call back the enum
    routine provided with each transport.

Arguments:


    Routine - Routine to call for each transport

    Context - Parameter to pass to 'Routine'

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    for (TransportEntry = BowserTransportHead.Flink ;
        TransportEntry != &BowserTransportHead ;
        TransportEntry = NextEntry) {

        PagedTransport = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT, GlobalNext);

        //
        // Ignore deleted transports.
        //
        if ( PagedTransport->DeletedTransport ) {
            NextEntry = PagedTransport->GlobalNext.Flink;
            continue;
        }

        Transport = PagedTransport->NonPagedTransport;

        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserForEachTransport.\n", Transport));
        BowserReferenceTransport(Transport);

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

        Status = (Routine)(Transport, Context);

        if (!NT_SUCCESS(Status)) {
            BowserDereferenceTransport(Transport);

            return Status;
        }

        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

        NextEntry = PagedTransport->GlobalNext.Flink;

        BowserDereferenceTransport(Transport);

    }

    ExReleaseResourceLite(&BowserTransportDatabaseResource);

    return Status;
}

NTSTATUS
BowserForEachTransportName(
    IN PTRANSPORT Transport,
    IN PTRANSPORT_NAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This routine will enumerate the names associated with a transport
    and call back the enum routine provided with each transport name.

Arguments:


Return Value:

    NTSTATUS - Final status of request.

--*/
{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT_NAME TransportName = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {

        for (TransportEntry = Transport->PagedTransport->NameChain.Flink ;
             TransportEntry &&
             (TransportEntry != &Transport->PagedTransport->NameChain) ;
             TransportEntry = NextEntry) {

            PagedTransportName = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT_NAME, TransportNext);

            TransportName = PagedTransportName->NonPagedTransportName;
            BowserReferenceTransportName( TransportName );
            ExReleaseResourceLite(&BowserTransportDatabaseResource);

            Status = (Routine)(TransportName, Context);

            if (!NT_SUCCESS(Status)) {
                ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
                BowserDereferenceTransportName( TransportName );
                try_return(Status);
            }

            ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
            NextEntry = PagedTransportName->TransportNext.Flink;
            BowserDereferenceTransportName( TransportName );
        }

try_exit:NOTHING;
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return Status;
}

NTSTATUS
BowserDeleteTransportNameByName(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Name OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType
    )
/*++

Routine Description:

    This routine deletes a transport name associated with a specific network.

Arguments:

    Transport - Specifies the transport on which to delete the name.

    Name - Specifies the transport name to delete.
        If not specified, all names of the specified name type are deleted.

    NameType - Specifies the name type of the name.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    PLIST_ENTRY TransportEntry, NextEntry;
    PTRANSPORT_NAME TransportName = NULL;
    PPAGED_TRANSPORT_NAME PagedTransportName = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {
        for (TransportEntry = Transport->PagedTransport->NameChain.Flink ;
             TransportEntry != &Transport->PagedTransport->NameChain ;
             TransportEntry = NextEntry) {

            PagedTransportName = CONTAINING_RECORD(TransportEntry, PAGED_TRANSPORT_NAME, TransportNext);

            TransportName = PagedTransportName->NonPagedTransportName;

            ASSERT (TransportName->NameType == PagedTransportName->Name->NameType);

            if ((TransportName->NameType == NameType) &&
                (Name == NULL ||
                 Name->Length == 0 ||
                RtlEqualUnicodeString(&PagedTransportName->Name->Name, Name, TRUE))) {
                NextEntry = TransportEntry->Flink;


                //
                // Remove the TransportName from the list of transport names for
                // this transport.
                //
                ASSERT( PagedTransportName->TransportNext.Flink != NULL);
                RemoveEntryList(&PagedTransportName->TransportNext);
                PagedTransportName->TransportNext.Flink = NULL;
                PagedTransportName->TransportNext.Blink = NULL;


                //
                // Since we delinked it, we need to dereference it.
                //
                Status = BowserDereferenceTransportName(TransportName);

                if (!NT_SUCCESS(Status)) {
                    try_return(Status);
                }

            } else {
                NextEntry = PagedTransportName->TransportNext.Flink;
            }

        }
try_exit:NOTHING;
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return Status;
}



NTSTATUS
BowserSubmitTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    PAGED_CODE();

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, BowserCompleteTdiRequest, &Event, TRUE, TRUE, TRUE);

    //
    //  Submit the disconnect request
    //

    Status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //

    if (!NT_SUCCESS(Status)) {
        dlog(DPRT_TDI, ("BowserSubmitTdiRequest: submit request.  Status = %X", Status));
        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
        return Status;
    }

    if (Status == STATUS_PENDING) {

        dlog(DPRT_TDI, ("TDI request issued, waiting..."));

        Status = KeWaitForSingleObject(&Event, // Object to wait on.
                                    Executive,  // Reason for waiting
                                    KernelMode, // Processor mode
                                    FALSE,      // Alertable
                                    NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            dlog(DPRT_TDI, ("Could not wait for operation to complete"));
            KeBugCheck( 666 );
        }

        Status = Irp->IoStatus.Status;
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    dlog(DPRT_TDI, ("TDI request complete\n"));

    return(Status);
}


NTSTATUS
BowserCompleteTdiRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Completion routine for SubmitTdiRequest operation.

Arguments:

    IN PDEVICE_OBJECT DeviceObject, - Supplies a pointer to the device object
    IN PIRP Irp, - Supplies the IRP submitted
    IN PVOID Context - Supplies a pointer to the kernel event to release

Return Value:

    NTSTATUS - Status of KeSetEvent


    We return STATUS_MORE_PROCESSING_REQUIRED to prevent the IRP completion
    code from processing this puppy any more.

--*/

{
    DISCARDABLE_CODE( BowserDiscardableCodeSection );
    dprintf(DPRT_TDI, ("CompleteTdiRequest: %lx\n", Context));

    //
    //  Set the event to the Signalled state with 0 priority increment and
    //  indicate that we will not be blocking soon.
    //

    KeSetEvent((PKEVENT )Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

    //  Quiet the compiler.

    if (Irp || DeviceObject){};
}

typedef struct _SEND_DATAGRAM_CONTEXT {
    PTDI_CONNECTION_INFORMATION ConnectionInformation;
    PVOID Header;
    BOOLEAN WaitForCompletion;
    KEVENT Event;
} SEND_DATAGRAM_CONTEXT, *PSEND_DATAGRAM_CONTEXT;


NTSTATUS
BowserSendDatagram (
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN WaitForCompletion,
    IN PSTRING DestinationAddress OPTIONAL,
    IN BOOLEAN IsHostAnnouncement
    )

/*++

Routine Description:

    This routine sends a datagram to the specified domain.

Arguments:

    Domain - the name of the domain to send to.
                Please note that the DOMAIN is padded with spaces and
                terminated with the appropriate signature byte (00 or 07).

    Buffer - the message to send.

    BufferLength - the length of the buffer,

    IsHostAnnouncement - True if the datagram is a host announcement

Return Value:

    NTSTATUS - results of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG connectionInformationSize;
    PIRP irp = NULL;
    PMDL mdlAddress = NULL;
    PSEND_DATAGRAM_CONTEXT context = NULL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
//    PTRANSPORT_NAME TComputerName;
    ANSI_STRING AnsiString;
    UCHAR IpxPacketType;
    PFILE_OBJECT    FileObject = NULL;
    PDEVICE_OBJECT  DeviceObject;
    PVOID pBuffToFree = Buffer;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    //
    // Ensure the computername has been registered for this transport
    //
    if ( Transport->ComputerName == NULL ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        Status = STATUS_BAD_NETWORK_PATH;
        goto Cleanup;
    }

    //
    // Ensure the Device and File object are known.
    //

    if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
        DeviceObject = Transport->ComputerName->DeviceObject;
        FileObject = Transport->ComputerName->FileObject;
    } else {
        DeviceObject = Transport->IpxSocketDeviceObject;
        FileObject = Transport->IpxSocketFileObject;
    }

    if ( DeviceObject == NULL || FileObject == NULL ) {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
        Status = STATUS_BAD_NETWORK_PATH;
        goto Cleanup;
    }

    if ( FileObject != NULL ) {
        ObReferenceObject( FileObject );
    }
    ExReleaseResourceLite(&BowserTransportDatabaseResource);


    //
    // Allocate a context describing this datagram send.
    //

    context = ALLOCATE_POOL(NonPagedPool, sizeof(SEND_DATAGRAM_CONTEXT), POOL_SENDDATAGRAM);

    if ( context == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    context->Header = NULL;
    context->ConnectionInformation = NULL;

    connectionInformationSize = sizeof(TDI_CONNECTION_INFORMATION) +
                                                max(sizeof(TA_NETBIOS_EX_ADDRESS),
                                                    sizeof(TA_IPX_ADDRESS));

    if (Domain == NULL) {
        Domain = &Transport->DomainInfo->DomUnicodeDomainName;
    }

    if (FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
        PSMB_IPX_NAME_PACKET NamePacket;
        OEM_STRING NetBiosName;

        context->Header = ALLOCATE_POOL(NonPagedPool, BufferLength + sizeof(SMB_IPX_NAME_PACKET), POOL_SENDDATAGRAM);

        if ( context->Header == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NamePacket = context->Header;

        RtlZeroMemory(NamePacket->Route, sizeof(NamePacket->Route));

        NamePacket->Operation = SMB_IPX_MAILSLOT_SEND;

        switch (NameType) {
        case BrowserElection:
            if ( IsHostAnnouncement ) {
                NamePacket->NameType = SMB_IPX_NAME_TYPE_BROWSER;
            } else {
                NamePacket->NameType = SMB_IPX_NAME_TYPE_WORKKGROUP;
            }
            break;
        case ComputerName:
        case AlternateComputerName:
            NamePacket->NameType = SMB_IPX_NAME_TYPE_MACHINE;
            break;
        case MasterBrowser:
            NamePacket->NameType = SMB_IPX_NAME_TYPE_WORKKGROUP;
            break;
        //
        // Don't send on name types that direct host IPX can't handle.
        //
        // Domain(1B): Direct host IPX datagram receivers aren't particular
        // about the 16th byte of the netbios name.  Therefore, all of them
        // accept a Domain<1B> datagram.  However, such sends are destined
        // only to the PDC.
        //
        // Domain(1C): Domain(1C) is registered only by NT DCs.  However,
        // NT DCs don't completely support direct host IPX.  But they do
        // completely support NwLnkNb.
        //
        // We silently ingore these errors allowing the caller to duplicate
        // the send on NwLnkNb.

        case PrimaryDomainBrowser:
        case DomainName:

            Status = STATUS_SUCCESS;
            goto Cleanup;

        //
        // Fail on sends to non-sensical name types.
        //
        //  DomainAnnouncements aren't sent separately.
        //

        default:
            // Silently ignore the
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto Cleanup;
        }

        NamePacket->MessageId = 0;

        NetBiosName.Length = 0;
        NetBiosName.MaximumLength = SMB_IPX_NAME_LENGTH;
        NetBiosName.Buffer = NamePacket->Name;

        Status = RtlUpcaseUnicodeStringToOemString(&NetBiosName, Domain, FALSE);

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        RtlCopyMemory(&NetBiosName.Buffer[NetBiosName.Length], "                ",
                                    SMB_IPX_NAME_LENGTH-NetBiosName.Length);

        NamePacket->Name[SMB_IPX_NAME_LENGTH-1] = WORKSTATION_SIGNATURE;

        RtlCopyMemory(NamePacket->SourceName, ((PTA_NETBIOS_ADDRESS)(Transport->ComputerName->TransportAddress.Buffer))->Address[0].Address->NetbiosName, SMB_IPX_NAME_LENGTH);

        RtlCopyMemory((NamePacket+1), Buffer, BufferLength);

        // Replace Buffer w/ IPX modified one.
        // - ensure cleanup will free input Buffer.
        ASSERT(Buffer == pBuffToFree);
        FREE_POOL(Buffer);
        pBuffToFree = NULL; // cleanup will free context->Header
        Buffer = context->Header;

        BufferLength += sizeof(SMB_IPX_NAME_PACKET);

    } else {
        // ensure consistency
        ASSERT(Buffer == pBuffToFree);
        context->Header = Buffer;
        pBuffToFree = NULL; // don't cleanup for async case.
    }

    context->ConnectionInformation = ALLOCATE_POOL(NonPagedPool,
                                connectionInformationSize, POOL_CONNECTINFO
                                );

    if ( context->ConnectionInformation == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    context->ConnectionInformation->UserDataLength = 0;
    context->ConnectionInformation->UserData = NULL;
    context->ConnectionInformation->OptionsLength = 0;
    context->ConnectionInformation->Options = NULL;

    AnsiString.Buffer = (PCHAR)(context->ConnectionInformation + 1);
    AnsiString.MaximumLength = (USHORT)(connectionInformationSize - sizeof(TDI_CONNECTION_INFORMATION));

    context->ConnectionInformation->RemoteAddress = AnsiString.Buffer;

    context->WaitForCompletion = WaitForCompletion;

//    ComputerName = Transport->ComputerName;

    if (!ARGUMENT_PRESENT(DestinationAddress)) {

        //
        //  If this is for our primary domain, and the request is destined
        //  for the master browser name, then stick in the address of our
        //  master browser if we know it.
        //

        if ((RtlCompareMemory(Domain->Buffer, ((PTA_NETBIOS_ADDRESS)(Transport->ComputerName->TransportAddress.Buffer))->Address[0].Address->NetbiosName, SMB_IPX_NAME_LENGTH) == SMB_IPX_NAME_LENGTH) &&
            ( NameType == MasterBrowser ) &&
            (Transport->PagedTransport->MasterBrowserAddress.Length != 0) ) {

            //
            //  This is for our domain.  If it's for our master browser
            //  and we know who that is, we're done - copy over the master's address
            //  and send it.
            //

            ASSERT (Transport->PagedTransport->MasterBrowserAddress.Length == sizeof(TA_IPX_ADDRESS));

            RtlCopyMemory(context->ConnectionInformation->RemoteAddress,
                            Transport->PagedTransport->MasterBrowserAddress.Buffer,
                            Transport->PagedTransport->MasterBrowserAddress.Length);

            //
            // This is a directed packet, don't broadcast it.
            //
            IpxPacketType = IPX_DIRECTED_PACKET;
            context->ConnectionInformation->OptionsLength = sizeof(IpxPacketType);
            context->ConnectionInformation->Options = &IpxPacketType;

        } else if (FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {

            PTA_IPX_ADDRESS IpxAddress = (PTA_IPX_ADDRESS)AnsiString.Buffer;

            IpxAddress->TAAddressCount = 1;
            IpxAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
            IpxAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IPX;

            IpxAddress->Address[0].Address[0].NetworkAddress = 0;
            IpxAddress->Address[0].Address[0].NodeAddress[0] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[1] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[2] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[3] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[4] = 0xff;
            IpxAddress->Address[0].Address[0].NodeAddress[5] = 0xff;
            IpxAddress->Address[0].Address[0].Socket = SMB_IPX_MAILSLOT_SOCKET;

        } else {

            Status = BowserBuildTransportAddress(&AnsiString,
                                    Domain,
                                    NameType,
                                    Transport);

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            context->ConnectionInformation->RemoteAddressLength = AnsiString.Length;
        }

    } else {

        //
        //  This is already correctly formatted, so just put it on the wire.
        //

        RtlCopyMemory(context->ConnectionInformation->RemoteAddress, DestinationAddress->Buffer, DestinationAddress->Length);
        context->ConnectionInformation->RemoteAddressLength = DestinationAddress->Length;

        //
        // This is a directed packet, don't broadcast it.
        //
        IpxPacketType = IPX_DIRECTED_PACKET;
        context->ConnectionInformation->OptionsLength = sizeof(IpxPacketType);
        context->ConnectionInformation->Options = &IpxPacketType;

    }

    irp = IoAllocateIrp( DeviceObject->StackSize, TRUE);

    if (irp == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    mdlAddress = IoAllocateMdl(Buffer, BufferLength, FALSE, FALSE, NULL);

    if (mdlAddress == NULL) {
        IoFreeIrp(irp);
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KeInitializeEvent(&context->Event, NotificationEvent, FALSE);

    MmBuildMdlForNonPagedPool(mdlAddress);

    ASSERT (KeGetCurrentIrql() == 0);

    TdiBuildSendDatagram( irp,
                          DeviceObject,
                          FileObject,
                          CompleteSendDatagram,
                          context,
                          mdlAddress,
                          BufferLength,
                          context->ConnectionInformation);


    Status = IoCallDriver(DeviceObject, irp);

    ASSERT (KeGetCurrentIrql() == 0);

    if (WaitForCompletion) {

        ASSERT (KeGetCurrentIrql() == 0);
        if (Status == STATUS_PENDING) {
            Status = KeWaitForSingleObject(&context->Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

        }

        IoFreeMdl(irp->MdlAddress);

        //
        //  Retrieve the status from the IRP.
        //

        Status = irp->IoStatus.Status;

        IoFreeIrp(irp);

    } else {
        //
        // Let completion routine free the context
        //
        context = NULL;
    }

    ASSERT (KeGetCurrentIrql() == 0);

    //
    // Free locally used resources
    //
Cleanup:

    if ( context != NULL ) {
        if ( context->Header != NULL &&
             context->Header != pBuffToFree ) {
            FREE_POOL( context->Header );
        }
        if (context->ConnectionInformation != NULL ) {
            FREE_POOL(context->ConnectionInformation);
        }
        FREE_POOL(context);
    }

    if (pBuffToFree) {
        FREE_POOL( pBuffToFree );
    }

    if ( FileObject != NULL ) {
        ObDereferenceObject( FileObject );
    }
    return Status;

} // BowserSendDatagram

NTSTATUS
CompleteSendDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Ctx
    )

/*++

Routine Description:

    Completion routine for SubmitTdiRequest operation.

Arguments:

    IN PDEVICE_OBJECT DeviceObject, - Supplies a pointer to the device object
    IN PIRP Irp, - Supplies the IRP submitted
    IN PVOID Context - Supplies a pointer to the kernel event to release

Return Value:

    NTSTATUS - Status of KeSetEvent


    We return STATUS_MORE_PROCESSING_REQUIRED to prevent the IRP completion
    code from processing this puppy any more.

--*/

{
    PSEND_DATAGRAM_CONTEXT Context = Ctx;

    dprintf(DPRT_TDI, ("CompleteTdiRequest: %lx\n", Context));

    if (Context->WaitForCompletion) {

        //
        //  Set the event to the Signalled state with 0 priority increment and
        //  indicate that we will not be blocking soon.
        //

        KeSetEvent(&Context->Event, 0, FALSE);

    } else {
        FREE_POOL(Context->ConnectionInformation);

        FREE_POOL(Context->Header);

        FREE_POOL(Context);

        IoFreeMdl(Irp->MdlAddress);

        IoFreeIrp(Irp);

    }
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER(DeviceObject);
}




NTSTATUS
BowserSendSecondClassMailslot (
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain OPTIONAL,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Message,
    IN ULONG MessageLength,
    IN BOOLEAN WaitForCompletion,
    IN PCHAR mailslotNameData,
    IN PSTRING DestinationAddress OPTIONAL
    )
{
    ULONG dataSize;
    ULONG transactionDataSize;
    ULONG smbSize;
    PSMB_HEADER header;
    PSMB_TRANSACT_MAILSLOT parameters;
    PSZ mailslotName;
    ULONG mailslotNameLength;
    PSZ domainInData;
    PVOID message;
    NTSTATUS status;

    PAGED_CODE();
    //
    // Determine the sizes of various fields that will go in the SMB
    // and the total size of the SMB.
    //

    mailslotNameLength = strlen( mailslotNameData );

    transactionDataSize = MessageLength;
    dataSize = mailslotNameLength + 1 + transactionDataSize;
    smbSize = sizeof(SMB_HEADER) + sizeof(SMB_TRANSACT_MAILSLOT) - 1 + dataSize;

    header = ALLOCATE_POOL( NonPagedPool, smbSize, POOL_MAILSLOT_HEADER );
    if ( header == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill in the header.  Most of the fields don't matter and are
    // zeroed.
    //

    RtlZeroMemory( header, smbSize );

    header->Protocol[0] = 0xFF;
    header->Protocol[1] = 'S';
    header->Protocol[2] = 'M';
    header->Protocol[3] = 'B';
    header->Command = SMB_COM_TRANSACTION;

    //
    // Get the pointer to the params and fill them in.
    //

    parameters = (PSMB_TRANSACT_MAILSLOT)( header + 1 );
    mailslotName = (PSZ)( parameters + 1 ) - 1;
    domainInData = mailslotName + mailslotNameLength + 1;
    message = domainInData;

    parameters->WordCount = 0x11;
    SmbPutUshort( &parameters->TotalDataCount, (USHORT)transactionDataSize );
    SmbPutUlong( &parameters->Timeout, 0x3E8 );                // !!! fix
    SmbPutUshort( &parameters->DataCount, (USHORT)transactionDataSize );
    SmbPutUshort(
        &parameters->DataOffset,
        (USHORT)( (ULONG_PTR)message - (ULONG_PTR)header )
        );
    parameters->SetupWordCount = 3;
    SmbPutUshort( &parameters->Opcode, MS_WRITE_OPCODE );
    SmbPutUshort( &parameters->Priority, 1);
    SmbPutUshort( &parameters->Class, 2 );
    SmbPutUshort( &parameters->ByteCount, (USHORT)dataSize );

    RtlCopyMemory( mailslotName, mailslotNameData, mailslotNameLength + 1 );
    RtlCopyMemory( message, Message, MessageLength );

    //
    // Send the actual mailslot message.
    //

    status = BowserSendDatagram( Transport,
                                 Domain,
                                 NameType,
                                 header,
                                 smbSize,
                                 WaitForCompletion,
                                 DestinationAddress,
                                 (BOOLEAN)(((PHOST_ANNOUNCE_PACKET)Message)->AnnounceType == LocalMasterAnnouncement) );

    return status;

} // BowserSendSecondClassMailslot


NTSTATUS
BowserSendRequestAnnouncement(
    IN PUNICODE_STRING DestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    )
{
    REQUEST_ANNOUNCE_PACKET AnnounceRequest;
    ULONG AnnouncementRequestLength;
    NTSTATUS Status;

    PAGED_CODE();
    //
    // If we don't
    AnnounceRequest.Type = AnnouncementRequest;

    AnnounceRequest.RequestAnnouncement.Flags = 0;

    strcpy( AnnounceRequest.RequestAnnouncement.Reply,
            Transport->DomainInfo->DomOemComputerName.Buffer );

    AnnouncementRequestLength = FIELD_OFFSET(REQUEST_ANNOUNCE_PACKET, RequestAnnouncement.Reply) +
                                Transport->DomainInfo->DomOemComputerName.Length + 1;

    Status = BowserSendSecondClassMailslot(Transport,
                                    DestinationName,
                                    NameType,
                                    &AnnounceRequest,
                                    AnnouncementRequestLength,
                                    TRUE,
                                    MAILSLOT_BROWSER_NAME,
                                    NULL);

    return Status;
}

VOID
BowserpInitializeTdi (
    VOID
    )

/*++

Routine Description:

    This routine initializes the global variables used in the transport
    package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the Transport list chain
    //

    InitializeListHead(&BowserTransportHead);

    ExInitializeResourceLite(&BowserTransportDatabaseResource);

    KeInitializeSpinLock(&BowserTransportMasterNameSpinLock);

    BowserInitializeDomains();
}

VOID
BowserpUninitializeTdi (
    VOID
    )

/*++

Routine Description:

    This routine initializes the global variables used in the transport
    package.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    ASSERT (IsListEmpty(&BowserTransportHead));

    ExDeleteResourceLite(&BowserTransportDatabaseResource);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowtdi.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    tdi.h

Abstract:

    This module defines all the constructs that are used when referencing
    the TDI (Transport Driver Interface) driver in NT.

Author:

    Larry Osterman (LarryO) 1-Jun-1990

Revision History:

    1-Jun-1990  LarryO

        Created

--*/
#ifndef _BOWTDI_
#define _BOWTDI_


struct _TRANSPORT;

struct _TRANSPORT_NAME;

struct _BOWSER_TIMER;

typedef enum {
    None,
    PotentialBackup,
    Backup,
    Master
} BROWSERROLE, *PBROWSERROLES;

typedef enum {
    Idle,
    ElectionInProgress,
    RunningElection,
    DeafToElections                     // Set if no become master IRPs outstanding.
} ELECTIONROLE, *PELECTIONROLE;

struct _PAGED_TRANSPORT;
struct _PAGED_TRANSPORT_NAME;


typedef struct _TRANSPORT {
    CSHORT Signature;                   // Structure signature.
    CSHORT Size;                        // Structure size in bytes.
    ULONG ReferenceCount;               // Reference count for structure.

    struct _PAGED_TRANSPORT *PagedTransport;

    struct _TRANSPORT_NAME *ComputerName; // Computer name.
    struct _TRANSPORT_NAME *PrimaryDomain;// Primary domain.
    struct _TRANSPORT_NAME *AltPrimaryDomain;// Primary domain.
    struct _TRANSPORT_NAME *MasterBrowser;// Master browser name.
    struct _TRANSPORT_NAME *BrowserElection;// Master browser name.

    PDOMAIN_INFO DomainInfo;            // Domain being emulated.

    ULONG DatagramSize;                 // Size of largest DG in bytes.

    //
    //  The token is used to match incoming getbrowserserverlist responses with
    //  the request that they are associated with.
    //
    //  It is protected by the backup list spin lock, and is incremented every
    //  time we send a GetBackupList request.
    //

    ULONG BrowserServerListToken;       // Token for GetBrowserList request.

    PFILE_OBJECT    IpxSocketFileObject;
    PDEVICE_OBJECT  IpxSocketDeviceObject;

    PBACKUP_LIST_RESPONSE_1 BowserBackupList;

    //
    //  Role of workstation in election.
    //

    ELECTIONROLE ElectionState;

    ERESOURCE AnnounceTableLock;        // Lock for announce table.
    ERESOURCE Lock;                     // Lock protecting fields below.

    BOWSER_TIMER ElectionTimer;

    BOWSER_TIMER FindMasterTimer;

    //
    //  List of browser servers active
    //

    ERESOURCE BrowserServerListResource;// Resource protecting BrowserServerList.

    KEVENT GetBackupListComplete;

    IRP_QUEUE BecomeBackupQueue;

    IRP_QUEUE BecomeMasterQueue;

    IRP_QUEUE FindMasterQueue;

    IRP_QUEUE WaitForMasterAnnounceQueue;

    IRP_QUEUE ChangeRoleQueue;

    IRP_QUEUE WaitForNewMasterNameQueue;

} TRANSPORT, *PTRANSPORT;

typedef struct _PAGED_TRANSPORT {
    CSHORT Signature;                   // Structure signature.
    CSHORT Size;                        // Structure size in bytes.
    PTRANSPORT NonPagedTransport;

    LIST_ENTRY GlobalNext;              // Pointer to next transport.
    LIST_ENTRY NameChain;               // List of names bound to this xport.

    UNICODE_STRING TransportName;       // Name of transport

    ULONG NumberOfBrowserServers;       // Number of browser servers in table.
    ULONG NumberOfServersInTable;       // Number of servers in browser svc.
    RTL_GENERIC_TABLE AnnouncementTable; // Announcement table for xport
    RTL_GENERIC_TABLE DomainTable;      // Domain table for xport
    LIST_ENTRY BackupBrowserList;       // List of active backup browsers.
    ULONG NumberOfBackupServerListEntries;
    HANDLE          IpxSocketHandle;

    //
    //  WinBALL compatible browser fields.
    //

    BROWSERROLE Role;                   // Role of browser in domain.
    ULONG ServiceStatus;                // Status of browser service.

    ULONG ElectionCount;
    ULONG ElectionsSent;                // Number of election requests sent.
    ULONG NextElection;
    ULONG Uptime;
    ULONG TimeLastLost;
    ULONG ElectionCriteria;
    ULONG TimeMaster;                   // The time we became the master.
    ULONG LastElectionSeen;             // The last time we saw an election.
    ULONG OtherMasterTime;              // Next time we can complain about another master browser

    UNICODE_STRING MasterName;
    STRING         MasterBrowserAddress;

    PWCHAR *BrowserServerListBuffer;    // Buffer containing browser server names

    ULONG BrowserServerListLength;      // Number of browser servers in list.

    ULONG IpSubnetNumber;               //

    USHORT  Flags;                      // Flags for transport.
#define ELECT_LOST_LAST_ELECTION    0x0001  // True if we lost the last election.
#define DIRECT_HOST_IPX             0x8000  // True if Xport is a direct host IPX

    BOOLEAN Wannish;                    // True if transport is wannish.
    BOOLEAN PointToPoint;               // True if transport is a gateway (RAS).
    BOOLEAN IsPrimaryDomainController;  // True if transport has the Domain[1B] name registered
    BOOLEAN DisabledTransport;          // True if transport is disabled
    BOOLEAN DeletedTransport;           // True if transport has been deleted

} PAGED_TRANSPORT, *PPAGED_TRANSPORT;




typedef struct _TRANSPORT_NAME {
    USHORT  Signature;                   // Structure signature.
    USHORT  Size;                       // Structure size in bytes.
    CHAR    NameType;
    BOOLEAN ProcessHostAnnouncements;   // TRUE if processing announcements.
    LONG    ReferenceCount;             // Reference count for T.N.
    struct _PAGED_TRANSPORT_NAME *PagedTransportName;
    PTRANSPORT Transport;
    PFILE_OBJECT FileObject;            // File object for transport device
    PDEVICE_OBJECT DeviceObject;        // Device object for transport
    ANSI_STRING  TransportAddress;      // Transport address for user.
} TRANSPORT_NAME, *PTRANSPORT_NAME;

typedef struct _PAGED_TRANSPORT_NAME {
    CSHORT Signature;                   // Structure signature.
    CSHORT Size;                        // Structure size in bytes.
    PTRANSPORT_NAME NonPagedTransportName;
    PBOWSER_NAME Name;
    LIST_ENTRY TransportNext;           // Pointer to next name on transport.
    LIST_ENTRY NameNext;                // Pointer to next name on bowser name.
    HANDLE Handle;                      // Handle to transport endpoint
} PAGED_TRANSPORT_NAME, *PPAGED_TRANSPORT_NAME;

#define LOCK_TRANSPORT(Transport)   \
    ExAcquireResourceExclusiveLite(&(Transport)->Lock, TRUE);

#define LOCK_TRANSPORT_SHARED(Transport)   \
    ExAcquireResourceSharedLite(&(Transport)->Lock, TRUE);

#define UNLOCK_TRANSPORT(Transport) \
    ExReleaseResourceLite(&(Transport)->Lock);


#define INITIALIZE_ANNOUNCE_DATABASE(Transport) \
    ExInitializeResourceLite(&Transport->AnnounceTableLock);

#define UNINITIALIZE_ANNOUNCE_DATABASE(Transport) \
    ExDeleteResourceLite(&Transport->AnnounceTableLock);


#define LOCK_ANNOUNCE_DATABASE_SHARED(Transport)        \
    ExAcquireResourceSharedLite(&Transport->AnnounceTableLock,\
                            TRUE                        \
                            );

#define LOCK_ANNOUNCE_DATABASE(Transport)               \
    ExAcquireResourceExclusiveLite(&Transport->AnnounceTableLock,\
                            TRUE                        \
                            );

#define UNLOCK_ANNOUNCE_DATABASE(Transport) \
    ExReleaseResourceLite(&Transport->AnnounceTableLock);


//
//  The first parameter to the BowserEnumerateTransports routine.
//

typedef
NTSTATUS
(*PTRANSPORT_ENUM_ROUTINE) (
    IN PTRANSPORT Transport,
    IN OUT PVOID Context
    );

typedef
NTSTATUS
(*PTRANSPORT_NAME_ENUM_ROUTINE) (
    IN PTRANSPORT_NAME Transport,
    IN OUT PVOID Context
    );


//
//  TDI Interface routines
//

NTSTATUS
BowserTdiAllocateTransport (
    PUNICODE_STRING TransportName,
    PUNICODE_STRING EmulatedDomainName,
    PUNICODE_STRING EmulatedComputerName
    );

PTRANSPORT_NAME
BowserFindTransportName(
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserCreateTransportName (
    IN PTRANSPORT Transport,
    IN PBOWSER_NAME Name
    );

NTSTATUS
BowserFreeTransportByName (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName
    );

NTSTATUS
BowserUnbindFromAllTransports(
    VOID
    );

NTSTATUS
BowserDeleteTransportNameByName(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType
    );

NTSTATUS
BowserEnumerateTransports (
    OUT PVOID OutputBuffer,
    OUT ULONG OutputBufferLength,
    IN OUT PULONG EntriesRead,
    IN OUT PULONG TotalEntries,
    IN OUT PULONG TotalBytesNeeded,
    IN ULONG_PTR OutputBufferDisplacement);

PTRANSPORT
BowserFindTransport (
    IN PUNICODE_STRING TransportName,
    IN PUNICODE_STRING EmulatedDomainName OPTIONAL
    );

VOID
BowserReferenceTransport (
    IN PTRANSPORT Transport
    );

VOID
BowserDereferenceTransport (
    IN PTRANSPORT Transport
    );


VOID
BowserReferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    );

NTSTATUS
BowserDereferenceTransportName(
    IN PTRANSPORT_NAME TransportName
    );

NTSTATUS
BowserSendRequestAnnouncement(
    IN PUNICODE_STRING DestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    );

VOID
BowserpInitializeTdi (
    VOID
    );

VOID
BowserpUninitializeTdi (
    VOID
    );

NTSTATUS
BowserBuildTransportAddress (
    OUT PANSI_STRING RemoteAddress,
    IN PUNICODE_STRING Name,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PTRANSPORT Transport
    );

NTSTATUS
BowserFreeTransportName(
    IN PTRANSPORT_NAME TransportName
    );

NTSTATUS
BowserForEachTransportInDomain (
    IN PDOMAIN_INFO DomainInfo,
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserForEachTransport (
    IN PTRANSPORT_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserForEachTransportName (
    IN PTRANSPORT Transport,
    IN PTRANSPORT_NAME_ENUM_ROUTINE Routine,
    IN OUT PVOID Context
    );

NTSTATUS
BowserSendSecondClassMailslot (
    IN PTRANSPORT Transport,
    IN PVOID RecipientAddress,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Message,
    IN ULONG MessageLength,
    IN BOOLEAN WaitForCompletion,
    IN PCHAR mailslotNameData,
    IN PSTRING DestinationAddress OPTIONAL
    );

NTSTATUS
BowserUpdateProviderInformation(
    IN OUT PPAGED_TRANSPORT PagedTransport
    );

NTSTATUS
BowserSetDomainName(
    PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING DomainName
    );

NTSTATUS
BowserAddDefaultNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

NTSTATUS
BowserDeleteDefaultDomainNames(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

ULONG
BowserTransportFlags(
    IN PPAGED_TRANSPORT PagedTransport
    );

extern
LIST_ENTRY
BowserTransportHead;

extern
ERESOURCE
BowserTransportDatabaseResource;

#endif  // _BOWTDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\brsrvlst.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brsrvlst.c.

Abstract:

    This module implements the routines to manipulate WinBALL browser server
    lists.


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/

#define INCLUDE_SMB_TRANSACTION

#include "precomp.h"
#pragma hdrstop

#define SECONDS_PER_ELECTION (((((ELECTION_DELAY_MAX - ELECTION_DELAY_MIN) / 2)*ELECTION_COUNT) + 999) / 1000)

LARGE_INTEGER
BowserGetBrowserListTimeout = {0};

VOID
BowserGetBackupListWorker(
    IN PVOID Ctx
    );

NTSTATUS
BowserSendBackupListRequest(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain
    );

NTSTATUS
AddBackupToBackupList(
    IN PCHAR *BackupPointer,
    IN PCHAR BackupListStart,
    IN PANNOUNCE_ENTRY ServerEntry
    );

KSPIN_LOCK
BowserBackupListSpinLock = {0};

#define BOWSER_BACKUP_LIST_RESPONSE_SIZE    1024

NTSTATUS
BowserCheckForPrimaryBrowserServer(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

PVOID
BowserGetBackupServerListFromTransport(
    IN PTRANSPORT Transport
    );

VOID
BowserFreeTransportBackupList(
    IN PTRANSPORT Transport
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFreeBrowserServerList)
#pragma alloc_text(PAGE, BowserShuffleBrowserServerList)
#pragma alloc_text(INIT, BowserpInitializeGetBrowserServerList)
#pragma alloc_text(PAGE, BowserpUninitializeGetBrowserServerList)
#pragma alloc_text(PAGE, BowserSendBackupListRequest)
#pragma alloc_text(PAGE, BowserGetBackupListWorker)
#pragma alloc_text(PAGE, AddBackupToBackupList)
#pragma alloc_text(PAGE, BowserGetBrowserServerList)
#pragma alloc_text(PAGE, BowserCheckForPrimaryBrowserServer)
#pragma alloc_text(PAGE4BROW, BowserGetBackupServerListFromTransport)
#pragma alloc_text(PAGE4BROW, BowserFreeTransportBackupList)
#endif

VOID
BowserFreeBrowserServerList (
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength
    )

/*++

Routine Description:

    This routine will free the list of browser servers associated with
    a transport.

Arguments:

    IN PTRANSPORT Transport - Supplies the transport whose buffer is to be freed

Return Value:

    None.

--*/
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < BrowserServerListLength ; i++) {
        FREE_POOL(BrowserServerList[i]);
    }

    FREE_POOL(BrowserServerList);

}

#define Swap(a,b)       \
    {                   \
        PWSTR t = a;    \
        a = b;          \
        b = t;          \
    }

NTSTATUS
BowserCheckForPrimaryBrowserServer(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{
    PWSTR ServerName = Context;

    PAGED_CODE();

    //
    // Grab a lock on the BrowserServerList for this transport.
    //
    // Since this call is made with the BrowserServerList exclusively locked for one of the
    // transports, we can't wait for the lock (there would be an implicit violation of the
    // locking order).
    //
    // However, since this call is simply being used as an optimization, we'll simply skip
    //  the check when we have contention.
    //

    if (!ExAcquireResourceSharedLite(&Transport->BrowserServerListResource, FALSE)) {
        return STATUS_SUCCESS;
    }

    if (Transport->PagedTransport->BrowserServerListBuffer != NULL) {

        if (!_wcsicmp(ServerName, Transport->PagedTransport->BrowserServerListBuffer[0])) {
            ExReleaseResourceLite(&Transport->BrowserServerListResource);
            return STATUS_UNSUCCESSFUL;

        }
    }

    ExReleaseResourceLite(&Transport->BrowserServerListResource);
    return STATUS_SUCCESS;
}

VOID
BowserShuffleBrowserServerList(
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength,
    IN BOOLEAN IsPrimaryDomain,
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    This routine will shuffle the list of browser servers associated with
    a transport.

Arguments:


Return Value:

    None.

Note:
    We rely on the fact that the DLL will always pick the 0th entry in the
    list for the server to remote the API to.  We will first shuffle the
    list completely, then, if this is our primary domain, we will
    walk the list of domains and check to see if this entry is the 0th
    entry on any of the transports.  If it isn't, then we swap this entry
    with the 0th entry and return, since we've guaranteed that it's ok on
    all the other transports.


--*/
{
    ULONG NewIndex;
    ULONG i;
    PAGED_CODE();
    ASSERT ( BrowserServerListLength != 0 );

    //
    //  First thoroughly shuffle the list.
    //

    for (i = 0 ; i < BrowserServerListLength ; i++ ) {
        NewIndex = BowserRandom(BrowserServerListLength);

        Swap(BrowserServerList[i], BrowserServerList[NewIndex]);
    }

    //
    //  If we are querying our primary domain, we want to make sure that we
    //  don't have this server as the primary server for any other transports.
    //
    //
    //  The reason for this is that the NT product 1 redirector cannot connect
    //  to the same server on different transports, so it has to disconnect and
    //  reconnect to that server.  We can avoid this disconnect/reconnect
    //  overhead by making sure that the primary browse server (the 0th entry
    //  in the browse list) is different for all transports.
    //

    if (IsPrimaryDomain) {

        //
        //  Now walk through the server list and if the server at this index
        //  is the 0th entry for another transport, we want to swap it with the
        //  ith entry and keep on going.
        //

        for (i = 0 ; i < BrowserServerListLength ; i++ ) {
            if (NT_SUCCESS(BowserForEachTransportInDomain(DomainInfo, BowserCheckForPrimaryBrowserServer, BrowserServerList[i]))) {

                Swap(BrowserServerList[0], BrowserServerList[i]);

                //
                //  This server isn't the primary browser server for any other
                //  transports, we can return now, since we're done.
                //

                break;
            }
        }
    }
}

PVOID
BowserGetBackupServerListFromTransport(
    IN PTRANSPORT Transport
    )
{
    KIRQL OldIrql;
    PVOID BackupList;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserBackupListSpinLock, &OldIrql);

    BackupList = Transport->BowserBackupList;

    Transport->BowserBackupList = NULL;

    RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);

    return BackupList;
}

VOID
BowserFreeTransportBackupList(
    IN PTRANSPORT Transport
    )
{
    KIRQL OldIrql;
    PVOID BackupList;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserBackupListSpinLock, &OldIrql);

    if (Transport->BowserBackupList != NULL) {

        BackupList = Transport->BowserBackupList;

        Transport->BowserBackupList = NULL;

        RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);

        FREE_POOL(BackupList);

    } else {
        RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);
    }

}

NTSTATUS
BowserGetBrowserServerList(
    IN PIRP Irp,
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PWSTR **BrowserServerList,
    OUT PULONG BrowserServerListLength
    )
/*++

Routine Description:

    This routine is the indication time processing needed to get a backup
    list response.

Arguments:

    IN PTRANSPORT_NAME TransportName - Supplies the transport name receiving
                    the request.
    IN PBACKUP_LIST_RESPONSE_1 BackupList - Supplies the backup server list

    IN ULONG BytesAvailable - Supplies the # of bytes in the message

    OUT PULONG BytesTaken;

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PUCHAR BackupPointer;
    ULONG i;
    PBACKUP_LIST_RESPONSE_1 BackupList = NULL;
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

    PAGED_CODE();

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

//    ASSERT (ExIsResourceAcquiredExclusiveLite(&Transport->BrowserServerListResource));

    //
    //  Initialize the browser server list to a known state.
    //

    *BrowserServerList = NULL;
    *BrowserServerListLength = 0;

    ASSERT (Transport->BowserBackupList == NULL);

    try {
        ULONG RetryCount = BOWSER_GETBROWSERLIST_RETRY_COUNT;

        //
        //  Allocate and save a buffer to hold the response server names.
        //

        Transport->BowserBackupList = ALLOCATE_POOL(NonPagedPool, Transport->DatagramSize, POOL_BACKUPLIST);

        if (Transport->BowserBackupList == NULL) {

            try_return(Status = STATUS_INSUFFICIENT_RESOURCES);

        }

        //
        //  This is a new request, so bump the token to indicate that this is
        //  a new GetBrowserServerList request.
        //

        ExInterlockedAddUlong(&Transport->BrowserServerListToken, 1, &BowserBackupListSpinLock);

        //
        //  We retry for 3 times, and we timeout the wait after 1 seconds.
        //  This means that in the worse case this routine takes 4 seconds
        //  to execute.
        //
        //

        while (RetryCount --) {
            ULONG Count = 0;

            //
            // Set the completion event to the not-signalled state.
            //

            KeResetEvent(&Transport->GetBackupListComplete);

            //
            //  Send the backup server list query.
            //

            Status = BowserSendBackupListRequest(Transport, DomainName);

            if (!NT_SUCCESS(Status)) {

                //
                //  If the send datagram failed, return a more browser like
                //  error.
                //

                try_return(Status = STATUS_NO_BROWSER_SERVERS_FOUND);
            }

            do {

                //
                //  Wait until either the server has responded to the request,
                //  or we give up.
                //

                Status = KeWaitForSingleObject(&Transport->GetBackupListComplete,
                                Executive,
                                KernelMode,
                                FALSE,
                                &BowserGetBrowserListTimeout);

                if (Status == STATUS_TIMEOUT) {

                    //
                    //  If this thread is terminating, then give up and return
                    //  a reasonable error to the caller.
                    //

                    if (PsIsThreadTerminating(Irp->Tail.Overlay.Thread)) {

                        Status = STATUS_CANCELLED;

                        break;
                    }
                }

            } while ( (Status == STATUS_TIMEOUT)

                                &&

                      (Count++ < BOWSER_GETBROWSERLIST_TIMEOUT) );

            //
            //  If the request succeeded, we can return
            //  right away.
            //

            if (Status != STATUS_TIMEOUT) {
                break;
            }

            //
            //  Force an election - We couldn't find a browser server.
            //

            dlog(DPRT_CLIENT,
                 ("%s: %ws: Unable to get browser server list - forcing election\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            PagedTransport->Uptime = BowserTimeUp();

            if (BowserLogElectionPackets) {
                BowserWriteErrorLogEntry(EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED, STATUS_SUCCESS, NULL, 0, 1, PagedTransport->TransportName.Buffer);
            }

        }

        //
        //  If, after all this, we still timed out, return an error.
        //

        if (Status == STATUS_TIMEOUT) {

            //
            //  If it has been less than the maximum amount of time for an election plus some
            //  slop to allow the WfW machine to add the transport, don't
            //  send the election packet.
            //

            if ((PagedTransport->Role == None)

                    ||

                ((DomainName != NULL) &&
                 !RtlEqualUnicodeString(DomainName, &Transport->DomainInfo->DomUnicodeDomainName, TRUE)
                )

                ||

                ((BowserTimeUp() - PagedTransport->LastElectionSeen) > ELECTION_TIME )
               ) {

                dlog(DPRT_ELECT,
                     ("%s: %ws: Starting election, domain %wZ.  Time Up: %lx, LastElectionSeen: %lx\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer,
                     (DomainName != NULL ? DomainName : &Transport->DomainInfo->DomUnicodeDomainName),
                     BowserTimeUp(),
                     Transport->PagedTransport->LastElectionSeen));


                BowserSendElection(DomainName,
                                   BrowserElection,
                                   Transport,
                                   FALSE);

            }

            try_return(Status = STATUS_NO_BROWSER_SERVERS_FOUND);
        }

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        //
        //  We now have a valid list of servers from the net.
        //
        //  Massage this list into a form that we can return.
        //

        BackupList = BowserGetBackupServerListFromTransport(Transport);

        *BrowserServerListLength = BackupList->BackupServerCount;

        *BrowserServerList = ALLOCATE_POOL(PagedPool | POOL_COLD_ALLOCATION, *BrowserServerListLength*sizeof(PWSTR), POOL_BROWSERSERVERLIST);

        if (*BrowserServerList == NULL) {
            try_return(Status = STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(*BrowserServerList, *BrowserServerListLength*sizeof(PWSTR));

        BackupPointer = BackupList->BackupServerList;

        for ( i = 0 ; i < (ULONG)BackupList->BackupServerCount ; i ++ ) {
            UNICODE_STRING UServerName;
            OEM_STRING AServerName;

            RtlInitAnsiString(&AServerName, BackupPointer);

            Status = RtlOemStringToUnicodeString(&UServerName, &AServerName, TRUE);

            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            (*BrowserServerList)[i] = ALLOCATE_POOL(PagedPool | POOL_COLD_ALLOCATION, UServerName.Length+(sizeof(WCHAR)*3), POOL_BROWSERSERVER);

            if ((*BrowserServerList)[i] == NULL) {
                RtlFreeUnicodeString(&UServerName);
                try_return(Status = STATUS_INSUFFICIENT_RESOURCES);
            }

            //
            //  Put "\\" at the start of the server name.
            //

            RtlCopyMemory((*BrowserServerList)[i], L"\\\\", 4);

            dlog(DPRT_CLIENT,
                 ("Packing server name %ws to %lx\n",
                 UServerName.Buffer, (*BrowserServerList)[i]));

            RtlCopyMemory(&((*BrowserServerList)[i])[2], UServerName.Buffer, UServerName.MaximumLength);

            //
            //  Bump the pointer to the backup server name.
            //

            BackupPointer += AServerName.Length + sizeof(CHAR);

            RtlFreeUnicodeString(&UServerName);

        }

        //
        //  Now shuffle the browser server list we got back from the server
        //  to ensure some degree of randomness in the choice.
        //

        BowserShuffleBrowserServerList(
            *BrowserServerList,
            *BrowserServerListLength,
            (BOOLEAN)(DomainName == NULL ||
                RtlEqualUnicodeString(&Transport->DomainInfo->DomUnicodeDomainName, DomainName, TRUE)),
            Transport->DomainInfo );

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {

        if (!NT_SUCCESS(Status)) {

            if (*BrowserServerList != NULL) {

                for ( i = 0 ; i < *BrowserServerListLength ; i ++ ) {

                    if ((*BrowserServerList)[i] != NULL) {

                        FREE_POOL((*BrowserServerList)[i]);

                    }
                }

                FREE_POOL(*BrowserServerList);

                *BrowserServerList = NULL;

            }

            *BrowserServerListLength = 0;

            BowserFreeTransportBackupList(Transport);

        }

        if (BackupList != NULL) {
            FREE_POOL(BackupList);
        }

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    }

    return Status;
}



DATAGRAM_HANDLER(
    BowserGetBackupListResponse
    )
/*++

Routine Description:

    This routine is the indication time processing needed to get a backup
    list response.

Arguments:

    IN PTRANSPORT_NAME TransportName - Supplies the transport name receiving
                    the request.
    IN PBACKUP_LIST_RESPONSE_1 BackupList - Supplies the backup server list

    IN ULONG BytesAvailable - Supplies the # of bytes in the message

    OUT PULONG BytesTaken;

Return Value:

    None.

--*/
{
    PTRANSPORT              Transport   = TransportName->Transport;
    PBACKUP_LIST_RESPONSE_1 BackupList  = Buffer;
    KIRQL                   OldIrql;
    ULONG                   StringCount = 0;
    PUCHAR                  Walker      = BackupList->BackupServerList;
    PUCHAR                  BufferEnd   = ((PUCHAR)Buffer) + BytesAvailable;

    if (Transport->BowserBackupList == NULL) {
        dprintf(DPRT_CLIENT,("BOWSER: Received GetBackupListResponse while not expecting one\n"));
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    ASSERT ( BytesAvailable <= Transport->DatagramSize );

    ACQUIRE_SPIN_LOCK(&BowserBackupListSpinLock, &OldIrql);

    //
    //  This response is for an old request - ignore it.
    //

    if (BackupList->Token != Transport->BrowserServerListToken) {
        RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);
        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    //
    //  Verify that the incoming buffer is a series of valid strings, and
    //     that the number indicated are actually present in the buffer.
    //

    while (StringCount < BackupList->BackupServerCount &&
           Walker < BufferEnd) {
        if (*Walker == '\0') {
            StringCount++;
        }
        Walker++;
    }

    if (Walker == BufferEnd) {
        if (StringCount < BackupList->BackupServerCount) {
            RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);
            return(STATUS_REQUEST_NOT_ACCEPTED);
        }
    }

    //
    //  Bump the token again to invalidate any incoming responses - they are
    //  no longer valid.
    //

    Transport->BrowserServerListToken += 1;

    if (Transport->BowserBackupList != NULL) {

        //
        //  Copy the received buffer.
        //

        TdiCopyLookaheadData(Transport->BowserBackupList, BackupList, BytesAvailable, ReceiveFlags);

        KeSetEvent(&Transport->GetBackupListComplete, IO_NETWORK_INCREMENT, FALSE);

    }

    RELEASE_SPIN_LOCK(&BowserBackupListSpinLock, OldIrql);


    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(BytesTaken);
}


NTSTATUS
BowserSendBackupListRequest(
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING Domain
    )
/*++

Routine Description:

    This routine sends a getbackup list request to the master browser server
    for a specified domain.

Arguments:

    IN PTRANSPORT_NAME TransportName - Supplies the transport name receiving
                    the request.
    IN PBACKUP_LIST_RESPONSE_1 BackupList - Supplies the backup server list

    IN ULONG BytesAvailable - Supplies the # of bytes in the message

    OUT PULONG BytesTaken;

Return Value:

    None.

--*/
{
    NTSTATUS Status, Status2;
    BACKUP_LIST_REQUEST Request;

    PAGED_CODE();

    Request.Type = GetBackupListReq;

    //
    //  Send this request.
    //

    Request.BackupListRequest.Token = Transport->BrowserServerListToken;

    //
    //  WinBALL only asks for 4 of these, so that's what I'll ask for.
    //

    Request.BackupListRequest.RequestedCount = 4;

    // ask for Master Browser
    Status = BowserSendSecondClassMailslot(Transport,
                            (Domain == NULL ?
                                    &Transport->DomainInfo->DomUnicodeDomainName :
                                    Domain),
                            MasterBrowser,
                            &Request, sizeof(Request), TRUE,
                            MAILSLOT_BROWSER_NAME,
                            NULL);



#ifdef ENABLE_PSEUDO_BROWSER
    if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX) &&
        BowserData.PseudoServerLevel != BROWSER_SEMI_PSEUDO_NO_DMB) {
#else
        if (!FlagOn(Transport->PagedTransport->Flags, DIRECT_HOST_IPX)) {
#endif
        // search for PDC
        // In some configurations, it is valid not to have a PDC, thus,
        // ignore status code (do not propagate up).
        // Do not talk to the DMB (PDC name) directly if we're semi-pseudo
        Status2 = BowserSendSecondClassMailslot(Transport,
                            (Domain == NULL ?
                                    &Transport->DomainInfo->DomUnicodeDomainName :
                                    Domain),
                            PrimaryDomainBrowser,
                            &Request, sizeof(Request), TRUE,
                            MAILSLOT_BROWSER_NAME,
                            NULL);
        // if either succeeded, we'll return success.
        Status = NT_SUCCESS(Status2) ? Status2: Status;
    }

    return (Status);
}


DATAGRAM_HANDLER(
    BowserGetBackupListRequest
    )
{
    NTSTATUS status;
    //
    //  We need to have at least enough bytes of data to read in
    //  a BACKUP_LIST_REQUEST_1 structure.
    //

    if (BytesAvailable < sizeof(BACKUP_LIST_REQUEST_1)) {

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    BowserStatistics.NumberOfGetBrowserServerListRequests += 1;

    status = BowserPostDatagramToWorkerThread(
            TransportName,
            Buffer,
            BytesAvailable,
            BytesTaken,
            SourceAddress,
            SourceAddressLength,
            SourceName,
            SourceNameLength,
            BowserGetBackupListWorker,
            NonPagedPool,
            DelayedWorkQueue,
            ReceiveFlags,
            TRUE);                  // Response will be sent.

    if (!NT_SUCCESS(status)) {
        BowserNumberOfMissedGetBrowserServerListRequests += 1;

        BowserStatistics.NumberOfMissedGetBrowserServerListRequests += 1;
        return status;
    }

    return status;
}

VOID
BowserGetBackupListWorker(
    IN PVOID Ctx
    )
{
    PPOST_DATAGRAM_CONTEXT Context = Ctx;
    PBACKUP_LIST_REQUEST_1 BackupListRequest = Context->Buffer;
    PIRP Irp = NULL;
    PTRANSPORT Transport = Context->TransportName->Transport;
    STRING ClientAddress;
    NTSTATUS Status;
    PBACKUP_LIST_RESPONSE BackupListResponse = NULL;
    PCHAR ClientName = Context->ClientName;
    UNICODE_STRING UClientName;
    OEM_STRING AClientName;
    WCHAR ClientNameBuffer[LM20_CNLEN+1];

    PAGED_CODE();

    ClientAddress.Buffer = Context->TdiClientAddress;
    ClientAddress.Length = ClientAddress.MaximumLength =
        (USHORT)Context->ClientAddressLength;

    UClientName.Buffer = ClientNameBuffer;
    UClientName.MaximumLength = (LM20_CNLEN+1)*sizeof(WCHAR);

    RtlInitAnsiString(&AClientName, Context->ClientName);

    Status = RtlOemStringToUnicodeString(&UClientName, &AClientName, FALSE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, AClientName.Buffer, AClientName.Length );

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

        return;
    }

    //
    //  Lock the transport to allow us access to the list.  This prevents
    //  any role changes while we're responding to the caller.
    //

    LOCK_TRANSPORT_SHARED(Transport);

    //
    //  Do nothing if we're not a master browser.  This can happen if
    //  we're running on the PDC, and aren't the master for some reason (for
    //  instance, if the master browser is running a newer version of the
    //  browser).
    //

    if ( Transport->PagedTransport->Role != Master ) {
        UNLOCK_TRANSPORT(Transport);

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

        return;
    }

    LOCK_ANNOUNCE_DATABASE_SHARED(Transport);

    try {
        PUCHAR BackupPointer;
        PLIST_ENTRY BackupEntry;
        PLIST_ENTRY TraverseStart;
        USHORT Count;
        UCHAR NumberOfBackupServers = 0;
        ULONG EntriesInList;
        PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

        BackupListResponse = ALLOCATE_POOL(PagedPool, BOWSER_BACKUP_LIST_RESPONSE_SIZE, POOL_BACKUPLIST_RESP);

        //
        //  If we can't allocate the buffer, just bail out.
        //

        if (BackupListResponse == NULL) {
            try_return(NOTHING);
        }

        BackupListResponse->Type = GetBackupListResp;

        BackupListResponse->BackupListResponse.BackupServerCount = 0;

        //
        //  Set the token to the clients requested value
        //

        SmbPutUlong(&BackupListResponse->BackupListResponse.Token, BackupListRequest->Token);

        BackupPointer = BackupListResponse->BackupListResponse.BackupServerList;

        //
        //  Since we're a backup browser, make sure that at least our name is
        //  in the list.
        //

        {
            RtlCopyMemory( BackupPointer,
                           Transport->DomainInfo->DomOemComputerName.Buffer,
                           Transport->DomainInfo->DomOemComputerName.MaximumLength );

            //
            //  Bump pointer by size of string.
            //

            BackupPointer += Transport->DomainInfo->DomOemComputerName.MaximumLength;

        }


        NumberOfBackupServers += 1;



#ifdef ENABLE_PSEUDO_BROWSER
        //
        // Pseudo Server should not advertise any backup server but itself.
        //

        if (BowserData.PseudoServerLevel != BROWSER_PSEUDO) {
#endif

            //
            //  Walk the list of servers forward by the Last DC returned # of elements
            //

            Count = BackupListRequest->RequestedCount;

            BackupEntry = PagedTransport->BackupBrowserList.Flink;

            EntriesInList = PagedTransport->NumberOfBackupServerListEntries;

            // KdPrint(("There are %ld entries in the list\n", EntriesInList));

            TraverseStart = BackupEntry;

            //
            //  Try to find DC's and BDC's to satisfy the users request
            //  first.  They presumably are more appropriate to be returned
            //  anyway.
            //

            dlog(DPRT_MASTER, ("Advanced servers: "));

            while (Count && EntriesInList -- ) {
                PANNOUNCE_ENTRY ServerEntry = CONTAINING_RECORD(BackupEntry, ANNOUNCE_ENTRY, BackupLink);

                // KdPrint(("Check entry %ws.  Flags: %lx\n", ServerEntry->ServerName, ServerEntry->ServerType));

                //
                //  If this machine was a backup, and is now a master, it is
                //  possible we might return ourselves in the list of backups.
                //
                //  While this is not fatal, it can possibly cause problems,
                //  so remove ourselves from the list and skip to the next server
                //  in the list.
                //
                //
                //  Since WfW machines don't support "double hops", we can't
                //  return them to clients as legitimate backup servers.
                //

                if (
                    (ServerEntry->ServerType & (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL))

                        &&

                    (ServerEntry->ServerBrowserVersion >= (BROWSER_VERSION_MAJOR<<8)+BROWSER_VERSION_MINOR)

                        &&

                    (!(PagedTransport->Wannish)

                            ||

                     (ServerEntry->ServerType & SV_TYPE_NT))

                        &&

                    _wcsicmp(ServerEntry->ServerName, Transport->DomainInfo->DomUnicodeComputerNameBuffer)
                   ) {

                    Status = AddBackupToBackupList(&BackupPointer, (PCHAR)BackupListResponse, ServerEntry);

                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    //
                    //  And indicate we've packed another server entry.
                    //

                    NumberOfBackupServers += 1;

                    //
                    //  We've packed another entry in the buffer, so decrement the
                    //  count.
                    //

                    Count -= 1;

                }

                //
                //  Skip to the next entry in the list.
                //

                BackupEntry = BackupEntry->Flink;

                if (BackupEntry == &PagedTransport->BackupBrowserList) {
                    BackupEntry = BackupEntry->Flink;
                }

                if (BackupEntry == TraverseStart) {
                    break;
                }

            }

            dlog(DPRT_MASTER, ("\n"));

            //
            //  If we've not satisfied the users request with our DC's, then
            //  we want to fill the remainder of the list with ordinary backup
            //  browsers.
            //

            BackupEntry = PagedTransport->BackupBrowserList.Flink;

            EntriesInList = PagedTransport->NumberOfBackupServerListEntries;

            // KdPrint(("There are %ld entries in the list\n", EntriesInList));

            dlog(DPRT_MASTER, ("Other servers: "));

            TraverseStart = BackupEntry;

            while ( Count && EntriesInList--) {
                PANNOUNCE_ENTRY ServerEntry = CONTAINING_RECORD(BackupEntry, ANNOUNCE_ENTRY, BackupLink);

                // KdPrint(("Check entry %ws.  Flags: %lx\n", ServerEntry->ServerName, ServerEntry->ServerType));

                //
                //  If this machine was a backup, and is now a master, it is
                //  possible we might return ourselves in the list of backups.
                //
                //  While this is not fatal, it can possibly cause problems,
                //  so remove ourselves from the list and skip to the next server
                //  in the list.
                //
                //
                //  Since WfW machines don't support "double hops", we can't
                //  return them to clients as legitimate backup servers.
                //
                //
                //  Please note that we DO NOT include BDC's in this scan, since
                //  we already included them in the previous pass.
                //

                if (
                    (!(PagedTransport->Wannish)

                            ||

                     (ServerEntry->ServerType & SV_TYPE_NT))

                        &&

                    (ServerEntry->ServerBrowserVersion >= (BROWSER_VERSION_MAJOR<<8)+BROWSER_VERSION_MINOR)

                        &&

                    !(ServerEntry->ServerType & (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL))

                        &&

                    _wcsicmp(ServerEntry->ServerName, Transport->DomainInfo->DomUnicodeComputerNameBuffer)
                   ) {

                    Status = AddBackupToBackupList(&BackupPointer, (PCHAR)BackupListResponse, ServerEntry);

                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    //
                    //  And indicate we've packed another server entry.
                    //

                    NumberOfBackupServers += 1;

                    //
                    //  We've packed another entry in the buffer, so decrement the
                    //  count.
                    //

                    Count -= 1;

                }

                //
                //  Skip to the next entry in the list.
                //

                BackupEntry = BackupEntry->Flink;

                if (BackupEntry == &PagedTransport->BackupBrowserList) {
                    BackupEntry = BackupEntry->Flink;
                }

                if (BackupEntry == TraverseStart) {
                    break;
                }

            }

            dlog(DPRT_MASTER, ("\n"));


#ifdef ENABLE_PSEUDO_BROWSER
        }
#endif

        BackupListResponse->BackupListResponse.BackupServerCount = NumberOfBackupServers;

//        dlog(DPRT_MASTER, ("Responding to server %wZ on %ws with %lx (length %lx)\n", &UClientName,
//                        PagedTransport->TransportName.Buffer,
//                        BackupListResponse,
//                        BackupPointer-(PUCHAR)BackupListResponse));

        //
        //  Now send the response to the poor guy who requested it (finally)
        //


        Status = BowserSendSecondClassMailslot(Transport,
                            &UClientName,       // Name receiving data
                            ComputerName,       // Name type of destination
                            BackupListResponse, // Datagram Buffer
                            (ULONG)(BackupPointer-(PUCHAR)BackupListResponse), // Length.
                            TRUE,
                            MAILSLOT_BROWSER_NAME,
                            &ClientAddress);




try_exit:NOTHING;
    } finally {
        if (BackupListResponse != NULL) {
            FREE_POOL(BackupListResponse);
        }

        UNLOCK_ANNOUNCE_DATABASE(Transport);

        UNLOCK_TRANSPORT(Transport);

        BowserDereferenceTransportName(Context->TransportName);
        BowserDereferenceTransport(Transport);

        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);
    }

    return;
}


NTSTATUS
AddBackupToBackupList(
    IN PCHAR *BackupPointer,
    IN PCHAR BackupListStart,
    IN PANNOUNCE_ENTRY ServerEntry
    )
{
    OEM_STRING OemBackupPointer;
    UNICODE_STRING UnicodeBackupPointer;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  If we can't fit this entry in the list, then we've packed all we
    //  can.
    //

    if (((*BackupPointer)+wcslen(ServerEntry->ServerName)+1)-BackupListStart >= BOWSER_BACKUP_LIST_RESPONSE_SIZE ) {
        return (STATUS_BUFFER_OVERFLOW);
    }

    dlog(DPRT_MASTER, ("%ws ", ServerEntry->ServerName));

//    KdPrint(("Add server %ws to list\n", ServerEntry->ServerName));

    OemBackupPointer.Buffer = (*BackupPointer);
    OemBackupPointer.MaximumLength = (USHORT)((ULONG_PTR)(BackupListStart + BOWSER_BACKUP_LIST_RESPONSE_SIZE) -
            (ULONG_PTR)(*BackupPointer));

    RtlInitUnicodeString(&UnicodeBackupPointer, ServerEntry->ServerName);

    Status = RtlUnicodeStringToOemString(&OemBackupPointer, &UnicodeBackupPointer, FALSE);

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    (*BackupPointer) += OemBackupPointer.Length + 1;

    return STATUS_SUCCESS;
}




VOID
BowserpInitializeGetBrowserServerList(
    VOID
    )

{
    //
    //  We want to delay for the average amount of time it takes to force an
    //  election.
    //

    BowserGetBrowserListTimeout.QuadPart = Int32x32To64(  1000, -10000 );

    KeInitializeSpinLock(&BowserBackupListSpinLock);


}

VOID
BowserpUninitializeGetBrowserServerList(
    VOID
    )

{
    PAGED_CODE();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\bowutils.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowutils.c

Abstract:

    This module implements various useful routines for the NT datagram
receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    24-Sep-1991 larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserMapUsersBuffer)
#pragma alloc_text(PAGE, BowserLockUsersBuffer)
#pragma alloc_text(PAGE, BowserConvertType3IoControlToType2IoControl)
#pragma alloc_text(PAGE, BowserPackNtString)
#pragma alloc_text(PAGE, BowserPackUnicodeString)
#pragma alloc_text(PAGE, BowserRandom)
#pragma alloc_text(PAGE, BowserTimeUp)
#pragma alloc_text(PAGE, BowserReferenceDiscardableCode)
#pragma alloc_text(PAGE, BowserDereferenceDiscardableCode)
#pragma alloc_text(PAGE, BowserUninitializeDiscardableCode)
#pragma alloc_text(INIT, BowserInitializeDiscardableCode)

#if DBG
#ifndef PRODUCT1
#pragma alloc_text(PAGE, BowserTrace)
#endif
#pragma alloc_text(PAGE, BowserInitializeTraceLog)
#pragma alloc_text(PAGE, BowserOpenTraceLogFile)
#pragma alloc_text(PAGE, BowserUninitializeTraceLog)
#pragma alloc_text(PAGE, BowserDebugCall)
#endif

#endif

BOOLEAN
BowserMapUsersBuffer (
    IN PIRP Irp,
    OUT PVOID *UserBuffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine will probe and lock the buffer described by the
    provided Irp.

Arguments:

    IN PIRP Irp - Supplies the IRP that is to be mapped.
    OUT PVOID *Buffer - Returns a buffer that maps the user's buffer in the IRP

Return Value:

    TRUE - The buffer was mapped into the current address space.
    FALSE - The buffer was NOT mapped in, it was already mappable.


--*/

{
    PAGED_CODE();

    if (Irp->MdlAddress) {
        *UserBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, LowPagePriority);
        return FALSE;
    } else {
        if (Irp->AssociatedIrp.SystemBuffer != NULL) {
            *UserBuffer = Irp->AssociatedIrp.SystemBuffer;

        } else if (Irp->RequestorMode != KernelMode) {
            PIO_STACK_LOCATION IrpSp;

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            if ((Length != 0) && (Irp->UserBuffer != 0)) {

                if ((IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) ||
                    (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL)) {
                    ULONG ControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

                    if ((ControlCode & 3) == METHOD_NEITHER) {
                        ProbeForWrite( Irp->UserBuffer,
                                        Length,
                                        sizeof(UCHAR) );
                    } else {
                        ASSERT ((ControlCode & 3) != METHOD_BUFFERED);
                        ASSERT ((ControlCode & 3) != METHOD_IN_DIRECT);
                        ASSERT ((ControlCode & 3) != METHOD_OUT_DIRECT);
                    }

                } else if ((IrpSp->MajorFunction == IRP_MJ_READ) ||
                    (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                    (IrpSp->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION) ||
                    (IrpSp->MajorFunction == IRP_MJ_QUERY_SECURITY) ||
                    (IrpSp->MajorFunction == IRP_MJ_DIRECTORY_CONTROL)) {

                    ProbeForWrite( Irp->UserBuffer,
                           Length,
                           sizeof(UCHAR) );
                } else {
                    ProbeForRead( Irp->UserBuffer,
                          Length,
                          sizeof(UCHAR) );
                }
            }

            *UserBuffer = Irp->UserBuffer;
        }

        return FALSE;
    }

}

NTSTATUS
BowserLockUsersBuffer (
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine will probe and lock the buffer described by the
    provided Irp.

Arguments:

    IN PIRP Irp - Supplies the IRP that is to be locked.
    IN LOCK_OPERATION Operation - Supplies the operation type to probe.

Return Value:

    None.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    if ((Irp->MdlAddress == NULL)) {

        try {

            Irp->MdlAddress = IoAllocateMdl(Irp->UserBuffer,
                     BufferLength,
                     FALSE,
                     TRUE,
                     NULL);

            if (Irp->MdlAddress == NULL) {
               return(STATUS_INSUFFICIENT_RESOURCES);
            }


            //
            //  Now probe and lock down the user's data buffer.
            //

            MmProbeAndLockPages(Irp->MdlAddress,
                            Irp->RequestorMode,
                            Operation);

        } except (BR_EXCEPTION) {
            Status =  GetExceptionCode();

            if (Irp->MdlAddress != NULL) {
                //
                //  We blew up in the probe and lock, free up the MDL
                //  and set the IRP to have a null MDL pointer - we are failing the
                //  request
                //

                IoFreeMdl(Irp->MdlAddress);
                Irp->MdlAddress = NULL;
            }

        }

    }

    return Status;

}

NTSTATUS
BowserConvertType3IoControlToType2IoControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine does the work necessary to convert a type 3 IoCtl to a
    type 2 IoCtl.  We do this when we have to pass a user IRP to the FSP.


Arguments:

    IN PIRP Irp - Supplies an IRP to convert
    IN PIO_STACK_LOCATION IrpSp - Supplies an Irp Stack location for convenience

Return Value:

    NTSTATUS - Status of operation

Note: This must be called in the FSD.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0) {
        Status = BowserLockUsersBuffer(Irp, IoWriteAccess, IrpSp->Parameters.DeviceIoControl.OutputBufferLength);

        //
        //  If we were unable to lock the users output buffer, return now.
        //

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    }

    ASSERT (Irp->AssociatedIrp.SystemBuffer == NULL);

    try {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != 0) {
            PCHAR InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            ULONG InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

            Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(PagedPool,
                                                            InputBufferLength, '  GD');

            if (Irp->AssociatedIrp.SystemBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // If called from a user process,
            //  probe the buffer to ensure it is in the callers address space.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead( InputBuffer,
                              InputBufferLength,
                              sizeof(UCHAR));
            }

            RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer,
                       InputBuffer,
                       InputBufferLength);

            Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);

        } else {
            Irp->AssociatedIrp.SystemBuffer = NULL;
        }

    } except (BR_EXCEPTION) {

        if (Irp->AssociatedIrp.SystemBuffer != NULL) {
           ExFreePool(Irp->AssociatedIrp.SystemBuffer);
        }
        return GetExceptionCode();

    }

    return STATUS_SUCCESS;
}

ULONG
BowserPackNtString(
    PUNICODE_STRING string,
    ULONG_PTR BufferDisplacement,
    PCHAR dataend,
    PCHAR * laststring
    )
/**     BowserPackNtString
 *
 *  BowserPackNtString is used to stuff variable-length data, which
 *  is pointed to by (surpise!) a pointer.  The data is assumed
 *  to be a nul-terminated string (ASCIIZ).  Repeated calls to
 *  this function are used to pack data from an entire structure.
 *
 *  Upon first call, the laststring pointer should point to just
 *  past the end of the buffer.  Data will be copied into the buffer from
 *  the end, working towards the beginning.  If a data item cannot
 *  fit, the pointer will be set to NULL, else the pointer will be
 *  set to the new data location.
 *
 *  Pointers which are passed in as NULL will be set to be pointer
 *  to and empty string, as the NULL-pointer is reserved for
 *  data which could not fit as opposed to data not available.
 *
 *  Returns:  0 if could not fit data into buffer
 *    else size of data stuffed (guaranteed non-zero)
 *
 *  See the test case for sample usage.  (tst/packtest.c)
 */

{
    LONG size;

    PAGED_CODE();

    dlog(DPRT_PACK, ("BowserPackNtString:\n"));
    dlog(DPRT_PACK, ("  string=%Fp, *string=%Fp, **string=\"%us\"\n",
                                                    string, *string, *string));
    dlog(DPRT_PACK, ("  end=%Fp\n", dataend));
    dlog(DPRT_PACK, ("  last=%Fp, *last=%Fp, **last=\"%us\"\n",
                                        laststring, *laststring, *laststring));

    ASSERT (dataend < *laststring);

    //
    //  is there room for the string?
    //

    size = string->Length;

    if ((*laststring - dataend) < size) {
        string->Length = 0;
        return(0);
    } else {
        *laststring -= size;
        RtlCopyMemory(*laststring, string->Buffer, size);
        string->Buffer = (PWSTR)((*laststring) - BufferDisplacement);
        return(size);
    }
}

ULONG
BowserPackUnicodeString(
    IN OUT PWCHAR * string,     // pointer by reference: string to be copied.
    IN ULONG StringLength,      // Length of this string (in bytes) (w/o trailing zero)
    IN ULONG_PTR OutputBufferDisplacement,  // Amount to subtract from output buffer
    IN PVOID dataend,          // pointer to end of fixed size data.
    IN OUT PVOID * laststring  // pointer by reference: top of string data.
    )

/*++

Routine Description:

    BowserPackUnicodeString is used to stuff variable-length data, which
    is pointed to by (surpise!) a pointer.  The data is assumed
    to be a nul-terminated string (ASCIIZ).  Repeated calls to
    this function are used to pack data from an entire structure.

    Upon first call, the laststring pointer should point to just
    past the end of the buffer.  Data will be copied into the buffer from
    the end, working towards the beginning.  If a data item cannot
    fit, the pointer will be set to NULL, else the pointer will be
    set to the new data location.

    Pointers which are passed in as NULL will be set to be pointer
    to and empty string, as the NULL-pointer is reserved for
    data which could not fit as opposed to data not available.

    See the test case for sample usage.  (tst/packtest.c)


Arguments:

    string - pointer by reference:  string to be copied.

    dataend - pointer to end of fixed size data.

    laststring - pointer by reference:  top of string data.

Return Value:

    0  - if it could not fit data into the buffer.  Or...

    sizeOfData - the size of data stuffed (guaranteed non-zero)

--*/

{
    DWORD  size;
    DWORD  Available       = (DWORD)((PCHAR)*laststring - (PCHAR)dataend);
    WCHAR  StringBuffer[1] = L"";

    PAGED_CODE();

    //
    //  Verify that there is room left for the string.  If a NULL string
    //    is input, there must be at least room for a UNICODE NULL, so set
    //    size to sizeof(WCHAR) in this case.
    //

    if (*string == NULL) {
        StringLength = 0;
        *string      = StringBuffer;
    }

    size = StringLength + sizeof(WCHAR);

	// if the end of the buffer passed to us is not aligned properly for wide chars, shift it inwards to align it
	*laststring = ROUND_DOWN_POINTER(*laststring, ALIGN_WCHAR);

    if (*laststring < dataend || size > Available) {
       *string = UNICODE_NULL;
       return(0);
    }

    *((PCHAR *)laststring) -= size;
    RtlCopyMemory(*laststring, *string, size-sizeof(WCHAR));
    *string = *laststring;
    (*string)[StringLength/2] = L'\0';
    *(PCHAR*)string -=OutputBufferDisplacement;
    return(size);

} // BowserUnicodePackString


ULONG
BowserTimeUp(
    VOID
    )
/*++

Routine Description:

    BowserTimeUp is used to return the number of seconds the browser has been
    running.


Arguments:

    None

Return Value:

    Number of seconds the browser has been up.

--*/
{
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeDelta;
    LARGE_INTEGER TimeUp;

    //
    //  These are the magic numbers needed to do our extended division.  The
    //  only numbers we ever need to divide by are
    //
    //      10,000 = convert 100ns tics to millisecond tics
    //
    //
    //  These values were stolen from ntos\rtl\time.c
    //

    LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13


    PAGED_CODE();

    KeQuerySystemTime(&CurrentTime);

    TimeDelta.QuadPart = CurrentTime.QuadPart - BowserStartTime.QuadPart;

    //
    //  TimeDelta is the number of 100ns units the bowser has been up.  Convert
    //  it to milliseconds using the magic routine.
    //

    TimeUp = RtlExtendedMagicDivide(TimeDelta, Magic10000, SHIFT10000);

    //
    //  Please note that TimeUp.LowPart wraps after about 49 days,
    //  this means that if a machine has been up for more than 49 days,
    //  we peg at 0xffffffff.
    //

    if (TimeUp.HighPart != 0) {
        return(0xffffffff);
    }

    return(TimeUp.LowPart);
}

ULONG
BowserRandom(
    IN ULONG MaxValue
    )
/*++

Routine Description:

    BowserRandom is used to return a random number between 0 and MaxValue

Arguments:

    MaxValue - The maximum value to return.

Return Value:

    Random # between 0 and MaxValue

--*/
{
    PAGED_CODE();

    return RtlRandom(&BowserRandomSeed) % MaxValue;
}


VOID
BowserReferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    )
/*++

Routine Description:

    BowserReferenceDiscardableCode is called to reference the browsers
    discardable code section.

    If the section is not present in memory, MmLockPagableCodeSection is
    called to fault the section into memory.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    RdrReferenceDiscardableCode(SectionName);


}

VOID
BowserDereferenceDiscardableCode(
    DISCARDABLE_SECTION_NAME SectionName
    )
/*++

Routine Description:

    BowserDereferenceDiscardableCode is called to dereference the browsers
    discardable code section.

    When the reference count drops to 0, a timer is set that will fire in <n>
    seconds, after which time the section will be unlocked.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();
    RdrDereferenceDiscardableCode(SectionName);
}

VOID
BowserInitializeDiscardableCode(
    VOID
    )
{
}

VOID
BowserUninitializeDiscardableCode(
    VOID
    )
{
    PAGED_CODE();
}

#if BOWSERPOOLDBG
typedef struct {
    ULONG Count;
    ULONG Size;
    PCHAR FileName;
    ULONG LineNumber;
} POOL_STATS, *PPOOL_STATS;


typedef struct _POOL_HEADER {
//    LIST_ENTRY ListEntry;
    ULONG NumberOfBytes;
    PPOOL_STATS Stats;
} POOL_HEADER, *PPOOL_HEADER;

ULONG CurrentAllocationCount;
ULONG CurrentAllocationSize;

ULONG NextFreeEntry = 0;

POOL_STATS PoolStats[POOL_MAXTYPE+1];

PVOID
BowserAllocatePool (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN ULONG Tag
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;
#if 1
    ULONG i;
#endif

#if  POOL_TAGGING
    header = ExAllocatePoolWithTag( PoolType, sizeof(POOL_HEADER) + NumberOfBytes, Tag );
#else
    header = ExAllocatePool( PoolType, sizeof(POOL_HEADER) + NumberOfBytes );

#endif
    if ( header == NULL ) {
        return NULL;
    }
    header->NumberOfBytes = NumberOfBytes;

//    DbgPrint( "BOWSER: allocated type %d, size %d at %x\n", AllocationType, NumberOfBytes, header );

    ACQUIRE_SPIN_LOCK( &BowserTimeSpinLock, &oldIrql );

    CurrentAllocationCount++;
    CurrentAllocationSize += NumberOfBytes;
#if 1
    //
    //  Lets see if we've already allocated one of these guys.
    //


    for (i = 0;i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == LineNumber) &&
            (PoolStats[i].FileName == FileName)) {

            //
            //  Yup, remember this allocation and return.
            //

            header->Stats = &PoolStats[i];
            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    for (i = NextFreeEntry; i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == 0) &&
            (PoolStats[i].FileName == NULL)) {

            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;
            PoolStats[i].FileName = FileName;
            PoolStats[i].LineNumber = LineNumber;
            header->Stats = &PoolStats[i];

            NextFreeEntry = i+1;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    header->Stats = &PoolStats[i];
    PoolStats[POOL_MAXTYPE].Count++;
    PoolStats[POOL_MAXTYPE].Size += NumberOfBytes;
#endif

    RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

    return header + 1;
}

PVOID
BowserAllocatePoolWithQuota (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN ULONG Tag
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;
#if 1
    ULONG i;
#endif

#if POOL_TAGGING
    header = ExAllocatePoolWithTagQuota( PoolType, sizeof(POOL_HEADER) + NumberOfBytes, Tag );
#else
    header = ExAllocatePoolWithQuota( PoolType, sizeof(POOL_HEADER) + NumberOfBytes );
#endif
    if ( header == NULL ) {
        return NULL;
    }
    header->NumberOfBytes = NumberOfBytes;

//    DbgPrint( "BOWSER: allocated type %d, size %d at %x\n", AllocationType, NumberOfBytes, header );

    ACQUIRE_SPIN_LOCK( &BowserTimeSpinLock, &oldIrql );

    CurrentAllocationCount++;
    CurrentAllocationSize += NumberOfBytes;
#if 1
    //
    //  Lets see if we've already allocated one of these guys.
    //


    for (i = 0;i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == LineNumber) &&
            (PoolStats[i].FileName == FileName)) {

            //
            //  Yup, remember this allocation and return.
            //

            header->Stats = &PoolStats[i];
            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    for (i = NextFreeEntry; i < POOL_MAXTYPE ; i+= 1 ) {
        if ((PoolStats[i].LineNumber == 0) &&
            (PoolStats[i].FileName == NULL)) {

            PoolStats[i].Count++;
            PoolStats[i].Size += NumberOfBytes;
            PoolStats[i].FileName = FileName;
            PoolStats[i].LineNumber = LineNumber;
            header->Stats = &PoolStats[i];

            NextFreeEntry = i+1;

            RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

            return header + 1;
        }
    }

    header->Stats = &PoolStats[i];
    PoolStats[POOL_MAXTYPE].Count++;
    PoolStats[POOL_MAXTYPE].Size += NumberOfBytes;

#endif

    RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

    return header + 1;
}

VOID
BowserFreePool (
    IN PVOID P
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;
    PPOOL_STATS stats;
    ULONG size;

    header = (PPOOL_HEADER)P - 1;

    size = header->NumberOfBytes;
    stats = header->Stats;

//    if ( allocationType > POOL_MAXTYPE ) allocationType = POOL_MAXTYPE;
//    DbgPrint( "BOWSER: freed type %d, size %d at %x\n", allocationType, size, header );

    ACQUIRE_SPIN_LOCK( &BowserTimeSpinLock, &oldIrql );

    CurrentAllocationCount--;
    CurrentAllocationSize -= size;
#if 1
    stats->Count--;
    stats->Size -= size;
#endif

    RELEASE_SPIN_LOCK( &BowserTimeSpinLock, oldIrql );

    ExFreePool( header );

    return;
}
#endif // BOWSERPOOLDBG

#if DBG

ERESOURCE
BrowserTraceLock;
HANDLE
BrowserTraceLogHandle = NULL;

UCHAR LastCharacter = '\n';

#ifndef PRODUCT1

VOID
BowserTrace(
    PCHAR FormatString,
    ...
    )

#define LAST_NAMED_ARGUMENT FormatString

{
#define BR_OUTPUT_STRING_BUFFER_SIZE 1024

    CHAR OutputString[BR_OUTPUT_STRING_BUFFER_SIZE];
    IO_STATUS_BLOCK IoStatus;
    BOOLEAN ProcessAttached = FALSE;
    BOOLEAN ReleaseResource = FALSE;
    va_list ParmPtr;                    // Pointer to stack parms.
    KAPC_STATE ApcState;
    NTSTATUS Status;

    PAGED_CODE();


	try {
		//
		// Acquire the BrowserTraceLock to prevent race condition
		// when two threads try to initialize the handle
		//
		ExAcquireResourceExclusive(&BrowserTraceLock, TRUE);
		ReleaseResource = TRUE;
		if (BrowserTraceLogHandle == NULL) {

			// Attach to FSP when using handle
			if (IoGetCurrentProcess() != BowserFspProcess) {
				KeStackAttachProcess(BowserFspProcess, &ApcState );

				ProcessAttached = TRUE;
			}

			if (!NT_SUCCESS(BowserOpenTraceLogFile(L"\\SystemRoot\\Bowser.Log"))) {

				BrowserTraceLogHandle = (HANDLE) -1;

				if (ProcessAttached) {
					KeUnstackDetachProcess( &ApcState );
					ProcessAttached = FALSE;
				}
				if (ReleaseResource) {
					ExReleaseResource(&BrowserTraceLock);
					ReleaseResource = FALSE;
				}

				return;
			}

		} else if (BrowserTraceLogHandle == (HANDLE) -1) {

			if (ProcessAttached) {
				KeUnstackDetachProcess( &ApcState );
				ProcessAttached = FALSE;
			}
			if (ReleaseResource) {
				ExReleaseResource(&BrowserTraceLock);
				ReleaseResource = FALSE;
			}

			return;
		}
	} finally {
        if (ReleaseResource) {
            ExReleaseResource(&BrowserTraceLock);
			ReleaseResource = FALSE;
        }
		if (ProcessAttached) {
			KeUnstackDetachProcess( &ApcState );
			ProcessAttached = FALSE;
		}
	}


	//
	// We need a try-finally. In addition, have a try-except so that
	// exceptions are caught here itself.
	//
	try {
		try {
			LARGE_INTEGER EndOfFile;

			ExAcquireResourceExclusive(&BrowserTraceLock, TRUE);
			ReleaseResource = TRUE;

			// re-verify we should be tracing (under lock).
			if (BrowserTraceLogHandle == NULL) {
				try_return(Status);
			}

			EndOfFile.HighPart = 0xffffffff;
			EndOfFile.LowPart = FILE_WRITE_TO_END_OF_FILE;

			if (LastCharacter == '\n') {
				LARGE_INTEGER SystemTime;
				TIME_FIELDS TimeFields;

				KeQuerySystemTime(&SystemTime);

				ExSystemTimeToLocalTime(&SystemTime, &SystemTime);

				RtlTimeToTimeFields(&SystemTime, &TimeFields);

				//
				//  The last character written was a newline character.  We should
				//  timestamp this record in the file.
				//
				StringCbPrintfA(OutputString, 
								BR_OUTPUT_STRING_BUFFER_SIZE,
								"%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%3.3d: ",
																TimeFields.Month,
																TimeFields.Day,
																TimeFields.Hour,
																TimeFields.Minute,
																TimeFields.Second,
																TimeFields.Milliseconds);
				// Attach to FSP when using handle
				if ( !ProcessAttached && (IoGetCurrentProcess() != BowserFspProcess) ) {
					KeStackAttachProcess(BowserFspProcess, &ApcState );

					ProcessAttached = TRUE;
				}

				if (!NT_SUCCESS(Status = ZwWriteFile(BrowserTraceLogHandle, NULL, NULL, NULL, &IoStatus, OutputString, strlen(OutputString), &EndOfFile, NULL))) {
					KdPrint(("Error writing time to Browser log file: %lX\n", Status));
					try_return(Status);
				}

				if (!NT_SUCCESS(IoStatus.Status)) {
					KdPrint(("Error writing time to Browser log file: %lX\n", IoStatus.Status));
					try_return(Status);
				}

				if (IoStatus.Information != strlen(OutputString)) {
					KdPrint(("Error writing time to Browser log file: %lX\n", IoStatus.Status));
					try_return(Status);
				}

			}

			va_start(ParmPtr, LAST_NAMED_ARGUMENT);

			// Be in caller's process when referencing parameters.
			if (ProcessAttached) {
				KeUnstackDetachProcess( &ApcState );
				ProcessAttached = FALSE;
			}

			//
			//  Format the parameters to the string.
			//

			StringCchVPrintfA(OutputString, BR_OUTPUT_STRING_BUFFER_SIZE, FormatString, ParmPtr);

			// Attach to FSP when using handle
			if (IoGetCurrentProcess() != BowserFspProcess) {
				KeStackAttachProcess(BowserFspProcess, &ApcState );

				ProcessAttached = TRUE;
			}

			if (!NT_SUCCESS(Status = ZwWriteFile(BrowserTraceLogHandle, NULL, NULL, NULL, &IoStatus, OutputString, strlen(OutputString), &EndOfFile, NULL))) {
				KdPrint(("Error writing string to Browser log file: %ld\n", Status));
				try_return(Status);
			}

			if (!NT_SUCCESS(IoStatus.Status)) {
				KdPrint(("Error writing string to Browser log file: %lX\n", IoStatus.Status));
				try_return(Status);
			}

			if (IoStatus.Information != strlen(OutputString)) {
				KdPrint(("Error writing string to Browser log file: %ld\n", IoStatus.Status));
				try_return(Status);
			}

			//
			//  Remember the last character output to the log.
			//

			LastCharacter = OutputString[strlen(OutputString)-1];

	try_exit:NOTHING;
		} finally {
			if (ReleaseResource) {
				ExReleaseResource(&BrowserTraceLock);
				ReleaseResource = FALSE;
			}
			if (ProcessAttached) {
				KeUnstackDetachProcess( &ApcState );
				ProcessAttached = FALSE;
			}
		}
	} except(EXCEPTION_EXECUTE_HANDLER){
	}
}

#endif

VOID
BowserInitializeTraceLog()
{

    PAGED_CODE();
    ExInitializeResource(&BrowserTraceLock);

}

NTSTATUS
BowserOpenTraceLogFile(
    IN PWCHAR TraceFile
    )
{
    UNICODE_STRING TraceFileName;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PAGED_CODE();

    RtlInitUnicodeString(&TraceFileName, TraceFile);

    InitializeObjectAttributes(&ObjA, &TraceFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = IoCreateFile(&BrowserTraceLogHandle,
                                        FILE_APPEND_DATA|SYNCHRONIZE,
                                        &ObjA,
                                        &IoStatusBlock,
                                        NULL,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FILE_SHARE_READ,
                                        FILE_OPEN_IF,
                                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY,
                                        NULL,
                                        0,
                                        CreateFileTypeNone,
                                        NULL,
                                        IO_FORCE_ACCESS_CHECK |         // Ensure the user has access to the file
                                            IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                                            IO_CHECK_CREATE_PARAMETERS  // But double check parameter consistancy
                                        );


    if (!NT_SUCCESS(Status)) {
        KdPrint(("Bowser: Error creating trace file %ws %lX\n", TraceFile, Status));

        return Status;
    }

    return Status;
}

VOID
BowserUninitializeTraceLog()
{
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;

    PAGED_CODE();

    ExDeleteResource(&BrowserTraceLock);

    if (BrowserTraceLogHandle != NULL) {
        if (IoGetCurrentProcess() != BowserFspProcess) {
            KeStackAttachProcess(BowserFspProcess, &ApcState );

            ProcessAttached = TRUE;
        }

        ZwClose(BrowserTraceLogHandle);

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
			ProcessAttached = FALSE;
        }
    }

    BrowserTraceLogHandle = NULL;
}

NTSTATUS
BowserDebugCall(
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )
{
    NTSTATUS Status;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }


    try {
        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status=STATUS_BUFFER_TOO_SMALL);
        }

        if ( InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM ) {
            try_return(Status=STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Parameters.Debug.OpenLog && InputBuffer->Parameters.Debug.CloseLog) {
            try_return(Status=STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Parameters.Debug.OpenLog) {

            ENSURE_IN_INPUT_BUFFER_STR( InputBuffer->Parameters.Debug.TraceFileName);

            Status = BowserOpenTraceLogFile(InputBuffer->Parameters.Debug.TraceFileName);

        } else if (InputBuffer->Parameters.Debug.CloseLog) {
            Status = ZwClose(BrowserTraceLogHandle);

            if (NT_SUCCESS(Status)) {
                BrowserTraceLogHandle = NULL;
            }

        } else if (InputBuffer->Parameters.Debug.TruncateLog) {
            FILE_END_OF_FILE_INFORMATION EndOfFileInformation;
            IO_STATUS_BLOCK IoStatus;

            if (BrowserTraceLogHandle == NULL) {
                try_return(Status=STATUS_INVALID_HANDLE);
            }

            EndOfFileInformation.EndOfFile.HighPart = 0;
            EndOfFileInformation.EndOfFile.LowPart = 0;

            Status = NtSetInformationFile(BrowserTraceLogHandle,
                                            &IoStatus,
                                            &EndOfFileInformation,
                                            sizeof(EndOfFileInformation),
                                            FileEndOfFileInformation);

        } else {
            BowserDebugLogLevel = InputBuffer->Parameters.Debug.DebugTraceBits;
            KdPrint(("Setting Browser Debug Trace Bits to %lx\n", BowserDebugLogLevel));
            Status = STATUS_SUCCESS;
        }

        try_return(Status);

    try_exit:NOTHING;
    } finally {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
			ProcessAttached = FALSE;
        }

    }

    return Status;
}

#endif

BOOL
BowserValidUnicodeString(
	IN PUNICODE_STRING Str
	)
{
	// lifted from ASSERT_WELL_FORMED_UNICODE_STRING_IN - ntos\rtl\ntrtlp.h
	if ( !((Str)->Length&1) && (!((Str)->Buffer) || !(sizeof((Str)->Buffer)&1) ) ) {
		//
		// check for aligned buffer
		if POINTER_IS_ALIGNED( (Str)->Buffer, ALIGN_WCHAR ) {
			return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\domain.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    domain.h

Abstract:

    Header file for code to manage primary and emulated networks.

Author:

    Cliff Van Dyke (CliffV) 23-Jan-1995

Revision History:

--*/

//
// Description of a single domain.
//

typedef struct _DOMAIN_INFO {

    //
    // Link to next domain in 'BowserServicedDomains'
    //  (Serialized by BowserTransportDatabaseResource)
    //

    LIST_ENTRY Next;

    //
    // Name of the domain being handled
    //

    CHAR DomOemDomainName[DNLEN+1];
    DWORD DomOemDomainNameLength;
    CHAR DomNetbiosDomainName[NETBIOS_NAME_LEN+1];
    WCHAR DomUnicodeDomainNameBuffer[DNLEN+1];
    UNICODE_STRING DomUnicodeDomainName;

    //
    // Computer name associated with this domain.
    //

    WCHAR DomUnicodeComputerNameBuffer[CNLEN+1];
    UNICODE_STRING DomUnicodeComputerName;
    CHAR DomOemComputerNameBuffer[CNLEN+1];
    OEM_STRING DomOemComputerName;

    //
    // Number of outstanding pointer to the domain structure.
    //  (Serialized by BowserTransportDatabaseResource)
    //

    DWORD ReferenceCount;

} DOMAIN_INFO, *PDOMAIN_INFO;

//
// List of all domains.  The primary domain is at the front of the list.
//
extern LIST_ENTRY BowserServicedDomains;


//
// domain.c procedure forwards.
//

VOID
BowserInitializeDomains(
    VOID
    );

PDOMAIN_INFO
BowserCreateDomain(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING ComputerName
    );

PDOMAIN_INFO
BowserFindDomain(
    PUNICODE_STRING DomainName
    );

VOID
BowserDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\brsrvlst.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brsrvlst.c.

Abstract:

    This module implements the NtDeviceIoControlFile API's for the NT datagram
receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/
#ifndef _BRSRVLST_
#define _BRSRVLST_

VOID
BowserFreeBrowserServerList (
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength
    );

VOID
BowserShuffleBrowserServerList(
    IN PWSTR *BrowserServerList,
    IN ULONG BrowserServerListLength,
    IN BOOLEAN IsPrimaryDomain,
    IN PDOMAIN_INFO DomainInfo
    );

NTSTATUS
BowserGetBrowserServerList(
    IN PIRP Irp,
    IN PTRANSPORT Transport,
    IN PUNICODE_STRING DomainName OPTIONAL,
    OUT PWSTR **BrowserServerList,
    OUT PULONG BrowserServerListLength
    );

DATAGRAM_HANDLER(
    BowserGetBackupListResponse
    );
DATAGRAM_HANDLER(
    BowserGetBackupListRequest
    );

VOID
BowserpInitializeGetBrowserServerList(
    VOID
    );

VOID
BowserpUninitializeGetBrowserServerList(
    VOID
    );


#endif // _BRSRVLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the server.

    !!! This module must be nonpageable.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Local procedure forwards
//

VOID
BowserLogIllegalNameWorker(
    IN PVOID Ctx
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserWriteErrorLogEntry)
#pragma alloc_text(PAGE, BowserLogIllegalNameWorker )
#endif


ULONG
BowserSequenceNumber = 0;

//#pragma optimize("",off)

VOID
_cdecl
BowserWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings


/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{

    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    int TotalErrorLogEntryLength;
    ULONG SizeOfStringData = 0;
    va_list ParmPtr;                    // Pointer to stack parms.
    ULONG Length;

    PAGED_CODE();

    if (NumberOfInsertionStrings != 0) {
        ULONG i;

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1) {

            PWSTR String = va_arg(ParmPtr, PWSTR);

            Length = wcslen(String);
            while ( (Length > 0) && (String[Length-1] == L' ') ) {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength =
         min( ExtraInformationLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
              ERROR_LOG_MAXIMUM_SIZE );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)BowserDeviceObject,
        (UCHAR)TotalErrorLogEntryLength
        );

    if (ErrorLogEntry != NULL) {
        PCHAR DumpData;
        ULONG RemainingSpace = TotalErrorLogEntryLength -
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
        ULONG i;
        ULONG SizeOfRawData;

        if (RemainingSpace > SizeOfStringData) {
            SizeOfRawData = RemainingSpace - SizeOfStringData;
        } else {
            SizeOfStringData = RemainingSpace;

            SizeOfRawData = 0;
        }

        //
        // Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = UniqueErrorCode;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatusCode;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.LowPart = 0;
        ErrorLogEntry->DeviceOffset.HighPart = 0;
        ErrorLogEntry->SequenceNumber = (ULONG)BowserSequenceNumber ++;
        ErrorLogEntry->StringOffset = (USHORT)(ROUND_UP_COUNT(
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + SizeOfRawData,
                    ALIGN_WORD));

        DumpData = (PCHAR)ErrorLogEntry->DumpData;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if (( ARGUMENT_PRESENT( ExtraInformationBuffer )) &&
            ( SizeOfRawData != 0 )) {
            ULONG Length;

            Length = min(ExtraInformationLength, (USHORT)SizeOfRawData);
            RtlCopyMemory(
                DumpData,
                ExtraInformationBuffer,
                Length);
            ErrorLogEntry->DumpDataSize = (USHORT)Length;
        } else {
            ErrorLogEntry->DumpDataSize = 0;
        }

        ErrorLogEntry->NumberOfStrings = 0;

        if (NumberOfInsertionStrings != 0) {
            PWSTR StringOffset = (PWSTR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);
            PWSTR InsertionString;

            //
            // Set up ParmPtr to point to first of the caller's parameters.
            //

            va_start(ParmPtr, LAST_NAMED_ARGUMENT);

            for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1) {
                InsertionString = va_arg(ParmPtr, PWSTR);
                Length = wcslen(InsertionString);
                while ( (Length > 0) && (InsertionString[Length-1] == L' ') ) {
                    Length--;
                }

                if ( ((Length + 1) * sizeof(WCHAR)) > SizeOfStringData ) {
                    Length = (SizeOfStringData/sizeof(WCHAR))-1;
                }

                if ( Length > 0 ) {
                    RtlCopyMemory(StringOffset, InsertionString, Length*sizeof(WCHAR));
                    StringOffset += Length;
                    *StringOffset++ = L'\0';

                    SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                    ErrorLogEntry->NumberOfStrings += 1;
                }

            }

        }

        IoWriteErrorLogEntry(ErrorLogEntry);
    }

}

typedef struct _ILLEGAL_NAME_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT_NAME TransportName;
    NTSTATUS EventStatus;
    NTSTATUS NtStatusCode;
    USHORT   BufferSize;
    UCHAR    Buffer[1];
} ILLEGAL_NAME_CONTEXT, *PILLEGAL_NAME_CONTEXT;

VOID
BowserLogIllegalName(
    IN NTSTATUS NtStatusCode,
    IN PVOID NameBuffer,
    IN USHORT NameBufferSize
    )
{
    KIRQL OldIrql;
    NTSTATUS ErrorStatus = STATUS_SUCCESS;

    ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);

    if (BowserIllegalNameCount > 0) {
        BowserIllegalNameCount -= 1;

        ErrorStatus = EVENT_BOWSER_NAME_CONVERSION_FAILED;

    } else if (!BowserIllegalNameThreshold) {
        BowserIllegalNameThreshold = TRUE;
        ErrorStatus = EVENT_BOWSER_NAME_CONVERSION_FAILED;
    }

    RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

    if (ErrorStatus != STATUS_SUCCESS) {
        PILLEGAL_NAME_CONTEXT Context = NULL;

        Context = ALLOCATE_POOL(NonPagedPool, sizeof(ILLEGAL_NAME_CONTEXT)+NameBufferSize, POOL_ILLEGALDGRAM);

        if (Context != NULL) {
            Context->EventStatus = ErrorStatus;
            Context->NtStatusCode = NtStatusCode;
            Context->BufferSize = NameBufferSize;

            RtlCopyMemory( Context->Buffer, NameBuffer, NameBufferSize );

            ExInitializeWorkItem(&Context->WorkItem, BowserLogIllegalNameWorker, Context);

            BowserQueueDelayedWorkItem( &Context->WorkItem );
        }

    }
}


VOID
BowserLogIllegalNameWorker(
    IN PVOID Ctx
    )
{
    PILLEGAL_NAME_CONTEXT Context = Ctx;
    NTSTATUS EventContext = Context->EventStatus;

    PAGED_CODE();

    BowserWriteErrorLogEntry( Context->EventStatus,
                              Context->NtStatusCode,
                              Context->Buffer,
                              Context->BufferSize,
                              0 );

    FREE_POOL(Context);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\fileinfo.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the NtQueryInformationFile and
NtQueryVolumeInformationFile API's for the NT datagram receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
BowserCommonQueryVolumeInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserCommonQueryInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFspQueryVolumeInformationFile)
#pragma alloc_text(PAGE, BowserFsdQueryVolumeInformationFile)
#pragma alloc_text(PAGE, BowserCommonQueryVolumeInformationFile)
#pragma alloc_text(PAGE, BowserFspQueryInformationFile)
#pragma alloc_text(PAGE, BowserFsdQueryInformationFile)
#pragma alloc_text(PAGE, BowserCommonQueryInformationFile)
#endif


NTSTATUS
BowserFspQueryVolumeInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;
    PAGED_CODE();
    Status = BowserCommonQueryVolumeInformationFile (TRUE,
                                        DeviceObject,
                                        Irp);
    return Status;

}

NTSTATUS
BowserFsdQueryVolumeInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserCommonQueryVolumeInformationFile (IoIsOperationSynchronous(Irp),
                                        DeviceObject,
                                        Irp);
    return Status;


}

NTSTATUS
BowserCommonQueryVolumeInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    BowserCompleteRequest(Irp, Status);

    return Status;

    DBG_UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserFspQueryInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserCommonQueryInformationFile (TRUE,
                                        DeviceObject,
                                        Irp);
    return Status;

}

NTSTATUS
BowserFsdQueryInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    Status = BowserCommonQueryInformationFile(IoIsOperationSynchronous(Irp),
                                        DeviceObject,
                                        Irp);
    return Status;


}

NTSTATUS
BowserCommonQueryInformationFile (
    IN BOOLEAN Wait,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    //
    // Return an error until we figure out valid information to return.
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    PAGED_CODE();

    BowserCompleteRequest(Irp, Status);

    return Status;

    DBG_UNREFERENCED_PARAMETER(Wait);

    UNREFERENCED_PARAMETER(DeviceObject);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\fsctl.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the NtDeviceIoControlFile API's for the NT datagram
receiver (bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991 larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop
#include <stddef.h> // offsetof


#define MIN(a,b) ( (a) < (b) ? (a) : (b) )



PEPROCESS
RxGetRDBSSProcess();

NTSTATUS
BowserCommonDeviceIoControlFile (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
StartBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
BowserEnumTransports (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
EnumNames (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
BowserBindToTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
UnbindFromTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
AddBowserName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
StopBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
DeleteName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
EnumServers (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );


NTSTATUS
WaitForBrowserRoleChange (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
WaitForNewMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
HandleBecomeBackup (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
BecomeMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


NTSTATUS
WaitForMasterAnnounce (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
WriteMailslot (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
WriteMailslotEx (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
	IN BOOLEAN WaitForCompletion
    );

NTSTATUS
UpdateStatus (
    IN PIRP Irp,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
GetBrowserServerList(
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN OUT PULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    );

NTSTATUS
QueryStatistics(
    IN PIRP Irp,
    OUT PBOWSER_STATISTICS OutputBuffer,
    IN OUT PULONG OutputBufferLength
    );

NTSTATUS
ResetStatistics(
    VOID
    );

NTSTATUS
BowserIpAddressChanged(
    IN PLMDR_REQUEST_PACKET InputBuffer
    );

NTSTATUS
BowserIpAddressChangedWorker(
    PTRANSPORT Transport,
    PVOID Context
    );

NTSTATUS
EnableDisableTransport (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

NTSTATUS
BowserRenameDomain (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );

PLMDR_REQUEST_PACKET
RequestPacket32to64 (
    IN      PLMDR_REQUEST_PACKET32  RequestPacket32,
    IN  OUT PLMDR_REQUEST_PACKET    RequestPacket,
	IN      ULONG InputBufferLength);




#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserCommonDeviceIoControlFile)
#pragma alloc_text(PAGE, BowserFspDeviceIoControlFile)
#pragma alloc_text(PAGE, BowserFsdDeviceIoControlFile)
#pragma alloc_text(PAGE, StartBowser)
#pragma alloc_text(PAGE, BowserEnumTransports)
#pragma alloc_text(PAGE, EnumNames)
#pragma alloc_text(PAGE, BowserBindToTransport)
#pragma alloc_text(PAGE, UnbindFromTransport)
#pragma alloc_text(PAGE, AddBowserName)
#pragma alloc_text(PAGE, StopBowser)
#pragma alloc_text(PAGE, DeleteName)
#pragma alloc_text(PAGE, EnumServers)
#pragma alloc_text(PAGE, WaitForBrowserRoleChange)
#pragma alloc_text(PAGE, HandleBecomeBackup)
#pragma alloc_text(PAGE, BecomeMaster)
#pragma alloc_text(PAGE, WaitForMasterAnnounce)
#pragma alloc_text(PAGE, WriteMailslot)
#pragma alloc_text(PAGE, WriteMailslotEx)
#pragma alloc_text(PAGE, UpdateStatus)
#pragma alloc_text(PAGE, BowserStopProcessingAnnouncements)
#pragma alloc_text(PAGE, GetBrowserServerList)
#pragma alloc_text(PAGE, WaitForNewMaster)
//#pragma alloc_text(PAGE, BowserIpAddressChanged)
#pragma alloc_text(PAGE, BowserIpAddressChangedWorker)
#pragma alloc_text(PAGE, EnableDisableTransport)
#pragma alloc_text(PAGE, BowserRenameDomain )
#pragma alloc_text(PAGE4BROW, QueryStatistics)
#pragma alloc_text(PAGE4BROW, ResetStatistics)
#pragma alloc_text(PAGE, RequestPacket32to64)
#if DBG
#pragma alloc_text(PAGE, BowserDebugCall)
#endif
#endif


NTSTATUS
BowserFspDeviceIoControlFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = BowserCommonDeviceIoControlFile(TRUE,
                                        FALSE,
                                        DeviceObject,
                                        Irp);
    return Status;

}

NTSTATUS
BowserFsdDeviceIoControlFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

#ifndef PRODUCT1
    FsRtlEnterFileSystem();
#endif

    //
    // Call the routine shared by the FSD/FSP.
    //
    // Even though this is the FSD, indicate we're in the FSP if our caller
    //  is in the system process.  This allows us to avoid posting this
    //  request to a worker thread if we're already in one.
    //
    Status = BowserCommonDeviceIoControlFile(
                 IoIsOperationSynchronous(Irp),
                 (BOOLEAN)(IoGetCurrentProcess() != BowserFspProcess),
                 DeviceObject,
                 Irp);

#ifndef PRODUCT1
    FsRtlExitFileSystem();
#endif

    return Status;


}

NTSTATUS
BowserCommonDeviceIoControlFile (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/
{
    NTSTATUS Status                 = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp        = IoGetCurrentIrpStackLocation(Irp);
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PVOID OutputBuffer              = NULL;
    ULONG OutputBufferLength;
    ULONG IoControlCode             = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    ULONG MinorFunction             = IrpSp->MinorFunction;
    LPBYTE OriginalInputBuffer      = NULL;
    BOOLEAN CopyEnumResultsToCaller = FALSE;
    BOOLEAN fThunk32bit;
    LMDR_REQUEST_PACKET             ReqPacketBuffer;

// Local Definitions

#define BOWSECURITYCHECK( _irp, _irpsp, _status)                                                \
    if (_irp->RequestorMode != KernelMode               &&                                      \
        !IoIsSystemThread ( _irp->Tail.Overlay.Thread)  &&                                      \
        !BowserSecurityCheck(_irp, _irpsp, &_status)){                                          \
                try_return (_status = (NT_SUCCESS(_status) ? STATUS_ACCESS_DENIED : _status) ); \
    }

    PAGED_CODE();

    try {

        //
        //  Before we call the worker functions, prep the parameters to those
        //  functions.
        //

        //
        // Is caller in 32bit process?
        // we'll process irp field size calculations depending on this knowledge.
        //

#ifdef _WIN64
        fThunk32bit = IoIs32bitProcess(Irp);

        //
        // Filter out all IOCTLs we do not support:
        // Since the browser is getting phased out, we would support only those
        // IOCTLs used only for NetServerEnum.
        //
        if ( fThunk32bit &&
             IoControlCode != IOCTL_LMDR_ENUMERATE_TRANSPORTS  &&
             IoControlCode != IOCTL_LMDR_GET_BROWSER_SERVER_LIST ) {
            // Only these ioctl's are supported in thunking mode
            try_return(Status = STATUS_NOT_IMPLEMENTED);
        }
#else
        // If we're in 32 bit (e.g. call above isn't available), use unchanged functionality
        // i.e. pure new-64-bit == pure old-32-bit == homogeneous environment. Thus, set to FALSE.
        fThunk32bit = FALSE;
#endif


        //
        //  The input buffer is either in Irp->AssociatedIrp.SystemBuffer, or
        //  in the Type3InputBuffer for type 3 IRP's.
        //

        InputBuffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  The lengths of the various buffers are easy to find, they're in the
        //  Irp stack location.
        //

        OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

        //
        // Input buffer length sanity
        //  * Wow64 -- support 32 bit clients on 64 bit systems (see bug 454130)
        //

        if ( InputBufferLength != 0 ) {
            // use 32 bit struct
            if ( fThunk32bit ) {
                 if ( InputBufferLength < offsetof( LMDR_REQUEST_PACKET32,Parameters ) ) {
                    dlog(DPRT_FSCTL, ("IoControlFile: input buffer too short %d (32 bit)\n",
                                      InputBufferLength));
                    try_return(Status = STATUS_INVALID_PARAMETER);
                 }

                 //
                 // Convert buffer to 64 presentation
                 //
                 if (InputBuffer) {
#if DBG
//
// Temporary:
// We're not aware of any such cases where there are 32 bit ioctl conversions
// in FSP. Print out a debug notice for debugging/tracing.
//
                     DbgPrint("[mrxsmb!fsctl.c] Converting 32 bit ioctl 0x%x in FSP\n",
                              IoControlCode);
#endif
                     // sanity on buffer
                     ENSURE_BUFFER_BOUNDARIES(InputBuffer, &(((PLMDR_REQUEST_PACKET32)InputBuffer)->TransportName));
                     ENSURE_BUFFER_BOUNDARIES(InputBuffer, &(((PLMDR_REQUEST_PACKET32)InputBuffer)->EmulatedDomainName));

                     //
                     // If the request came from UserMode, we need to Probe
                     // the InputBuffer for reading. This is because the
                     // function RequestPacket32to64 will be reading the 
                     // contents of this InputBuffer.
                     //
                     try {
                         if (Irp->RequestorMode != KernelMode) {
                             ProbeForRead(InputBuffer, InputBufferLength, sizeof(UCHAR));
                         }
                     } except (EXCEPTION_EXECUTE_HANDLER) {
                           try_return(Status = STATUS_INVALID_USER_BUFFER);
                     }

                     // convert buffer
                     OriginalInputBuffer = (LPBYTE)InputBuffer;
                     InputBuffer = (PVOID)RequestPacket32to64(
                                            (PLMDR_REQUEST_PACKET32)InputBuffer,
                                            &ReqPacketBuffer,
											InputBufferLength);
                     // fix length
                     InputBufferLength += sizeof(LMDR_REQUEST_PACKET) - sizeof(LMDR_REQUEST_PACKET32);
                 }

            }

            // use homogeneous environment struct
            if (InputBufferLength < offsetof( LMDR_REQUEST_PACKET,Parameters ) ) {
                dlog(DPRT_FSCTL, ("IoControlFile: input buffer too short %d\n", InputBufferLength));
                try_return(Status = STATUS_INVALID_PARAMETER);
            }
        }           // inputbufferlength != 0

        //
        //  If we are in the FSD, then the input buffer is in Type3InputBuffer
        //  on type 3 api's, not in SystemBuffer.
        //
        // Capture the type 3 buffer.
        //

        if (InputBuffer == NULL &&
            InputBufferLength != 0) {

            //
            //  This had better be a type 3 IOCTL.
            //


            if ((IoControlCode & 3) == METHOD_NEITHER) {
                PLMDR_REQUEST_PACKET RequestPacket;

                //
                // Capture the input buffer.
                //

                OriginalInputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                Status = BowserConvertType3IoControlToType2IoControl( Irp, IrpSp);

                if ( !NT_SUCCESS(Status) ) {
                    try_return( Status );
                }

                //
                // Relocate all the pointers in the input buffer.
                //  (Don't validate the pointers here.  Not all function codes
                //  initialize these fields.  For such function codes,
                //  this "relocation" may be changing the uninitialized garbage.)
                //
                RequestPacket = Irp->AssociatedIrp.SystemBuffer;

                //
                // Protect against callers that didn't specify an input buffer.
                //

                if ( RequestPacket == NULL ) {
                    try_return(Status = STATUS_INVALID_PARAMETER);
                }

                if (fThunk32bit) {

                    // convert buffer
                    RequestPacket = (PVOID)RequestPacket32to64(
                                                (PLMDR_REQUEST_PACKET32)RequestPacket,
                                                &ReqPacketBuffer,
												InputBufferLength);
                    // fix length
                    InputBufferLength += sizeof(LMDR_REQUEST_PACKET) - sizeof(LMDR_REQUEST_PACKET32);
                    // remark: sanity on buffers is done immediately below.
                    //         (cannot apply ENSURE_BUFFER_BOUNDARIES test to type3 ioctl)
                }
                //
                // Initialize the embedded unicode strings to NULL for IOCTLs which
                //   don't reference them.  The user-mode components don't always
                //   initialize buffers to zero.
                //

                if (IoControlCode == IOCTL_LMDR_START ||
                    IoControlCode == IOCTL_LMDR_STOP) {
                    RtlInitUnicodeString(&RequestPacket->EmulatedDomainName,NULL);
                    RtlInitUnicodeString(&RequestPacket->TransportName,NULL);
                }


                if (RequestPacket->Version == LMDR_REQUEST_PACKET_VERSION_DOM ||
                    RequestPacket->Version == LMDR_REQUEST_PACKET_VERSION) {

                    //
                    //  Relocate the transport name associated with this request.
                    //

                    if (RequestPacket->TransportName.Length != 0) {
                        PCHAR BufferStart = (PCHAR)RequestPacket->TransportName.Buffer;
                        PCHAR BufferEnd   = ((PCHAR)RequestPacket->TransportName.Buffer)+
                                            RequestPacket->TransportName.Length;

                        //
                        // Verify that the entire buffer indicated is contained within the input buffer.
                        //

                        if ((BufferStart < OriginalInputBuffer) ||
                            (BufferStart > OriginalInputBuffer + InputBufferLength) ||
                            (BufferEnd < OriginalInputBuffer) ||
                            (BufferEnd > OriginalInputBuffer + InputBufferLength)) {

                           //
                           // An invalid input string was specified.
                           //

                           try_return(Status = STATUS_INVALID_PARAMETER);

                        }

                        //
                        //  The name in within bounds, so convert it.
                        //

                        RequestPacket->TransportName.Buffer = (PWSTR)
                                    (((ULONG_PTR)Irp->AssociatedIrp.SystemBuffer)+
                                        (((ULONG_PTR)BufferStart) -
                                         ((ULONG_PTR)OriginalInputBuffer)));
                    } else {
                        RequestPacket->TransportName.MaximumLength = 0;
                        RequestPacket->TransportName.Buffer        = NULL;
                    }

                    //
                    //  Relocate the EmulatedDomain name associated with this request.
                    //

                    if (RequestPacket->EmulatedDomainName.Length != 0 &&
                        RequestPacket->Version != LMDR_REQUEST_PACKET_VERSION) {
                        PCHAR BufferStart = (PCHAR)RequestPacket->EmulatedDomainName.Buffer;
                        PCHAR BufferEnd   = ((PCHAR)RequestPacket->EmulatedDomainName.Buffer)+
                                            RequestPacket->EmulatedDomainName.Length;

                        //
                        // Verify that the entire buffer indicated is contained within the input buffer.
                        //

                        if ((BufferStart < OriginalInputBuffer) ||
                            (BufferStart > OriginalInputBuffer + InputBufferLength) ||
                            (BufferEnd < OriginalInputBuffer) ||
                            (BufferEnd > OriginalInputBuffer + InputBufferLength)) {

                           //
                           // An invalid input string was specified.
                           //

                           try_return(Status = STATUS_INVALID_PARAMETER);

                        }

                        //
                        //  The name in within bounds, so convert it.
                        //

                        RequestPacket->EmulatedDomainName.Buffer = (PWSTR)
                                    (((ULONG_PTR)Irp->AssociatedIrp.SystemBuffer)+
                                        (((ULONG_PTR)BufferStart) -
                                         ((ULONG_PTR)OriginalInputBuffer)));
                    } else {
                        RequestPacket->EmulatedDomainName.MaximumLength = 0;
                        RequestPacket->EmulatedDomainName.Buffer        = NULL;
                    }
                } else {
                    try_return(Status = STATUS_INVALID_PARAMETER);
                }

                //
                // Use the newly allocated input buffer from now on
                //
                InputBuffer = RequestPacket;

            } else {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }
        }

        //
        //  Probe/lock the output buffer in memory, or is
        //  available in the input buffer.
        //

        try {
            PLMDR_REQUEST_PACKET RequestPacket = InputBuffer;

            if (OutputBufferLength != 0) {
                BowserMapUsersBuffer(Irp, &OutputBuffer, OutputBufferLength);
                if (OutputBuffer == NULL)
                {
                    //
                    // Error: Could not map user buffer (out of resources?)
                    //
                    try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
                }
            }

            //
            // Convert old version requests to new version requests.
            //

            if (RequestPacket != NULL) {
                if (InputBufferLength < offsetof( LMDR_REQUEST_PACKET,Parameters )) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
                if (RequestPacket->Version == LMDR_REQUEST_PACKET_VERSION ) {
                    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );
                    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
                }
            }

        } except (BR_EXCEPTION) {
            try_return (Status = GetExceptionCode());
        }

        switch (MinorFunction) {

            //
            //  The NT redirector does not support local physical media, all
            //  such IoControlFile requests are unsupported.
            //

            case IRP_MN_USER_FS_REQUEST:

                //
                // If we're not starting the bowser,
                //  make sure it is started.
                //

                ExAcquireResourceSharedLite(&BowserDataResource, TRUE);
                if ( IoControlCode != IOCTL_LMDR_START ) {

                    if (BowserData.Initialized != TRUE) {
                        dlog(DPRT_FSCTL, ("Bowser not started.\n"));
                        ExReleaseResourceLite(&BowserDataResource);
                        Status = STATUS_REDIRECTOR_NOT_STARTED;
                        break;
                    }
                }

                //
                // Ensure a IOCTL_LMDR_STOP doesn't come in while
                //  we're working.
                //
                InterlockedIncrement( &BowserOperationCount );

                ExReleaseResourceLite(&BowserDataResource);

                switch (IoControlCode) {

                case IOCTL_LMDR_START:
                    Status = StartBowser(Wait, InFsd, DeviceObject, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_STOP:
                    Status = StopBowser(Wait, InFsd, DeviceObject,  InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_BIND_TO_TRANSPORT:
                case IOCTL_LMDR_BIND_TO_TRANSPORT_DOM:
                    BOWSECURITYCHECK ( Irp, IrpSp, Status );
                    Status = BowserBindToTransport(Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_UNBIND_FROM_TRANSPORT:
                case IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM:
                    Status = UnbindFromTransport(Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_ENUMERATE_TRANSPORTS:
                    Status = BowserEnumTransports(Wait, InFsd,
                                                  InputBuffer, &InputBufferLength,
                                                  OutputBuffer, OutputBufferLength,
                                                  (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;

                case IOCTL_LMDR_ENUMERATE_NAMES:
                    Status = EnumNames(Wait, InFsd,
                                       InputBuffer, &InputBufferLength,
                                       OutputBuffer, OutputBufferLength,
                                       (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;

                case IOCTL_LMDR_ADD_NAME:
                case IOCTL_LMDR_ADD_NAME_DOM:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = AddBowserName(Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_DELETE_NAME:
                case IOCTL_LMDR_DELETE_NAME_DOM:
                    Status = DeleteName (Wait, InFsd, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_ENUMERATE_SERVERS:
                    Status = EnumServers(Wait, InFsd,
                                         InputBuffer, &InputBufferLength,
                                         OutputBuffer, OutputBufferLength,
                                         (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;

                case IOCTL_LMDR_GET_BROWSER_SERVER_LIST:
                    Status = GetBrowserServerList(Irp, Wait, InFsd,
                                                  InputBuffer, &InputBufferLength,
                                                  OutputBuffer, OutputBufferLength,
                                                  (PUCHAR)OutputBuffer - (PUCHAR)Irp->UserBuffer);
                    CopyEnumResultsToCaller = TRUE;
                    break;


                case IOCTL_LMDR_GET_MASTER_NAME:
                    Status = GetMasterName(Irp, Wait, InFsd,
                                            InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_BECOME_BACKUP:
                    Status = HandleBecomeBackup(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_BECOME_MASTER:
                    Status = BecomeMaster(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE:
                    Status = WaitForMasterAnnounce(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_WRITE_MAILSLOT:
                    Status = WriteMailslot(Irp, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
                    break;

                case IOCTL_LMDR_UPDATE_STATUS:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = UpdateStatus(Irp, InFsd, InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_CHANGE_ROLE:
                    Status = WaitForBrowserRoleChange(Irp, InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_NEW_MASTER_NAME:
                    Status = WaitForNewMaster(Irp, InputBuffer, InputBufferLength);
                    break;

                case IOCTL_LMDR_QUERY_STATISTICS:
                    Status = QueryStatistics(Irp, OutputBuffer, &OutputBufferLength);
                    InputBufferLength = OutputBufferLength;
                    break;

                case IOCTL_LMDR_RESET_STATISTICS:
                    Status = ResetStatistics();
                    break;

                case IOCTL_LMDR_NETLOGON_MAILSLOT_READ:
                    Status = BowserReadPnp( Irp, OutputBufferLength, NETLOGON_PNP );
                    break;

                case IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE:
                    BOWSECURITYCHECK ( Irp, IrpSp, Status );

                    if (InputBufferLength <
                        (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(DWORD)) {
                        Status = STATUS_INVALID_PARAMETER;
                    } else  {
                        Status = BowserEnablePnp( InputBuffer, NETLOGON_PNP );
                    }
                    break;

                case IOCTL_LMDR_IP_ADDRESS_CHANGED:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = BowserIpAddressChanged( InputBuffer );
                    break;

                case IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT:
                    Status = EnableDisableTransport( InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_BROWSER_PNP_READ:
                    Status = BowserReadPnp( Irp, OutputBufferLength, BROWSER_PNP );
                    break;

                case IOCTL_LMDR_BROWSER_PNP_ENABLE:
                    if (InputBufferLength <
                        (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(DWORD)) {
                       Status = STATUS_INVALID_PARAMETER;
                    } else  {
                       Status = BowserEnablePnp( InputBuffer, BROWSER_PNP );
                    }
                    break;

                case IOCTL_LMDR_RENAME_DOMAIN:
                    BOWSECURITYCHECK(Irp, IrpSp, Status);
                    Status = BowserRenameDomain( InputBuffer, InputBufferLength );
                    break;

                case IOCTL_LMDR_WRITE_MAILSLOT_ASYNC:
                    Status = WriteMailslotEx(Irp, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, FALSE);
                    break;

#if DBG
                case IOCTL_LMDR_DEBUG_CALL:
                    Status = BowserDebugCall(InputBuffer, InputBufferLength);
                    break;
#endif

                default:
                    dlog(DPRT_FSCTL, ("Unknown IoControlFile %d\n", MinorFunction));
                    Status = STATUS_NOT_IMPLEMENTED;
                    break;
                }

                //
                // Allow IOCTL_LMDR_STOP
                //
                InterlockedDecrement( &BowserOperationCount );

                break;

            //
            //  All other IoControlFile API's
            //

            default:
                dlog(DPRT_FSCTL, ("Unknown IoControlFile %d\n", MinorFunction));
                Status = STATUS_NOT_IMPLEMENTED;
                break;
        }

        if (Status != STATUS_PENDING) {
            //
            //  Return the size of the input buffer to the caller.
            //      (But never more than the output buffer size).
            //

            Irp->IoStatus.Information = min(InputBufferLength, OutputBufferLength);

            //
            // If the input buffer needs to be copied back to the caller,
            //  do so now.
            //

            if ( CopyEnumResultsToCaller && OriginalInputBuffer != NULL ) {
                try {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForWrite( OriginalInputBuffer,
                                       InputBufferLength,
                                       sizeof(DWORD) );
                    }

                    //
                    // Copy the enumeration results to the caller.
                    //
                    // Don't copy the entire request packet back to the caller.
                    // It has other modified fields (e.g., relocated pointers)
                    //
                    if ( fThunk32bit ) {
                        // typecast to 32bit buffer
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.EntriesRead =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.EntriesRead;
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.TotalEntries =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalEntries;
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded;
                        ((PLMDR_REQUEST_PACKET32)OriginalInputBuffer)->Parameters.EnumerateNames.ResumeHandle =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.ResumeHandle;
                    }
                    else{
                        // native mode
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.EntriesRead =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.EntriesRead;
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.TotalEntries =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalEntries;
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.TotalBytesNeeded;
                        ((PLMDR_REQUEST_PACKET)OriginalInputBuffer)->Parameters.EnumerateNames.ResumeHandle =
                            ((PLMDR_REQUEST_PACKET)InputBuffer)->Parameters.EnumerateNames.ResumeHandle;
                    }

                } except (BR_EXCEPTION) {
                    try_return (Status = GetExceptionCode());
                }
            }
        }


try_exit:NOTHING;
    } finally {

        if (Status == STATUS_PENDING) {

            //
            //  If this is one of the longterm FsControl APIs, they are
            //  not to be processed in the FSP, they should just be returned
            //  to the caller with STATUS_PENDING.
            //

            if ((MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                ((IoControlCode == IOCTL_LMDR_GET_MASTER_NAME) ||
                 (IoControlCode == IOCTL_LMDR_BECOME_BACKUP) ||
                 (IoControlCode == IOCTL_LMDR_BECOME_MASTER) ||
                 (IoControlCode == IOCTL_LMDR_CHANGE_ROLE) ||
                 (IoControlCode == IOCTL_LMDR_NEW_MASTER_NAME) ||
                 (IoControlCode == IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE) ||
                 (IoControlCode == IOCTL_LMDR_NETLOGON_MAILSLOT_READ) ||
                 (IoControlCode == IOCTL_LMDR_BROWSER_PNP_READ) )) {
                //  return Status;

				//
				// If this is an asynchronous IOCTL that has created another new IRP
				// for completing the request, signal this IRP as completed
				//
            } else if ( IoControlCode == IOCTL_LMDR_WRITE_MAILSLOT_ASYNC ) {

				Status = STATUS_SUCCESS;
				BowserCompleteRequest(Irp, Status);
				
				//
				// If this call is to be processed in the FSP,
				//  do it.
				//
				// The input buffer has already been captured and relocated.
				//
			} else {
                Status = BowserFsdPostToFsp(DeviceObject, Irp);

                if (Status != STATUS_PENDING) {
                    BowserCompleteRequest(Irp, Status);
                }
            }

        } else {
            BowserCompleteRequest(Irp, Status);
        }
    }

    dlog(DPRT_FSCTL, ("Returning status: %X\n", Status));

#undef BOWSECURITYCHECK

    return Status;
}

NTSTATUS
StartBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Initialize request\n"));

    if (!ExAcquireResourceExclusiveLite(&BowserDataResource, Wait)) {
        return STATUS_PENDING;
    }

    try {

        if (BowserData.Initialized == TRUE) {
            dlog(DPRT_FSCTL, ("Bowser already started\n"));
            try_return(Status = STATUS_REDIRECTOR_STARTED);
        }

        //
        // Load a pointer to the users input buffer into InputBuffer
        //

        if (InputBufferLength != sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        BowserFspProcess = RxGetRDBSSProcess();

        BowserData.IllegalDatagramThreshold = InputBuffer->Parameters.Start.IllegalDatagramThreshold;
        BowserData.EventLogResetFrequency = InputBuffer->Parameters.Start.EventLogResetFrequency;

        BowserData.NumberOfMailslotBuffers = InputBuffer->Parameters.Start.NumberOfMailslotBuffers;
        BowserData.NumberOfServerAnnounceBuffers = InputBuffer->Parameters.Start.NumberOfServerAnnounceBuffers;

        BowserLogElectionPackets = InputBuffer->Parameters.Start.LogElectionPackets;
        BowserData.IsLanmanNt = InputBuffer->Parameters.Start.IsLanManNt;

#ifdef ENABLE_PSEUDO_BROWSER
        BowserData.PseudoServerLevel = BROWSER_NON_PSEUDO;
#endif

        Status = BowserpInitializeAnnounceTable();

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        BowserData.Initialized = TRUE;

        //
        //  Now that we know the browser parameters, we can kick off the
        //  browser timer...
        //

        IoStartTimer((PDEVICE_OBJECT )DeviceObject);


        KeQuerySystemTime(&BowserStartTime);

        RtlZeroMemory(&BowserStatistics, sizeof(BOWSER_STATISTICS));

        KeQuerySystemTime(&BowserStatistics.StartTime);

        KeInitializeSpinLock(&BowserStatisticsLock);

        try_return(Status = STATUS_SUCCESS);
try_exit:NOTHING;

    } finally {
        ExReleaseResourceLite(&BowserDataResource);
    }

    return Status;
    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}



NTSTATUS
StopBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine sets the username for the NT redirector.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject, - Device object of destination of Irp
    IN PIRP Irp, - Io Request Packet for request
    IN PIO_STACK_LOCATION IrpSp - Current I/O Stack location for request

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Initialize request\n"));

    if (!ExAcquireResourceExclusiveLite(&BowserDataResource, Wait)) {
        return STATUS_PENDING;
    }


    try {

        if (BowserData.Initialized != TRUE) {
            try_return(Status = STATUS_REDIRECTOR_NOT_STARTED);
        }

        //
        // Load a pointer to the users input buffer into InputBuffer
        //

        if (InputBufferLength != sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InFsd) {
            try_return(Status = STATUS_PENDING);
        }

        //
        // Prevent any new callers.
        //
        BowserData.Initialized = FALSE;

        //
        // Loop until our caller has the last outstanding reference.
        //

        while ( InterlockedDecrement( &BowserOperationCount ) != 0 ) {
            LARGE_INTEGER Interval;
            InterlockedIncrement( &BowserOperationCount );

            // Don't hold the resource while we're waiting.
            ExReleaseResourceLite(&BowserDataResource);

            // Sleep to relinquish the CPU
            Interval.QuadPart = -1000*10000; // .1 second
            KeDelayExecutionThread( KernelMode, FALSE, &Interval );

            ExAcquireResourceExclusiveLite(&BowserDataResource, TRUE);
        }
        InterlockedIncrement( &BowserOperationCount );


        //
        // Finally stop the bowser now that we know we have exclusive access
        //

        Status = BowserUnbindFromAllTransports();

        if (!NT_SUCCESS(Status)) {
            dlog(DPRT_FSCTL, ("StopBowser: Failed to Unbind transports <0x%x>\n", Status));
            // Fall through to continue cleanup regardless.
        }

        Status = BowserpUninitializeAnnounceTable();

        if (!NT_SUCCESS(Status)) {
            dlog(DPRT_FSCTL, ("StopBowser: Failed to Uninitialize AnnounceTable <0x%x>\n", Status));
            // Fall through to continue cleanup regardless.
        }

        //
        //  Now that we know the browser parameters, we can kick off the
        //  browser timer...
        //

        IoStopTimer((PDEVICE_OBJECT )DeviceObject);

        try_return(Status = STATUS_SUCCESS);
try_exit:NOTHING;

    } finally {

        ExReleaseResourceLite(&BowserDataResource);
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}


NTSTATUS
BowserBindToTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    UNICODE_STRING TransportName;
    UNICODE_STRING EmulatedComputerName;
    UNICODE_STRING EmulatedDomainName;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    try {
        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength <= (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.Bind.TransportName)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        //
        // Get the transport name from the input buffer.
        //

        TransportName.MaximumLength = TransportName.Length = (USHORT )
                                                InputBuffer->Parameters.Bind.TransportNameLength;
        TransportName.Buffer = InputBuffer->Parameters.Bind.TransportName;
		//
		// If the passed name is not a valid unicode string, return error
		//
		if ( !BowserValidUnicodeString(&TransportName) ) {
			try_return( Status = STATUS_INVALID_PARAMETER );
		}

        ENSURE_IN_INPUT_BUFFER( &TransportName, FALSE, FALSE );

        //
        // Ignore the new NetbiosSmb transport
        //

        {
            UNICODE_STRING NetbiosSmb;
            RtlInitUnicodeString( &NetbiosSmb, L"\\Device\\NetbiosSmb" );
            if ( RtlEqualUnicodeString(&TransportName, &NetbiosSmb, TRUE )) {
                try_return(Status = STATUS_SUCCESS);
            }
        }

        //
        // Get & verify emulated domain name
        //

        EmulatedDomainName = InputBuffer->EmulatedDomainName;
        ENSURE_IN_INPUT_BUFFER( &EmulatedDomainName, FALSE, FALSE );


        //
        // Get the emulated computer name from the input buffer.
        //  (Callers that don't want us to do the add names don't pass the computername)
        //

        if ( InputBuffer->Level ) {
            ENSURE_IN_INPUT_BUFFER_STR( (LPWSTR)((PCHAR)TransportName.Buffer+TransportName.Length) );
            RtlInitUnicodeString( &EmulatedComputerName,
                                  (LPWSTR)((PCHAR)TransportName.Buffer+TransportName.Length) );
        } else {
            RtlInitUnicodeString( &EmulatedComputerName, NULL );
        }

        //
        // Fail if either EmulatedDomainName or EmulatedComputerName is missing.
        //

        if ( EmulatedDomainName.Length == 0 || EmulatedComputerName.Length == 0 ) {
            try_return(Status = STATUS_INVALID_COMPUTER_NAME);
        }


        dlog(DPRT_FSCTL,
             ("%wZ: %wZ: %wZ: NtDeviceIoControlFile: Bind to transport\n",
             &EmulatedDomainName,
             &EmulatedComputerName,
             &TransportName ));

        Status = BowserTdiAllocateTransport( &TransportName,
                                             &EmulatedDomainName,
                                             &EmulatedComputerName );



        try_return(Status);

try_exit:NOTHING;
    } finally {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);
}


NTSTATUS
UnbindFromTransport (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING TransportName;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Unbind from transport\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength <= (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.Unbind.TransportName)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        //
        // Capture transport name.
        //
        TransportName.MaximumLength = TransportName.Length = (USHORT )
                                                InputBuffer->Parameters.Unbind.TransportNameLength;
        TransportName.Buffer = InputBuffer->Parameters.Unbind.TransportName;
        ENSURE_IN_INPUT_BUFFER( &TransportName, FALSE, FALSE );
        dlog(DPRT_FSCTL, ("%wZ", &TransportName));
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        Status = BowserFreeTransportByName(&TransportName, &InputBuffer->EmulatedDomainName );

        try_return(Status);

try_exit:NOTHING;
    } finally {

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);
}

NTSTATUS
BowserEnumTransports (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine enumerates the transports bound into the bowser.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: EnumerateTransports\n"));


    //
    // Check some fields in the input buffer.
    //

    if (*InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (InputBuffer->Type != EnumerateXports) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (OutputBufferLength < sizeof(LMDR_TRANSPORT_LIST)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ReturnStatus;
    }

    Status = BowserEnumerateTransports(OutputBuffer,
                    OutputBufferLength,
                    &InputBuffer->Parameters.EnumerateTransports.EntriesRead,
                    &InputBuffer->Parameters.EnumerateTransports.TotalEntries,
                    &InputBuffer->Parameters.EnumerateTransports.TotalBytesNeeded,
                    OutputBufferDisplacement);

    *InputBufferLength = sizeof(LMDR_REQUEST_PACKET);

ReturnStatus:
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}

NTSTATUS
EnumNames (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG RetInputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine enumerates the names bound into the bowser.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;
    PTRANSPORT Transport = NULL;
    ULONG InputBufferLength = *RetInputBufferLength;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: EnumerateNames\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Type != EnumerateNames) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (OutputBufferLength < sizeof(DGRECEIVE_NAMES)) {
            try_return (Status = STATUS_BUFFER_TOO_SMALL);
        }

        //
        // Find the emulated domain the names are to be enumerated for
        //

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );
        DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

        if ( DomainInfo == NULL ) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }


        //
        // If we want to limit our search to a particular transport,
        //  lookup that transport.
        //

        if ( InputBuffer->TransportName.Length != 0 ) {

            ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
            Transport = BowserFindTransport ( &InputBuffer->TransportName,
                                              &InputBuffer->EmulatedDomainName );
            dprintf(DPRT_REF, ("Called Find transport %lx from EnumNames.\n", Transport));

            if ( Transport == NULL ) {
                try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }
        }

        Status = BowserEnumerateNamesInDomain(
                        DomainInfo,
                        Transport,
                        OutputBuffer,
                        OutputBufferLength,
                        &InputBuffer->Parameters.EnumerateTransports.EntriesRead,
                        &InputBuffer->Parameters.EnumerateTransports.TotalEntries,
                        &InputBuffer->Parameters.EnumerateTransports.TotalBytesNeeded,
                        OutputBufferDisplacement);

        *RetInputBufferLength = sizeof(LMDR_REQUEST_PACKET);

try_exit:NOTHING;
    } finally {
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

        if ( Transport != NULL ) {
            BowserDereferenceTransport( Transport );
        }
    }
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}


NTSTATUS
DeleteName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    PDOMAIN_INFO DomainInfo = NULL;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Delete Name\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength <= (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.AddDelName.Name)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        // NULL name means to delete all names of that name type.
        Name.MaximumLength = Name.Length = (USHORT )
                      InputBuffer->Parameters.AddDelName.DgReceiverNameLength;
        Name.Buffer = InputBuffer->Parameters.AddDelName.Name;
        ENSURE_IN_INPUT_BUFFER( &Name, TRUE, FALSE );

        //
        // Find the emulated domain the name is to be deleted for
        //

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );
        DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

        if ( DomainInfo == NULL ) {
            try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        dlog(DPRT_FSCTL, ("Deleting \"%wZ\"", &Name));

        Status = BowserDeleteNameByName(DomainInfo, &Name, InputBuffer->Parameters.AddDelName.Type);

        try_return(Status);

try_exit:NOTHING;
    } finally {

        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);
}


NTSTATUS
EnumServers (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN PULONG RetInputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING DomainName;
    ULONG InputBufferLength = *RetInputBufferLength;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: EnumerateServers\n"));

    //
    // Check some fields in the input buffer.
    //

    try {

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Type != EnumerateServers) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Level != 100 && InputBuffer->Level != 101) {
            try_return (Status = STATUS_INVALID_LEVEL);
        }

        if (OutputBufferLength < sizeof(SERVER_INFO_100)) {
            try_return (Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Level == 101 && OutputBufferLength < sizeof(SERVER_INFO_101)) {
            try_return (Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Parameters.EnumerateServers.DomainNameLength != 0) {
            DomainName.Buffer = InputBuffer->Parameters.EnumerateServers.DomainName;
            DomainName.Length = DomainName.MaximumLength =
                (USHORT )InputBuffer->Parameters.EnumerateServers.DomainNameLength;
            ENSURE_IN_INPUT_BUFFER( &DomainName, FALSE, FALSE );

        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, FALSE, FALSE );
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, TRUE, FALSE );
        Status = BowserEnumerateServers( InputBuffer->Level, &InputBuffer->LogonId,
                        &InputBuffer->Parameters.EnumerateServers.ResumeHandle,
                        InputBuffer->Parameters.EnumerateServers.ServerType,
                        (InputBuffer->TransportName.Length != 0 ? &InputBuffer->TransportName : NULL),
                        &InputBuffer->EmulatedDomainName,
                        (InputBuffer->Parameters.EnumerateServers.DomainNameLength != 0 ? &DomainName : NULL),
                        OutputBuffer,
                        OutputBufferLength,
                        &InputBuffer->Parameters.EnumerateServers.EntriesRead,
                        &InputBuffer->Parameters.EnumerateServers.TotalEntries,
                        &InputBuffer->Parameters.EnumerateServers.TotalBytesNeeded,
                        OutputBufferDisplacement);

        *RetInputBufferLength = sizeof(LMDR_REQUEST_PACKET);

try_exit:NOTHING;
    } finally {
    }
    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InFsd);
}



NTSTATUS
AddBowserName (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine adds a reference to a file object created with .

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    PTRANSPORT Transport = NULL;
    PDOMAIN_INFO DomainInfo = NULL;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Bind to transport\n"));

    try {
        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength <= (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.AddDelName.Name)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }


        Name.MaximumLength = Name.Length = (USHORT )
                           InputBuffer->Parameters.AddDelName.DgReceiverNameLength;
        Name.Buffer = InputBuffer->Parameters.AddDelName.Name;
        ENSURE_IN_INPUT_BUFFER( &Name, FALSE, FALSE );

        dlog(DPRT_FSCTL, ("%wZ", &Name));

        //
        // If the transport was specified,
        //  just add the name on that transport.
        //
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );
        if (InputBuffer->TransportName.Length != 0) {
            ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
            Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
            dprintf(DPRT_REF, ("Called Find transport %lx from AddBowserName.\n", Transport));

            if (Transport == NULL) {
                try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }

        //
        // If the transport wasn't specified,
        //  just add the name on the specified domain.
        //
        // It doesn't make sense to add the name on ALL transports. Either the domain name
        // or the transport name must be specified.
        //

        } else {
            DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

            if ( DomainInfo == NULL ) {
                try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }


        }

        Status = BowserAllocateName(&Name,
                                    InputBuffer->Parameters.AddDelName.Type,
                                    Transport,
                                    DomainInfo );

        try_return(Status);

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;

    UNREFERENCED_PARAMETER(Wait);
    UNREFERENCED_PARAMETER(InputBufferLength);

}

NTSTATUS
GetBrowserServerList(
    IN PIRP Irp,
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN OUT PULONG RetInputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    IN ULONG_PTR OutputBufferDisplacement
    )

/*++

Routine Description:

    This routine will return the list of browser servers for the specified
    net on the specified domain.

Arguments:

    IN BOOLEAN Wait, - True IFF redirector can block callers thread on request
    IN BOOLEAN InFsd, - True IFF this request is initiated from the FSD.
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN OUT PULONG OutputBufferLength

Return Value:

    NTSTATUS - Status of operation.

--*/
{

    NTSTATUS Status;
    UNICODE_STRING DomainName;
    PTRANSPORT Transport = NULL;
    ULONG BrowserServerListLength;
    PWSTR *BrowserServerList = NULL;
    BOOLEAN IsPrimaryDomain = FALSE;
    BOOLEAN TransportBrowserListAcquired = FALSE;
    PVOID OutputBufferEnd = (PCHAR)OutputBuffer + OutputBufferLength;
    PPAGED_TRANSPORT PagedTransport;
    ULONG InputBufferLength = *RetInputBufferLength;
    BOOLEAN fThunk32bit;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: GetBrowserServerList\n"));

    try {

        //
        // Check some fields in the input buffer.
        //


        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->TransportName.Length == 0 ||
            InputBuffer->TransportName.Buffer == NULL) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

		//
		// Check the alignment of the output buffer
		//

		if (!POINTER_IS_ALIGNED( OutputBuffer, sizeof(PWSTR) ) ) {
            try_return(Status = STATUS_INVALID_PARAMETER);
		}

#ifdef _WIN64
        fThunk32bit = IoIs32bitProcess(Irp);
#else
        // If we're in 32 bit (e.g. call above isn't available), use unchanged functionality
        // i.e. pure new-64-bit == pure old-32-bit == homogeneous environment. Thus, set to FALSE.
        fThunk32bit = FALSE;
#endif


        if (InputBuffer->Parameters.GetBrowserServerList.DomainNameLength != 0) {
            DomainName.Buffer = InputBuffer->Parameters.GetBrowserServerList.DomainName;
            DomainName.Length = DomainName.MaximumLength =
                (USHORT)InputBuffer->Parameters.GetBrowserServerList.DomainNameLength;
            ENSURE_IN_INPUT_BUFFER( &DomainName, FALSE, fThunk32bit );
        } else {
            DomainName.Length = 0;
            DomainName.Buffer = NULL;
        }

        //
        // See if the specified domain is an emulated domain.
        //

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, fThunk32bit );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &DomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from GetBrowserServerList.\n", Transport));

        if (Transport == NULL) {

            //
            // Otherwise simply use the primary domain transport
            //

            Transport = BowserFindTransport(&InputBuffer->TransportName, NULL );
            dprintf(DPRT_REF, ("Called Find transport %lx from GetBrowserServerList (2).\n", Transport));

            if ( Transport == NULL ) {
                try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
            }
        }

        PagedTransport = Transport->PagedTransport;

        if (!ExAcquireResourceSharedLite(&Transport->BrowserServerListResource, Wait)) {
            try_return(Status = STATUS_PENDING);
        }

        TransportBrowserListAcquired = TRUE;

        //
        //  If this request is for the primary domain and there are no entries
        //  in the cached list, or if it is not for the primary domain, or
        //  if we are supposed to force a rescan of the list, get the list
        //  from the master for that domain..
        //

        if ((DomainName.Length == 0) ||
             RtlEqualUnicodeString(&DomainName, &Transport->DomainInfo->DomUnicodeDomainName, TRUE)) {
            IsPrimaryDomain = TRUE;

            BrowserServerList = PagedTransport->BrowserServerListBuffer;

            BrowserServerListLength = PagedTransport->BrowserServerListLength;
        }


        if ((IsPrimaryDomain &&
             (BrowserServerListLength == 0))

                ||

            !IsPrimaryDomain

                ||

            (InputBuffer->Parameters.GetBrowserServerList.ForceRescan)) {

            //
            //  We need to re-gather the transport list.
            //  Re-acquire the BrowserServerList resource for exclusive access.
            //

            ExReleaseResourceLite(&Transport->BrowserServerListResource);

            TransportBrowserListAcquired = FALSE;

            if (!ExAcquireResourceExclusiveLite(&Transport->BrowserServerListResource, Wait)) {
                try_return(Status = STATUS_PENDING);
            }

            TransportBrowserListAcquired = TRUE;

            //
            //  If we are being asked to rescan the list, free it up.
            //

            if (InputBuffer->Parameters.GetBrowserServerList.ForceRescan &&
                PagedTransport->BrowserServerListBuffer != NULL) {

                BowserFreeBrowserServerList(PagedTransport->BrowserServerListBuffer,
                                        PagedTransport->BrowserServerListLength);

                PagedTransport->BrowserServerListLength = 0;

                PagedTransport->BrowserServerListBuffer = NULL;

            }

            //
            //  If there are still no servers in the list, get the list.
            //

            Status = BowserGetBrowserServerList(Irp,
                                                 Transport,
                                                 (DomainName.Length == 0 ?
                                                        NULL :
                                                        &DomainName),
                                                 &BrowserServerList,
                                                 &BrowserServerListLength);
            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            if (IsPrimaryDomain) {

                //
                // Save away the list of servers retreived in the transport.
                //
                if (PagedTransport->BrowserServerListBuffer != NULL) {
                    BowserFreeBrowserServerList(
                       PagedTransport->BrowserServerListBuffer,
                       PagedTransport->BrowserServerListLength);
                }

                PagedTransport->BrowserServerListBuffer = BrowserServerList;
                PagedTransport->BrowserServerListLength = BrowserServerListLength;
            }

        }

        //
        //  If there any servers in the browser server list, we want to
        //  pick the first 3 of them and return them to the caller.
        //


        if (BrowserServerListLength != 0) {
            ULONG    i;
            PWSTR   *ServerList      = OutputBuffer;
            BOOLEAN  BufferRemaining = TRUE;

            InputBuffer->Parameters.GetBrowserServerList.TotalEntries = 0;

            InputBuffer->Parameters.GetBrowserServerList.EntriesRead = 0;

            InputBuffer->Parameters.GetBrowserServerList.TotalBytesNeeded = 0;

            //
            //  Now pick the first 3 entries from the list to return.
            //

            for ( i = 0 ; i < min(3, BrowserServerListLength) ; i ++ ) {
                PWSTR Temp;

                InputBuffer->Parameters.GetBrowserServerList.TotalEntries += 1;

                InputBuffer->Parameters.GetBrowserServerList.TotalBytesNeeded += wcslen(BrowserServerList[i])*sizeof(WCHAR);

                Temp = BrowserServerList[i];

                dlog(DPRT_CLIENT, ("Packing server name %ws into buffer...", Temp));

                //
                //  Pack the entry into the users buffer.
                //

                if (BufferRemaining &&
                    BowserPackUnicodeString(&Temp,
                            wcslen(Temp)*sizeof(WCHAR),
                            OutputBufferDisplacement,
                            &ServerList[i+1],
                            &OutputBufferEnd) != 0) {
                    ServerList[i] = Temp;
                    InputBuffer->Parameters.GetBrowserServerList.EntriesRead += 1;
                } else {
                    BufferRemaining = FALSE;
                }


            }
        }

        //
        //  Set the number of bytes to copy on return.
        //

        *RetInputBufferLength = sizeof(LMDR_REQUEST_PACKET);

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {

            if (TransportBrowserListAcquired) {
                ExReleaseResourceLite(&Transport->BrowserServerListResource);
            }

            BowserDereferenceTransport(Transport);
        }

        if (NT_SUCCESS(Status) && !IsPrimaryDomain && (BrowserServerList != NULL) ) {
            BowserFreeBrowserServerList(BrowserServerList,
                                BrowserServerListLength);

        }

    }

    return(Status);

    UNREFERENCED_PARAMETER(Irp);

    UNREFERENCED_PARAMETER(InFsd);

}

NTSTATUS
HandleBecomeBackup (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when a request
    to make the workstation become a backup browser is received.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: %wZ: Get Announce Request\n", &InputBuffer->TransportName ));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from HandleBecomeBackup.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->BecomeBackupQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
BecomeMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when the workstation
    becomes a master browser server.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: BecomeMaster\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from BecomeMaster.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        LOCK_TRANSPORT (Transport);

        if (Transport->ElectionState == DeafToElections) {
            Transport->ElectionState = Idle;
        }

        UNLOCK_TRANSPORT (Transport);

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->BecomeMasterQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
WaitForMasterAnnounce (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when the workstation
    becomes a master browser server.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS           Status;
    PTRANSPORT         Transport = NULL;
    PIO_STACK_LOCATION IrpSp     = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: WaitForMasterAnnounce\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.WaitForMasterAnnouncement.Name)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if ( (InputBuffer->TransportName.Length & 1) != 0 ) {
            // invalid unicode string. bug 55448.
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WaitForMasterAnnounce.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->WaitForMasterAnnounceQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}


NTSTATUS
UpdateStatus(
    IN PIRP Irp,
    IN BOOLEAN InFsd,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTRANSPORT Transport = NULL;
    ULONG NewStatus;
    BOOLEAN TransportLocked = FALSE;
    PPAGED_TRANSPORT PagedTransport;
    BOOLEAN ProcessAttached = FALSE;
    KAPC_STATE ApcState;


    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: Update status\n"));

    if (IoGetCurrentProcess() != BowserFspProcess) {
        KeStackAttachProcess(BowserFspProcess, &ApcState );

        ProcessAttached = TRUE;
    }

    try {

        if (InputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters)+sizeof(InputBuffer->Parameters.UpdateStatus)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from UpdateStatus.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        PagedTransport = Transport->PagedTransport;

        NewStatus = InputBuffer->Parameters.UpdateStatus.NewStatus;

        BowserData.MaintainServerList = InputBuffer->Parameters.UpdateStatus.MaintainServerList;

        BowserData.IsLanmanNt = InputBuffer->Parameters.UpdateStatus.IsLanmanNt;


#ifdef ENABLE_PSEUDO_BROWSER
        BowserData.PseudoServerLevel = (DWORD)InputBuffer->Parameters.UpdateStatus.PseudoServerLevel;
#endif

        LOCK_TRANSPORT(Transport);

        TransportLocked = TRUE;


        //
        //  We are being called to update our state.  There are several
        //  actions that should be performed on the state change:
        //
        //  New Role |               Previous Role
        //           |  Potential Browser | Backup Browser | Master Browser
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // Potential |    N/A             |      N/A       |     N/A
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // Backup    |  Update role       |      N/A       |     N/A
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // Master    |  Update role       |  Update role   |     N/A
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //           |                    |                |
        // None      |  Remove elect      |  Remove elect  | Remove all names
        //           |                    |                |
        // ----------+--------------------+----------------+----------------
        //

        dlog(DPRT_BROWSER,
             ("%s: %ws: Update status to %lx\n",
             Transport->DomainInfo->DomOemDomainName,
             PagedTransport->TransportName.Buffer,
             NewStatus));

        PagedTransport->ServiceStatus = NewStatus;

        //
        // If the caller says we should have the 1E name registered,
        //  and we don't.
        //  Do so now.
        //

        if ( PagedTransport->Role == None &&
            (NewStatus & SV_TYPE_POTENTIAL_BROWSER) != 0 ) {

            dlog(DPRT_BROWSER,
                 ("%s: %ws: New status indicates we are a potential browser, but we're not\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            PagedTransport->Role = PotentialBackup;

            UNLOCK_TRANSPORT(Transport);

            TransportLocked = FALSE;

            Status = BowserAllocateName(
                                &Transport->DomainInfo->DomUnicodeDomainName,
                                BrowserElection,
                                Transport,
                                Transport->DomainInfo );

            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            LOCK_TRANSPORT(Transport);

            TransportLocked = TRUE;
        }


        //
        //  If we are a master, then update appropriately.
        //

        if (PagedTransport->Role == Master) {

            PagedTransport->NumberOfServersInTable = InputBuffer->Parameters.UpdateStatus.NumberOfServersInTable;

            //
            //  If the new status doesn't indicate that we should be a master
            //  browser, flag it as such.
            //

            if (!(NewStatus & SV_TYPE_MASTER_BROWSER)) {
                dlog(DPRT_BROWSER,
                     ("%s: %ws: New status indicates we are not a master browser\n",
                      Transport->DomainInfo->DomOemDomainName,
                      PagedTransport->TransportName.Buffer ));

                //
                //  We must be a backup now, if we're not a master.
                //

                PagedTransport->Role = Backup;

                //
                //  Stop processing announcements on this transport.
                //

                Status = BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

                UNLOCK_TRANSPORT(Transport);

                TransportLocked = FALSE;

                Status = BowserDeleteTransportNameByName(Transport, NULL, MasterBrowser);

                if (!NT_SUCCESS(Status)) {
                    dlog(DPRT_BROWSER,
                         ("%s: %ws: Unable to remove master name: %X\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer,
                         Status));
                }

                Status = BowserDeleteTransportNameByName(Transport, NULL,
                                DomainAnnouncement);

                if (!NT_SUCCESS(Status)) {

                    dlog(DPRT_BROWSER,
                         ("%s: %ws: Unable to delete domain announcement name: %X\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer,
                         Status));
                }


                if (!(NewStatus & SV_TYPE_BACKUP_BROWSER)) {

                    //
                    //  We've stopped being a master browser, and we're not
                    //  going to be a backup browser. We want to toss our
                    //  cached browser server list just in case we're on the
                    //  list.
                    //

                    ExAcquireResourceExclusiveLite(&Transport->BrowserServerListResource, TRUE);

                    if (PagedTransport->BrowserServerListBuffer != NULL) {
                        BowserFreeBrowserServerList(PagedTransport->BrowserServerListBuffer,
                                                    PagedTransport->BrowserServerListLength);

                        PagedTransport->BrowserServerListLength = 0;

                        PagedTransport->BrowserServerListBuffer = NULL;

                    }

                    ExReleaseResourceLite(&Transport->BrowserServerListResource);

                }

                LOCK_TRANSPORT(Transport);

                TransportLocked = TRUE;

            }
        } else if (NewStatus & SV_TYPE_MASTER_BROWSER) {
            dlog(DPRT_BROWSER | DPRT_MASTER,
                 ("%s: %ws: New status indicates we should be master, but we're not.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            UNLOCK_TRANSPORT(Transport);

            TransportLocked = FALSE;

            Status = BowserBecomeMaster (Transport);

            LOCK_TRANSPORT(Transport);

            dlog(DPRT_BROWSER | DPRT_MASTER,
                 ("%s: %ws: Master promotion status: %lX.\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer,
                 Status));

            TransportLocked = TRUE;

            ASSERT ((PagedTransport->Role == Master) || !NT_SUCCESS(Status));

        }

        if (!NT_SUCCESS(Status) || PagedTransport->Role == Master) {
            try_return(Status);
        }


        //
        //  If we are a backup, then update appropriately.
        //

        if (PagedTransport->Role == Backup) {

            if (!(NewStatus & SV_TYPE_BACKUP_BROWSER)) {
                dlog(DPRT_BROWSER,
                     ("%s: %ws: New status indicates we are not a backup browser\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));

                PagedTransport->Role = PotentialBackup;

                //
                //  We've stopped being a browser. We want to toss our cached
                //  browser list in case we're on the list.
                //

                ExAcquireResourceExclusiveLite(&Transport->BrowserServerListResource, TRUE);

                if (PagedTransport->BrowserServerListBuffer != NULL) {
                    BowserFreeBrowserServerList(PagedTransport->BrowserServerListBuffer,
                                                PagedTransport->BrowserServerListLength);

                    PagedTransport->BrowserServerListLength = 0;

                    PagedTransport->BrowserServerListBuffer = NULL;
                }

                ExReleaseResourceLite(&Transport->BrowserServerListResource);

            }

        } else if (NewStatus & SV_TYPE_BACKUP_BROWSER) {

            dlog(DPRT_BROWSER,
                 ("%s: %ws: New status indicates we are a backup, but we think we are not\n",
                 Transport->DomainInfo->DomOemDomainName,
                 PagedTransport->TransportName.Buffer ));

            PagedTransport->Role = Backup;

            Status = STATUS_SUCCESS;

        }

        if (!NT_SUCCESS(Status) || PagedTransport->Role == Backup) {
            try_return(Status);
        }

        //
        //  If we are a potential backup, then update appropriately.
        //

        if (PagedTransport->Role == PotentialBackup) {

            if (!(NewStatus & SV_TYPE_POTENTIAL_BROWSER)) {
                dlog(DPRT_BROWSER,
                     ("%s: %ws: New status indicates we are not a potential browser\n",
                     Transport->DomainInfo->DomOemDomainName,
                     PagedTransport->TransportName.Buffer ));

                UNLOCK_TRANSPORT(Transport);

                TransportLocked = FALSE;

                Status = BowserDeleteTransportNameByName(Transport, NULL,
                                BrowserElection);

                if (!NT_SUCCESS(Status)) {
                    dlog(DPRT_BROWSER,
                         ("%s: %ws: Unable to remove election name: %X\n",
                         Transport->DomainInfo->DomOemDomainName,
                         PagedTransport->TransportName.Buffer,
                         Status));

                    try_return(Status);
                }

                LOCK_TRANSPORT(Transport);
                TransportLocked = TRUE;

                PagedTransport->Role = None;

            }

        }

        try_return(Status);

try_exit:NOTHING;
    } finally {
        if (TransportLocked) {
            UNLOCK_TRANSPORT(Transport);
        }

        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }

        if (ProcessAttached) {
            KeUnstackDetachProcess( &ApcState );
        }
    }

    return Status;
}

NTSTATUS
BowserStopProcessingAnnouncements(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Context
    )
{
    PAGED_CODE();

    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (TransportName->NameType == TransportName->PagedTransportName->Name->NameType);

    if ((TransportName->NameType == OtherDomain) ||
        (TransportName->NameType == MasterBrowser) ||
        (TransportName->NameType == PrimaryDomain) ||
        (TransportName->NameType == BrowserElection) ||
        (TransportName->NameType == DomainAnnouncement)) {

        if (TransportName->ProcessHostAnnouncements) {

            BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

            TransportName->ProcessHostAnnouncements = FALSE;
        }
    }

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(Context);
}

NTSTATUS
WaitForBrowserRoleChange (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when a request
    to make the workstation become a backup browser is received.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: WaitForMasterRoleChange\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength < sizeof(LMDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WaitForBrowserRoleChange.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->ChangeRoleQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}


NTSTATUS
WriteMailslot (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

	// Just call WriteMailslotEx with waitforcompletion true
	Status = WriteMailslotEx (
		Irp,
		InputBuffer,
		InputBufferLength,
		OutputBuffer,
		OutputBufferLength,
		TRUE );

	return Status;
}


NTSTATUS
WriteMailslotEx (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
	IN BOOLEAN WaitForCompletion
    )

/*++

Routine Description:

    This routine will announce the primary domain to the world

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;
    UNICODE_STRING DestinationName;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: %wZ: Write MailslotEx\n", &InputBuffer->TransportName ));

    try {

        ANSI_STRING MailslotName;

        if (InputBufferLength <= (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.SendDatagram.Name) ||
            OutputBufferLength < 1) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WriteMailslotEx.\n", Transport));

        if (Transport == NULL) {
            try_return(Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        DestinationName.Length = DestinationName.MaximumLength =
            (USHORT)InputBuffer->Parameters.SendDatagram.NameLength;
        DestinationName.Buffer = InputBuffer->Parameters.SendDatagram.Name;
        if ( DestinationName.Length == 0  ) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }
        ENSURE_IN_INPUT_BUFFER( &DestinationName, TRUE, FALSE );

        if (InputBuffer->Parameters.SendDatagram.MailslotNameLength != 0) {

            MailslotName.Buffer = ((PCHAR)InputBuffer->Parameters.SendDatagram.Name)+
                            InputBuffer->Parameters.SendDatagram.NameLength;
            MailslotName.MaximumLength = (USHORT)
                InputBuffer->Parameters.SendDatagram.MailslotNameLength;
            MailslotName.Length = MailslotName.MaximumLength - 1;
            ENSURE_IN_INPUT_BUFFER( &MailslotName, FALSE, FALSE );
            if ( MailslotName.Buffer[MailslotName.Length] != '\0' ) {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }

        } else {
            MailslotName.Buffer = MAILSLOT_BROWSER_NAME;
        }


        Status = BowserSendSecondClassMailslot(Transport,
                        &DestinationName,
                        InputBuffer->Parameters.SendDatagram.DestinationNameType,
                        OutputBuffer,
                        OutputBufferLength,
                        WaitForCompletion,
                        MailslotName.Buffer,
                        NULL);

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
WaitForNewMaster (
    IN PIRP Irp,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine will queue a request that will complete when a new workstation
    becomes the master browser server.

Arguments:

    IN PIRP Irp - I/O request packet describing request.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    NTSTATUS           Status;
    PTRANSPORT         Transport           = NULL;
    UNICODE_STRING     ExistingMasterName;
    PIO_STACK_LOCATION IrpSp               = IoGetCurrentIrpStackLocation(Irp);

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: WaitForNewMaster\n"));

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];
        WCHAR ExistingMasterNameBuffer[CNLEN+1];

        if (InputBufferLength <= (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.GetMasterName.Name)) {
           try_return(Status = STATUS_INVALID_PARAMETER);
        }

        ExistingMasterName.Buffer = InputBuffer->Parameters.GetMasterName.Name;
        ExistingMasterName.Length = ExistingMasterName.MaximumLength = (USHORT)InputBuffer->Parameters.GetMasterName.MasterNameLength;
        ENSURE_IN_INPUT_BUFFER(&ExistingMasterName, FALSE, FALSE);

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from WaitForNewMaster.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        if (Transport->PagedTransport->Flags & DIRECT_HOST_IPX) {
            try_return (Status = STATUS_NOT_SUPPORTED);
        }

        if (Transport->PagedTransport->MasterName.Length != 0) {
            UNICODE_STRING ExistingMasterNameCopy;
            WCHAR MasterNameBuffer[CNLEN+1];

            ExistingMasterNameCopy.Buffer = MasterNameBuffer;
            ExistingMasterNameCopy.MaximumLength = sizeof(MasterNameBuffer);

            Status = RtlUpcaseUnicodeString(&ExistingMasterNameCopy, &ExistingMasterName, FALSE);

            if (!NT_SUCCESS(Status)) {
                try_return (Status);
            }

            //
            //  If the name the application passed in was not the same as the
            //  name we have stored locally, we complete the request immediately,
            //  since the name changed between when we last determined the name
            //  and now.
            //

            LOCK_TRANSPORT(Transport);

            if (!RtlEqualUnicodeString(&ExistingMasterNameCopy, &Transport->PagedTransport->MasterName, FALSE)) {

                RtlCopyUnicodeString(&ExistingMasterNameCopy, &Transport->PagedTransport->MasterName);

                UNLOCK_TRANSPORT(Transport);

                if (InputBufferLength <
                    ((ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.GetMasterName.Name)+
                    ExistingMasterNameCopy.Length+3*sizeof(WCHAR))) {
                   try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }

                InputBuffer->Parameters.GetMasterName.Name[0] = L'\\';

                InputBuffer->Parameters.GetMasterName.Name[1] = L'\\';

                RtlCopyMemory(&InputBuffer->Parameters.GetMasterName.Name[2], ExistingMasterNameCopy.Buffer,
                    ExistingMasterNameCopy.Length);

                InputBuffer->Parameters.GetMasterName.MasterNameLength = ExistingMasterNameCopy.Length+2*sizeof(WCHAR);

                InputBuffer->Parameters.GetMasterName.Name[2+(ExistingMasterNameCopy.Length/sizeof(WCHAR))] = UNICODE_NULL;

                Irp->IoStatus.Information = FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.GetMasterName.Name) +
                    ExistingMasterNameCopy.Length+3*sizeof(WCHAR);;

                try_return (Status = STATUS_SUCCESS);
            }

            UNLOCK_TRANSPORT(Transport);
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters.GetMasterName.Name)+3*sizeof(WCHAR)) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        Status = BowserQueueNonBufferRequest(Irp,
                                             &Transport->WaitForNewMasterNameQueue,
                                             BowserCancelQueuedRequest
                                             );

try_exit:NOTHING;
    } finally {
        if ( Transport != NULL ) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}

NTSTATUS
QueryStatistics(
    IN PIRP Irp,
    OUT PBOWSER_STATISTICS OutputBuffer,
    IN OUT PULONG OutputBufferLength
    )
{
    KIRQL OldIrql;

    if (*OutputBufferLength != sizeof(BOWSER_STATISTICS)) {
        *OutputBufferLength = 0;
        return STATUS_BUFFER_TOO_SMALL;
    }

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserStatisticsLock, &OldIrql);

    RtlCopyMemory(OutputBuffer, &BowserStatistics, sizeof(BOWSER_STATISTICS));

    RELEASE_SPIN_LOCK(&BowserStatisticsLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return STATUS_SUCCESS;
}

NTSTATUS
ResetStatistics(
    VOID
    )
{
    KIRQL OldIrql;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    ACQUIRE_SPIN_LOCK(&BowserStatisticsLock, &OldIrql);

    RtlZeroMemory(&BowserStatistics, sizeof(BOWSER_STATISTICS));

    KeQuerySystemTime(&BowserStatistics.StartTime);

    RELEASE_SPIN_LOCK(&BowserStatisticsLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return STATUS_SUCCESS;

}



NTSTATUS
BowserIpAddressChanged(
    IN PLMDR_REQUEST_PACKET InputBuffer
    )

/*++

Routine Description:

    This routine is called whenever the IP address of a transport changes.
    NetBt uses the IP address to associate it's transport endpoint with the
    appropriate NDIS driver.  As such, it can't return NDIS specific information,
    until the IP address is defined.

Arguments:

    InputBuffer - Buffer specifying the name of the transport whose address
        has changed.

Return Value:

NTSTATUS

--*/

{
    NTSTATUS Status;
    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: BowserIpAddressChanged: Calling dead code!!\n"));

    //
    // Nobody should call into us here. This is dead code.
    //
//    ASSERT(FALSE);

    //
    // The no longer need notification of address changes.
    // The redir gets PNP bind and unbind notifications when the IP address
    // changes.  The redir passes those along to us.
    //
    return STATUS_SUCCESS;

#ifdef notdef

    //
    // Check some fields in the input buffer.
    //

    if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }

    if (InputBuffer->TransportName.Length == 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto ReturnStatus;
    }


    //
    // Handle each transport (in each emulated domain) that has this transport name.
    //

    ENSURE_IN_INPUT_BUFFER( &InputBuffer->TransportName, FALSE, FALSE );
    Status = BowserForEachTransport( BowserIpAddressChangedWorker,
                                     &InputBuffer->TransportName );


ReturnStatus:
    return Status;
#endif // notdef

}

#ifdef notdef
NTSTATUS
BowserIpAddressChangedWorker(
    PTRANSPORT Transport,
    PVOID Context
    )
/*++

Routine Description:

    This routine is the worker routine for BowserIpAddressChanged.

    This routine is called whenever the IP address of a transport changes.

Arguments:

    Transport - Current transport being handled.

    Context - Name of transport to search for

Return Value:

    Status of the operation.

--*/

{
    PUNICODE_STRING TransportName = (PUNICODE_STRING) Context;

    PAGED_CODE();

    try {

        //
        // If the TransportName of the transport matches the one passed in,
        //  update the information from the NDIS driver.
        //

        if (RtlEqualUnicodeString(TransportName,
                                  &Transport->PagedTransport->TransportName, TRUE)) {

            //
            // Notify services that the IP address changed for this transport.
            //

            BowserSendPnp(
                NlPnpNewIpAddress,
                NULL,    // All hosted domains
                &Transport->PagedTransport->TransportName,
                BowserTransportFlags(Transport->PagedTransport) );

            //
            // Update bowser information about the provider.

            (VOID) BowserUpdateProviderInformation( Transport->PagedTransport );

        }

    } finally {
    }

    return STATUS_SUCCESS;
}
#endif // notdef



NTSTATUS
EnableDisableTransport (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine Implements the IOCTL to enable or disable a transport.

Arguments:

    InputBuffer - Buffer indicating whether we should enable or disable the
        transport.

Return Value:

    Status of operation.


--*/

{
    NTSTATUS Status;
    PTRANSPORT Transport = NULL;
    PPAGED_TRANSPORT PagedTransport;

    PAGED_CODE();

    try {
        WCHAR TransportNameBuffer[MAX_PATH+1];
        WCHAR DomainNameBuffer[DNLEN+1];

        if (InputBufferLength <
            (ULONG)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters) +
            sizeof(InputBuffer->Parameters.EnableDisableTransport)) {
           try_return(Status = STATUS_INVALID_PARAMETER);
        }

        CAPTURE_UNICODE_STRING( &InputBuffer->TransportName, TransportNameBuffer );
        CAPTURE_UNICODE_STRING( &InputBuffer->EmulatedDomainName, DomainNameBuffer );

        //
        // Check some fields in the input buffer.
        //

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->TransportName.Length == 0) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }


        //
        // Find the transport whose address has changed.
        //

        dlog( DPRT_FSCTL,
              ("NtDeviceIoControlFile: %wZ: Enable/Disable transport &ld\n",
              &InputBuffer->TransportName,
              InputBuffer->Parameters.EnableDisableTransport.EnableTransport ));
        Transport = BowserFindTransport(&InputBuffer->TransportName, &InputBuffer->EmulatedDomainName );
        dprintf(DPRT_REF, ("Called Find transport %lx from EnableDisableTransport.\n", Transport));

        if (Transport == NULL) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        PagedTransport = Transport->PagedTransport;

        //
        // Set the disabled bit correctly.
        //

        InputBuffer->Parameters.EnableDisableTransport.PreviouslyEnabled =
            !PagedTransport->DisabledTransport;

        if ( InputBuffer->Parameters.EnableDisableTransport.EnableTransport ) {
            PagedTransport->DisabledTransport = FALSE;

            //
            // If the transport was previously disabled and this is an NTAS server,
            //  force an election.
            //

            if ( (!InputBuffer->Parameters.EnableDisableTransport.PreviouslyEnabled) &&
                 BowserData.IsLanmanNt ) {
                BowserStartElection( Transport );
            }

        } else {
            PagedTransport->DisabledTransport = TRUE;

            //
            // If we're disabling a previously enabled transport,
            //  ensure we're not the master browser.
            //

            BowserLoseElection( Transport );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {
        if (Transport != NULL) {
            BowserDereferenceTransport(Transport);
        }
    }

    return Status;

}


NTSTATUS
BowserRenameDomain (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

    This routine renames an emulated domain.

Arguments:

    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength,

Return Value:

    NTSTATUS - Status of operation.

--*/

{
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;

    WCHAR OldDomainNameBuffer[DNLEN+1];
    UNICODE_STRING OldDomainName;
    CHAR OemDomainName[DNLEN+1];
    DWORD OemDomainNameLength;
    UNICODE_STRING NewDomainName;

    PAGED_CODE();

    dlog(DPRT_FSCTL, ("NtDeviceIoControlFile: RenameDomain\n"));

    try {

        //
        // Check some fields in the input buffer.
        //

        if (InputBufferLength < offsetof(LMDR_REQUEST_PACKET, Parameters.DomainRename.DomainName)) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        if (InputBuffer->Version != LMDR_REQUEST_PACKET_VERSION_DOM) {
            try_return (Status = STATUS_INVALID_PARAMETER);
        }

        ENSURE_IN_INPUT_BUFFER( &InputBuffer->EmulatedDomainName, TRUE, FALSE );

        NewDomainName.MaximumLength = NewDomainName.Length = (USHORT )
                      InputBuffer->Parameters.DomainRename.DomainNameLength;
        NewDomainName.Buffer = InputBuffer->Parameters.DomainRename.DomainName;
        ENSURE_IN_INPUT_BUFFER( &NewDomainName, FALSE, FALSE );
		
		if ( !BowserValidUnicodeString(&NewDomainName) ) {
            try_return (Status = STATUS_INVALID_PARAMETER);
		}

        //
        // Find the emulated domain to rename
        //

        DomainInfo = BowserFindDomain( &InputBuffer->EmulatedDomainName );

        if ( DomainInfo == NULL ) {
            try_return (Status = STATUS_OBJECT_NAME_NOT_FOUND);
        }

        //
        // Make a copy of the old domain name for use throughout the routine.
        //

        wcscpy( OldDomainNameBuffer, DomainInfo->DomUnicodeDomainNameBuffer );
        RtlInitUnicodeString( &OldDomainName, OldDomainNameBuffer );


        //
        // If the old and new names are the same,
        //  we're done.
        //

        if ( RtlEqualUnicodeString( &OldDomainName, &NewDomainName, TRUE) ) {
            try_return (Status = STATUS_SUCCESS);
        }


        //
        // Register the new default names with the new domain name.
        //

        Status = BowserForEachTransportInDomain(DomainInfo, BowserAddDefaultNames, &NewDomainName );

        if ( !NT_SUCCESS(Status) || InputBuffer->Parameters.DomainRename.ValidateOnly ) {
            NTSTATUS TempStatus;

            //
            // Delete any names that did get registered.
            //

            (VOID) BowserForEachTransportInDomain(DomainInfo, BowserDeleteDefaultDomainNames, &NewDomainName );


        } else {


            //
            // Store the new domain name into the domain structure
            //

            Status = BowserSetDomainName( DomainInfo, &NewDomainName );

            if ( !NT_SUCCESS(Status)) {
                //
                // Delete any names that did get registered.
                //

                (VOID) BowserForEachTransportInDomain(DomainInfo, BowserDeleteDefaultDomainNames, &NewDomainName );
            } else {

                //
                // Delete the old names.
                //

                (VOID) BowserForEachTransportInDomain(DomainInfo, BowserDeleteDefaultDomainNames, &OldDomainName );

                //
                // Tell Netlogon and the Browser service about this domain rename.
                //

                BowserSendPnp( NlPnpDomainRename,
                               &OldDomainName,
                               NULL,    // Affects all transports
                               0 );
            }
        }

try_exit:NOTHING;
    } finally {
        if ( DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
        }

    }
    return Status;
}


PLMDR_REQUEST_PACKET
RequestPacket32to64 (
    IN      PLMDR_REQUEST_PACKET32  RequestPacket32,
    IN  OUT PLMDR_REQUEST_PACKET    RequestPacket,
	IN      ULONG InputBufferLength)
/*++

Routine Description:

    Converts a 32 bit request packet into supplied native (64 bit)
    packet format. (see bug 454130)


Arguments:

    RequestPacket32 -- Buffer containing request packet packet by a 32 bit client

    ReqestPacket -- Native (64 bit) request packet buffer



Return Value:

    a pointer to converted buffer (ReqestPacket arg)



Remarks:
    No checks assumed at this point (this is a convinience function). It is assumed
    that the conversion is needed at this point


--*/
{
	ULONG ParametersLength;

    PAGED_CODE();

    ASSERT(RequestPacket32);

    //
    // The following code depends on the request packet structure contents.
    //  1. copy everything before the 2 unicode strings  TransportName & EmulatedDomainName.
    //  2. convert the string structs.
    //  3. copy the rest.
    //

    RequestPacket->Type = RequestPacket32->Type;
    RequestPacket->Version = RequestPacket32->Version;
    RequestPacket->Level = RequestPacket32->Level;
    RequestPacket->LogonId = RequestPacket32->LogonId;


    // convert strings.
    RequestPacket->TransportName.Length = RequestPacket32->TransportName.Length;
    RequestPacket->TransportName.MaximumLength = RequestPacket32->TransportName.MaximumLength;
    // note: this line is the reason for all of this
    RequestPacket->TransportName.Buffer = (WCHAR * POINTER_32) RequestPacket32->TransportName.Buffer;

    RequestPacket->EmulatedDomainName.Length = RequestPacket32->EmulatedDomainName.Length;
    RequestPacket->EmulatedDomainName.MaximumLength = RequestPacket32->EmulatedDomainName.MaximumLength;
    // note: this line is the reason for all of this
    RequestPacket->EmulatedDomainName.Buffer = (WCHAR * POINTER_32) RequestPacket32->EmulatedDomainName.Buffer;

	// Copy only as many bytes as the user specified, upto a maximum of the size of the parameters union.
	ParametersLength = MIN( (InputBufferLength - (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET32,Parameters)), 
							(sizeof(LMDR_REQUEST_PACKET32) - (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET32,Parameters)) );

    RtlCopyMemory((PBYTE)RequestPacket + (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET,Parameters),
                  (PBYTE)RequestPacket32 + (SIZE_T)FIELD_OFFSET(LMDR_REQUEST_PACKET32,Parameters),
                  ParametersLength);

    return RequestPacket;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\domain.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    domain.c

Abstract:

    Code to manage primary and emulated networks.

Author:

    Cliff Van Dyke (CliffV) 23-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Module specific globals
//

// Serialized by BowserTransportDatabaseResource
LIST_ENTRY BowserServicedDomains = {0};

//
// Local procedure forwards.
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, BowserInitializeDomains)
#pragma alloc_text(PAGE, BowserCreateDomain)
#pragma alloc_text(PAGE, BowserSetDomainName)
#pragma alloc_text(PAGE, BowserFindDomain)
#pragma alloc_text(PAGE, BowserDereferenceDomain)
#endif


VOID
BowserInitializeDomains(
    VOID
    )

/*++

Routine Description:

    Initialize domain.c.

Arguments:

    None

Return Value:

    None.

--*/
{
    PAGED_CODE();
    //
    // Initialize globals
    //

    InitializeListHead(&BowserServicedDomains);
}


PDOMAIN_INFO
BowserCreateDomain(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING ComputerName
    )

/*++

Routine Description:

    Find the existing domain definition or create a new domain to browse on.

Arguments:

    DomainName - Name of the domain to browse on

    ComputerName - emulated computer name for this domain.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found/created.  The found/created domain should be dereferenced
    using BowserDereferenceDomain.

--*/
{
    NTSTATUS Status;

    PDOMAIN_INFO DomainInfo = NULL;
    ULONG OemComputerNameLength;

    PAGED_CODE();
    dlog(DPRT_DOMAIN, ("%wZ: BowserCreateDomain\n", DomainName));


    try {
        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);


        //
        // If the domain already exists, use it.
        //
        DomainInfo = BowserFindDomain( DomainName );

        if ( DomainInfo == NULL) {

            //
            // Allocate a structure describing the new domain.
            //

            DomainInfo = ALLOCATE_POOL(NonPagedPool, sizeof(DOMAIN_INFO), POOL_DOMAIN_INFO);

            if ( DomainInfo == NULL ) {
                try_return( Status = STATUS_NO_MEMORY );
            }
            RtlZeroMemory( DomainInfo, sizeof(DOMAIN_INFO) );


            //
            // Create an interim reference count for this domain.
            //
            // One for the caller.
            //
            // We don't increment the reference count for being in the global list since
            // the domain info structure is merely a performance enchancements that lives
            // only because it is referenced by a network.
            //

            DomainInfo->ReferenceCount = 1;

            //
            // Link the domain into the list of domains
            //
            //  The primary domain is at the front of the list.
            //

            InsertTailList(&BowserServicedDomains, &DomainInfo->Next);
        }

        //
        // Copy the DomainName into the structure
        //

        Status = BowserSetDomainName( DomainInfo, DomainName );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }


        //
        // Copy the OEM Computer name into the structure.
        //
        if ( ComputerName->Length > CNLEN*sizeof(WCHAR) ) {
            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemComputerNameBuffer,
                                         sizeof(DomainInfo->DomOemComputerNameBuffer)-1,
                                         &OemComputerNameLength,
                                         ComputerName->Buffer,
                                         ComputerName->Length );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        DomainInfo->DomOemComputerNameBuffer[OemComputerNameLength] = '\0';
        DomainInfo->DomOemComputerName.Buffer = DomainInfo->DomOemComputerNameBuffer;
        DomainInfo->DomOemComputerName.Length = (USHORT)OemComputerNameLength;
        DomainInfo->DomOemComputerName.MaximumLength = (USHORT)(OemComputerNameLength + 1);

        //
        // Copy the upcased Unicode Computer name into the structure.
        //

        DomainInfo->DomUnicodeComputerName.Buffer = DomainInfo->DomUnicodeComputerNameBuffer;
        DomainInfo->DomUnicodeComputerName.MaximumLength = sizeof(DomainInfo->DomUnicodeComputerNameBuffer);

        Status = RtlOemStringToUnicodeString(&DomainInfo->DomUnicodeComputerName, &DomainInfo->DomOemComputerName, FALSE);

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {
        if ( !NT_SUCCESS(Status) && DomainInfo != NULL ) {
            BowserDereferenceDomain( DomainInfo );
            DomainInfo = NULL;
        }
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return DomainInfo;
}


NTSTATUS
BowserSetDomainName(
    PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING DomainName
    )
/*++

Routine Description:

    Find the existing domain definition or create a new domain to browse on.

Arguments:

    DomainName - Name of the domain to browse on

    ComputerName - emulated computer name for this domain.

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    STRING OemDomainName;

    PAGED_CODE();

    try {
        ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

		// if the alignment of the name given is bad, return error
		if ( !POINTER_IS_ALIGNED( DomainName->Buffer, ALIGN_WCHAR ) ) {
			try_return( STATUS_DATATYPE_MISALIGNMENT_ERROR );
		}

        //
        // Copy the DomainName into the structure
        //

        Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemDomainName,
                                         sizeof(DomainInfo->DomOemDomainName),
                                         &DomainInfo->DomOemDomainNameLength,
                                         DomainName->Buffer,
                                         DomainName->Length );

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        DomainInfo->DomOemDomainName[DomainInfo->DomOemDomainNameLength] = '\0';

        //
        // Build the domain name as a Netbios name
        //  Trailing blank filled and <00> 16th byte
        //

        RtlCopyMemory( DomainInfo->DomNetbiosDomainName,
                       DomainInfo->DomOemDomainName,
                       DomainInfo->DomOemDomainNameLength );
        RtlFillMemory( DomainInfo->DomNetbiosDomainName+DomainInfo->DomOemDomainNameLength,
                       NETBIOS_NAME_LEN-1-DomainInfo->DomOemDomainNameLength,
                       ' ');
        DomainInfo->DomNetbiosDomainName[NETBIOS_NAME_LEN-1] = PRIMARY_DOMAIN_SIGNATURE;


        //
        // Copy the upcased Unicode domain name into the structure.
        //

        OemDomainName.Buffer = DomainInfo->DomOemDomainName;
        OemDomainName.Length = (USHORT)DomainInfo->DomOemDomainNameLength;
        OemDomainName.MaximumLength = OemDomainName.Length + sizeof(WCHAR);

        DomainInfo->DomUnicodeDomainName.Buffer = DomainInfo->DomUnicodeDomainNameBuffer;
        DomainInfo->DomUnicodeDomainName.MaximumLength = sizeof(DomainInfo->DomUnicodeDomainNameBuffer);

        Status = RtlOemStringToUnicodeString(&DomainInfo->DomUnicodeDomainName, &OemDomainName, FALSE);

        if (!NT_SUCCESS(Status)) {
            try_return( Status );
        }

        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {
        ExReleaseResourceLite(&BowserTransportDatabaseResource);
    }

    return Status;
}

PDOMAIN_INFO
BowserFindDomain(
    PUNICODE_STRING DomainName OPTIONAL
    )
/*++

Routine Description:

    This routine will look up a domain given a name.

Arguments:

    DomainName - The name of the domain to look up.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using BowserDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY DomainEntry;

    PDOMAIN_INFO DomainInfo = NULL;

    CHAR OemDomainName[DNLEN+1];
    DWORD OemDomainNameLength;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);

    try {


        // If no domain was specified
        //  try to return primary domain.
        //

        if ( DomainName == NULL || DomainName->Length == 0 ) {
            if ( !IsListEmpty( &BowserServicedDomains ) ) {
                DomainInfo = CONTAINING_RECORD(BowserServicedDomains.Flink, DOMAIN_INFO, Next);
            }

		// if the alignment of the name given is bad, return null
		} else if ( !POINTER_IS_ALIGNED( DomainName->Buffer, ALIGN_WCHAR ) ) {
			DomainInfo = NULL;

        //
        // If the domain name was specified,
        //  Find it in the list of domains.
        //
        } else {


            //
            // Convert the domain name to OEM for faster comparison
            //
            Status = RtlUpcaseUnicodeToOemN( OemDomainName,
                                             DNLEN,
                                             &OemDomainNameLength,
                                             DomainName->Buffer,
                                             DomainName->Length );


            if ( NT_SUCCESS(Status)) {

                //
                // The PrimaryDomainInfo structure is allocated with no
                //  domain name during bowser driver initialization.
                //  Detect that case here and always return that domain
                //  entry for all lookups.
                //
                if ( !IsListEmpty( &BowserServicedDomains ) ) {
                    DomainInfo = CONTAINING_RECORD(BowserServicedDomains.Flink, DOMAIN_INFO, Next);

                    if ( DomainInfo->DomOemDomainNameLength == 0 ) {
                        try_return( DomainInfo );
                    }

                }

                //
                // Loop trying to find this domain name.
                //

                for (DomainEntry = BowserServicedDomains.Flink ;
                     DomainEntry != &BowserServicedDomains;
                     DomainEntry = DomainEntry->Flink ) {

                    DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

                    if ( DomainInfo->DomOemDomainNameLength == OemDomainNameLength &&
                         RtlCompareMemory( DomainInfo->DomOemDomainName,
                                           OemDomainName,
                                           OemDomainNameLength ) == OemDomainNameLength ) {
                        try_return( DomainInfo );
                    }


                }

                DomainInfo = NULL;
            }

        }

try_exit:NOTHING;
    } finally {

        //
        // Reference the domain.
        //

        if ( DomainInfo != NULL ) {
            DomainInfo->ReferenceCount ++;
            dprintf(DPRT_REF, ("Reference domain %lx.  Count now %lx\n", DomainInfo, DomainInfo->ReferenceCount));
        }

        ExReleaseResourceLite(&BowserTransportDatabaseResource);

    }

    return DomainInfo;
}


VOID
BowserDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Decrement the reference count on a domain.

    If the reference count goes to 0, remove the domain.

    On entry, the global BowserTransportDatabaseResource may not be locked

Arguments:

    DomainInfo - The domain to dereference

Return Value:

    None

--*/
{
    NTSTATUS Status;
    ULONG ReferenceCount;

    PAGED_CODE();

    //
    // Decrement the reference count
    //

    ExAcquireResourceExclusiveLite(&BowserTransportDatabaseResource, TRUE);
    ReferenceCount = -- DomainInfo->ReferenceCount;
    if ( ReferenceCount == 0 ) {
        RemoveEntryList( &DomainInfo->Next );
    }
    ExReleaseResourceLite(&BowserTransportDatabaseResource);
    dprintf(DPRT_REF, ("Dereference domain %lx.  Count now %lx\n", DomainInfo, DomainInfo->ReferenceCount));

    if ( ReferenceCount != 0 ) {
        return;
    }


    //
    // Free the Domain Info structure.
    //
    dlog(DPRT_DOMAIN, ("%s: BowserDereferenceDomain: domain deleted.\n",
                          DomainInfo->DomOemDomainName ));
    FREE_POOL(DomainInfo );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\fsddisp.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    fsddisp.c

Abstract:

    This module implements the FSD dispatching routines for the NT datagram
    browser (the Bowser).


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  larryo

        Created

--*/

#include "precomp.h"
#pragma hdrstop

//KSPIN_LOCK
//BowserRefcountInterlock = {0};

NTSTATUS
BowserStopBrowser(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

NTSTATUS
BowserCancelRequestsOnTransport(
    IN PTRANSPORT Transport,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFsdCreate)
#pragma alloc_text(PAGE, BowserFsdClose)
#pragma alloc_text(PAGE, BowserFsdCleanup)
#pragma alloc_text(PAGE, BowserCancelRequestsOnTransport)
#pragma alloc_text(PAGE, BowserStopBrowser)
#pragma alloc_text(INIT, BowserInitializeFsd)
#endif

NTSTATUS
BowserFsdCreate (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes an NtCreateFile of the NT Bowser device driver.

Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    InterlockedIncrement(&BowserNumberOfOpenFiles);

    BowserCompleteRequest(Irp, Status);

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserFsdClose (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the last reference to a handle to the NT Bowser
    device driver is removed.

Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    BowserCompleteRequest(Irp, Status);

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserFsdCleanup (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the last handle to the NT Bowser device
    driver is closed.

Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies a device object for the request.
    IN PIRP Irp - Supplies an IRP for the create request.

Return Value:

    NTSTATUS - Final Status of operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    FsRtlEnterFileSystem();

    BowserForEachTransport(BowserCancelRequestsOnTransport, Irp->Tail.Overlay.OriginalFileObject);

    if (InterlockedDecrement(&BowserNumberOfOpenFiles) == 0) {
        //
        //  There are no longer any handles open to the browser.
        //
        //  Make sure we aren't a browser on any of our networks now.
        //

        BowserForEachTransport(BowserStopBrowser, NULL);
    }

    FsRtlExitFileSystem();

    BowserCompleteRequest(Irp, Status);

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);
}

NTSTATUS
BowserCancelRequestsOnTransport(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{
    PFILE_OBJECT FileObject = Context;

    PAGED_CODE();

    BowserCancelQueuedIoForFile(&Transport->BecomeBackupQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->BecomeMasterQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->FindMasterQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->WaitForMasterAnnounceQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->ChangeRoleQueue, FileObject);
    BowserCancelQueuedIoForFile(&Transport->WaitForNewMasterNameQueue, FileObject);

    return STATUS_SUCCESS;
}

NTSTATUS
BowserStopBrowser(
    IN PTRANSPORT Transport,
    IN PVOID Context
    )
{
    PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;
    PAGED_CODE();
    LOCK_TRANSPORT(Transport);

    //
    //  Make sure that we cannot possibly participate in an election.
    //

    PagedTransport->Role = None;

    PagedTransport->ServiceStatus &= ~(SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER | SV_TYPE_POTENTIAL_BROWSER);

    BowserForEachTransportName(Transport, BowserStopProcessingAnnouncements, NULL);

    BowserStopTimer(&Transport->ElectionTimer);

    BowserStopTimer(&Transport->FindMasterTimer);

    UNLOCK_TRANSPORT(Transport);

    //
    //  Delete the names associated with being a browser.
    //

    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                MasterBrowser);

    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                DomainAnnouncement);

    BowserDeleteTransportNameByName(Transport,
                                NULL,
                                BrowserElection);

    return(STATUS_SUCCESS);


}


VOID
BowserInitializeFsd(
    VOID
    )
{
//    KeInitializeSpinLock(&BowserRefcountInterlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\fsddisp.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    fspdisp.h

Abstract:

    This module defines the routines prototypes used for the bowser FSD.


Author:

    Larry Osterman (LarryO) 13-Aug-1990

Revision History:

    13-Aug-1990 LarryO

        Created

--*/
#ifndef _FSDDISP_
#define _FSDDISP_

NTSTATUS
BowserFsdCreate (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdClose (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdQueryInformationFile (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdQueryVolumeInformationFile (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdCleanup (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFsdDeviceIoControlFile (
    IN struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject,
    IN PIRP Irp
    );


#endif  // _FSDDISP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\fspdisp.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    fspdisp.h

Abstract:

    This module defines the data structures and routines used for the FSP
    dispatching code.


Author:

    Larry Osterman (LarryO) 13-Aug-1990

Revision History:

    13-Aug-1990 LarryO

        Created

--*/
#ifndef _FSPDISP_
#define _FSPDISP_


//
// Define communications data area between FSD and FSP.  This is done through
// the use of a Device Object.  This model allows one device object to be
// created for each volume that is/has been mounted in the system.  That is,
// each time a volume is mounted, the file system creates a device object to
// represent it so that the I/O system can vector directly to the proper file
// system.  The file system then uses information in the device object and in
// the file object to locate and synchronize access to its database of open
// file data structures (often called File Control Blocks - or, FCBs), Volume
// Control Blocks (VCBs), Map Control Blocks (MCBs), etc.
//
// The event and spinlock will be used to control access to the queue of IRPs.
// The IRPs are passed from the FSD to the FSP by inserting them onto the work
// queue in an interlocked manner and then setting the event to the Signaled
// state.  The event is an autoclearing type so the FSP simply wakes up when
// the event is Signaled and begins processing entries in the queue.
//
// Other data in this record should contain any information which both the FSD
// and the FSP need to share.  For example, a list of all of the open files
// might be something that both should be able to see.  Notice that all data
// placed in this area must be allocated from paged or non-paged pool.
//

typedef struct _BOWSER_FS_DEVICE_OBJECT {
    DEVICE_OBJECT DeviceObject;

} BOWSER_FS_DEVICE_OBJECT, *PBOWSER_FS_DEVICE_OBJECT;


NTSTATUS
BowserpInitializeFsp(
    PDRIVER_OBJECT BowserDriverObject
    );

VOID
BowserpUninitializeFsp (
    VOID
    );

VOID
BowserWorkerDispatch (
    PVOID Context
    );

NTSTATUS
BowserFsdPostToFsp(
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFspQueryInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFspQueryVolumeInformationFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
BowserFspDeviceIoControlFile (
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BowserIdleTimer (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#endif  // _FSPDISP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\mailslot.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    This module implements the routines needed to process incoming mailslot
    requests.



Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#include "precomp.h"
#pragma hdrstop
#include <netlogon.h>
#define _INC_WINDOWS 1
#include <winsock2.h>


// Free list of 512-byte buffers.
LIST_ENTRY
BowserMailslotBufferList = {0};

KSPIN_LOCK
BowserMailslotSpinLock = {0};

// Largest "typical" datagram size
#define BOWSER_MAX_DATAGRAM_SIZE 512

// Total number of mailslot buffers currently allocated.
LONG
BowserNumberOfMailslotBuffers = {0};

// Number of 512-byte buffers currently allocated.
LONG
BowserNumberOfMaxSizeMailslotBuffers = {0};

// Number of 512-byte buffers currently in the free list.
LONG
BowserNumberOfFreeMailslotBuffers = {0};

#if DBG
ULONG
BowserMailslotCacheHitCount = 0;

ULONG
BowserMailslotCacheMissCount = 0;
#endif // DBG


//
// Variables describing bowser support for handling netlogon mailslot messages and
//  PNP messages to Netlogon service or BrowserService.

typedef struct _BROWSER_PNP_STATE {

    // Queue of mailslot messages.
    LIST_ENTRY MailslotMessageQueue;


    // Maximum queue length
    ULONG MaxMessageCount;

    // Current queue length
    ULONG CurrentMessageCount;

    // Queue of IRPs used to read the queues
    IRP_QUEUE IrpQueue;

    // Queue of PNP events
    LIST_ENTRY PnpQueue;

} BROWSER_PNP_STATE, *PBROWSER_PNP_STATE;

//
// There is one BROWSER_PNP_STATE for the Netlogon service and one for the
// Browser service.
//

BROWSER_PNP_STATE BowserPnp[BOWSER_PNP_COUNT];


//
// Queue of PNP notifications to netlogon or browser service
//
typedef struct _BR_PNP_MESSAGE {
    LIST_ENTRY Next;                    // List of all queued entries.

    NETLOGON_PNP_OPCODE NlPnpOpcode;    // Operation to be notified

    ULONG TransportFlags;               // Flags describing transport

    UNICODE_STRING TransportName;       // Transport operation happened on

    UNICODE_STRING HostedDomainName;    // Hosted domain operation happened on

} BR_PNP_MESSAGE, *PBR_PNP_MESSAGE;



//
// Forwards for the alloc_text
//

NTSTATUS
BowserNetlogonCopyMessage(
    IN PIRP Irp,
    IN PMAILSLOT_BUFFER MailslotBuffer
    );

NTSTATUS
BowserCopyPnp(
    IN PIRP Irp,
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName,
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags
    );

VOID
BowserTrimMessageQueue (
    PBROWSER_PNP_STATE BrPnp
    );

BOOLEAN
BowserProcessNetlogonMailslotWrite(
    IN PMAILSLOT_BUFFER MailslotBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE5NETLOGON, BowserNetlogonCopyMessage)
#pragma alloc_text(PAGE4BROW, BowserCopyPnp)
#pragma alloc_text(PAGE4BROW, BowserTrimMessageQueue)
#pragma alloc_text(PAGE5NETLOGON, BowserNetlogonDeleteTransportFromMessageQueue )
#pragma alloc_text(PAGE5NETLOGON, BowserProcessNetlogonMailslotWrite)
#pragma alloc_text(PAGE4BROW, BowserSendPnp)
#pragma alloc_text(PAGE4BROW, BowserEnablePnp )
#pragma alloc_text(PAGE4BROW, BowserReadPnp )
#pragma alloc_text(PAGE, BowserProcessMailslotWrite)
#pragma alloc_text(PAGE4BROW, BowserFreeMailslotBuffer)
#pragma alloc_text(INIT, BowserpInitializeMailslot)
#pragma alloc_text(PAGE, BowserpUninitializeMailslot)
#endif

NTSTATUS
BowserNetlogonCopyMessage(
    IN PIRP Irp,
    IN PMAILSLOT_BUFFER MailslotBuffer
    )
/*++

Routine Description:

    This routine copies the data from the specified MailslotBuffer into the
    IRP for the netlogon request.

    This routine unconditionally frees the passed in Mailslot Buffer.

Arguments:

    Irp - IRP for the IOCTL from the netlogon service.

    MailslotBuffer - Buffer describing the mailslot message.

Return Value:

    Status of the operation.

    The caller should complete the I/O operation with this status code.

--*/
{
    NTSTATUS Status;

    PSMB_HEADER SmbHeader;
    PSMB_TRANSACT_MAILSLOT MailslotSmb;
    PUCHAR MailslotData;
    OEM_STRING MailslotNameA;
    UNICODE_STRING MailslotNameU;
    UNICODE_STRING TransportName;
    UNICODE_STRING DestinationName;
    USHORT DataCount;

    PNETLOGON_MAILSLOT NetlogonMailslot;
    PUCHAR Where;

    PIO_STACK_LOCATION IrpSp;

    BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

    DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );

    //
    // Extract the name of the mailslot and address/size of mailslot message
    //  from SMB.
    //

    SmbHeader = (PSMB_HEADER )MailslotBuffer->Buffer;
    MailslotSmb = (PSMB_TRANSACT_MAILSLOT)(SmbHeader+1);
    MailslotData = (((PCHAR )SmbHeader) + SmbGetUshort(&MailslotSmb->DataOffset));
    RtlInitString(&MailslotNameA, MailslotSmb->Buffer );
    DataCount = SmbGetUshort(&MailslotSmb->DataCount);

    //
    // Get the name of the transport and netbios name the mailslot message arrived on.
    //

    TransportName =
        MailslotBuffer->TransportName->Transport->PagedTransport->TransportName;
    DestinationName =
        MailslotBuffer->TransportName->PagedTransportName->Name->Name;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    try {

        //
        // Convert mailslot name to unicode for return.
        //

        Status = RtlOemStringToUnicodeString(&MailslotNameU, &MailslotNameA, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, MailslotNameA.Buffer, MailslotNameA.Length );
            MailslotNameU.Buffer = NULL;
            try_return( NOTHING );
        }

        //
        // Ensure the data fits in the user's output buffer.
        //

        if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(NETLOGON_MAILSLOT) +    // Header structure
             DataCount +                    // Actual mailslot message
             sizeof(DWORD) +                // alignment for socket address
             sizeof(SOCKADDR_IN) +          // Client Socket Address
             sizeof(WCHAR) +                // alignment of unicode strings
             TransportName.Length +         // TransportName
             sizeof(WCHAR) +                // zero terminator
             MailslotNameU.Length +         // Mailslot name
             sizeof(WCHAR) +                // zero terminator
             DestinationName.Length +       // Destination name
             sizeof(WCHAR) ) {              // zero terminator

            try_return( Status = STATUS_BUFFER_TOO_SMALL );
        }


        //
        // Get the address of Netlogon's buffer and fill in common portion.
        //
        NetlogonMailslot = MmGetSystemAddressForMdl( Irp->MdlAddress );

        if ( NULL == NetlogonMailslot ) {
            try_return( Status = STATUS_NO_MEMORY );
        }

        if (!POINTER_IS_ALIGNED( NetlogonMailslot, ALIGN_DWORD) ) {
            try_return( Status = STATUS_INVALID_PARAMETER );            
        }

        Where = (PUCHAR) (NetlogonMailslot+1);

        NetlogonMailslot->TimeReceived = MailslotBuffer->TimeReceived;

        //
        // Copy the datagram to the buffer
        //

        NetlogonMailslot->MailslotMessageSize = DataCount;
        NetlogonMailslot->MailslotMessageOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);
        RtlCopyMemory( Where, MailslotData, DataCount );

        Where += DataCount;

        //
        // Copy Client IpAddress to buffer.
        //
        if ( MailslotBuffer->ClientIpAddress != 0 ) {
            PSOCKADDR_IN SockAddrIn;

            *Where = 0;
            *(Where+1) = 0;
            *(Where+2) = 0;
            Where = ROUND_UP_POINTER( Where, ALIGN_DWORD );

            NetlogonMailslot->ClientSockAddrSize = sizeof(SOCKADDR_IN);
            NetlogonMailslot->ClientSockAddrOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

            SockAddrIn = (PSOCKADDR_IN) Where;
            RtlZeroMemory( SockAddrIn, sizeof(SOCKADDR_IN) );
            SockAddrIn->sin_family = AF_INET;
            SockAddrIn->sin_addr.S_un.S_addr = MailslotBuffer->ClientIpAddress;

            Where += sizeof(SOCKADDR_IN);

        } else {
            NetlogonMailslot->ClientSockAddrSize = 0;
            NetlogonMailslot->ClientSockAddrOffset = 0;
        }

        //
        // Copy the transport name to the buffer
        //

        *Where = 0;
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );
        NetlogonMailslot->TransportNameSize = TransportName.Length;
        NetlogonMailslot->TransportNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, TransportName.Buffer, TransportName.Length );
        Where += TransportName.Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);

        //
        // Copy the mailslot name to the buffer
        //

        NetlogonMailslot->MailslotNameSize = MailslotNameU.Length;
        NetlogonMailslot->MailslotNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, MailslotNameU.Buffer, MailslotNameU.Length );
        Where += MailslotNameU.Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);


        //
        // Copy the destination netbios name to the buffer
        //

        NetlogonMailslot->DestinationNameSize = DestinationName.Length;
        NetlogonMailslot->DestinationNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, DestinationName.Buffer, DestinationName.Length );
        Where += DestinationName.Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);


        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {


        //
        // Free Locally allocated buffers
        //

        RtlFreeUnicodeString(&MailslotNameU);

        //
        // Always free the incoming mailslot message
        //

        BowserFreeMailslotBuffer( MailslotBuffer );

    }

    BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
    return Status;
}

NTSTATUS
BowserCopyPnp(
    IN PIRP Irp,
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName,
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags
    )
/*++

Routine Description:

    This routine copies the data for a PNP notification into the
    IRP for the I/O request.

Arguments:

    Irp - IRP for the IOCTL from the service.

    NlPnpOpcode - Opcode describing the event being notified.

    HostedDomainName - Name of the hosted domain this event applies to

    TransportName - Name of transport being affected.

    TransportFlags - Flags describing the transport

Return Value:

    Status of the operation.

    The caller should complete the I/O operation with this status code.

--*/
{
    NTSTATUS Status;

    PNETLOGON_MAILSLOT NetlogonMailslot;
    PUCHAR Where;

    PIO_STACK_LOCATION IrpSp;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );


    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    try {

        //
        // Ensure the data fits in the user's output buffer.
        //

        if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(NETLOGON_MAILSLOT) +             // Header structure
             TransportName->Length + sizeof(WCHAR) + // TransportName
             HostedDomainName->Length + sizeof(WCHAR) + // DomainName
             1 ) {           // possible rounding requirement

            try_return( Status = STATUS_BUFFER_TOO_SMALL );
        }


        //
        // Get the address of service's buffer and fill in common portion.
        //

        NetlogonMailslot = MmGetSystemAddressForMdl( Irp->MdlAddress );

        if ( NULL == NetlogonMailslot ) {
            try_return( Status = STATUS_NO_MEMORY );
        }

        if (!POINTER_IS_ALIGNED( NetlogonMailslot, ALIGN_DWORD) ) {
            try_return( Status = STATUS_INVALID_PARAMETER );            
        }

        RtlZeroMemory( NetlogonMailslot, sizeof(NETLOGON_MAILSLOT));

        //
        // Copy the opcode
        //

        NetlogonMailslot->MailslotNameOffset = NlPnpOpcode;

        //
        // Copy the transport flags.
        //

        NetlogonMailslot->MailslotMessageOffset = TransportFlags;

        //
        // Copy the transport name to the buffer
        //

        Where = (PUCHAR) (NetlogonMailslot+1);
        *Where = 0;
        Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );

        NetlogonMailslot->TransportNameSize = TransportName->Length;
        NetlogonMailslot->TransportNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, TransportName->Buffer, TransportName->Length );
        Where += TransportName->Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);

        //
        // Copy the hosted domain name to the buffer
        //

        NetlogonMailslot->DestinationNameSize = HostedDomainName->Length;
        NetlogonMailslot->DestinationNameOffset = (ULONG)(Where - (PUCHAR)NetlogonMailslot);

        RtlCopyMemory( Where, HostedDomainName->Buffer, HostedDomainName->Length );
        Where += HostedDomainName->Length;
        *((PWCH)Where) = L'\0';
        Where += sizeof(WCHAR);


        Status = STATUS_SUCCESS;

try_exit:NOTHING;
    } finally {

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    }
    return Status;
}


VOID
BowserTrimMessageQueue (
    PBROWSER_PNP_STATE BrPnp
    )

/*++

Routine Description:

    This routines ensures there are not too many mailslot messages in
    the message queue.  Any excess messages are deleted.

Arguments:

    BrPnp - Indicates which message queue to trim

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    dprintf(DPRT_NETLOGON, ("Bowser: trim message queue to %ld\n", BrPnp->MaxMessageCount ));

    //
    //
    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    // If too many messages are queued,
    //  delete the oldest messages.
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    while ( BrPnp->CurrentMessageCount > BrPnp->MaxMessageCount){
        PLIST_ENTRY Entry;
        PMAILSLOT_BUFFER MailslotBuffer;

        Entry = RemoveHeadList(&BrPnp->MailslotMessageQueue);
        BrPnp->CurrentMessageCount--;
        MailslotBuffer = CONTAINING_RECORD(Entry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
        BowserFreeMailslotBuffer( MailslotBuffer );
        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

    }

    //
    // If absolutely no queued messages are allowed,
    //  delete the queued PNP messages, too.
    //  (Either netlogon or the bowser is shutting down.)
    //
    if ( BrPnp->MaxMessageCount == 0 ) {
        while ( !IsListEmpty(&BrPnp->PnpQueue) ) {
            PLIST_ENTRY ListEntry;
            PBR_PNP_MESSAGE PnpMessage;

            ListEntry = RemoveHeadList(&BrPnp->PnpQueue);

            PnpMessage = CONTAINING_RECORD(ListEntry, BR_PNP_MESSAGE, Next);

            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            FREE_POOL(PnpMessage);
            ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        }
    }
    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

}


VOID
BowserNetlogonDeleteTransportFromMessageQueue (
    PTRANSPORT Transport
    )

/*++

Routine Description:

    This routines removes queued mailslot messages that arrived on the specified
    transport.

Arguments:

    Transport - Transport who's mailslot messages are to be deleted.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY ListEntry;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[NETLOGON_PNP];

    dprintf(DPRT_NETLOGON, ("Bowser: remove messages queued by transport %lx\n", Transport ));

    //
    //
    BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

    DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );

    //
    // Loop through all of the queued messages.
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    for ( ListEntry = BrPnp->MailslotMessageQueue.Flink;
          ListEntry != &BrPnp->MailslotMessageQueue;
          ) {

        PMAILSLOT_BUFFER MailslotBuffer;

        //
        // If the message wasn't queued by this transport,
        //  go on to the next entry.
        //

        MailslotBuffer = CONTAINING_RECORD(ListEntry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        if ( MailslotBuffer->TransportName->Transport != Transport ) {
            ListEntry = ListEntry->Flink;

        //
        // Otherwise,
        //  delete the entry.
        //

        } else {

            dprintf(DPRT_ALWAYS, ("Bowser: removing message %lx queued by transport %lx\n", MailslotBuffer, Transport ));
            RemoveEntryList( ListEntry );
            BrPnp->CurrentMessageCount--;

            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            BowserFreeMailslotBuffer( MailslotBuffer );
            ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

            //
            // Start over at the beginning of the list since we dropped the spinlock.
            //

            ListEntry = BrPnp->MailslotMessageQueue.Flink;

        }

    }
    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
    BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

}

BOOLEAN
BowserProcessNetlogonMailslotWrite(
    IN PMAILSLOT_BUFFER MailslotBuffer
    )
/*++

Routine Description:

    This routine checks to see if the described mailslot message is destined
    to the Netlogon service and if the Bowser is currently handling such
    messages

Arguments:

    MailslotBuffer - Buffer describing the mailslot message.

Return Value:

    TRUE - iff the mailslot message was successfully queued to the netlogon
        service.

--*/
{
    KIRQL OldIrql;
    NTSTATUS Status;

    PSMB_HEADER SmbHeader;
    PSMB_TRANSACT_MAILSLOT MailslotSmb;
    BOOLEAN TrimIt;
    BOOLEAN ReturnValue;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[NETLOGON_PNP];

    PIRP Irp;

    BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );

    DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );

    //
    // If this message isn't destined to the Netlogon service,
    //  just return.
    //

    SmbHeader = (PSMB_HEADER )MailslotBuffer->Buffer;
    MailslotSmb = (PSMB_TRANSACT_MAILSLOT)(SmbHeader+1);

    if ( _stricmp( MailslotSmb->Buffer, NETLOGON_LM_MAILSLOT_A ) != 0 &&
         _stricmp( MailslotSmb->Buffer, NETLOGON_NT_MAILSLOT_A ) != 0 ) {

        ReturnValue = FALSE;

    //
    // The mailslot message is destined to netlogon.
    //

    } else {

        //
        // Check to ensure we're queuing messages to Netlogon
        //

        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        if ( BrPnp->MaxMessageCount == 0 ) {
            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            ReturnValue = FALSE;

        //
        // Queueing to netlogon is enabled.
        //

        } else {

            //
            // If there already is an IRP from netlogon queued,
            //  return this mailslot message to netlogon now.
            //
            //  This routine locks BowserIrpQueueSpinLock so watch the spin lock
            //  locking order.
            //

            ReturnValue = TRUE;

            Irp = BowserDequeueQueuedIrp( &BrPnp->IrpQueue );

            if ( Irp != NULL ) {

                ASSERT( IsListEmpty( &BrPnp->MailslotMessageQueue ) );
                dprintf(DPRT_NETLOGON, ("Bowser: found already queued netlogon IRP\n"));

                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

                Status = BowserNetlogonCopyMessage( Irp, MailslotBuffer );

                BowserCompleteRequest( Irp, Status );

            } else {

                //
                // Queue the mailslot message for netlogon to pick up later.
                //

                InsertTailList( &BrPnp->MailslotMessageQueue,
                                &MailslotBuffer->Overlay.NextBuffer);

                BrPnp->CurrentMessageCount++;

                TrimIt =
                    (BrPnp->CurrentMessageCount > BrPnp->MaxMessageCount);


                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

                //
                // If there are too many messages queued,
                //  trim entries from the front.
                //

                if ( TrimIt ) {
                    BowserTrimMessageQueue(BrPnp);
                }
            }
        }
    }

    BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
    return ReturnValue;
}

VOID
BowserSendPnp(
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName OPTIONAL,
    IN PUNICODE_STRING TransportName OPTIONAL,
    IN ULONG TransportFlags
    )
/*++

Routine Description:

    This routine sends a PNP notification to the Netlogon service.

Arguments:

    NlPnpOpcode - Opcode describing the event being notified.

    HostedDomainName - Hosted domain name
        NULL - if the operation affects all hosted domains

    TransportName - Name of transport being affected.
        NULL - if the operation affects all transports

    TransportFlags - Flags describing the transport

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    NTSTATUS Status;

    PIRP Irp;
    PBR_PNP_MESSAGE PnpMessage = NULL;
    PBROWSER_PNP_STATE BrPnp;
    UNICODE_STRING NullUnicodeString = { 0, 0, NULL };

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );
    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    // Initialization.
    //

    if ( TransportName == NULL ) {
        TransportName = &NullUnicodeString;
    }

    if ( HostedDomainName == NULL ) {
        HostedDomainName = &NullUnicodeString;
    }


    //
    // Send the PNP message to each service that wants it.
    //

    for ( BrPnp=&BowserPnp[0];
          BrPnp<&BowserPnp[BOWSER_PNP_COUNT];
          BrPnp++) {

        //
        // If this service doesn't want notification,
        //  skip it.
        //

        if ( BrPnp->MaxMessageCount == 0 ) {
            continue;
        }



        //
        // Preallocate the buffer since we can't do it under the spinlock.
        //

        if ( PnpMessage == NULL ) {
            PnpMessage = ALLOCATE_POOL( NonPagedPool,
                                    sizeof(BR_PNP_MESSAGE) +
                                        TransportName->Length +
                                        HostedDomainName->Length,
                                    POOL_NETLOGON_BUFFER);

            //
            // Copy the parameters into the newly allocated buffer.
            //

            if ( PnpMessage != NULL ) {
                LPBYTE Where;
                PnpMessage->NlPnpOpcode = NlPnpOpcode;
                PnpMessage->TransportFlags = TransportFlags;
                Where = (LPBYTE)(PnpMessage + 1);

                // Copy the TransportName
                PnpMessage->TransportName.MaximumLength =
                    PnpMessage->TransportName.Length = TransportName->Length;
                PnpMessage->TransportName.Buffer = (LPWSTR) Where;
                RtlCopyMemory( Where,
                               TransportName->Buffer,
                               TransportName->Length );
                Where += TransportName->Length;

                // Copy the HostedDomainName
                PnpMessage->HostedDomainName.MaximumLength =
                    PnpMessage->HostedDomainName.Length = HostedDomainName->Length;
                PnpMessage->HostedDomainName.Buffer = (LPWSTR) Where;
                RtlCopyMemory( Where,
                               HostedDomainName->Buffer,
                               HostedDomainName->Length );
                Where += HostedDomainName->Length;
            }

        }

        //
        // Check to ensure we're queuing messages to this service.
        //

        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        if ( BrPnp->MaxMessageCount == 0 ) {
            RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        //
        // Queueing to service is enabled.
        //

        } else {

            //
            // If there already is an IRP from the service queued,
            //  return this PNP message to the service now.
            //
            //  This routine locks BowserIrpQueueSpinLock so watch the spin lock
            //  locking order.
            //

            Irp = BowserDequeueQueuedIrp( &BrPnp->IrpQueue );

            if ( Irp != NULL ) {

                ASSERT( IsListEmpty( &BrPnp->MailslotMessageQueue ) );
                dprintf(DPRT_NETLOGON, ("Bowser: found already queued netlogon IRP\n"));

                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

                Status = BowserCopyPnp( Irp, NlPnpOpcode, HostedDomainName, TransportName, TransportFlags );

                BowserCompleteRequest( Irp, Status );

            } else {

                //
                // Queue the mailslot message for the service to pick up later.
                //  (Drop notification on the floor if there is no memory.)
                //

                if ( PnpMessage != NULL ) {
                    InsertTailList( &BrPnp->PnpQueue, &PnpMessage->Next );
                    PnpMessage = NULL;
                }

                RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
            }
        }
    }

    //
    // Free the PnpMessage buffer if we didn't need it.
    //

    if ( PnpMessage != NULL ) {
        FREE_POOL(PnpMessage);
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
    return;
}

NTSTATUS
BowserEnablePnp (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG ServiceIndex
    )

/*++

Routine Description:

    This routine processes an IOCTL from the netlogon service to enable or
    disable the queueing of netlogon mailslot messages.

Arguments:

    InputBuffer - Specifies the number of mailslot messages to queue.
        Zero disables queuing.

    ServiceIndex - Index of service to set queue size for.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.

--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;
    ULONG MaxMessageCount;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[ServiceIndex];

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );


    try {

        MaxMessageCount = InputBuffer->Parameters.NetlogonMailslotEnable.MaxMessageCount;
        dprintf(DPRT_NETLOGON,
                ("NtDeviceIoControlFile: Netlogon enable %ld\n",
                MaxMessageCount ));

        //
        // Set the new size of the message queue
        //

        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
        BrPnp->MaxMessageCount = MaxMessageCount;
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        //
        // Trim the message queue to the new size.
        //
        BowserTrimMessageQueue(BrPnp);

        try_return(Status = STATUS_SUCCESS);

try_exit:NOTHING;
    } finally {
        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    }

    return Status;

}


NTSTATUS
BowserReadPnp (
    IN PIRP Irp,
    IN ULONG OutputBufferLength,
    IN ULONG ServiceIndex
    )

/*++

Routine Description:

    This routine processes an IOCTL from the netlogon service to get the next
    mailslot message.

Arguments:

    Irp - I/O request packet describing request.

    ServiceIndex - Index of service to set queue size for.

Return Value:

    Status of operation.

Please note that this IRP is cancelable.


--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;
    PBROWSER_PNP_STATE BrPnp=&BowserPnp[ServiceIndex];

    //
    // If this is Netlogon,
    //  page in BowserNetlogonCopyMessage.
    //

    if ( ServiceIndex == NETLOGON_PNP ) {
        BowserReferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
        DISCARDABLE_CODE( BowserNetlogonDiscardableCodeSection );
    }

    //
    // Reference the discardable code of this routine and
    //  BowserQueueNonBufferRequestReferenced()
    //

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );
    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    // Ensure service has asked the browser to queue messages
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    if ( BrPnp->MaxMessageCount == 0 ) {
        dprintf(DPRT_NETLOGON, ("Bowser called from Netlogon when not enabled\n"));
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
        Status = STATUS_NOT_SUPPORTED;

    //
    // If there already is a PNP message queued,
    //  just return it to netlogon immediately.
    //

    } else if ( !IsListEmpty( &BrPnp->PnpQueue )) {
        PBR_PNP_MESSAGE PnpMessage;
        PLIST_ENTRY ListEntry;

        dprintf(DPRT_NETLOGON, ("Bowser found netlogon PNP message already queued\n"));

        ListEntry = RemoveHeadList(&BrPnp->PnpQueue);

        PnpMessage = CONTAINING_RECORD(ListEntry, BR_PNP_MESSAGE, Next);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        Status = BowserCopyPnp( Irp,
                                PnpMessage->NlPnpOpcode,
                                &PnpMessage->HostedDomainName,
                                &PnpMessage->TransportName,
                                PnpMessage->TransportFlags );

        FREE_POOL(PnpMessage);

    //
    // If there already is a mailslot message queued,
    //  just return it to netlogon immediately.
    //

    } else if ( ServiceIndex == NETLOGON_PNP &&
                !IsListEmpty( &BrPnp->MailslotMessageQueue )) {
        PMAILSLOT_BUFFER MailslotBuffer;
        PLIST_ENTRY ListEntry;

        dprintf(DPRT_NETLOGON, ("Bowser found netlogon mailslot message already queued\n"));

        ListEntry = RemoveHeadList(&BrPnp->MailslotMessageQueue);
        BrPnp->CurrentMessageCount--;

        MailslotBuffer = CONTAINING_RECORD(ListEntry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        Status = BowserNetlogonCopyMessage( Irp, MailslotBuffer );

    //
    // Otherwise, save this IRP until a mailslot message arrives.
    //  This routine locks BowserIrpQueueSpinLock so watch the spin lock
    //  locking order.
    //

    } else {

        dprintf(DPRT_NETLOGON, ("Bowser: queue netlogon mailslot irp\n"));

        Status = BowserQueueNonBufferRequestReferenced(
                    Irp,
                    &BrPnp->IrpQueue,
                    BowserCancelQueuedRequest );

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
    }

    if ( ServiceIndex == NETLOGON_PNP ) {
        BowserDereferenceDiscardableCode( BowserNetlogonDiscardableCodeSection );
    }
    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return Status;

}

VOID
BowserProcessMailslotWrite(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine performs all the task time operations to perform a mailslot
    write.

    It will open the mailslot, write the specified data into the mailslot,
    and close the mailslot.

Arguments:

    IN PWORK_HEADER WorkHeader - Specifies the mailslot buffer holding the
                                    mailslot write


Return Value:

    None.

--*/
{
    PSMB_HEADER SmbHeader;
    PSMB_TRANSACT_MAILSLOT MailslotSmb;
    PMAILSLOT_BUFFER MailslotBuffer = Context;
    PUCHAR MailslotData;
    HANDLE MailslotHandle = NULL;
    OBJECT_ATTRIBUTES ObjAttr;
    OEM_STRING MailslotNameA;
    UNICODE_STRING MailslotNameU;
    IO_STATUS_BLOCK IoStatusBlock;
    CHAR MailslotName[MAXIMUM_FILENAME_LENGTH+1];
    NTSTATUS Status;
    ULONG DataCount;
    ULONG TotalDataCount;

    PAGED_CODE();

    ASSERT (MailslotBuffer->Signature == STRUCTURE_SIGNATURE_MAILSLOT_BUFFER);

    SmbHeader = (PSMB_HEADER )MailslotBuffer->Buffer;

    ASSERT (SmbHeader->Command == SMB_COM_TRANSACTION);

    MailslotSmb = (PSMB_TRANSACT_MAILSLOT)(SmbHeader+1);

    ASSERT (MailslotSmb->WordCount == 17);

    ASSERT (MailslotSmb->Class == 2);

    MailslotData = (((PCHAR )SmbHeader) + SmbGetUshort(&MailslotSmb->DataOffset));

    DataCount = (ULONG)SmbGetUshort(&MailslotSmb->DataCount);

    TotalDataCount = (ULONG)SmbGetUshort(&MailslotSmb->TotalDataCount);

    //
    //  Verify that all of the data was received and that the indicated data doesn't
    //     overflow the received buffer.
    //

    if (TotalDataCount != DataCount ||
        (MailslotData > MailslotBuffer->Buffer + MailslotBuffer->ReceiveLength) ||
        (DataCount + SmbGetUshort(&MailslotSmb->DataOffset) > MailslotBuffer->ReceiveLength )) {

        BowserLogIllegalDatagram(MailslotBuffer->TransportName,
                                 SmbHeader,
                                 (USHORT)MailslotBuffer->ReceiveLength,
                                 MailslotBuffer->ClientAddress,
                                 0);

        BowserFreeMailslotBuffer(MailslotBuffer);
        return;
    }

    MailslotNameU.MaximumLength = MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)+sizeof(WCHAR);

#define DEVICE_PREFIX_LENGTH 7
    strcpy(MailslotName, "\\Device");

    strncpy( MailslotName+DEVICE_PREFIX_LENGTH,
             MailslotSmb->Buffer,
             sizeof(MailslotName)-DEVICE_PREFIX_LENGTH);
    MailslotName[sizeof(MailslotName)-1] = '\0';

    RtlInitString(&MailslotNameA, MailslotName);

    //
    // Handle netlogon mailslot messages specially.
    //  Don't call the discardable code at all if netlogon isn't running
    //

    if ( BowserPnp[NETLOGON_PNP].MaxMessageCount != 0 &&
         BowserProcessNetlogonMailslotWrite( MailslotBuffer ) ) {
        return;
    }

    //
    // Write the mailslot message to the mailslot
    //

    try {
        Status = RtlOemStringToUnicodeString(&MailslotNameU, &MailslotNameA, TRUE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, MailslotNameA.Buffer, MailslotNameA.Length );
            try_return(NOTHING);
        }

        InitializeObjectAttributes(&ObjAttr,
                                &MailslotNameU,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

        Status = NtCreateFile(&MailslotHandle, // Handle
                                GENERIC_WRITE | SYNCHRONIZE,
                                &ObjAttr, // Object Attributes
                                &IoStatusBlock, // Final I/O status block
                                NULL,           // Allocation Size
                                FILE_ATTRIBUTE_NORMAL, // Normal attributes
                                FILE_SHARE_READ|FILE_SHARE_WRITE,// Sharing attributes
                                FILE_OPEN, // Create disposition
                                0,      // CreateOptions
                                NULL,   // EA Buffer
                                0);     // EA Length


        RtlFreeUnicodeString(&MailslotNameU);

        //
        //  If the mailslot doesn't exist, ditch the request -
        //
        if (!NT_SUCCESS(Status)) {
            BowserStatistics.NumberOfFailedMailslotOpens += 1;

            try_return(NOTHING);
        }

        //
        //  Now that the mailslot is opened, write the mailslot data into
        //  the mailslot.
        //

        Status = NtWriteFile(MailslotHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            MailslotData,
                            DataCount,
                            NULL,
                            NULL);

        if (!NT_SUCCESS(Status)) {
            BowserStatistics.NumberOfFailedMailslotWrites += 1;
        } else {
            BowserStatistics.NumberOfMailslotWrites += 1;
        }

try_exit:NOTHING;
    } finally {

        //
        //  If we opened the mailslot, close it.
        //

        if (MailslotHandle != NULL) {
            ZwClose(MailslotHandle);
        }

        //
        //  Free the mailslot buffer holding this mailslot.
        //

        BowserFreeMailslotBuffer(MailslotBuffer);

    }
}


PMAILSLOT_BUFFER
BowserAllocateMailslotBuffer(
    IN PTRANSPORT_NAME TransportName,
    IN ULONG RequestedBufferSize
    )
/*++

Routine Description:

    This routine will allocate a mailslot buffer from the mailslot buffer pool.

    If it is unable to allocate a buffer, it will allocate the buffer from
    non-paged pool (up to the maximum configured by the user).


Arguments:

    TransportName - The transport name for this request.

    RequestedBufferSize - Minimum size of buffer to allocate.

Return Value:

    MAILSLOT_BUFFER - The allocated buffer.

--*/
{
    KIRQL OldIrql;
    PMAILSLOT_BUFFER Buffer     = NULL;
    ULONG BufferSize;
    BOOLEAN AllocatingMaxBuffer = FALSE;



    //
    // If the request fits into a cached buffer,
    //  and there is a cache buffer available,
    //  use it.
    //

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);
    if ( RequestedBufferSize <= BOWSER_MAX_DATAGRAM_SIZE &&
         !IsListEmpty(&BowserMailslotBufferList)) {
        PMAILSLOT_BUFFER Buffer;
        PLIST_ENTRY Entry;

        Entry = RemoveHeadList(&BowserMailslotBufferList);
        BowserNumberOfFreeMailslotBuffers --;

        Buffer = CONTAINING_RECORD(Entry, MAILSLOT_BUFFER, Overlay.NextBuffer);

#if DBG
        BowserMailslotCacheHitCount++;
#endif // DBG
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        Buffer->TransportName = TransportName;
        BowserReferenceTransportName(TransportName);
        BowserReferenceTransport( TransportName->Transport );

        return Buffer;
    }

    //
    // If we've got too many buffers allocated,
    //  don't allocate any more.
    //
    // BowserData.NumberOfMailslotBuffers is the maximum number we're allowed to have
    //  in the cache at once.  It defaults to 3.
    //
    // BrPnp[NETLOGON].MaxMessageCount is the number of buffers the netlogon service may
    //  have queued at any one point in time.  It may be zero when netlogon isn't
    //  running or if we're running on a non-DC.  On DC's it defaults to 500.
    //
    // Add 50, to ensure we don't limit it by too much.
    //

    if ( (ULONG)BowserNumberOfMailslotBuffers >=
         max( (ULONG)BowserData.NumberOfMailslotBuffers, BowserPnp[NETLOGON_PNP].MaxMessageCount+50 )) {

        BowserStatistics.NumberOfMissedMailslotDatagrams += 1;
        BowserNumberOfMissedMailslotDatagrams += 1;
        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);
        return NULL;
    }

    //
    // The first few buffers we allocate should be maximum size so we can keep a preallocated
    //  cache of huge buffers.
    //

    if ( BowserNumberOfMaxSizeMailslotBuffers < BowserData.NumberOfMailslotBuffers &&
         RequestedBufferSize <= BOWSER_MAX_DATAGRAM_SIZE ) {
        BufferSize = FIELD_OFFSET(MAILSLOT_BUFFER, Buffer) + BOWSER_MAX_DATAGRAM_SIZE;
        AllocatingMaxBuffer = TRUE;
        BowserNumberOfMaxSizeMailslotBuffers += 1;
    } else {
        BufferSize = FIELD_OFFSET(MAILSLOT_BUFFER, Buffer) + RequestedBufferSize;
    }

    BowserNumberOfMailslotBuffers += 1;

    ASSERT ( (BufferSize - FIELD_OFFSET(MAILSLOT_BUFFER, Buffer)) <= 0xffff);

#if DBG
    BowserMailslotCacheMissCount++;
#endif // DBG

    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

    Buffer = ALLOCATE_POOL(NonPagedPool, BufferSize, POOL_MAILSLOT_BUFFER);

    //
    //  If we couldn't allocate the buffer from non paged pool, give up.
    //

    if (Buffer == NULL) {
        ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

        ASSERT (BowserNumberOfMailslotBuffers);

        BowserNumberOfMailslotBuffers -= 1;
        if ( AllocatingMaxBuffer ) {
            BowserNumberOfMaxSizeMailslotBuffers -= 1;
        }

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        BowserStatistics.NumberOfFailedMailslotAllocations += 1;

        //
        //  Since we couldn't allocate this buffer, we've effectively missed
        //  this mailslot request.
        //

        BowserStatistics.NumberOfMissedMailslotDatagrams += 1;
        BowserNumberOfMissedMailslotDatagrams += 1;

        return NULL;
    }

    Buffer->Signature = STRUCTURE_SIGNATURE_MAILSLOT_BUFFER;

    Buffer->Size = FIELD_OFFSET(MAILSLOT_BUFFER, Buffer);

    Buffer->BufferSize = BufferSize - FIELD_OFFSET(MAILSLOT_BUFFER, Buffer);

    Buffer->TransportName = TransportName;
    BowserReferenceTransportName(TransportName);
    BowserReferenceTransport( TransportName->Transport );

    return Buffer;
}

VOID
BowserFreeMailslotBuffer(
    IN PMAILSLOT_BUFFER Buffer
    )
/*++

Routine Description:

    This routine will return a mailslot buffer to the view buffer pool.

    If the buffer was allocated from must-succeed pool, it is freed back
    to pool.  In addition, if the buffer is smaller than the current
    max view buffer size, we free it.

Arguments:

    IN PVIEW_BUFFER Buffer - Supplies the buffer to free

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    PTRANSPORT Transport;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    Transport = Buffer->TransportName->Transport;
    (VOID) BowserDereferenceTransportName( Buffer->TransportName );
    BowserDereferenceTransport( Transport);

    ACQUIRE_SPIN_LOCK(&BowserMailslotSpinLock, &OldIrql);

    //
    //  Also, if a new transport was added that is larger than this buffer,
    //  we want to free the buffer.
    //

    //
    //  If we have more mailslot buffers than the size of our lookaside list,
    //  free it, don't stick it on our lookaside list.
    //

    if (Buffer->BufferSize != BOWSER_MAX_DATAGRAM_SIZE ||
        BowserNumberOfFreeMailslotBuffers > BowserData.NumberOfMailslotBuffers) {

        //
        //  Since we're returning this buffer to pool, we shouldn't count it
        //  against our total number of mailslot buffers.
        //

        BowserNumberOfMailslotBuffers -= 1;

        ASSERT (BowserNumberOfMailslotBuffers >= 0);

        RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

        FREE_POOL(Buffer);

        BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

        return;
    }

    InsertTailList(&BowserMailslotBufferList, &Buffer->Overlay.NextBuffer);
    BowserNumberOfFreeMailslotBuffers ++;

    RELEASE_SPIN_LOCK(&BowserMailslotSpinLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
}

VOID
BowserFreeMailslotBufferHighIrql(
    IN PMAILSLOT_BUFFER Buffer
    )
/*++

Routine Description:

    This routine will return a mailslot buffer to the view buffer pool if the
    caller is at raised irql.

Arguments:

    Buffer - Supplies the buffer to free

Return Value:

    None.

--*/
{
    //
    // Queue the request to a worker routine.
    //
    ExInitializeWorkItem(&Buffer->Overlay.WorkHeader,
                         (PWORKER_THREAD_ROUTINE) BowserFreeMailslotBuffer,
                         Buffer);

    BowserQueueDelayedWorkItem( &Buffer->Overlay.WorkHeader );
}




VOID
BowserpInitializeMailslot (
    VOID
    )
/*++

Routine Description:

    This routine will allocate a transport descriptor and bind the bowser
    to the transport.

Arguments:

    None


Return Value:

    None

--*/
{
    PBROWSER_PNP_STATE BrPnp;

    KeInitializeSpinLock(&BowserMailslotSpinLock);

    InitializeListHead(&BowserMailslotBufferList);

    for ( BrPnp=&BowserPnp[0];
          BrPnp<&BowserPnp[BOWSER_PNP_COUNT];
          BrPnp++) {
        InitializeListHead(&BrPnp->MailslotMessageQueue);
        InitializeListHead(&BrPnp->PnpQueue);

        BowserInitializeIrpQueue( &BrPnp->IrpQueue );
    }

}

VOID
BowserpUninitializeMailslot (
    VOID
    )
/*++

Routine Description:


Arguments:

    None


Return Value:

    None

--*/
{
    PBROWSER_PNP_STATE BrPnp;
    PAGED_CODE();

    //
    // Trim the netlogon message queue to zero entries.
    //

    for ( BrPnp=&BowserPnp[0];
          BrPnp<&BowserPnp[BOWSER_PNP_COUNT];
          BrPnp++) {
        BrPnp->MaxMessageCount = 0;
        BowserTrimMessageQueue(BrPnp);
        BowserUninitializeIrpQueue( &BrPnp->IrpQueue );
    }

    //
    // Free the mailslot buffers.

    while (!IsListEmpty(&BowserMailslotBufferList)) {
        PLIST_ENTRY Entry;
        PMAILSLOT_BUFFER Buffer;

        Entry = RemoveHeadList(&BowserMailslotBufferList);
        Buffer = CONTAINING_RECORD(Entry, MAILSLOT_BUFFER, Overlay.NextBuffer);

        FREE_POOL(Buffer);

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the initialization code of the NT browser
    File System Driver (FSD) and File System Process (FSP).


Author:

    Larry Osterman (larryo) 24-May-1990

Environment:

    Kernel mode, FSD, and FSP

Revision History:

    30-May-1990 LarryO

        Created

--*/

//
// Include modules
//

#include "precomp.h"
#pragma hdrstop

HANDLE
BowserServerAnnouncementEventHandle = {0};

PKEVENT
BowserServerAnnouncementEvent = {0};

PDOMAIN_INFO BowserPrimaryDomainInfo = NULL;


// External functions

//(fsctl.c)
NTSTATUS
StopBowser (
    IN BOOLEAN Wait,
    IN BOOLEAN InFsd,
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG InputBufferLength
    );


// Local functions

VOID
BowserReadBowserConfiguration(
    PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, BowserDriverEntry)
#pragma alloc_text(PAGE, BowserUnload)
#pragma alloc_text(INIT, BowserReadBowserConfiguration)
#endif

NTSTATUS
BowserDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the file system.  It is invoked once
    when the driver is loaded into the system.  Its job is to initialize all
    the structures which will be used by the FSD and the FSP.  It also creates
    the process from which all of the file system threads will be executed.  It
    then registers the file system with the I/O system as a valid file system
    resident in the system.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING unicodeEventName;
    UNICODE_STRING DummyDomain;

    PDEVICE_OBJECT DeviceObject;
    OBJECT_ATTRIBUTES obja;

    PAGED_CODE();

#if DBG
    BowserInitializeTraceLog();
#endif

    //
    // Create the device object for this file system.
    //

    RtlInitUnicodeString( &BowserNameString, DD_BROWSER_DEVICE_NAME_U );

    dlog(DPRT_INIT, ("Creating device %wZ\n", &BowserNameString));


#if DBG
#define BOWSER_LOAD_BP 0
#if BOWSER_LOAD_BP
    dlog(DPRT_INIT, ("DebugBreakPoint...\n"));
    DbgBreakPoint();
#endif
#endif

    dlog(DPRT_INIT, ("DriverObject at %08lx\n", DriverObject));

    Status = IoCreateDevice( DriverObject,
              sizeof(BOWSER_FS_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
              &BowserNameString,
              FILE_DEVICE_NETWORK_BROWSER,
              0,
              FALSE,
              &DeviceObject );

    if (!NT_SUCCESS(Status)) {
        InternalError(("Unable to create redirector device"));
    }

    dlog(DPRT_INIT, ("Device created at %08lx\n", DeviceObject));



    Status = BowserInitializeSecurity(DeviceObject);

    if (!NT_SUCCESS(Status)) {
        InternalError(("Unable to initialize security."));
    }

    dlog(DPRT_INIT, ("Initialized Browser security at %p\n", g_pBowSecurityDescriptor));


    ExInitializeResourceLite( &BowserDataResource );

    //
    // Save the device object address for this file system driver.
    //

    BowserDeviceObject = (PBOWSER_FS_DEVICE_OBJECT )DeviceObject;

    BowserReadBowserConfiguration(RegistryPath);

    DeviceObject->StackSize = (CCHAR)BowserIrpStackSize;

    dlog(DPRT_INIT, ("Stacksize is %d\n",DeviceObject->StackSize));

    //
    // Initialize the TDI package
    //

    BowserpInitializeTdi();

    //
    // Initialize the datagram buffer structures
    //

    BowserpInitializeMailslot();

    BowserInitializeFsd();

    BowserpInitializeIrpQueue();

    //
    //  Initialize the code to receive a browser server list.
    //

    BowserpInitializeGetBrowserServerList();

    //
    //  Initialize the bowser FSP.
    //

    if (!NT_SUCCESS(Status = BowserpInitializeFsp(DriverObject))) {
        return Status;
    }

    if (!NT_SUCCESS(Status = BowserpInitializeNames())) {
        return Status;
    }

#if DBG
    //
    //  If we have a preconfigured trace level, open the browser trace log
    //  right away.
    //

    if (BowserDebugLogLevel != 0) {
        BowserOpenTraceLogFile(L"\\SystemRoot\\Bowser.Log");
    }
#endif

//    //
//    //  Set up the browsers unload routine.
//    //
//
//    DriverObject->DriverUnload = BowserUnload;

    BowserInitializeDiscardableCode();


    //
    //  Set the timer up for the idle timer.
    //

    IoInitializeTimer((PDEVICE_OBJECT )BowserDeviceObject, BowserIdleTimer,
                                                NULL);



    RtlInitUnicodeString( &unicodeEventName, SERVER_ANNOUNCE_EVENT_W );
    InitializeObjectAttributes( &obja, &unicodeEventName, OBJ_OPENIF, NULL, NULL );

    Status = ZwCreateEvent(
                 &BowserServerAnnouncementEventHandle,
                 SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                 &obja,
                 SynchronizationEvent,
                 FALSE
                 );

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(BowserServerAnnouncementEventHandle,
                                            EVENT_MODIFY_STATE,
                                            NULL,
                                            KernelMode,
                                            &BowserServerAnnouncementEvent,
                                            NULL);
    }

    //
    // Always create a domain structure for the primary domain.
    //
    RtlInitUnicodeString( &DummyDomain, NULL );
    BowserPrimaryDomainInfo = BowserCreateDomain( &DummyDomain, &DummyDomain );

    return Status;

}


VOID
BowserUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the bowser device.

Arguments:

     DriverObject - pointer to the driver object for the browser driver

Return Value:

     None

--*/

{
    PAGED_CODE();

    if ( BowserData.Initialized ){

        //
        // StopBowser was never called (mem cleanup skipped etc).
        // Call it before exiting (see bug 359407).
        //

        // Fake (unused) paramters
        BOWSER_FS_DEVICE_OBJECT fsDevice;
        LMDR_REQUEST_PACKET InputBuffer;

        fsDevice.DeviceObject = *DriverObject->DeviceObject;

        // set fake input buffer. It is unused (except param check) in
        // StopBowser
        InputBuffer.Version = LMDR_REQUEST_PACKET_VERSION_DOM;


        ASSERT ((IoGetCurrentProcess() == BowserFspProcess));
        (VOID) StopBowser(
                   TRUE,
                   TRUE,
                   &fsDevice,
                   &InputBuffer,
                   sizeof(LMDR_REQUEST_PACKET) );

    }

    //
    // Ditch the global reference to the primary domain.
    //

    if ( BowserPrimaryDomainInfo != NULL ) {
        // break if we're leaking memory. StopBowser should
        // have cleaned all references.
        ASSERT ( BowserPrimaryDomainInfo->ReferenceCount == 1 );
        BowserDereferenceDomain( BowserPrimaryDomainInfo );
    }

    //
    //  Uninitialize the bowser name structures.
    //

    BowserpUninitializeNames();

    //
    //  Uninitialize the bowser FSP.
    //

    BowserpUninitializeFsp();

    //
    //  Uninitialize the routines involved in retrieving browser server lists.
    //

    BowserpUninitializeGetBrowserServerList();

    //
    //  Uninitialize the mailslot related functions.
    //

    BowserpUninitializeMailslot();

    //
    //  Uninitialize the TDI related functions.
    //

    BowserpUninitializeTdi();

    //
    //  Delete the resource protecting the bowser global data.
    //

    ExDeleteResourceLite(&BowserDataResource);

    ObDereferenceObject(BowserServerAnnouncementEvent);

    ZwClose(BowserServerAnnouncementEventHandle);

#if DBG
    BowserUninitializeTraceLog();
#endif

    //
    //  Delete the browser device object.
    //

    IoDeleteDevice((PDEVICE_OBJECT)BowserDeviceObject);

    BowserUninitializeDiscardableCode();

    return;
}

VOID
BowserReadBowserConfiguration(
    PUNICODE_STRING RegistryPath
    )
{
    ULONG Storage[256];
    UNICODE_STRING UnicodeString;
    HANDLE RedirConfigHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    ULONG BytesRead;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PBOWSER_CONFIG_INFO ConfigEntry;
    PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

    PAGED_CODE();

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&RedirConfigHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        BowserWriteErrorLogEntry (
            EVENT_BOWSER_CANT_READ_REGISTRY,
            Status,
            NULL,
            0,
            0
            );

        return;
    }

    RtlInitUnicodeString(&UnicodeString, BOWSER_CONFIG_PARAMETERS);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        RedirConfigHandle,
        NULL
        );


    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        BowserWriteErrorLogEntry (
            EVENT_BOWSER_CANT_READ_REGISTRY,
            Status,
            NULL,
            0,
            0
            );

        ZwClose(RedirConfigHandle);

        return;
    }

    for (ConfigEntry = BowserConfigEntries;
         ConfigEntry->ConfigParameterName != NULL;
         ConfigEntry += 1) {

        RtlInitUnicodeString(&UnicodeString, ConfigEntry->ConfigParameterName);

        Status = ZwQueryValueKey(ParametersHandle,
                            &UnicodeString,
                            KeyValueFullInformation,
                            Value,
                            sizeof(Storage),
                            &BytesRead);


        if (NT_SUCCESS(Status)) {

            if (Value->DataLength != 0) {

                if (ConfigEntry->ConfigValueType == REG_BOOLEAN) {
                    if (Value->Type != REG_DWORD ||
                        Value->DataLength != REG_BOOLEAN_SIZE) {
                        BowserWriteErrorLogEntry (
                            EVENT_BOWSER_CANT_READ_REGISTRY,
                            STATUS_INVALID_PARAMETER,
                            ConfigEntry->ConfigParameterName,
                            (USHORT)(wcslen(ConfigEntry->ConfigParameterName)*sizeof(WCHAR)),
                            0
                            );

                    } else {
                        ULONG_PTR ConfigValue = (ULONG_PTR)((PCHAR)Value)+Value->DataOffset;

                        *(PBOOLEAN)(ConfigEntry->ConfigValue) = (BOOLEAN)(*((PULONG)ConfigValue) != 0);
                    }

                } else if (Value->Type != ConfigEntry->ConfigValueType ||
                    Value->DataLength != ConfigEntry->ConfigValueSize) {

                    BowserWriteErrorLogEntry (
                        EVENT_BOWSER_CANT_READ_REGISTRY,
                        STATUS_INVALID_PARAMETER,
                        ConfigEntry->ConfigParameterName,
                        (USHORT)(wcslen(ConfigEntry->ConfigParameterName)*sizeof(WCHAR)),
                        0
                        );

                } else {

                    RtlCopyMemory(ConfigEntry->ConfigValue, ((PCHAR)Value)+Value->DataOffset, Value->DataLength);
                }
            } else {
                BowserWriteErrorLogEntry (
                        EVENT_BOWSER_CANT_READ_REGISTRY,
                        STATUS_INVALID_PARAMETER,
                        ConfigEntry->ConfigParameterName,
                        (USHORT)(wcslen(ConfigEntry->ConfigParameterName)*sizeof(WCHAR)),
                        0
                        );
            }
        }

    }


    ZwClose(ParametersHandle);

    ZwClose(RedirConfigHandle);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\fspdisp.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    fspdisp.c

Abstract:

    This file provides the main FSP dispatch routine for the NT browser.

    It mostly provides a switch statement that calls the appropriate BowserFsp
    routine and returns that status to the caller.

Notes:
    There are two classes of browser FSP worker threads.  The first
    are what are called FSP worker threads.  These threads are responsible
    for processing NT Irp's passed onto the browser's main work thread.

    In addition to this pool of threads, there is a small pool of "generic"
    worker threads whose sole purpose is to process generic request
    operations.  These are used for processing such operations as close
    behind, etc.


Author:

    Larry Osterman (LarryO) 31-May-1990

Revision History:

    31-May-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop


//
//  This defines the granularity of the scavenger timer.  If it is set
//  to 30 (for example), the scavenger thread will fire every 30 seconds.
//

#define SCAVENGER_TIMER_GRANULARITY 30
#define UNEXPECTED_TIMER_GRANULARITY (60 * 60 / SCAVENGER_TIMER_GRANULARITY)

//
// This counter is used to control kicking the scavenger thread.
//
ULONG
BowserTimerCounter = SCAVENGER_TIMER_GRANULARITY;


KSPIN_LOCK
BowserTimeSpinLock = {0};

VOID
BowserFspDispatch (
    IN PVOID WorkHeader
    );

VOID
BowserScavenger (
    IN PVOID WorkHeader
    );

VOID
BowserLogUnexpectedEvents(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserFsdPostToFsp)
#pragma alloc_text(PAGE, BowserFspDispatch)
#pragma alloc_text(PAGE, BowserLogUnexpectedEvents)
#pragma alloc_text(PAGE, BowserScavenger)
#pragma alloc_text(PAGE, BowserpUninitializeFsp)
#pragma alloc_text(INIT, BowserpInitializeFsp)
#endif

NTSTATUS
BowserFsdPostToFsp(
    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine passes the IRP specified onto the FSP work queue, and kicks
    an FSP thread.   This routine accepts an I/O Request Packet (IRP) and a
    work queue and passes the request to the appropriate request queue.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    PIRP_CONTEXT IrpContext;

    PAGED_CODE();

    IrpContext = BowserAllocateIrpContext();

    if ( IrpContext == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Mark this I/O request as being pending.
    //

    IoMarkIrpPending(Irp);

    //
    //  Queue the request to a generic worker thread.
    //

    IrpContext->Irp = Irp;

    IrpContext->DeviceObject = DeviceObject;

    ExInitializeWorkItem(&IrpContext->WorkHeader, BowserFspDispatch, IrpContext);

    ExQueueWorkItem(&IrpContext->WorkHeader, DelayedWorkQueue);

    return STATUS_PENDING;

}


VOID
BowserFspDispatch (
    IN PVOID WorkHeader
    )

/*++

Routine Description:

    BowserFspDispatch is the main dispatch routine for the NT browser's
    FSP.  It will process worker requests as queued.

Arguments:

    DeviceObject - A pointer to the browser DeviceObject

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext = WorkHeader;
    PIRP Irp = IrpContext->Irp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status;
    PBOWSER_FS_DEVICE_OBJECT DeviceObject = IrpContext->DeviceObject;

    PAGED_CODE();

    //
    //  We no longer need the IRP context, free it as soon as possible.
    //

    BowserFreeIrpContext(IrpContext);

    dlog(DPRT_FSPDISP, ("BowserFspDispatch: Got request, Irp = %08lx, "
            "Function = %d Aux buffer = %08lx\n", Irp, IrpSp->MajorFunction,
                                           Irp->Tail.Overlay.AuxiliaryBuffer));

    switch (IrpSp->MajorFunction) {

    case IRP_MJ_DEVICE_CONTROL:
        Status =  BowserFspDeviceIoControlFile (DeviceObject, Irp);
        break;

    case IRP_MJ_QUERY_INFORMATION:
        Status =  BowserFspQueryInformationFile (DeviceObject, Irp);
        break;

    case IRP_MJ_QUERY_VOLUME_INFORMATION:
        Status =  BowserFspQueryVolumeInformationFile (DeviceObject, Irp);
        break;

    case IRP_MJ_FILE_SYSTEM_CONTROL:
    case IRP_MJ_CREATE:
    case IRP_MJ_CLEANUP:
    case IRP_MJ_READ:
    case IRP_MJ_WRITE:
    case IRP_MJ_DIRECTORY_CONTROL:
    case IRP_MJ_SET_INFORMATION:
    case IRP_MJ_LOCK_CONTROL:
    case IRP_MJ_FLUSH_BUFFERS:
    case IRP_MJ_QUERY_EA:
    case IRP_MJ_CREATE_NAMED_PIPE:
    case IRP_MJ_CLOSE:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        BowserCompleteRequest(Irp, Status);
        break;

    default:
        InternalError(("Unimplemented function %d\n", IrpSp->MajorFunction));
        Status = STATUS_NOT_IMPLEMENTED;
        BowserCompleteRequest(Irp, Status);
        break;
    }

    return;
}


VOID
BowserIdleTimer (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine implements the NT redirector's scavenger thread timer.
    It basically waits for the timer granularity and kicks the scavenger
    thread.


Arguments:

    IN PDEVICE_OBJECT DeviceObject - Supplies the device object for the timer
    IN PVOID Context - Ignored in this routine.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);

    //
    //  Bump the current time counter.
    //

    BowserCurrentTime++;

    if (BowserEventLogResetFrequency != -1) {
        BowserEventLogResetFrequency -= 1;

        if (BowserEventLogResetFrequency < 0) {
            BowserEventLogResetFrequency = BowserData.EventLogResetFrequency;

            BowserIllegalDatagramCount = BowserData.IllegalDatagramThreshold;
            BowserIllegalDatagramThreshold = FALSE;

            BowserIllegalNameCount = BowserData.IllegalDatagramThreshold;
            BowserIllegalNameThreshold = FALSE;
        }
    }


    //
    //  We use the redirector's time spinlock as a convenient spinlock here.
    //

    if (BowserTimerCounter != 0) {

        BowserTimerCounter -= 1;

        if (BowserTimerCounter == 0) {
            PWORK_QUEUE_ITEM WorkHeader;

            RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

            WorkHeader = ALLOCATE_POOL(NonPagedPool, sizeof(WORK_QUEUE_ITEM), POOL_WORKITEM);

            //
            //  If the allocation of pool fails, we simply don't queue this
            //  request to the scavenger.  The scavenger is low priority,
            //  thus it isn't a big deal to fail this request.
            //

            if (WorkHeader != NULL) {

                ExInitializeWorkItem(WorkHeader, BowserScavenger, WorkHeader);

                //
                // Due to bug 245645 we need to queue in delayed worker queue rather then execute timed tasks.
                // OLD WAY: ExQueueWorkItem(WorkHeader, DelayedWorkQueue);
                //
                BowserQueueDelayedWorkItem( WorkHeader );


            }

            //
            //  Re-acquire the spin lock to make the exit path cleaner.
            //

            ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);
        }
    }

    RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

    return;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Context);
}

LONG
UnexpectedEventTimer = UNEXPECTED_TIMER_GRANULARITY;

VOID
BowserLogUnexpectedEvents(
    VOID
    )
{
    LONG TimerSign;
    PAGED_CODE();

    TimerSign = InterlockedDecrement( &UnexpectedEventTimer );

    if ( TimerSign == 0) {

        if (BowserNumberOfMissedMailslotDatagrams > BowserMailslotDatagramThreshold) {
            BowserWriteErrorLogEntry(EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED, STATUS_INSUFFICIENT_RESOURCES, NULL, 0, 0);
            BowserNumberOfMissedMailslotDatagrams = 0;
        }

        if (BowserNumberOfMissedGetBrowserServerListRequests > BowserGetBrowserListThreshold) {
            BowserWriteErrorLogEntry(EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED, STATUS_INSUFFICIENT_RESOURCES, NULL, 0, 0);
            BowserNumberOfMissedGetBrowserServerListRequests = 0;
        }

        InterlockedExchangeAdd(&UnexpectedEventTimer, UNEXPECTED_TIMER_GRANULARITY );
    }
}

VOID
BowserScavenger (
    IN PVOID Context
    )

/*++

Routine Description:

    This function implements the NT browsers's scavenger thread.  It
    performs all idle time operations such as closing out dormant connections
    etc.


Arguments:

    IN PBOWSER_FS_DEVICE_OBJECT DeviceObject - Supplies the device object associated
            with this request.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    dlog(DPRT_SCAVTHRD, ("BowserScavenger\n"));

    //
    //  Deallocate the pool used for the work context header - we're done with
    //  it.
    //

    FREE_POOL(Context);

    //
    //  Remove old entries from the announcetable.
    //

    BowserAgeServerAnnouncements();

    //
    //  Log if any of our thresholds have been exceeded.
    //

    BowserLogUnexpectedEvents();

    //
    //  Time out any outstanding find master requests if they have taken too
    //  long.
    //

    BowserTimeoutFindMasterRequests();

    //
    //  Reset the timer counter back to the appropriate value
    //  once we have finished processing these requests.
    //

    ExInterlockedAddUlong(&BowserTimerCounter, SCAVENGER_TIMER_GRANULARITY, &BowserTimeSpinLock);

}


NTSTATUS
BowserpInitializeFsp (
    PDRIVER_OBJECT BowserDriverObject
    )

/*++

Routine Description:

    This routine initializes the FSP specific components and dispatch
    routines.

Arguments:

    None.

Return Value:

    None.

--*/

{
#if 0
    USHORT i;

    //
    // Initialize the driver object with this driver's entry points.
    //
    // By default, pass all requests to the FSD.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        BowserDriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)BowserFsdPostToFsp;
    }

    //
    //  Initialize those request that are to be performed in the FSD, not
    //  in the FSP.
    //

    BowserDriverObject->MajorFunction[IRP_MJ_CREATE] =
            (PDRIVER_DISPATCH )BowserFsdCreate;

    BowserDriverObject->MajorFunction[IRP_MJ_CLOSE] =
            (PDRIVER_DISPATCH )BowserFsdClose;

    BowserDriverObject->MajorFunction[IRP_MJ_CLEANUP] =
            (PDRIVER_DISPATCH )BowserFsdCleanup;

    BowserDriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] =
            (PDRIVER_DISPATCH )BowserFsdQueryInformationFile;

    BowserDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
            (PDRIVER_DISPATCH )BowserFsdDeviceIoControlFile;

#endif

    BowserInitializeIrpContext();

    KeInitializeSpinLock(&BowserTimeSpinLock);

    return STATUS_SUCCESS;

}

VOID
BowserpUninitializeFsp (
    VOID
    )

/*++

Routine Description:

    This routine initializes the FSP specific components and dispatch
    routines.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    BowserpUninitializeIrpContext();

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\precomp.h ===
#include <ntifs.h>

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#include "bowser.h"
#include <align.h>
#include <ctype.h>
#include <netevent.h>
#include <stdarg.h>
#include <stdio.h>
#include <tstr.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\receive.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module implements the routines needed to process TDI receive
indication requests.


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  LarryO

        Created

--*/
#include "precomp.h"
#pragma hdrstop

//
// Keep track of the number of datagram queued to worker threads.
//  Keep a separate count of critical versus non-critical to ensure non-critical
//  datagrams don't starve critical ones.
//

LONG BowserPostedDatagramCount;
LONG BowserPostedCriticalDatagramCount;
#define BOWSER_MAX_POSTED_DATAGRAMS 100

#define INCLUDE_SMB_TRANSACTION

typedef struct _PROCESS_MASTER_ANNOUNCEMENT_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT Transport;
    ULONG   ServerType;
    ULONG   ServerElectionVersion;
    UCHAR   MasterName[NETBIOS_NAME_LEN];
    ULONG   MasterAddressLength;
    UCHAR   Buffer[1];
} PROCESS_MASTER_ANNOUNCEMENT_CONTEXT, *PPROCESS_MASTER_ANNOUNCEMENT_CONTEXT;

typedef struct _ILLEGAL_DATAGRAM_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT_NAME TransportName;
    NTSTATUS EventStatus;
    USHORT   BufferSize;
    UCHAR    SenderName[max(NETBIOS_NAME_LEN, SMB_IPX_NAME_LENGTH)];
    UCHAR    Buffer[1];
} ILLEGAL_DATAGRAM_CONTEXT, *PILLEGAL_DATAGRAM_CONTEXT;

VOID
BowserLogIllegalDatagramWorker(
    IN PVOID Ctx
    );

VOID
BowserProcessMasterAnnouncement(
    IN PVOID Ctx
    );


DATAGRAM_HANDLER(
    HandleLocalMasterAnnouncement
    );

DATAGRAM_HANDLER(
    HandleAnnounceRequest
    );

NTSTATUS
CompleteReceiveMailslot (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CompleteShortBrowserPacket (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Ctx
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserLogIllegalDatagramWorker)
#pragma alloc_text(PAGE, BowserProcessMasterAnnouncement)
#endif


PDATAGRAM_HANDLER
BowserDatagramHandlerTable[] = {
    NULL,                           // 0 - Illegal (no opcode for this).
    BowserHandleServerAnnouncement, // 1 - HostAnnouncement
    HandleAnnounceRequest,          // 2 - AnnouncementRequest
    NULL,                           // 3 - InterrogateInfoRequest
    NULL,                           // 4 - RelogonRequest
    NULL,                           // 5
    NULL,                           // 6
    NULL,                           // 7
    BowserHandleElection,           // 8 - Election
    BowserGetBackupListRequest,     // 9 - GetBackupListReq
    BowserGetBackupListResponse,    // a - GetBackupListResp
    BowserHandleBecomeBackup,       // b - BecomeBackupServer
    BowserHandleDomainAnnouncement, // c - WkGroupAnnouncement,
    BowserMasterAnnouncement,       // d - MasterAnnouncement,
    BowserResetState,               // e - ResetBrowserState
    HandleLocalMasterAnnouncement   // f - LocalMasterAnnouncement
};

NTSTATUS
BowserTdiReceiveDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,           // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )

/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PVOID TdiEventContext    - the event context
    IN int SourceAddressLength  - length of the originator of the datagram
    IN PVOID SourceAddress,     - string describing the originator of the datagram
    IN int OptionsLength,       - options for the receive
    IN PVOID Options,           -
    IN ULONG BytesIndicated,    - number of bytes this indication
    IN ULONG BytesAvailable,    - number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,      - number of bytes used
    IN PVOID Tsdu,              - pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket   - TdiReceive IRP if MORE_PROCESSING_REQUIRED.


Return Value:

    NTSTATUS - Status of operation.

--*/


{
    PVOID DatagramData;
    PINTERNAL_TRANSACTION InternalTransaction = NULL;
    ULONG DatagramDataSize;
    PTRANSPORT_NAME TransportName = TdiEventContext;
    MAILSLOTTYPE Opcode;
    TA_NETBIOS_ADDRESS ClientNetbiosAddress;
    ULONG ClientNetbiosAddressSize;

    if (BytesAvailable > ((PTRANSPORT_NAME)TdiEventContext)->Transport->DatagramSize) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    if (NULL == TransportName->DeviceObject) {
        //
        // The transport isn't ready yet to process receives (probably
        // we're still processing the transport bind call).
        // Drop this receive.
        //
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    //
    // Make a copy of the SourceAddress that just has the netbios address
    //  (We could pass the second address along, but there are many
    //  places that expect just a single source address.)
    //

    if ( SourceAddressLength < sizeof(TA_NETBIOS_ADDRESS)) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    TdiCopyLookaheadData( &ClientNetbiosAddress, SourceAddress, sizeof(TA_NETBIOS_ADDRESS), ReceiveDatagramFlags);

    if ( ClientNetbiosAddress.Address[0].AddressType != TDI_ADDRESS_TYPE_NETBIOS ) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }
    ClientNetbiosAddressSize = sizeof(TA_NETBIOS_ADDRESS);

    ClientNetbiosAddress.TAAddressCount = 1;


    //
    //  Classify the incoming packet according to it's type.  Depending on
    //  the type, either process it as:
    //
    //  1) A server announcement
    //  2) An incoming mailslot
    //

    Opcode = BowserClassifyIncomingDatagram(Tsdu, BytesIndicated,
                                            &DatagramData,
                                            &DatagramDataSize);
    if (Opcode == MailslotTransaction) {

        //
        // Grab the IP address of the client.
        //
        PTA_NETBIOS_ADDRESS OrigNetbiosAddress = SourceAddress;
        ULONG ClientIpAddress = 0;
        if ( OrigNetbiosAddress->TAAddressCount > 1 ) {
            TA_ADDRESS * TaAddress = (TA_ADDRESS *)
                (((LPBYTE)&OrigNetbiosAddress->Address[0].Address[0]) +
                    OrigNetbiosAddress->Address[0].AddressLength);

            if ( TaAddress->AddressLength >= sizeof(TDI_ADDRESS_IP) &&
                 TaAddress->AddressType == TDI_ADDRESS_TYPE_IP ) {
                TDI_ADDRESS_IP UNALIGNED * TdiAddressIp = (TDI_ADDRESS_IP UNALIGNED *) (TaAddress->Address);

                ClientIpAddress = TdiAddressIp->in_addr;
            }

        }

        return BowserHandleMailslotTransaction(
                    TransportName,
                    ClientNetbiosAddress.Address[0].Address->NetbiosName,
                    ClientIpAddress,
                    0,      // SMB offset into TSDU
                    ReceiveDatagramFlags,
                    BytesIndicated,
                    BytesAvailable,
                    BytesTaken,
                    Tsdu,
                    IoRequestPacket );

    } else if (Opcode == Illegal) {
        BowserLogIllegalDatagram(TdiEventContext,
                                    Tsdu,
                                    (USHORT)(BytesIndicated & 0xffff),
                                    ClientNetbiosAddress.Address[0].Address->NetbiosName,
                                    ReceiveDatagramFlags);
        return STATUS_REQUEST_NOT_ACCEPTED;
    } else {

        if (BowserDatagramHandlerTable[Opcode] == NULL) {
            return STATUS_SUCCESS;
        }

        //
        //  If this isn't the full packet, post a receive for it and
        //  handle it when we finally complete the receive.
        //

        if (BytesIndicated < BytesAvailable) {
            return BowserHandleShortBrowserPacket(TransportName,
                                                    TdiEventContext,
                                                    ClientNetbiosAddressSize,
                                                    &ClientNetbiosAddress,
                                                    OptionsLength,
                                                    Options,
                                                    ReceiveDatagramFlags,
                                                    BytesAvailable,
                                                    BytesTaken,
                                                    IoRequestPacket,
                                                    BowserTdiReceiveDatagramHandler
                                                    );
        }

        InternalTransaction = DatagramData;

        if (((Opcode == WkGroupAnnouncement) ||
             (Opcode == HostAnnouncement)) && !TransportName->ProcessHostAnnouncements) {
            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        ASSERT (DatagramDataSize == (BytesIndicated - ((PCHAR)InternalTransaction - (PCHAR)Tsdu)));

        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BrowseAnnouncement));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.RequestElection));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BecomeBackup));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListRequest));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListResp));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.ResetState));
        ASSERT (FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement) == FIELD_OFFSET(INTERNAL_TRANSACTION, Union.MasterAnnouncement));

        return BowserDatagramHandlerTable[Opcode](TdiEventContext,
                                            &InternalTransaction->Union.Announcement,
                                            BytesIndicated-(ULONG)((PCHAR)&InternalTransaction->Union.Announcement - (PCHAR)Tsdu),
                                            BytesTaken,
                                            &ClientNetbiosAddress,
                                            ClientNetbiosAddressSize,
                                            ClientNetbiosAddress.Address[0].Address->NetbiosName,
                                            NETBIOS_NAME_LEN,
                                            ReceiveDatagramFlags);
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(OptionsLength);
    UNREFERENCED_PARAMETER(Options);
    UNREFERENCED_PARAMETER(ReceiveDatagramFlags);
}

VOID
BowserLogIllegalDatagram(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID IncomingBuffer,
    IN USHORT BufferSize,
    IN PCHAR ClientName,
    IN ULONG ReceiveFlags
    )
{
    KIRQL OldIrql;
    NTSTATUS ErrorStatus = STATUS_SUCCESS;

    ExInterlockedAddLargeStatistic(&BowserStatistics.NumberOfIllegalDatagrams, 1);

    ACQUIRE_SPIN_LOCK(&BowserTimeSpinLock, &OldIrql);

    if (BowserIllegalDatagramCount > 0) {
        BowserIllegalDatagramCount -= 1;

        ErrorStatus = EVENT_BOWSER_ILLEGAL_DATAGRAM;

    } else if (!BowserIllegalDatagramThreshold) {
        BowserIllegalDatagramThreshold = TRUE;
        ErrorStatus = EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD;
    }

    RELEASE_SPIN_LOCK(&BowserTimeSpinLock, OldIrql);

//    if (!memcmp(TransportName->Transport->ComputerName->Name->NetbiosName.Address[0].Address->NetbiosName, ClientAddress->Address[0].Address->NetbiosName, CNLEN)) {
//        DbgBreakPoint();
//    }

    if (ErrorStatus != STATUS_SUCCESS) {
        PILLEGAL_DATAGRAM_CONTEXT Context = NULL;

        Context = ALLOCATE_POOL(NonPagedPool, sizeof(ILLEGAL_DATAGRAM_CONTEXT)+BufferSize, POOL_ILLEGALDGRAM);

        if (Context != NULL) {
            Context->EventStatus = ErrorStatus;
            Context->TransportName = TransportName;
            Context->BufferSize = BufferSize;

            TdiCopyLookaheadData(&Context->Buffer, IncomingBuffer, BufferSize, 0);

            BowserCopyOemComputerName( Context->SenderName,
                                       ClientName,
                                       sizeof(Context->SenderName),
                                       ReceiveFlags);

            ExInitializeWorkItem(&Context->WorkItem, BowserLogIllegalDatagramWorker, Context);

            BowserQueueDelayedWorkItem( &Context->WorkItem );
        }

    }
}

VOID
BowserCopyOemComputerName(
    PCHAR OutputComputerName,
    PCHAR NetbiosName,
    ULONG NetbiosNameLength,
    IN ULONG ReceiveFlags
    )
{
    ULONG i;

    //
    //  Since this routine can be called at indication time, we need to use
    //  TdiCopyLookaheadData
    //

    TdiCopyLookaheadData(OutputComputerName, NetbiosName, NetbiosNameLength, ReceiveFlags);

    for (i = NetbiosNameLength-2; i ; i -= 1) {

        if ((OutputComputerName[i] != ' ') &&
            (OutputComputerName[i] != '\0')) {
            OutputComputerName[i+1] = '\0';
            break;
        }
    }
}


VOID
BowserLogIllegalDatagramWorker(
    IN PVOID Ctx
    )
{
    PILLEGAL_DATAGRAM_CONTEXT Context = Ctx;
    NTSTATUS EventContext = Context->EventStatus;
    LPWSTR TransportNamePointer = &Context->TransportName->Transport->PagedTransport->TransportName.Buffer[(sizeof(L"\\Device\\") / sizeof(WCHAR))-1];
    LPWSTR NamePointer = Context->TransportName->PagedTransportName->Name->Name.Buffer;
    UNICODE_STRING ClientNameU;
    OEM_STRING ClientNameO;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitAnsiString(&ClientNameO, Context->SenderName);

    Status = RtlOemStringToUnicodeString(&ClientNameU, &ClientNameO, TRUE);

    if (!NT_SUCCESS(Status)) {
        BowserLogIllegalName( Status, ClientNameO.Buffer, ClientNameO.Length );
    }
    else {

        BowserWriteErrorLogEntry(EventContext, STATUS_REQUEST_NOT_ACCEPTED,
                                                Context->Buffer,
                                                Context->BufferSize,
                                                3, ClientNameU.Buffer,
                                                NamePointer,
                                                TransportNamePointer);
        RtlFreeUnicodeString(&ClientNameU);
    }

    FREE_POOL(Context);

}


CHAR BowserMinimumDatagramSize[] = {
    (CHAR)0xff,                   // 0 - Illegal (no opcode for this).
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement.NameComment), // HostAnnouncement
    (CHAR)0xff,                   // AnnouncementRequest
    (CHAR)0xff,                   // InterrogateInfoRequest
    (CHAR)0xff,                   // RelogonRequest
    (CHAR)0xff,                   // 5
    (CHAR)0xff,                   // 6
    (CHAR)0xff,                   // 7
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.RequestElection.ServerName),// Election
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListRequest.Token),// GetBackupListReq
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.GetBackupListResp.Token),   // GetBackupListResp
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BecomeBackup.BrowserToPromote), // BecomeBackupServer
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.BrowseAnnouncement.Comment), // WkGroupAnnouncement,
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.ResetState.Options),        // ResetBrowserState
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.MasterAnnouncement.MasterName), // MasterAnnouncement,
    (CHAR)FIELD_OFFSET(INTERNAL_TRANSACTION, Union.Announcement.NameComment) // LocalMasterAnnouncement
};

MAILSLOTTYPE
BowserClassifyIncomingDatagram(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *DatagramData,
    OUT PULONG DatagramDataSize
    )
/*++

Routine Description:

    This routine will classify an incoming datagram into its type - either
    Illegal, ServerAnnouncement, or MailslotRequest.

Arguments:

    IN PVOID Buffer,      - pointer describing this TSDU, typically a lump of bytes
    IN ULONG BufferLength - number of bytes in complete Tsdu

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PSMB_HEADER Header = Buffer;
    PSMB_TRANSACT_MAILSLOT Transaction = (PSMB_TRANSACT_MAILSLOT) (Header+1);
    PSZ MailslotName = Transaction->Buffer;
    PINTERNAL_TRANSACTION InternalTransaction;
    BOOLEAN MailslotLanman = FALSE;
    BOOLEAN MailslotBrowse = FALSE;
    ULONG i;
    ULONG MaxMailslotNameLength;

    ASSERT (sizeof(BowserMinimumDatagramSize) == MaximumMailslotType);

    //
    //  We only know things that start with an SMB header.
    //

    if ((BufferLength < sizeof(SMB_HEADER)) ||

        (SmbGetUlong(((PULONG )Header->Protocol)) != (ULONG)SMB_HEADER_PROTOCOL) ||

    //
    //  All mailslots and server announcements go via the transaction SMB
    //  protocol.
    //
        (Header->Command != SMB_COM_TRANSACTION) ||

    //
    //  The buffer has to be big enough to hold a mailslot transaction.
    //

        (BufferLength <= (FIELD_OFFSET(SMB_TRANSACT_MAILSLOT, Buffer)  + sizeof(SMB_HEADER)) + SMB_MAILSLOT_PREFIX_LENGTH) ||

    //
    //  The word count for a transaction SMB is 17 (14+3 setup words).
    //

        (Transaction->WordCount != 17) ||

    //
    //  There must be 3 setup words.
    //

        (Transaction->SetupWordCount != 3) ||

//    //
//    //  Mailslot and server announcements expect no response.
//    //
//
//        (!(SmbGetUshort(&Transaction->Flags) & SMB_TRANSACTION_NO_RESPONSE)) ||

    //
    //  There are no parameter bytes for a mailslot write.
    //

        (SmbGetUshort(&Transaction->TotalParameterCount) != 0) ||

    //
    //  This must be a mailslot write command.
    //

        (SmbGetUshort(&Transaction->Opcode) != TRANS_MAILSLOT_WRITE) ||

    //
    //  And it must be a second class mailslot write.
    //

        (SmbGetUshort(&Transaction->Class) != 2) ||

        _strnicmp(MailslotName, SMB_MAILSLOT_PREFIX,
                 min(SMB_MAILSLOT_PREFIX_LENGTH,
                     BufferLength-(ULONG)((PCHAR)MailslotName-(PCHAR)Buffer)))) {

        return Illegal;
    }


    //
    // Ensure there's a zero byte in the mailslotname
    //

    MaxMailslotNameLength =
                min( MAXIMUM_FILENAME_LENGTH-7,   // \Device
                BufferLength-(ULONG)((PCHAR)MailslotName-(PCHAR)Buffer));

    for ( i = SMB_MAILSLOT_PREFIX_LENGTH; i < MaxMailslotNameLength; i++ ) {
        if ( MailslotName[i] == '\0' ) {
            break;
        }
    }

    if ( i == MaxMailslotNameLength ) {
        return Illegal;
    }


    //
    //  We now know this is a mailslot of some kind.  Now check what type
    //  of mailslot it is.
    //
    //
    //  There are two special mailslot names we understand, \MAILSLOT\LANMAN,
    //  and \MAILSLOT\BROWSE
    //

    if (_strnicmp(MailslotName, MAILSLOT_LANMAN_NAME, min(sizeof(MAILSLOT_LANMAN_NAME)-1, BufferLength-(ULONG)((PCHAR)Buffer-(PCHAR)MailslotName)))) {

        if (_strnicmp(MailslotName, MAILSLOT_BROWSER_NAME, min(sizeof(MAILSLOT_BROWSER_NAME)-1, BufferLength-(ULONG)((PCHAR)Buffer-(PCHAR)MailslotName)))) {
            return MailslotTransaction;
        }
    }

//
//  CLEANUP - Not necessary with code below commented out.
//
//          else {
//            MailslotBrowse = TRUE;
//        }
//
//    } else {
//        MailslotLanman = TRUE;
//    }
//

    //
    //  This mailslot write is to the special mailslot \MAILSLOT\LANMAN (or \MAILSLOT\MSBROWSE).
    //

    //
    //  Check that the data is within the supplied buffer, and ensure that the one
    //     byte Type field is within the buffer since we need to dereference it below
    //     to do the overall size check (this is the reason for BufferLength - 1).
    //

    if (SmbGetUshort(&Transaction->DataOffset) > BufferLength - 1) {
       return Illegal;
    }

    //
    //  Verify that the supplied data size exceeds the minimum for this type of
    //     transaction.
    //

    *DatagramData       = (((PCHAR)Header) + SmbGetUshort(&Transaction->DataOffset));
    InternalTransaction = *DatagramData;
    *DatagramDataSize   = (BufferLength - (ULONG)((PCHAR)InternalTransaction - (PCHAR)Buffer));

    if (InternalTransaction->Type >= MaximumMailslotType) {
        return Illegal;
    }

    if (((LONG)*DatagramDataSize) < BowserMinimumDatagramSize[InternalTransaction->Type]) {
        return Illegal;
    }

//    //
//    //  Figure out what type of mailslot it is by looking at the
//    //  data in the message.
//    //
//
//
//    //
//    //  Depending on which special mailslot this is, certain types of requests
//    //  are illegal.
//    //
//    switch (InternalTransaction->Type) {
//    case InterrogateInfoRequest:
//    case RelogonRequest:
//        if (MailslotBrowse) {
//            return Illegal;
//        }
//        break;
//
//    case GetBackupListReq:
//    case GetBackupListResp:
//    case BecomeBackupServer:
//    case WkGroupAnnouncement:
//    case MasterAnnouncement:
//    case Election:
//        if (MailslotLanman) {
//            return Illegal;
//        }
//        break;
//    }
//

    //
    //  The type of this request is the first UCHAR inside the transaction
    //  data.
    //

    return (MAILSLOTTYPE )InternalTransaction->Type;

}

DATAGRAM_HANDLER(
    HandleLocalMasterAnnouncement
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT Transport     - The transport provider for this request.
    IN ULONG BytesAvailable     - number of bytes in complete Tsdu
    IN PHOST_ANNOUNCE_PACKET_1 HostAnnouncement - the server announcement.
    IN ULONG BytesAvailable     - The number of bytes in the announcement.
    OUT ULONG *BytesTaken       - number of bytes used
    IN UCHAR Opcode             - the mailslot write opcode.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PPROCESS_MASTER_ANNOUNCEMENT_CONTEXT Context = NULL;
    PBROWSE_ANNOUNCE_PACKET_1 BrowseAnnouncement = Buffer;

    if (BytesAvailable < FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET_1, Comment)) {
        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    //
    // Ensure we've not consumed too much memory
    //

    InterlockedIncrement( &BowserPostedDatagramCount );

    if ( BowserPostedDatagramCount > BOWSER_MAX_POSTED_DATAGRAMS ) {
        InterlockedDecrement( &BowserPostedDatagramCount );
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    Context = ALLOCATE_POOL(NonPagedPool, sizeof(PROCESS_MASTER_ANNOUNCEMENT_CONTEXT) + SourceAddressLength, POOL_MASTERANNOUNCE);

    //
    //  If we couldn't allocate the pool from non paged pool, just give up,
    //  the master will announce within 15 minutes anyway.
    //

    if (Context == NULL) {
        InterlockedDecrement( &BowserPostedDatagramCount );
        return STATUS_SUCCESS;
    }

    ExInitializeWorkItem(&Context->WorkItem, BowserProcessMasterAnnouncement, Context);

    BowserReferenceTransport( TransportName->Transport );
    Context->Transport = TransportName->Transport;

    Context->ServerType = SmbGetUlong(&BrowseAnnouncement->Type);
    Context->ServerElectionVersion = SmbGetUlong(&BrowseAnnouncement->CommentPointer);

    RtlCopyMemory(Context->MasterName, BrowseAnnouncement->ServerName, sizeof(Context->MasterName)-1);
    Context->MasterName[sizeof(Context->MasterName)-1] = '\0';

    Context->MasterAddressLength = SourceAddressLength;

    TdiCopyLookaheadData(Context->Buffer, SourceAddress, SourceAddressLength, ReceiveFlags);

    BowserQueueDelayedWorkItem( &Context->WorkItem );

    //
    //  If we are not processing host announcements for this
    //  transport, ignore this request.
    //

    if (!TransportName->ProcessHostAnnouncements) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    return BowserHandleServerAnnouncement(TransportName,
                                            Buffer,
                                            BytesAvailable,
                                            BytesTaken,
                                            SourceAddress,
                                            SourceAddressLength,
                                            SourceName,
                                            SourceNameLength,
                                            ReceiveFlags);

}




VOID
BowserProcessMasterAnnouncement(
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine will process browser master announcements.

Arguments:

    IN PVOID Context    - Context block containing master name.

Return Value:

    None.

--*/
{
    PPROCESS_MASTER_ANNOUNCEMENT_CONTEXT Context = Ctx;
    PTRANSPORT Transport = Context->Transport;
    UNICODE_STRING MasterName;
    OEM_STRING AnsiMasterName;
    WCHAR MasterNameBuffer[LM20_CNLEN+1];

    PAGED_CODE();

    try {
        NTSTATUS Status;
        PPAGED_TRANSPORT PagedTransport = Transport->PagedTransport;

        LOCK_TRANSPORT(Transport);

        MasterName.Buffer = MasterNameBuffer;
        MasterName.MaximumLength = sizeof(MasterNameBuffer);

        //
        //  If we are currently running an election, ignore this announcement.
        //

        if (Transport->ElectionState == RunningElection) {
            try_return(NOTHING);
        }

        RtlInitAnsiString(&AnsiMasterName, Context->MasterName);

        Status = RtlOemStringToUnicodeString(&MasterName, &AnsiMasterName, FALSE);

        if (!NT_SUCCESS(Status)) {
            BowserLogIllegalName( Status, AnsiMasterName.Buffer, AnsiMasterName.Length );
            try_return(NOTHING);
        }

        //
        //  We've found our master - stop our timers - there's a master,
        //  and any find masters we have outstanding will be completed.
        //

        PagedTransport->ElectionCount = 0;

        Transport->ElectionState = Idle;

        BowserStopTimer(&Transport->ElectionTimer);

        BowserStopTimer(&Transport->FindMasterTimer);

        //
        //  If this address doesn't match the address we have for the master,
        //  then use the new address.
        //

        if (Context->MasterAddressLength != PagedTransport->MasterBrowserAddress.Length ||
            RtlCompareMemory(PagedTransport->MasterBrowserAddress.Buffer, Context->Buffer, Context->MasterAddressLength) != Context->MasterAddressLength) {

            ASSERT (Context->MasterAddressLength <= PagedTransport->MasterBrowserAddress.MaximumLength);

            if (Context->MasterAddressLength <= PagedTransport->MasterBrowserAddress.MaximumLength) {
                PagedTransport->MasterBrowserAddress.Length = (USHORT)Context->MasterAddressLength;
                RtlCopyMemory(PagedTransport->MasterBrowserAddress.Buffer, Context->Buffer, Context->MasterAddressLength);
            }

        }

        //
        //  We got a master announcement from someone else.  Remember the
        //  transport address of the master.
        //

        if (!RtlEqualUnicodeString(&Transport->DomainInfo->DomUnicodeComputerName, &MasterName, TRUE)) {
            BOOLEAN sendElection = FALSE;

            //
            //  If we're a master, and we receive this from someone else,
            //  stop being a master and force an election.
            //

            if (PagedTransport->Role == Master) {

                BowserStatistics.NumberOfDuplicateMasterAnnouncements += 1;


                //
                // Log this event.
                //  But avoid logging another one on this transport for the next
                //  60 seconds.
                //
                if ( PagedTransport->OtherMasterTime < BowserCurrentTime ) {
                    PagedTransport->OtherMasterTime = BowserCurrentTime + BowserData.EventLogResetFrequency;

                    BowserWriteErrorLogEntry(EVENT_BOWSER_OTHER_MASTER_ON_NET,
                                                STATUS_SUCCESS,
                                                NULL,
                                                0,
                                                2,
                                                MasterName.Buffer,
                                                &Transport->PagedTransport->TransportName.Buffer[(sizeof(L"\\Device\\") / sizeof(WCHAR))-1]);
                }

                if (!(PagedTransport->Flags & ELECT_LOST_LAST_ELECTION)) {

                    //
                    //  If we're the PDC, and we didn't lose the last election (ie.
                    //  we SHOULD be the browse master),then send a dummy election
                    //  packet to get the other guy to shut up.
                    //

                    if (PagedTransport->IsPrimaryDomainController) {

                        sendElection = TRUE;

                    //
                    //  If we're not an NTAS machine, or if we just lost the
                    //  last election, or if the guy announcing is a DC of some
                    //  kind, stop being the master and reset our state.
                    //

                    } else if (!BowserData.IsLanmanNt ||
                        (Context->ServerType & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL))) {

                        //
                        //  If we're not the PDC, then we want to simply inform
                        //  the browser service that someone else is the master
                        //  and let things sort themselves out when it's done.
                        //

                        BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);
                    }

                } else {

                    //
                    //  If we lost the last election, then we want to shut down
                    //  the browser regardless of what state the other browser
                    //  is in.
                    //

                    BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);
                }
            }

            //
            //  If this guy is a WfW machine, we must force an election to move
            //  mastery off of the WfW machine.
            //

            if (Context->ServerType & SV_TYPE_WFW) {
                sendElection = TRUE;
            }

            //
            // If this guy is running an older version of the browser than we are,
            //  and we didn't lose last election,
            //  then force an election to try to become master.
            //
            // We check to see if we lost the last election to prevent us from
            // constantly forcing an election when the older version is still
            // a better browse master than we are.
            //

            if ((Context->ServerElectionVersion >> 16) == 0xaa55 &&
                 (Context->ServerElectionVersion & 0xffff) <
                    (BROWSER_VERSION_MAJOR << 8) + BROWSER_VERSION_MINOR &&
                !(PagedTransport->Flags & ELECT_LOST_LAST_ELECTION)) {

                sendElection = TRUE;
            }


            //
            //  if we're an NTAS server, and the guy announcing as a master
            //  isn't an NTAS server, and we won the last election, force an
            //  election.  This will tend mastership towards DC's.
            //

            if (BowserData.IsLanmanNt &&
                !(PagedTransport->Flags & ELECT_LOST_LAST_ELECTION)) {

                if (PagedTransport->IsPrimaryDomainController) {

                    //
                    //  If we're the PDC and we didn't send the announcement,
                    //  force an election.
                    //

                    sendElection = TRUE;

                } else if (!(Context->ServerType & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL))) {
                    //
                    //  Otherwise, if the guy who announced isn't a DC, and we
                    //  are, force an election.
                    //

                    sendElection = TRUE;
                }
            }

            if (sendElection) {
                //
                //  Send a dummy election packet.  This will cause the
                //  othe browser to stop being the master and will
                //  allow the correct machine to become the master.
                //

                BowserSendElection(&Transport->DomainInfo->DomUnicodeDomainName,
                                        BrowserElection,
                                        Transport,
                                        FALSE);

            }

            //
            //  We know who the master is, complete any find master request
            //  outstanding now.
            //

            BowserCompleteFindMasterRequests(Transport, &MasterName, STATUS_SUCCESS);

        } else {

            if (PagedTransport->Role == Master) {
                BowserCompleteFindMasterRequests(Transport, &MasterName, STATUS_MORE_PROCESSING_REQUIRED);

            } else {

                //
                // If the transport is disabled,
                //  we know this transport isn't really the master,
                //  this datagram is probably just a datagram leaked from another
                //  enabled transport on the same wire.
                //
                if ( !PagedTransport->DisabledTransport ) {
                    BowserWriteErrorLogEntry(EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE,
                                                STATUS_SUCCESS,
                                                NULL,
                                                0,
                                                1,
                                                MasterName.Buffer);
                    //
                    //  Make sure that the service realizes it is out of sync
                    //  with the driver.
                    //

                    BowserResetStateForTransport(Transport, RESET_STATE_STOP_MASTER);
                }

            }
        }
try_exit:NOTHING;
    } finally {

        UNLOCK_TRANSPORT(Transport);
        BowserDereferenceTransport( Transport );


        InterlockedDecrement( &BowserPostedDatagramCount );
        FREE_POOL(Context);

    }
}



NTSTATUS
BowserHandleMailslotTransaction (
    IN PTRANSPORT_NAME TransportName,
    IN PCHAR ClientName,
    IN ULONG ClientIpAddress,
    IN ULONG SmbOffset,
    IN DWORD ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *Irp
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    TransportName - The transport name for this request.

    ClientIpAddress - IP Address of the client that sent the datagram.
        0: Not an IP transport.

    BytesAvailable  - number of bytes in complete Tsdu

    Irp - I/O request packet used to complete the request

    SmbOffset - Offset from the beginning of the indicated data to the SMB

    BytesIndicated - Number of bytes currently available in the TSDU

    BytesTaken - Returns the number of bytes of TSDU already consumed

    Tsdu - The datagram itself.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PMAILSLOT_BUFFER Buffer;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PTRANSPORT Transport = TransportName->Transport;
    ULONG BytesToReceive = BytesAvailable - SmbOffset;

    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (BytesAvailable <= TransportName->Transport->DatagramSize);

    //
    //  We must ignore all mailslot requests coming to any names domains
    //  other than the primary domain, the computer name, and the LanMan/NT
    //  domain name.
    //

    if ((TransportName->NameType != ComputerName) &&
        (TransportName->NameType != AlternateComputerName) &&
        (TransportName->NameType != DomainName) &&
        (TransportName->NameType != PrimaryDomain) &&
        (TransportName->NameType != PrimaryDomainBrowser) ) {
        return STATUS_SUCCESS;
    }

    //
    //  Now allocate a buffer to hold the data.
    //

    Buffer = BowserAllocateMailslotBuffer( TransportName, BytesToReceive );

    if (Buffer == NULL) {

        //
        //  We couldn't allocate a buffer to hold the data - ditch the request.
        //

        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    ASSERT (Buffer->BufferSize >= BytesToReceive);
    KeQuerySystemTime( &Buffer->TimeReceived );
    Buffer->ClientIpAddress = ClientIpAddress;

    //
    //  Save away the name of the client
    //  just in case the datagram turns out to be illegal.
    //

    TdiCopyLookaheadData(Buffer->ClientAddress, ClientName, max(NETBIOS_NAME_LEN, SMB_IPX_NAME_LENGTH), ReceiveFlags);

    //
    // If the entire datagram has been indicated (or already received as a short packet),
    //  just copy the data into the Mailslot buffer directly.
    //

    if ( BytesAvailable == BytesIndicated ) {

        //
        //  Copy the data into the mailslot buffer
        //

        Buffer->ReceiveLength = BytesToReceive;
        TdiCopyLookaheadData( Buffer->Buffer,
                              ((LPBYTE)(Tsdu)) + SmbOffset,
                              BytesToReceive,
                              ReceiveFlags);


        //
        // Queue the request to the worker routine.
        //
        ExInitializeWorkItem(&Buffer->Overlay.WorkHeader,
                             BowserProcessMailslotWrite,
                             Buffer);

        BowserQueueDelayedWorkItem( &Buffer->Overlay.WorkHeader );

        return STATUS_SUCCESS;
    }

    //
    //  We rely on the fact that the device object is NULL for
    //  IPX transport names.
    //

    if (TransportName->DeviceObject == NULL) {

        ASSERT (Transport->IpxSocketDeviceObject != NULL);

        ASSERT (Transport->IpxSocketFileObject != NULL);

        ASSERT (TransportName->FileObject == NULL);

        DeviceObject = Transport->IpxSocketDeviceObject;
        FileObject = Transport->IpxSocketFileObject;
    } else {
        ASSERT (Transport->IpxSocketDeviceObject == NULL);

        ASSERT (Transport->IpxSocketFileObject == NULL);

        DeviceObject = TransportName->DeviceObject;
        FileObject = TransportName->FileObject;
    }

    //
    //  Now allocate an IRP to hold the incoming mailslot.
    //

    *Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (*Irp == NULL) {
        BowserFreeMailslotBufferHighIrql(Buffer);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    (*Irp)->MdlAddress = IoAllocateMdl(Buffer->Buffer, BytesToReceive, FALSE, FALSE, NULL);

    //
    //  If we were unable to allocate the MDL, ditch the datagram.
    //

    if ((*Irp)->MdlAddress == NULL) {
        IoFreeIrp(*Irp);

        BowserFreeMailslotBufferHighIrql(Buffer);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;

    }

    MmBuildMdlForNonPagedPool((*Irp)->MdlAddress);

    //
    //  Build the receive datagram IRP.
    //

    TdiBuildReceiveDatagram((*Irp),
                            DeviceObject,
                            FileObject,
                            CompleteReceiveMailslot,
                            Buffer,
                            (*Irp)->MdlAddress,
                            BytesToReceive,
                            NULL,
                            NULL,
                            0);



    //
    //  This gets kinda wierd.
    //
    //  Since this IRP is going to be completed by the transport without
    //  ever going to IoCallDriver, we have to update the stack location
    //  to make the transports stack location the current stack location.
    //
    //  Please note that this means that any transport provider that uses
    //  IoCallDriver to re-submit it's requests at indication time will
    //  break badly because of this code....
    //

    IoSetNextIrpStackLocation(*Irp);

    //
    // Indicate we've already handled everything before the SMB
    //

    *BytesTaken = SmbOffset;

    //
    //  And return to the caller indicating we want to receive this stuff.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
CompleteReceiveMailslot (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine handles completion of a mailslot write operation.

Arguments:

    IN PDEVICE_OBJECT TransportDevice - Device object for transport.
    IN PIRP Irp - I/O request packet to complete.
    IN PVOID Context - Context for request (transport name).


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PMAILSLOT_BUFFER Buffer = Context;
    NTSTATUS Status = Irp->IoStatus.Status;

    ASSERT (MmGetSystemAddressForMdl(Irp->MdlAddress) == Buffer->Buffer);

    //
    //  Save away the number of bytes we received.
    //

    Buffer->ReceiveLength = (ULONG)Irp->IoStatus.Information;

    //
    //  Release the MDL, we're done with it.
    //

    IoFreeMdl(Irp->MdlAddress);

    //
    //  And free the IRP, we're done with it as well.
    //

    IoFreeIrp(Irp);

    if (NT_SUCCESS(Status)) {

        ExInitializeWorkItem(&Buffer->Overlay.WorkHeader,
                             BowserProcessMailslotWrite,
                             Buffer);

        BowserQueueDelayedWorkItem( &Buffer->Overlay.WorkHeader );

    } else {

        BowserStatistics.NumberOfFailedMailslotReceives += 1;
        BowserFreeMailslotBufferHighIrql(Buffer);

    }


    //
    //  Short circuit I/O completion for this request.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER(TransportDevice);

}

typedef struct _SHORT_ANNOUNCEMENT_CONTEXT {
    PVOID   EventContext;
    int     SourceAddressLength;
    PVOID   SourceAddress;
    int     OptionsLength;
    PVOID   Options;
    ULONG   ReceiveDatagramFlags;
    PVOID   Buffer;
    PTDI_IND_RECEIVE_DATAGRAM ReceiveDatagramHandler;
    CHAR    Data[1];
} SHORT_ANNOUNCEMENT_CONTEXT, *PSHORT_ANNOUNCEMENT_CONTEXT;


NTSTATUS
BowserHandleShortBrowserPacket(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID EventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesAvailable,
    IN ULONG *BytesTaken,
    IN PIRP *Irp,
    PTDI_IND_RECEIVE_DATAGRAM Handler
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages, and
    process them as appropriate.

Arguments:

    IN PTRANSPORT_NAME TransportName - The transport name for this request.
    IN ULONG BytesAvailable  - number of bytes in complete Tsdu
    OUT PIRP *BytesTaken,    - I/O request packet used to complete the request


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PTRANSPORT Transport = TransportName->Transport;
    PSHORT_ANNOUNCEMENT_CONTEXT Context;


    ASSERT (TransportName->Signature == STRUCTURE_SIGNATURE_TRANSPORTNAME);

    ASSERT (BytesAvailable <= TransportName->Transport->DatagramSize);

    //
    //  Now allocate a buffer to hold the data.
    //

    Context = ALLOCATE_POOL(NonPagedPool, sizeof(SHORT_ANNOUNCEMENT_CONTEXT) + SourceAddressLength + OptionsLength + BytesAvailable, POOL_SHORT_CONTEXT);

    if (Context == NULL) {

        //
        //  We couldn't allocate a buffer to hold the data - ditch the request.
        //

        return(STATUS_REQUEST_NOT_ACCEPTED);
    }

    //
    //  Save away the name of the client and which transport this was received
    //  on just in case the datagram turns out to be illegal.
    //


    Context->SourceAddress = ((PCHAR)Context + FIELD_OFFSET(SHORT_ANNOUNCEMENT_CONTEXT, Data));

    Context->Options = ((PCHAR)Context + FIELD_OFFSET(SHORT_ANNOUNCEMENT_CONTEXT, Data) + SourceAddressLength);

    Context->Buffer = ((PCHAR)Context + FIELD_OFFSET(SHORT_ANNOUNCEMENT_CONTEXT, Data) + SourceAddressLength + OptionsLength);

    TdiCopyLookaheadData(Context->SourceAddress, SourceAddress, SourceAddressLength, ReceiveDatagramFlags);

    Context->SourceAddressLength = SourceAddressLength;

    TdiCopyLookaheadData(Context->Options, Options, OptionsLength, ReceiveDatagramFlags);

    Context->OptionsLength = OptionsLength;

    Context->ReceiveDatagramFlags = ReceiveDatagramFlags;

    Context->EventContext = EventContext;

    Context->ReceiveDatagramHandler = Handler;

    //
    //  We rely on the fact that the device object is NULL for
    //  IPX transport names.
    //

    if (TransportName->DeviceObject == NULL) {

        ASSERT (Transport->IpxSocketDeviceObject != NULL);

        ASSERT (Transport->IpxSocketFileObject != NULL);

        ASSERT (TransportName->FileObject == NULL);

        DeviceObject = Transport->IpxSocketDeviceObject;

        FileObject = Transport->IpxSocketFileObject;
    } else {
        ASSERT (Transport->IpxSocketDeviceObject == NULL);

        ASSERT (Transport->IpxSocketFileObject == NULL);

        DeviceObject = TransportName->DeviceObject;
        FileObject = TransportName->FileObject;
    }

    //
    //  Now allocate an IRP to hold the incoming mailslot.
    //

    *Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

    if (*Irp == NULL) {
        FREE_POOL(Context);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    (*Irp)->MdlAddress = IoAllocateMdl(Context->Buffer, BytesAvailable, FALSE, FALSE, NULL);

    //
    //  If we were unable to allocate the MDL, ditch the datagram.
    //

    if ((*Irp)->MdlAddress == NULL) {
        IoFreeIrp(*Irp);

        FREE_POOL(Context);

        BowserStatistics.NumberOfFailedMailslotReceives += 1;

        return STATUS_REQUEST_NOT_ACCEPTED;

    }

    MmBuildMdlForNonPagedPool((*Irp)->MdlAddress);

    //
    //  Build the receive datagram IRP.
    //

    TdiBuildReceiveDatagram((*Irp),
                            DeviceObject,
                            FileObject,
                            CompleteShortBrowserPacket,
                            Context,
                            (*Irp)->MdlAddress,
                            BytesAvailable,
                            NULL,
                            NULL,
                            0);



    //
    //  This gets kinda wierd.
    //
    //  Since this IRP is going to be completed by the transport without
    //  ever going to IoCallDriver, we have to update the stack location
    //  to make the transports stack location the current stack location.
    //
    //  Please note that this means that any transport provider that uses
    //  IoCallDriver to re-submit it's requests at indication time will
    //  break badly because of this code....
    //

    IoSetNextIrpStackLocation(*Irp);

    *BytesTaken = 0;

    //
    //  And return to the caller indicating we want to receive this stuff.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
CompleteShortBrowserPacket (
    IN PDEVICE_OBJECT TransportDevice,
    IN PIRP Irp,
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine handles completion of a mailslot write operation.

Arguments:

    IN PDEVICE_OBJECT TransportDevice - Device object for transport.
    IN PIRP Irp - I/O request packet to complete.
    IN PVOID Context - Context for request (transport name).


Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PSHORT_ANNOUNCEMENT_CONTEXT Context = Ctx;
    NTSTATUS Status = Irp->IoStatus.Status;
    ULONG ReceiveLength;
    ULONG BytesTaken;
    //
    //  Save away the number of bytes we received.
    //

    ReceiveLength = (ULONG)Irp->IoStatus.Information;

    //
    //  Release the MDL, we're done with it.
    //

    IoFreeMdl(Irp->MdlAddress);

    //
    //  And free the IRP, we're done with it as well.
    //

    IoFreeIrp(Irp);

    if (NT_SUCCESS(Status)) {

        Status = Context->ReceiveDatagramHandler(Context->EventContext,
                                        Context->SourceAddressLength,
                                        Context->SourceAddress,
                                        Context->OptionsLength,
                                        Context->Options,
                                        Context->ReceiveDatagramFlags,
                                        ReceiveLength,
                                        ReceiveLength,
                                        &BytesTaken,
                                        Context->Buffer,
                                        &Irp);
        ASSERT (Status != STATUS_MORE_PROCESSING_REQUIRED);

    }

    FREE_POOL(Context);

    //
    //  Short circuit I/O completion for this request.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER(TransportDevice);

}


DATAGRAM_HANDLER(
    HandleAnnounceRequest
    )
/*++

Routine Description:

    This routine will process receive datagram indication messages for announce
    requests.


Arguments:

    None.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
	//
	// checking for NULL - inserted because it was hit in stress - bug 633273
	// although a complete validation of parameters upfront would be good,
	// we are not doing it now since browser is in maintainance mode.
	//
	if ( (TransportName == NULL) || (TransportName->Transport == NULL ) ) {
		return STATUS_INVALID_PARAMETER;
	}

    //
    //  If we're running an election, ignore announce requests.
    //

    if (TransportName->Transport->ElectionState != RunningElection) {

        if ((TransportName->NameType == BrowserElection) ||
            (TransportName->NameType == MasterBrowser) ||
            (TransportName->NameType == PrimaryDomain)) {

            //
            //  This one's easy - simply set the servers announcement event to the
            //  signalled state.  If the server is running, this will force an
            //  announcement
            //

            KeSetEvent(BowserServerAnnouncementEvent, IO_NETWORK_INCREMENT, FALSE);
        } else if (TransportName->NameType == DomainAnnouncement) {
            //
            //  Old comment: NEED TO HANDLE REQUEST ANNOUNCEMENT OF DOMAIN REQUEST.
            //  PhaseOut: we did so wonderfully so far. we won't be handling anything else
            //  due to browser phase out.
            //  Announcement requests are handled by the srvsvc. It determines what to announce
            //  based on the server state.
            //
        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
BowserPostDatagramToWorkerThread(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Datagram,
    IN ULONG Length,
    OUT PULONG BytesTaken,
    IN PVOID OriginatorsAddress,
    IN ULONG OriginatorsAddressLength,
    IN PVOID OriginatorsName,
    IN ULONG OriginatorsNameLength,
    IN PWORKER_THREAD_ROUTINE Handler,
    IN POOL_TYPE PoolType,
    IN WORK_QUEUE_TYPE QueueType,
    IN ULONG ReceiveFlags,
    IN BOOLEAN PostToRdrWorkerThread
    )
/*++

Routine Description:

    Queue a datagram to a worker thread.

    This routine increment the reference count on the Transport and TransportName.
    The Handler routine is expected to dereference them.

Arguments:

    Many.

Return Value:

    NTSTATUS - Status of operation.

--*/
{
    PPOST_DATAGRAM_CONTEXT Context;
    PTA_NETBIOS_ADDRESS NetbiosAddress = OriginatorsAddress;

    ASSERT (NetbiosAddress->TAAddressCount == 1);

    ASSERT ((NetbiosAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_NETBIOS) ||
            (NetbiosAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IPX));

    Context = ALLOCATE_POOL(PoolType, sizeof(POST_DATAGRAM_CONTEXT) + Length + OriginatorsAddressLength, POOL_POSTDG_CONTEXT);

    if (Context == NULL) {
        return STATUS_REQUEST_NOT_ACCEPTED;
    }

    Context->TransportName = TransportName;

    Context->Buffer = ((PCHAR)(Context+1))+OriginatorsAddressLength;

    Context->BytesAvailable = Length;

    TdiCopyLookaheadData(Context->Buffer, Datagram, Length, ReceiveFlags);

    Context->ClientAddressLength = OriginatorsAddressLength;

    TdiCopyLookaheadData(Context->TdiClientAddress, OriginatorsAddress, OriginatorsAddressLength, ReceiveFlags);

    //
    //  Copy over the client name into the buffer.
    //

    Context->ClientNameLength = NETBIOS_NAME_LEN;

    BowserCopyOemComputerName(Context->ClientName,
                              OriginatorsName,
                              OriginatorsNameLength,
                              ReceiveFlags);

    *BytesTaken = Length;

    ExInitializeWorkItem(&Context->WorkItem, Handler, Context);

    if ( QueueType == CriticalWorkQueue ) {

        //
        // Ensure we've not consumed too much memory
        //

        InterlockedIncrement( &BowserPostedCriticalDatagramCount );

        if ( BowserPostedCriticalDatagramCount > BOWSER_MAX_POSTED_DATAGRAMS ) {
            InterlockedDecrement( &BowserPostedCriticalDatagramCount );
            FREE_POOL( Context );
            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        // Reference the Transport and TransportName to ensure they aren't deleted.   The
        // Handler routine is expected to dereference them.
        //
        BowserReferenceTransportName(TransportName);
        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserPostDatagramToWorkerThread %lx.\n", TransportName->Transport, Handler ));
        BowserReferenceTransport( TransportName->Transport );

        //
        // Queue the workitem.
        //
        BowserQueueCriticalWorkItem( &Context->WorkItem );
    } else {

        //
        // Ensure we've not consumed too much memory
        //

        InterlockedIncrement( &BowserPostedDatagramCount );

        if ( BowserPostedDatagramCount > BOWSER_MAX_POSTED_DATAGRAMS ) {
            InterlockedDecrement( &BowserPostedDatagramCount );
            FREE_POOL( Context );
            return STATUS_REQUEST_NOT_ACCEPTED;
        }

        //
        // Reference the Transport and TransportName to ensure they aren't deleted.   The
        // Handler routine is expected to dereference them.
        //
        BowserReferenceTransportName(TransportName);
        dprintf(DPRT_REF, ("Call Reference transport %lx from BowserPostDatagramToWorkerThread %lx (2).\n", TransportName->Transport, Handler ));
        BowserReferenceTransport( TransportName->Transport );

        //
        // Queue the workitem.
        //
        BowserQueueDelayedWorkItem( &Context->WorkItem );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\mailslot.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    This module implements the routines needed to process incoming mailslot
    requests.



Author:

    Larry Osterman (larryo) 18-Oct-1991

Revision History:

    18-Oct-1991  larryo

        Created

--*/
#ifndef _MAILSLOT_
#define _MAILSLOT_

//
//  The MAILSLOTBUFFER structure is a structure that is prepended to a mailslot
//  message to facilitate the transfer of the data between the FSD and the FSP.
//

typedef struct _MAILSLOT_BUFFER {
    CSHORT  Signature;
    CSHORT  Size;
    union {
        LIST_ENTRY  NextBuffer;                 // Pointer to next buffer.
        WORK_QUEUE_ITEM WorkHeader;             // Executive Worker item header.
    } Overlay;
    ULONG   BufferSize;

    LARGE_INTEGER TimeReceived;                 // Time message was received

    ULONG ClientIpAddress;                      // IP Address of client sending datagram

    PTRANSPORT_NAME TransportName;              // Transport address receiving DG

    CHAR ClientAddress[max(NETBIOS_NAME_LEN, SMB_IPX_NAME_LENGTH)]; // Name of client initiating receive.

    ULONG ReceiveLength;                        // # of bytes received.

    CHAR Buffer[1];                             // Buffer
} MAILSLOT_BUFFER, *PMAILSLOT_BUFFER;

extern ULONG BowserNetlogonMaxMessageCount;

//
// Two services get their PNP messages through the bowser.
//

#define BROWSER_PNP         0
#define NETLOGON_PNP        1
#define BOWSER_PNP_COUNT    2


NTSTATUS
BowserEnablePnp (
    IN PLMDR_REQUEST_PACKET InputBuffer,
    IN ULONG ServiceIndex
    );

NTSTATUS
BowserReadPnp (
    IN PIRP Irp,
    IN ULONG OutputBufferLength,
    IN ULONG ServiceIndex
    );

VOID
BowserSendPnp(
    IN NETLOGON_PNP_OPCODE NlPnpOpcode,
    IN PUNICODE_STRING HostedDomainName OPTIONAL,
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags
    );

VOID
BowserNetlogonDeleteTransportFromMessageQueue (
    PTRANSPORT Transport
    );

VOID
BowserProcessMailslotWrite (
    IN PVOID WorkHeader
    );

PMAILSLOT_BUFFER
BowserAllocateMailslotBuffer(
    IN PTRANSPORT_NAME TransportName,
    IN ULONG BufferSize
    );

VOID
BowserFreeMailslotBuffer(
    IN PMAILSLOT_BUFFER Buffer
    );

VOID
BowserFreeMailslotBufferHighIrql(
    IN PMAILSLOT_BUFFER Buffer
    );

VOID
BowserpInitializeMailslot (
    VOID
    );


VOID
BowserpUninitializeMailslot (
    VOID
    );

#endif          // _MAILSLOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\workque.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    workque.c

Abstract:

    This module handles the communication between the NT redirector
    FSP and the NT redirector FSD.

    It defines routines that queue requests to the FSD, and routines
    that remove requests from the FSD work queue.


Author:

    Larry Osterman (LarryO) 30-May-1990

Revision History:

    30-May-1990 LarryO

        Created

--*/

#include "precomp.h"
#pragma hdrstop

VOID
BowserCriticalThreadWorker(
    IN PVOID Ctx
    );

VOID
BowserDelayedThreadWorker(
    IN PVOID Ctx
    );

KSPIN_LOCK
BowserIrpContextInterlock = {0};

LIST_ENTRY
BowserIrpContextList = {0};

KSPIN_LOCK
BowserIrpQueueSpinLock = {0};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BowserAllocateIrpContext)
#pragma alloc_text(PAGE, BowserFreeIrpContext)
#pragma alloc_text(PAGE, BowserInitializeIrpContext)
#pragma alloc_text(PAGE, BowserpUninitializeIrpContext)
#pragma alloc_text(PAGE, BowserInitializeIrpQueue)
#pragma alloc_text(PAGE, BowserQueueNonBufferRequest)
#pragma alloc_text(INIT, BowserpInitializeIrpQueue)
#pragma alloc_text(PAGE4BROW, BowserUninitializeIrpQueue)
#pragma alloc_text(PAGE4BROW, BowserQueueNonBufferRequestReferenced)
#pragma alloc_text(PAGE4BROW, BowserCancelQueuedIoForFile)
#pragma alloc_text(PAGE4BROW, BowserTimeoutQueuedIrp)
#endif

//
// Variables describing browsers use of a Critical system thread.
//

BOOLEAN BowserCriticalThreadRunning = FALSE;

LIST_ENTRY BowserCriticalThreadQueue;

WORK_QUEUE_ITEM BowserCriticalThreadWorkItem;



VOID
BowserQueueCriticalWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This routine queues an item onto the critical work queue.

    This routine ensures that at most one critical system thread is consumed
    by the browser by actually queing this item onto a browser specific queue
    then enqueing a critical work queue item that processes that queue.

Arguments:

    WorkItem -- Work item to be processed on the critical work queue.

Return Value:

    NONE

--*/


{
    KIRQL OldIrql;

    //
    // Insert the queue entry into the browser specific queue.
    //
    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
    InsertTailList( &BowserCriticalThreadQueue, &WorkItem->List );

    //
    // If the browser doesn't have a critical system thread running,
    //  start one now.
    //

    if ( !BowserCriticalThreadRunning ) {

        //
        // Mark that the thread is running now
        //
        BowserCriticalThreadRunning = TRUE;
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        ExInitializeWorkItem( &BowserCriticalThreadWorkItem,
                              BowserCriticalThreadWorker,
                              NULL );

        ExQueueWorkItem(&BowserCriticalThreadWorkItem, CriticalWorkQueue );

    } else {
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
    }

}

VOID
BowserCriticalThreadWorker(
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine processes critical browser workitems.

    This routine runs in a critical system thread.  It is the only critical
    system thread used by the browser.

Arguments:

    Ctx - Not used

Return Value:

    NONE

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PWORK_QUEUE_ITEM WorkItem;

    UNREFERENCED_PARAMETER( Ctx );

    //
    // Loop processing work items
    //

    while( TRUE ) {

        //
        // If the queue is empty,
        //  indicate that this thread is no longer running.
        //  return.
        //

        ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

        if ( IsListEmpty( &BowserCriticalThreadQueue ) ) {
            BowserCriticalThreadRunning = FALSE;
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            return;
        }

        //
        // Remove an entry from the queue.
        //

        Entry = RemoveHeadList( &BowserCriticalThreadQueue );
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Call the queued routine
        //

        (*WorkItem->WorkerRoutine)(WorkItem->Parameter);

    }
}



//
// Variables describing browsers use of a Delayed system thread.
//

BOOLEAN BowserDelayedThreadRunning = FALSE;

LIST_ENTRY BowserDelayedThreadQueue;

WORK_QUEUE_ITEM BowserDelayedThreadWorkItem;



VOID
BowserQueueDelayedWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This routine queues an item onto the Delayed work queue.

    This routine ensures that at most one Delayed system thread is consumed
    by the browser by actually queing this item onto a browser specific queue
    then enqueing a Delayed work queue item that processes that queue.

Arguments:

    WorkItem -- Work item to be processed on the Delayed work queue.

Return Value:

    NONE

--*/


{
    KIRQL OldIrql;

    //
    // Insert the queue entry into the browser specific queue.
    //
    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
    InsertTailList( &BowserDelayedThreadQueue, &WorkItem->List );

    //
    // If the browser doesn't have a Delayed system thread running,
    //  start one now.
    //

    if ( !BowserDelayedThreadRunning ) {

        //
        // Mark that the thread is running now
        //
        BowserDelayedThreadRunning = TRUE;
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        ExInitializeWorkItem( &BowserDelayedThreadWorkItem,
                              BowserDelayedThreadWorker,
                              NULL );

        ExQueueWorkItem(&BowserDelayedThreadWorkItem, DelayedWorkQueue );

    } else {
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
    }

}

VOID
BowserDelayedThreadWorker(
    IN PVOID Ctx
    )
/*++

Routine Description:

    This routine processes Delayed browser workitems.

    This routine runs in a Delayed system thread.  It is the only Delayed
    system thread used by the browser.

Arguments:

    Ctx - Not used

Return Value:

    NONE

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    PWORK_QUEUE_ITEM WorkItem;

    UNREFERENCED_PARAMETER( Ctx );

    //
    // Loop processing work items
    //

    while( TRUE ) {

        //
        // If the queue is empty,
        //  indicate that this thread is no longer running.
        //  return.
        //

        ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

        if ( IsListEmpty( &BowserDelayedThreadQueue ) ) {
            BowserDelayedThreadRunning = FALSE;
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            return;
        }

        //
        // Remove an entry from the queue.
        //

        Entry = RemoveHeadList( &BowserDelayedThreadQueue );
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Call the queued routine
        //

        (*WorkItem->WorkerRoutine)(WorkItem->Parameter);

    }
}



PIRP_CONTEXT
BowserAllocateIrpContext (
    VOID
    )
/*++

Routine Description:

    Initialize a work queue structure, allocating all structures used for it.

Arguments:

    None


Return Value:

    PIRP_CONTEXT - Newly allocated Irp Context.

--*/
{
    PIRP_CONTEXT IrpContext;
    PAGED_CODE();

    if ((IrpContext = (PIRP_CONTEXT )ExInterlockedRemoveHeadList(&BowserIrpContextList, &BowserIrpContextInterlock)) == NULL) {

        //
        //  If there are no IRP contexts in the "zone",  allocate a new
        //  Irp context from non paged pool.
        //

        IrpContext = ALLOCATE_POOL(NonPagedPool, sizeof(IRP_CONTEXT), POOL_IRPCONTEXT);

        if (IrpContext == NULL) {
            InternalError(("Could not allocate pool for IRP context\n"));
        }

        return IrpContext;
    }

    return IrpContext;
}

VOID
BowserFreeIrpContext (
    PIRP_CONTEXT IrpContext
    )
/*++

Routine Description:

    Initialize a work queue structure, allocating all structures used for it.

Arguments:

    PIRP_CONTEXT IrpContext - Irp Context to free.
    None


Return Value:


--*/
{
    PAGED_CODE();

    //
    //  We use the first two longwords of the IRP context as a list entry
    //  when we free it to the zone.
    //

    ExInterlockedInsertTailList(&BowserIrpContextList, (PLIST_ENTRY )IrpContext,
                                                        &BowserIrpContextInterlock);
}


VOID
BowserInitializeIrpContext (
    VOID
    )
/*++

Routine Description:

    Initialize the Irp Context system

Arguments:

    None.


Return Value:
    None.

--*/
{
    PAGED_CODE();

    KeInitializeSpinLock(&BowserIrpContextInterlock);
    InitializeListHead(&BowserIrpContextList);
}

VOID
BowserpUninitializeIrpContext(
    VOID
    )
{
    PAGED_CODE();

    while (!IsListEmpty(&BowserIrpContextList)) {
        PIRP_CONTEXT IrpContext = (PIRP_CONTEXT)RemoveHeadList(&BowserIrpContextList);

        FREE_POOL(IrpContext);
    }
}


VOID
BowserInitializeIrpQueue(
    PIRP_QUEUE Queue
    )
{
    PAGED_CODE();

    InitializeListHead(&Queue->Queue);

}

VOID
BowserUninitializeIrpQueue(
    PIRP_QUEUE Queue
    )
{
    KIRQL               OldIrql, CancelIrql;
    PDRIVER_CANCEL      pDriverCancel;
    PLIST_ENTRY         Entry;
    PIRP                Request;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    //
    //  Now remove this IRP from the request chain.
    //

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    while (!IsListEmpty(&Queue->Queue)) {

        Entry = RemoveHeadList(&Queue->Queue);

        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        // clear cancel routine
        Request->IoStatus.Information = 0;
        Request->Cancel = FALSE;
        pDriverCancel = IoSetCancelRoutine(Request, NULL);

        // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
        if ( pDriverCancel ) {
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            BowserCompleteRequest(Request, STATUS_CANCELLED);
            ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
        }
        // otherwise the cancel routine is running at the moment.
    }

    ASSERT (IsListEmpty(&Queue->Queue));

    //
    //  Make sure no more entries are inserted on this queue.
    //

    Queue->Queue.Flink = NULL;
    Queue->Queue.Blink = NULL;

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

}

VOID
BowserCancelQueuedRequest(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    )
/*++

Routine Description:
    This routine will cancel a queued IRP.

Arguments:
    IN PIRP Irp - Supplies the IRP to cancel.

    IN PKSPIN_LOCK SpinLock - Supplies a pointer to the spin lock protecting the
                    queue

    IN PLIST_ENTRY Queue - Supplies a pointer to the head of the queue.

Note: See bug history for more: 294055, 306281, 124178, 124180, 131773...
--*/

{
    KIRQL OldIrql;
    KIRQL CancelIrql;
    PLIST_ENTRY Entry, NextEntry;
    PIRP Request;
    PIRP_QUEUE Queue;
    PIO_STACK_LOCATION NextStack = IoGetNextIrpStackLocation(Irp);
    LIST_ENTRY         CancelList;

    ASSERT ( Irp->CancelRoutine == NULL );

    InitializeListHead(&CancelList);

    //
    // Release IOmgr set cancel IRP spinlock & acquire the local
    // queue protection spinlock.  Then reaquire the cancel spinlock.
    // This is the proper lock order.
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );
    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);
    IoAcquireCancelSpinLock( &CancelIrql );

    //
    //  Now remove this IRP from the request chain.
    //


    //
    //  A pointer to the queue is stored in the next stack location.
    //

    Queue = (PIRP_QUEUE)NextStack->Parameters.Others.Argument4;

    if (Queue != NULL && Queue->Queue.Flink != NULL) {

        for (Entry = Queue->Queue.Flink ;
             Entry != &Queue->Queue ;
             Entry = NextEntry) {

            Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

            if (Request->Cancel) {
                // we're in a cancel routine so the global cancel spinlock is locked

                NextEntry = Entry->Flink;
                RemoveEntryList(Entry);

                Request->IoStatus.Information = 0;
                Request->IoStatus.Status = STATUS_CANCELLED;
                IoSetCancelRoutine(Request, NULL);

                InsertTailList(&CancelList,Entry);

            } else {
                NextEntry = Entry->Flink;
            }

        }
    }


    IoReleaseCancelSpinLock( CancelIrql );
    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    while (!IsListEmpty(&CancelList)) {
        Entry = RemoveHeadList(&CancelList);
        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        BowserCompleteRequest(Request, Request->IoStatus.Status);
    }

    UNREFERENCED_PARAMETER(DeviceObject);

}

NTSTATUS
BowserQueueNonBufferRequest(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    )
/*++

Routine Description:

    Queue an IRP in the specified queue.

    This routine cannot be called at an IRQ level above APC_LEVEL.

Arguments:

    Irp - Supplies the IRP to queue.

    Queue - Supplies a pointer to the head of the queue.

    CancelRoutine - Address of routine to call if the IRP is cancelled.
--*/

{
    NTSTATUS Status;

    //
    // This routine itself is paged code which calls the discardable code
    // in BowserQueueNonBufferRequestReferenced().
    //
    PAGED_CODE();

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );
    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    Status = BowserQueueNonBufferRequestReferenced( Irp,
                                                    Queue,
                                                    CancelRoutine );

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

    return Status;
}

NTSTATUS
BowserQueueNonBufferRequestReferenced(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    )
/*++

Routine Description:

    Queue an IRP in the specified queue.

    This routine can only be called if the BowserDiscardableCodeSection
    is already referenced.  It can be called at any IRQ level.

Arguments:

    Irp - Supplies the IRP to queue.

    Queue - Supplies a pointer to the head of the queue.

    CancelRoutine - Address of routine to call if the IRP is cancelled.
--*/

{
    KIRQL OldIrql, CancelIrql;
    LARGE_INTEGER CurrentTickCount;
    PIO_STACK_LOCATION NextStackLocation;
    BOOL bReleaseSpinlocks;

    DISCARDABLE_CODE( BowserDiscardableCodeSection );


//    DbgPrint("Queue IRP %lx to queue %lx\n", Irp, Queue);

    //
    //  Insert the request into the request announcement list.
    //

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    if (Queue->Queue.Flink == NULL) {

        ASSERT (Queue->Queue.Blink == NULL);
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

        return(STATUS_CANCELLED);
    }

    //
    //  Flag that this request is going to be pending.
    //

    IoMarkIrpPending(Irp);

    InsertTailList(&Queue->Queue, &Irp->Tail.Overlay.ListEntry);

    //
    //  Make sure there's room enough in the stack location for this.
    //

    ASSERT (Irp->CurrentLocation <= Irp->StackCount);

    NextStackLocation = IoGetNextIrpStackLocation(Irp);

    //
    //  Stick the current tick count into the next IRP stack location
    //  for this IRP.  This allows us to figure out if these IRP's have been
    //  around for "too long".
    //
    // Beware:the IRP stack location is unaligned.
    //

    KeQueryTickCount( &CurrentTickCount );
    *((LARGE_INTEGER UNALIGNED *)&NextStackLocation->Parameters.Others.Argument1) =
        CurrentTickCount;


    //
    //  Link the queue into the IRP.
    //

    NextStackLocation->Parameters.Others.Argument4 = (PVOID)Queue;

    // WARNING: double spinlock condition
    IoAcquireCancelSpinLock(&CancelIrql);
    bReleaseSpinlocks = TRUE;

    if (Irp->Cancel) {

        //
        // The Irp is in cancellable state:
        // if CancelRoutine == NULL, the routine is currently running
        // Otherwise, we need to cancel it ourselves
        //
        if ( Irp->CancelRoutine ) {
            // cacelable:
            //   - rm is valid since we're still holding BowserIrpQueueSpinLock
            RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

            // release spinlocks before completing the request
            IoReleaseCancelSpinLock(CancelIrql);
            RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
            bReleaseSpinlocks = FALSE;

            // complete.
            BowserCompleteRequest ( Irp, STATUS_CANCELLED );
        }
        // else CancelRoutine is running
    } else {

        IoSetCancelRoutine(Irp, CancelRoutine);
    }

    if ( bReleaseSpinlocks ) {
        // release spinlocks
        IoReleaseCancelSpinLock(CancelIrql);
        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);
    }

    return STATUS_PENDING;

}

VOID
BowserTimeoutQueuedIrp(
    IN PIRP_QUEUE Queue,
    IN ULONG NumberOfSecondsToTimeOut
    )
/*++

Routine Description:
    This routine will scan an IRP queue and time out any requests that have
    been on the queue for "too long"

Arguments:
    IN PIRP_QUEUE Queue - Supplies the Queue to scan.
    IN ULONG NumberOfSecondsToTimeOut - Supplies the number of seconds a request
                                            should remain on the queue.

Return Value:
    None

    This routine will also complete any canceled queued requests it finds (on
    general principles).

--*/

{
    PIRP Irp;
    KIRQL OldIrql, CancelIrql;
    PDRIVER_CANCEL pDriverCancel;
    PLIST_ENTRY Entry, NextEntry;
    LARGE_INTEGER Timeout;
    LIST_ENTRY    CancelList;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    InitializeListHead(&CancelList);

    //
    //  Compute the timeout time into 100ns units.
    //

    Timeout.QuadPart = (LONGLONG)NumberOfSecondsToTimeOut * (LONGLONG)(10000*1000);

    //
    //  Now convert the timeout into a number of ticks.
    //

    Timeout.QuadPart = Timeout.QuadPart / (LONGLONG)KeQueryTimeIncrement();

    ASSERT (Timeout.HighPart == 0);

//    DbgPrint("Dequeue irp from queue %lx...", Queue);

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);


    for (Entry = Queue->Queue.Flink ;
         Entry != &Queue->Queue ;
         Entry = NextEntry) {

        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        //
        //  If the request was canceled, this is a convenient time to cancel
        //  it.
        //

        if (Irp->Cancel) {

            NextEntry = Entry->Flink;

            pDriverCancel = IoSetCancelRoutine(Irp, NULL);

            // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
            if ( pDriverCancel ) {

                Irp->IoStatus.Information = 0;
                Irp->IoStatus.Status      = STATUS_CANCELLED;

                RemoveEntryList(Entry);

                InsertTailList(&CancelList,Entry);
            }
            // otherwise the cancel routine is running at the moment.



        //
        //  Now check to see if this request is "too old".  If it is, complete
        //  it with an error.
        //

        } else {
            PIO_STACK_LOCATION NextIrpStackLocation;
            LARGE_INTEGER CurrentTickCount;
            LARGE_INTEGER RequestTime;
            LARGE_INTEGER Temp;

            NextIrpStackLocation = IoGetNextIrpStackLocation(Irp);

            //
            //  Snapshot the current tickcount.
            //

            KeQueryTickCount(&CurrentTickCount);

            //
            //  Figure out how many seconds this request has been active for
            //

            Temp.LowPart = (*((LARGE_INTEGER UNALIGNED *)&NextIrpStackLocation->Parameters.Others.Argument1)).LowPart;
            Temp.HighPart= (*((LARGE_INTEGER UNALIGNED *)&NextIrpStackLocation->Parameters.Others.Argument1)).HighPart;
            RequestTime.QuadPart = CurrentTickCount.QuadPart - Temp.QuadPart;

            ASSERT (RequestTime.HighPart == 0);

            //
            //  If this request has lasted "too long", then time it
            //  out.
            //

            if (RequestTime.LowPart > Timeout.LowPart) {


                NextEntry = Entry->Flink;

                pDriverCancel = IoSetCancelRoutine(Irp, NULL);

                // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
                if ( pDriverCancel ) {

                    Irp->IoStatus.Information = 0;
                    Irp->IoStatus.Status      = STATUS_IO_TIMEOUT;

                    RemoveEntryList(Entry);

                    InsertTailList(&CancelList,Entry);
                }
                // otherwise it the cancel routine is running


            } else {
                NextEntry = Entry->Flink;
            }
        }

    }

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    while (!IsListEmpty(&CancelList)) {
        Entry = RemoveHeadList(&CancelList);
        Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        BowserCompleteRequest(Irp, Irp->IoStatus.Status);
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );

//    DbgPrint("%lx.\n", Irp);


}

PIRP
BowserDequeueQueuedIrp(
    IN PIRP_QUEUE Queue
    )
{
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY IrpEntry;

//    DbgPrint("Dequeue irp from queue %lx...", Queue);

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    if (IsListEmpty(&Queue->Queue)) {
        //
        //  There are no waiting request announcement FsControls, so
        //  return success.
        //

        RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

//        DbgPrint("No entry found.\n");
        return NULL;
    }

    IrpEntry = RemoveHeadList(&Queue->Queue);

    Irp = CONTAINING_RECORD(IrpEntry, IRP, Tail.Overlay.ListEntry);

    IoAcquireCancelSpinLock(&Irp->CancelIrql);

    //
    //  Remove the cancel request for this IRP.
    //

    Irp->Cancel = FALSE;

    IoSetCancelRoutine(Irp, NULL);

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

//    DbgPrint("%lx.\n", Irp);
    return Irp;
}


VOID
BowserCancelQueuedIoForFile(
    IN PIRP_QUEUE Queue,
    IN PFILE_OBJECT FileObject
    )
{
    KIRQL OldIrql;
    PLIST_ENTRY Entry, NextEntry;
    PDRIVER_CANCEL pDriverCancel;
    PIRP Request;
    LIST_ENTRY CancelList;

    BowserReferenceDiscardableCode( BowserDiscardableCodeSection );

    DISCARDABLE_CODE( BowserDiscardableCodeSection );

    InitializeListHead(&CancelList);

    //
    //  Walk the outstanding IRP list for this
    //

    ACQUIRE_SPIN_LOCK(&BowserIrpQueueSpinLock, &OldIrql);

    for (Entry = Queue->Queue.Flink ;
         Entry != &Queue->Queue ;
         Entry = NextEntry) {

        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);

        //
        //  If the request was canceled, blow it away.
        //

        if (Request->Cancel) {

            NextEntry = Entry->Flink;

            // This is the cancel routine setting of cancel routine ptr to NULL.
            pDriverCancel = IoSetCancelRoutine(Request, NULL);

            // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
            if ( pDriverCancel ) {

                RemoveEntryList(Entry);
                Request->IoStatus.Information = 0;
                Request->IoStatus.Status      = STATUS_CANCELLED;

                InsertTailList(&CancelList,Entry);
            }
            // otherwise the cancel routine is running currently.

        //
        //  If the request was for this file object, blow it away.
        //

        } else if (Request->Tail.Overlay.OriginalFileObject == FileObject) {

            NextEntry = Entry->Flink;

            // This is the cancel routine setting of cancel routine ptr to NULL.
            pDriverCancel = IoSetCancelRoutine(Request, NULL);

            // Set to NULL in the cancel routine under BowserIrpQueueSpinLock protection.
            if ( pDriverCancel ) {

                RemoveEntryList(Entry);

                Request->IoStatus.Information = 0;
                Request->IoStatus.Status      = STATUS_FILE_CLOSED;

                InsertTailList(&CancelList,Entry);
            }
            // otherwise the cancel routine is running currently.

        } else {
            NextEntry = Entry->Flink;
        }

    }

    RELEASE_SPIN_LOCK(&BowserIrpQueueSpinLock, OldIrql);

    while (!IsListEmpty(&CancelList)) {
        Entry = RemoveHeadList(&CancelList);
        Request = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        BowserCompleteRequest(Request, Request->IoStatus.Status);
    }

    BowserDereferenceDiscardableCode( BowserDiscardableCodeSection );
}


VOID
BowserpInitializeIrpQueue(
    VOID
    )
{
    KeInitializeSpinLock(&BowserIrpQueueSpinLock);
    InitializeListHead( &BowserCriticalThreadQueue );
    InitializeListHead( &BowserDelayedThreadQueue );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\receive.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    receive.h

Abstract:

    This module describes the public routines in receive.c


Author:

    Larry Osterman (larryo) 6-May-1991

Revision History:

    6-May-1991  larryo

    Created

--*/

#ifndef _RECEIVE_
#define _RECEIVE_

#define DATAGRAM_HANDLER(RoutineName)           \
NTSTATUS                                        \
RoutineName (                                   \
    IN struct _TRANSPORT_NAME *TransportName,   \
    IN PVOID Buffer,                            \
    IN ULONG BytesAvailable,                    \
    IN OUT PULONG BytesTaken,                   \
    IN PVOID SourceAddress,                     \
    IN ULONG SourceAddressLength,               \
    IN PVOID SourceName,                        \
    IN ULONG SourceNameLength,                  \
    IN ULONG ReceiveFlags                       \
    )                                           \

typedef
(*PDATAGRAM_HANDLER)(
    IN struct _TRANSPORT_NAME *TransportName,
    IN PVOID Buffer,
    IN ULONG BytesAvailable,
    IN OUT PULONG BytesTaken,
    IN PVOID SourceAddress,
    IN ULONG SourceAddressLength,
    IN PVOID SourceName,
    IN ULONG SourceNameLength,
    IN ULONG ReceiveFlags
    );

LONG BowserPostedDatagramCount;
LONG BowserPostedCriticalDatagramCount;

typedef struct _POST_DATAGRAM_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PTRANSPORT_NAME TransportName;
    PVOID           Buffer;
    ULONG           BytesAvailable;
    int             ClientNameLength;
    CHAR            ClientName[NETBIOS_NAME_LEN];
    int             ClientAddressLength;
    CHAR            TdiClientAddress[1];
} POST_DATAGRAM_CONTEXT, *PPOST_DATAGRAM_CONTEXT;

NTSTATUS
BowserTdiReceiveDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

VOID
BowserCancelAnnounceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
BowserCopyOemComputerName(
    PCHAR OutputComputerName,
    PCHAR NetbiosName,
    ULONG NetbiosNameLength,
    IN ULONG ReceiveFlags
    );

VOID
BowserLogIllegalDatagram(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID IncomingBuffer,
    IN USHORT BufferSize,
    IN PCHAR ClientAddress,
    IN ULONG ReceiveFlags
    );

NTSTATUS
BowserPostDatagramToWorkerThread(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID Datagram,
    IN ULONG Length,
    OUT PULONG BytesTaken,
    IN PVOID OriginatorsAddress,
    IN ULONG OriginatorsAddressLength,
    IN PVOID OriginatorsName,
    IN ULONG OriginatorsNameLength,
    IN PWORKER_THREAD_ROUTINE Handler,
    IN POOL_TYPE PoolType,
    IN WORK_QUEUE_TYPE QueueType,
    IN ULONG ReceiveFlags,
    IN BOOLEAN PostToRdrWorkerThread
    );

MAILSLOTTYPE
BowserClassifyIncomingDatagram(
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PVOID *DatagramData,
    OUT PULONG DatagramDataSize
    );

extern
PDATAGRAM_HANDLER
BowserDatagramHandlerTable[];

NTSTATUS
BowserHandleMailslotTransaction (
    IN PTRANSPORT_NAME TransportName,
    IN PCHAR ClientName,
    IN ULONG ClientIpAddress,
    IN ULONG SmbOffset,
    IN DWORD ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *Irp
    );

NTSTATUS
BowserHandleShortBrowserPacket(
    IN PTRANSPORT_NAME TransportName,
    IN PVOID EventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesAvailable,
    IN ULONG *BytesTaken,
    IN PIRP *Irp,
    PTDI_IND_RECEIVE_DATAGRAM Handler
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\assert.h ===
#ifndef __ASSERT_H__
#define __ASSERT_H__
/* Routines for debugging and error messages. */


#ifdef DEBUG
#define VERIFY(f) {if(!(f)) AssertFn(szError, szFileAssert,__LINE__);}
#else
#define VERIFY(f)
#endif

#ifdef VxD

#define AssertFn  IFSMgr_AssertFailed
#define PrintFn   IFSMgr_Printf

#else

#define AssertFn  AssertFn
#define PrintFn   PrintFn

#endif

#ifdef DEBUG

#define AssertData static char szFileAssert[] = __FILE__;
#define AssertError static char szError[] = "Error";
#define Assert(f)  do {if (!(f)) AssertFn(szError, szFileAssert, __LINE__);} while(0)
#define AssertSz(f, sz)  do {if (!(f)) AssertFn(sz, szFileAssert, __LINE__);} while(0)
#define DEBUG_PRINT(_x_)  PrintFn _x_
#else

#define Assert(f)
#define AssertData
#define AssertError
#define AssertSz(f, sz)
#define DEBUG_PRINT(_X_)

#endif


#ifdef VxD
void IFSMgr_AssertFailed(PSZ pMsg, PSZ pFile, unsigned long uLine);
void IFSMgr_Printf(PSZ pFmt, ...);
#else
VOID __cdecl AssertFn(LPSTR lpMsg, LPSTR lpFile, ULONG uLine);
VOID __cdecl PrintFn(LPSTR lpFmt, ...);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\cscapi.h ===
#ifndef _INC_CSCAPI
#define _INC_CSCAPI

#ifdef  __cplusplus
extern "C" {
#endif
// flags returned in the status field for files and folders.
// NB!!!! these bit definitions match exactly with those in shdcom.h


#define  FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED     0x0001
#define  FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED   0x0002
#define  FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED     0x0004
#define  FLAG_CSC_COPY_STATUS_STALE                     0x0008
#define  FLAG_CSC_COPY_STATUS_LOCALLY_DELETED           0x0010
#define  FLAG_CSC_COPY_STATUS_SPARSE                    0x0020

#define  FLAG_CSC_COPY_STATUS_ORPHAN                    0x0100
#define  FLAG_CSC_COPY_STATUS_SUSPECT                   0x0200
#define  FLAG_CSC_COPY_STATUS_LOCALLY_CREATED           0x0400

#define  FLAG_CSC_COPY_STATUS_IS_FILE                   0x80000000
#define  FLAG_CSC_COPY_STATUS_FILE_IN_USE               0x40000000

// Flags returned in the status field for shares

#define FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE          0x0001
#define FLAG_CSC_SHARE_STATUS_CONNECTED                 0x0800
#define FLAG_CSC_SHARE_STATUS_FILES_OPEN                0x0400
#define FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS         0x0200
#define FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP           0x8000
#define FLAG_CSC_SHARE_MERGING                          0x4000

#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000  // No automatic file by file reint  (Persistent)
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040  // File by file reint is OK         (Persistent)
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080  // no need to flow opens            (Persistent)
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0  // client should not cache this share (Persistent)

#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0  // type of caching

#define FLAG_CSC_ACCESS_MASK                            0x003F0000
#define FLAG_CSC_USER_ACCESS_MASK                       0x00030000
#define FLAG_CSC_GUEST_ACCESS_MASK                      0x000C0000
#define FLAG_CSC_OTHER_ACCESS_MASK                      0x00300000

#define FLAG_CSC_USER_ACCESS_SHIFT_COUNT                16
#define FLAG_CSC_GUEST_ACCESS_SHIFT_COUNT               18
#define FLAG_CSC_OTHER_ACCESS_SHIFT_COUNT               20

#define FLAG_CSC_READ_ACCESS                            0x00000001
#define FLAG_CSC_WRITE_ACCESS                           0x00000002

// Hint flags Definitions:
#define FLAG_CSC_HINT_PIN_USER                  0x01    // When this bit is set, the item is being pinned for the user
                                                        // Note that there is only one pincount allotted for user.
#define FLAG_CSC_HINT_PIN_INHERIT_USER          0x02    // When this flag is set on a folder, all  descendents subsequently
                                                        // Created in this folder get pinned for the user
#define FLAG_CSC_HINT_PIN_INHERIT_SYSTEM        0x04    // When this flag is set on a folder, all descendents
                                                        // Subsequently  created in this folder get pinned for the
                                                        // system
#define FLAG_CSC_HINT_CONSERVE_BANDWIDTH        0x08    // When this flag is set on a folder,  for executables and
                                                        // Other related file, CSC tries to conserver bandwidth
                                                        // By not flowing opens when these files are fully


#define FLAG_CSC_HINT_PIN_SYSTEM                0x10    // This flag indicates it is pinned for the system

#define FLAG_CSC_HINT_COMMAND_MASK                      0xf0000000
#define FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT           0x80000000  // Increments/decrements pin count


// Database status bits

#define FLAG_DATABASESTATUS_DIRTY                   0x00000001

#define FLAG_DATABASESTATUS_ENCRYPTION_MASK         0x00000006

#define FLAG_DATABASESTATUS_UNENCRYPTED             0x00000000 // new fileinodes will NOT be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED   0x00000004

#define FLAG_DATABASESTATUS_ENCRYPTED               0x00000002 // new fileinodes will be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED     0x00000006


// definitions for callback reason

#define CSCPROC_REASON_BEGIN        1
#define CSCPROC_REASON_MORE_DATA    2
#define CSCPROC_REASON_END          3


// Definitions for callback return values:

#define CSCPROC_RETURN_CONTINUE         1
#define CSCPROC_RETURN_SKIP             2
#define CSCPROC_RETURN_ABORT            3
#define CSCPROC_RETURN_FORCE_INWARD     4        // applies only while merging
#define CSCPROC_RETURN_FORCE_OUTWARD    5    // applies only while merging
#define CSCPROC_RETURN_RETRY            6



typedef DWORD   (WINAPI *LPCSCPROCW)(
                LPCWSTR             lpszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                WIN32_FIND_DATAW    *lpFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext
                );

typedef DWORD   (WINAPI *LPCSCPROCA)(
                LPCSTR              lpszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                WIN32_FIND_DATAA    *lpFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext
                );



BOOL
WINAPI
CSCIsCSCEnabled(
    VOID
);


BOOL
WINAPI
CSCFindClose(
    IN  HANDLE    hFind
);

BOOL
WINAPI
CSCPinFileA(
    IN  LPCSTR      lpszFileName,
    IN  DWORD       dwHintFlags,
    OUT LPDWORD     lpdwStatus,
    OUT LPDWORD     lpdwPinCount,
    OUT LPDWORD     lpdwHintFlags
    );

BOOL
WINAPI
CSCUnpinFileA(
    IN  LPCSTR  lpszFileName,
    IN  DWORD   dwHintFlags,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags
    );

BOOL
WINAPI
CSCQueryFileStatusA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags
);

BOOL
WINAPI
CSCQueryFileStatusExA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags,
    OUT LPDWORD lpdwUserPerms,
    OUT LPDWORD lpdwOtherPerms
);

BOOL
WINAPI
CSCQueryShareStatusA(
    IN  LPCSTR  lpszFileName,
    OUT LPDWORD lpdwStatus,
    OUT LPDWORD lpdwPinCount,
    OUT LPDWORD lpdwHintFlags,
    OUT LPDWORD lpdwUserPerms,
    OUT LPDWORD lpdwOtherPerms
);

HANDLE
WINAPI
CSCFindFirstFileA(
    IN  LPCSTR          lpszFileName,    // if NULL, returns the shares cached
    OUT WIN32_FIND_DATA *lpFind32,
    OUT LPDWORD         lpdwStatus,        // returns FLAG_CSC_SHARE_STATUS_XXX for shares
                                            // FLAG_CSC_STATUS_XXX for the rest
    OUT LPDWORD         lpdwPinCount,
    OUT LPDWORD         lpdwHintFlags,
    OUT FILETIME        *lpOrgFileTime
);

BOOL
WINAPI
CSCFindNextFileA(
    IN  HANDLE          hFind,
    OUT WIN32_FIND_DATA *lpFind32,
    OUT LPDWORD         lpdwStatus,
    OUT LPDWORD         lpdwPinCount,
    OUT LPDWORD         lpdwHintFlags,
    OUT FILETIME        *lpOrgFileTime
);

BOOL
WINAPI
CSCDeleteA(
    IN  LPCSTR    lpszFileName
);


BOOL
WINAPI
CSCFillSparseFilesA(
    IN    LPCSTR        lpszShareName,
    IN    BOOL          fFullSync,
    IN    LPCSCPROCA    lpprocFillProgress,
    IN    DWORD_PTR     dwContext
);



BOOL
WINAPI
CSCMergeShareA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnMergeProgress,
    IN  DWORD_PTR   dwContext
);


BOOL
WINAPI
CSCCopyReplicaA(
    IN  LPCSTR  lpszFullPath,
    OUT LPSTR   *lplpszLocalName
);


BOOL
WINAPI
CSCEnumForStatsA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCEnumForStatsExA(
    IN  LPCSTR      lpszShareName,
    IN  LPCSCPROCA  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCPinFileW(
    LPCWSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
);

BOOL
WINAPI
CSCUnpinFileW(
    LPCWSTR     lpszFileName,
    DWORD       dwHintFlags,
    LPDWORD     lpdwStatus,
    LPDWORD     lpdwPinCount,
    LPDWORD     lpdwHintFlags
    );

BOOL
WINAPI
CSCQueryFileStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags
);

BOOL
WINAPI
CSCQueryFileStatusExW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
);

BOOL
WINAPI
CSCQueryShareStatusW(
    LPCWSTR lpszFileName,
    LPDWORD lpdwStatus,
    LPDWORD lpdwPinCount,
    LPDWORD lpdwHintFlags,
    LPDWORD lpdwUserPerms,
    LPDWORD lpdwOtherPerms
);

HANDLE
WINAPI
CSCFindFirstFileW(
    LPCWSTR             lpszFileName,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);

HANDLE
WINAPI
CSCFindFirstFileForSidW(
    LPCWSTR             lpszFileName,
    PSID                pSid,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);
BOOL
WINAPI
CSCFindNextFileW(
    HANDLE              hFind,
    WIN32_FIND_DATAW    *lpFind32,
    LPDWORD             lpdwStatus,
    LPDWORD             lpdwPinCount,
    LPDWORD             lpdwHintFlags,
    FILETIME            *lpOrgFileTime
);

BOOL
WINAPI
CSCDeleteW(
    IN  LPCWSTR    lpszFileName
);

BOOL
WINAPI
CSCFillSparseFilesW(
    IN    LPCWSTR       lpszShareName,
    IN    BOOL          fFullSync,
    IN    LPCSCPROCW    lpprocFillProgress,
    IN    DWORD_PTR     dwContext
);



BOOL
WINAPI
CSCMergeShareW(
    IN  LPCWSTR         lpszShareName,
    IN  LPCSCPROCW      lpfnMergeProgress,
    IN  DWORD_PTR       dwContext
);


BOOL
WINAPI
CSCCopyReplicaW(
    IN  LPCWSTR lpszFullPath,
    OUT LPWSTR  *lplpszLocalName
);

BOOL
WINAPI
CSCEnumForStatsW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCEnumForStatsExW(
    IN  LPCWSTR     lpszShareName,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
);

BOOL
WINAPI
CSCFreeSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
    );

BOOL
WINAPI
CSCIsServerOfflineA(
    IN  LPCSTR     lpszServerName,
    OUT BOOL        *lpfOffline
    );

BOOL
WINAPI
CSCIsServerOfflineW(
    IN  LPCWSTR     lpszServerName,
    OUT BOOL        *lpfOffline
    );

BOOL
WINAPI
CSCGetSpaceUsageA(
    OUT LPSTR   lptzLocation,
    IN  DWORD   dwSize,
    OUT LPDWORD lpdwMaxSpaceHigh,
    OUT LPDWORD lpdwMaxSpaceLow,
    OUT LPDWORD lpdwCurrentSpaceHigh,
    OUT LPDWORD lpdwCurrentSpaceLow,
    OUT LPDWORD lpcntTotalFiles,
    OUT LPDWORD lpcntTotalDirs
);

BOOL
WINAPI
CSCGetSpaceUsageW(
    OUT LPWSTR  lptzLocation,
    IN  DWORD   dwSize,
    OUT LPDWORD lpdwMaxSpaceHigh,
    OUT LPDWORD lpdwMaxSpaceLow,
    OUT LPDWORD lpdwCurrentSpaceHigh,
    OUT LPDWORD lpdwCurrentSpaceLow,
    OUT LPDWORD lpcntTotalFiles,
    OUT LPDWORD lpcntTotalDirs
);

BOOL
WINAPI
CSCSetMaxSpace(
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow
);

BOOL
WINAPI
CSCTransitionServerOnlineW(
    IN  LPCWSTR     lpszServerName
    );

BOOL
WINAPI
CSCTransitionServerOnlineA(
    IN  LPCSTR     lpszServerName
    );

BOOL
WINAPI
CSCCheckShareOnlineW(
    IN  LPCWSTR     lpszShareName
    );

BOOL
WINAPI
CSCCheckShareOnlineExW(
    IN  LPCWSTR     lpszShareName,
    IN  DWORD       *lpdwSpeed
    );

BOOL
WINAPI
CSCCheckShareOnlineA(
    IN  LPCSTR     lpszShareName
    );

BOOL
WINAPI
CSCDoLocalRenameW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  BOOL        fReplaceFile
    );

BOOL
WINAPI
CSCDoLocalRenameA(
    IN  LPCSTR      lpszSource,
    IN  LPCSTR      lpszDestination,
    IN  BOOL        fReplaceFile
    );

BOOL
WINAPI
CSCDoLocalRenameExA(
    IN  LPCSTR     lpszSource,
    IN  LPCSTR     lpszDestination,
    IN  WIN32_FIND_DATAA    *lpFin32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    );

BOOL
WINAPI
CSCDoLocalRenameExW(
    IN  LPCWSTR     lpszSource,
    IN  LPCWSTR     lpszDestination,
    IN  WIN32_FIND_DATAW    *lpFin32,
    IN  BOOL        fMarkAsLocal,
    IN  BOOL        fReplaceFileIfExists
    );

BOOL
WINAPI
CSCDoEnableDisable(
    BOOL    fEnable
    );


BOOL
WINAPI
CSCBeginSynchronizationW(
    IN  LPCWSTR     lpszShareName,
    LPDWORD         lpdwSpeed,
    LPDWORD         lpdwContext
    );


BOOL
WINAPI
CSCEndSynchronizationW(
    IN  LPCWSTR     lpszShareName,
    DWORD           dwContext
    );

BOOL
WINAPI
CSCEncryptDecryptDatabase(
    IN  BOOL        fEncrypt,
    IN  LPCSCPROCW  lpfnEnumProgress,
    IN  DWORD_PTR   dwContext
    );

BOOL
WINAPI
CSCQueryDatabaseStatus(
    ULONG   *pulStatus,
    ULONG   *pulErrors
    );

BOOL
WINAPI
CSCPurgeUnpinnedFiles(
    ULONG   Timeout,
    ULONG   *pulnFiles,
    ULONG   *pulnYoungFiles
    );

BOOL
WINAPI
CSCShareIdToShareName(
    ULONG ShareId,
    PBYTE Buffer,
    PDWORD pdwBufSize
    );

#ifdef UNICODE

#define CSCPinFile          CSCPinFileW
#define CSCUnpinFile        CSCUnpinFileW
#define CSCQueryFileStatus  CSCQueryFileStatusW
#define CSCQueryFileStatusEx  CSCQueryFileStatusExW
#define CSCQueryShareStatus  CSCQueryShareStatusW
#define CSCFindFirstFile    CSCFindFirstFileW
#define CSCFindFirstFileForSid    CSCFindFirstFileForSidW
#define CSCFindNextFile     CSCFindNextFileW
#define CSCDelete           CSCDeleteW
#define CSCFillSparseFiles  CSCFillSparseFilesW
#define CSCMergeShare       CSCMergeShareW
#define CSCCopyReplica      CSCCopyReplicaW
#define CSCEnumForStats     CSCEnumForStatsW
#define CSCIsServerOffline  CSCIsServerOfflineW
#define LPCSCPROC           LPCSCPROCW
#define CSCGetSpaceUsage    CSCGetSpaceUsageW
#define CSCTransitionServerOnline   CSCTransitionServerOnlineW
#define CSCCheckShareOnline         CSCCheckShareOnlineW
#define CSCCheckShareOnlineEx         CSCCheckShareOnlineExW
#define CSCDoLocalRename            CSCDoLocalRenameW
#define CSCDoLocalRenameEx            CSCDoLocalRenameExW
#define CSCEnumForStatsEx     CSCEnumForStatsExW
#define CSCBeginSynchronization    CSCBeginSynchronizationW
#define CSCEndSynchronization   CSCEndSynchronizationW
#else

#define CSCPinFile          CSCPinFileA
#define CSCUnpinFile        CSCUnpinFileA
#define CSCQueryFileStatus  CSCQueryFileStatusA
#define CSCQueryFileStatusEx  CSCQueryFileStatusExA
#define CSCQueryShareStatus  CSCQueryShareStatusA
#define CSCFindFirstFile    CSCFindFirstFileA
#define CSCFindFirstFileForSid    CSCFindFirstFileForSidA
#define CSCFindNextFile     CSCFindNextFileA
#define CSCDelete           CSCDeleteA
#define CSCFillSparseFiles  CSCFillSparseFilesA
#define CSCMergeShare       CSCMergeShareA
#define CSCCopyReplica      CSCCopyReplicaA
#define CSCEnumForStats     CSCEnumForStatsA
#define CSCIsServerOffline  CSCIsServerOfflineA
#define LPCSCPROC           LPCSCPROCA
#define CSCGetSpaceUsage    CSCGetSpaceUsageA
#define CSCTransitionServerOnline   CSCTransitionServerOnlineA
#define CSCCheckShareOnline        CSCCheckShareOnlineA
#define CSCCheckShareOnlineEx         CSCCheckShareOnlineExA
#define CSCDoLocalRename            CSCDoLocalRenameA
#define CSCEnumForStatsEx     CSCEnumForStatsExA
#define CSCDoLocalRenameEx            CSCDoLocalRenameExA
#endif

#ifdef __cplusplus
}   /* ... extern "C" */
#endif


#endif  // _INC_CSCAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\bowser\workque.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    workque.h

Abstract:

    This module defines the data structures and routines used for the FSP
    dispatching code.


Author:

    Larry Osterman (LarryO) 13-Aug-1990

Revision History:

    13-Aug-1990 LarryO

        Created

--*/
#ifndef _WORKQUE_
#define _WORKQUE_


typedef struct _IRP_QUEUE {
    LIST_ENTRY Queue;               //  Queue itself.
} IRP_QUEUE, *PIRP_QUEUE;


struct _BOWSER_FS_DEVICE_OBJECT;

//
//  IRP Context.
//
//  The IRP context is a wrapper that used when passing an IRP from the
//  redirectors FSD to its FSP.
//

typedef
struct _IRP_CONTEXT {
    WORK_QUEUE_ITEM WorkHeader;
    PIRP Irp;
    struct _BOWSER_FS_DEVICE_OBJECT *DeviceObject;
} IRP_CONTEXT, *PIRP_CONTEXT;

VOID
BowserQueueCriticalWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    );

VOID
BowserQueueDelayedWorkItem (
    IN PWORK_QUEUE_ITEM WorkItem
    );

PIRP_CONTEXT
BowserAllocateIrpContext(
    VOID
    );

VOID
BowserFreeIrpContext(
    PIRP_CONTEXT IrpContext
    );

VOID
BowserInitializeIrpQueue(
    PIRP_QUEUE Queue
    );

VOID
BowserUninitializeIrpQueue(
    PIRP_QUEUE Queue
    );

VOID
BowserCancelQueuedRequest(
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIRP Irp
    );

VOID
BowserCancelQueuedIoForFile(
    IN PIRP_QUEUE Queue,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
BowserQueueNonBufferRequest(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    );

NTSTATUS
BowserQueueNonBufferRequestReferenced(
    IN PIRP Irp,
    IN PIRP_QUEUE Queue,
    IN PDRIVER_CANCEL CancelRoutine
    );

VOID
BowserTimeoutQueuedIrp(
    IN PIRP_QUEUE Queue,
    IN ULONG NumberOfSecondsToTimeOut
    );

PIRP
BowserDequeueQueuedIrp(
    IN PIRP_QUEUE Queue
    );

VOID
BowserInitializeIrpContext(
    VOID
    );

VOID
BowserpUninitializeIrpContext(
    VOID
    );

VOID
BowserpInitializeIrpQueue(
    VOID
    );

//
//  Returns TRUE if there are no entries in the IRP queue.
//

#define BowserIsIrpQueueEmpty(IrpQueue) IsListEmpty(&(IrpQueue)->Queue)


#endif  // _WORKQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\csc_bmpc.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpc.h

Abstract:

    Common header file for csc bitmap code

    Client Side Bitmap common header for both kernel mode code and user
    mode code. The 'c' in the filename means 'Common header'

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/


#ifndef _CSC_BMPC_H_
#define _CSC_BMPC_H_

typedef struct CscBmpFileHdr {
    DWORD magicnum;
    BYTE  inuse;  // a BOOL
    BYTE  valid;  // a BOOL
    DWORD sizeinbits;
    DWORD numDWORDs;
} CscBmpFileHdr;

#define BLOCKSIZE 4096 // # bytes per bitmapped block

#define MAGICNUM 0xAA55FF0D /* to be placed in the begining of the
			       bitmap file. For checking validity of bitmap
			       as well as version. Change if bitmap file
			       format changes, or that one bit represents
			       different number of bytes.
			     */

#define STRMNAME ":cscbmp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\generr.h ===
//
// err.h: Declares data, defines and struct types for error handling
//          module.
//
//

#ifndef __GENERR_H__
#define __GENERR_H__

// Requires comm.h to be included prior to this
//

/////////////////////////////////////////////////////  INCLUDES
/////////////////////////////////////////////////////  DEFINES

#ifdef DEBUG

// Dump flags used in g_uDumpFlags
//
#define DF_RECLIST      0x0001
#define DF_RECITEM      0x0002
#define DF_RECNODE      0x0004
#define DF_CREATETWIN   0x0008
#define DF_ATOMS        0x0010
#define DF_CRL          0x0020
#define DF_CBS          0x0040
#define DF_CPATH        0x0080
#define DF_PATHS        0x0100
#define DF_UPDATECOUNT  0x0200
#define DF_TWINPAIR     0x0400
#define DF_FOLDERTWIN   0x0800
#define DF_CHOOSESIDE   0x1000

// Break flags used in g_uBreakFlags
//
#define BF_ONOPEN       0x0001
#define BF_ONCLOSE      0x0002
#define BF_ONRUNONCE    0x0004
#define BF_ONVALIDATE   0x0010
#define BF_ONTHREADATT  0x0100
#define BF_ONTHREADDET  0x0200
#define BF_ONPROCESSATT 0x0400
#define BF_ONPROCESSDET 0x0800

#endif

// Trace flags used in g_uTraceFlags (defined in retail on purpose)
//
#define TF_ALWAYS       0x0000
#define TF_WARNING      0x0001
#define TF_ERROR        0x0002
#define TF_GENERAL      0x0004      // Standard briefcase trace messages
#define TF_FUNC         0x0008      // Trace function calls
#define TF_CACHE        0x0010      // Cache-specific trace messages
#define TF_ATOM         0x0020      // Atom-specific trace messages
#define TF_PROGRESS     0x0040      // Progress bar deltas

//---------------------------------------------------------------------------
// HRESULT error codes
//---------------------------------------------------------------------------

// Map a TWINRESULT error value into a HRESULT
// Note: TR_SUCCESS should not be mapped
// Note: This assumes that TWINRESULT errors fall in the range -32k to 32k.
//
#define TR_DELTAVALUE           1000
#define FACILITY_TR             0x018a          // magic number

#define HRESULT_FROM_TR(x)      (TR_SUCCESS == (x) ? NOERROR : \
                                                   ((HRESULT) ((((x) + TR_DELTAVALUE) & 0x0000FFFF) | (FACILITY_TR << 16) | 0x80000000)))
#define IS_ENGINE_ERROR(hr)     IsFlagSet(hr, ((FACILITY_TR << 16) | 0x80000000))
#define GET_TR(hr)              ((TWINRESULT)((hr) & 0x0000FFFF) - TR_DELTAVALUE)

HRESULT PUBLIC MapToOfficialHresult(HRESULT hres);

// SCODE values that correspond to TWINRESULT values
#define E_TR_RH_LOAD_FAILED         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_RH_LOAD_FAILED)
#define E_TR_SRC_OPEN_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_OPEN_FAILED)
#define E_TR_SRC_READ_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_READ_FAILED)
#define E_TR_DEST_OPEN_FAILED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_OPEN_FAILED)
#define E_TR_DEST_WRITE_FAILED      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_WRITE_FAILED)
#define E_TR_ABORT                  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_ABORT)
#define E_TR_UNAVAILABLE_VOLUME     MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_UNAVAILABLE_VOLUME)
#define E_TR_OUT_OF_MEMORY          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_OUT_OF_MEMORY)
#define E_TR_FILE_CHANGED           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_FILE_CHANGED)
#define E_TR_DUPLICATE_TWIN         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DUPLICATE_TWIN)
#define E_TR_DELETED_TWIN           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DELETED_TWIN)
#define E_TR_HAS_FOLDER_TWIN_SRC    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_HAS_FOLDER_TWIN_SRC)
#define E_TR_INVALID_PARAMETER      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_INVALID_PARAMETER)
#define E_TR_SAME_FOLDER            MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SAME_FOLDER)
#define E_TR_SUBTREE_CYCLE_FOUND    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SUBTREE_CYCLE_FOUND)
#define E_TR_NO_MERGE_HANDLER       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MERGE_HANDLER)
#define E_TR_MERGE_INCOMPLETE       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_MERGE_INCOMPLETE)
#define E_TR_TOO_DIFFERENT          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_TOO_DIFFERENT)
#define E_TR_BRIEFCASE_LOCKED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_LOCKED)
#define E_TR_BRIEFCASE_OPEN_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_OPEN_FAILED)
#define E_TR_BRIEFCASE_READ_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_READ_FAILED)
#define E_TR_BRIEFCASE_WRITE_FAILED MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_WRITE_FAILED)
#define E_TR_CORRUPT_BRIEFCASE      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_CORRUPT_BRIEFCASE)
#define E_TR_NEWER_BRIEFCASE        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NEWER_BRIEFCASE)
#define E_TR_NO_MORE                MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MORE)

/////////////////////////////////////////////////////  MACROS

// Error table for lookup strings.  Usually an array of these
// structures is created and placed in the readonly data segment.
//
typedef struct _SETbl
    {
    HRESULT hres;       // standard result
    UINT    ids;        // String ID of message
    UINT    uStyle;     // MB_ flags
    } SETbl, * PSETBL;

typedef SETbl const *  PCSETBL;

int PUBLIC SEMsgBox(HWND hwnd, UINT idsCaption, SCODE sc, PCSETBL pseTable, UINT cArraySize);


// Retry loop
//
#define RETRY_BEGIN(bInit)      {BOOL bMyRetry; do { bMyRetry = (bInit);
#define RETRY_END()             } while (bMyRetry); }
#define RETRY_SET()             bMyRetry = TRUE
#define RETRY_CLEAR()           bMyRetry = FALSE


// Debugging macros
//

#ifdef DEBUG

#define DEBUG_CASE_STRING(x)    case x: return #x

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)	/* ;Internal */ \
    static const char ASSERTSEG sz[] = msg;

void PUBLIC BrfAssertFailed(LPCSTR szFile, int line);
void CPUBLIC BrfAssertMsg(BOOL f, LPCSTR pszMsg, ...);
void CPUBLIC GenErrDebugMsg(UINT mask, LPCSTR pszMsg, ...);

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, __FILE__);                                    \
        if (!(f))                                                       \
            BrfAssertFailed(szFile, __LINE__);                          \
    }
#define ASSERT_E(f)  ASSERT(f)

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   BrfAssertMsg

// DEBUG_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    GenErrDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFYSZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFYSZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFYSZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFYSZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(szFn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(szFn)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "()")


// DBG_ENTER_SZ(szFn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(szFn, sz)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., \"%s\",...)", Dbg_SafeStr(sz))


// DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf)  -- Generates a function entry 
//                          debug spew for a function that accepts a 
//                          string as one of its parameters.
//
#define DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf) \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_DataObjStr(pdtobj, szBuf))


// DBG_ENTER_RIID(szFn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(szFn, riid)                  \
    TRACE_MSG(TF_FUNC, " > " szFn "(..., %s,...)", Dbg_GetRiidName(riid))


// DBG_EXIT(szFn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(szFn)                              \
        TRACE_MSG(TF_FUNC, " < " szFn "()")

// DBG_EXIT_US(szFn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(szFn, us)                       \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#x", (USHORT)us)

// DBG_EXIT_UL(szFn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(szFn, ul)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (ULONG)ul)

// DBG_EXIT_PTR(szFn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(szFn, pv)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %#lx", (LPVOID)pv)

// DBG_EXIT_HRES(szFn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(szFn, hres)                   \
        TRACE_MSG(TF_FUNC, " < " szFn "() with %s", Dbg_GetScode(hres))


#else

#define ASSERT(f)
#define ASSERT_E(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFYSZ(f, szFmt, x)     (f)

#define DBG_ENTER(szFn)
#define DBG_ENTER_SZ(szFn, sz)
#define DBG_ENTER_DTOBJ(szFn, pdtobj, sz)
#define DBG_ENTER_RIID(szFn, riid)   

#define DBG_EXIT(szFn)                            
#define DBG_EXIT_US(szFn, us)
#define DBG_EXIT_UL(szFn, ul)
#define DBG_EXIT_PTR(szFn, ptr)                            
#define DBG_EXIT_HRES(szFn, hres)   

#endif

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#ifdef DEBUG

void PUBLIC DEBUG_BREAK(UINT flag);

LPCSTR PUBLIC Dbg_GetRiidName(REFIID riid);
LPCSTR PUBLIC Dbg_GetScode(HRESULT hres);
LPCSTR PUBLIC Dbg_SafeStr(LPCSTR psz);
LPCSTR PUBLIC Dbg_DataObjStr(LPDATAOBJECT pdtobj, LPSTR pszBuf);

#endif

#endif // __ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\makefile.inc ===
$(PROJECT_INC_PATH)\cscapi.h : cscapi.h
    $(PUBLISH_CMD) {$?=$@}

$(PROJECT_INC_PATH)\shdcom.h : shdcom.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\logdat.h ===
#define  VFNLOG_DELETE        0
#define  VFNLOG_CREATE_DIR    1
#define  VFNLOG_DELETE_DIR    2
#define  VFNLOG_CHECK_DIR     3
#define  VFNLOG_GET_ATTRB     4
#define  VFNLOG_SET_ATTRB     5
#define  VFNLOG_FLUSH         6
#define  VFNLOG_GETDISKINFO   7
#define  VFNLOG_GETDISKPARAMS 8
#define  VFNLOG_OPEN          9
#define  VFNLOG_RENAME        10
#define  VFNLOG_SRCHFRST      11
#define  VFNLOG_SRCHNEXT      12
#define  VFNLOG_QUERY0        13
#define  VFNLOG_QUERY1        14
#define  VFNLOG_QUERY2        15
#define  VFNLOG_CONNECT       16
#define  VFNLOG_DISCONNECT    17
#define  VFNLOG_UNCPIPEREQ    18
#define  VFNLOG_IOCTL16DRV    19
#define  VFNLOG_DASDIO        20
#define  VFNLOG_FINDOPEN      21
#define  HFNLOG_FINDNEXT      22
#define  HFNLOG_FINDCLOSE     23
#define  HFNLOG_READ          24
#define  HFNLOG_WRITE         25
#define  HFNLOG_CLOSE         26
#define  HFNLOG_SEEK          27
#define  HFNLOG_COMMIT        28
#define  HFNLOG_FLOCK         29
#define  HFNLOG_FUNLOCK       30
#define  HFNLOG_GET_TIME      31
#define  HFNLOG_SET_TIME      32
#define  HFNLOG_GET_LATIME    33
#define  HFNLOG_SET_LATIME    34
#define  HFNLOG_PIPEREQ       35
#define  HFNLOG_HANDLEINFO    36
#define  HFNLOG_ENUMHANDLE    37
#define  VFNLOG_QUERY83_DIR   38
#define  VFNLOG_QUERYLONG_DIR 39

#define  TIME_PRINT_PRINT_FORMAT %02d:%02d:%02.2d
#define  DATE_PRINT_FORMAT       %02d-%02d-%02d
#define  TIME_DATE_PRINT_FORMAT  %02d:%02d:%02.2d;%02d-%02d-%02d

typedef struct tagLOGCMD
   {
   LPSTR lpCmd;
   LPSTR lpFmt;
   }
LOGCMD;

char szCR[] = "\r";
char szTimeDateFormat[] = "%02d:%02d:%02.2d %02d-%02d-%02d";
char szTimeFormat[] = "%02d:%02d:%02.2d";
char szPreFmt[]="%s %02d:%02d:%02.2d err=%d %s ";
char szDummy[]="XX";
char szLog[] = "C:\\shadow.log";


LOGCMD rgsLogCmd[] =
   {
     "Del     "   ,szCR
   , "Mkdir   "   ,szCR
   , "Rmdir   "   ,szCR
   , "Chkdir  "   ,szCR
   , "GetAttrb"   ,"Atrb=%xh\r"
   , "SetAttrb"   ,"Atrb=%xh\r"
   , "Flush   "   ,szCR
   , "GetDiskI"   ,szCR
   , "GetDiskP"   ,szCR
   , "Open    "   ,"AccsShr=%xh Action=%xh Attr=%xh Size=%d Time="
   , "Ren     "   ,"To %s\r"
   , "Srchfrst"   ,"Atrb=%xh %s \r"
   , "Srchnext"   ,"%s \r"
   , "Query   "   ,szCR
   , "Query   "   ,"Status=%xh\r"
   , "Query   "   ,"Status=%xh MaxPath = %d MaxFileName = %d\r"
   , "Connect "   ,"ResType=%d\r"
   , "Disconn "   ,szCR
   , "UncPpRq "   ,szCR
   , "Ioctl16D"   ,szCR
   , "Dasdio  "   ,szCR
   , "FindOpen"   ,"Options=%xh %s\r"
   , "FindNext"   ,"%s\r"
   , "FindCls "   ,szCR
   , "Read    "   ,"p=%d l=%d\r"
   , "Write   "   ,"p=%d l=%d\r"
   , "Close   "   ,"Type=%d\r"
   , "Seek    "   ,"p=%d type=%d\r"
   , "Commit  "   ,szCR
   , "LockF   "   ,"p=%d l=%d\r"
   , "UnlockF "   ,"p=%d l=%d\r"
   , "GetFtime"   ,szCR
   , "SetFtime"   ,szCR
   , "GetLaTim"   ,szCR
   , "SetLaTim"   ,szCR
   , "Pipereq "   ,szCR
   , "HndlInfo"   ,szCR
   , "EnumHndl"   ,"type = %d \r"
   , "Query83"    ,szCR
   , "QueryLong"  ,szCR
   };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\lib3.h ===
#ifndef __LIB3_H__
#define __LIB3_H__

#ifdef __cplusplus
extern "C" {
#endif

#undef VxD



#include "shdcom.h"

#ifndef __COPYCHUNKCONTEXT__
#define __COPYCHUNKCONTEXT__
typedef struct tagCOPYCHUNKCONTEXT
{
    DWORD    dwFlags;
    ULONG    LastAmountRead;
    ULONG    TotalSizeBeforeThisRead;
    HANDLE   handle;
    ULONG    ChunkSize;
    ULONG    Context[1];
}
COPYCHUNKCONTEXT;
#endif

/* lib3.c */

#ifdef UNICODE

#define GetShadow                           GetShadowW
#define GetShadowEx                         GetShadowExW
#define CreateShadow                        CreateShadowW
#define GetShadowInfo                       GetShadowInfoW
#define GetShadowInfoEx                     GetShadowInfoExW
#define SetShadowInfo                       SetShadowInfoW
#define GetUNCPath                          GetUNCPathW
#define FindOpenShadow                      FindOpenShadowW
#define FindNextShadow                      FindNextShadowW
#define AddHint                             AddHintW
#define DeleteHint                          DeleteHintW
#define GetShareInfo                       GetShareInfoW
#define ChkUpdtStatus                       ChkUpdtStatusW
#define FindOpenHint                        FindOpenHintW
#define FindNextHint                        FindNextHintW
#define LpAllocCopyParams                   LpAllocCopyParamsW
#define FreeCopyParams                      FreeCopyParamsW
#define CopyShadow                          CopyShadowW
#define GetShadowDatabaseLocation           GetShadowDatabaseLocationW
#define GetNameOfServerGoingOffline         GetNameOfServerGoingOfflineW
#else

#define GetShadow                           GetShadowA
#define GetShadowEx                         GetShadowExA
#define CreateShadow                        CreateShadowA
#define GetShadowInfo                       GetShadowInfoA
#define GetShadowInfoEx                     GetShadowInfoExA
#define SetShadowInfo                       SetShadowInfoA
#define GetUNCPath                          GetUNCPathA
#define FindOpenShadow                      FindOpenShadowA
#define FindNextShadow                      FindNextShadowA
#define AddHint                             AddHintA
#define DeleteHint                          DeleteHintA
#define GetShareInfo                       GetShareInfoA
#define ChkUpdtStatus                       ChkUpdtStatusA
#define FindOpenHint                        FindOpenHintA
#define FindNextHint                        FindNextHintA
#define LpAllocCopyParams                   LpAllocCopyParamsA
#define FreeCopyParams                      FreeCopyParamsA
#define CopyShadow                          CopyShadowA
#define GetShadowDatabaseLocation           GetShadowDatabaseLocationA
#endif



HANDLE __OpenShadowDatabaseIO(ULONG WaitForDriver);
#define  OpenShadowDatabaseIO() (__OpenShadowDatabaseIO(0))
/*++

Routine Description:

    This routine is called by the callers in usermode using "APIs" in this file
    in order to establish a means of communicating with redir in the kernel mode. All
    the APIs are wrappers to various device IO controls to the redir in order to accomplish
    the appropriate task

Arguments:

    None. The waitfordriver argument is a temporary hack which will be removed soon.
    All callers should call OpenShadowDatabaseIO().


Returns:
    If suuccessful, it returns a handle to the redir (actually a symbolic link called shadow)
    Returns IMVALID_HANDLE_VALUE if it fails. GetLastError() gives the error value.

Notes:

    This is a wrapper function that does CreateFile on the "Shadow" deviceobject.

--*/



void CloseShadowDatabaseIO(HANDLE hShadowDB);
/*++

Routine Description:

    Closes the handle opened for communicating with the redir.

Arguments:

    Handle returned from a successful OpenShadowDatabaseIO call.

Returns:

    Nothing.

Notes:

    It is important to have a matching CloseShadowDatabaseIO call for every successful open
    call, otherwise the redir may not be able to stop in the net stop redir command.

--*/



int GetShadow(HANDLE hShadowDB, HSHADOW hDir, LPHSHADOW lphShadow, LPWIN32_FIND_DATA lpFind32, unsigned long *lpuStatus);
/*++

Routine Description:
    Given the directory Inode and a name of an entry within that directory, returns the
    WIN32 strucutre for the entry and it's current status. For definition of status bits
    refer to shdcom.h.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine.

                If hDir is 0, then the name in the lpFind32 strucutre must be a UNC name
                of a share in \\server\share form.

    lphShadow   returns the Inode number for the entry in the shadow database. If hDir is 0,
                the indoe is that of the root of this share.

    lpFind32    InOut parameter. Contains the name of the entry in cFileName member. On return
                all the elements of the find strucutre are filled up. These represent the
                find32 info as obtained from the server, with any subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.


    lpuStatus   returns the status of the entry, such as partially filled (sparse), locally modified
                etc. See SHADOW_xxx in shdcom.h

                If value returned in lphShadow is the root inode of a share, (ie if hDir is 0)
                then the status bits are SHARE_xxx as defined in shdcom.h. eg. the bits
                indicate whether the share is connected right now, whether it has any outstanding
                opens, whether it is operating in disconnected state etc.

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

--*/



int GetShadowEx(HANDLE hShadowDB, HSHADOW hDir, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    Given the directory Inode and a name of an entry within that directory, returns the
    WIN32 strucutre for the entry and all it's metadata maintained by the shadowing database.
    For a defintion of SHADOWINFO structure refer to shdcom.h


Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine

                If hDir is 0, then the name in the lpFind32 strucutre must be a UNC name
                of a share in \\server\share form.

    lphShadow   returns the Inode number for the entry in the shadow database

    lpFind32    InOut parameter. Contains the name of the entry in cFileName member. On return
                all the elements of the find strucutre are filled up. These represent the
                find32 info as obtained from the server, with any subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                When the object is in ssync, both the local and remote timestamps are identical.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.


                If value returned in lphShadow is the root inode of a share, (ie if hDir is 0)
                then the status bits in lpSI->uStatus are SHARE_xxx as defined in shdcom.h.
                eg. the bits indicate whether the share is connected right now, whether it has
                any outstanding opens, whether it is operating in disconnected state etc.

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

    GetShadowEx is a superset of GetShadow and should be preferred.

--*/



int CreateShadow(HANDLE hShadowDB, HSHADOW hDir, LPWIN32_FIND_DATA lpFind32, unsigned long uStatus, LPHSHADOW lphShadow);
/*++

Routine Description:

                Given the directory Inode and WIN32 strucutre for a file/directory, creates an
                Inode for the same.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.


    lpFind32    Should contain all the elements of the find32 info as obtained from the server.
                Only the ftLastWriteTime timestamp is used, other timestamps are ignored.

                If hDir is 0, then the name in the lpFind32 strucutre must be a UNC name
                of a share in \\server\share form. All other elements of the strucutre are ignored


    uStatus     the initial status of the entry to be created, such as partially filled (sparse)
                etc. See SHADOW_xxx in shdcom.h

    lphShadow   returns the Inode number for the entry in the shadow database

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

    For non-root entries, if the shadow already exists, the routine works just like SetShadowInfo.

--*/




int DeleteShadow(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow);
/*++

Routine Description:

    Deletes an entry from the shadow database.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.



    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.


Returns:

    1 if successful, 0 if failed. (Error reporting is not very good here)

Notes:

    The routine failes if hShadow is a directory and has descendents of it's own.
    If hDir is 0, then the root of the share is deleted. This would cause the share to
    be inaccessible in disconnected state, because it would have gone from the
    CSC database.

--*/




int GetShadowInfo(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow, LPWIN32_FIND_DATA lpFind32, unsigned long *lpuStatus);
/*++

Routine Description:

    Given the directory Inode and an inode within that directory, returns the
    WIN32 strucutre for the entry and it's current status. For definition of status bits
    refer to shdcom.h.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.


    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.

    lpFind32    Can be NULL. If non-NULL on return all the elements of the find strucutre
                are filled up. These represent the find32 info as obtained from the server,
                with any subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.


    lpuStatus   returns the status of the entry, such as partially filled (sparse), locally modified
                etc. See SHADOW_xxx in shdcom.h

                If hShadow is the root inode of a share, (ie if hDir is 0) then the status bits
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has any outstanding opens, whether
                it is operating in disconnected state etc.

Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

--*/



int GetShadowInfoEx(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    Given the directory Inode and an inode within that directory, returns the
    WIN32 strucutre for the entry and it's current status. For definition of status bits
    refer to shdcom.h.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.


    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.

    lpFind32    Can be NULL. If non NULL, on return all the elements of the find strucutre are
                filled up. These represent the find32 info as obtained from the server.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is a root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.

                If hShadow a root inode of a share, (ie if hDir is 0) then the status bits in lpSI->uStatus
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has ant outstanding opens, whether
                it is operating in disconnected state etc.
Returns:

    1 if successful, 0 otherwise. GetlastError() gives the error of unsuccessful.

Notes:

    GetShadowInfoEx is a superset of GetShadowInfo and should be preferred.

--*/




int SetShadowInfo(HANDLE hShadowDB, HSHADOW hDir, HSHADOW hShadow, LPWIN32_FIND_DATA lpFind32, unsigned long uStatus, unsigned long uOp);
/*++

Routine Description:

    Given the directory Inode and an inode within that directory, sets the WIN32 strucutre
    for the entry and it's current status. For definition of status bits refer to shdcom.h.


Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.


    lpFind32    If Non-NULL, should contain all the elements of the find32 info as obtained from the server.
                Only the ftLastWriteTime timestamp is used.

                If NULL, no modification is done to the find data strucutre.


    uStatus     the initial status of the entry to be created, such as partially filled (sparse)
                etc. See SHADOW_xxx in shdcom.h

    uOp         specifies operation SHADOW_FLAGS_ASSIGN, SHADOW_FLAGS_AND or SHADOW_FLAGS_OR
                to do the corresponding operation between the existing status bits and the
                one passed in the uStatus parameter.

Returns:

    1 if successful 0 if failed. The routine failes if hDir is 0, ie. there is no way to set
    info on the root of a share.

Notes:

--*/



int GetUNCPath(HANDLE hShadowDB, HSHARE hShare, HSHADOW hDir, HSHADOW hShadow, LPCOPYPARAMS lpCP);
/*++

Routine Description:

    This routine returns the path of the remote file with respect to it's root, the UNC string
    of ths share and the fully qualified path of the local replica.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     The share ID on which this shadow lives. (not really necessary)

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    hShadow     Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine. This
                inode represents a child of the directory represented by hDir.

    lpCP        COPYPARAMS structure as defined in shdcom.h. The buffer should be big enough to
                hold two MAX_PATH size elements and one MAX_SHARE_PATH element. On return the
                appropriate entires are filled up.


Returns:

    1 if successful 0 if failed

Notes:

--*/


int GetGlobalStatus(HANDLE hShadowDB, LPGLOBALSTATUS lpGS);
/*++

Routine Description:

    Returns the status of the entire CSC database, such as the maximum size, the current size
    etc.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    lpGS        GLOBALSTATUS structure returned by the API. Refer to shdcom.h for
                the strucutre definition.

Returns:

    1 if successful 0 if failed

Notes:

--*/



int FindOpenShadow(HANDLE hShadowDB, HSHADOW hDir, unsigned uOp, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    This API allows callers to begin enumeration of all entries in a directory in the CSC database.
    Does wildcard pattern matching.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow passing in INVALID_HANDLE_VALUE.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode of a share.

    uOp         Bitfield indicating which type of entries to enumerate. The alternatives are

                a) All normal entries when FINDINFO_SHADOWINFO_NORMAL is set
                b) All sparse entries when FINDINFO_SHADOWINFO_SPARSE is set
                c) All entries marked deleted when FINDINFO_SHADOWINFO_DELETED is set

                Setting FINDOPEN_SHADOWINFO_ALL enumerates all the three kind.

    lpFind32    InOut parameter. Contains the name of the entry in cFileName member, the name can
                cotain wildcard characters. On return all the elements of the find strucutre are
                filled up. These represent the find32 info as obtained from the server, with any
                subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is the root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.

                If hShadow a root inode of a share, (ie if hDir is 0) then the status bits in lpSI->uStatus
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has ant outstanding opens, whether
                it is operating in disconnected state etc.


                lpSI->uEmumCookie contains the enumeration handle that should be used in
                subsequent FindNext calls.
Returns:

    1 if successful 0 if failed


Notes:

        The wildcard matching is done on both Long File Name and Short File name of an entry
        and if either one matches, the entry is returned.

--*/



int FindNextShadow(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie, LPWIN32_FIND_DATA lpFind32, LPSHADOWINFO lpSI);
/*++

Routine Description:

    This API allows callers to continue enumeration of entries in a directory in the CSC database
    begun by a FindOpenHSHADOW API call. The restrictions specified by the FindOpenHSHADOW call
    such as the wildcard pattern etc. apply to this API.


Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow passing in INVALID_HANDLE_VALUE.

    ulEnumCookie    The enumeration handle returned in lpSI->uEnumCOokie after a successful
                    FindOpenHSHADOW call.


    lpFind32    Output parameter. On return all the elements of the find strucutre are
                filled up. These represent the find32 info as obtained from the server, with any
                subsequent local modifications if any.

                The only significant timestamp is ftLastWriteTime. ftLastCreateTime is set to 0.
                ftLastAccessTime contains the timestamp of the original file/directory as
                returned by the server.

                If this is the root inode of a share, the info in the Find32 strucutre is cooked up.

    lpSI        returns all the information about the entry maintained by the CSC database.

                If hShadow a root inode of a share, (ie if hDir is 0) then the status bits in lpSI->uStatus
                are SHARE_xxx as defined in shdcom.h. eg. the bits indicate whether the
                share is connected right now, whether it has ant outstanding opens, whether
                it is operating in disconnected state etc.


Returns:

    1 if successful 0 if either the enumeration completed or some error happened. 

Notes:



--*/



int FindCloseShadow(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie);
/*++

Routine Description:

    This API frees up the resources associated with an enumeration initiated by FindOpenHSHADOW.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow appssing in INVALID_HANDLE_VALUE.

    ulEnumCookie    The enumeration handle returned in lpSI->uEnumCookie after a successful
                    FindOpenHSHADOW call.


Returns:


Notes:

--*/



int AddHint(HANDLE hShadowDB, HSHADOW hDir, TCHAR *cFileName, LPHSHADOW lphShadow, unsigned long ulHintFlags, unsigned long ulHintPri);
/*++

Routine Description:

    This API allows callers to set pincount and other flags on a database entry

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    cFileName   The name of the element on which to set the pincount.

    lphShadow   returns the Inode.

    ulHintFlags Misc flags to be set on the entry

    ulHintPri   Pincount increment. Called hintpri for historical reasons.


Returns:

    1 if successful 0 if failed

Notes:

    In the current implementation, the max pin count per entry is 255.

--*/



int DeleteHint(HANDLE hShadowDB, HSHADOW hDir, TCHAR *cFileName, BOOL fClearAll);
/*++

Routine Description:

    This API allows callers to decrement/remove pincount on a CSC database entry.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        The directory Inode value obtained from either a FindOpen/FindNext call or
                from an earlier call to a GetShadow(Ex)/CreateShadow routine, or 0 which
                indicates the root inode.

    cFileName   The name of the element on which to set the pincount.

    fClearAll   if TRUE, clears all pincounts and flags on the entry.

Returns:

    1 if successful 0 if failed

Notes:


--*/






int SetMaxShadowSpace(HANDLE hShadowDB, long nFileSizeHigh, long nFileSizeLow);
/*++

Routine Description:

    Sets the maximum size of the shadow database

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    nFileSizeHigh   The high order value of the space size

    nFileSizeLow    The Low order value of the space size

Returns:

    1 if successful 0 otherwise

Notes:

    Used by control panel shell extension to set the max space

--*/

int FreeShadowSpace(HANDLE hShadowDB, long nFileSizeHigh, long nFileSizeLow, BOOL fClearAll);
/*++

Routine Description:

    Allows the caller to free the requisite amount of space from the CSC database

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    nFileSizeHigh   The high order value of the space size to be cleared

    nFileSizeLow    The Low order value of the space size to be cleared

    fClearAll   Clear the entire database, to the extent possible. 


Returns:

    1 on success 0 on failure

Notes:

--*/



int SetShareStatus(HANDLE hShadowDB, HSHARE hShare, unsigned long uStatus, unsigned long uOp);
/*++

Routine Description:

    This API allwos the caller to set the status bits on a share.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     Represents a share in the flat name space. hShare should have been
                obtained from lpSI->hShare of a successful call to GetShadowInfoEx
                or FindOpenHShadow/FindnextHShadow

    uStatus     should have SHARE_xxx.

    uOp         specifies operation SHADOW_FLAGS_ASSIGN, SHADOW_FLAGS_AND or SHADOW_FLAGS_OR
                to do the corresponding operation between the existing status bits and the
                one passed in the uStatus parameter.

Returns:

    1 if successful 0 if failed

Notes:

    This should be used only for setting or clearing dirty bit on a share

--*/



int GetShareStatus(HANDLE hShadowDB, HSHARE hShare, unsigned long *lpulStatus);
/*++

Routine Description:

    This API allwos the caller to get the status bits set on a share.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     Represents a share in the flat name space. hShare should have been
                obtained from lpSI->hShare of a successful call to GetShadowInfoEx
                or FindOpenHShadow/FindnextHShadow

    lpuStatus   Contains SHARE_xxx on return

Returns:

    1 if successful 0 if failed

Notes:

--*/



int GetShareInfo(HANDLE hShadowDB, HSHARE hShare, LPSHAREINFO lpSVRI, unsigned long *lpulStatus);
/*++

Routine Description:

    This API allwos the caller to get the status bits set on a share as well at info about
    the filesystem it runs etc.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hShare     Represents a share in the flat name space. hShare should have been
                obtained from lpSI->hShare of a successful call to GetShadowInfoEx
                or FindOpenHShadow/FindnextHShadow

    lpSVRI      Info about the filesystem the share is running. Refer to shdcom.h

    lpuStatus   Contains SHARE_xxx on return

Returns:

    1 if successful 0 if failed

Notes:

--*/







/**************** Routines below this line for the agent and the NP ************************/


int BeginInodeTransactionHSHADOW(
    VOID
    );
/*++

Routine Description:



Arguments:


Returns:


Notes:

--*/

int EndInodeTransactionHSHADOW(
    VOID
    );
/*++

Routine Description:



Arguments:


Returns:


Notes:

--*/
int ShadowSwitches(HANDLE hShadowDB, unsigned long * lpuSwitches, unsigned long uOp);
/*++

Routine Description:



Arguments:


Returns:


Notes:

--*/



int BeginPQEnum(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:

    Begin priority Q enumeration

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow appssing in INVALID_HANDLE_VALUE.


    lpPQ        if successful, lpPQ->uEnumCookie containes the handle for enumeration


Returns:

    1 if successful 0 otherwise

Notes:

--*/



int NextPriShadow(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:

    Gets the next entry from the priority queue in the order of priority

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                This API does not allow appssing in INVALID_HANDLE_VALUE.


    lpPQ        Input: Must be the same lpPQ that was used in an earlier BeginPQEnum/NextPriShadow

                Output: If successful and lpPQ->hShadow is nono-zero then the lpPQ contains
                        the next priority queue entry. If lpPQ->hShadow is 0, then we are at
                        the end of the enumeration.

Returns:

    1 if successful 0 otherwise

Notes:


--*/



int PrevPriShadow(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EndPQEnum(HANDLE hShadowDB, LPPQPARAMS lpPQP);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/




int ChkUpdtStatus(HANDLE hShadowDB, unsigned long hDir, unsigned long hShadow, LPWIN32_FIND_DATA lpFind32, unsigned long *lpulShadowStatus);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int CopyChunk(HANDLE hShadowDB,  LPSHADOWINFO lpSI, struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/


// APIs for copying inward on NT, used only by the agent
int OpenFileWithCopyChunkIntent(HANDLE hShadowDB, LPCWSTR lpFileName,
                                struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext,
                                int ChunkSize);
int CloseFileWithCopyChunkIntent(HANDLE hShadowDB, struct tagCOPYCHUNKCONTEXT FAR *CopyChunkContext);


int BeginReint(HSHARE hShare, BOOL fBlockingReint, LPVOID *lplpReintContext);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EndReint(HSHARE hShare, LPVOID lpReintContext);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/




int RegisterAgent(HANDLE hShadowDB, HWND hwndAgent, HANDLE hEvent);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int UnregisterAgent(HANDLE hShadowDB, HWND hwndAgent);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/


int DisableShadowingForThisThread(HANDLE hShadowDB);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EnableShadowingForThisThread(HANDLE hShadowDB);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int ReinitShadowDatabase(
    HANDLE  hShadowDB,
    LPCSTR  lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR  lpszUserName,            // name of the user
    DWORD   dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize
    );

/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int EnableShadowing(
    HANDLE  hShadowDB,
    LPCSTR  lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR  lpszUserName,            // user name
    DWORD   dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize,          // clustersize for rounding database space
    BOOL    fReformat
);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

int FindOpenHint(HANDLE hShadowDB, HSHADOW hDir, LPWIN32_FIND_DATA lpFind32, CSC_ENUMCOOKIE *lpuEnumCookie, HSHADOW *hShadow, unsigned long *lpulHintFlags, unsigned long *lpulHintPri);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int FindNextHint(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie, LPWIN32_FIND_DATA lpFind32, HSHADOW *hShadow, unsigned long *lpulHintFlags, unsigned long *lpulHintPri);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



int FindCloseHint(HANDLE hShadowDB, CSC_ENUMCOOKIE uEnumCookie);
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/



AddHintFromInode(
    HANDLE          hShadowDB,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    unsigned    long    *lpulPinCount,
    unsigned    long    *lpulHintFlags
    );

/*++

Routine Description:

    The routine allows the caller to OR hintflags and increment one pincount, either for
    the system or for the user.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        Directory Inode

    hShadow     Shadow on which the hintflags are to be applied

    lpulPinCount    pincount on exit

    lpulHintFlags   inout filed, contains flags to be ORed, returns the flags on the entry
                    on a successful operation

Returns:

    1 if successful 0 if failed. It fails, if a) the pin count is about to go over MAX_PRI or
    b) it is attempting to pin it for the user but is already pinned for the user

Notes:

    Mainly for CSCPinFile's use
--*/

DeleteHintFromInode(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned    long    *lpulPinCount,
    unsigned    long    *lpulHintFlags
    );

/*++

Routine Description:

    The routine allows the caller to AND ~ of hintflags and decrement one pincount, either for
    the system or for the user.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    hDir        Directory Inode

    hShadow     Shadow on which the hintflags are to be applied

    lpulPinCount    pincount on exit

    lpulHintFlags   inout filed, contains flags whose ~ is to be ANDed, returns the flags on the entry
                    on a successful operation

Returns:

    1 if successful 0 if failed. It fails, if a) the pin count is about to go below MIN_PRI or
    b) it is attempting to unpin it for the user but isn't pinned for the user

Notes:

    Mainly for CSCPinFile's use
--*/

int DoShadowMaintenance(HANDLE hShadowDB, unsigned long uOp);
/*++

Routine Description:

    The routine allows the caller to perform various maitenance tasks.

Arguments:

    hShadowDB   Handle to the shadow database as obtained from OpenShadowDatabaseIO.
                if INVALID_HANDLE_VALUE is passed in, the API, opens the shadow database,
                issues the corresponding ioctl, and closes it before returning.

    uOp         Various operations to perform.



Returns:

    1 if successful 0 if failed

Notes:

    Mainly for agents purposes, shouldn't be used by UI
--*/


BOOL
IsNetDisconnected(
    DWORD dwErrorCode
);
/*++

Routine Description:

    The routine checks from the errocode whether the net is disconnected

Arguments:

    dwErrorCode one of the codes defined in winerror.h

Returns:

    TRUE if net is disconnected, FALSE otherwise

Notes:

    A central place for all CSC users of lib3, to know whether net is disconnected

--*/

BOOL
PurgeUnpinnedFiles(
    HANDLE hShadowDB,
    LONG Timeout,
    PULONG pnFiles,
    PULONG pnYoungFiles);

BOOL
ShareIdToShareName(
    HANDLE hShadowDB,
    ULONG ShareId,
    PBYTE pBuffer,
    PDWORD pBufSize);

BOOL
CopyShadow(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    TCHAR   *lpFileName
);
/*++

Routine Description:

    The routine makes a copy of an inode file in the CSC database

Arguments:

    hDir        Directory Inode

    hShadow     Inode whose copy is wanted

    lpFileName  Fully qualified local path of the filename to be given to the copy

Returns:

    TRUE if the copy succeeded.

Notes:

    Useful for backup/dragdrop etc.

--*/


LPCOPYPARAMSW
LpAllocCopyParamsW(
    VOID
);

VOID
FreeCopyParamsW(
    LPCOPYPARAMSW lpCP
);

LPCOPYPARAMSA
LpAllocCopyParamsA(
    VOID
);

VOID
FreeCopyParamsA(
    LPCOPYPARAMSA lpCP
);

int
GetSecurityInfoForCSC(
    HANDLE          hShadowDB,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPSECURITYINFO  lpSecurityInfo,
    DWORD           *lpdwBufferSize
    );

int
FindCreatePrincipalIDFromSID(
    HANDLE  hShadowDB,
    LPVOID  lpSidBuffer,
    ULONG   cbSidLength,
    ULONG   *lpuPrincipalID,
    BOOL    fCreate
    );

BOOL
SetExclusionList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    );

BOOL
SetBandwidthConservationList(
    HANDLE  hShadowDB,
    LPWSTR  lpwList,
    DWORD   cbSize
    );

BOOL
TransitionShareToOffline(
    HANDLE  hShadowDB,
    HSHARE hShare,
    BOOL    fTransition
    );
BOOL
TransitionShareToOnline(
    HANDLE   hShadowDB,
    HSHARE   hShare
    );

BOOL
IsServerOfflineW(
    HANDLE  hShadowDB,
    LPCWSTR lptzServer,
    BOOL    *lpfOffline
    );

BOOL
IsServerOfflineA(
    HANDLE  hShadowDB,
    LPCSTR  lptzServer,
    BOOL    *lpfOffline
    );

int GetShadowDatabaseLocation(
    HANDLE              hShadowDB,
    WIN32_FIND_DATA    *lpFind32
    );

int
GetSpaceStats(
    HANDLE  hShadowDB,
    SHADOWSTORE *lpsST
);

BOOL
GetNameOfServerGoingOfflineW(
    HANDLE      hShadowDB,
    LPBYTE      lpBuffer,
    LPDWORD     lpdwSize
    );

BOOL
RenameShadow(
    HANDLE  hShadowDB,
    HSHADOW hDirFrom,
    HSHADOW hShadowFrom,
    HSHADOW hDirTo,
    LPWIN32_FIND_DATAW   lpFind32,
    BOOL    fReplaceFileIfExists,
    HSHADOW *lphShadowTo
    );

BOOL
GetSparseStaleDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    );

BOOL
GetManualFileDetectionCounter(
    HANDLE  hShadowDB,
    LPDWORD lpdwCounter
    );

int EnableShadowingForUser(
    HANDLE    hShadowDB,
    LPCSTR    lpszDatabaseLocation,    // location of the shadowing directory
    LPCSTR    lpszUserName,            // name of the user
    DWORD    dwDefDataSizeHigh,        // cache size if being created for the first time
    DWORD    dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat
);

int DisableShadowingForUser(
    HANDLE    hShadowDB
);

HANDLE
OpenShadowDatabaseIOex(
    ULONG WaitForDriver, 
    DWORD dwFlags);

BOOL
RecreateShadow(
    HANDLE  hShadowDB,
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttrib
    );

BOOL
SetDatabaseStatus(
    HANDLE  hShadowDB,
    ULONG   ulStatus,
    ULONG   uMask
    );
    
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\oslayeru.h ===
#define  COPY_BUFF_SIZE 4096

#define BCS_OEM     1
#define BCS_UNI     2

#define ACCESS_MODE_MASK    0x0007  /* Mask for access mode bits */
#define ACCESS_READONLY     0x0000  /* open for read-only access */
#define ACCESS_WRITEONLY    0x0001  /* open for write-only access */
#define ACCESS_READWRITE    0x0002  /* open for read and write access */
#define ACCESS_EXECUTE      0x0003  /* open for execute access */

#define SHARE_MODE_MASK     0x0070  /* Mask for share mode bits */
#define SHARE_COMPATIBILITY 0x0000  /* open in compatability mode */
#define SHARE_DENYREADWRITE 0x0010  /* open for exclusive access */
#define SHARE_DENYWRITE     0x0020  /* open allowing read-only access */
#define SHARE_DENYREAD      0x0030  /* open allowing write-only access */
#define SHARE_DENYNONE      0x0040  /* open allowing other processes access */
#define SHARE_FCB           0x0070  /* FCB mode open */

/** Values for ir_options for VFN_OPEN: */

#define ACTION_MASK             0xff    /* Open Actions Mask */
#define ACTION_OPENEXISTING     0x01    /* open an existing file */
#define ACTION_REPLACEEXISTING  0x02    /* open existing file and set length */
#define ACTION_CREATENEW        0x10    /* create a new file, fail if exists */
#define ACTION_OPENALWAYS       0x11    /* open file, create if does not exist */
#define ACTION_CREATEALWAYS     0x12    /* create a new file, even if it exists */

/** Alternate method: bit assignments for the above values: */

#define ACTION_EXISTS_OPEN  0x01    // BIT: If file exists, open file
#define ACTION_TRUNCATE     0x02    // BIT: Truncate file
#define ACTION_NEXISTS_CREATE   0x10    // BIT: If file does not exist, create


#define OPEN_FLAGS_NOINHERIT                    0x0080
//#define OPEN_FLAGS_NO_CACHE       R0_NO_CACHE  /* 0x0100 */
#define OPEN_FLAGS_NO_COMPRESS                  0x0200
#define OPEN_FLAGS_ALIAS_HINT                   0x0400
#define OPEN_FLAGS_REOPEN                       0x0800
#define OPEN_FLAGS_RSVD_1                       0x1000 /* NEVER #define this */
#define OPEN_FLAGS_NOCRITERR                    0x2000
#define OPEN_FLAGS_COMMIT                       0x4000
#define OPEN_FLAGS_RSVD_2                       0x8000 /* NEVER #define this */
#define OPEN_FLAGS_EXTENDED_SIZE            0x00010000
#define OPEN_FLAGS_RAND_ACCESS_HINT         0x00020000
#define OPEN_FLAGS_SEQ_ACCESS_HINT          0x00040000
#define OPEN_EXT_FLAGS_MASK                 0x00FF0000
#define  ATTRIB_DEL_ANY     0x0007   // Attrib passed to ring0 delete


#define FLAG_RW_OSLAYER_INSTRUMENT      0x00000001
#define FLAG_RW_OSLAYER_PAGED_BUFFER    0x00000002

typedef HANDLE   CSCHFILE;
typedef int (*PATHPROC)(USHORT *, USHORT *, LPVOID);

#define CSCHFILE_NULL   0

//typedef USHORT        USHORT;
//typedef ULONG     ULONG;

#define _FILETIME           FILETIME
#define _WIN32_FIND_DATA    WIN32_FIND_DATA
#define string_t            unsigned short *

#define FILE_ATTRIBUTE_ALL (FILE_ATTRIBUTE_READONLY| FILE_ATTRIBUTE_HIDDEN \
                           | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY \
                           | FILE_ATTRIBUTE_ARCHIVE)

#define  IsFile(dwAttr) (!((dwAttr) & (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE)))

#define CheckHeap(a) {;}

#define GetLastErrorLocal() GetLastError()
#define SetLastErrorLocal(X) SetLastError(X)

#ifndef KdPrint
#ifdef DEBUG
#define KdPrint(X)  PrintFn X
#else
#define KdPrint(X)
#endif
#endif

CSCHFILE CreateFileLocal(LPSTR lpName);
CSCHFILE OpenFileLocal(LPSTR lpName);
int DeleteFileLocal(LPSTR lpName, USHORT usAttrib);
int FileExists (LPSTR lpName);
long ReadFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff,  long lCount);
long WriteFileLocal (CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount);
long WriteFileInContextLocal (CSCHFILE, ULONG, LPVOID, long);
ULONG CloseFileLocal (CSCHFILE handle);
ULONG CloseFileLocalFromHandleCache (CSCHFILE handle);
int GetFileSizeLocal (CSCHFILE, PULONG);
int GetDiskFreeSpaceLocal(int indx
   , ULONG *lpuSectorsPerCluster
   , ULONG *lpuBytesPerSector
   , ULONG *lpuFreeClusters
   , ULONG *lpuTotalClusters
   );

int GetAttributesLocal (LPSTR, ULONG *);
int GetAttributesLocalEx (LPSTR lpPath, BOOL fFile, ULONG *lpuAttr);
int SetAttributesLocal (LPSTR, ULONG);
int RenameFileLocal (LPSTR, LPSTR);
int FileLockLocal(CSCHFILE, ULONG, ULONG, ULONG, BOOL);

LPVOID AllocMem (ULONG uSize);
VOID FreeMem (LPVOID lpBuff);
//VOID CheckHeap(LPVOID lpBuff);
LPVOID AllocMemPaged (ULONG uSize);
VOID FreeMemPaged(LPVOID lpBuff);

CSCHFILE R0OpenFile (USHORT usOpenFlags, UCHAR bAction, LPSTR lpPath);

CSCHFILE OpenFileLocalEx(LPSTR lpPath, BOOL fInstrument);
long ReadFileLocalEx
    (
    CSCHFILE handle,
    ULONG pos,
    LPVOID pBuff,
    long  lCount,
    BOOL    fInstrument
    );
long WriteFileLocalEx(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, BOOL fInstrument);
CSCHFILE R0OpenFileEx
    (
    USHORT  usOpenFlags,
    UCHAR   bAction,
    ULONG   ulAttr,
    LPSTR   lpPath,
    BOOL    fInstrument
    );
long ReadFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, ULONG flags);
long WriteFileLocalEx2(CSCHFILE handle, ULONG pos, LPVOID lpBuff, long lCount, ULONG flags);

int HexToA(ULONG ulHex, LPSTR lpBuff, int count);
ULONG AtoHex(LPSTR lpBuff, int count);
int wstrnicmp(const USHORT *, const USHORT *, ULONG);
ULONG strmcpy(LPSTR, LPSTR, ULONG);
int DosToWin32FileSize(ULONG, int *, int *);
int Win32ToDosFileSize(int, int, ULONG *);
int CompareTimes(_FILETIME, _FILETIME);
int CompareSize(long nHighDst, long nLowDst, long nHighSrc, long nLowSrc);
LPSTR mystrpbrk(LPSTR, LPSTR);

int CompareTimesAtDosTimePrecision( _FILETIME ftDst,
   _FILETIME ftSrc
   );

VOID
IncrementFileTime(
    _FILETIME *lpft
    );
unsigned int
UniToBCS (
     unsigned char  *pStr,
     unsigned short *pUni,
     unsigned int length,
     unsigned int maxLength,
     int charSet
);
unsigned int
BCSToUni (
     unsigned short *pUni,
     unsigned char  *pStr,
     unsigned int length,
     int charSet
);

ULONG wstrlen(
     USHORT *lpuStr
     );

int
PUBLIC
mystrnicmp(
    LPCSTR pStr1,
    LPCSTR pStr2,
    unsigned count
    );


int CreateDirectoryLocal(
    LPSTR   lpszPath
    );


ULONG
GetTimeInSecondsSince1970(
    VOID
    );

BOOL
IterateOnUNCPathElements(
    USHORT  *lpuPath,
    PATHPROC lpfn,
    LPVOID  lpCookie
    );

BOOL
IsPathUNC(
    USHORT      *lpuPath,
    int         cntMaxChars
    );


#define JOE_DECL_PROGRESS()
#define JOE_INIT_PROGRESS(counter,nearargs)
#define JOE_PROGRESS(bit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\port32.h ===
#ifdef WIN32

// Shouldn't be using these things.
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

#define GetWindowInt    GetWindowLong
#define SetWindowInt    SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)

#define CopyIcon(hInst, hIcon)                 CopyIcon(hIcon)
#define LOADICONEX(hInst, hInst2, a, b, c, d)  LoadIconEx(hInst2, a, b, c, d)
#define SHELLEXECUTE(a, b, c, d, e, f)         ShellExecuteEx(a, b, c, d, e, NULL, f)

#define ISVALIDLIBRARY(hLib)            (hLib != NULL)

#else  // WIN32

#define ISLPTR(pv)      (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

#define GetWindowInt    GetWindowWord
#define SetWindowInt    SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define LOADICONEX(hInst, hInst2, a, b, c, d)  LoadIconEx(hInst, hInst2, a, b, c, d)
#define SHELLEXECUTE(a, b, c, d, e, f)         ShellExecute(a, b, c, d, e, f)

#define ISVALIDLIBRARY(hLib)            (hLib >= HINSTANCE_ERROR)

#endif // WIN32

#ifdef WIN32

/*****************************************************************************\
* PWIN32.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 32 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/

/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v32)
#define MAPTYPE(v16, v32)               v32
#define MAKEMPOINT(l)                   (*((MPOINT *)&(l)))
#define MPOINT2POINT(mpt,pt)            ((pt).x = (mpt).x, (pt).y = (mpt).y)
#define POINT2MPOINT(pt, mpt)           ((mpt).x = (SHORT)(pt).x, (mpt).y = (SHORT)(pt).y)
#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))

#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowLong(hwnd, index, (LONG)(ui))
#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowLong(hwnd, index)
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassLong(hwnd, index, (LONG)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassLong(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCL_CBWNDEXTRA)     
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCL_CBWNDEXTRA, cb) 
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCL_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCL_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCL_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCL_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCL_HMODULE)            
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCL_HMODULE, h) 
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCL_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCL_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCL_STYLE)            
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCL_STYLE, style) 
#define GETHWNDINSTANCE(hwnd)           (HINSTANCE)GETWINDOWUINT((hwnd), GWL_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HINSTANCE)SETWINDOWUINT((hwnd), GWL_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWL_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWL_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWL_ID)            
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWL_ID, id) 

#else

/*****************************************************************************\
* PWIN16.H - PORTABILITY MAPPING HEADER FILE
*
* This file provides macros to map portable windows code to its 16 bit form.
\*****************************************************************************/

/*-----------------------------------USER------------------------------------*/
 
/* HELPER MACROS */

#define MAPVALUE(v16, v32)              (v16)
#define MAPTYPE(v16, v32)               v16
#define MAKEMPOINT(l)                   (*((MPOINT FAR *)&(l)))
#define MPOINT2POINT(mpt, pt)           (pt = *(POINT FAR *)&(mpt))
#define POINT2MPOINT(pt, mpt)           (mpt = *(MPOINT FAR *)&(pt))
#define LONG2POINT(l, pt)               ((pt).x = (INT)LOWORD(l), (pt).y = (INT)HIWORD(l))

#define GETWINDOWUINT(hwnd, index)      (UINT)GetWindowWord(hwnd, index)
#define SETWINDOWUINT(hwnd, index, ui)  (UINT)SetWindowWord(hwnd, index, (WORD)(ui))
#define SETCLASSUINT(hwnd, index, ui)   (UINT)SetClassWord(hwnd, index, (WORD)(ui))
#define GETCLASSUINT(hwnd, index)       (UINT)GetClassWord(hwnd, index)

#define GETCBCLSEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBCLSEXTRA)
#define SETCBCLSEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBCLSEXTRA, cb)
#define GETCBWNDEXTRA(hwnd)             GETCLASSUINT(hwnd, GCW_CBWNDEXTRA)     
#define SETCBWNDEXTRA(hwnd, cb)         SETCLASSUINT(hwnd, GCW_CBWNDEXTRA, cb) 
#define GETCLASSBRBACKGROUND(hwnd)      (HBRUSH)GETCLASSUINT(hwnd, GCW_HBRBACKGROUND)
#define SETCLASSBRBACKGROUND(hwnd, h)   (HBRUSH)SETCLASSUINT(hwnd, GCW_HBRBACKGROUND, h)
#define GETCLASSCURSOR(hwnd)            (HCURSOR)GETCLASSUINT(hwnd, GCW_HCURSOR)
#define SETCLASSCURSOR(hwnd, h)         (HCURSOR)SETCLASSUINT(hwnd, GCW_HCURSOR, h)
#define GETCLASSHMODULE(hwnd)           (HMODULE)GETCLASSUINT(hwnd, GCW_HMODULE)            
#define SETCLASSHMODULE(hwnd, h)        (HMODULE)SETCLASSUINT(hwnd, GCW_HMODULE, h) 
#define GETCLASSICON(hwnd)              (HICON)GETCLASSUINT((hwnd), GCW_HICON)
#define SETCLASSICON(hwnd, h)           (HICON)SETCLASSUINT((hwnd), GCW_HICON, h)
#define GETCLASSSTYLE(hwnd)             GETCLASSUINT((hwnd), GCW_STYLE)            
#define SETCLASSSTYLE(hwnd, style)      SETCLASSUINT((hwnd), GCW_STYLE, style) 
#define GETHWNDINSTANCE(hwnd)           (HMODULE)GETWINDOWUINT((hwnd), GWW_HINSTANCE)
#define SETHWNDINSTANCE(hwnd, h)        (HMODULE)SETWINDOWUINT((hwnd), GWW_HINSTANCE, h)
#define GETHWNDPARENT(hwnd)             (HWND)GETWINDOWUINT((hwnd), GWW_HWNDPARENT)
#define SETHWNDPARENT(hwnd, h)          (HWND)SETWINDOWUINT((hwnd), GWW_HWNDPARENT, h)
#define GETWINDOWID(hwnd)               GETWINDOWUINT((hwnd), GWW_ID)            
#define SETWINDOWID(hwnd, id)           SETWINDOWUINT((hwnd), GWW_ID, id) 

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\clregs.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

#ifndef CSC_RECORDMANAGER_WINNT
typedef	union UserRegs UserRegs, *pUserRegs, *PUSERREGS;
union UserRegs {
	struct Client_Reg_Struc			r;	// DWord register layout
	struct Client_Word_Reg_Struc	w;	// Access word registers
	struct Client_Byte_Reg_Struc	b;	// Access byte registers
};	/* UserRegs */

#endif //ifndef CSC_RECORDMANAGER_WINNT

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\shdsys.h ===
/*

	Copyright 1991-1993 Microsoft Corporation.  All rights reserved.
	Microsoft Confidential.

	Common macros - internal use only; subincludes several .h files

*/

#ifndef _INCLUDE_SHDSYSH
#define _INCLUDE_SHDSYSH

/******************* Controlling Defines ************************************/
// define DEBUG unless explicitly asked not to:

#ifndef NONDEBUG
#ifndef DEBUG
#define DEBUG
#endif //DEBUG
#endif //NONDEBUG

#define VSZDD					// add vszDDxx strings in DDErr

/******************* Includes ***********************************************/
#ifndef _INC_WINDOWS
#include <windows.h>
#endif //_INC_WINDOWS

#include <stdlib.h>
#include <string.h>			// for string macros
#include <limits.h>			// implementation dependent values


/******************* Defines ************************************************/
#define cbSzTMax				256	// size of temp string buffers
#define cbSzRcMax				256	// max size of RC strings
#define cbSzNameMax			32		// max size of app name, class names, etc

#ifdef CHICAGO
#define cbSzFileMax			260	// max size of file names for Chicago
#else	// WIN31
#define cbSzFileMax			128	// max size of file names
#endif //CHICAGO

#ifndef TRUE
#define TRUE					1
#endif //TRUE

#ifndef FALSE
#define FALSE					0
#endif //FALSE

#define fTrue					TRUE	// alias
#define fFalse					FALSE	// alias
#define wDontCare				1
#define lDontCare				1L
#define lpszNull				((LPSTR)NULL)

/******************* Calling Conventions ************************************/

/* Exported functions: FAR PASCAL, LOADDS if BUILDDLL is defined

	WINAPI		Documented API (see windows.h)
	CALLBACK		DlgProc, WndProc, DriverProc, ResultsFunction (see windows.h)
	EXPORT		Internal system entry point (e.g. PenAboutBoxFn)
*/

#define EXPORT					WINAPI


/*	Internal functions, not exported:

	PUBLIC		FAR PASCAL (NEAR if SMALL)
					Called internally from several functional areas

	FASTPUBLIC	FAR _fastcall (NEAR if SMALL)
					Called internally from several functional areas;
					few arguments, no far ptrs, NOT exported

	FARPRIVATE	FAR PASCAL
					Called internally from one or few functional areas
		
	PRIVATE		NEAR PASCAL
					Called internally from same file

	FASTPRIVATE	NEAR _fastcall
					Called internally from same file;
					few arguments, no far ptrs, NOT exported

	IWINAPI		FAR PASCAL [LOADDS]
					For exclusive use by parameter validation layer;
					this is NOT exported (e.g. ITPtoDP)
*/

#ifdef SMALL
#ifndef PUBLIC
#define PUBLIC					NEAR PASCAL
#endif
#define FASTPUBLIC			NEAR _fastcall

#else // !SMALL
#ifndef PUBLIC
#define PUBLIC					FAR PASCAL
#endif
#define FASTPUBLIC			FAR _fastcall

#endif //SMALL

#define FARPRIVATE			FAR PASCAL
#ifndef PRIVATE
#define PRIVATE				NEAR PASCAL
#endif
#define FASTPRIVATE			NEAR _fastcall

#define IWINAPI				WINAPI

// for compatability only, in DLLs compiled without -Gw:
#define DLLEXPORT				FAR PASCAL _loadds


/******************* Generic Macros *****************************************/

#ifndef RC_INVOKED			// BLOCK is used in .rc version stamping
#define BLOCK
#endif //!RC_INVOKED

#define NOREF
#define Unref(var)			var;

#undef SetFlag
#undef ToggleFlag
#undef ResetFlag

// flag setting and testing (multiple flags ok):
#define SetFlag(w, flags)		do {(w) |= (flags);} while (0)
#define ToggleFlag(w, flags)	do {(w) ^= (flags);} while (0)
#define ResetFlag(w, flags)		do {(w) &= ~(flags);} while (0)

// tests: FFlag is common (T if any flag), FExactFlag is rare (all flags req):
#define FFlag(w, flags)			(BOOL)(((w) & (flags)) != 0)
#define FExactFlag(w, flags)	(BOOL)(((w) & (flags)) == (flags))

/******************* User Macros ********************************************/

/******************* Mem Macros *********************************************/

#define SG(x)					_based(_segname("_" #x))

#define CODECONST				SG(CODE)

// extra debug info: local name of function
#ifdef DEBUG
#define ThisFnIs(sz)\
	static char CODECONST szThisFn[] = sz;\
	static LPCSTR CODECONST lpszThisFn = szThisFn
#else
#define ThisFnIs(sz)	// nothing
#define lpszThisFn	NULL
#endif //DEBUG

#ifdef DEBUG
#define AssertSameSeg(x1,x2) (HIWORD((LPVOID)(x1))==HIWORD((LPVOID)(x2)))
#else
#define AssertSameSeg(x1, x2)
#endif //DEBUG

// handle from ptr (from windowsx.h):
#ifndef GlobalPtrHandle
#define GlobalPtrHandle(lp)\
	((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))
#endif

#define LocalUnlockFree(hMem) \
	do {\
	BOOL fErr = LocalUnlock(hMem);\
	HLOCAL h = LocalFree(hMem);\
	Assert(!fErr && !h);\
	hMem = (HLOCAL)NULL;\
	} while (0)

#define GlobalUnlockFree(hMem) do {\
	BOOL fErr = GlobalUnlock(hMem);\
	HGLOBAL h = GlobalFree(hMem);\
	Assert(!fErr && !h);\
	hMem = (HGLOBAL)NULL;\
	} while (0)


// mX macros return BOOL success of operation (and put dbg sz);
// for example: if (!mGlobalFree(hMem)) goto endFn;


#ifdef DEBUG
#define mGlobalAlloc(hglb, fuAlloc, cbAlloc) \
	(((HGLOBAL)hglb = GlobalAlloc(fuAlloc, cbAlloc)) != NULL \
	|| OOMSz(vszDDGlobalAlloc))

#define mGlobalReAlloc(hglbNew, hglb, cbNewSize, fuAlloc) \
	(((HGLOBAL)hglbNew = GlobalReAlloc((HGLOBAL)(hglb), cbNewSize, fuAlloc)) != NULL \
	|| OOMSz(vszDDGlobalReAlloc))

#define mGlobalLock(lpv, hglb) \
	(((LPVOID)lpv = GlobalLock((HGLOBAL)(hglb))) != NULL \
	|| PanicSz(vszDDGlobalLock))

#define mGlobalUnlock(hglb) \
	(!GlobalUnlock((HGLOBAL)(hglb)) || DbgSz(vszDDGlobalUnlock))

#define mGlobalFree(hglb) \
	(GlobalFree((HGLOBAL)(hglb)) == NULL || DbgSz(vszDDGlobalFree))


#define mLocalAlloc(hloc, fuAlloc, cbAlloc) \
	(((HLOCAL)hloc = LocalAlloc(fuAlloc, cbAlloc)) != NULL \
	|| OOMSz(vszDDLocalAlloc))

#define mLocalReAlloc(hlocNew, hloc, cbNewSize, fuAlloc) \
	(((HLOCAL)hlocNew = LocalReAlloc((HLOCAL)(hloc), cbNewSize, fuAlloc)) != NULL \
	|| OOMSz(vszDDLocalReAlloc))

#define mLocalLock(lpv, hloc) \
	(((LPVOID)lpv = LocalLock((HLOCAL)(hloc))) != NULL \
	|| PanicSz(vszDDLocalLock))

#define mLocalUnlock(hloc) \
	(!LocalUnlock((HLOCAL)(hloc)) || DbgSz(vszDDLocalUnlock))

#define mLocalFree(hloc) \
	(LocalFree((HLOCAL)(hloc)) == NULL)

#else

#define mGlobalAlloc(hglb, fuAlloc, cbAlloc) \
	(((HGLOBAL)hglb = GlobalAlloc(fuAlloc, cbAlloc)) != NULL)

#define mGlobalReAlloc(hglbNew, hglb, cbNewSize, fuAlloc) \
	(((HGLOBAL)hglbNew = GlobalReAlloc((HGLOBAL)(hglb), cbNewSize, fuAlloc)) != NULL)

#define mGlobalLock(lpv, hglb) \
	(((LPVOID)lpv = GlobalLock((HGLOBAL)(hglb))) != NULL)

#define mGlobalUnlock(hglb) \
	(!GlobalUnlock((HGLOBAL)(hglb)))

#define mGlobalFree(hglb) \
	(GlobalFree((HGLOBAL)(hglb)) == NULL)


#define mLocalAlloc(hloc, fuAlloc, cbAlloc) \
	(((HLOCAL)hloc = LocalAlloc(fuAlloc, cbAlloc)) != NULL)

#define mLocalReAlloc(hlocNew, hloc, cbNewSize, fuAlloc) \
	(((HLOCAL)hlocNew = LocalReAlloc((HLOCAL)(hloc), cbNewSize, fuAlloc)) != NULL)

#define mLocalLock(lpv, hloc) \
	(((LPVOID)lpv = LocalLock((HLOCAL)(hloc))) != NULL)

#define mLocalUnlock(hloc) \
	(!LocalUnlock((HLOCAL)(hloc)))

#define mLocalFree(hloc) \
	(LocalFree((HLOCAL)(hloc)) == NULL)

#endif //DEBUG




/******************* Gdi Macros *********************************************/

// delete GDI object if non NULL:
#define AssertDelObj(hobj) \
	do {\
	if (hobj && IsGDIObject(hobj)) {\
		BOOL fOk = DeleteObject(hobj);\
		Assert(fOk);\
	}\
	hobj = (HANDLE)0;\
	} while (0)

#define IsValidRect(lpr) \
	((lpr) \
	&& sizeof(*(lpr))==sizeof(RECT) \
	&& (lpr)->right >= (lpr)->left \
	&& (lpr)->bottom >= (lpr)->top)

#define IsValidNonemptyRect(lpr) \
	(IsValidRect(lpr) && !IsRectEmpty((CONST LPRECT)lpr))

/******************* String Macros ******************************************/
/* String macros. */

// If compiling an app small/medium model, then should use more efficient
//	near pointer version of

// this hack err... software innovation works quite well with models
// and National Language support to reduce duplication
#ifdef JAPAN
#define StrNlsPrefix()		j
#else
#define StrNlsPrefix()		
#endif //JAPAN

#ifdef SMALLSTRING
#define StrModelPrefix()	
#else
#define StrModelPrefix()	_f
#endif //SMALLSTRING

/*	These are the macros which have to have different implementations
	based on language (at least for DBCS) and model.

	These macros can be replaced transparently to deal with DBCS
	(without any changes in an app and without breaking any assuptions
	made by an app). Others such as strlen and strncmp have 2 flavors
	byte-oriented and logical character oriented. There will have
	to be new macro names defined for logical charcters since the apps
	currently assume byte orientation.
*/

#define SzStrStr(sz1,sz2)				StrModelPrefix() ##				\
	StrNlsPrefix() ## strstr(sz1, sz2)
#define SzStrCh(sz1,ch)					StrModelPrefix() ##				\
	StrNlsPrefix() ## strchr(sz1, ch)
#define SzStrTok(sz1,sz2)				StrModelPrefix() ##				\
	StrNlsPrefix() ## strtok(sz1,sz2)

/*	These macros are currently independent of language do not
	understand DBCS and are byte oriented. Refer above.
	StrModelPrefix is used here to create a single definition for
	multiple models.
*/

#define CbSizeSz(sz)						StrModelPrefix() ## strlen(sz)
#define SzCat(sz1,sz2)					StrModelPrefix() ## strcat(sz1,sz2)
#define SzNCat(sz1,sz2,n)				StrModelPrefix() ## strncat(sz1,sz2,n)
#define SzCopy(sz1,sz2)					StrModelPrefix() ## strcpy(sz2,sz1)
#define SzNCopy(sz1,sz2,n)				StrModelPrefix() ## strncpy(sz2,sz1,n)
#define FillBuf(sz,ch,c)				StrModelPrefix() ## memset(sz,ch,c)
#define FIsLpvEqualLpv(lpv1,lpv2,cb) (BOOL)(StrModelPrefix() ## 			\
	memcmp((LPVOID)(lpv1), (LPVOID)(lpv2), cb) == 0)
#define FIsSzEqualSzN(sz1,sz2,n)		(BOOL)(StrModelPrefix() ## 			\
	strnicmp(sz1,sz2,n) == 0)
#define Bltbyte(rgbSrc,rgbDest,cb)	StrModelPrefix() ## 						\
	memmove(rgbDest, rgbSrc, cb)
#define PvFindCharInBuf(pv,ch,cb)	StrModelPrefix() ## memchr(pv, ch, cb)

// model independent, language-independent (DBCS aware) macros
#define FIsSzEqualSz(sz1,sz2)			(BOOL)(lstrcmpi(sz1,sz2) == 0)
#define FIsSz1LessThanSz2(sz1,sz2)	(BOOL)(lstrcmpi(sz1,sz2) < 0)
#define FIsCaseSzEqualSz(sz1,sz2)	(BOOL)(lstrcmp(sz1,sz2) == 0)
#define SzFromInt(sz,w)					(wsprintf((LPSTR)sz, (LPSTR)"%d", w), (LPSTR)sz)
#define FLenSzLessThanCb(sz, cb)		(BOOL)(PvFindCharInBuf(sz, 0, cb) != NULL)

#ifdef SMALLSTRING
#define IntFromSz(sz)					atoi(sz)
#endif //SMALLSTRING


/******************* Typedefs ***********************************************/
typedef int						INT;	// alias
typedef int						RS;	// Resource String
typedef unsigned long      ulong;
typedef unsigned short     ushort;

#ifndef  VXD
typedef  LPSTR LPPATH;
#endif


#endif //_INCLUDE_SHDSYSH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\timelog.h ===
#define TIMELOG_EditRecordEx                    0
#define TIMELOG_AddFileRecordFR                 1
#define TIMELOG_DeleteFileRecFromInode          2
#define TIMELOG_FindFileRecord                  3
#define TIMELOG_UpdateFileRecordFR              4
#define TIMELOG_AddPriQRecord                   5
#define TIMELOG_DeletePriQRecord                6
#define TIMELOG_FindPriQRecordInternal          7
#define TIMELOG_SetPriorityForInode             8

#define TIMELOG_CreateShadowInternal            9
#define TIMELOG_GetShadow                       10
#define TIMELOG_GetShadowInfo                   11
#define TIMELOG_SetShadowInfoInternal           12
#define TIMELOG_ChangePriEntryStatusHSHADOW     13
#define TIMELOG_MRxSmbCscCreateShadowFromPath   14
#define TIMELOG_MRxSmbGetFileInfoFromServer     15
#define TIMELOG_EditRecordEx_OpenFileLocal      16
#define TIMELOG_EditRecordEx_Lookup             17
#define TIMELOG_KeAttachProcess_R0Open          18
#define TIMELOG_IoCreateFile_R0Open             19
#define TIMELOG_KeDetachProcess_R0Open          20
#define TIMELOG_KeAttachProcess_R0Read          21
#define TIMELOG_R0ReadWrite                     22
#define TIMELOG_KeDetachProcess_R0Read          23
#define TIMELOG_FindQRecordInsertionPoint_Addq  24
#define TIMELOG_LinkQRecord_Addq                25
#define TIMELOG_UnlinkQRecord_Addq              26
#define TIMELOG_FindQRecordInsertionPoint_Addq_dir  27
#define TIMELOG_EditRecordEx_ValidateHeader                  28
#define TIMELOG_EditRecordEx_Data                29

#define TIMELOG_MAX                             30


#ifdef DEBUG

#ifdef CSC_RECORDMANAGER_WINNT
#define BEGIN_TIMING(indx)  {LARGE_INTEGER   llTimeBegin;\
                             KeQuerySystemTime(&llTimeBegin);\
                             rgllTimeArray[TIMELOG_##indx] -= llTimeBegin.QuadPart;}

#define END_TIMING(indx)    {LARGE_INTEGER   llTimeEnd;\
                             KeQuerySystemTime(&llTimeEnd);\
                             rgllTimeArray[TIMELOG_##indx] += llTimeEnd.QuadPart;}

extern  LONGLONG rgllTimeArray[TIMELOG_MAX];
#else
#define BEGIN_TIMING(indx)  ;

#define END_TIMING(indx)    ;

#endif

#else

#define BEGIN_TIMING(indx)  ;

#define END_TIMING(indx)    ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\assert.h ===
/* Routines for debugging and error messages. */

#ifdef VxD
#define AssertFn  IFSMgr_AssertFailed
#define PrintFn   IFSMgr_Printf
#else
#define AssertFn  AssertFn
#define PrintFn   PrintFn
#endif

#ifdef DEBUG


#define AssertData static char szFileAssert[] = __FILE__;
#define AssertError static char szError[] = "Error";
#define Assert(f)  do {if (!(f)) AssertFn(szError, szFileAssert, __LINE__);} while(0)
#define AssertSz(f, sz)  do {if (!(f)) AssertFn(sz, szFileAssert, __LINE__);} while(0)
//BUGBUG this way of handling dbgprint is not very good....it can cause side effects in some cases.
//also, it doesn't work at all for NT. the whole of the sources should be munged-->KdPrint
//also, this is just cookie cutter code......since it's in the vxd directory it's unlikely to be called
//without defined(VxD)
#define DbgPrint  PrintFn
#else

#define Assert(f)
#define AssertData
#define AssertError
#define AssertSz(f, sz)
//BUGBUG see above
#define DbgPrint
#endif


#ifdef Vxd
void IFSMgr_AssertFailed(PCHAR pMsg, PCHAR pFile, ULONG uLine);
void IFSMgr_Printf(PCHAR pFmt, ...);
#else
VOID AssertFn(PCHAR pMsg, PCHAR pFile, ULONG uLine);
VOID PrintFn(PCHAR pFmt, ...);
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\inc\shdcom.h ===
#ifndef __SHDCOM_H__
#define __SHDCOM_H__

/* Common definitions, needed by Ring0 and Ring3 code */

#define CSC_DATABASE_VERSION    0x00010005  // major # in higher WORD, minor # in lower word

#define MIN_SPARSEFILL_PRI   1
#define MAX_SERVER_SHARE_NAME_FOR_CSC   64


#ifndef  WM_USER
#define  WM_USER                 0x400
#endif

#define  WM_FILE_OPENS           (WM_USER+1)
#define  WM_SHADOW_ADDED         (WM_USER+2)
#define  WM_SHADOW_DELETED       (WM_USER+3)
#define  WM_SHARE_DISCONNECTED  (WM_USER+4)


#define  WM_DIRTY    WM_USER+100
#define  WM_STALE    WM_USER+101
#define  WM_SPARSE   WM_USER+102

#ifndef IOCTL_RDR_BASE
#define IOCTL_RDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM
#endif //ifndef IOCTL_RDR_BASE

#define SHADOW_IOCTL_ENUM_BASE 1000
#define _SHADOW_IOCTL_CODE(__enum) \
                CTL_CODE(IOCTL_RDR_BASE,SHADOW_IOCTL_ENUM_BASE+__enum, METHOD_NEITHER, FILE_ANY_ACCESS)

#define  IOCTL_SHADOW_GETVERSION                (_SHADOW_IOCTL_CODE(0))

#define  IOCTL_SHADOW_REGISTER_AGENT            (_SHADOW_IOCTL_CODE(1))
#define  IOCTL_SHADOW_UNREGISTER_AGENT          (_SHADOW_IOCTL_CODE(2))
#define  IOCTL_SHADOW_GET_UNC_PATH              (_SHADOW_IOCTL_CODE(3))
#define  IOCTL_SHADOW_BEGIN_PQ_ENUM             (_SHADOW_IOCTL_CODE(4))
#define  IOCTL_SHADOW_END_PQ_ENUM               (_SHADOW_IOCTL_CODE(5))
#define  IOCTL_SHADOW_NEXT_PRI_SHADOW           (_SHADOW_IOCTL_CODE(6))
#define  IOCTL_SHADOW_PREV_PRI_SHADOW           (_SHADOW_IOCTL_CODE(7))
#define  IOCTL_SHADOW_GET_SHADOW_INFO           (_SHADOW_IOCTL_CODE(8))
#define  IOCTL_SHADOW_SET_SHADOW_INFO           (_SHADOW_IOCTL_CODE(9))
#define  IOCTL_SHADOW_CHK_UPDT_STATUS           (_SHADOW_IOCTL_CODE(10))
#define  IOCTL_DO_SHADOW_MAINTENANCE            (_SHADOW_IOCTL_CODE(11))
#define  IOCTL_SHADOW_COPYCHUNK                 (_SHADOW_IOCTL_CODE(12))
#define  IOCTL_SHADOW_BEGIN_REINT               (_SHADOW_IOCTL_CODE(13))
#define  IOCTL_SHADOW_END_REINT                 (_SHADOW_IOCTL_CODE(14))
#define  IOCTL_SHADOW_CREATE                    (_SHADOW_IOCTL_CODE(15))
#define  IOCTL_SHADOW_DELETE                    (_SHADOW_IOCTL_CODE(16))
#define  IOCTL_GET_SHARE_STATUS                 (_SHADOW_IOCTL_CODE(17))
#define  IOCTL_SET_SHARE_STATUS                 (_SHADOW_IOCTL_CODE(18))
#define  IOCTL_ADDUSE                           (_SHADOW_IOCTL_CODE(19))
#define  IOCTL_DELUSE                           (_SHADOW_IOCTL_CODE(20))
#define  IOCTL_GETUSE                           (_SHADOW_IOCTL_CODE(21))
#define  IOCTL_SWITCHES                         (_SHADOW_IOCTL_CODE(22))
#define  IOCTL_GETSHADOW                        (_SHADOW_IOCTL_CODE(23))
#define  IOCTL_GETGLOBALSTATUS                  (_SHADOW_IOCTL_CODE(24))
#define  IOCTL_FINDOPEN_SHADOW                  (_SHADOW_IOCTL_CODE(25))
#define  IOCTL_FINDNEXT_SHADOW                  (_SHADOW_IOCTL_CODE(26))
#define  IOCTL_FINDCLOSE_SHADOW                 (_SHADOW_IOCTL_CODE(27))
#define  IOCTL_GETPRIORITY_SHADOW               (_SHADOW_IOCTL_CODE(28))
#define  IOCTL_SETPRIORITY_SHADOW               (_SHADOW_IOCTL_CODE(29))
#define  IOCTL_ADD_HINT                         (_SHADOW_IOCTL_CODE(30))
#define  IOCTL_DELETE_HINT                      (_SHADOW_IOCTL_CODE(31))
#define  IOCTL_FINDOPEN_HINT                    (_SHADOW_IOCTL_CODE(32))
#define  IOCTL_FINDNEXT_HINT                    (_SHADOW_IOCTL_CODE(33))
#define  IOCTL_FINDCLOSE_HINT                   (_SHADOW_IOCTL_CODE(34))
#define  IOCTL_GET_IH_PRIORITY                  (_SHADOW_IOCTL_CODE(35))
#define  IOCTL_GETALIAS_HSHADOW                 (_SHADOW_IOCTL_CODE(36))
#define  IOCTL_GET_DEBUG_INFO                   (_SHADOW_IOCTL_CODE(37))

// the following are only used on NT but there's no harm in defining them for win9x as well
#define  IOCTL_OPENFORCOPYCHUNK                 (_SHADOW_IOCTL_CODE(40))
#define  IOCTL_CLOSEFORCOPYCHUNK                (_SHADOW_IOCTL_CODE(41))

#define IOCTL_IS_SERVER_OFFLINE                 (_SHADOW_IOCTL_CODE(42))
#define IOCTL_TRANSITION_SERVER_TO_ONLINE       (_SHADOW_IOCTL_CODE(43))
#define IOCTL_TRANSITION_SERVER_TO_OFFLINE      (_SHADOW_IOCTL_CODE(44))
#define IOCTL_NAME_OF_SERVER_GOING_OFFLINE      (_SHADOW_IOCTL_CODE(45))
#define IOCTL_TAKE_SERVER_OFFLINE               (_SHADOW_IOCTL_CODE(46))
#define IOCTL_SHAREID_TO_SHARENAME              (_SHADOW_IOCTL_CODE(47))

#define  CSC_IOCTL_MIN      IOCTL_SHADOW_GETVERSION
#define  CSC_IOCTL_MAX_W9X  IOCTL_GETALIAS_HSHADOW
#define  CSC_IOCTL_MAX_NT   IOCTL_SHAREID_TO_SHARENAME


// Sub operations for IOCTL_DO_SHADOW_MAINTENATCE

#define SHADOW_MAKE_SPACE               1
#define SHADOW_REDUCE_REFPRI            2
#define SHADOW_ADD_SPACE                3
#define SHADOW_FREE_SPACE               4
#define SHADOW_GET_SPACE_STATS          5
#define SHADOW_SET_MAX_SPACE            6
#define SHADOW_PER_THREAD_DISABLE       7
#define SHADOW_PER_THREAD_ENABLE        8
#define SHADOW_REINIT_DATABASE          9
#define SHADOW_ADDHINT_FROM_INODE       10
#define SHADOW_DELETEHINT_FROM_INODE    11
#define SHADOW_COPY_INODE_FILE          12
#define SHADOW_BEGIN_INODE_TRANSACTION  13
#define SHADOW_END_INODE_TRANSACTION    14
#define SHADOW_FIND_CREATE_PRINCIPAL_ID 15
#define SHADOW_GET_SECURITY_INFO        16
#define SHADOW_SET_EXCLUSION_LIST       17
#define SHADOW_SET_BW_CONSERVE_LIST     18
#define SHADOW_TRANSITION_SERVER_TO_OFFLINE 19
#define SHADOW_CHANGE_HANDLE_CACHING_STATE  20
#define SHADOW_RECREATE                     21
#define SHADOW_RENAME                       22
#define SHADOW_SPARSE_STALE_DETECTION_COUNTER   23
#define SHADOW_ENABLE_CSC_FOR_USER              24
#define SHADOW_DISABLE_CSC_FOR_USER             25
#define SHADOW_SET_DATABASE_STATUS              26
#define SHADOW_PURGE_UNPINNED_FILES             27
#define SHADOW_MANUAL_FILE_DETECTION_COUNTER    28

// persistent status flags on files/directories in the CSC database

#define  SHADOW_DIRTY               0x0001   // Contents of file/dir modified while offline

#define  SHADOW_ATTRIB_CHANGE       0x0002  // attributes have been changed offline

#define  SHADOW_TIME_CHANGE         0x0004  // lastmodtime changed offline

#define  SHADOW_STALE               0x0008  // file/dir replic is not in sync with server copy

#define  SHADOW_DELETED             0x0010  // file/dir was deleted in an offline operation

#define  SHADOW_SPARSE              0x0020  // file/dir is not completely filled up

#define  SHADOW_BUSY                0x0040  //

#define  SHADOW_REUSED              0x0080  // A replica name has been reused during an offline
                                            // operation of delete follwed by a create

#define  SHADOW_ORPHAN              0x0100  // used to be a replica but the original has vanished
                                            // from the server

#define  SHADOW_SUSPECT             0x0200  // writes failed on this shadow


#define  SHADOW_LOCALLY_CREATED     0x0400  // File/directory created offline


#define  SHADOW_LOCAL_INODE         0x4000  // This has meaning only for an inode,
                                            // it means that the inode was created while offline

#define  SHADOW_NOT_FSOBJ           0x8000  // This is only a hint


//not used...incorrect #define  mShadowIsFsObj(uStatus)    (((uStatus) & SHADOW_FILESYSTEM_OBJECT)==0)
#define  mShadowHintType(uStatus)   ((uStatus) & SHADOW_HINT_MASK)
#define  mSetHintType(uStatus, type)         ((uStatus) = ((uStatus) & ~SHADOW_HINT_MASK) | ((type) & SHADOW_HINT_MASK))

#define  SHADOW_IS_FILE             0x80000000   // flag ored at runtime for PQ enumeration
#define  SHADOW_FILE_IS_OPEN        0x40000000   // flag ored at runtime for dir enumeration


#define  SHADOW_MODFLAGS         (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_LOCALLY_CREATED|SHADOW_DELETED|SHADOW_REUSED)



// Flags defined for a share entry in the CSC database

#define SHARE_REINT                0x0001  // Needs reintegration (persistent)
#define SHARE_CONFLICTS            0x0002  // Conflicts while merging (Persistent)
#define SHARE_ERRORS               0x0004  // Database errors (Persistent)
//                                  0x0008  // free
#define SHARE_PRESERVES_CASE       0x0010  // (Persistent) may be expendable
#define SHARE_SUPPORTS_LFN         0x0020  // (Persistent) may be expendable

// share caching types (derived from the SMB spec).
// These are set by the admin on the server side.

#define SHARE_MANUAL_REINT          0x0000  // No automatic file by file reint  (Persistent)
#define SHARE_AUTO_REINT            0x0040  // File by file reint is OK         (Persistent)
#define SHARE_VDO                   0x0080  // no need to flow opens            (Persistent)
#define SHARE_NO_CACHING            0x00c0  // client should not cache this share (Persistent)

#define SHARE_CACHING_MASK         0x00c0  // type of caching


// in memory flags
#define  SHARE_FINDS_IN_PROGRESS   0x0200  // has finds in progress
#define  SHARE_FILES_OPEN          0x0400  // has files open
#define  SHARE_CONNECTED           0x0800  // Share is connected right now
#define  SHARE_SHADOWNP            0x1000  // A shadow connection
#define  SHARE_PINNED_OFFLINE      0x2000  // Don't auto-reconnect
#define  SHARE_MERGING             0x4000  // free
#define  SHARE_DISCONNECTED_OP     0x8000  // Disconnected operation in progress




// NB these are identical to
#define  mShadowLocallyCreated(uFlags) ((uFlags) & SHADOW_LOCALLY_CREATED)
#define  mShadowStale(uFlags)          ((uFlags) & SHADOW_STALE)
#define  mShadowDirty(uFlags)          ((uFlags) & SHADOW_DIRTY)
#define  mShadowTimeChange(uFlags)     ((uFlags) & SHADOW_TIME_CHANGE)
#define  mShadowAttribChange(uFlags)   ((uFlags) & SHADOW_ATTRIB_CHANGE)
#define  mShadowSparse(uFlags)         ((uFlags) & SHADOW_SPARSE)
#define  mShadowBusy(uFlags)           ((uFlags) & SHADOW_BUSY)
#define  mShadowSuspect(uFlags)        ((uFlags) & SHADOW_SUSPECT)
#define  mShadowDeleted(uFlags)        ((uFlags) & SHADOW_DELETED)
#define  mShadowReused(uFlags)         ((uFlags) & SHADOW_REUSED)
#define  mShadowOrphan(uFlags)         ((uFlags) & SHADOW_ORPHAN)

#define  mShadowNeedReint(uFlags)      ((uFlags) & (SHADOW_MODFLAGS))
#define  mShadowConflict(uFlags)       (((uFlags) & SHADOW_STALE) && ((uFlags) & SHADOW_MODFLAGS))
#define  mShadowUsable(uFlags)         (!((uFlags) & (SHADOW_STALE|SHADOW_SUSPECT)))

#define  mShadowIsFile(uFlags)         ((uFlags) & SHADOW_IS_FILE)

#define  SHADOW_FLAGS_BITOP_MASK    0xf
#define  SHADOW_FLAGS_ASSIGN        0
#define  SHADOW_FLAGS_AND           1
#define  SHADOW_FLAGS_OR            2

#define  SHADOW_OBJECT_FINDFIRST    3
#define  SHADOW_OBJECT_FINDNEXT     4
#define  SHADOW_OBJECT_FINDCLOSE    5

#define  SHADOW_HINT_FINDFIRST      6
#define  SHADOW_HINT_FINDNEXT       7
#define  SHADOW_HINT_FINDCLOSE      8

#define  SHADOW_HINT_ADD            9
#define  SHADOW_DELETE_HINT         10

#define SHADOW_FLAGS_COMMAND_MASK        0xff00
#define SHADOW_FLAGS_DONT_UPDATE_ORGTIME 0x1000
#define SHADOW_FLAGS_TRUNCATE_DATA       0x2000
#define SHADOW_FLAGS_FORCE_RELINK        0x4000 // forces the entry at the top of PQ even if
                                                // it's current priority is MAX_PRI and all
                                                // it's predecessors are MAX_PRI
#define SHADOW_FLAGS_CHANGE_83NAME       0x8000 // applicable to setshadowinfo
#define SHADOW_FLAGS_SET_REFRESH_TIME    0x0100 // setshadowinfo will update lastrefreshed time

#define  mBitOpShadowFlags(uOp)  ((uOp) & SHADOW_FLAGS_BITOP_MASK)
#define  mOrShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_OR)
#define  mAndShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_AND)
#define  mAssignShadowFlags(uOp)  (((uOp) & SHADOW_FLAGS_BITOP_MASK)==SHADOW_FLAGS_ASSIGN)

#define  mSetShadowFlagsOp(uVar, uOp)  (((uVar) &= ~SHADOW_FLAGS_BITOP_MASK), (uVar) |= (uOp))
#define  mSetSetShadowCommand(uVar, uCommand)   (((uVar) &= ~SHADOW_FLAGS_COMMAND_MASK), (uVar) |= uCommand)

#define  mDontUpdateOrgTime(uOp)    ((uOp) & SHADOW_FLAGS_DONT_UPDATE_ORGTIME)
#define  mTruncateDataCommand(uOp)  ((uOp) & SHADOW_FLAGS_TRUNCATE_DATA)
#define  mForceRelink(uOp)          ((uOp) & SHADOW_FLAGS_FORCE_RELINK)
#define  mChange83Name(uOp)         ((uOp) & SHADOW_FLAGS_CHANGE_83NAME)
#define  mSetLastRefreshTime(uOp)   ((uOp) & SHADOW_FLAGS_SET_REFRESH_TIME)

#define  SHADOW_SWITCH_SHADOWING        0x0001
#define  SHADOW_SWITCH_LOGGING          0x0002
#define  SHADOW_SWITCH_SHADOWFIND       0x0004
#define  SHADOW_SWITCH_SPEAD_OPTIMIZE   0x0008
#define  SHADOW_SWITCH_REMOTE_BOOT      0x0010

#define  SHADOW_SWITCH_OFF             1
#define  SHADOW_SWITCH_ON              2
#define  SHADOW_SWITCH_GET_STATE       3

#define  mSetBits(uFlags, uBits)    ((uFlags) |= (uBits))
#define  mClearBits(uFlags, uBits)  ((uFlags) &= ~(uBits))
#define  mQueryBits(uFlags, uBits)      ((uFlags) & (uBits))

#ifndef CSC_ON_NT
#define FlagOn(uFlags, uBit)    (mQueryBits(uFlags, uBit) != 0)
#endif

#define RETAIN_VALUE                0xffffffff

// pin flags
// NTRAID#455275-shishirp-1/31/2000, we ended up replicating these in cscapi.h

#define FLAG_CSC_HINT_PIN_USER                  0x01
#define FLAG_CSC_HINT_PIN_INHERIT_USER          0x02
#define FLAG_CSC_HINT_PIN_INHERIT_SYSTEM        0x04
#define FLAG_CSC_HINT_CONSERVE_BANDWIDTH        0x08
#define FLAG_CSC_HINT_PIN_SYSTEM                0x10

#define FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT   0x80000000
#define FLAG_CSC_HINT_COMMAND_MASK              0xf0000000
#define FLAG_CSC_HINT_INHERIT_MASK               (FLAG_CSC_HINT_PIN_INHERIT_USER|FLAG_CSC_HINT_PIN_INHERIT_SYSTEM)

#define mPinFlags(ulHintFlags)          ((ulHintFlags) & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))
#define mPinInheritFlags(ulHintFlags)   ((ulHintFlags) & (FLAG_CSC_HINT_PIN_INHERIT_USER|FLAG_CSC_HINT_PIN_INHERIT_SYSTEM))
#define mPinCommand(ulHintFlags)        ((ulHintFlags) & FLAG_CSC_HINT_COMMAND_MASK)
#define mPinAlterCount(ulHintFlags)     ((ulHintFlags) & FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT)

// These defines are here for historical reasons, they are not used anymore
// Hint, Hint
#define  HINT_FLAG_TYPE_MASK        0x03
#define  HINT_EXCLUSION             0x04
#define  HINT_WILDCARD              0x08

#define  HINT_TYPE_FILE             1
#define  HINT_TYPE_FOLDER           2
#define  HINT_TYPE_SUBTREE          3
//
#define  mNotFsobj(uStatus)         ((uStatus) & SHADOW_NOT_FSOBJ)
#define  mIsHint(uHF)               ((uHF) & HINT_FLAG_TYPE_MASK)
#define  mHintSubtree(uHF)          (((uHF) & HINT_FLAG_TYPE_MASK)==HINT_TYPE_SUBTREE)
#define  mHintExclude(uHF)          ((uHF) & HINT_EXCLUSION)
#define  mHintWildcard(uHF)         ((uHF) & HINT_WILDCARD)



#ifdef  VxD
typedef _WIN32_FIND_DATA   WIN32_FIND_DATA, *PFIND32, far *LPFIND32;
typedef _FILETIME   FILETIME;
#else
typedef LPWIN32_FIND_DATAW   LPFIND32;
#endif

#ifdef CSC_RECORDMANAGER_WINNT
typedef _FILETIME   FILETIME;
#endif

typedef  ULONG  HSERVER;
typedef  ULONG  HSHADOW;
typedef  ULONG  HSHARE;

typedef  ULONG  *PHSHARE;
typedef  ULONG  *PHSERVER;
typedef  ULONG  *PHSHADOW;

#ifdef  VxD
typedef USHORT  wchar_t;
#endif
typedef wchar_t *PWCHAR;
typedef wchar_t *LPWCH, *PWCH;
typedef CONST wchar_t *LPCWCH, *PCWCH;
typedef wchar_t *NWPSTR;
typedef wchar_t *LPWSTR, *PWSTR;

typedef CONST wchar_t *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;
typedef VOID    *CSC_ENUMCOOKIE;

typedef struct tagSTOREDATA
{
    ULONG   ulSize;           // Max shadow data size
    ULONG   ucntDirs;         // Current count of dirs
    ULONG   ucntFiles;        // Current count of files
}
STOREDATA;


#ifndef __COPYCHUNKCONTEXT__
#define __COPYCHUNKCONTEXT__
typedef struct tagCOPYCHUNKCONTEXT
{
    DWORD   dwFlags;
    ULONG   LastAmountRead;
    ULONG   TotalSizeBeforeThisRead;
    HANDLE  handle;
    ULONG   ChunkSize;
    ULONG   Context[1];
}
COPYCHUNKCONTEXT;
#endif

#define COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN 0x00000001

typedef struct tagSHADOWSTORE
{
    ULONG       uFlags;
    STOREDATA   sMax;
    STOREDATA   sCur;
}
SHADOWSTORE;


typedef struct tagCOPYPARAMSA
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG    uOp;
            HSHARE   hShare;
            HSHADOW  hDir;
            HSHADOW  hShadow;
            LPSTR    lpLocalPath;
            LPSTR    lpRemotePath;
            LPSTR    lpSharePath;
        };
    };
}
COPYPARAMSA;

typedef struct tagCOPYPARAMSW
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG       uOp;
            HSHARE      hShare;
            HSHADOW     hDir;
            HSHADOW     hShadow;
            LPWSTR      lpLocalPath;
            LPWSTR      lpRemotePath;
            LPWSTR      lpSharePath;
        };
    };
}
COPYPARAMSW;

typedef struct tagPQPARAMS
{
    union
    {
        DWORD   dwError;
        struct
        {
            HSHARE      hShare;
            HSHADOW     hDir;
            HSHADOW     hShadow;
            ULONG       ulStatus;
            ULONG       ulRefPri;
            ULONG       ulIHPri;
            ULONG       ulHintFlags;
            ULONG       ulHintPri;
            CSC_ENUMCOOKIE       uEnumCookie;
            ULONG       uPos;
            DWORD       dwPQVersion;
        };
    };
}
PQPARAMS;

typedef struct tagSHADOWINFO
{
    union
    {
        DWORD   dwError;
        struct
        {
            HSHARE     hShare;            // share ID
            HSHADOW     hDir;               // directory inode
            HSHADOW     hShadow;            // inode for the item
            union
            {
                HSHADOW     hShadowOrg;         // original inode, applies only to a replica
                HSHADOW     hDirTo;             // input for renaming hShadowFrom into hDirTo
            };
            FILETIME    ftOrgTime;          // the timestamp of a replica as obtained
            FILETIME    ftLastRefreshTime;  // last time a replica was refreshed
            union
            {
                LPFIND32    lpFind32;
                LPVOID      lpBuffer;
            };

            ULONG       uStatus;            // status of the item in the database

            ULONG       ulRefPri;

            union
            {
                ULONG       ulPrincipalID;
                ULONG       ulIHPri;
                ULONG       uRootStatus;
            };

            ULONG       ulHintFlags;

            ULONG       ulHintPri;

            union
            {
                ULONG       uOp;
                ULONG       uSubOperation;
            };

            CSC_ENUMCOOKIE  uEnumCookie;
            ULONG       cbBufferSize;
            DWORD       dwNameSpaceVersion;
        };

    };
}
SHADOWINFO;

#define  FINDOPEN_SHADOWINFO_NORMAL   0x1
#define  FINDOPEN_SHADOWINFO_SPARSE   0x2
#define  FINDOPEN_SHADOWINFO_DELETED  0x4
#define  FINDOPEN_SHADOWINFO_ALL      0x7

typedef struct tagSHAREINFOW
{
    union
    {
        DWORD   dwError;

        struct
        {
            HSHARE  hShare;
            USHORT usCaps;        // Type of resource
            USHORT usState;       // State of the resource (connected/paused etc.)
            unsigned    short rgSharePath[MAX_SERVER_SHARE_NAME_FOR_CSC];    // name of the path
            unsigned    short rgFileSystem[16];    // name of the file system
        };
    };
}
SHAREINFOW;

typedef struct tagSHAREINFOA
{
    union
    {
        DWORD   dwError;

        struct
        {
            HSHARE  hShare;
            USHORT usCaps;        // Type of resource
            USHORT usState;       // State of the resource (connected/paused etc.)
            char rgSharePath[MAX_SERVER_SHARE_NAME_FOR_CSC];    // name of the path
            char rgFileSystem[16];    // name of the file system
        };
    };
}
SHAREINFOA;


typedef struct tagGLOBALSTATUS
{
    union
    {
        DWORD   dwError;
        struct
        {
            ULONG       uFlagsEvents;     // Reports the latest events noted
            ULONG       uDatabaseErrorFlags;
            SHADOWSTORE sST;
            HSHADOW     hShadowAdded;
            HSHADOW     hDirAdded;
            HSHADOW     hShadowDeleted;
            HSHADOW     hDirDeleted;
            int         cntFileOpen;   // Count of file opens
            HSHARE     hShareDisconnected;
        };
    };
}
GLOBALSTATUS, *LPGLOBALSTATUS;

typedef struct  tagSECURITYINFO
{
    ULONG   ulPrincipalID;      // identifier of the principal
    ULONG   ulPermissions;      // permissions mask
}
SECURITYINFO, *LPSECURITYINFO;

// achtung, these should match with those in the cscsec.h

#define CSC_MAXIMUM_NUMBER_OF_CACHED_PRINCIPAL_IDS (0x4)
#define CSC_GUEST_PRINCIPAL_ID           (0xfffe)
#define CSC_INVALID_PRINCIPAL_ID         (0x0)


#define FLAG_GLOBALSTATUS_SHADOW_ADDED          0x0001
#define FLAG_GLOBALSTATUS_SHADOW_DELETED        0x0002
#define FLAG_GLOBALSTATUS_FILE_OPENS            0x0004
#define FLAG_GLOBALSTATUS_SHADOW_SPACE          0x0008
#define FLAG_GLOBALSTATUS_SHARE_DISCONNECTED    0x0010
#define FLAG_GLOBALSTATUS_STOP                  0x0020
#define FLAG_GLOBALSTATUS_START                 0x0040
#define FLAG_GLOBALSTATUS_NO_NET                0x0080
#define FLAG_GLOBALSTATUS_GOT_NET               0x0100
#define FLAG_GLOBALSTATUS_INVOKE_AUTODIAL       0x0200
#define FLAG_GLOBALSTATUS_INVOKE_FREESPACE      0x0400

#define FLAG_DATABASESTATUS_DIRTY                   0x00000001
#define FLAG_DATABASESTATUS_ENCRYPTION_MASK         0x00000006
#define FLAG_DATABASESTATUS_UNENCRYPTED             0x00000000 // new inodes will NOT be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED   0x00000004
#define FLAG_DATABASESTATUS_ENCRYPTED               0x00000002 // new fileinodes will be encrypted
#define FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED     0x00000006

#define mDatabaseEncryptionEnabled(ulGlobalStatus)  ((ulGlobalStatus) & 0x00000002)

#define mDatabasePartiallyEncrypted(ulGlobalStatus) (((ulGlobalStatus) & FLAG_DATABASESTATUS_ENCRYPTION_MASK)==FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED)
#define mDatabasePartiallyUnencrypted(ulGlobalStatus) (((ulGlobalStatus) & FLAG_DATABASESTATUS_ENCRYPTION_MASK)==FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED)

//
// Neutral ANSI/UNICODE types and macros
//
#ifndef _TCHAR_DEFINED

#ifdef  UNICODE                     // r_winnt

typedef wchar_t TCHAR, *PTCHAR;
typedef wchar_t TBYTE , *PTBYTE ;

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR LPCTSTR;
typedef LPWSTR LP;
#define _TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define _TEXT(quote) quote      // r_winnt

#endif /* UNICODE */                // r_winnt

#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

#ifdef VXD

#define UNICODE

#endif

#ifdef  UNICODE

#define COPYPARAMS      COPYPARAMSW
#define SHAREINFO      SHAREINFOW
#define LPCOPYPARAMS    LPCOPYPARAMSW
#define LPSHAREINFO    LPSHAREINFOW
#else

#define COPYPARAMS  COPYPARAMSA
#define SHAREINFO  SHAREINFOA
#define LPCOPYPARAMS    LPCOPYPARAMSA
#define LPSHAREINFO    LPSHAREINFOA
#endif

#ifdef   VxD
typedef HSHARE       *LPHSHARE;
typedef HSHADOW      *LPHSHADOW;
typedef SHADOWSTORE  *LPSHADOWSTORE;
typedef SHADOWINFO   *LPSHADOWINFO;
typedef STOREDATA    *LPSTOREDATA;
typedef PQPARAMS     *LPPQPARAMS;
typedef COPYPARAMSA  *LPCOPYPARAMSA;
typedef SHAREINFOA  *LPSHAREINFOA;
typedef COPYPARAMSW  *LPCOPYPARAMSW;
typedef SHAREINFOW  *LPSHAREINFOW;
#else
typedef HSHARE       FAR *LPHSHARE;
typedef HSHADOW      FAR *LPHSHADOW;
typedef SHADOWSTORE  FAR *LPSHADOWSTORE;
typedef SHADOWINFO   FAR *LPSHADOWINFO;
typedef STOREDATA    FAR *LPSTOREDATA;
typedef PQPARAMS     FAR *LPPQPARAMS;
typedef COPYPARAMS   FAR *LPCOPYPARAMS;
typedef COPYPARAMSA  FAR *LPCOPYPARAMSA;
typedef SHAREINFOA  FAR *LPSHAREINFOA;
typedef COPYPARAMSW  FAR *LPCOPYPARAMSW;
typedef SHAREINFOW  FAR *LPSHAREINFOW;
#endif



// UNICODE versions of registry key/value names

// kept for hist(y)rical reasons
#define REG_KEY_IEXPLORER                       _TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REG_KEY_SHADOW                          _TEXT("System\\CurrentControlSet\\Services\\VxD\\Shadow")

// settings exclusively used by cscdll.dll

#define REG_KEY_CSC_SETTINGS                    _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\CSCSettings")
#define REG_STRING_DATABASE_LOCATION            _TEXT("DatabaseLocation")
#define REG_VALUE_DATABASE_SIZE                 _TEXT("DatabaseSizePercent")
#define REG_VALUE_ENABLED                       _TEXT("Enabled")


// settings defined by UI and policy

#define REG_STRING_POLICY_NETCACHE_KEY          _TEXT("Software\\Policies\\Microsoft\\Windows\\NetCache")
#define REG_STRING_NETCACHE_KEY                 _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache")
#define REG_STRING_EXCLUSION_LIST               _TEXT("ExcludeExtensions")
#define REG_STRING_BANDWIDTH_CONSERVATION_LIST  _TEXT("BandwidthConservationList")
#define REG_VALUE_FORMAT_DATABASE               _TEXT("FormatDatabase")

// ANSI versions of registry key/value names

// kept for hist(y)rical reasons
#define REG_KEY_IEXPLORER_A                     "Software\\Microsoft\\Internet Explorer\\Main"
#define REG_KEY_SHADOW_A                        "System\\CurrentControlSet\\Services\\VxD\\Shadow"

// settings exclusively used by cscdll.dll

#define REG_KEY_CSC_SETTINGS_A                  "Software\\Microsoft\\Windows\\CurrentVersion\\CSCSettings"
#define REG_STRING_DATABASE_LOCATION_A          "DatabaseLocation"
#define REG_VALUE_DATABASE_SIZE_A               "DatabaseSizePercent"
#define REG_VALUE_ENABLED_A                     "Enabled"

// settings defined by UI and policy

#define REG_STRING_POLICY_NETCACHE_KEY_A        "Software\\Policies\\Microsoft\\Windows\\NetCache"
#define REG_STRING_NETCACHE_KEY_A               "Software\\Microsoft\\Windows\\CurrentVersion\\NetCache"
#define REG_STRING_EXCLUSION_LIST_A             "ExcludeExtensions"
#define REG_STRING_BANDWIDTH_CONSERVATION_LIST_A "BandwidthConservationList"
#define REG_STRING_ENCRYPTED_A                  "Encrypted"
#define REG_STRING_ENCRYPT_DECRYPT_A            "EcDc"

#define REG_VALUE_FORMAT_DATABASE_A             "FormatDatabase"

#define SESSION_EVENT_NAME_NT L"\\BaseNamedObjects\\jjCSCSessEvent_UM_KM"
#define SHARED_FILL_EVENT_NAME_NT L"\\BaseNamedObjects\\jjCSCSharedFillEvent_UM_KM"
#define IFNOT_CSC_RECORDMANAGER_WINNT if(FALSE)
#define IF_CSC_RECORDMANAGER_WINNT if(TRUE)
#define WINNT_DOIT(x__) x__

int ShadowLog(
    LPSTR lpFmt,
    ...
    );

#define DoCSCLog(__x)   ShadowLog __x

extern DWORD    dwDebugLogVector;

#define DEBUG_LOG(__bits, __x) {\
    if (((DEBUG_LOG_BIT_##__bits)==0) || FlagOn(dwDebugLogVector,(DEBUG_LOG_BIT_##__bits))){\
            DoCSCLog(__x); \
        }\
    }

#define DEBUG_LOG_BIT_RECORD    0x00000001
#define DEBUG_LOG_BIT_CSHADOW   0x00000002

#endif //#ifndef __SHDCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\cscsec.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cscsec.h

Abstract:

    This module implements all security related definitions for disconnected
    operation of Client Side Caching

Revision History:

    Balan Sethu Raman     [SethuR]    6-October-1997

Notes:

--*/

#ifndef _SECURITY_H_
#define _SECURITY_H_

// The following functions are used to store/retrieve the access rights information
// for the various files/directories cached in the CSC database.

// routines to initialize/teardown the access rights infrastructure in CSC

extern DWORD
CscInitializeSecurity(
    LPVOID ShadowDatabaseName);

extern DWORD
CscTearDownSecurity(LPSTR s);

extern DWORD
CscInitializeSecurityDescriptor();

extern DWORD
CscUninitializeSecurityDescriptor();

//
// The CSC access rights database is organized around SIDs. SIDs uniquely identify
// an user across reboots, i.e., they are persistent.
//

typedef USHORT CSC_SID_INDEX, *PCSC_SID_INDEX;

extern DWORD
CscAddSidToDatabase(
    PVOID   pSid,
    ULONG   SidLength,
    PCSC_SID_INDEX pSidindex);

extern DWORD
CscRemoveSidFromDatabase(
    PVOID   pSid,
    ULONG   SidLength);

typedef struct _CSC_SID_ACCESS_RIGHTS_ {
    PVOID       pSid;
    ULONG       SidLength;
    ULONG       MaximalAccessRights;
} CSC_SID_ACCESS_RIGHTS, *PCSC_SID_ACCESS_RIGHTS;

extern DWORD
CscAddMaximalAccessRightsForSids(
    HSHADOW                 hParent,
    HSHADOW                 hShadow,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights);

extern DWORD
CscAddMaximalAccessRightsForShare(
    HSERVER                 hServer,
    ULONG                   NumberOfSids,
    PCSC_SID_ACCESS_RIGHTS  pSidAccessRights);

extern DWORD
CscRemoveMaximalAccessRightsForSid(
    HSHADOW     hParent,
    HSHADOW     hShadow,
    PVOID       pSid,
    ULONG       SidLength);

//
// Since there are large number of files cached for a given SID the access rights
// are stored corresponding to a SID index. The SIDs are stored persistently in
// a special SID mapping file in the CSC database. Currently the SIDs are
// stored as an array and linear comparions are made. Since the number of SIDs
// will be typically less than 10 in any given system this organization suffices.
// The length of the SID is cached to facilitate quicker comparisons and avoid
// recomputation using the security API's.
//

typedef struct _CSC_SID_ {
    ULONG   SidLength;
    PVOID   pSid;
} CSC_SID, *PCSC_SID;

typedef struct _CSC_SIDS_ {
    ULONG   MaximumNumberOfSids;
    ULONG   NumberOfSids;
    CSC_SID Sids[];
} CSC_SIDS, *PCSC_SIDS;

// Two special indexes are distinguished, the CSC_GUEST_SID_INDEX which is used as
// the default access rights indicator when the SID does not map to a valid
// index and CSC_INVALID_SID_INDEX to indicate an invalid SID mapping.
//

#define CSC_GUEST_SID         (PVOID)(0x11111111)
#define CSC_GUEST_SID_LENGTH  (0x4)

// Achtung !!! these should match with those in shdcom.h
#define CSC_GUEST_SID_INDEX   (0xfffe)
#define CSC_INVALID_SID_INDEX (0x0)

// Achtung !!! this should match with that in shdcom.h
#define CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES (0x4)

#define CSC_SID_QUANTUM       (0x2)

extern CSC_SID_INDEX
CscMapSidToIndex(
    PVOID   pSid,
    ULONG   SidLength);

//
// Currently access rights for upto four users are cached with any given file in
// the CSC database. This is based upon the fact that 4 DWORDs have been allocated
// for the security information in the CSC database. The file system specific
// access rights are 9 bits long ( it has been rounded off to 16 bits) and 16
// bits are used for the SID index. It is possible to increase this to 8 by
// squeezing in the SID index to the 7 bits in the 16 bits allocated for
// access rights.
//

#define MAXIMUM_NUMBER_OF_USERS (0x4)

typedef struct _ACCESS_RIGHTS_ {
    CSC_SID_INDEX SidIndex;
    USHORT        MaximalRights;
} ACCESS_RIGHTS, *PACCESS_RIGHTS;

typedef struct _CACHED_ACCESS_RIGHTS_ {
    ACCESS_RIGHTS   AccessRights[MAXIMUM_NUMBER_OF_USERS];
} CACHED_SECURITY_INFORMATION, *PCACHED_SECURITY_INFORMATION;

//
// All the global variables used in mapping/evaluating access rights are aggregated
// in the CSC_SECURITY data structure. Currently it contains the sid mapping file
// in the CSC database and the in memory data structure used.
//

typedef struct _CSC_SECURITY_ {
    CSCHFILE    hSidMappingsFile;
    PCSC_SIDS   pCscSids;
    LPVOID      ShadowDatabaseName;
} CSC_SECURITY, *PCSC_SECURITY;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\csc_bmpk.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpk.h

Abstract:

    Interface to the kernel mode utility functions of bitmaps
    associated with CSC files. The 'k' in the file name means "kernel"

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#ifndef _CSC_BITMAPK_H_
#define _CSC_BITMAPK_H_

#include "csc_bmpc.h" // common header for CscBmp file format

// Note: This CSC_BITMAP is different than the CSC_BITMAP in csc_bmpu.h

typedef struct _CSC_BITMAP {
    FAST_MUTEX mutex;   // synchronization
    BOOL valid;
    DWORD bitmapsize;   // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;     // how many DWORDs allocated for the bitmap 
    LPDWORD bitmap;     // the bitmap itself
} CSC_BITMAP, *LPCSC_BITMAP, *PCSC_BITMAP;

extern LPSTR CscBmpAltStrmName;

LPCSC_BITMAP
CscBmpCreate(
    DWORD filesize);

VOID
CscBmpDelete(
    LPCSC_BITMAP *lplpbitmap);

// Outsiders should call CscBmpResize
BOOL
CscBmpResizeInternal(
    LPCSC_BITMAP lpbitmap,
    DWORD newfilesize,
    BOOL fAcquireMutex);

#define CscBmpResize(l, n) CscBmpResizeInternal(l, n, TRUE);

BOOL
CscBmpMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Mark);

BOOL
CscBmpUnMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Unmark);

BOOL
CscBmpMarkAll(
    LPCSC_BITMAP lpbitmap);

BOOL
CscBmpUnMarkAll(
    LPCSC_BITMAP lpbitmap);

int
CscBmpIsMarked(
    LPCSC_BITMAP lpbitmap,
    DWORD bitoffset);

int
CscBmpMarkInvalid(
    LPCSC_BITMAP lpbitmap);

DWORD
CscBmpGetBlockSize();

int
CscBmpGetSize(
    LPCSC_BITMAP lpbitmap);

int
CscBmpRead(
    LPCSC_BITMAP *lplpbitmap,
    LPSTR strmFname,
    DWORD filesize);

int
CscBmpWrite(
    LPCSC_BITMAP lpbitmap,
    LPSTR strmFname);

#endif // #ifndef _CSC_BMPK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\cshadow.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

     CShadow.c

Abstract:

    This file implements the "cshadow" interface that is used by the redir and ioctls.
    The cshadow interface hides the actual implementation of the csc database from the
    users of the database.

    There are three persistant database types exposed

    1) The database of shares
    2) The filesystem hierarchy under any particular share
    3) The priority queue / Master File Table

    Operations for set and get are provided on the 1) and 2). 3) Is allwed to be
    enumerated. The priority queue is enumerated by the usermode agent to a) fill partially
    filled files and b) keep the space used within the specified constraints

Author:

     Shishir Pardikar      [Shishirp]        01-jan-1995

Revision History:

     Joe Linn                 [JoeLinn]         23-jan-97     Ported for use on NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifndef CSC_RECORDMANAGER_WINNT
#define WIN32_APIS
#include "record.h"
#include "cshadow.h"
#endif //ifndef CSC_RECORDMANAGER_WINNT

#include "string.h"
#include "stdlib.h"
#include "vxdwraps.h"

// Defines and Typedefs -------------------------------------------------------------------

#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {qweee __d__;}

#ifdef DEBUG
//cshadow dbgprint interface
#define CShadowKdPrint(__bit,__x) {\
    if (((CSHADOW_KDP_##__bit)==0) || FlagOn(CShadowKdPrintVector,(CSHADOW_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define CSHADOW_KDP_ALWAYS              0x00000000
#define CSHADOW_KDP_BADERRORS           0x00000001
#define CSHADOW_KDP_CREATESHADOWHI      0x00000002
#define CSHADOW_KDP_CREATESHADOWLO      0x00000004
#define CSHADOW_KDP_DELETESHADOWBAD     0x00000008
#define CSHADOW_KDP_DELETESHADOWHI      0x00000010
#define CSHADOW_KDP_DELETESHADOWLO      0x00000020
#define CSHADOW_KDP_RENAMESHADOWHI      0x00000040
#define CSHADOW_KDP_RENAMESHADOWLO      0x00000080
#define CSHADOW_KDP_GETSHADOWHI         0x00000100
#define CSHADOW_KDP_GETSHADOWLO         0x00000200
#define CSHADOW_KDP_SETSHADOWINFOHI     0x00000400
#define CSHADOW_KDP_SETSHADOWINFOLO     0x00000800
#define CSHADOW_KDP_READSHADOWINFOHI    0x00001000
#define CSHADOW_KDP_READSHADOWINFOLO    0x00002000
#define CSHADOW_KDP_COPYLOCAL           0x00004000
#define CSHADOW_KDP_COPYFILE            0x00008000
#define CSHADOW_KDP_FINDCREATESHARE    0x80000000
#define CSHADOW_KDP_MISC                0x00010000
#define CSHADOW_KDP_STOREDATA           0x00020000

#define CSHADOW_KDP_GOOD_DEFAULT (CSHADOW_KDP_BADERRORS         \
                | CSHADOW_KDP_CREATESHADOWHI    \
                | CSHADOW_KDP_DELETESHADOWHI    \
                | CSHADOW_KDP_RENAMESHADOWHI    \
                | CSHADOW_KDP_GETSHADOWHI       \
                | CSHADOW_KDP_SETSHADOWINFOHI   \
                | CSHADOW_KDP_FINDCREATESHARE  \
                | 0)


#define IF_HSHADOW_SPECIAL(___hshadow) if((___hshadow)==hShadowSpecial_x)
#define SET_HSHADOW_SPECIAL(___hshadow) {hShadowSpecial_x = (___hshadow);}
ULONG CShadowKdPrintVector = CSHADOW_KDP_BADERRORS;
//ULONG CShadowKdPrintVector = CSHADOW_KDP_GOOD_DEFAULT;
ULONG CShadowKdPrintVectorDef = CSHADOW_KDP_GOOD_DEFAULT;
#else
#define CShadowKdPrint(__bit,__x)  {NOTHING;}
#define IF_HSHADOW_SPECIAL(___hshadow) if(FALSE)
#define SET_HSHADOW_SPECIAL(___hshadow) {NOTHING;}
#endif

// ReadShadowInfo action flags
#define  RSI_COMPARE 0x0001
#define  RSI_GET      0x0002
#define  RSI_SET      0x0004

#define mIsDir(lpF32)           (((LPFIND32)(lpF32))->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)

#define  ENTERCRIT_SHADOW  {if (semShadow)\
                    Wait_Semaphore(semShadow, BLOCK_SVC_INTS);}
#define  LEAVECRIT_SHADOW  {if (semShadow)\
                    Signal_Semaphore(semShadow);}

#define  InuseGlobalFRExt()        (vfInuseFRExt)

#define  UseGlobalFilerecExt()  {Assert(!vfInuseFRExt);vfInuseFRExt = TRUE;memset(&vsFRExt, 0, sizeof(FILERECEXT));}
#define  UnUseGlobalFilerecExt() (vfInuseFRExt = FALSE)

#pragma intrinsic (memcmp, memcpy, memset, strcat, strcmp, strcpy, strlen)


// Global data ----------------------------------------------------------------------------

USHORT vwzRegDelimiters[] = L";, ";

USHORT  *vrgwExclusionListDef[] =
{
    L"*.SLM",
    L"*.MDB",
    L"*.LDB",
    L"*.MDW",
    L"*.MDE",
    L"*.PST",
    L"*.DB?"
};

USHORT  **vlplpExclusionList = vrgwExclusionListDef;

ULONG   vcntExclusionListEntries = (sizeof(vrgwExclusionListDef)/sizeof(USHORT *));

USHORT  *vrgwBandwidthConservationListDef[] =
{
    L"*.EXE",
    L"*.DLL",
    L"*.SYS",
    L"*.COM",
    L"*.HLP",
    L"*.CPL",
    L"*.INF"
};

USHORT  **vlplpBandwidthConservationList = vrgwBandwidthConservationListDef;

ULONG   vcntBandwidthConservationListEntries = (sizeof(vrgwBandwidthConservationListDef)/sizeof(USHORT *));

USHORT vtzExcludedCharsList[] = L":*?";

ULONG hShadowSpecial_x = -1;
VMM_SEMAPHORE  semShadow=0; // To serialize Shadow database accesses
ULONG hShadowCritOwner=0;
#ifdef DEBUG
BOOL vfInShadowCrit = FALSE;
extern BOOL vfStopHandleCaching;
#endif

char vszShadowVolume[] = "SHADOW";
USHORT  vwszFileSystemName[] = L"FAT";

FILERECEXT  vsFRExt;
BOOL vfInuseFRExt = FALSE;
LPVOID lpdbShadow = NULL;

// vdwSparseStaleDetecionCount is a tick counter used to keep track of how many stale or sparse
// file inodes were encountered by the cshadow interface during all APIs that produce
// sparse or stale files, such as CreateShadowInternal, SetShadowinfoEx and ReadShadowInfo
// The agent continues to loop through the PQ till he finds that he has looped through
// the entire PQ and hasn't encountered a single sparse or stale file at which point he
// goes in a mode where he starts to check whether any inodes have been newly sparsed
// or gone stale. If none are, then he doesn't enumerate the queue, else he goes to
// the earlier state.

// ACHTUNG: It is to be noted that a sparse or a stale entry may get counted multiple times.
// As an example, when a shadow is created the count is bumped once, then if it's
// pin data is changed it is bumped up, similarly when it is moved in the priority Q
// it is again changed because SetPriorityHSHADOW goes through SetShadowInfoEx

DWORD   vdwSparseStaleDetecionCount=0;
DWORD   vdwManualFileDetectionCount=0;

// vdwCSCNameSpaceVersion is bumped up everytime a create,rename or delete is performed on
// the local database. This is useful for quickly checking cache-coherency. When a full
// UNC name is cached, the version# of the database is obtained before caching. When using the
// cached UNC name, the version # is queried. If it has changed, the cache is thrown away.
// The version is at a very coarse granularity. It would be nice to have a finer control

DWORD   vdwCSCNameSpaceVersion=0;
DWORD   vdwPQVersion=0;

AssertData
AssertError

// a callback function that someone can set and be called when a directory delete succeeds
// this is useful only for ioctls doing finds on a directory, at the moment
// If there is a more general need for callbacks, we will extend this to be a list etc.

LPDELETECALLBACK    lpDeleteCBForIoctl = NULL;

// status of the database. Used mostly for encryption state
ULONG   vulDatabaseStatus=0;

// Local function prototypes -----------------------------------------------------------

int PRIVATE ReadShadowInfo(HSHADOW, HSHADOW, LPFIND32, ULONG far *, LPOTHERINFO, LPVOID, LPDWORD, ULONG);
int CopyFilerecToOtherInfo(LPFILERECEXT lpFR, LPOTHERINFO lpOI);
int CopyOtherInfoToFilerec(LPOTHERINFO lpOI, LPFILERECEXT lpFR);
int CreateShadowInternal(HSHADOW, LPFIND32, ULONG, LPOTHERINFO, LPHSHADOW);
int CopySharerecToFindInfo(LPSHAREREC, LPFIND32);
int CopyOtherInfoToSharerec(LPOTHERINFO, LPSHAREREC);
int CopyPQToOtherInfo(LPPRIQREC, LPOTHERINFO);
int CopyOtherInfoToPQ(LPOTHERINFO, LPPRIQREC);
int CopySharerecToShadowInfo(LPSHAREREC       lpSR, LPSHADOWINFO lpSI);
int RenameDirFileHSHADOW(HSHADOW, HSHADOW, HSHARE, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, ULONG, LPFILERECEXT, LPFIND32, LPVOID, LPDWORD);
int RenameFileHSHADOW(HSHADOW, HSHADOW, HSHADOW, HSHADOW, ULONG, LPOTHERINFO, ULONG, LPFILERECEXT, LPFIND32, LPVOID, LPDWORD);
int DestroyShareInternal(LPSHAREREC);

//prototypes added to make it compile on NT
int PUBLIC SetPriorityHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG ulRefPri,
    ULONG ulIHPri
    );

int CopySharerecToOtherInfo(LPSHAREREC lpSR, LPOTHERINFO lpOI);

int MetaMatchShare(
    HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG *lpuCookie,
    LPHSHADOW    lphShadow,
    ULONG *lpuStatus,
    LPOTHERINFO lpOI,
    METAMATCHPROC    lpfnMMP,
    LPVOID            lpData
    );

int MetaMatchDir( HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG *lpuCookie,
    LPHSHADOW    lphShadow,
    ULONG *lpuStatus,
    LPOTHERINFO lpOI,
    METAMATCHPROC    lpfnMMP,
    LPVOID            lpData
    );

int
DeleteShadowInternal(                           //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    BOOL            fForce
    );

int
CShadowFindFilerecFromInode(
    LPVOID  lpdbID,
    HSHADOW hDir,
    HSHADOW hShadow,
    LPPRIQREC lpPQ,
    LPFILERECEXT    lpFRUse
    );

BOOL
CopySecurityContextToBuffer(
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext,
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize
    );

BOOL
CopyBufferToSecurityContext(
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize,
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext
    );

int CopyFindInfoToSharerec(
    LPFIND32 lpFind32,
    LPSHAREREC lpSR
    );

#ifdef DEBUG
int
ValidatePri(
    LPFILERECEXT lpFR
    );
#endif


VOID
AdjustSparseStaleDetectionCount(
    ULONG hShare,
    LPFILERECEXT    lpFRUse
    );

VOID FreeLists(
    VOID
);

VOID
CscNotifyAgentOfFullCacheIfRequired(
    VOID);


//
// From cscapi.h
//
#define FLAG_CSC_SHARE_STATUS_MANUAL_REINT              0x0000
#define FLAG_CSC_SHARE_STATUS_AUTO_REINT                0x0040
#define FLAG_CSC_SHARE_STATUS_VDO                       0x0080
#define FLAG_CSC_SHARE_STATUS_NO_CACHING                0x00c0
#define FLAG_CSC_SHARE_STATUS_CACHING_MASK              0x00c0

// Functions -------------------------------------------------------------------------------


BOOL FExistsShadowDB(
    LPSTR  lpszLocation
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (FExistsRecDB(lpszLocation));
}

int OpenShadowDB(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   dwDefDataSizeHigh,
    DWORD   dwDefDataSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReinit,
    BOOL    *lpfReinited
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD Status;
    BOOL fEncrypt;
    
    if (!semShadow)
    {
        CShadowKdPrint(ALWAYS,("OpenShadowDB:Shadow Semaphore doesn't exist, bailing out \r\n"));
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return -1;
    }

    Status = CscInitializeSecurityDescriptor();

    if (Status != ERROR_SUCCESS) {
        CShadowKdPrint(BADERRORS,("Failed to initialize Security descriptor Status=%x\n",Status));
        return -1;
    }

    if (!(lpdbShadow = OpenRecDB(lpszLocation, lpszUserName, dwDefDataSizeHigh, dwDefDataSizeLow, dwClusterSize, fReinit, lpfReinited, &vulDatabaseStatus)))
    {
        return -1;
    }

    Status = CscInitializeSecurity(lpdbShadow);

    if (Status != ERROR_SUCCESS)
    {
        CloseShadowDB();
        CscUninitializeSecurityDescriptor();

        CShadowKdPrint(BADERRORS,("OpenShadowDB  %s at %s for %s with size %ld %lx \n",
               "couldn't Initialize Security %lx",
               lpszLocation, lpszUserName, dwDefDataSizeLow,Status));

        return -1;
    }

    fEncrypt = -1;
    
    if(mDatabasePartiallyEncrypted(vulDatabaseStatus))
    {
        fEncrypt = TRUE;
    }
    else if (mDatabasePartiallyUnencrypted(vulDatabaseStatus))
    {
        fEncrypt = FALSE;
    }
    // do the best we can 
    if (fEncrypt != -1)
    {
        if(EncryptDecryptDB(lpdbShadow, fEncrypt))
        {
            if (fEncrypt)
            {
                vulDatabaseStatus = ((vulDatabaseStatus & ~FLAG_DATABASESTATUS_ENCRYPTION_MASK) | FLAG_DATABASESTATUS_ENCRYPTED);
            }
            else
            {
                vulDatabaseStatus = ((vulDatabaseStatus & ~FLAG_DATABASESTATUS_ENCRYPTION_MASK) | FLAG_DATABASESTATUS_UNENCRYPTED);
            }
            
            SetDatabaseStatus(vulDatabaseStatus, FLAG_DATABASESTATUS_ENCRYPTION_MASK);
        }
    }
    

//    CSCInitLists();

    return 1;
}

int CloseShadowDB(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (!lpdbShadow)
    {
        return -1;
    }

    if(!CloseRecDB(lpdbShadow))
    {
        return -1;
    }

    CscUninitializeSecurityDescriptor();

    FreeLists();

    lpdbShadow = NULL;

    Assert(semShadow != 0);

    return (1);
}

//on NT, we allocate this statically
#ifdef CSC_RECORDMANAGER_WINNT
FAST_MUTEX Nt5CscShadowMutex;
#endif

BOOL
InitializeShadowCritStructures (
    void
    )
{
#ifndef CSC_RECORDMANAGER_WINNT
    semShadow = Create_Semaphore(1);
#else
    semShadow = &Nt5CscShadowMutex;
    ExInitializeFastMutex(semShadow);
#endif
    return (semShadow != 0);
}

VOID
CleanupShadowCritStructures(
    VOID
    )
{

//    Assert(semShadow);
#ifndef CSC_RECORDMANAGER_WINNT
    Destroy_Semaphore(semShadow);
#else
    semShadow = NULL;
#endif

}

#ifdef DEBUG
WINNT_DOIT(
    PSZ ShadowCritAcquireFile;
    ULONG ShadowCritAcquireLine;
    BOOLEAN ShadowCritDbgPrintEnable = FALSE; //TRUE;
    )
#endif

#ifndef CSC_RECORDMANAGER_WINNT
int EnterShadowCrit( void)
#else
int __EnterShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE)
#endif
{
#ifdef CSC_RECORDMANAGER_WINNT

    if(!MRxSmbIsCscEnabled) {
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        DbgPrint("CSC not enabled, not asserting for semShadow\n");
        return(1);
    }
#endif
    Assert(semShadow != NULL);


    ENTERCRIT_SHADOW;


    hShadowCritOwner = GetCurThreadHandle();

#ifdef DEBUG
    ++vfInShadowCrit;
    WINNT_DOIT(
    ShadowCritAcquireFile = FileName;
    ShadowCritAcquireLine = LineNumber;
    if (ShadowCritDbgPrintEnable) {
        DbgPrint("ACQUIRESHADOWCRIT at %s %u\n",FileName,LineNumber);
    }
    )
#endif
    return 1;
}

#ifndef CSC_RECORDMANAGER_WINNT
int LeaveShadowCrit( void)
#else
int __LeaveShadowCrit(ENTERLEAVESHADOWCRIT_SIGNATURE)
#endif
{
#ifdef CSC_RECORDMANAGER_WINNT
    
    if(!MRxSmbIsCscEnabled) {
        DbgPrint("CSC not enabled, not asserting for vfInShadowCrit\n");
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return(1);
    }
#endif
    Assert(vfInShadowCrit != 0);
#ifdef DEBUG
    --vfInShadowCrit;
    WINNT_DOIT(
    ShadowCritAcquireLine *= -1;
    if (ShadowCritDbgPrintEnable) {
        DbgPrint("RELEASESHADOWCRIT at %s %u\n",FileName,LineNumber);
    }
    )
#endif
    hShadowCritOwner = 0;
    LEAVECRIT_SHADOW;
    return 1;
}

int LeaveShadowCritIfThisThreadOwnsIt(
    void
    )
{
    if (hShadowCritOwner == GetCurThreadHandle())
    {
        LeaveShadowCrit();
    }

    return 1;
}

int SetList(
    USHORT  *lpList,
    DWORD   cbBufferSize,
    int     typeList
    )
/*++

Routine Description:

    This routine sets various lists that the CSHADOW interface provides. The known lists include
    the exclusion list and the bandwidth conservation list.

    The exclusion list contains wildcarded file extensions that should not be cached automatically.
    The bandwidth conservation list is the list of file types for which opens should be
    done locally if possible.

Parameters:

    lpList     A list of wide character strings terminated by a NULL string

    typeList            CSHADOW_LIST_TYPE_EXCLUDE or CSHADOW_LIST_TYPE_CONSERVE_BW

Return Value:

Notes:


--*/
{
    DWORD   dwCount=0;
    USHORT  **lplpListArray = NULL, *lpuT;
    int iRet = -1;
    BOOL    fUpdateList = FALSE;

    if (cbBufferSize)
    {
        CShadowKdPrint(MISC, (" %ws\r\n", lpList));

#if 0
        if (typeList == CSHADOW_LIST_TYPE_EXCLUDE)
        {
            DbgPrint("ExclusionList: %ws\n", lpList);
        }
        if (typeList == CSHADOW_LIST_TYPE_CONSERVE_BW)
        {
            DbgPrint("BW: %ws\n", lpList);
        }
#endif
        
        if (CreateStringArrayFromDelimitedList(lpList, vwzRegDelimiters, NULL, &dwCount))
        {
            if (dwCount)
            {
                lplpListArray = (LPWSTR *)AllocMem(dwCount * sizeof(USHORT *) + cbBufferSize);

                if (lplpListArray)
                {
                    lpuT = (USHORT *)((LPBYTE)lplpListArray + dwCount * sizeof(USHORT *));

                    // copy it while uppercasing
                    memcpy(lpuT, lpList, cbBufferSize);

                    UniToUpper(lpuT, lpuT, cbBufferSize);

                    if (CreateStringArrayFromDelimitedList( lpuT,
                                                            vwzRegDelimiters,
                                                            lplpListArray,
                                                            &dwCount))
                    {
                        fUpdateList = TRUE;

                    }

                }
            }
            else
            {
                Assert(lplpListArray == NULL);
                fUpdateList = TRUE;
            }

            if (fUpdateList)
            {
                switch (typeList)
                {
                    case CSHADOW_LIST_TYPE_EXCLUDE:

                        if(vlplpExclusionList != vrgwExclusionListDef)
                        {
                            if (vlplpExclusionList)
                            {
                                FreeMem(vlplpExclusionList);
                            }

                        }

                        vlplpExclusionList = lplpListArray;
                        vcntExclusionListEntries = dwCount;
                        iRet = 0;
                        break;
                    case CSHADOW_LIST_TYPE_CONSERVE_BW:
                        if(vlplpBandwidthConservationList != vrgwBandwidthConservationListDef)
                        {
                            if (vlplpBandwidthConservationList)
                            {
                                FreeMem(vlplpBandwidthConservationList);
                            }

                        }

                        vlplpBandwidthConservationList = lplpListArray;
                        vcntBandwidthConservationListEntries = dwCount;

                        iRet = 0;

                        break;
                    default:
                        break;
                }
            }
        }
    }

    if (iRet == -1)
    {
        if (lplpListArray)
        {
            FreeMem(lplpListArray);
        }
    }

    return (iRet);
}


VOID FreeLists(
    VOID
)
/*++

Routine Description:

    Free the user associated lists and set them back to the default

Parameters:

    None

Return Value:

    None

Notes:

    Called while shutting down the database

--*/
{
    if(vlplpExclusionList != vrgwExclusionListDef)
    {
        if (vlplpExclusionList)
        {
            FreeMem(vlplpExclusionList);
            vlplpExclusionList = NULL;
        }

        vlplpExclusionList = vrgwExclusionListDef;
        vcntExclusionListEntries = (sizeof(vrgwExclusionListDef)/sizeof(USHORT *));

    }

    if(vlplpBandwidthConservationList != vrgwBandwidthConservationListDef)
    {
        if (vlplpBandwidthConservationList)
        {
            FreeMem(vlplpBandwidthConservationList);
            vlplpBandwidthConservationList = NULL;
        }

        vcntBandwidthConservationListEntries = 0;
    }

}


int BeginInodeTransactionHSHADOW(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

    This routine ensures that an inode is not reused while this is happening. It is used by various APIs so that while they
    are travesring a hierarchy, they don't end up pointing somewhere else if they refer to an inode.

--*/
{
    if (!lpdbShadow)
    {
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return -1;
    }
    BeginInodeTransaction();

    return 1;
}

int EndInodeTransactionHSHADOW(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

    The converse of BeginInodeTransaction. The timespan betwen the two is supposed to be very short (20 sec).

--*/
{
    if (!lpdbShadow)
    {
        SetLastErrorLocal(ERROR_SERVICE_NOT_ACTIVE);
        return -1;
    }

    EndInodeTransaction();

    return 1;

}

HSHADOW  HAllocShadowID( HSHADOW  hDir,
    BOOL      fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    HSHADOW  hShadow;

    Assert(vfInShadowCrit != 0);

    hShadow = UlAllocInode(lpdbShadow, hDir, fFile);

    return (hShadow);
}

int FreeShadowID( HSHADOW  hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return(FreeInode(lpdbShadow, hShadow));
}

int GetShadowSpaceInfo(
    LPSHADOWSTORE  lpShSt
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER sSH;

    if (ReadShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    lpShSt->sMax = sSH.sMax;
    lpShSt->sCur = sSH.sCur;
    lpShSt->uFlags= sSH.uFlags;
    
    return SRET_OK;
}

int SetMaxShadowSpace(
    long nFileSizeHigh,
    long nFileSizeLow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER sSH;

    if (ReadShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    Win32ToDosFileSize(nFileSizeHigh, nFileSizeLow, &(sSH.sMax.ulSize));
    if (WriteShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    return SRET_OK;
}

int AdjustShadowSpace(
    long nFileSizeHighOld,
    long nFileSizeLowOld,
    long nFileSizeHighNew,
    long nFileSizeLowNew,
    BOOL fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD dwFileSizeNew, dwFileSizeOld;
    STOREDATA sSD;
    int iRet = 0;

    memset(&sSD, 0, sizeof(STOREDATA));

    dwFileSizeNew = RealFileSize(nFileSizeLowNew);
    dwFileSizeOld = RealFileSize(nFileSizeLowOld);

    if (dwFileSizeNew > dwFileSizeOld)
    {
        sSD.ulSize = dwFileSizeNew - dwFileSizeOld;
        iRet = AddStoreData(lpdbShadow, &sSD);
    }
    else if (dwFileSizeNew < dwFileSizeOld)
    {
        sSD.ulSize = dwFileSizeOld - dwFileSizeNew;
        iRet = SubtractStoreData(lpdbShadow, &sSD);
    }

    return (iRet);
}

int AllocShadowSpace(
    long nFileSizeHigh,
    long nFileSizeLow,
    BOOL  fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    STOREDATA sSD;

    memset(&sSD, 0, sizeof(STOREDATA));
    sSD.ulSize = RealFileSize(nFileSizeLow);
    AddStoreData(lpdbShadow, &sSD);

    return (0);
}

int FreeShadowSpace(
    long nFileSizeHigh,
    long nFileSizeLow,
    BOOL  fFile
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    STOREDATA sSD;

    memset(&sSD, 0, sizeof(STOREDATA));
    sSD.ulSize = RealFileSize(nFileSizeLow);
    SubtractStoreData(lpdbShadow, &sSD);

    return (0);
}

int
SetDatabaseStatus(
    ULONG   ulStatus,
    ULONG   uMask
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREHEADER sSH;


    if (ReadShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;

    sSH.uFlags &= ~uMask;
    sSH.uFlags |= ulStatus;    
    
    
    if (WriteShareHeader(lpdbShadow, &sSH) < SRET_OK)
        return SRET_ERROR;
    
    vulDatabaseStatus = sSH.uFlags;
            
    return SRET_OK;
}
    
int
GetDatabaseInfo(
    SHAREHEADER *psSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (ReadShareHeader(lpdbShadow, psSH) < SRET_OK)
        return SRET_ERROR;
    return SRET_OK;
}


int GetLocalNameHSHADOW( HSHADOW  hShadow,
    LPBYTE    lpName,
    int       cbSize,
    BOOL      fExternal
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName, lpT;
    int iRet = SRET_ERROR;

    lpT = lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
    {
        return (SRET_ERROR);
    }

    if (fExternal)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        lpT = lpszName + (sizeof(NT_DB_PREFIX)-1);
#endif
    }

    // bad interface, caller can't know what the problem was; needed to send in a pointer to cbSize

    if (strlen(lpT) < ((ULONG)cbSize))
    {
        strcpy(lpName, lpT);
        iRet = SRET_OK;
    }

    FreeNameString(lpszName);

    return iRet;
}

int GetWideCharLocalNameHSHADOW(
    HSHADOW  hShadow,
    USHORT      *lpBuffer,
    LPDWORD     lpdwSize,
    BOOL        fExternal
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName, lpT;
    int iRet = SRET_ERROR;
    DWORD   dwRequiredSize;

    lpT = lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
    {
        return (SRET_ERROR);
    }

    if (fExternal)
    {
#ifdef CSC_RECORDMANAGER_WINNT
        lpT = lpszName + (sizeof(NT_DB_PREFIX)-1);
#endif
    }

    dwRequiredSize = (strlen(lpT)+1)*sizeof(USHORT);

    // bad interface, caller can't know what the problem was; needed to send in a pointer to cbSize

    if ( dwRequiredSize <= *lpdwSize)
    {
        BCSToUni(lpBuffer, lpT, dwRequiredSize/sizeof(USHORT), BCS_WANSI);
        iRet = SRET_OK;
    }
    else
    {
        SetLastErrorLocal(ERROR_MORE_DATA);
        *lpdwSize = dwRequiredSize;
    }

    FreeNameString(lpszName);

    return iRet;
}

int CreateFileHSHADOW(
    HSHADOW hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    LPSTR   lpszName;
    int iRet = SRET_ERROR;
    ULONG   ulAttrib = 0;
    
    lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
    {
        return (SRET_ERROR);
    }
    
    // Nuke it if it exists, this is a very strict semantics
    if(DeleteFileLocal(lpszName, ATTRIB_DEL_ANY) < SRET_OK)
    {
        if((GetLastErrorLocal() !=ERROR_FILE_NOT_FOUND) && 
            (GetLastErrorLocal() !=ERROR_PATH_NOT_FOUND))
        {
            FreeNameString(lpszName);
            return (SRET_ERROR);
        }
    }

    ulAttrib = ((IsLeaf(hShadow) && mDatabaseEncryptionEnabled(vulDatabaseStatus))? FILE_ATTRIBUTE_ENCRYPTED:0);
        
    if ((hf = R0OpenFileEx(ACCESS_READWRITE, ACTION_CREATEALWAYS, ulAttrib, lpszName, FALSE)))
    {
        CloseFileLocal(hf);
        iRet = SRET_OK;
    }
    
    FreeNameString(lpszName);
    return iRet;
}

#if defined(BITCOPY)
int OpenFileHSHADOWAndCscBmp(
    HSHADOW hShadow,
    USHORT usOpenFlags,
    UCHAR  bAction,
    CSCHFILE far *lphf,
    BOOL fOpenCscBmp,
    DWORD filesize, // if !fOpenCscBmp this field is ignored
    LPCSC_BITMAP * lplpbitmap
    )
#else
int OpenFileHSHADOW(
    HSHADOW hShadow,
    USHORT usOpenFlags,
    UCHAR  bAction,
    CSCHFILE far *lphf
    )
#endif // defined(BITCOPY)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    LPSTR   lpszName = NULL;
    int iRet = SRET_ERROR;
    ULONG   ulAttrib = 0;
    
    *lphf = NULL;
    lpszName = FormNameString(lpdbShadow, hShadow);

    if (!lpszName)
        return (SRET_ERROR);


    if (!(bAction & (ACTION_NEXISTS_CREATE|ACTION_CREATEALWAYS))) {
        *lphf = OpenFileLocal(lpszName);
        if (*lphf != NULL) {
#if defined(BITCOPY)
            if (fOpenCscBmp)
                CscBmpRead(lplpbitmap, lpszName, filesize);
#endif // defined(BITCOPY)
            iRet = SRET_OK;
        }
    } else {
        // Nuke it if it exists, this is a very strict semantics
        if (DeleteFileLocal(lpszName, ATTRIB_DEL_ANY) < SRET_OK) {
            if ((GetLastErrorLocal() != ERROR_FILE_NOT_FOUND) && 
                    (GetLastErrorLocal() != ERROR_PATH_NOT_FOUND)) {
                iRet = SRET_ERROR;
                goto Cleanup;
            }
        }

        ulAttrib = 0;
        if (IsLeaf(hShadow) && mDatabaseEncryptionEnabled(vulDatabaseStatus))
            ulAttrib = FILE_ATTRIBUTE_ENCRYPTED;
        
        *lphf = R0OpenFileEx(
                        ACCESS_READWRITE,
                        ACTION_CREATEALWAYS,
                        ulAttrib,
                        lpszName,
                        FALSE);

        if (*lphf != NULL) {
#if defined(BITCOPY)
            if (fOpenCscBmp)
                CscBmpRead(lplpbitmap, lpszName, 0);
#endif // defined(BITCOPY)
            iRet = SRET_OK;
        }
    }

      
Cleanup:
    if (lpszName != NULL)
        FreeNameString(lpszName);


    return iRet;
}

#if defined(BITCOPY)
int
OpenCscBmp(
    HSHADOW hShadow,
    LPCSC_BITMAP *lplpbitmap)
{
    LPSTR strmName = NULL;
    int iRet = SRET_ERROR;
    ULONG fileSizeLow;
    ULONG fileSizeHigh;

    strmName = FormAppendNameString(lpdbShadow, hShadow, CscBmpAltStrmName);
    if (strmName == NULL)
        return (SRET_ERROR);
    
    if (GetSizeHSHADOW(hShadow, &fileSizeHigh, &fileSizeLow) < SRET_OK)
          fileSizeLow = 0; // Set the bitmap size to 0 so it can expand later on

    if (CscBmpRead(lplpbitmap, strmName, fileSizeLow) == 1)
      iRet = SRET_OK;

    FreeNameString(strmName);

    return iRet;
}
#endif // defined(BITCOPY)


int GetSizeHSHADOW( HSHADOW  hShadow,
    ULONG *lpnFileSizeHigh,
    ULONG *lpnFileSizeLow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uSize;
    if (GetInodeFileSize(lpdbShadow, hShadow, &uSize) < SRET_OK)
        return SRET_ERROR;
    DosToWin32FileSize(uSize, lpnFileSizeHigh, lpnFileSizeLow);
    return (0);
}

int GetDosTypeSizeHSHADOW( HSHADOW  hShadow,
    ULONG *lpFileSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (GetInodeFileSize(lpdbShadow, hShadow, lpFileSize) < SRET_OK)
        return SRET_ERROR;
    return (0);
}


BOOL PUBLIC
ExcludeFromCreateShadow(
    USHORT  *lpuName,
    ULONG   len,
    BOOL    fCheckFileTypeExclusionList
    )
/*++

Routine Description:

Parameters:

    lpuName                 File name

    len                     size

    fCheckFileTypeExclusionList if !FALSE, check exclusion list as well as the metacharacter rules
                                if FALSE check only the character exclusion rules

Return Value:

Notes:


--*/
{
    ULONG i;
    USHORT  *lpuT1;
    BOOL    fRet = FALSE;


    if (!len || (len> MAX_PATH))
    {
        return TRUE;
    }

    UseGlobalFilerecExt();

    lpuT1 = (USHORT *)&vsFRExt;

    memcpy(lpuT1, lpuName, len * sizeof(USHORT));

    lpuT1[len] = 0;

    if (!wstrpbrk(lpuT1, vtzExcludedCharsList))
    {

        //
        if (fCheckFileTypeExclusionList)
        {
            for (i=0; i< vcntExclusionListEntries; ++i)
            {
                if(IFSMgr_MetaMatch(vlplpExclusionList[i], lpuT1, UFLG_NT|UFLG_META))
                {
                    fRet = TRUE;
                    break;
                }
            }
        }
    }
    else
    {
        fRet = TRUE;    // exclude
    }

    UnUseGlobalFilerecExt();

    return fRet;
}

BOOL PUBLIC
CheckForBandwidthConservation(
    USHORT  *lpuName,
    ULONG   len
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG i;
    USHORT  *lpuT1;
    BOOL    fRet = FALSE;

    if (!len || (len> MAX_PATH))
    {
        return FALSE;
    }

    UseGlobalFilerecExt();

    lpuT1 = (USHORT *)&vsFRExt;

    memcpy(lpuT1, lpuName, len * sizeof(USHORT));

    lpuT1[len] = 0;

    for (i=0; i< vcntBandwidthConservationListEntries; ++i)
    {
        if(IFSMgr_MetaMatch(vlplpBandwidthConservationList[i], lpuT1, UFLG_NT|UFLG_META))
        {
            fRet = TRUE;
            break;
        }
    }

    UnUseGlobalFilerecExt();

    return fRet;
}

int PUBLIC                      // ret
CreateShadow(                               //
    HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG uFlags,
    LPHSHADOW   lphNew,
    BOOL            *lpfCreated
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uStatus;
    int iRet = SRET_ERROR;

    Assert(vfInShadowCrit != 0);

    if (lpfCreated)
    {
        *lpfCreated = FALSE;
    }

    mClearBits(uFlags, SHADOW_NOT_FSOBJ);
    if (GetShadow(hDir, lpFind32->cFileName, lphNew, NULL, &uStatus, NULL)>=SRET_OK)
    {

        if (*lphNew)
        {
            CShadowKdPrint(ALWAYS,("CreateShadow: already exists for %ws\r\n", lpFind32->cFileName));

            if (mNotFsobj(uStatus))
            {
                iRet = SRET_ERROR;
            }
            else
            {
                iRet = SetShadowInfo(hDir, *lphNew, lpFind32, uFlags, SHADOW_FLAGS_ASSIGN);
            }
        }
        else
        {
            iRet = CreateShadowInternal(hDir, lpFind32, uFlags, NULL, lphNew);

            if ((iRet >= SRET_OK) && lpfCreated)
            {
                *lpfCreated = TRUE;
            }
        }
    }
    return (iRet);
}

int PUBLIC                      // ret
CreateShadowInternal(
    HSHADOW  hDir,
    LPFIND32 lpFind32,
    ULONG uFlags,
    LPOTHERINFO lpOI,
    LPHSHADOW  lphNew
    )
/*++

Routine Description:

    Routine that creates database entries for all names other than the root of a share
    HCreateShareObj deals with createing the share entry where the root of the share gets created

Parameters:

    hDir        Directory inode in which to create the entry

    lpFind32    WIN32_FIND_DATA info to be kept in the database

    uFlags      status flags (SHADOW_XXXX in csc\inc\shdcom.h) to be assigned to this entry

    lpOI        all the rest of the metadata needed for managing the entry. May be NULL

    lphNew      out parameter, returns the inode that was created if successful

Return Value:

Notes:


--*/
{
    PRIQREC  sPQ;
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    HSHADOW  hNew=0, hAncestor=0;
    HSHARE hShare=0;
    ULONG ulRefPri=MAX_PRI, ulrecDirEntry=INVALID_REC, ulHintPri=0, ulHintFlags=0;
    STOREDATA sSD;

    Assert(vfInShadowCrit != 0);

    if (!(!hDir || IsDirInode(hDir)))
        return SRET_ERROR;

    BEGIN_TIMING(CreateShadowInternal);

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    memset(lpFRUse, 0, sizeof(FILERECEXT));

    // Don't do anything for server yet
    if (hDir)
    {

        *lphNew = hNew = UlAllocInode(lpdbShadow, hDir, IsFile(lpFind32->dwFileAttributes));

        if (!hNew)
        {
            CShadowKdPrint(BADERRORS,("Error creating shadow Inode\r\n"));
            goto bailout;
        }


        if (IsFile(lpFind32->dwFileAttributes))
        {
            if (lpFind32->nFileSizeHigh)
            {
                SetLastErrorLocal(ERROR_ONLY_IF_CONNECTED);
                goto bailout;
            }

            if(CreateFileHSHADOW(hNew) == SRET_ERROR)
            {
                CShadowKdPrint(BADERRORS,("Error creating shadow data for %x \r\n", hNew));
                goto bailout;
            }
            // start file priorities with max
            ulRefPri=MAX_PRI;
        }
        else
        {
            if(CreateDirInode(lpdbShadow, 0, hDir, hNew) < 0)
            {
                CShadowKdPrint(BADERRORS,("Error creating shadow data for %x \r\n", hNew));
                goto bailout;
            }
            // start directory priorities with MIN_PRI, this is to optimize
            // later moving
            // A better solution might be to change createshadow to take refpri and pincount
            // as parameters
            ulRefPri=MIN_PRI;
        }


        CopyFindInfoToFilerec(lpFind32, lpFRUse, CPFR_INITREC|CPFR_COPYNAME);
        //RxDbgTrace(0,Dbg,("CreateShadowInternal3 %s %s\n",
        //                          lpFRUse->sFR.rgcName, lpFRUse->sFR.rg83Name));

        lpFRUse->sFR.uchRefPri = (UCHAR)ulRefPri;
        lpFRUse->sFR.uchHintPri = (UCHAR)ulHintPri;
        lpFRUse->sFR.uchHintFlags = (UCHAR)ulHintFlags;

        // overwite filerec with any info that the user gave
        if (lpOI)
        {
            CShadowKdPrint(CREATESHADOWHI,("ulHintPri=%x ulHintFlags=%x\r\n",lpOI->ulHintPri, lpOI->ulHintFlags));
            CopyOtherInfoToFilerec(lpOI, lpFRUse);
        }

        lpFRUse->sFR.ftOrgTime = lpFRUse->sFR.ftLastWriteTime;

        CShadowKdPrint(CREATESHADOWHI,("CreateShadow: %x for %ws: loctLo=%x loctHi=%x \r\n",
                 hNew,
                 lpFRUse->sFR.rgwName,
                lpFRUse->sFR.ftOrgTime.dwLowDateTime,
                lpFRUse->sFR.ftOrgTime.dwHighDateTime));

        lpFRUse->sFR.ulidShadow = hNew;
        lpFRUse->sFR.uStatus = (USHORT)uFlags;
        lpFRUse->sFR.ulLastRefreshTime = (ULONG)IFSMgr_Get_NetTime();

        // if this entry is being created offline, then it doesn't have any original inode
        if (uFlags & SHADOW_LOCALLY_CREATED)
        {
            lpFRUse->sFR.ulidShadowOrg = 0;
        }
        else
        {
            lpFRUse->sFR.ulidShadowOrg = hNew;
        }

#ifdef DEBUG
        ValidatePri(lpFRUse);
#endif
        if(!(ulrecDirEntry = AddFileRecordFR(lpdbShadow, hDir, lpFRUse)))
        {
            // could be legit failure if we are running out of disk space
            CShadowKdPrint(CREATESHADOWHI,("Failed AddFileRecordFR for %x, %ws\r\n",
                 hNew,
                 lpFRUse->sFR.rgwName));

            goto bailout;
        }

        Assert(ulrecDirEntry != INVALID_REC);


        if(FindAncestorsFromInode(lpdbShadow, hDir, &hAncestor, &hShare) < 0)
        {
            CShadowKdPrint(CREATESHADOWHI,("Failed to find ancestor for %x, %ws\r\n",
                 hNew,
                 lpFRUse->sFR.rgwName));

            goto bailout;
        }

        // mark the inode as locally created or not
        // NB, this flag has meaning only for the inode
        // We use this information during reintegration of
        // renames and deletes

        if (uFlags & SHADOW_LOCALLY_CREATED)
        {
            uFlags |= SHADOW_LOCAL_INODE;
        }
        else
        {
            uFlags &= ~SHADOW_LOCAL_INODE;
        }

        if (AddPriQRecord(  lpdbShadow,
                            hShare,
                            hDir,
                            hNew,
                            uFlags,
                            (ULONG)(lpFRUse->sFR.uchRefPri),
                            (ULONG)(lpFRUse->sFR.uchIHPri),
                            (ULONG)(lpFRUse->sFR.uchHintPri),
                            (ULONG)(lpFRUse->sFR.uchHintFlags),
                            ulrecDirEntry) < 0)
        {
            CShadowKdPrint(CREATESHADOWHI,("Failed to AddPriQRecord for %x, %ws\r\n",
             hNew,
             lpFRUse->sFR.rgwName));
            Assert(FALSE);

            goto bailout;
        }


        // The check below was is a holdover from our now-defunct hints scheme
        if (!mNotFsobj(lpFRUse->sFR.uStatus))
        {
            memset(&sSD, 0, sizeof(STOREDATA));

            CShadowKdPrint(CREATESHADOWHI,("uchHintPri=%x uchHintFlags=%x\r\n",lpFRUse->sFR.uchHintPri, lpFRUse->sFR.uchHintFlags));

            if ((!(lpFind32->dwFileAttributes &
                                     (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE))))
            {
                sSD.ucntFiles++;
                // if there is a initial pin count or special pinflags are set
                // then this files data  should not be considered for space accounting

                sSD.ulSize = (lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags))?0:RealFileSize(lpFRUse->sFR.ulFileSize);

            }
            else
            {
                sSD.ucntDirs++;

            }

            if (sSD.ulSize)
            {
                CShadowKdPrint(STOREDATA,("CreateShadowInternal: Adding %d for hDir=%x Name=%ws\r\n", sSD.ulSize, hDir, lpFind32->cFileName));
            }
            else
            {
                if ((!(lpFind32->dwFileAttributes &
                                     (FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_DEVICE)))
                                     && RealFileSize(lpFRUse->sFR.ulFileSize)
                                     )
                {
                    Assert((lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)));
                }
            }
            AddStoreData(lpdbShadow, &sSD);
            AdjustSparseStaleDetectionCount(hShare, lpFRUse);
        }
        
        vdwCSCNameSpaceVersion++;
        vdwPQVersion++;
        
        iRet = SRET_OK;
    }

bailout:
    if (iRet==SRET_ERROR)
    {
        if (hNew)
        {
            FreeInode(lpdbShadow, hNew);
        }
    }
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();

    END_TIMING(CreateShadowInternal);

    return iRet;
}


int
DeleteShadow(
    HSHADOW     hDir,
    HSHADOW     hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return DeleteShadowInternal(hDir, hShadow, FALSE);      // try a gentle delete
}

ULONG DelShadowInternalEntries = 0;
#define JOE_DECL_CURRENT_PROGRESS CscProgressDelShdwI
JOE_DECL_PROGRESS();

int
DeleteShadowInternal(                           //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    BOOL        fForce
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    STOREDATA sSD;
    int iRet= SRET_ERROR;
    PRIQREC sPQ;
    LPFILERECEXT lpFR = NULL, lpFRUse;

    Assert(vfInShadowCrit != 0);

    DelShadowInternalEntries++;
    JOE_INIT_PROGRESS(DelShadowInternalEntries,&hDir);

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    if (!hDir)
    {
        if(FindSharerecFromInode(lpdbShadow, hShadow, (LPSHAREREC)lpFRUse))
        {
            if (fForce || !HasDescendents(lpdbShadow, 0, ((LPSHAREREC)lpFRUse)->ulidShadow))
            {
                iRet = DestroyShareInternal((LPSHAREREC)lpFRUse);
            }
        }
    }
    else
    {
        int iRetInner;

        //ASSERT(hShadow!=0);
        JOE_PROGRESS(2);

        if (!fForce &&  // not being forced
            !FInodeIsFile(lpdbShadow, hDir, hShadow) &&     // and it is a dir
            HasDescendents(lpdbShadow, hDir, hShadow))      // and has descendents
        {
            JOE_PROGRESS(3);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow: Trying to delete a directory with descendents \r\n"));
            SetLastErrorLocal(ERROR_DIR_NOT_EMPTY);
            goto bailout;
        }

        JOE_PROGRESS(4);
        if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ)<=0)
        {
            JOE_PROGRESS(5);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow: Trying to delete a noexistent inode %x \r\n", hShadow));
            SetLastErrorLocal(ERROR_FILE_NOT_FOUND);
            goto bailout;
        }

        Assert(hShadow == sPQ.ulidShadow);

        DeleteFromHandleCache(hShadow);

        iRetInner = DeleteInodeFile(lpdbShadow, hShadow);

        if(iRetInner<0){
            if (GetLastErrorLocal() != ERROR_FILE_NOT_FOUND)
            {
                CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow: delete stent inode %x \r\n", hShadow));
                goto bailout;
            }
        }

        JOE_PROGRESS(6);
        if(DeleteFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) == 0L)
        {
            JOE_PROGRESS(7);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow:DeleteFileRecord failed \r\n"));
            goto bailout;
        }

        JOE_PROGRESS(8);
        Assert(hShadow == lpFRUse->sFR.ulidShadow);

        JOE_PROGRESS(11);
        // No error checking is done on the following call as they
        // are benign errors.
        iRetInner = DeletePriQRecord(lpdbShadow, hDir, hShadow, &sPQ);
        if(iRetInner>=0){
            JOE_PROGRESS(12);
            CShadowKdPrint(DELETESHADOWBAD,("DeleteShadow priq %d\n", iRetInner));
        }

        JOE_PROGRESS(13);
        memset((LPVOID)&sSD, 0, sizeof(STOREDATA));

        // Let us deal with only file records for now
        if (!mNotFsobj(lpFRUse->sFR.uStatus))
        {
            if(IsFile(lpFRUse->sFR.dwFileAttrib))
            {
                sSD.ucntFiles++;
                // subtract store data only if it was accounted for in the first place
                sSD.ulSize = (lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags))
                                ? 0 : RealFileSize(lpFRUse->sFR.ulFileSize);
            }
            else
            {
                sSD.ucntDirs++;
            }

            if (sSD.ulSize)
            {
                CShadowKdPrint(STOREDATA,("DeleteShadowInternal:Deleting storedata for hDir=%x Name=%ws\r\n", hDir, lpFRUse->sFR.rgwName));
            }

            SubtractStoreData(lpdbShadow, &sSD);
        }

        if (!FInodeIsFile(lpdbShadow, hDir, hShadow) && lpDeleteCBForIoctl)
        {
            (*lpDeleteCBForIoctl)(hDir, hShadow);
        }
        // we don't care if this fails because then the worst
        // that can happen is that this inode will be permanenetly lost.
        // Checkdisk utility should recover this.

        JOE_PROGRESS(14);
        FreeInode(lpdbShadow, hShadow);


        // Yes we did delete a shadow
        iRet = SRET_OK;
        
        vdwCSCNameSpaceVersion++;
        vdwPQVersion++;
    }

bailout:
    JOE_PROGRESS(20);
#if 0 //this insert has errors.........
#if VERBOSE > 2
    if (iRet==SRET_OK)
        CShadowKdPrint(DELETESHADOWHI,("DeleteShadow: deleted shadow %x for %s\r\n", lpFRUse->sFR.ulidShadow, lpName));
    else
        CShadowKdPrint(DELETESHADOWHI,("DeleteShadow: error deleting shadow for %s\r\n", lpName));
#endif //VERBOSE > 2
#endif //if 0 for errors
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();
    JOE_PROGRESS(21);
    return (iRet);
}


int TruncateDataHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uSize=0;
//    long nFileSizeHigh, nFileSizeLow;

    Assert(vfInShadowCrit != 0);
    Assert(!hDir || IsDirInode(hDir));

    if (FInodeIsFile(lpdbShadow, hDir, hShadow))
    {
//        GetInodeFileSize(lpdbShadow, hShadow, &uSize);
//        DosToWin32FileSize(uSize, &nFileSizeHigh, &nFileSizeLow);
        if (TruncateInodeFile(lpdbShadow, hShadow) < SRET_OK)
            return SRET_ERROR;

//        FreeShadowSpace(nFileSizeHigh, nFileSizeLow, IsLeaf(hShadow));
    }
    else
    {
        if (!HasDescendents(lpdbShadow, hDir, hShadow))
        {
            CreateDirInode(lpdbShadow, 0, hDir, hShadow);
        }
        else
        {
            SetLastErrorLocal(ERROR_ACCESS_DENIED);
            return SRET_ERROR;
        }
    }
    return(SRET_OK);
}


int PUBLIC
    RenameShadow(
    HSHADOW     hDirFrom,
    HSHADOW     hShadowFrom,
    HSHADOW     hDirTo,
    LPFIND32    lpFind32To,
    ULONG       uShadowStatusTo,
    LPOTHERINFO lpOI,
    ULONG       uRenameFlags,
    LPHSHADOW   lphShadowTo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (RenameShadowEx(hDirFrom, hShadowFrom, 0, hDirTo, lpFind32To, uShadowStatusTo, lpOI, uRenameFlags, NULL, NULL, lphShadowTo));
}

int PUBLIC
    RenameShadowEx(
    HSHADOW     hDirFrom,
    HSHADOW     hShadowFrom,
    HSHARE     hShareTo,
    HSHADOW     hDirTo,
    LPFIND32    lpFind32To,
    ULONG       uShadowStatusTo,
    LPOTHERINFO lpOI,
    ULONG       uRenameFlags,
    LPVOID      lpSecurityBlobTo,
    LPDWORD     lpdwBlobSizeTo,
    LPHSHADOW   lphShadowTo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    HSHADOW  hShadowTo;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    BOOL fFile = FInodeIsFile(lpdbShadow, hDirFrom, hShadowFrom);

    Assert(vfInShadowCrit != 0);

    Assert(!hDirFrom || IsDirInode(hDirFrom));
    Assert(!hDirTo || IsDirInode(hDirTo));

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    // If we are keeping the renamer, we are going to have to create
    // a new inode and an empty directory/file
    if (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED))
    {
        // Allocate an INODE for the new shadow
        if (!(hShadowTo = UlAllocInode(lpdbShadow, hDirFrom, IsLeaf(hShadowFrom))))
        {
            goto bailout;
        }

        Assert(IsLeaf(hShadowFrom) == IsLeaf(hShadowTo));


        if (!IsLeaf(hShadowTo))
        {
            if(CreateDirInode(lpdbShadow, 0, hDirFrom, hShadowTo) < 0)
                goto bailout;
        }
        else
        {
            if(CreateFileHSHADOW(hShadowTo) < 0)
            {
                goto bailout;
            }
        }
    }
    else
    {
        hShadowTo = 0;
    }



    iRet = RenameDirFileHSHADOW(hDirFrom, hShadowFrom, hShareTo, hDirTo, hShadowTo, uShadowStatusTo, lpOI, uRenameFlags, lpFRUse, lpFind32To, lpSecurityBlobTo, lpdwBlobSizeTo);

    if (lphShadowTo)
    {
        *lphShadowTo = (hShadowTo)?hShadowTo:hShadowFrom;
    }


bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();
    return (iRet);
}


int RenameDirFileHSHADOW(
    HSHADOW         hDirFrom,
    HSHADOW         hShadowFrom,
    HSHADOW         hShareTo,
    HSHADOW         hDirTo,
    HSHADOW         hShadowTo,
    ULONG           uShadowStatusTo,
    LPOTHERINFO     lpOI,
    ULONG           uRenameFlags,
    LPFILERECEXT    lpFRUse,
    LPFIND32        lpFind32To,
    LPVOID          lpSecurityBlobTo,
    LPDWORD         lpdwBlobSizeTo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    FILEHEADER sFH;
    PRIQREC sPQ;
    int count, iRet = SRET_ERROR;
    LPFILERECEXT lpFRDir = NULL;
    ULONG ulrecDirEntryTo, ulrecDirEntryFrom;
    BOOL fWasPinned=FALSE, fIsPinned=FALSE;

    Assert(lpFind32To);

    if(FindPriQRecord(lpdbShadow, hDirFrom, hShadowFrom, &sPQ)<=0)
    {
//        Assert(FALSE);
        goto bailout;
    }

    ulrecDirEntryFrom = sPQ.ulrecDirEntry;

    if(CShadowFindFilerecFromInode(lpdbShadow, hDirFrom, hShadowFrom, &sPQ, lpFRUse)<=0)
    {
//        Assert(FALSE);
        goto bailout;
    }

    Assert(sPQ.ulidShadow == lpFRUse->sFR.ulidShadow);

    fWasPinned = ((lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)) != 0);

    if (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED))
    {
        lpFRDir = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT));
        if (!lpFRDir)
        {
            Assert(FALSE);
            goto bailout;
        }
    }


    if (lpFRDir)
    {
        Assert (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED));
        // Save it's contents
        *lpFRDir = *lpFRUse;
    }

    // Change the name of hShadowFrom to the new name
    CopyNamesToFilerec(lpFind32To, lpFRUse);

    if (lpOI)
    {
        CopyOtherInfoToFilerec(lpOI, lpFRUse);
        CopyOtherInfoToPQ(lpOI, &sPQ);
    }

    fIsPinned = ((lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)) != 0);

    // And it's status as requested by the caller
    lpFRUse->sFR.uStatus = (USHORT)uShadowStatusTo;

    if (uRenameFlags & RNMFLGS_USE_FIND32_TIMESTAMPS)
    {
        lpFRUse->sFR.ftLastWriteTime = lpFind32To->ftLastWriteTime;
        lpFRUse->sFR.ftOrgTime = lpFind32To->ftLastAccessTime;
    }

    // Both SAVE and RETAIN should never be ON
    Assert(mQueryBits(uRenameFlags, (RNMFLGS_SAVE_ALIAS|RNMFLGS_RETAIN_ALIAS))
        !=(RNMFLGS_SAVE_ALIAS|RNMFLGS_RETAIN_ALIAS));

    if (mQueryBits(uRenameFlags, RNMFLGS_SAVE_ALIAS))
    {
        Assert(!mQueryBits(uRenameFlags, RNMFLGS_RETAIN_ALIAS));
        Assert(hShadowTo != 0);
        lpFRUse->sFR.ulidShadowOrg = hShadowTo;
    }
    else if (!mQueryBits(uRenameFlags, RNMFLGS_RETAIN_ALIAS))
    {
        lpFRUse->sFR.ulidShadowOrg = 0;
    }

    // update the security context
    CopyBufferToSecurityContext(lpSecurityBlobTo, lpdwBlobSizeTo, &(lpFRUse->sFR.Security));

    // Write the record. Now hDirFrom is the renamee
    if ((ulrecDirEntryTo = AddFileRecordFR(lpdbShadow, hDirTo, lpFRUse)) <=0)
    {
        // this could happen if there is no disk space
        goto bailout;
    }

    // if this going across shares, fix up the PQ entry with the right share
    if (hShareTo)
    {
        sPQ.ulidShare = hShareTo;
    }

    sPQ.ulidDir = hDirTo;
    sPQ.ulrecDirEntry = ulrecDirEntryTo;
    sPQ.uStatus = ((USHORT)uShadowStatusTo | (sPQ.uStatus & SHADOW_LOCAL_INODE));


    if (UpdatePriQRecord(lpdbShadow, hDirTo, hShadowFrom, &sPQ)< 0)
    {
        Assert(FALSE);
        goto bailout;
    }

    // by this time a hShadowFrom has been associated with the new name
    // and is also pointing back to hDirTo
    // We still have a filerec entry which associates hShadowFrom with
    // the old name and we need to take care of it

    if (mQueryBits(uRenameFlags, RNMFLGS_MARK_SOURCE_DELETED))
    {
        // we are running in disconnected mode
        // need to keep the old name
        Assert(hShadowTo != 0);
        lpFRDir->sFR.uStatus = SHADOW_DELETED;
        lpFRDir->sFR.ulidShadow = hShadowTo;

        // update filerecord without doing any compares
        if(UpdateFileRecFromInodeEx(lpdbShadow, hDirFrom, hShadowFrom, ulrecDirEntryFrom, lpFRDir, FALSE)<=0)
        {
            Assert(FALSE);
            goto bailout;
        }

        if(AddPriQRecord(lpdbShadow, sPQ.ulidShare, hDirFrom, hShadowTo, SHADOW_DELETED
            , (ULONG)(sPQ.uchRefPri), (ULONG)(sPQ.uchIHPri)
            , (ULONG)(sPQ.uchHintPri), (ULONG)(sPQ.uchHintFlags), ulrecDirEntryFrom)<=0)
        {
            Assert(FALSE);
            goto bailout;
        }
    }
    else
    {
        if(DeleteFileRecFromInode(lpdbShadow, hDirFrom, hShadowFrom, ulrecDirEntryFrom, lpFRUse) <= 0L)
        {
            Assert(FALSE);
            goto bailout;
        }
    }

    if (IsLeaf(hShadowFrom) && (fWasPinned != fIsPinned))
    {
        CShadowKdPrint(STOREDATA,("RenameDirFileHSHADOW: hDirFrom=%x hShadowFrom=%x hDirTo=%x To=%ws\r\n", hDirFrom, hShadowFrom, hDirTo, lpFind32To->cFileName));
        CShadowKdPrint(STOREDATA,("RenameDirFileHSHADOW: WasPinned=%d IsPinned=%d\r\n", fWasPinned, fIsPinned));
        AdjustShadowSpace( 0,
                            (fWasPinned)?0:RealFileSize(lpFRUse->sFR.ulFileSize), // if it was pinned it's old size was zero for space computation
                                                                    // else it was the actual size
                            0,
                            (fWasPinned)?RealFileSize(lpFRUse->sFR.ulFileSize):0, // if it was pinned it's new size should be zero for space computation
                                                                    // else it should be the actual size

                            TRUE);
    }

    iRet = SRET_OK;
    
    vdwCSCNameSpaceVersion++;
    
bailout:
    if (lpFRDir)
    {
        FreeMem(lpFRDir);
    }
    return (iRet);
}

int PUBLIC                              // ret
GetShadow(                              //
    HSHADOW  hDir,
    USHORT *lpName,
    LPHSHADOW lphShadow,
    LPFIND32 lpFind32,
    ULONG far *lpuShadowStatus,
    LPOTHERINFO lpOI
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (GetShadowEx(hDir, lpName, lphShadow, lpFind32, lpuShadowStatus, lpOI, NULL, NULL));
}


int PUBLIC                              // ret
GetShadowEx(                              //
    HSHADOW  hDir,
    USHORT *lpName,
    LPHSHADOW lphShadow,
    LPFIND32 lpFind32,
    ULONG far *lpuShadowStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;

    Assert(vfInShadowCrit != 0);

    if(!(!hDir || IsDirInode(hDir)))
    {
        return iRet;
    }

    BEGIN_TIMING(GetShadow);

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    *lphShadow = 0L;
    *lpuShadowStatus = 0;
    if (!hDir)
    {
        // We are looking for the root
        if(FindShareRecord(lpdbShadow, lpName, (LPSHAREREC)lpFRUse))
        {
            *lphShadow = ((LPSHAREREC)lpFRUse)->ulidShadow;

            *lpuShadowStatus = (ULONG)(((LPSHAREREC)lpFRUse)->uStatus);

            if (lpFind32)
            {
                CopySharerecToFindInfo(((LPSHAREREC)lpFRUse), lpFind32);
            }
            if (lpOI)
            {
                CopySharerecToOtherInfo((LPSHAREREC)lpFRUse, lpOI);
            }

            CopySecurityContextToBuffer(
                    &((LPSHAREREC)lpFRUse)->sShareSecurity,
                    lpSecurityBlob,
                    lpdwBlobSize);
        }
    }
    else
    {
        if (FindFileRecord(lpdbShadow, hDir, lpName, lpFRUse))
        {

            *lphShadow = lpFRUse->sFR.ulidShadow;
            if (lpFind32)
            {
                CopyFilerecToFindInfo(lpFRUse, lpFind32);
            }

            *lpuShadowStatus = lpFRUse->sFR.uStatus;

            CopySecurityContextToBuffer(&(lpFRUse->sFR.Security), lpSecurityBlob, lpdwBlobSize);

        }
        if (lpOI)
        {
            CopyFilerecToOtherInfo(lpFRUse, lpOI);
        }
    }
    iRet = SRET_OK;

    if (*lphShadow)
    {
        CShadowKdPrint(GETSHADOWHI,("GetShadow: %0lX is the shadow for %ws \r\n", *lphShadow, lpName));
        if (0) {  //keep this in case we need it again.........
            if ((lpName[0]==L'm') && (lpName[1]==L'f') && (lpName[2]==0)) {
            DbgPrint("Found mf!!!!\n");
            SET_HSHADOW_SPECIAL(*lphShadow);
            }
        }
    }
    else
    {
        CShadowKdPrint(GETSHADOWHI,("GetShadow: No shadow for %ws \r\n", lpName));
    }

bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();

    END_TIMING(GetShadow);

    return iRet;
}

int PUBLIC                              // ret
ChkStatusHSHADOW(                               //
    HSHADOW      hDir,
    HSHADOW      hShadow,
    LPFIND32     lpFind32,
    ULONG     far *lpuStatus
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;
    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, NULL, NULL, NULL, RSI_COMPARE);
    return(iRet);
}

int PUBLIC                              // ret
ChkUpdtStatusHSHADOW(                           //
    HSHADOW      hDir,
    HSHADOW      hShadow,
    LPFIND32     lpFind32,
    ULONG     far *lpuStatus
    )                                                       //
{
    int iRet;
    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, NULL, NULL, NULL, RSI_COMPARE|RSI_SET);
    return(iRet);
}

int PUBLIC GetShadowInfo
    (
    HSHADOW      hDir,
    HSHADOW      hShadow,
    LPFIND32     lpFind32,
    ULONG     far *lpuStatus,
    LPOTHERINFO lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    SHAREREC sSR;

    BEGIN_TIMING(GetShadowInfo);

    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, lpOI, NULL, NULL, RSI_GET);

    END_TIMING(GetShadowInfo);
    return(iRet);
}

int PUBLIC GetShadowInfoEx
    (
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       far *lpuStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    SHAREREC sSR;

    BEGIN_TIMING(GetShadowInfo);

    iRet = ReadShadowInfo(hDir, hShadow, lpFind32, lpuStatus, lpOI, lpSecurityBlob, lpdwBlobSize, RSI_GET);

    END_TIMING(GetShadowInfo);
    return(iRet);
}

int PUBLIC                              // ret
SetShadowInfo(                          //
    HSHADOW  hDir,
    HSHADOW  hShadow,
    LPFIND32 lpFind32,
    ULONG uFlags,
    ULONG uOp
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (SetShadowInfoEx(hDir, hShadow, lpFind32, uFlags, uOp, NULL, NULL, NULL));
}

int PUBLIC                              // ret
SetShadowInfoEx(                          //
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       uFlags,
    ULONG       uOp,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize
    )                                                       //
/*++

Routine Description:

    This routine is the central routine that modifies the database entry for a particular inode

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    PRIQREC sPQ;
    ULONG   uOldSize = 0, uNewSize=0, ulOldHintPri=0, ulOldHintFlags = 0, ulOldRefPri, ulOldFlags;
    BOOL fRefPriChange = FALSE;

    Assert(vfInShadowCrit != 0);
    if(!(!hDir || IsDirInode(hDir)))
    {
        return iRet;
    }


    BEGIN_TIMING(SetShadowInfoInternal);

    if (lpFind32)
    {
        if(!( (IsLeaf(hShadow) && IsFile(lpFind32->dwFileAttributes)) ||
                (!IsLeaf(hShadow) && !IsFile(lpFind32->dwFileAttributes))))
        {
            return SRET_ERROR;
        }
    }

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
            lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    if (!hDir)
    {
        // We are looking for the root
        if(FindSharerecFromInode(lpdbShadow, hShadow, (LPSHAREREC)lpFRUse))
        {
            if (lpFind32)
            {
                CopyFindInfoToSharerec(lpFind32, (LPSHAREREC)lpFRUse);
            }

            if (lpOI)
            {
                CopyOtherInfoToSharerec(lpOI, (LPSHAREREC)lpFRUse);
            }

            CopyBufferToSecurityContext(    lpSecurityBlob,
                                            lpdwBlobSize,
                                            &(((LPSHAREREC)lpFRUse)->sRootSecurity));

            if (mAndShadowFlags(uOp))
            {
                ((LPSHAREREC)lpFRUse)->usRootStatus &= (USHORT)uFlags;
            }
            else if (mOrShadowFlags(uOp))
            {
                ((LPSHAREREC)lpFRUse)->usRootStatus |= (USHORT)uFlags;
            }
            else
            {
                ((LPSHAREREC)lpFRUse)->usRootStatus = (USHORT)uFlags;
            }

            iRet = SetShareRecord(lpdbShadow, ((LPSHAREREC)lpFRUse)->ulShare, (LPSHAREREC)lpFRUse);
        }
    }
    else
    {
        IF_HSHADOW_SPECIAL(hShadow) {
        //ASSERT(!"SpecialShadow in setshadinfo");
        }

        if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
        {
            goto bailout;
        }

        Assert((sPQ.ulidDir == hDir) && (sPQ.ulidShadow == hShadow));

        if (CShadowFindFilerecFromInode(lpdbShadow, hDir, hShadow, &sPQ, lpFRUse)> 0)
        {
            Assert(lpFRUse->sFR.ulidShadow == hShadow);
            uOldSize = uNewSize = lpFRUse->sFR.ulFileSize;
            ulOldFlags = lpFRUse->sFR.usStatus;



            if (lpFind32)
            {
                uNewSize = (ULONG)(lpFind32->nFileSizeLow);

                CopyFindInfoToFilerec(lpFind32, lpFRUse, (mChange83Name(uOp))?CPFR_COPYNAME:0);

                if (!mDontUpdateOrgTime(uOp))
                {
                    lpFRUse->sFR.ftOrgTime = lpFRUse->sFR.ftLastWriteTime;
                }
            }

            if (mAndShadowFlags(uOp))
            {
                lpFRUse->sFR.uStatus &= (USHORT)uFlags;
            }
            else if (mOrShadowFlags(uOp))
            {
                lpFRUse->sFR.uStatus |= (USHORT)uFlags;
            }
            else
            {
                lpFRUse->sFR.uStatus = (USHORT)uFlags;
            }

            if (mShadowNeedReint(ulOldFlags) && !mShadowNeedReint(lpFRUse->sFR.usStatus))
            {
                if(DeleteStream(lpdbShadow, hShadow, CscBmpAltStrmName) < SRET_OK)
                {
                    DbgPrint("DeleteStream failed with %x /n", GetLastErrorLocal());
                    goto bailout;
                }
            }

            if (lpOI)
            {
                // save some key old info before copying the new info

                ulOldHintPri = lpFRUse->sFR.uchHintPri;
                ulOldHintFlags = lpFRUse->sFR.uchHintFlags;
                ulOldRefPri = lpFRUse->sFR.uchRefPri;

                CopyOtherInfoToFilerec(lpOI, lpFRUse);

                CopyOtherInfoToPQ(lpOI, &sPQ);

                if (IsFile(lpFRUse->sFR.dwFileAttrib))
                {
                    if ((!ulOldHintPri && !mPinFlags(ulOldHintFlags)) &&    // was unpinned
                        (lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags)))  //is getting pinned
                    {
                        // If it went from unpinned to pinned
                        // make the new size 0
                        uNewSize = 0;
                    }
                    else if ((ulOldHintPri || mPinFlags(ulOldHintFlags)) && // was pinned
                        (!lpFRUse->sFR.uchHintPri && !mPinFlags(lpFRUse->sFR.uchHintFlags))) //is getting unpinned
                    {
                        // If it went from pinned to unpinned
                        // we must add the new size

                        uOldSize = 0;
                    }

                }

                if(mForceRelink(uOp) || ((ulOldRefPri != (ULONG)(sPQ.uchRefPri))
                    )
                  )
                {
                    fRefPriChange = TRUE;

                }

            }
            else
            {
                // if this is a pinned entry, we need to not have any space adjustment
                if(lpFRUse->sFR.uchHintPri || mPinFlags(lpFRUse->sFR.uchHintFlags))
                {
                    uOldSize = uNewSize;
                }
            }

            if (IsFile(lpFRUse->sFR.dwFileAttrib))
            {
                Assert(lpFRUse->sFR.uchRefPri == MAX_PRI);
            }
            else
            {
                Assert(sPQ.uchRefPri == MIN_PRI);
                Assert(lpFRUse->sFR.uchRefPri == MIN_PRI);
            }

            CShadowKdPrint(SETSHADOWINFOHI,("SetShadowInfo: %x %x: loctLo=%x loctHi=%x \r\n",
                 hDir,hShadow,
                 lpFRUse->sFR.ftOrgTime.dwLowDateTime,
                 lpFRUse->sFR.ftOrgTime.dwHighDateTime));

            CopyBufferToSecurityContext(lpSecurityBlob, lpdwBlobSize, &(lpFRUse->sFR.Security));

#ifdef DEBUG
            ValidatePri(lpFRUse);
#endif

            if ((ulOldFlags & SHADOW_SPARSE) && !(lpFRUse->sFR.usStatus & SHADOW_SPARSE))
            {
                CShadowKdPrint(SETSHADOWINFOHI,("SetShadowInfo: File Unsparsed\n"));
            }

            if (mSetLastRefreshTime(uOp) || ((ulOldFlags & SHADOW_STALE) && !(lpFRUse->sFR.usStatus & SHADOW_STALE)))
            {
                lpFRUse->sFR.ulLastRefreshTime = (ULONG)IFSMgr_Get_NetTime();
            }

            if (UpdateFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) < SRET_OK)
            {
                Assert(FALSE);
                goto bailout;
            }

            if (mShadowNeedReint(ulOldFlags) && !mShadowNeedReint(lpFRUse->sFR.usStatus))
            {
                sPQ.usStatus = lpFRUse->sFR.uStatus;
 //               Assert(!(sPQ.usStatus & SHADOW_LOCAL_INODE));
                lpFRUse->sFR.ulidShadowOrg = lpFRUse->sFR.ulidShadow;
            }
            else
            {
                sPQ.usStatus = ((USHORT)(lpFRUse->sFR.uStatus) | (sPQ.usStatus & SHADOW_LOCAL_INODE));
            }

            if (fRefPriChange)
            {
                // update the record with and relinking it in the queue
                if (UpdatePriQRecordAndRelink(lpdbShadow, hDir, hShadow, &sPQ) < SRET_OK)
                {
                    Assert(FALSE);
                    goto bailout;
                }
            }
            else
            {
                // update the record without relinking
                if (UpdatePriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < SRET_OK)
                {
                    Assert(FALSE);
                    goto bailout;
                }
            }

            // we do space accounting only for files
            // If the file went from pinned to upinned and viceversa

            if (IsFile(lpFRUse->sFR.dwFileAttrib) && (uOldSize != uNewSize))
            {

                CShadowKdPrint(STOREDATA,("SetShadowInfo: Size changed for hDir=%x Name=%ws\r\n", hDir, lpFRUse->sFR.rgwName));
                AdjustShadowSpace(0, uOldSize, 0, uNewSize, TRUE);
            }

            AdjustSparseStaleDetectionCount(0, lpFRUse);

            iRet = SRET_OK;

        }
    }
bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();

    END_TIMING(SetShadowInfoInternal);

    return iRet;
}

int PRIVATE ReadShadowInfo(
    HSHADOW     hDir,
    HSHADOW     hShadow,
    LPFIND32    lpFind32,
    ULONG       far *lpuStatus,
    LPOTHERINFO lpOI,
    LPVOID      lpSecurityBlob,
    LPDWORD     lpdwBlobSize,
    ULONG       uFlags
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    BOOL fStale = FALSE;
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    PRIQREC sPQ;

    Assert(vfInShadowCrit != 0);
    if(!(!hDir || IsDirInode(hDir)))
    {
        return iRet;
    }


    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    Assert((uFlags & (RSI_GET|RSI_SET)) != (RSI_GET|RSI_SET));

    if (!hDir)
    {
        if(FindSharerecFromInode(lpdbShadow, hShadow, (LPSHAREREC)lpFRUse))
        {
            if (lpuStatus != NULL) {
                *lpuStatus = (ULONG)(((LPSHAREREC)lpFRUse)->usRootStatus);
            }

            if (lpFind32)
            {
                CopySharerecToFindInfo((LPSHAREREC)lpFRUse, lpFind32);
            }

            if (lpOI)
            {
                CopySharerecToOtherInfo((LPSHAREREC)lpFRUse, lpOI);
            }

            CopySecurityContextToBuffer(
                &(((LPSHAREREC)lpFRUse)->sShareSecurity),
                lpSecurityBlob,
                lpdwBlobSize);

            iRet = SRET_OK;
        }

        goto bailout;
    }

    Assert(hDir);


    if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
        goto bailout;

    if(!CShadowFindFilerecFromInode(lpdbShadow, hDir, hShadow, &sPQ, lpFRUse))
    {
        CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! no filerec for pq entry Inode=%x, deleting PQ entry\r\n",
                        hShadow));
        goto bailout;
    }


    CopySecurityContextToBuffer(&(lpFRUse->sFR.Security), lpSecurityBlob, lpdwBlobSize);


    if (lpFind32)
    {
        if (uFlags & RSI_COMPARE)
        {
            // ACHTUNG!! we compare last write times. It is possible that
            // somebody might have changed the filetime on the server to
            // be something earlier than what we had when we shadowed the file
            // for the first time. We detect this case here and say that the file
            // is stale
#ifdef  CSC_RECORDMANAGER_WINNT
            fStale = ((CompareTimes(lpFind32->ftLastWriteTime, lpFRUse->sFR.ftOrgTime) != 0)||
                      (lpFind32->nFileSizeLow !=lpFRUse->sFR.ulFileSize));
#else
            fStale = (CompareTimesAtDosTimePrecision(lpFind32->ftLastWriteTime, lpFRUse->sFR.ftOrgTime) != 0);
#endif

            // If remote time > local time, copy the file
            if ((!fStale && (lpFRUse->sFR.uStatus & SHADOW_STALE))||
                (fStale && !(lpFRUse->sFR.uStatus & SHADOW_STALE)))
            {

                CShadowKdPrint(READSHADOWINFOHI,("ReadShadowInfo: %x: remtLo=%x remtHi=%x, \r\n locTLo=%x, locTHi=%x \r\n"
                ,hShadow, lpFind32->ftLastWriteTime.dwLowDateTime, lpFind32->ftLastWriteTime.dwHighDateTime
                , lpFRUse->sFR.ftOrgTime.dwLowDateTime, lpFRUse->sFR.ftOrgTime.dwHighDateTime));

                // Toggle the staleness bit
                lpFRUse->sFR.uStatus ^= SHADOW_STALE;
                sPQ.usStatus = (USHORT)(lpFRUse->sFR.uStatus) | (sPQ.usStatus & SHADOW_LOCAL_INODE);

                if (uFlags & RSI_SET)
                {
                    if (UpdateFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) < SRET_OK)
                    {
                        Assert(FALSE);
                        goto bailout;
                    }

                    if (UpdatePriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < SRET_OK)
                    {
                        // Toggle the staleness bit
                        lpFRUse->sFR.uStatus ^= SHADOW_STALE;

                        //try to undo the change
                        if (UpdateFileRecFromInode(lpdbShadow, hDir, hShadow, sPQ.ulrecDirEntry, lpFRUse) < SRET_OK)
                        {
                            Assert(FALSE);
                        }
                        goto bailout;
                    }

                    AdjustSparseStaleDetectionCount(0, lpFRUse);
                }
                iRet = 1;
            }
            else
            {
                iRet = 0;
            }
        }
        else
        {
            iRet = 0;
        }

        if (uFlags & RSI_GET)
        {
            CopyFilerecToFindInfo(lpFRUse, lpFind32);

            Assert((IsLeaf(hShadow) && IsFile(lpFind32->dwFileAttributes)) ||
                (!IsLeaf(hShadow) && !IsFile(lpFind32->dwFileAttributes)));
        }

    }
    else
    {
        iRet = 0;

    }

    if (lpOI)
    {
        CopyFilerecToOtherInfo(lpFRUse, lpOI);
    }

    if (lpuStatus != NULL) {
        *lpuStatus = lpFRUse->sFR.uStatus;
    }

bailout:
    if (lpFR)
    {
        FreeMem(lpFR);
    }
    else
    {
        UnUseGlobalFilerecExt();
    }
    return iRet;
}


HSHARE PUBLIC                  // ret
HCreateShareObj(                       //
    USHORT          *lpShare,
    LPSHADOWINFO    lpSI
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG ulidShare=0;
    HSHADOW hRoot=0;
    SHAREREC sSR;


    Assert(vfInShadowCrit != 0);

    memset(lpSI, 0, sizeof(SHADOWINFO));

    if(!InitShareRec(&sSR, lpShare,0))
    {
        return 0;
    }

    if (!(ulidShare = AllocShareRecord(lpdbShadow, lpShare)))
        return 0;

    if(!(hRoot = UlAllocInode(lpdbShadow, 0L, FALSE)))
        return 0;

    // Let us create an empty root
    if(CreateDirInode(lpdbShadow, ulidShare, 0L, hRoot) < 0L)
    {
        CShadowKdPrint(BADERRORS,("Error in creating root \r\n"));
        return 0L;
    }

    if (AddPriQRecord(lpdbShadow, ulidShare, 0, hRoot, SHADOW_SPARSE, 0, 0, 0, 0, ulidShare) < 0)
    {
        CShadowKdPrint(BADERRORS,("Error in inserting root in the priorityQ\r\n"));
        return 0L;
    }

    sSR.ulShare =      ulidShare;
    sSR.ulidShadow =    hRoot;
    sSR.uStatus =       0;
    sSR.usRootStatus =  SHADOW_SPARSE;
    sSR.dwFileAttrib =  FILE_ATTRIBUTE_DIRECTORY;

    if (sSR.ftLastWriteTime.dwLowDateTime == 0 && sSR.ftLastWriteTime.dwHighDateTime == 0) {
        KeQuerySystemTime(((PLARGE_INTEGER)(&sSR.ftLastWriteTime)));
        if (sSR.ftOrgTime.dwLowDateTime == 0 && sSR.ftOrgTime.dwHighDateTime == 0)
            sSR.ftOrgTime = sSR.ftLastWriteTime;
    }

    // there needs to be a way for passing in ftLastWriteTime, which we would
    // stamp as the ftOrgTime. We don't use the ORG time right now, but we might want to
    // in future

    // All entities have been individually created. Let us tie them up
    // in the database
    ulidShare = AddShareRecord(lpdbShadow, &sSR);

    if (ulidShare)
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
        vdwCSCNameSpaceVersion++;
        vdwPQVersion++;
    }

    return ((HSHARE)ulidShare);
}


int PUBLIC                                      // ret
DestroyHSHARE(                 //
    HSHARE hShare
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
    {
    SHAREREC sSR;
    int iRet = SRET_ERROR;

    Assert(vfInShadowCrit != 0);

    if(FindSharerecFromShare(lpdbShadow, hShare, &sSR))
    {
    if (DestroyShareInternal(&sSR) >= 0)
        iRet = SRET_OK;
    }
    return (iRet);
    }

int DestroyShareInternal( LPSHAREREC lpSR
    )
{
    PRIQREC sPQ;
    int iRet = -1;

    if (!mNotFsobj(lpSR->uStatus))
    {
        if(DeletePriQRecord(lpdbShadow, 0, lpSR->ulidShadow, &sPQ) >= 0)
        {
            if (DeleteShareRecord(lpdbShadow, lpSR->ulShare))
            {
                FreeInode(lpdbShadow, lpSR->ulidShadow);
                DeleteInodeFile(lpdbShadow, lpSR->ulidShadow);
                iRet = 1;
                vdwCSCNameSpaceVersion++;
                vdwPQVersion++;
            }
            else
            {
                CShadowKdPrint(BADERRORS, ("Failed to delete record for share=%x\r\n", lpSR->ulShare));
            }
        }
    }
    return (iRet);
}


int PUBLIC                      // ret
GetShareFromPath(              //
    USHORT                      *lpShare,
    LPSHADOWINFO    lpSI
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    Assert(vfInShadowCrit != 0);

    memset(lpSI, 0, sizeof(SHADOWINFO));

    if(FindShareRecord(lpdbShadow, lpShare, &sSR))
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
    }

    return SRET_OK;
}

int PUBLIC                      // ret
GetShareFromPathEx(              //
    USHORT          *lpShare,
    LPSHADOWINFO    lpSI,
    LPVOID          lpSecurityBlob,
    LPDWORD         lpdwBlobSize
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    memset(lpSI, 0, sizeof(SHADOWINFO));

    Assert(vfInShadowCrit != 0);

    if(FindShareRecord(lpdbShadow, lpShare, &sSR))
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
        CopySecurityContextToBuffer(&(sSR.sShareSecurity), lpSecurityBlob, lpdwBlobSize);
    }

    return SRET_OK;
}

int PUBLIC                                      // ret
GetShareInfo(          //
    HSHARE         hShare,
    LPSHAREINFOW   lpShareInfo,
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (GetShareInfoEx(hShare, lpShareInfo, lpSI, NULL, NULL));
}

int PUBLIC
GetShareInfoEx(
    HSHARE         hShare,
    LPSHAREINFOW   lpShareInfo,
    LPSHADOWINFO    lpSI,
    LPVOID          lpSecurityBlob,
    LPDWORD         lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    Assert(vfInShadowCrit != 0);

    if (!hShare)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return SRET_ERROR;
    }

    if (GetShareRecord(lpdbShadow, hShare, &sSR) < SRET_OK)
    {
        return SRET_ERROR;
    }

    if (lpShareInfo)
    {
        lpShareInfo->hShare = hShare;

        memset(lpShareInfo->rgSharePath, 0, sizeof(lpShareInfo->rgSharePath));
        memcpy(lpShareInfo->rgSharePath, sSR.rgPath, wstrlen(sSR.rgPath)*sizeof(USHORT));

        memcpy(lpShareInfo->rgFileSystem, vwszFileSystemName, wstrlen(vwszFileSystemName)*sizeof(USHORT));

        lpShareInfo->usCaps = FS_CASE_IS_PRESERVED|FS_VOL_SUPPORTS_LONG_NAMES;
        lpShareInfo->usState = RESSTAT_OK;
    }
    if (lpSI)
    {
        CopySharerecToShadowInfo(&sSR, lpSI);
    }

    CopySecurityContextToBuffer(&(sSR.sShareSecurity), lpSecurityBlob, lpdwBlobSize);

    return (SRET_OK);
}


int
SetShareStatus( HSHARE  hShare,
    ULONG uStatus,
    ULONG uOp
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (SetShareStatusEx(hShare, uStatus, uOp, NULL, NULL));
}

int
SetShareStatusEx(
    HSHARE         hShare,
    ULONG           uStatus,
    ULONG           uOp,
    LPVOID          lpSecurityBlob,
    LPDWORD         lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    SHAREREC sSR;

    Assert(vfInShadowCrit != 0);

    if (!hShare)
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        return SRET_ERROR;
    }

    if (GetShareRecord(lpdbShadow, hShare, &sSR) < SRET_OK)
    {
        return SRET_ERROR;
    }

    if (mAndShadowFlags(uOp))
    {
        sSR.uStatus &= (USHORT)uStatus;
    }
    else if (mOrShadowFlags(uOp))
    {
        sSR.uStatus |= (USHORT)uStatus;
    }
    else
    {
        sSR.uStatus = (USHORT)uStatus;
    }

    CopyBufferToSecurityContext(lpSecurityBlob, lpdwBlobSize, &(sSR.sShareSecurity));


    return (SetShareRecord(lpdbShadow, hShare, &sSR));
}


int PUBLIC                      // ret
GetAncestorsHSHADOW(                    //
    HSHADOW hName,
    LPHSHADOW    lphDir,
    LPHSHARE    lphShare
    )                                                       //
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (FindAncestorsFromInode(lpdbShadow, hName, lphDir, lphShare));
}

int PUBLIC SetPriorityHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG ulRefPri,
    ULONG ulIHPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    OTHERINFO sOI;
    ULONG uOp = SHADOW_FLAGS_OR;

    Assert(vfInShadowCrit != 0);


    ulIHPri;
    InitOtherInfo(&sOI);

    // we make sure that if the new priority being set is MAX_PRI, then this
    // inode does get to the top of the PQ even if it's current priority is
    // MAX_PRI.

    if (ulRefPri == MAX_PRI)
    {
        uOp |= SHADOW_FLAGS_FORCE_RELINK;
    }
    sOI.ulRefPri = ulRefPri;
    sOI.ulIHPri = 0;

    if(SetShadowInfoEx(hDir, hShadow, NULL, 0, uOp, &sOI, NULL, NULL))
        return (SRET_ERROR);

    return (SRET_OK);
}

int PUBLIC  GetPriorityHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG *lpulRefPri,
    ULONG *lpulIHPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;

    Assert(vfInShadowCrit != 0);

    if((FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)||mNotFsobj(sPQ.usStatus))
        return SRET_ERROR;

    if (lpulRefPri)
    {
        *lpulRefPri = (ULONG)(sPQ.uchRefPri);
    }
    if (lpulIHPri)
    {
        *lpulIHPri = (ULONG)(sPQ.uchIHPri);
    }
    return (SRET_OK);
}

int PUBLIC
ChangePriEntryStatusHSHADOW(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    ULONG   uStatus,
    ULONG   uOp,
    BOOL    fChangeRefPri,
    LPOTHERINFO lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    PRIQREC sPQ;
    int iRet;
#ifdef DEBUG
    ULONG   ulRefPri;
#endif
    Assert(vfInShadowCrit != 0);
    Assert(!hDir || IsDirInode(hDir));

    BEGIN_TIMING(ChangePriEntryStatusHSHADOW);

    if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
        return SRET_ERROR;
#ifdef DEBUG
    ulRefPri = (ULONG)(sPQ.uchRefPri);
#endif

    if (uOp==SHADOW_FLAGS_AND)
    {
        sPQ.usStatus &= (USHORT)uStatus;
    }
    else if (uOp==SHADOW_FLAGS_OR)
    {
        sPQ.usStatus |= (USHORT)uStatus;
    }
    else
    {
        sPQ.usStatus = (USHORT)uStatus;
    }
    if (lpOI)
    {
        CopyOtherInfoToPQ(lpOI, &sPQ);
    }

    if (!fChangeRefPri)
    {
        Assert(ulRefPri == (ULONG)(sPQ.uchRefPri));
        iRet = UpdatePriQRecord(lpdbShadow, hDir, hShadow, &sPQ);
    }
    else
    {
        iRet = UpdatePriQRecordAndRelink(lpdbShadow, hDir, hShadow, &sPQ);
        vdwPQVersion++;

    }

    END_TIMING(ChangePriEntryStatusHSHADOW);

    return (iRet);

}

CSC_ENUMCOOKIE PUBLIC                    // ret
HBeginPQEnum(   //
    VOID)                                           // no params
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    Assert(vfInShadowCrit != 0);

    return ((CSC_ENUMCOOKIE)BeginSeqReadPQ(lpdbShadow));
}

int PUBLIC EndPQEnum(
    CSC_ENUMCOOKIE  hPQEnum
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    Assert(vfInShadowCrit != 0);

    return(EndSeqReadQ((CSCHFILE)hPQEnum));
}

int PUBLIC                      // ret
PrevPriSHADOW(
    LPPQPARAMS  lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QREC sQrec;
    int iRet=-1;

    Assert(vfInShadowCrit != 0);

    sQrec.uchType = 0;
    if (lpPQ->uPos)
    {
        sQrec.ulrecPrev = lpPQ->uPos;
        iRet = SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETPREV);
    }
    else
    {
        iRet=SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETLAST);
    }

    if (iRet>=0)
    {

        // it is possible, that as the agent is traversing the PQ,
        // the next inode he is trying to read may have already been
        // deleted. In such a case, just fail, so he will start all
        // over in due course

        if(sQrec.uchType == REC_DATA)
        {
            lpPQ->hShare = sQrec.ulidShare;
            lpPQ->hDir = sQrec.ulidDir;
            lpPQ->hShadow = sQrec.ulidShadow;
            lpPQ->ulStatus = sQrec.usStatus;
            if (FInodeIsFile(lpdbShadow, sQrec.ulidDir, sQrec.ulidShadow))
            {
                lpPQ->ulStatus |= SHADOW_IS_FILE;
            }
            lpPQ->ulRefPri = (ULONG)(sQrec.uchRefPri);
            lpPQ->ulHintPri = (ULONG)(sQrec.uchHintPri);
            lpPQ->ulHintFlags = (ULONG)(sQrec.uchHintFlags);
            lpPQ->uPos = sQrec.ulrecPrev;
            lpPQ->dwPQVersion = vdwPQVersion;
        }
        else
        {
            lpPQ->hShadow = 0;
            iRet = -1;
        }
    }
    return (iRet);
}


int PUBLIC                      // ret
NextPriSHADOW(
    LPPQPARAMS  lpPQ
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    QREC sQrec;
    int iRet=-1;

    Assert(vfInShadowCrit != 0);

    sQrec.uchType = 0;
    if (lpPQ->uPos)
    {
        sQrec.ulrecNext = lpPQ->uPos;
        iRet = SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETNEXT);
    }
    else
    {
        iRet = SeqReadQ(lpPQ->uEnumCookie, &sQrec, &sQrec, Q_GETFIRST);
    }

    if (iRet >=0)
    {
        // it is possible, that as the agent is traversing the PQ,
        // the next inode he is trying to read may have already been
        // deleted. In such a case, just fail, so he will start all
        // over in due course

        if(sQrec.uchType == REC_DATA)
        {
            lpPQ->hShare = sQrec.ulidShare;
            lpPQ->hDir = sQrec.ulidDir;
            lpPQ->hShadow = sQrec.ulidShadow;
            lpPQ->ulStatus = (sQrec.usStatus);
            if (FInodeIsFile(lpdbShadow, sQrec.ulidDir, sQrec.ulidShadow))
            {
                lpPQ->ulStatus |= SHADOW_IS_FILE;
            }
            lpPQ->ulRefPri = (ULONG)(sQrec.uchRefPri);
            lpPQ->ulHintPri = (ULONG)(sQrec.uchHintPri);
            lpPQ->ulHintFlags = (ULONG)(sQrec.uchHintFlags);
            lpPQ->uPos = sQrec.ulrecNext;
            lpPQ->dwPQVersion = vdwPQVersion;
        }
        else
        {
            lpPQ->hShadow = 0;
            iRet = -1;
        }
    }
    return (iRet);
}



int GetRenameAliasHSHADOW( HSHADOW      hShadow,
    HSHADOW      hDir,
    LPHSHADOW    lphDirFrom,
    LPHSHADOW    lphShadowFrom
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    PRIQREC sPQ;

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    *lphShadowFrom = *lphDirFrom = 0;

    if(FindPriQRecord(lpdbShadow, hDir, hShadow, &sPQ) < 0)
    {
        goto bailout;
    }

    if(!CShadowFindFilerecFromInode(lpdbShadow, hDir, hShadow, &sPQ, lpFRUse))
        goto bailout;

    Assert(lpFRUse->sFR.ulidShadow == sPQ.ulidShadow);

    *lphShadowFrom = lpFRUse->sFR.ulidShadowOrg;
    if (*lphShadowFrom)
    {
        FindAncestorsFromInode(lpdbShadow, *lphShadowFrom, lphDirFrom, NULL);
    }
    iRet = SRET_OK;

bailout:
    if (lpFR)
        FreeMem(lpFR);
    else
        UnUseGlobalFilerecExt();
    return iRet;
}

int
CopyHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    LPSTR   lpszDestinationFile,
    ULONG   ulAttrib
)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return (CopyFileLocal(lpdbShadow, hShadow, lpszDestinationFile, ulAttrib));
}


int RenameDataHSHADOW(
    ULONG ulidFrom,
    ULONG ulidTo
    )
{
    return (RenameInode(lpdbShadow, ulidFrom, ulidTo));
}

int MetaMatchInit(
    ULONG *lpuCookie
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    *lpuCookie = 1;
    return(0);
}

int MetaMatch(
    HSHADOW         hDir,
    LPFIND32        lpFind32,
    ULONG           *lpuCookie,
    LPHSHADOW       lphShadow,
    ULONG           *lpuStatus,
    LPOTHERINFO     lpOI,
    METAMATCHPROC   lpfnMMP,
    LPVOID          lpData
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet;

    Assert(vfInShadowCrit != 0);

    if (hDir)
    iRet = MetaMatchDir(hDir, lpFind32, lpuCookie, lphShadow, lpuStatus, lpOI, lpfnMMP, lpData);
    else
    iRet = MetaMatchShare(hDir, lpFind32, lpuCookie, lphShadow, lpuStatus, lpOI, lpfnMMP, lpData);

    return (iRet);
}

int MetaMatchShare(
    HSHADOW         hDir,
    LPFIND32        lpFind32,
    ULONG           *lpuCookie,
    LPHSHADOW       lphShadow,
    ULONG           *lpuStatus,
    LPOTHERINFO     lpOI,
    METAMATCHPROC   lpfnMMP,
    LPVOID          lpData
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = -1, iFound=-1;
    GENERICHEADER  sGH;
    CSCHFILE hf = NULL;
    ULONG uSize, ulrecPosFound = 0;
    OTHERINFO sOI;
    SHAREREC sSR;
    BOOL    fCached;

    if (!(hf = OpenInodeFileAndCacheHandle(lpdbShadow, ULID_SHARE, ACCESS_READWRITE, &fCached)))
    {
        goto bailout;
    }

    if(ReadHeader(hf, &sGH, sizeof(FILEHEADER)) < 0)
    {
        goto bailout;
    }

    for (;*lpuCookie <=sGH.ulRecords;)
    {
        iRet = ReadRecord(hf, &sGH, *lpuCookie, (LPGENERICREC)&sSR);
        if (iRet < 0)
            goto bailout;

        // bump the record pointer
        *lpuCookie += iRet;

        if (sSR.uchType != REC_DATA)
            continue;

        CopySharerecToFindInfo(&sSR, lpFind32);
        CopySharerecToOtherInfo(&sSR, &sOI);
        if (lpOI)
        {
            *lpOI = sOI;
        }

        *lpuStatus = (ULONG)(sSR.usStatus);

        *lphShadow = sSR.ulidShadow;

        iFound = (*lpfnMMP)(lpFind32, hDir, *lphShadow, *lpuStatus, &sOI, lpData);
        if (iFound==MM_RET_FOUND_CONTINUE)
        {
            ulrecPosFound = *lpuCookie - iRet;
        }
        else if (iFound <= MM_RET_FOUND_BREAK)
        {
            break;
        }
    }

    if (ulrecPosFound || (iFound==MM_RET_FOUND_BREAK))
    {
        if (ulrecPosFound)
        {
            ReadRecord(hf, &sGH, ulrecPosFound,  (LPGENERICREC)&sSR);

            CopySharerecToFindInfo(&sSR, lpFind32);

            *lpuStatus =  (ULONG)(sSR.usStatus);
            *lphShadow = sSR.ulidShadow;
            if (lpOI)
            {
                CopySharerecToOtherInfo(&sSR, lpOI);
            }
        }
    }
    else
    {
        *lpuStatus = *lphShadow = 0;
    }

    iRet = SRET_OK;

bailout:

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);

}

int MetaMatchDir(
    HSHADOW  hDir,
    LPFIND32        lpFind32,
    ULONG           *lpuCookie,
    LPHSHADOW       lphShadow,
    ULONG           *lpuStatus,
    LPOTHERINFO     lpOI,
    METAMATCHPROC   lpfnMMP,
    LPVOID          lpData
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR, iFound=-1;
    GENERICHEADER  sGH;
    CSCHFILE hf = NULL;
    ULONG uSize, ulrecPosFound = 0;
    OTHERINFO sOI;
    LPFILERECEXT lpFR = NULL, lpFRUse;
    BOOL    fCached;
    PRIQREC sPQ;

    if (InuseGlobalFRExt())
    {
        if (!(lpFR = (LPFILERECEXT)AllocMem(sizeof(FILERECEXT))))
            goto bailout;
        lpFRUse = lpFR;
    }
    else
    {
        UseGlobalFilerecExt();
        lpFRUse = &vsFRExt;
    }

    if (FInodeIsFile(lpdbShadow, 0, hDir))
    {
        SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        goto bailout;
    }


    if (!(hf = OpenInodeFileAndCacheHandle(lpdbShadow, hDir, ACCESS_READWRITE, &fCached)))
    {
        DWORD   dwError;
        dwError = GetLastErrorLocal();

        if(FindPriQRecordInternal(lpdbShadow, hDir, &sPQ) < 0)
        {
            SetLastErrorLocal(ERROR_INVALID_PARAMETER);
        }
        else
        {
            SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_MISSING_INODE);
            SetLastErrorLocal(dwError);
        }

        goto bailout;
    }

    if(ReadHeader(hf, &sGH, sizeof(FILEHEADER)) < 0)
    {
        goto bailout;
    }

    for (;*lpuCookie <=sGH.ulRecords;)
    {
        iRet = ReadRecord(hf, &sGH, *lpuCookie,  (LPGENERICREC)lpFRUse);
        if (iRet < 0)
        {
            goto bailout;
        }

        // bump the record pointer
        *lpuCookie += iRet;

        if (lpFRUse->sFR.uchType != REC_DATA)
        {
            continue;
        }

        CopyFilerecToFindInfo(lpFRUse, lpFind32);

        *lphShadow = lpFRUse->sFR.ulidShadow;

        CopyFilerecToOtherInfo(lpFRUse, &sOI);
        if (lpOI)
        {
            *lpOI = sOI;
        }
        *lpuStatus = (ULONG)(lpFRUse->sFR.uStatus);
        iFound = (*lpfnMMP)(lpFind32, hDir, *lphShadow, *lpuStatus, &sOI, lpData);
        if (iFound==MM_RET_FOUND_CONTINUE)
        {
            ulrecPosFound = *lpuCookie - iRet;
        }
        else if (iFound <= MM_RET_FOUND_BREAK)
        {
            break;
        }
    }


    if (ulrecPosFound || (iFound==MM_RET_FOUND_BREAK))
    {
        if (ulrecPosFound)
        {
            ReadRecord(hf, &sGH, ulrecPosFound,  (LPGENERICREC)lpFRUse);

            CopyFilerecToFindInfo(lpFRUse, lpFind32);
            *lpuStatus =  (ULONG)(lpFRUse->sFR.uStatus);
            *lphShadow = lpFRUse->sFR.ulidShadow;
            if (lpOI)
            {
                CopyFilerecToOtherInfo(lpFRUse, lpOI);
            }
        }
    }
    else
    {
        *lpuStatus = *lphShadow = 0;
    }
    iRet = SRET_OK;
bailout:

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    if (lpFR)
    {
        FreeMem(lpFR);
    }
    else
    {
        UnUseGlobalFilerecExt();
    }

    return (iRet);
}


int CreateHint(
    HSHADOW hShadow,
    LPFIND32 lpFind32,
    ULONG ulHintFlags,
    ULONG ulHintPri,
    LPHSHADOW lphHint
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet=SRET_ERROR;
    OTHERINFO sOI;
    ULONG uStatus;

    // This must be either a wildcard hint, or else it can't be without an Fsobj
    if ((GetShadow(hShadow, lpFind32->cFileName, lphHint, lpFind32, &uStatus, &sOI)>=SRET_OK)
      && (*lphHint))
    {
        Assert((FHasWildcard(lpFind32->cFileName, MAX_PATH) || !mNotFsobj(uStatus)));

        if ((sOI.ulHintPri < MAX_HINT_PRI) &&
            (ulHintPri < MAX_HINT_PRI)
            )
        {
            sOI.ulHintPri += ulHintPri;

            if (sOI.ulHintPri <= MAX_HINT_PRI)
            {
                sOI.ulHintFlags = ulHintFlags;

                mClearBits(sOI.ulHintFlags, HINT_WILDCARD);

                iRet = SetShadowInfoEx(hShadow, *lphHint, lpFind32, 0, SHADOW_FLAGS_OR, &sOI, NULL, NULL);

                if (iRet>=SRET_OK)
                {
                    iRet = SRET_OBJECT_HINT;
                }
            }
        }
    }
    else
    {
        if (FHasWildcard(lpFind32->cFileName, MAX_PATH) && (ulHintPri <= MAX_HINT_PRI))
        {
            InitOtherInfo(&sOI);
            sOI.ulHintFlags = ulHintFlags;
            sOI.ulHintPri = ulHintPri;
            // Tell him that we are creating a file shadow
            lpFind32->dwFileAttributes = FILE_ATTRIBUTE_ARCHIVE;
            iRet = CreateShadowInternal(hShadow, lpFind32, SHADOW_NOT_FSOBJ, &sOI, lphHint);
            if (iRet>=SRET_OK)
            {
                iRet = SRET_WILDCARD_HINT;
            }
        }
    }
    return (iRet);
}

int DeleteHint(
    HSHADOW hShadow,
    USHORT *lpuHintName,
    BOOL fClearAll
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG uStatus;
    HSHADOW hChild;
    int iRet=SRET_ERROR;
    OTHERINFO sOI;

    if (GetShadow(hShadow, lpuHintName, &hChild, NULL, &uStatus, &sOI)>=SRET_OK)
    {
        // Nuke if there is no filesystem object with it
        if (mNotFsobj(uStatus))
        {
            iRet = DeleteShadowInternal(hShadow, hChild, TRUE);

            if (iRet>=SRET_OK)
            {
                iRet = SRET_WILDCARD_HINT;
            }
        }
        else
        {
            BOOL fDoit = TRUE;

            if (fClearAll)
            {
                sOI.ulHintPri = 0;
                sOI.ulHintFlags = 0;
            }
            else
            {
                if (sOI.ulHintPri > 0)
                {
                    --sOI.ulHintPri;
                }
                else
                {
                    fDoit = FALSE;
                }
            }

            if (fDoit)
            {
                iRet = SetShadowInfoEx(   hShadow,
                                                hChild,
                                                NULL,
                                                uStatus,
                                                SHADOW_FLAGS_ASSIGN,
                                                &sOI,
                                                NULL,
                                                NULL
                                                );

                if (iRet>=SRET_OK)
                {
                    iRet = SRET_OBJECT_HINT;
                }
            }
        }
    }
    return (iRet);
}

int CreateGlobalHint(
    USHORT *lpuName,
    ULONG ulHintFlags,
    ULONG ulHintPri
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    SHAREREC sSR;
    ULONG ulidShare, ulT;
#if 0
    if (FindShareRecord(lpdbShadow, lpuName, &sSR))
    {
        if ((sSR.uchHintPri < MAX_HINT_PRI) &&
            (ulHintPri < MAX_HINT_PRI)
            )
        {
            ulT = (ULONG)sSR.uchHintPri + ulHintPri;

            if (ulT <= MAX_HINT_PRI)
            {
                // Setting a hint on the root of the server
                sSR.uchHintFlags = (UCHAR)(ulHintFlags);
                sSR.uchHintPri = (UCHAR)(ulT);
                mClearBits(sSR.uchHintFlags, HINT_WILDCARD);
                Assert(FHasWildcard(lpuName, MAX_PATH) || !mNotFsobj(sSR.uStatus));
                if(SetShareRecord(lpdbShadow, sSR.ulShare, &sSR) > 0)
                {
                    iRet = SRET_OBJECT_HINT;
                }
            }
        }
    }
    else
    {
        if (FHasWildcard(lpuName, MAX_SERVER_SHARE))
        {
            if (ulidShare = AllocShareRecord(lpdbShadow, lpuName))
            {
                //InitShareRec(lpuName, &sSR);
                InitShareRec(&sSR, lpuName, 0);
                sSR.ulShare = ulidShare;
                sSR.ulidShadow = 0xffffffff; // Just to fool FindOpenHSHADOW
                sSR.uchHintFlags = (UCHAR)ulHintFlags;
                sSR.uchHintPri = (UCHAR)ulHintPri;
                mSetBits(sSR.uStatus, SHADOW_NOT_FSOBJ);
                if(AddShareRecord(lpdbShadow, &sSR) > 0)
                {
                    iRet = SRET_WILDCARD_HINT;
                }
            }
        }
    }
#endif
    return (iRet);
}

int DeleteGlobalHint(
    USHORT *lpuName,
    BOOL fClearAll
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;
    SHAREREC sSR;
#if 0
    if (FindShareRecord(lpdbShadow, lpuName, &sSR))
    {
        if (mNotFsobj(sSR.uStatus))
        {
            iRet = DeleteShareRecord(lpdbShadow, sSR.ulShare);
        }
        else
        {
            if (fClearAll)
            {
                sSR.uchHintPri = sSR.uchHintFlags = 0;
            }
            else
            {
                if (sSR.uchHintPri > 0)
                {
                    --sSR.uchHintPri;
                }
            }
            if(SetShareRecord(lpdbShadow, sSR.ulShare, &sSR) > 0)
            {
                iRet = SRET_OK;
            }
        }
    }
#endif
    return (iRet);
}


int CopyFilerecToOtherInfo(
    LPFILERECEXT lpFR,
    LPOTHERINFO lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpOI->ulRefPri          = (ULONG)(lpFR->sFR.uchRefPri);
    lpOI->ulIHPri           = (ULONG)(lpFR->sFR.uchIHPri);
    lpOI->ulHintFlags       = (ULONG)(lpFR->sFR.uchHintFlags);
    lpOI->ulHintPri         = (ULONG)(lpFR->sFR.uchHintPri);
    lpOI->ftOrgTime         = lpFR->sFR.ftOrgTime;
    lpOI->ftLastRefreshTime = IFSMgr_NetToWin32Time(lpFR->sFR.ulLastRefreshTime);

    return(0);
}

int CopyOtherInfoToFilerec(
    LPOTHERINFO lpOI,
    LPFILERECEXT lpFR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpOI->ulIHPri != RETAIN_VALUE)
    {
        lpFR->sFR.uchIHPri = (UCHAR)(lpOI->ulIHPri);
    }
    if (lpOI->ulHintPri != RETAIN_VALUE)
    {
        lpFR->sFR.uchHintPri = (UCHAR)(lpOI->ulHintPri);
    }
    if (lpOI->ulRefPri != RETAIN_VALUE)
    {
        lpFR->sFR.uchRefPri = (UCHAR)((lpOI->ulRefPri <= MAX_PRI)?lpOI->ulRefPri:MAX_PRI);
    }
    if (lpOI->ulHintFlags != RETAIN_VALUE)
    {
        lpFR->sFR.uchHintFlags = (UCHAR)(lpOI->ulHintFlags);
    }
    return(0);
}


int CopySharerecToOtherInfo(LPSHAREREC lpSR, LPOTHERINFO lpOI)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpOI->ulRefPri = 0;
    lpOI->ulRootStatus = (ULONG)(lpSR->usRootStatus);
    lpOI->ulHintFlags = (ULONG)(lpSR->uchHintFlags);
    lpOI->ulHintPri = (ULONG)(lpSR->uchHintPri);
    return(0);
}


int CopyOtherInfoToSharerec(
    LPOTHERINFO lpOI,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpOI->ulHintFlags != RETAIN_VALUE)
    {
        lpSR->uchHintFlags = (UCHAR)(lpOI->ulHintFlags);
    }
    if (lpOI->ulHintPri != RETAIN_VALUE)
    {
        lpSR->uchHintPri = (UCHAR)(lpOI->ulHintPri);
    }
    return(0);
}


int CopyPQToOtherInfo( LPPRIQREC lpPQ,
    LPOTHERINFO lpOI)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpOI->ulRefPri = (ULONG)(lpPQ->uchRefPri);
    lpOI->ulIHPri = (ULONG)(lpPQ->uchIHPri);
    lpOI->ulHintFlags = (ULONG)(lpPQ->uchHintFlags);
    lpOI->ulHintPri = (ULONG)(lpPQ->uchHintPri);
    return(0);
}

int CopyOtherInfoToPQ( LPOTHERINFO lpOI,
    LPPRIQREC lpPQ)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    if (lpOI->ulIHPri != RETAIN_VALUE)
    {
        lpPQ->uchIHPri = (UCHAR)(lpOI->ulIHPri);
    }
    if (lpOI->ulHintPri != RETAIN_VALUE)
    {
        lpPQ->uchHintPri = (UCHAR)(lpOI->ulHintPri);
    }
    if (lpOI->ulRefPri != RETAIN_VALUE)
    {
        lpPQ->uchRefPri = (UCHAR)((lpOI->ulRefPri <= MAX_PRI)?lpOI->ulRefPri:MAX_PRI);
    }
    if (lpOI->ulHintFlags != RETAIN_VALUE)
    {
        lpPQ->uchHintFlags = (UCHAR)(lpOI->ulHintFlags);
    }
    return(0);
}

int CopySharerecToFindInfo( LPSHAREREC lpSR,
    LPFIND32 lpFind32
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpFind32, 0, sizeof(WIN32_FIND_DATA));
//    lpFind32->dwReserved0 = lpSR->ulShare;
//    lpFind32->dwReserved1 = lpSR->ulidShadow;
    lpFind32->dwFileAttributes = lpSR->dwFileAttrib & ~FILE_ATTRIBUTE_ENCRYPTED;
    lpFind32->ftLastWriteTime = lpSR->ftLastWriteTime;
    lpFind32->ftLastAccessTime = lpSR->ftOrgTime;
    memset(lpFind32->cFileName, 0, sizeof(lpFind32->cFileName));
    memcpy(lpFind32->cFileName, lpSR->rgPath, sizeof(lpSR->rgPath));
    return(0);
}

int CopyFindInfoToSharerec(
    LPFIND32 lpFind32,
    LPSHAREREC lpSR
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    // be paranoid and or the directory attribute bit anyway

    lpSR->dwFileAttrib = (lpFind32->dwFileAttributes | FILE_ATTRIBUTE_DIRECTORY);
    lpSR->ftLastWriteTime = lpFind32->ftLastWriteTime;

    return(0);
}


int
CopySharerecToShadowInfo(
    LPSHAREREC     lpSR,
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpSI, 0, sizeof(SHADOWINFO));

    lpSI->hShare = lpSR->ulShare;
    lpSI->hShadow = lpSR->ulidShadow;
    lpSI->uStatus = (ULONG)(lpSR->uStatus);

    lpSI->uRootStatus = (ULONG)(lpSR->usRootStatus);
    lpSI->ulHintFlags = (ULONG)(lpSR->uchHintFlags);
    lpSI->ulHintPri = (ULONG)(lpSR->uchHintPri);

    return 0;
}


int CopyOtherInfoToShadowInfo(
    LPOTHERINFO     lpOI,
    LPSHADOWINFO    lpShadowInfo
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    lpShadowInfo->ulHintFlags = lpOI->ulHintFlags;
    lpShadowInfo->ulHintPri = lpOI->ulHintPri;
    lpShadowInfo->ftOrgTime = lpOI->ftOrgTime;
    lpShadowInfo->ftLastRefreshTime = lpOI->ftLastRefreshTime;
    lpShadowInfo->dwNameSpaceVersion = vdwCSCNameSpaceVersion;
    
    return(0);  //stop complaining about no return value
}

int InitOtherInfo(
    LPOTHERINFO lpOI)
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    memset(lpOI, 0xff, sizeof(OTHERINFO));
    return(0);
}



int PUBLIC                      // ret
FindOpenHSHADOW(        //
    LPFINDSHADOW    lpFindShadow,
    LPHSHADOW       lphShadow,
    LPFIND32        lpFind32,
    ULONG far       *lpuShadowStatus,
    LPOTHERINFO     lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;

    MetaMatchInit(&(lpFindShadow->ulCookie));
    if ((lpFindShadow->uSrchFlags & FLAG_FINDSHADOW_ALLOW_NORMAL)
    && ((lpFindShadow->uAttrib & 0xff) == FILE_ATTRIBUTE_LABEL))
    {
        BCSToUni(lpFind32->cFileName, vszShadowVolume, strlen(vszShadowVolume), BCS_OEM);
        iRet = 1;
    }
    else
    {
        if (MetaMatch(lpFindShadow->hDir, lpFind32
                , &(lpFindShadow->ulCookie)
                , lphShadow, lpuShadowStatus
                , lpOI, lpFindShadow->lpfnMMProc
                , (LPVOID)lpFindShadow)==SRET_OK)
        {
            iRet = (*lphShadow)?SRET_OK:SRET_ERROR;
        }
    }
    return (iRet);
}



int PUBLIC FindNextHSHADOW(             //
    LPFINDSHADOW    lpFindShadow,
    LPHSHADOW       lphShadow,
    LPFIND32        lpFind32,
    ULONG far       *lpuShadowStatus,
    LPOTHERINFO     lpOI
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = SRET_ERROR;

    if ((lpFindShadow->uSrchFlags & FLAG_FINDSHADOW_ALLOW_NORMAL)
    && ((lpFindShadow->uAttrib & 0xff) == FILE_ATTRIBUTE_LABEL))
    {
        BCSToUni(lpFind32->cFileName, vszShadowVolume, strlen(vszShadowVolume), BCS_OEM);
        iRet = SRET_OK;
    }
    else
    {
        if (MetaMatch(lpFindShadow->hDir, lpFind32
                , &(lpFindShadow->ulCookie), lphShadow
                , lpuShadowStatus, lpOI
                , lpFindShadow->lpfnMMProc
                , (LPVOID)lpFindShadow)==SRET_OK)
        {
            iRet = (*lphShadow)?SRET_OK:SRET_ERROR;
        }
    }

    return (iRet);
}

int PUBLIC                              // ret
FindCloseHSHADOW(               //
    LPFINDSHADOW    lpFS
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    return SRET_OK;
}


// Callback function for MetaMatch,

// Return values: -1 => not found, stop; 0 => found, stop; 1 => keep going

int FsobjMMProc(
    LPFIND32        lpFind32,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    ULONG           uStatus,
    LPOTHERINFO     lpOI,
    LPFINDSHADOW    lpFSH
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int matchSem, iRet;
    BOOL fInvalid=FALSE, fIsDeleted, fIsSparse;
    USHORT rgu83[11];

    iRet = MM_RET_CONTINUE;

    if (mNotFsobj(uStatus))
    {
        return (iRet);
    }

#ifdef OFFLINE
    if ((lpFSH->uSrchFlags & FLAG_FINDSHADOW_DONT_ALLOW_INSYNC)
        && !mShadowOutofSync(uStatus))
    return (iRet);
#endif //OFFLINE

    // we are enumerating a directory
    if (hDir && !(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALL))
    {
        fIsDeleted = mShadowDeleted(uStatus);
        fIsSparse = (!mIsDir(lpFind32) && mShadowSparse(uStatus));

        fInvalid = ((!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALLOW_DELETED)&& fIsDeleted)
                ||(!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALLOW_SPARSE)&& fIsSparse)
                ||(!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_ALLOW_NORMAL) && (!fIsDeleted && !fIsSparse)));
    }

    /* If the call came from an NT style API we will use NT
    semantics to match BOTH long names and short name with the
    given pattern.
    If it came from an old style API we will use NT style semantics
    with the short name
    */
    if (lpFSH->uSrchFlags & FLAG_FINDSHADOW_NEWSTYLE)
        matchSem = UFLG_NT;
    else
        matchSem = UFLG_DOS;

    if (lpFSH->uSrchFlags & FLAG_FINDSHADOW_META)
        matchSem |= UFLG_META;

    if (lpFSH->uSrchFlags & FLAG_FINDSHADOW_NEWSTYLE)
    {
        if(IFSMgr_MetaMatch(lpFSH->lpPattern, lpFind32->cFileName, matchSem)||
            (lpFind32->cAlternateFileName[0] && IFSMgr_MetaMatch(lpFSH->lpPattern, lpFind32->cAlternateFileName, matchSem)))
        {
            iRet = MM_RET_FOUND_BREAK;
        }
    }
    else
    {
        // Check if there is an 83name. This can happen when in disconnected state
        // we create an LFN object.
        if (lpFind32->cAlternateFileName[0])
        {
            Conv83UniToFcbUni(lpFind32->cAlternateFileName, rgu83);
            if(IFSMgr_MetaMatch(lpFSH->lpPattern, rgu83, matchSem))
            {
                // If this object has some attributes and they don't match with
                // the search attributes passed in
                if ((lpFind32->dwFileAttributes & FILE_ATTRIBUTE_EVERYTHING)
                    && !(lpFind32->dwFileAttributes & lpFSH->uAttrib))
                {
                    // If this is not a metamatch
                    if (!(lpFSH->uSrchFlags & FLAG_FINDSHADOW_META))
                    {
                    // terminate search
                    iRet = MM_RET_BREAK;
                    }
                    else
                    {
                    // metamatching is going on, let us continue
                    Assert(iRet==MM_RET_CONTINUE);
                    }
                }
                else
                {
                    iRet = MM_RET_FOUND_BREAK;
                }
            }
        }
    }
    if ((iRet==MM_RET_FOUND_BREAK) && fInvalid)
    {
        // we found this object but it is invalid, as per the flags
        // passed in
        if (!(matchSem & UFLG_META))
        {
            // We are not doing metamatching
            iRet = MM_RET_BREAK; // Say not found, and break
        }
        else
        {
            //we are doing metamatching.
            iRet = MM_RET_CONTINUE;    // ask him to keep going
        }
    }
    return (iRet);
}


int GetShadowWithChecksProc(
    LPFIND32        lpFind32,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    ULONG           uStatus,
    LPOTHERINFO     lpOI,
    LPSHADOWCHECK   lpSC
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = MM_RET_CONTINUE;
    BOOL fHintMatch=FALSE, fObjMatch=FALSE;
    ULONG ulHintFlagsThisLevel = HINT_EXCLUSION; // hint flags at this level

    // Convert the patterns to uppercase, as demanded by metamatch
    UniToUpper(lpFind32->cFileName, lpFind32->cFileName, sizeof(lpFind32->cFileName));

    // This is a filesystem object and we haven't found our match yet
    if (!mNotFsobj(uStatus) && !(lpSC->uFlagsOut & FLAG_OUT_SHADOWCHECK_FOUND))
    {
        // Is the source a name?
        if (lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_NAME)
        {
            UniToUpper(lpFind32->cAlternateFileName, lpFind32->cAlternateFileName, sizeof(lpFind32->cFileName));

            // check for normal name and it's alias
            if((IFSMgr_MetaMatch(lpFind32->cFileName, lpSC->lpuName,  UFLG_NT)||

            //ACHTUNG UFLG_NT used even for short name because
            // we are just checking from name coming down from ifsmgr as a path
            // and it is never an FCB style name
            IFSMgr_MetaMatch(lpFind32->cAlternateFileName, lpSC->lpuName, UFLG_NT)))
            {
                fObjMatch = TRUE;
            }
        }
        else  // The source is a shadow ID
        {
            fObjMatch = ((HSHADOW)(ULONG_PTR)(lpSC->lpuName)==hShadow);
        }

        if (fObjMatch)
        {
            if (lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_IGNOREHINTS)
            {
                // No hint checking needed, lets say we found it and stop
                iRet = MM_RET_FOUND_BREAK;
            }
            else
            {
                // found it, mark it as being found.
                lpSC->uFlagsOut |= FLAG_OUT_SHADOWCHECK_FOUND;
#ifdef MAYBE
                lpSC->sOI = *lpOI;
#endif //MAYBE
                if(fHintMatch = ((mIsHint(lpOI->ulHintFlags))!=0))
                {
                    // Let this guy override all previous includes, because
                    // really speaking he is at a lower level in the hierarchy
                    // and by our logic, hints at lower level in the hierarchy
                    // dominate those coming from above
                    lpSC->ulHintPri = 0;
                    lpSC->ulHintFlags = 0;
                    iRet = MM_RET_FOUND_BREAK;
                }
                else
                {
                    iRet = MM_RET_FOUND_CONTINUE;
                }
            }
        }
    }
    else if (!(lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_IGNOREHINTS) // Don't ignore hints
        && mNotFsobj(uStatus)        // This IS a hint
        && (!(lpSC->uFlagsIn & FLAG_IN_SHADOWCHECK_SUBTREE)
            ||mHintSubtree(lpOI->ulHintFlags)))
    {
        // This is a pure hint and
        // we are either at the end, so we can look at all kinds of hints
        // or we can look at only subtree hints

        if(IFSMgr_MetaMatch(lpFind32->cFileName, lpSC->lpuType, UFLG_NT|UFLG_META))
        {
            // The type matches with the hint
            fHintMatch = TRUE;
        }
    }

    if (fHintMatch)
    {
        if (mHintExclude(lpOI->ulHintFlags))
        {
            // Is this an exclusion hint, and the object has not
            // been included by a previous hint at this level, set it
            if (mHintExclude(ulHintFlagsThisLevel))
            {
//                Assert(lpOI->ulHintPri == 0);
//                lpSC->ulHintPri = lpOI->ulHintPri;
                lpSC->ulHintPri = 0;
                ulHintFlagsThisLevel = lpSC->ulHintFlags = lpOI->ulHintFlags;
            }
        }
        else
        {
            // Inclusion hint, override earlier excludes, or lower priority hints
            if (mHintExclude(lpSC->ulHintFlags) ||
                (lpSC->ulHintPri <  lpOI->ulHintPri))
            {
                lpSC->ulHintPri = lpOI->ulHintPri;
                ulHintFlagsThisLevel = lpSC->ulHintFlags = lpOI->ulHintFlags;
            }
        }
    }
    return (iRet);
}

int
FindCreateShare(
    USHORT                  *lpShareName,
    BOOL                    fCreate,
    LPSHADOWINFO            lpSI,
    BOOL                    *lpfCreated
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    ULONG       uShadowStatus, hShare;
    BOOL    fCreated = FALSE;
    int iRet = SRET_ERROR;

    Assert(vfInShadowCrit != 0);

    if (!IsPathUNC(lpShareName, MAX_SERVER_SHARE_NAME_FOR_CSC))
    {

        CShadowKdPrint(ALWAYS,("FindCreateShare: Invalid share name %ws\r\n", lpShareName));
//        Assert(FALSE);
        return (iRet);
    }
    if (lpfCreated)
    {
        *lpfCreated = FALSE;
    }


    if (GetShareFromPath(lpShareName, lpSI) <= SRET_ERROR)
    {
        CShadowKdPrint(FINDCREATESHARE,("FindCreateShare: Error creating server\r\n"));
        return SRET_ERROR;
    }

    if (lpSI->hShare)
    {
        iRet = SRET_OK;
    }
    else
    {
        if (fCreate)
        {
            if(hShare = HCreateShareObj(lpShareName, lpSI))
            {
                if (lpfCreated)
                {
                    *lpfCreated = TRUE;
                }
                iRet = SRET_OK;
            }
            else
            {
                CShadowKdPrint(FINDCREATESHARE,("FindCreateShare: Couldn't create server object \r\n"));
            }
        }
    }

    return (iRet);
}

#ifdef CSC_RECORDMANAGER_WINNT

int FindCreateShareForNt(
    PUNICODE_STRING         lpShareName,
    BOOL                    fCreate,
    LPSHADOWINFO            lpSI,
    BOOL                    *lpfCreated
    )
{
    int iRet, lenName;
    int ShareNameLengthInChars;
    BOOL fIsLoopBack = FALSE;

    Assert(vfInShadowCrit != 0);

    

    ShareNameLengthInChars = lpShareName->Length / sizeof(WCHAR);

    if ( ShareNameLengthInChars >= (sizeof(vsFRExt.sFR.rgwName)-1))
    {
        return SRET_ERROR;
    }

    UseGlobalFilerecExt();

    // plug the extra slash.
    vsFRExt.sFR.rgwName[0] = (USHORT)('\\');

    // append the rest of the share name
    memcpy(&(vsFRExt.sFR.rgwName[1]), lpShareName->Buffer, lpShareName->Length);

    // put in a terminating NULL
    vsFRExt.sFR.rgwName[ShareNameLengthInChars + 1] = 0;

    if (MRxSmbCscIsLoopbackServer(vsFRExt.sFR.rgwName, &fIsLoopBack)==STATUS_SUCCESS) {
        if (fIsLoopBack){
            UnUseGlobalFilerecExt();
            return SRET_ERROR;
        }

    }

    iRet = FindCreateShare(vsFRExt.sFR.rgwName, fCreate, lpSI, lpfCreated);

    UnUseGlobalFilerecExt();

    return iRet;
}
#endif
int
CShadowFindFilerecFromInode(
    LPVOID          lpdbID,
    HSHADOW         hDir,
    HSHADOW         hShadow,
    LPPRIQREC       lpPQ,
    LPFILERECEXT    lpFRUse
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int iRet = 0;

    Assert(vfInShadowCrit != 0);

    if(!FindFileRecFromInode(lpdbShadow, hDir, hShadow, lpPQ->ulrecDirEntry, lpFRUse))
    {
        SetCSCDatabaseErrorFlags(CSC_DATABASE_ERROR_MISSING_INODE);
        SetLastErrorLocal(ERROR_FILE_NOT_FOUND);
        CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! no filerec for pq entry Inode=%x\r\n",
                        hShadow));
//        DeletePriQRecord(lpdbShadow, hDir, hShadow, lpPQ);
        goto bailout;
    }

    if ((lpFRUse->sFR.ulidShadow != lpPQ->ulidShadow)||(lpFRUse->sFR.ulidShadow != hShadow))
    {
        CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! mismatched filerec for pq entry Inode=%x\r\n",
                hShadow));

        // try getting it the hard way.
        if(!(lpPQ->ulrecDirEntry = FindFileRecFromInode(lpdbShadow, hDir, hShadow, INVALID_REC, lpFRUse)))
        {
            CShadowKdPrint(ALWAYS,("ReadShadowInfo: !!! no filerec for pq entry Inode=%x, deleting PQ entry\r\n",
                            hShadow));
//            DeletePriQRecord(lpdbShadow, hDir, hShadow, lpPQ);
            goto bailout;
        }
        else
        {
            // try updating this info.
            // don't check for errors, if there is a problem we will fix it on the fly
            // next time around
            UpdatePriQRecord(lpdbShadow, hDir, hShadow, lpPQ);
        }
    }

    iRet = lpPQ->ulrecDirEntry;

bailout:

    return (iRet);
}

BOOL
CopySecurityContextToBuffer(
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext,
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   dwSizeCopied = 0;

    if (lpdwBlobSize)
    {
        if (lpSecurityBlob)
        {
            dwSizeCopied = min(*lpdwBlobSize, sizeof(RECORDMANAGER_SECURITY_CONTEXT));

            memcpy(lpSecurityBlob, lpSecurityContext,  dwSizeCopied);

            *lpdwBlobSize = dwSizeCopied;
        }
        else
        {
            // size needed
            *lpdwBlobSize = sizeof(RECORDMANAGER_SECURITY_CONTEXT);
        }
    }

    return ((lpSecurityBlob != NULL) && dwSizeCopied);
}


BOOL
CopyBufferToSecurityContext(
    LPVOID                              lpSecurityBlob,
    LPDWORD                             lpdwBlobSize,
    LPRECORDMANAGER_SECURITY_CONTEXT    lpSecurityContext
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    DWORD   dwSizeCopied = 0;

    if (lpdwBlobSize)
    {

        if (lpSecurityBlob)
        {
            dwSizeCopied = min(*lpdwBlobSize, sizeof(RECORDMANAGER_SECURITY_CONTEXT));
            memcpy(lpSecurityContext, lpSecurityBlob, dwSizeCopied);
            *lpdwBlobSize = dwSizeCopied;
        }
        else
        {
            // size copied
            *lpdwBlobSize = 0;
        }

    }

    // we have done some copying

    return ((lpSecurityBlob != NULL) && dwSizeCopied);
}


int PathFromHShadow(
    HSHADOW  hDir,
    HSHADOW  hShadow,
    USHORT   *lpBuff,
    int      cBuff  // # of WCHAR characters that lpBuff can fit
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    int cCount, cRemain, iRet=-1;
    LPFIND32 lpFind32;
    ULONG uShadowStatus;
    HSHADOW  hTmp;

    Assert(vfInShadowCrit != 0);

    Assert(cBuff > 1);
    if (!(lpFind32 = (LPFIND32)AllocMem(sizeof(WIN32_FIND_DATA))))
    {
        KdPrint(("PathFromHSHADOW:Error Allocating memory\r\n"));
        goto bailout;
    }
    memset(lpBuff, 0, cBuff * sizeof(USHORT));
    cRemain = cBuff-1;

    // special case the root
    if (!hDir)
    {
        lpBuff[--cRemain] = (USHORT)('\\');

    }
    else
    {
        do
        {
            // If we are not dealing with the root
            if (hDir)
            {
                if(GetShadowInfo(hDir, hShadow, lpFind32, &uShadowStatus, NULL) < SRET_OK)
                    goto bailout;
                // Count of characters
                cCount = wstrlen(lpFind32->cFileName);
                // We need count+1 for prepending a backslash
                if (cCount >= cRemain)
                    goto bailout;
                // Save the ending byte which may be destroyed by UniToBCS
                // Convert
//                UniToBCS(lpBuff+cRemain-cCount, lpFind32->cFileName, sizeof(lpFind32->cFileName), cCount, BCS_WANSI);
                memcpy(lpBuff+cRemain-cCount, lpFind32->cFileName, cCount * sizeof(USHORT));
                cRemain -= cCount;
            }
            lpBuff[--cRemain] = (USHORT)('\\');
            if(GetAncestorsHSHADOW(hDir, &hTmp, NULL) < SRET_OK)
                goto bailout;
            hShadow = hDir;
            hDir = hTmp;
        }
        while (hDir);
    }

    // !!ACHTUNG!! this should work because the overlap is in the right way
    iRet = cBuff-cRemain;
    memcpy(lpBuff, lpBuff+cRemain, iRet * sizeof(USHORT));

bailout:
    if (lpFind32)
        FreeMem(lpFind32);
    return (iRet);
}

int
GetSecurityInfosFromBlob(
    LPVOID          lpvBlob,
    DWORD           dwBlobSize,
    LPSECURITYINFO  lpSecInfo,
    DWORD           *lpdwBytes
    )
/*++

Routine Description:

    Given security blob, this routine returns the information in form of an array of
    SECURITYINFO structures.

Arguments:

    lpvBlob         blob buffer that is obtained from GetShadowEx or GetShadowInfoEx

    dwBlobSize      blob buffer size obtained from GetShadowEx or GetShadowInfoEx

    lpSecInfo       Array of SECURITYINFO strucutres where to output the info

    lpdwBytes

Return Value:

    ERROR_SUCCESS if successful, otherwise appropriate error

--*/
{
    PACCESS_RIGHTS  pAccessRights = (PACCESS_RIGHTS)lpvBlob;
    DWORD   i, cnt;

    cnt = *lpdwBytes/sizeof(ACCESS_RIGHTS);
    cnt = min(cnt, CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES);

    if (!lpSecInfo)
    {
        *lpdwBytes = CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES * sizeof(ACCESS_RIGHTS);
        return 0;
    }

    for (i=0; i<cnt; ++i)
    {
        (lpSecInfo+i)->ulPrincipalID = (pAccessRights + i)->SidIndex;
        (lpSecInfo+i)->ulPermissions = (pAccessRights + i)->MaximalRights;
    }

    return TRUE;
}

int
GetDatabaseLocation(
    LPSTR   lpszBuff
    )
/*++

Routine Description:

    Returns the current location of the database in ANSI string.

Arguments:

    lpszBuff    buffer, must be MAX_PATH

Return Value:

    returns SRET_OK if successfull else returns SRET_ERROR

--*/
{
    return(QueryRecDB(lpszBuff, NULL, NULL, NULL, NULL) >= SRET_OK);
}

#if 0
int PUBLIC CopyFile(
    LPPATH lpSrc,
    ULONG ulidDir,
    ULONG ulidNew
    )
{
    LPSTR   lpszName = NULL;
    int iRet=-1;
    HFREMOTE hfSrc= (HFREMOTE)NULL;
    CSCHFILE hfDst= NULL;
    ULONG pos;
    LPVOID lpBuff=NULL;

    if (OpenFileRemoteEx(lpSrc, ACCESS_READONLY, ACTION_OPENEXISTING, 0, &hfSrc))
    {
        CShadowKdPrint(BADERRORS,("CopyFile: Can't open remote file\r\n"));
        goto bailout;
    }

    if (!(lpBuff = AllocMem(COPY_BUFF_SIZE)))
    {
        goto bailout;
    }

    lpszName = AllocMem(MAX_PATH);

    if (!lpszName)
    {
        goto bailout;
    }

    if(GetLocalNameHSHADOW(ulidNew, lpszName, MAX_PATH, FALSE)!=SRET_OK)
    {
        goto bailout;
    }

    // If the original file existed it would be truncated
    if ( !(hfDst = R0OpenFile(ACCESS_READWRITE, ACTION_CREATEALWAYS, lpszName)))
    {
        CShadowKdPrint(BADERRORS,("CopyFile: Can't create %s\r\n", lpszName));
        goto bailout;
    }

    CShadowKdPrint(COPYFILE,("Copying...\r\n"));
    pos = 0;

    // Both the files are correctly positioned
    while ((iRet = ReadFileRemote(hfSrc, LpIoreqFromFileInfo(hfSrc)
                , pos, lpBuff, COPY_BUFF_SIZE))>0)
    {
    if (WriteFileLocal(hfDst, pos, lpBuff, iRet) < 0)
    {
        CShadowKdPrint(BADERRORS,("CopyFile: Write Error\r\n"));
        goto bailout;
    }
    pos += iRet;
    }

    CShadowKdPrint(COPYFILE,("Copy Complete\r\n"));

    iRet = 1;
bailout:
    if (hfSrc)
    CloseFileRemote(hfSrc, NULL);
    if (hfDst)
    CloseFileLocal(hfDst);
    if (lpBuff)
    FreeMem(lpBuff);
    if ((iRet==-1) && hfDst)
    {
    DeleteFileLocal(lpszName, ATTRIB_DEL_ANY);
    }
    if (lpszName)
    {
        FreeMem(lpszName);
    }
    return iRet;
}
#endif

#ifdef DEBUG
int
ValidatePri(
    LPFILERECEXT lpFR
    )
{
    if (!(lpFR->sFR.dwFileAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        if((lpFR->sFR.uchRefPri != MAX_PRI))
        {
            CShadowKdPrint(ALWAYS,("Bad refpri %x %ws\r\n",
                                            lpFR->sFR.uchRefPri,
                                            lpFR->sFR.rgw83Name));
            return 0;
        }
    }
    else
    {
        if((lpFR->sFR.uchRefPri != MIN_PRI))
        {
            CShadowKdPrint(ALWAYS,("Bad refpri %x %ws\r\n",
                                            lpFR->sFR.uchRefPri,
                                            lpFR->sFR.rgw83Name));
            return 0;
        }

    }
    return 1;
}
#endif


int
GetHShareFromUNCString(
    USHORT  *lpServer,
    int     cbServer,
    int     lenSkip,
    BOOL    fIsShareName,
    HSHARE *lphShare,
    ULONG   *lpulHintFlags
    )
/*++

Routine Description:


Arguments:


Return Value:

    This is the ONLY routine that is called from rdr2 code that expects the ciritcal section not to be held
    because of deadlock with FAT during paging writes, if the net goes down.
    See comments in rdr2\rdbss\smb.mrx\csc.nt5\transitn.c

--*/
{
    int iRet = -1, i;
    GENERICHEADER  sGH;
    CSCHFILE hf = NULL;
    ULONG ulRec;
    SHAREREC sSR;
    BOOL    fCached;
    USHORT  uchDelimiter=(USHORT)'\\';

    *lphShare = 0;
    *lpulHintFlags = 0;

    if ((cbServer/sizeof(USHORT)+lenSkip)>= (sizeof(sSR.rgPath)/sizeof(USHORT)))
    {
        return iRet;
    }

    if (fIsShareName)
    {
        uchDelimiter = 0;
    }

    if (!(hf = OpenInodeFileAndCacheHandle(lpdbShadow, ULID_SHARE, ACCESS_READWRITE, &fCached)))
    {
        goto bailout;
    }

    if(ReadHeader(hf, &sGH, sizeof(FILEHEADER)) < 0)
    {
        goto bailout;
    }
    

    for (ulRec=1; ulRec<=sGH.ulRecords; ulRec++)
    {
        if(ReadRecord(hf, &sGH, ulRec, (LPGENERICREC)&sSR) < 0)
        {
            goto bailout;
        }

        if (sSR.uchType != REC_DATA)
        {
            continue;
        }

        // 0 return means it matched
        if(!wstrnicmp(lpServer, sSR.rgPath + lenSkip, cbServer))
        {
            Assert(sSR.ulShare);

            if (sSR.rgPath[lenSkip+cbServer/sizeof(USHORT)] == uchDelimiter)
            {
                *lphShare = sSR.ulShare;
                *lpulHintFlags = (ULONG)(sSR.uchHintFlags);
                iRet = SRET_OK;
                break;
            }
        }

    }

    iRet = SRET_OK;

bailout:

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return (iRet);

}

BOOL
EnableHandleCaching(
    BOOL    fEnable
    )
/*++

Routine Description:


Arguments:


Return Value:

    returns previous handlecaching value

--*/
{
    BOOL    fT, fT1;
    Assert(vfInShadowCrit != 0);

    fT = EnableHandleCachingSidFile(fEnable);

    fT1 = EnableHandleCachingInodeFile(fEnable);

    Assert(fT == fT1);
    return (fT1);
}

int
RecreateHSHADOW(
    HSHADOW hDir,
    HSHADOW hShadow,
    ULONG   ulAttrib
    )
/*++

Routine Description:

    This routine recreates an inode data file. This is so that when the CSC directory is
    marked for encryption/decryption, the newly created inode file will get encrypted.

Arguments:

    hDir        Inode directory

    hShadow     Inode whose file needs to be recreated

    ulAttrib    recreate with given attributes

Return Value:


--*/
{
    return (RecreateInode(lpdbShadow, hShadow, ulAttrib));
}

VOID
AdjustSparseStaleDetectionCount(
    ULONG hShare,
    LPFILERECEXT    lpFRUse
    )
/*++

Routine Description:

    This routine deals with a monotonically increasing (that is untill it wraps around), counter
    that is essentially a tick count that indicates when was the last time the cshadow interface
    created/set a sparse or a stale file.

    This is used by the agent to decide whether to enumerate the priority Q or not.

    Added code to also check if we're creating a file on a manually-cached share, and
    if so then to start the agent so it will clean this file up later.

Arguments:

    lpFRUse     record for the file/dir

Return Value:

    None

--*/
{
    ULONG cStatus;
    SHAREREC sSR = {0};
    LONG iRet = SRET_ERROR;
    
    // DbgPrint("AdjustSparseStaleDetectionCount(hShare=0x%x)\n", hShare);

    //
    // if this is a file and is stale or sparse
    //
    if (IsFile(lpFRUse->sFR.dwFileAttrib) &&
        (lpFRUse->sFR.uStatus & (SHADOW_STALE|SHADOW_SPARSE))) {
        ++vdwSparseStaleDetecionCount;
        // DbgPrint("####Pulsing agent #2 (1)\n");
        MRxSmbCscSignalFillAgent(NULL, 0);
        goto AllDone;
    }

    if (hShare != 0) {
        //
        // If we're creating a file on a manually-cached share, let the agent know
        //
        if (IsFile(lpFRUse->sFR.dwFileAttrib)) {
            iRet = GetShareRecord(lpdbShadow, hShare, &sSR);
            if (iRet < SRET_OK) {
                // DbgPrint("AdjustSparseStaleDetectionCount exit (1) iRet = %d\n", iRet);
                goto AllDone;
            }
        }
        cStatus = sSR.uStatus & FLAG_CSC_SHARE_STATUS_CACHING_MASK;
        // DbgPrint("AdjustSparseStaleDetectionCount cStatus=0x%x\n", cStatus);
        if (cStatus == FLAG_CSC_SHARE_STATUS_MANUAL_REINT) {
            ++vdwManualFileDetectionCount;
            // DbgPrint("####Pulsing agent #2 (2)\n");
            MRxSmbCscSignalFillAgent(NULL, 0);
        }
    }

AllDone:
    return;
}

VOID
QuerySparseStaleDetectionCount(
    LPDWORD lpcnt
    )
/*++

Routine Description:

Arguments:

    lpcnt       for returning the count

Return Value:

    None

--*/
{
    *lpcnt = vdwSparseStaleDetecionCount;
}

VOID
QueryManualFileDetectionCount(
    LPDWORD lpcnt
    )
/*++

Routine Description:

Arguments:

    lpcnt       for returning the count

Return Value:

    None

--*/
{
    *lpcnt = vdwManualFileDetectionCount;
}

ULONG
QueryDatabaseErrorFlags(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    return GetCSCDatabaseErrorFlags();
}

int
HasDescendentsHShadow(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOLEAN    *lpfDescendents
    )
/*++

Routine Description:

Arguments:

Return Value:

    None

--*/
{
    *lpfDescendents = (!FInodeIsFile(lpdbShadow, hDir, hShadow) && 
                        HasDescendents(lpdbShadow, 0, hShadow));

    return 0;
}

int PUBLIC AddStoreData(
    LPTSTR    lpdbID,
    LPSTOREDATA lpSD
    )
/*++

Routine Description:

    Adds space and file/dir count to the database. This is used for purging
    unpinned data.

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    SHAREHEADER sSH;
    int iRet = -1;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_SHARE, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    if (lpSD->ulSize)
    {
        // RecordKdPrint(STOREDATA,("Adding %ld \r\n", lpSD->ulSize));

    }
    if ((iRet = ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))> 0)
    {
        if (lpSD->ulSize)
        {
            // RecordKdPrint(STOREDATA,("AddStoreData Before: %ld \r\n", sSH.sCur.ulSize));
        }
        sSH.sCur.ulSize += lpSD->ulSize;
        sSH.sCur.ucntDirs += lpSD->ucntDirs;
        sSH.sCur.ucntFiles += lpSD->ucntFiles;

        // ensure that the data is always in clustersizes
        Assert(!(lpSD->ulSize%(vdwClusterSizeMinusOne+1)));

        if ((iRet = WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER))) < 0)
            Assert(FALSE);

        if (lpSD->ulSize)
        {
            // RecordKdPrint(STOREDATA,("AddStoreData After: %ld \r\n", sSH.sCur.ulSize));
        }

        //
        // If we are at the full cache size, kick the agent so he'll
        // free up some space.
        //
        if (sSH.sCur.ulSize > sSH.sMax.ulSize) {
            // DbgPrint("Full cache, notifying agent...\n");
            CscNotifyAgentOfFullCacheIfRequired();
        }
    }

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }
    return iRet;
}

int PUBLIC SubtractStoreData(
    LPTSTR    lpdbID,
    LPSTOREDATA lpSD
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    CSCHFILE hf;
    SHAREHEADER sSH;
    int iRet = -1;
    BOOL    fCached;

    hf = OpenInodeFileAndCacheHandle(lpdbID, ULID_SHARE, ACCESS_READWRITE, &fCached);

    if (!hf)
    {
        return -1;
    }

    if (lpSD->ulSize)
    {
        // RecordKdPrint(STOREDATA,("Subtracting %ld \r\n", lpSD->ulSize));

    }
    if ((iRet = ReadHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))> 0)
    {
        // RecordKdPrint(STOREDATA,("SubtractStoreData Before: %ld \r\n", sSH.sCur.ulSize));
        if (sSH.sCur.ulSize >lpSD->ulSize)
        {
            sSH.sCur.ulSize -= lpSD->ulSize;
        }
        else
        {
            sSH.sCur.ulSize = 0;
        }
        if (sSH.sCur.ucntDirs > lpSD->ucntDirs)
        {
            sSH.sCur.ucntDirs -= lpSD->ucntDirs;
        }
        else
        {
            sSH.sCur.ucntDirs = 0;
        }
        if (sSH.sCur.ucntFiles > lpSD->ucntFiles)
        {
            sSH.sCur.ucntFiles -= lpSD->ucntFiles;
        }
        else
        {
            sSH.sCur.ucntFiles = 0;
        }

        // ensure that the data is always in clustersizes
        Assert(!(lpSD->ulSize%(vdwClusterSizeMinusOne+1)));

        if ((iRet = WriteHeader(hf, (LPVOID)&sSH, sizeof(SHAREHEADER)))<0)
            Assert(FALSE);
        // RecordKdPrint(STOREDATA,("SubtractStoreData After: %ld \r\n", sSH.sCur.ulSize));
    }

    if (hf && !fCached)
    {
        Assert(vfStopHandleCaching);
        CloseFileLocal(hf);
    }
    else
    {
        Assert(!hf || !vfStopHandleCaching);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\hookcmmn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    HookCmmn.c

Abstract:

    The purpose of this module is to have a common source for many routines
    used by the hook on win95 and on NT. In this way, there'll be only one
    place to change even if there's some code uglyness (ifdefs, etc.)

    Initially, i (jll) have not actually removed any routines from the win95
    hook....i have just made copies of them here. accordingly, everything is
    initially under ifdef-NT. the rule that is being used is that anything that
    requires visibility of the Rx Fcb structures will not be included here;
    rather, it'll be in the minirdr part. the following are steps that need to be
    accomplished:

       1. ensure that the win95 shadow vxd can be built from these sources.
       1a. juggle the win95 vxd compile to use precomp and stdcall.
       2. juggle the record manager structs so that we'll be RISCable
       3. remove any routines from hook.h that are actually here.
       4. remove a number of other routines that i splated around from hook.c
          under NT-ifdef and place them here.

Author:

    Shishir Pardikar     [Shishirp]      01-jan-1995

Revision History:

    Joe Linn             [JoeLinn]       10-mar-97    Initial munging for NT

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) {qweee __d__;}

#ifdef DEBUG
//cshadow dbgprint interface
#define HookCmmnKdPrint(__bit,__x) {\
    if (((HOOKCMMN_KDP_##__bit)==0) || FlagOn(HookCmmnKdPrintVector,(HOOKCMMN_KDP_##__bit))) {\
        KdPrint (__x);\
    }\
}
#define HOOKCMMN_KDP_ALWAYS                 0x00000000
#define HOOKCMMN_KDP_BADERRORS              0x00000001
#define HOOKCMMN_KDP_ISSPECIALAPP           0x00000002
#define HOOKCMMN_KDP_INITDATABASE           0x00000004
#define HOOKCMMN_KDP_TUNNELING              0x00000008


#define HOOKCMMN_KDP_GOOD_DEFAULT (HOOKCMMN_KDP_BADERRORS         \
                                    | 0)

ULONG HookCmmnKdPrintVector = HOOKCMMN_KDP_GOOD_DEFAULT;
ULONG HookCmmnKdPrintVectorDef = HOOKCMMN_KDP_GOOD_DEFAULT;
#else
#define HookCmmnKdPrint(__bit,__x)  {NOTHING;}
#endif

//this is just for editing ease......
//#ifdef CSC_RECORDMANAGER_WINNT
//#endif //ifdef CSC_RECORDMANAGER_WINNT


#ifdef CSC_RECORDMANAGER_WINNT
BOOL fInitDB = FALSE;   // Database Initialized
BOOL fReadInit = FALSE; // Init values have been read
BOOL fSpeadOpt = TRUE;  // spead option, reads the cached files even when
                        // locks are set on the share
GLOBALSTATUS sGS;       // Global status used for communicating with ring3

// Semaphore used to synchronize in memory structures
VMM_SEMAPHORE  semHook;

// This strucutre is used as temporary I/O buffer only within Shadow critical
// section
WIN32_FIND_DATA   vsFind32;


// Agent Info, obtained through IoctlRegisterAgent
ULONG hthreadReint=0; // Thred ID
ULONG hwndReint=0;    // windows handle.
ULONG heventReint;

// upto 16 threads can temporarily enable and disable shadowing
ULONG rghthreadTemp[16];


// Reintegration happens one share at a time. If it is going on, then BeginReint
// in ioctl.c sets  hShareReint to the share on which we are doing reint
// if vfBlockingReint is TRUE, then all operations on that share will fail
// when the share is reintegrating.
// If vfBlockingReint is not true, then if the dwActivityCount is non-zero
// the ioctls to change any state on any of the descendents of this share fail
// causing the agent to aboort reintegration
// The acitvycount is incremented based on a trigger from the redir/hook, when
// any namespace mutating operation is performed.

HSHARE hShareReint=0;   // Share that is currently being reintegrated
BOOL    vfBlockingReint = TRUE;
DWORD   vdwActivityCount = 0;
//from shadow.asm   ---------------------------------------------------
int fShadow = 0;

#if defined(_X86_)
int fLog = 1;
#else
int fLog = 0;
#endif


//tunnel cache
SH_TUNNEL rgsTunnel[10] = {0};

#ifdef DEBUG
ULONG cntReadHits=0;
tchar pathbuff[MAX_PATH+1];
#endif



BOOL FindTempAgentHandle(
   ULONG hthread)
   {
   int i;

   for (i=0; i < (sizeof(rghthreadTemp)/sizeof(ULONG)); ++i)
      {
      if (rghthreadTemp[i]==hthread)
         {
         return TRUE;
         }
      }
   return FALSE;

   }

BOOL
RegisterTempAgent(
    VOID
)
{
    int i;
    ULONG hthread;

    hthread = GetCurThreadHandle();

    for (i=0; i< (sizeof(rghthreadTemp)/sizeof(ULONG)); ++i)
    {
        if (!rghthreadTemp[i])
        {
            rghthreadTemp[i] = hthread;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
UnregisterTempAgent(
    VOID
)
{
    int i;
    ULONG hthread;

    hthread = GetCurThreadHandle();

    for (i=0; i < (sizeof(rghthreadTemp)/sizeof(ULONG)); ++i)
    {
        if (rghthreadTemp[i]==hthread)
        {
            rghthreadTemp[i] = 0;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsSpecialApp
   (
   VOID
   )
   {
   ULONG hthread;

   hthread = GetCurThreadHandle();
   if ((hthread==hthreadReint) || FindTempAgentHandle(hthread))
      {
      HookCmmnKdPrint(ISSPECIALAPP,("This is our Special App \r\n"));
      return TRUE;
      }
   return FALSE;
   }


#define SetHintsFromList(a,b) ((-1))
int InitShadowDB(VOID)
   {
    //for NT, we don't have all this hint stuff....just return success
    return(1);
#if 0
   VMMHKEY hKeyShadow;
   int iSize = sizeof(int), iRet = -1;
   DWORD dwType;
   extern char vszExcludeList[], vszIncludeList[];
   BOOL fOpen = FALSE;
   char rgchList[128];
   if (_RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_SHADOW, &hKeyShadow) ==  ERROR_SUCCESS)
      {
      fOpen = TRUE;
      iSize = sizeof(rgchList);
      if (_RegQueryValueEx(hKeyShadow, vszExcludeList, NULL, &dwType, rgchList, &iSize)==ERROR_SUCCESS)
         {
         if (SetHintsFromList(rgchList, TRUE) < 0)
            goto bailout;
         }
      iSize = sizeof(rgchList);
      if (_RegQueryValueEx(hKeyShadow, vszIncludeList, NULL, &dwType, rgchList, &iSize)==ERROR_SUCCESS)
         {
         if (SetHintsFromList(rgchList, FALSE) < 0)
            goto bailout;
         }

      iRet = 1;
      }
bailout:
   if (fOpen)
      {
      _RegCloseKey(hKeyShadow);
      }
   return (iRet);
#endif //0
   }

int ReinitializeDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize
    )
{
    BOOL fDBReinited = FALSE;
    if(OpenShadowDB(lpszLocation, lpszUserName, nFileSizeHigh, nFileSizeLow, dwClusterSize, TRUE, &fDBReinited) >= 0)
    {
        if (InitShadowDB() >= 0)
        {
            Assert(fDBReinited == TRUE);
            fInitDB = 1;
        }
        else
        {
            CloseShadowDB();
        }
    }
    if (fInitDB != 1)
    {
        fInitDB = -1;
        fShadow = 0;
    }

    return (fInitDB);
}

int
InitDatabase(
    LPSTR   lpszLocation,
    LPSTR   lpszUserName,
    DWORD   nFileSizeHigh,
    DWORD   nFileSizeLow,
    DWORD   dwClusterSize,
    BOOL    fReformat,
    BOOL    *lpfNew
)
{
    int iRet = 1;
    BOOL fDBReinited = FALSE;
    LPSTR PrefixedLocation = NULL;

    HookCmmnKdPrint(INITDATABASE,("Opening database at %s for %s with size %d \r\n", lpszLocation, lpszUserName, nFileSizeLow));

    //
    // When CSC is started by the kernel as part of a remote boot, the input path
    // will already be in NT format.
    //

    if (( _strnicmp(lpszLocation,"\\Device\\Harddisk",strlen("\\Device\\Harddisk")) != 0 ) &&
        ( _strnicmp(lpszLocation,"\\ArcName",strlen("\\ArcName")) != 0 )) {

        //this would be NT only..........
        PrefixedLocation = AllocMem(strlen(lpszLocation)+sizeof(NT_DB_PREFIX));

        if (!PrefixedLocation)
        {
            return -1;
        }

        strcpy(PrefixedLocation, NT_DB_PREFIX);
        strcat(PrefixedLocation, lpszLocation);
        HookCmmnKdPrint(INITDATABASE,("Opening database at %s changing to %s \r\n", lpszLocation, PrefixedLocation));

        //fortunately, this is call-by-value....so i can just overwrite the input parameter
        lpszLocation = PrefixedLocation;
    }


    // Do onetime init
    if (!fReadInit)
    {
        ReadInitValues();
        memset(rghthreadTemp, 0, sizeof(rghthreadTemp));
        fReadInit = TRUE;
    }

    // check if the database is not already initialized
    if (!fInitDB)
    {
        // open/create it
        iRet = OpenShadowDB(
                    lpszLocation,
                    lpszUserName,
                    nFileSizeHigh,
                    nFileSizeLow,
                    dwClusterSize,
                    fReformat,
                    &fDBReinited
                    );

        // open/create DB succeeded?
        if (iRet < 0)
        {
            //no
            HookCmmnKdPrint(ALWAYS,("Error Opening/Createing shadow database \r\n"));
            fInitDB = -1;
            fShadow = 0;
        }
        else
        {
            *lpfNew = fDBReinited;

            // did it exist in the first place?
            if (fDBReinited)
            {
                // no it didn't, let use create things like the filters and such
                iRet = InitShadowDB();
            }

            if (iRet >= 0)
            {
                fInitDB = 1;
            }
            else
            {
                CloseShadowDB();
            }
        }
    }

    if (PrefixedLocation)
    {
        FreeMem(PrefixedLocation);        
    }
    return (iRet);
}


int
CloseDatabase(
    VOID
    )
{
    if (fInitDB)
    {
        CloseShadowDB();
        fInitDB = FALSE;
        return (1);
    }
    return (0);
}

BOOL IsBusy
   (
   HSHADOW hShadow
   )
   {
   DeclareFindFromShadowOnNtVars()

   if (PFindFdbFromHShadow(hShadow))
      return TRUE;
   return FALSE;
   }


int PRIVATE DeleteShadowHelper
   (
   BOOL        fMarkDeleted,
   HSHADOW     hDir,
   HSHADOW     hNew
        )
        {
   int iRet = -1;

   if (!fMarkDeleted)
      {
      if (DeleteShadow(hDir, hNew) < SRET_OK)
         goto bailout;
      }
   else
      {
      if (TruncateDataHSHADOW(hDir, hNew) < SRET_OK)
            goto bailout;
      // ACHTUNG!! other people depend on status being SHADOW_DELETED
      if (SetShadowInfo(hDir, hNew, NULL, SHADOW_DELETED, SHADOW_FLAGS_OR) < SRET_OK)
         goto bailout;
      }
   iRet = 0;

bailout:

   return (iRet);
        }


/*+-------------------------------------------------------------------------*/
/*    @doc    INTERNAL HOOK
    @func    BOOL | InsertTunnelInfo | 2.0

            The <f InsertTunnelInfo> function inserts file names
            in a tunnelling table. These entries are considered
            useful only for STALE_TUNNEL_INFO seconds. Tunnelling is
            used to retain LPOTHERINFO for files that get renamed/deleted
            and some other file is renamed to it. This typically done
            by editors, spreadsheets and such while saving things.

    @parm    HSHADOW | hDir | Directory to which this guy belongs
    @parm    LPPE | lppe | PathELement for the file to be tunnelled
    @parm    LPOTHERINFO | lpOI | Info to be kept with the tunnelled entry

    @comm    >>comment_text, <p parm> etc...

    @rdesc This function returns TRUE if successful. Otherwise the
        return value is FALSE.
    @xref    >><f related_func>, <t RELATEDSTRUCT> ...
*/


BOOL InsertTunnelInfo(
    HSHADOW      hDir,
    USHORT       *lpcFileName,
    USHORT       *lpcAlternateFileName,  // assume 14 USHORTs
    LPOTHERINFO lpOI
    )
{
    int i, iHole = -1;
    ULONG uTime = IFSMgr_Get_NetTime(), cbFileName;

    cbFileName = (wstrlen(lpcFileName)+1)*sizeof(USHORT);
    ASSERT(hDir!=0);

    FreeStaleEntries();
    for (i=0;i< (sizeof(rgsTunnel)/sizeof(SH_TUNNEL)); ++i)
    {
        if (!rgsTunnel[i].hDir && (iHole < 0))
        {
            iHole = i;
        }
        if ((rgsTunnel[i].hDir==hDir)
            && (!wstrnicmp(lpcFileName, rgsTunnel[i].lpcFileName, MAX_PATH*sizeof(USHORT))||
                !wstrnicmp( lpcFileName,
                            rgsTunnel[i].cAlternateFileName,
                            sizeof(rgsTunnel[i].cAlternateFileName)))
            ) {
            FreeEntry(&rgsTunnel[i]);
            iHole = i;
            break;
        }
    }
    if (iHole >=0)
    {
        if (!(rgsTunnel[iHole].lpcFileName = (USHORT *)AllocMem(cbFileName)))
            {
                return (FALSE);
            }
            rgsTunnel[iHole].uTime = uTime;
            rgsTunnel[iHole].hDir = hDir;
            rgsTunnel[iHole].ubHintFlags = (UCHAR)(lpOI->ulHintFlags);
            rgsTunnel[iHole].ubHintPri = (UCHAR)(lpOI->ulHintPri);
            rgsTunnel[iHole].ubIHPri = (UCHAR)(lpOI->ulIHPri);
            rgsTunnel[iHole].ubRefPri = (UCHAR)(lpOI->ulRefPri);

            // copy without the NULL, we know that allocmem will have a NULL at the end
            memcpy(rgsTunnel[iHole].lpcFileName, lpcFileName, cbFileName-sizeof(USHORT));

            // assumes 14 USHORTS
            memcpy(    rgsTunnel[iHole].cAlternateFileName,
                    lpcAlternateFileName,
                    sizeof(rgsTunnel[iHole].cAlternateFileName));

            HookCmmnKdPrint(TUNNELING,("InsertTunnelInfo: Inserting %ws/%ws, Hintpri=%d, HintFlags=%d RefPri=%d \r\n",
                    lpcFileName,lpcAlternateFileName,
                    lpOI->ulHintPri,
                    lpOI->ulHintFlags,
                    lpOI->ulRefPri
                    ));

            return (TRUE);
    }
    return (FALSE);
}

/*+-------------------------------------------------------------------------*/
/*    @doc    INTERNAL HOOK
    @func    BOOL | RetrieveTunnelInfo | 2.0

            The <f RetrieveTunnelInfo> function returns to the caller
            OTHERINFO structure containing priorities and such about
            files which have been recently renamed or deleted. Entries
            which are older than STALE_TUNNEL_INFO seconds are thrown
            out.

    @parm    HSHADOW | hDir | Directory to which this guy belongs
    @parm    ushort *| lpcFileName| name of the file whose info is needed
    @parm    LPOTHERINFO | lpOI | Info to be retrieved from the tunnelled entry

    @comm    >>comment_text, <p parm> etc...

    @rdesc This function returns TRUE if successful. Otherwise the
        return value is FALSE.
    @xref    >><f related_func>, <t RELATEDSTRUCT> ...
*/


#ifndef MRXSMB_BUILD_FOR_CSC_DCON
BOOL RetrieveTunnelInfo(
#else
RETRIEVE_TUNNEL_INFO_RETURNS
RetrieveTunnelInfo(
#endif
    HSHADOW  hDir,
    USHORT    *lpcFileName,
    WIN32_FIND_DATA    *lpFind32,    // if NULL, get only otherinfo
    LPOTHERINFO lpOI
    )
{
    int i;
#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    RETRIEVE_TUNNEL_INFO_RETURNS RetVal;
#endif

    ASSERT(hDir!=0);
    FreeStaleEntries();
    for (i=0;i< (sizeof(rgsTunnel)/sizeof(SH_TUNNEL)); ++i)
    {
#ifndef MRXSMB_BUILD_FOR_CSC_DCON
        if (rgsTunnel[i].hDir
            && (!wstrnicmp(lpcFileName, rgsTunnel[i].lpcFileName, MAX_PATH*sizeof(USHORT))||
                !wstrnicmp(    lpcFileName,
                            rgsTunnel[i].cAlternateFileName,
                            sizeof(rgsTunnel[i].cAlternateFileName)))
            ) {
#else
        if (rgsTunnel[i].hDir==hDir)
        {
            if (!wstrnicmp(lpcFileName,
                          rgsTunnel[i].cAlternateFileName,
                          sizeof(rgsTunnel[i].cAlternateFileName)) ) {
                RetVal = TUNNEL_RET_SHORTNAME_TUNNEL;
            } else if ( !wstrnicmp(lpcFileName, rgsTunnel[i].lpcFileName, MAX_PATH*sizeof(USHORT))  ){
                RetVal = TUNNEL_RET_LONGNAME_TUNNEL;
            } else {
                continue;
            }

#endif
            InitOtherInfo(lpOI);

            lpOI->ulHintFlags = (ULONG)(rgsTunnel[i].ubHintFlags);
            lpOI->ulHintPri = (ULONG)(rgsTunnel[i].ubHintPri);
            lpOI->ulIHPri = (ULONG)(rgsTunnel[i].ubIHPri);

// don't copy the reference priority, it is assigned by the record manager
//            lpOI->ulRefPri = (ULONG)(rgsTunnel[i].ubRefPri);

            HookCmmnKdPrint(TUNNELING,("RetrieveTunnelInfo: %ws found, Hintpri=%d, HintFlags=%d RefPri=%d \r\n",
                    lpcFileName,
                    lpOI->ulHintPri,
                    lpOI->ulHintFlags,
                    lpOI->ulRefPri
                    ));

            if (lpFind32)
            {
                memcpy( lpFind32->cFileName,
                        rgsTunnel[i].lpcFileName,
                        (wstrlen(rgsTunnel[i].lpcFileName)+1)*sizeof(USHORT)
                        );
                memcpy( lpFind32->cAlternateFileName,
                        rgsTunnel[i].cAlternateFileName,
                        sizeof(rgsTunnel[i].cAlternateFileName)
                        );
                HookCmmnKdPrint(TUNNELING,("Recovered LFN %ws/%ws \r\n",
                                          lpFind32->cFileName,
                                          lpFind32->cAlternateFileName));
            }

            FreeEntry(&rgsTunnel[i]);
#ifndef MRXSMB_BUILD_FOR_CSC_DCON
            return (TRUE);
        }
    }
    return (FALSE);
#else
            return (RetVal);
        }
    }
    return (TUNNEL_RET_NOTFOUND);
#endif
}

VOID  FreeStaleEntries()
{
    int i;
    ULONG uTime = IFSMgr_Get_NetTime();

    for (i=0;i< (sizeof(rgsTunnel)/sizeof(SH_TUNNEL)); ++i)
    {
        if (rgsTunnel[i].lpcFileName
            && ((uTime- rgsTunnel[i].uTime)>STALE_TUNNEL_INFO))
        {
            FreeEntry(&rgsTunnel[i]);
        }
    }

}

void FreeEntry(LPSH_TUNNEL lpshTunnel)
{
    FreeMem(lpshTunnel->lpcFileName);
    memset(lpshTunnel, 0, sizeof(SH_TUNNEL));
}

//got this from hook.c...not the same because w95 looks at the
//resource flags directly
BOOL IsShadowVisible(
#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    BOOLEAN Disconnected,
#else
    PRESOURCE    pResource,
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON
    DWORD         dwAttr,
    ULONG     uShadowStatus
    )
{
    BOOL fVisible = 1;

    // To a filesystem API the shadow is never visible when it is marked
    // as being deleted

    if (mShadowDeleted(uShadowStatus))
        return (0);

#ifdef MRXSMB_BUILD_FOR_CSC_DCON
    if (Disconnected)
#else
    if (mIsDisconnected(pResource))
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON
    {
        if (IsFile(dwAttr))
        {
#ifdef OFFLINE
#ifdef CSC_RECORDMANAGER_WINNT
            ASSERT(FALSE);
#endif //ifdef CSC_RECORDMANAGER_WINNT
            if (mIsOfflineConnection(pResource))
            { // offline connection
                if (!mShadowOutofSync(uShadowStatus))
                {
                    fVisible = 0;
                }
            }
            else
#endif //OFFLINE
            {// pure disconnected state
                // ignore sparse files
                if (mShadowSparse(uShadowStatus))
                {
                    fVisible = 0;
                }
            }
        }
    }
    else
    {  // connected state, bypass all out of ssync files, doesn't include
            // stale, because we can handle staleness during open
        if (IsFile(dwAttr))
        {
            if (mShadowOutofSync(uShadowStatus))
            {
                fVisible = 0;
            }
        }
        else if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        { // and locallycreated or orphaned directories
            if (mQueryBits(uShadowStatus, SHADOW_LOCALLY_CREATED|SHADOW_ORPHAN))
            {
                fVisible = 0;
            }
        }
    }
    return (fVisible);
}


//got this from hook.c...not the same because w95 looks at the
//resource flags directly


//CODE.IMPROVEMENT we should define a common header for RESOURCE and FDB so that most stuff
//   would just work.
int MarkShareDirty(
    PUSHORT ShareStatus,
    ULONG  hShare
    )
{

    if (!mQueryBits(*ShareStatus, SHARE_REINT))
    {
        SetShareStatus(hShare, SHARE_REINT, SHADOW_FLAGS_OR);
        mSetBits(*ShareStatus, SHARE_REINT);
    }
    return SRET_OK;
}

#endif //ifdef CSC_RECORDMANAGER_WINNT

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\defs.h ===
#ifndef BASETYPES
#define BASETYPES
typedef long   LONG;
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PCHAR;
// typedef void   VOID;
#endif  /* !BASETYPES */

#define MAX_PATH          260

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#undef far
#undef near
#undef pascal

#define far
#define near
#if (_MSC_VER >= 800)
#define pascal __stdcall
#else
#define pascal
#endif

#ifdef DOSWIN32
#define cdecl _cdecl
#ifndef CDECL
#define CDECL _cdecl
#endif
#else
#define cdecl
#ifndef CDECL
#define CDECL
#endif
#endif

#if (_MSC_VER >= 800)
#define CALLBACK    __stdcall
#define WINAPI      __stdcall
#define WINAPIV     __cdecl
#define APIENTRY    WINAPI
#define APIPRIVATE  __stdcall
// #define PASCAL      __stdcall
#else
#define CALLBACK
#define WINAPI
#define WINAPIV
#define APIENTRY    WINAPI
#define APIPRIVATE
#define PASCAL      pascal
#endif

#define NEAR                near
#ifndef CONST
#define CONST               const
#endif

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL near           *PBOOL;
typedef BOOL far            *LPBOOL;
typedef BYTE near           *PBYTE;
typedef BYTE far            *LPBYTE;
typedef int near            *PINT;
typedef int far             *LPINT;
typedef WORD near           *PWORD;
typedef WORD far            *LPWORD;
typedef long far            *LPLONG;
typedef DWORD near          *PDWORD;
typedef DWORD far           *LPDWORD;
typedef void far            *LPVOID, *PVOID;
typedef CONST void far      *LPCVOID;
typedef  char  far          *LPSZ, *LPSTR, *LPCHAR;
typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\csc\record.mgr\csc_bmpk.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    csc_bmpk.c

Abstract:

    This module implements the kernel mode utility functions of
    bitmaps associated with CSC files. CSC_BMP is an opaque
    structure. Must use the functions here to create/modify/destroy a
    CSC_BMP to ensure data integrity. The 'k' in the filename means
    "kernel mode."

Author:

    Nigel Choi [t-nigelc]  Sept 3, 1999

--*/

#include "precomp.h"
#include "csc_bmpk.h"

#if defined(BITCOPY)

LPSTR CscBmpAltStrmName = STRMNAME; /* used to append to file names */

#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//
#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

//csc_bmp dbgprint interface
#ifdef DEBUG
#define CscBmpKdPrint(__bit,__x) {\
    if (((CSCBMP_KDP_##__bit)==0) || \
    FlagOn(CscBmpKdPrintVector,(CSCBMP_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define CSCBMP_KDP_ALWAYS             0x00000000
#define CSCBMP_KDP_BADERRORS          0x00000001
#define CSCBMP_KDP_IO                 0x00000002
#define CSCBMP_KDP_BITMANIP           0x00000004
#define CSCBMP_KDP_BITCHECK           0x00000008
#define CSCBMP_KDP_BITRANGE           0x00000010
#define CSCBMP_KDP_CREATEDESTROY      0x00000020
#define CSCBMP_KDP_RESIZE             0x00000040
#define CSCBMP_KDP_MUTEX              0x00000080
#define CSCBMP_KDP_READWRITE          0x00000100

#define CSCBMP_KDP_GOOD_DEFAULT (CSCBMP_KDP_BADERRORS)
#define CSCBMP_KDP_ALL 0xFFFFFFFF

// ULONG CscBmpKdPrintVector = CSCBMP_KDP_ALL;
ULONG CscBmpKdPrintVector = CSCBMP_KDP_BADERRORS;
#else
#define CscBmpKdPrint(__bit,__x)  {NOTHING;}
#endif


//
// Internally used functions
//

/*
    findBitRange

    Given a DWORD byte offset of a file and bytes to mark and number 
    of bits in CSC_BITMAP, return the start and end DWORD bit mask
    and index into the DWORD array.
    ** Does not prevent out of bounds. It's the responsibility of caller.
    Returns: last bit to mark.
*/

static DWORD
findBitRange(
    DWORD fileOffset,
    DWORD b2Mark,
    LPDWORD lpstartBitMask,
    LPDWORD lpendBitMask,
    LPDWORD lpstartDWORD,
    LPDWORD lpendDWORD)
{
    DWORD startbit; /* first bit to mark */
    DWORD endbit; /* last bit to mark */
    DWORD DWORDnumbits;
    DWORD all1s = -1;

    startbit = fileOffset/BLOCKSIZE;
    //if (startbit >= ttlNumBits) return FALSE;

    endbit = (fileOffset + b2Mark - 1)/BLOCKSIZE;
    //if (endbit >= ttlNumBits) endbit = ttlNumBits - 1;
    ASSERT(startbit <= endbit);

    DWORDnumbits = 8*sizeof(DWORD); /* sizeof returns size in bytes (8-bits) */

    *lpstartBitMask = all1s << (startbit%DWORDnumbits);
    *lpendBitMask = all1s >> (DWORDnumbits - endbit%DWORDnumbits - 1);
    *lpstartDWORD = startbit/DWORDnumbits;
    *lpendDWORD = endbit/DWORDnumbits;

    CscBmpKdPrint(
        BITRANGE,
        ("fileoffset: %u\tbytes2Mark: %u\n",
         fileOffset, b2Mark));
    CscBmpKdPrint(
        BITRANGE,
        ("startbit: %u\tendbit: %u\tstartDWORD: %u\tendDWORD: %u\n",
         startbit, endbit, *lpstartDWORD, *lpendDWORD));
    CscBmpKdPrint(
        BITRANGE,
        ("startBitMask: 0x%08x\nendBitMask: 0x%08x\n",
         *lpstartBitMask, *lpendBitMask));
    return endbit;
}

/*
    Justification of using FastMutex:

    Although we could implement a single writer/multiple reader
    synchronization mechanism, the overhead involved would not be
    justified for the operation on bitmaps. All of the operations that
    needed the mutex are short, in-memory operations. We instead use a
    simple, fast mutex to allow only one thread to read from/write to
    the lpbitmap being protected at a time.
*/

// ***Note*** check if lpbitmap is NULL before calling
#ifdef DEBUG
void
CscBmpAcquireFastMutex(
    LPCSC_BITMAP lpbitmap)
{
    CscBmpKdPrint(
        MUTEX, 
        ("CscBmpAcquireFastMutex for lpbitmap %x\n", lpbitmap));
    ExAcquireFastMutex(&(lpbitmap->mutex));
}
#else
#define CscBmpAcquireFastMutex(lpbitmap) \
               ExAcquireFastMutex(&((lpbitmap)->mutex));
#endif

// ***Note*** check if lpbitmap is NULL before calling
#ifdef DEBUG
void
CscBmpReleaseFastMutex(
    LPCSC_BITMAP lpbitmap)
{
    CscBmpKdPrint(
        MUTEX, 
        ("CscBmpReleaseFastMutex for lpbitmap %x\n", lpbitmap));
      ExReleaseFastMutex(&(lpbitmap->mutex));
}
#else
#define CscBmpReleaseFastMutex(lpbitmap) \
               ExReleaseFastMutex(&((lpbitmap)->mutex));
#endif

//
// Library Functions
//

/*++

    LPCSC_BITMAP CscBmpCreate()

    Routine Description:

       Creates a bitmap structure according to the filesize passed in. 
       Must use this function to create a CSC_BITMAP structure.

    Arguments:


    Returns:


    Notes:

--*/
LPCSC_BITMAP
CscBmpCreate(
    DWORD filesize)
{
    LPCSC_BITMAP bm;
    DWORD bitmapbytesize;
    DWORD i;

    bm = (LPCSC_BITMAP)RxAllocatePool(NonPagedPool, sizeof(CSC_BITMAP));

    if (bm == NULL)
        goto ERROROUT;

    bm->bitmapsize = filesize/BLOCKSIZE;
    if (filesize % BLOCKSIZE)
        bm->bitmapsize++;
    bm->numDWORD = bm->bitmapsize/(8*sizeof(DWORD));
    if (bm->bitmapsize % (8*sizeof(DWORD)))
        bm->numDWORD++;

    bm->bitmap = NULL;
    bm->valid = TRUE;
    bitmapbytesize = bm->numDWORD*sizeof(DWORD);
    if (bitmapbytesize) {
        bm->bitmap = (LPDWORD)RxAllocatePool(
                                NonPagedPool,
                                bitmapbytesize);
        if (bm->bitmap == NULL) {
            RxFreePool(bm);
            goto ERROROUT;
        }
        RtlZeroMemory(bm->bitmap, bitmapbytesize);
    }

    ExInitializeFastMutex(&bm->mutex);

    CscBmpKdPrint(
        CREATEDESTROY,
        ("CscBmpCreate %x: Allocated %u bytes; filesize %u; bitmapsize %u\n",
        bm,
        bitmapbytesize,
        filesize,
        bm->bitmapsize));
    CscBmpKdPrint(
        CREATEDESTROY,
        ("\tbitmap: %x\n", bm->bitmap));
    return bm;

ERROROUT:
    CscBmpKdPrint(
        BADERRORS,
        ("CscBmpCreate: Failed to allocate memory\n"));
    return NULL;
}

/*++

    CscBmpDelete(LPCSC_BITMAP * lplpbitmap)

Routine Description:

    Deletes and free up memory occupied by the bitmap structure.
    Must use this function to delete a CSC_BITMAP structure.
    Note that you have to pass in a pointer to an LPCSC_BITMAP.
    The function sets the LPCSC_BITMAP to NULL for you.

Arguments:


Returns:


Notes:

--*/
VOID
CscBmpDelete(
    LPCSC_BITMAP * lplpbitmap)
{
    if (*lplpbitmap == NULL) {
        CscBmpKdPrint(
            CREATEDESTROY,
            ("CscBmpDelete: no bitmap to delete\n"));
        return;
    }
    CscBmpKdPrint(
        CREATEDESTROY,
        ("CscBmpDelete commence %x bitmapsize: %u\n",
        *lplpbitmap,
        (*lplpbitmap)->bitmapsize));

    // Wait for all operations to get done
    CscBmpAcquireFastMutex(*lplpbitmap);
    CscBmpReleaseFastMutex(*lplpbitmap);

    if ((*lplpbitmap)->bitmap) {
        CscBmpKdPrint(
            CREATEDESTROY,
            ("CscBmpDelete: bitmap: %x\n", (*lplpbitmap)->bitmap));
        RxFreePool((*lplpbitmap)->bitmap);
    }
    RxFreePool(*lplpbitmap);
    *lplpbitmap = NULL;
    CscBmpKdPrint(
        CREATEDESTROY,
        ("CscBmpDelete: Done\n"));
}

/*++

    CscBmpResizeInternal()

Routine Description:

    Resizes a bitmap structure according to the newfilesize.
    Newly allocated bits will be marked. the param fAcquireMutex
    specifies if the mutex in lpbitmap should be acquired or not. If
    called from outside the library it should, as seen in the CscBmpResize
    macro in csc_bmpk.h . But if calling from CscBmpMark or Unmark it should
    not, because the mutex is already acquired before calling this function.
    If bitmap is marked invalid no resize is done.

Arguments:


Returns:

    FALSE if error in memory allocation, or if lpbitmap is NULL.

Notes:

--*/
BOOL
CscBmpResizeInternal(
    LPCSC_BITMAP lpbitmap,
    DWORD newfilesize,
    BOOL fAcquireMutex)
{
    LPDWORD newbitmap;
    DWORD newBitmapSize;
    DWORD newNumDWORD;
    DWORD bitMask;
    DWORD DWORDbits;
    DWORD all1s = -1;
    DWORD i;

    if (lpbitmap == NULL)
        return FALSE;

    if (!lpbitmap->valid) {
        CscBmpKdPrint(RESIZE, ("CscBmpResize: Bitmap marked invalid, done\n"));
        return TRUE;
    }

    DWORDbits = sizeof(DWORD)*8;

    newBitmapSize = newfilesize/BLOCKSIZE;
    if (newfilesize % BLOCKSIZE)
        newBitmapSize++;
    newNumDWORD = newBitmapSize/DWORDbits;
    if (newBitmapSize % DWORDbits)
        newNumDWORD++;

    // note: if new bitmap is smaller, data truncated from the old bitmap
    // will be lost, even if the bitmap is enlarged later on.

    CscBmpKdPrint(RESIZE, ("About to resize:\n"));
    CscBmpKdPrint(RESIZE, ("Old numDWORD = %u\n",lpbitmap->numDWORD));
    CscBmpKdPrint(RESIZE, ("New numDWORD = %u\n", newNumDWORD));
    CscBmpKdPrint(RESIZE, ("Old bitmap size = %u\n", lpbitmap->bitmapsize));
    CscBmpKdPrint(RESIZE, ("New bitmap size = %u\n", newBitmapSize));

    if (fAcquireMutex)
        CscBmpAcquireFastMutex(lpbitmap);

    if (newBitmapSize == lpbitmap->bitmapsize) {
        CscBmpKdPrint(
            RESIZE,
            ("new bitmap size == old bitmap size, no need to resize\n"));
    }

    if (newNumDWORD != lpbitmap->numDWORD) {
        // reallocate array of DWORD
        if (newBitmapSize != 0) {
            newbitmap = (LPDWORD)RxAllocatePool(
                                    NonPagedPool,
                                    newNumDWORD*sizeof(DWORD));
            if (!newbitmap)
                goto ERROROUT;
            ASSERT(newNumDWORD != lpbitmap->numDWORD);

            if (newNumDWORD > lpbitmap->numDWORD) {
                for (i = 0; i < lpbitmap->numDWORD; i++) {
                    newbitmap[i] = lpbitmap->bitmap[i];
            }
            for (i = lpbitmap->numDWORD; i < newNumDWORD; i++) {
                // mark all bits in the new DWORDS
                newbitmap[i] = -1;
            }
        } else {
            for (i = 0; i < newNumDWORD; i++) {
                newbitmap[i] = lpbitmap->bitmap[i];
            }
        }
    } else {
        newbitmap = NULL;
    }

    if (lpbitmap->bitmap) {
        RxFreePool(lpbitmap->bitmap);
    }
    lpbitmap->bitmap = newbitmap;
    CscBmpKdPrint(
        RESIZE,
        ("Reallocated New Bitmap: %x\n", 
        lpbitmap->bitmap));
    } else {
        CscBmpKdPrint(
            RESIZE,
            ("newNumDWORD == lpbitmap->numDWORD, no need to reallocate bitmap\n"));
    }

    if (lpbitmap->bitmap != NULL && lpbitmap->bitmapsize != 0) {
        if (newBitmapSize >= lpbitmap->bitmapsize) {
            // mark all new bits and the last bit in the last DWORD of "old" bitmap
            bitMask = all1s << ( (lpbitmap->bitmapsize%DWORDbits) - 1 );
            lpbitmap->bitmap[lpbitmap->numDWORD-1] |= bitMask;
        } else {
            // mark last bit of the "new" bitmap
            bitMask = all1s << ( (newBitmapSize%DWORDbits) - 1 );
            lpbitmap->bitmap[newNumDWORD-1] |= bitMask;
        }
        CscBmpKdPrint(RESIZE, ("Bitmask = 0x%x\n", bitMask));
        CscBmpKdPrint(RESIZE, ("Last DWORD of new bitmap= 0x%x\n",
        lpbitmap->bitmap[newNumDWORD-1]));
    }

    lpbitmap->bitmapsize = newBitmapSize;
    lpbitmap->numDWORD = newNumDWORD;

    if (fAcquireMutex)
        CscBmpReleaseFastMutex(lpbitmap);

    CscBmpKdPrint(RESIZE, ("Done Resize\n"));
    return TRUE;

ERROROUT:
    CscBmpKdPrint(
        BADERRORS,
        ("CscBmpResize: Failed to allocate memory for new bitmap\n"));
    return FALSE;
}

/*++

    CscBmpMark()

Routine Description:

   Marks the bit(s) in the bitmap according to the fileoffset
   and bytes2Mark. fileoffset is the byte offset into the file
   starting from the beginning of the file. bytes2Mark is the number
   of bytes altered in the file after and including the byte
   indicated by fileoffset. Return FALSE if lpbitmap is NULL.
   If lpbitmap is not valid do nothing and return TRUE.

Arguments:


Returns:


Notes:

--*/
BOOL
CscBmpMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Mark)
{
    DWORD startbitmask;
    DWORD endbitmask;
    DWORD startDWORD;
    DWORD endDWORD;
    DWORD i;

    CscBmpKdPrint(
        BITMANIP,
        ("CscBmpMark: offset: %u bytes2Mark: %u\n",
        fileoffset, bytes2Mark));
    if (lpbitmap == NULL) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMark: null bitmap, done.\n"));
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMark: bitmap marked invalid, done\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    // Extend bitmap if endbit is larger than existing
    if (findBitRange(
            fileoffset,
            bytes2Mark,
            &startbitmask,
            &endbitmask,
            &startDWORD,
            &endDWORD) >= lpbitmap->bitmapsize
    ) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMark: have to resize\n"));
        CscBmpResizeInternal(lpbitmap, fileoffset+bytes2Mark, FALSE);
    }

    ASSERT(startDWORD <= endDWORD);
    if (startDWORD == endDWORD) {
        startbitmask &= endbitmask;
        ASSERT(startbitmask != 0);
        lpbitmap->bitmap[startDWORD] |= startbitmask;
    } else {
        for (i = (startDWORD+1); i < endDWORD; i++) {
            lpbitmap->bitmap[i] = -1; /* mark all */
        }
        lpbitmap->bitmap[startDWORD] |= startbitmask;
        lpbitmap->bitmap[endDWORD] |= endbitmask;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpMark: Done\n"));
    return TRUE;
}

/*++

    CscBmpUnMark()

Routine Description:

    Unmarks the bit(s) in the bitmap according to the fileoffset
    and bytes2Mark. fileoffset is the byte offset into the file
    starting from the beginning of the file. bytes2Unmark is the number
    of bytes altered in the file after and including the byte
    indicated by fileoffset.

Arguments:


Returns:

    Return FALSE if lpbitmap is NULL.

Notes:

--*/
BOOL
CscBmpUnMark(
    LPCSC_BITMAP lpbitmap,
    DWORD fileoffset,
    DWORD bytes2Unmark)
{
    DWORD startbitmask;
    DWORD endbitmask;
    DWORD startDWORD;
    DWORD endDWORD;
    DWORD i;

    CscBmpKdPrint(
        BITMANIP,
        ("CscBmpUnMark: offset: %u bytes2Mark: %u\n",
        fileoffset,
        bytes2Unmark));

    if (lpbitmap == NULL) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: bitmap null. Done.\n"));
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: bitmap marked invalid, done\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    // Extend bitmap if endbit is larger than existing
    if (findBitRange(
            fileoffset,
            bytes2Unmark,
            &startbitmask,
            &endbitmask,
            &startDWORD,
            &endDWORD) >= lpbitmap->bitmapsize
    ) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: have to resize\n"));
        CscBmpResizeInternal(lpbitmap, fileoffset+bytes2Unmark, FALSE);
    }

    ASSERT(startDWORD <= endDWORD);

    startbitmask = ~startbitmask;
    endbitmask = ~endbitmask;

    if (startDWORD == endDWORD) {
        startbitmask |= endbitmask;
        ASSERT(startbitmask != 0);
        lpbitmap->bitmap[startDWORD] &= startbitmask;
    } else {
        for (i = (startDWORD+1); i < endDWORD; i++) {
            lpbitmap->bitmap[i] = 0; /* unmark all */
        }
        lpbitmap->bitmap[startDWORD] &= startbitmask;
        lpbitmap->bitmap[endDWORD] &= endbitmask;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpUnMark: done\n"));
    return TRUE;
}

/*++

    CscBmpMarkAll()

Routine Description:

    Sets all bits in the bitmap to 1s.

Arguments:


Returns:

    FALSE if lpbitmap is NULL.
    TRUE otherwise.

Notes:

--*/
BOOL
CscBmpMarkAll(
    LPCSC_BITMAP lpbitmap)
{
    DWORD i;

    if (!lpbitmap) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMarkAll: bitmap null\n"));
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpMarkAll: bitmap marked invalid\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    for (i = 0; i < lpbitmap->numDWORD; i++) {
        lpbitmap->bitmap[i] = 0xFFFFFFFF;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpMarkAll: done\n"));
    return TRUE;
}

/*++
    CscBmpUnMarkAll()

Routine Description:

    Sets all bits in the bitmap to 0's.

Arguments:


Returns:

    FALSE if lpbitmap is NULL.
    TRUE otherwise.

Notes:

--*/
BOOL
CscBmpUnMarkAll(
    LPCSC_BITMAP lpbitmap)
{
    DWORD i;

    if (!lpbitmap) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMarkAll: bitmap null\n"));    
        return FALSE;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITMANIP, ("CscBmpUnMarkAll: bitmap marked invalid\n"));
        return TRUE;
    }

    CscBmpAcquireFastMutex(lpbitmap);
        for (i = 0; i < lpbitmap->numDWORD; i++) {
        lpbitmap->bitmap[i] = 0;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    CscBmpKdPrint(BITMANIP, ("CscBmpUnMarkAll: done\n"));
    return TRUE;
}

/*++

    CscBmpIsMarked()

Routine Description:

    Check if bitoffset'th bit in bitmap is marked. 

Arguments:


Returns:

    TRUE if marked
    FALSE if unmarked
        -1 if lpbitmap is NULL, or
            bitoffset is larger than the size of the bitmap, or
            bitmap is marked invalid

Notes:

    To translate from actual fileoffset to bitoffset, use
    fileoffset/CscBmpGetBlockSize();

--*/
int
CscBmpIsMarked(
    LPCSC_BITMAP lpbitmap, DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;
    BOOL ret;

    if (lpbitmap == NULL) {
        CscBmpKdPrint(BITCHECK, ("CscBmpIsMarked: bitmap null\n"));
        return -1;
    }

    if (!lpbitmap->valid) {
        CscBmpKdPrint(BITCHECK, ("CscBmpIsMarked: bitmap is marked invalid\n"));
        return -1;
    }

    CscBmpAcquireFastMutex(lpbitmap);
    if (bitoffset >= lpbitmap->bitmapsize) {
        CscBmpKdPrint(
            BITCHECK,
            ("CscBmpIsMarked: bitoffset %u too big\n",
            bitoffset));
        CscBmpReleaseFastMutex(lpbitmap);
        return -1;
    }

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    CscBmpKdPrint(
        BITCHECK,
        ("CscBmpIsMarked: bitoffset %u is "));
    if (lpbitmap->bitmap[DWORDnum] & bitpos) {
        CscBmpKdPrint(BITCHECK, ("marked\n"));
        ret = TRUE;
    } else {
        CscBmpKdPrint(BITCHECK, ("unmarked\n"));
        ret = FALSE;
    }
    CscBmpReleaseFastMutex(lpbitmap);
    return ret;
}

/*++

    CscBmpMarkInvalid()

Routine Description:

    Marks the bitmap invalid.

Arguments:

Returns:

    TRUE successful
    FALSE if lpbitmap is NULL

Notes:

--*/
int
CscBmpMarkInvalid(
    LPCSC_BITMAP lpbitmap)
{
    if (lpbitmap == NULL)
        return FALSE;

    lpbitmap->valid = FALSE;
    return TRUE;
}

/*++

    CscBmpGetBlockSize()

Routine Description:

    returns the pre-defined block size represented by 1 bit in the bitmap.

Arguments:

Returns:

Notes:

--*/
DWORD
CscBmpGetBlockSize()
{
  return BLOCKSIZE;
}

/*++

    CscBmpGetSize()

Routine Description:

    returns the bitmap size of the bitmap. if lpbitmap is NULL, return -1.

Arguments:

Returns:

Notes:

--*/
int
CscBmpGetSize(
    LPCSC_BITMAP lpbitmap)
{
    int ret;
    if (lpbitmap == NULL)
        return -1;

    CscBmpAcquireFastMutex(lpbitmap);
    ret = lpbitmap->bitmapsize;
    CscBmpReleaseFastMutex(lpbitmap);

    return ret;
}

/*++

    CscBmpRead()

Routine Description:

    For the bitmap file format, see csc_bmpc.c

    Reads the bitmap from the given strmFname. If file does not exist,
    create the bitmap file. Set the bitmap file into used state. One
    bitmap file can only be Read once before it is written back. Use
    file:stream format for strmFname.

    *** Remember to issue CscBmpWrite on the same file to set the bitmap
    *** file back to un-used state. ***

    if *lplpbitmap is NULL, allocate a new bitmap. The size of the
    bitmap is determined by the on-disk bitmap size. If there is no
    on-disk bitmap, the size of the new bitmap will be determined by the
    filesize argument.

    If *lplpbitmap is not NULL, the bitmap will be resized to the
    on-disk bitmap size if an on-disk bitmap exists and that it is
    larger than *lplpbitmap. If the on-disk bitmap does not exist,
    *lplpbitmap will be resize to the parameter filesize if filesize is
    larger than the size of *lplpbitmap. If both on-disk bitmap exists and
    *lplpbitmap is not NULL, the current bitmap will be merged with the
    on-disk bitmap.

    The inuse field of the file is set to TRUE once the file is open, if
    it is not already so. Otherwise, if the inuse field is already TRUE,
    the file is set to invalid since only one in-memory representation
    of the CSC_BMP can exist for one file. During synchronization, if
    the valid field or the inuse field of the file is FALSE, the bitmap
    will not be used during synchronization. The inuse field is set back
    to FALSE at CscBmpWrite (time the file closes).

    *** Note *** Check the legality of the filename before passing it in.
    The function does not check the filename.

Arguments:

    The filesize argument is used only when there are no on-disk
    bitmap. See Description above.

    strmFname is used as is. No stream name is appended. User of this
    function must append the stream name themselves. The stream name
    including the colon is defined as CscBmpAltStrmName.

Returns:

    -1 if lplpbitmap is NULL. 
    FALSE(0) if error in writing.
    1 if everything works well.

Notes:

    CODE.IMPROVEMENT better error code return

--*/
int
CscBmpRead(
    LPCSC_BITMAP *lplpbitmap,
    LPSTR strmFname,
    DWORD filesize)
{
    PNT5CSC_MINIFILEOBJECT miniFileObj;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS Status;
    CscBmpFileHdr hdr;
    DWORD * bmpBuf;
    BOOL createdNew;
    BOOL corruptBmpFile = FALSE;
    DWORD bmpByteSize, i;
    int ret = 1;

    if (lplpbitmap == NULL) {
        CscBmpKdPrint(READWRITE, ("CscBmpRead: lplpbitmap == NULL\n"));
        return -1;
    }

    CscBmpKdPrint(
        READWRITE,
        ("CscBmpRead commence on lpbitmap %x file %s\n",
         *lplpbitmap, strmFname));

    try {
        miniFileObj = __Nt5CscCreateFile(NULL,
                          strmFname,
                          FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                          FILE_OPEN, // Create Disposition
                          0, // No Share Access 
                          FILE_READ_DATA |
                          FILE_WRITE_DATA|
                          SYNCHRONIZE, // DesiredAccess
                          NULL, // Continuation
                          NULL, FALSE); // Continuation Context

        Status = GetLastErrorLocal();
        CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead status of (open existing ) CreateFile %u\n",
                Status));

        if (miniFileObj != NULL) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead open existing bitmap %s\n", strmFname));
            createdNew = FALSE;
        } else if (Status == ERROR_FILE_NOT_FOUND) {
            // No Bitmap stream exists for the file, create new
            miniFileObj = __Nt5CscCreateFile(
                            NULL,
                            strmFname,
                            FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                            FILE_OPEN_IF, // Create Disposition
                            0, // No Share Access 
                            FILE_READ_DATA|
                            FILE_WRITE_DATA|
                            SYNCHRONIZE, // DesiredAccess
                            NULL, // Continuation
                            NULL, FALSE); // Continuation Context

            Status = GetLastErrorLocal();

            CscBmpKdPrint(
                  READWRITE,
                  ("CscBmpRead status of (create if not existing) %u\n",
                  Status));

            if (miniFileObj != NULL) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead create new bitmap %s\n", strmFname));
                createdNew = TRUE;
            }
        }

        if (miniFileObj == NULL) {
            CscBmpKdPrint(
                BADERRORS,
                ("CscBmpRead: Can't read/create bitmap %s\n",
                strmFname));
            goto DONE;
        }

        if (*lplpbitmap && !((*lplpbitmap)->valid)) {
            corruptBmpFile = TRUE;
            goto WRITEHDR;
        }

        if (!createdNew) {
            // Read the file header
            Nt5CscReadWriteFileEx(
                R0_READFILE,
                (CSCHFILE)miniFileObj,
                0, // pos
                &hdr,
                sizeof(CscBmpFileHdr),
                0, // Flags
                &ioStatusBlock);

            if (ioStatusBlock.Status != STATUS_SUCCESS) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: Can't read header of bitmap file %s,Status\n",
                    strmFname,
                    ioStatusBlock.Status));
                corruptBmpFile = TRUE;
            } else if (ioStatusBlock.Information < sizeof(CscBmpFileHdr)) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: Can't read the whole header from %s,\n",
                    strmFname));
                CscBmpKdPrint(
                    READWRITE,
                    ("\tAssume corrupt bitmap file\n"));
                corruptBmpFile = TRUE;
            } else if (hdr.magicnum != MAGICNUM) {
                CscBmpKdPrint(
                    READWRITE,
                ("CscBmpRead: Magic Number don't match\n"));
                corruptBmpFile = TRUE;
            } else if (hdr.inuse) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: bitmap %s opened before this, mark corrupt\n",
                    strmFname));
                corruptBmpFile = TRUE;
            } else if (!hdr.valid) {
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpRead: on-disk bitmap %s marked corrupt\n",
                    strmFname));
                corruptBmpFile = TRUE;
            }
            if (corruptBmpFile) {
                goto WRITEHDR;
            } else if (hdr.numDWORDs == 0) {
                if (*lplpbitmap == NULL) {
                    // size of on-disk bitmap is 0, and *lplpbitmap does not exist
                    // make a 0-sized lpbitmap
                    *lplpbitmap = CscBmpCreate(0);
                }
            } else {
                // Allocate mem for bmpBuf
                bmpByteSize = hdr.numDWORDs * sizeof(DWORD);
                bmpBuf = (DWORD *)RxAllocatePool(NonPagedPool, bmpByteSize);
                // Read the DWORD arrays into bmpBuf
                Nt5CscReadWriteFileEx(
                    R0_READFILE,
                    (CSCHFILE)miniFileObj,
                    sizeof(hdr), // pos
                    bmpBuf,
                    bmpByteSize,
                    0, // Flags
                    &ioStatusBlock);

                if (ioStatusBlock.Status != STATUS_SUCCESS) {
                    CscBmpKdPrint(
                        READWRITE,
                        ("CscBmpRead: Error reading bitmap %s, Status %u\n",
                        strmFname, ioStatusBlock.Status));
                    corruptBmpFile = TRUE;
                    goto WRITEHDR;
                } else if (ioStatusBlock.Information < bmpByteSize) {
                    CscBmpKdPrint(
                        READWRITE,
                        ("CscBmpRead: bitmap %s read != anticipated size\n",
                        strmFname));
                    corruptBmpFile = TRUE;
                    goto WRITEHDR;
                }

                // Allocate(Create)/Resize *lplpbitmap if necessary according 
                //          to size of *lplpbitmap, or size specified by header,
                //          whichever is bigger.
                if (*lplpbitmap) {
                    CscBmpAcquireFastMutex(*lplpbitmap);
                    // bitmap exists, resize if needed.
                    if ((*lplpbitmap)->bitmapsize < hdr.sizeinbits) {
                        // hdr specifies a bigger size than
                        // current *lplpbitmap size
                        CscBmpResizeInternal(*lplpbitmap,
                        hdr.sizeinbits*BLOCKSIZE,
                        FALSE);
                    }
                    CscBmpReleaseFastMutex(*lplpbitmap);
                } else {
                    // in-memory bitmap does not exist, Create it
                    *lplpbitmap = CscBmpCreate(hdr.sizeinbits*BLOCKSIZE);
                    if (!*lplpbitmap) {
                        goto DONE;
                    }
                }

                // Bitwise OR bmpBuf and (*lplpbitmap)->bitmap
                CscBmpAcquireFastMutex(*lplpbitmap);
                ASSERT((*lplpbitmap)->bitmapsize >= hdr.sizeinbits);
                for (i = 0; i < hdr.numDWORDs; i++) {
                    (*lplpbitmap)->bitmap[i] |= bmpBuf[i];
                }
                CscBmpReleaseFastMutex(*lplpbitmap);
            } // if not corrupt bitmap file
        } else { // if not created new (bitmap file exists)
            // createdNew on-disk bitmap
            // Allocate(Create)/Resize *lplpbitmap if necessary according to
            // filesize passed in, or current *lplpbitmap size, whichever is bigger.
            if (*lplpbitmap) {
                // Resize if needed
                CscBmpAcquireFastMutex(*lplpbitmap);
                if ((*lplpbitmap)->bitmapsize < filesize) {
                  CscBmpResizeInternal(*lplpbitmap, filesize, FALSE);
                }
                CscBmpReleaseFastMutex(*lplpbitmap);
            } else {
                // Create *lplpbitmap according to size information passed in
                *lplpbitmap = CscBmpCreate(filesize);
                if (!*lplpbitmap) {
                  goto DONE;
                }
            }
        }

WRITEHDR:
        // Write Header back to file, indicating:
        //   New sizes, in use, and if corruptBmpFile, invalid.
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpRead: Writing back hdr to %s\n",strmFname));
        hdr.magicnum = MAGICNUM;
        hdr.inuse = (BYTE)TRUE;
        hdr.valid = (BYTE)!corruptBmpFile;
        if (hdr.valid) {
            CscBmpAcquireFastMutex(*lplpbitmap);
            hdr.sizeinbits = (*lplpbitmap)->bitmapsize;
            hdr.numDWORDs = (*lplpbitmap)->numDWORD;
            CscBmpReleaseFastMutex(*lplpbitmap);
        } else {
            hdr.sizeinbits = 0;
            hdr.numDWORDs = 0;
        }
        IF_DEBUG {
            if (corruptBmpFile)
                CscBmpKdPrint(
                    READWRITE,
                    ("CscBmpWrite: On disk bitmap %s invalid\n",
                    strmFname));
        }
        Nt5CscReadWriteFileEx(
            R0_WRITEFILE,
            (CSCHFILE)miniFileObj,
            0, // pos
            &hdr,
            sizeof(hdr),
            0, // Flags
            &ioStatusBlock);
        if (ioStatusBlock.Status != STATUS_SUCCESS) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead: Error writing back hdr file to %s\n",
                strmFname));
        } else if (ioStatusBlock.Information < sizeof(hdr)) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpRead: hdr size written to %s is incorrect\n",
                strmFname));
        }
        // Close miniFileObj
        CloseFileLocal((CSCHFILE)miniFileObj);
DONE:
        NOTHING;
    } finally {
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpRead done on lpbitmap %x file %s\n",
            *lplpbitmap, strmFname));
    }

    return 1;
}

/*++

    CscBmpWrite()

    Routine Description:

        Tries to open the on-disk bitmap. If no on-disk bitmap exists,
        create one that is invalid, then bail out. The bitmap should be
        "Read," leaving a header, before "Write"

        Reads the header first from the Bitmap file. If the on-disk bitmap
        is valid, writes the bitmap to disk and set inuse to FALSE. If the
        on-disk bitmap is not valid, bail out.

        If a NULL lpbitmap is passed in, a size 0 INVALID bitmap is written
        on disk.

        *** Note *** Check the leaglity of the filename before passing it in.
        The function does not check the filename.

    Arguments:

        strmFname is used as is. No stream name is appended. User of this
        function must append the stream name themselves. The stream name
        including the colon is defined as CscBmpAltStrmName.

    Returns:

        FALSE(0) if error in writing.
        1 if everything works well.

    Notes:

--*/

int
CscBmpWrite(
    LPCSC_BITMAP lpbitmap,
    LPSTR strmFname)
{
    PNT5CSC_MINIFILEOBJECT miniFileObj;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS Status;
    CscBmpFileHdr hdr;
    //BOOL createdNew;
    BOOL corruptBmpFile = FALSE;
    DWORD * bmpBuf = NULL;
    DWORD bmpByteSize;
    int iRet = 1;

    CscBmpKdPrint(
        READWRITE,
        ("++++++++++++++CscBmpWrite commence on %s\n", strmFname));

    try {
        miniFileObj = __Nt5CscCreateFile(
                            NULL,
                            strmFname,
                            FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                            FILE_OPEN, // Create Disposition
                            0, // No Share Access 
                            FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE, // DesiredAccess
                            NULL, // Continuation
                            NULL, // Continuation Context
                            FALSE
                        );
        Status = GetLastErrorLocal();
        CscBmpKdPrint(
            READWRITE,
            ("CscBmpWrite status of first (open existing) CreateFile %u\n",
            Status));

        if (miniFileObj != NULL) {
            CscBmpKdPrint(
                READWRITE,
                ("CscBmpWrite open existing bitmap %s\n", strmFname));
            //createdNew = FALSE;
        } else if (Status == ERROR_FILE_NOT_FOUND) {
            corruptBmpFile = TRUE;
            // No Bitmap stream exists for the file, create new
            miniFileObj = __Nt5CscCreateFile(
                                NULL,
                                strmFname,
                                FLAG_CREATE_OSLAYER_OPEN_STRM, // CSCFlags
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_WRITE_THROUGH|FILE_NON_DIRECTORY_FILE,
                         